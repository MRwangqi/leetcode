{
	"titleSlug": "distinct-subsequences",
	"slug": "dong-tai-gui-hua-by-powcai-5",
	"url": "https://leetcode-cn.com/problems/distinct-subsequences/solution/dong-tai-gui-hua-by-powcai-5/",
	"content": "### 思路:\r\n\r\n动态规划\r\n\r\n `dp[i][j]` 代表 `T` 前 `i` 字符串可以由 `S`  `j` 字符串组成最多个数.\r\n\r\n所以动态方程:\r\n\r\n当 `S[j] == T[i]` , ` dp[i][j] = dp[i-1][j-1] + dp[i][j-1]`;\r\n\r\n当 `S[j] != T[i]` , ` dp[i][j] = dp[i][j-1]`\r\n\r\n举个例子,如示例的\r\n\r\n![1561970400084.png](https://pic.leetcode-cn.com/a3a1d30700be05cad2e60666f20ab261e7a04b85ed88b854dd1d8cb484909983-1561970400084.png){:width=\"500\"}\r\n{:align=center}\r\n\r\n对于第一行, `T` 为空,因为空集是所有字符串子集, 所以我们第一行都是 `1` \r\n\r\n对于第一列,  `S` 为空,这样组成 `T` 个数当然为 0` 了\r\n\r\n至于下面如何进行,大家可以通过动态方程,自行模拟一下!\r\n\r\n### 代码:\r\n\r\n```python [1]\r\nclass Solution:\r\n    def numDistinct(self, s: str, t: str) -> int:\r\n        n1 = len(s)\r\n        n2 = len(t)\r\n        dp = [[0] * (n1 + 1) for _ in range(n2 + 1)]\r\n        for j in range(n1 + 1):\r\n            dp[0][j] = 1\r\n        for i in range(1, n2 + 1):\r\n            for j in range(1, n1 + 1):\r\n                if t[i - 1] == s[j - 1]:\r\n                    dp[i][j] = dp[i - 1][j - 1]  + dp[i][j - 1]\r\n                else:\r\n                    dp[i][j] = dp[i][j - 1]\r\n        #print(dp)\r\n        return dp[-1][-1]\r\n```\r\n\r\n\r\n \r\n```java [1]\r\nclass Solution {\r\n    public int numDistinct(String s, String t) {\r\n        int[][] dp = new int[t.length() + 1][s.length() + 1];\r\n        for (int j = 0; j < s.length() + 1; j++) dp[0][j] = 1;\r\n        for (int i = 1; i < t.length() + 1; i++) {\r\n            for (int j = 1; j < s.length() + 1; j++) {\r\n                if (t.charAt(i - 1) == s.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];\r\n                else dp[i][j] = dp[i][j - 1];\r\n            }\r\n        }\r\n        return dp[t.length()][s.length()];\r\n    }\r\n}\r\n```\r\n\r\n"
}