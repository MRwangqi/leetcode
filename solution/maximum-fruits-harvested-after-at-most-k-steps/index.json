{
	"titleSlug": "maximum-fruits-harvested-after-at-most-k-steps",
	"slug": "hen-zhi-guan-de-si-lu-qian-zhui-he-er-fe-sbjv",
	"url": "https://leetcode-cn.com/problems/maximum-fruits-harvested-after-at-most-k-steps/solution/hen-zhi-guan-de-si-lu-qian-zhui-he-er-fe-sbjv/",
	"content": "简单分析一下，发现无非就是线段 `[l, r]` 覆盖了多少水果。\r\n\r\n线段有多少种可能呢？假设人向左走 $y$ 步，然后回到原点，再向右走 $x$ 步，那么区间长度就是：$x + 2y$ ，其中 $x + 2y \\le k$ ，区间表示为 `[startPos - y, startPos + x]` 。\r\n\r\n同理，如果向右走 $y$ 步，然后回到原点，再向左走 $x$ 步，那么区间表示为 `[startPos - x, startPos + y]` 。\r\n\r\n所以我们枚举 `y` 长度就可以把所有最长线段都枚举出来：\r\n```cpp\r\nfor (int x = k; x >= 0; -- x)\r\n{\r\n    int y = (k - x) / 2;\r\n    int l, r;\r\n    // x + 2y = k\r\n    l = startPos - x, r = startPos + y;\r\n    ans = max(线段 [l, r] 覆盖了多少水果, ans)\r\n    // 2y + x = k\r\n    l = startPos - y, r = startPos + x;\r\n    ans = max(线段 [l, r] 覆盖了多少水果, ans)\r\n}\r\n```\r\n\r\n那么，如何求 `线段 [l, r] 覆盖了多少水果` ？\r\n\r\n很容易想到 **前缀和预处理，累加一下各个水果节点数量，然后二分找 `l` 和 `r` 各自对应的水果节点。**\r\n\r\n完整代码如下。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\r\n        int n = fruits.size();\r\n        \r\n        // 前缀和，用于求区间 [l, r] 共有多少水果\r\n        vector<int> sum;\r\n        sum.push_back(0);\r\n        for (int i = 1; i <= n; ++ i)\r\n            sum.push_back(fruits[i - 1][1] + sum[i - 1]);\r\n\r\n        vector<int> pos;\r\n        for (int i = 0; i < n; ++ i)\r\n            pos.push_back(fruits[i][0]);\r\n\r\n        // 枚举可能抵达的区间\r\n        int ans = 0;\r\n        for (int x = k; x >= 0; -- x)\r\n        {\r\n            int y = (k - x) / 2;\r\n            int l, r;\r\n            // x + 2y = k\r\n            l = startPos - x, r = startPos + y;\r\n            auto pl = lower_bound(pos.begin(), pos.end(), l) - pos.begin(), pr = upper_bound(pos.begin(), pos.end(), r) - pos.begin();\r\n            ans = max(ans, sum[pr] - sum[pl]);\r\n            // 2y + x = k\r\n            l = startPos - y, r = startPos + x;\r\n            pl = lower_bound(pos.begin(), pos.end(), l) - pos.begin(), pr = upper_bound(pos.begin(), pos.end(), r) - pos.begin();\r\n            ans = max(ans, sum[pr] - sum[pl]);\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n"
}