{
	"titleSlug": "find-longest-subarray-lcci",
	"slug": "by-xiaowei_algorithm-xt8z",
	"url": "https://leetcode-cn.com/problems/find-longest-subarray-lcci/solution/by-xiaowei_algorithm-xt8z/",
	"content": "![00D035414EC2F328066FA5D32A5F8D60.png](https://pic.leetcode-cn.com/1653904446-ikGIBu-00D035414EC2F328066FA5D32A5F8D60.png)\r\n\r\n\r\n**解题思路：**\r\n\r\n1. 经典前缀和[525. 连续数组](/problems/contiguous-array/)同源了,和[560. 和为 K 的子数组](/problems/subarray-sum-equals-k/)也差不多\r\n2. 用哈希表记录前缀和，需要先放入哨兵\r\n3. 如果哈希表存在当前前缀和，说明找到一组字母和数字等个数的子数组\r\n4. 同时记录长度，已及左右端点\r\n5. 如上图，当一个为`0`时，已经出现了一个符合的子数组，但是哈希表里面没有`0`，我们需放入哨兵\r\n6. 又例如我们找到第二个的`1`在`B`处，说明出现了一组符合的子数组，左端点为 `map.get(sum) + 1`， 右端点为当前索引\r\n\r\n\r\n**代码如下：**\r\n\r\n```java\r\nclass Solution {\r\n    public String[] findLongestSubarray(String[] arr) {\r\n        int n = arr.length;\r\n        int res = 0;\r\n        int sum = 0;\r\n        int left = 0;\r\n        int right = 0;\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        map.put(0, -1);\r\n        for (int i = 0; i < n; i++) {\r\n            if (isDigit(arr[i].charAt(0))) {\r\n                sum--;\r\n            } else {\r\n                sum++;\r\n            }\r\n            if (map.containsKey(sum)) {\r\n                if (res < i - map.get(sum)) {\r\n                    res = i - map.get(sum);\r\n                    left = map.get(sum);\r\n                    right = i;\r\n                }\r\n            } else {\r\n                map.put(sum, i);\r\n            }\r\n        }\r\n        if (right - left == n) {\r\n            return arr;\r\n        }\r\n        String[] ans = new String[right - left];\r\n        int idx = 0;\r\n        for (int i = left + 1; i <= right; i++) {\r\n            ans[idx] = arr[i];\r\n            idx++;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    private boolean isDigit(char c) {\r\n        if (c >= '0' && c <= '9') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n"
}