{
	"titleSlug": "string-compression",
	"slug": "gong-shui-san-xie-shuang-zhi-zhen-yuan-d-bppu",
	"url": "https://leetcode-cn.com/problems/string-compression/solution/gong-shui-san-xie-shuang-zhi-zhen-yuan-d-bppu/",
	"content": "## 双指针\n\n令输入数组 `cs` 长度为 $n$。\n\n使用两个指针 `i` 和 `j` 分别指向「当前处理到的位置」和「答案待插入的位置」：\n\n1. `i` 指针一直往后处理，每次找到字符相同的连续一段 $[i, idx)$，令长度为 $cnt$；\n2. 将当前字符插入到答案，并让 `j` 指针后移：`cs[j++] = cs[i]`；\n3. 检查长度 $cnt$ 是否大于 $1$，如果大于 $1$，需要将数字拆分存储。由于简单的实现中，我们只能从个位开始处理 $cnt$，因此需要使用 `start` 和 `end` 记录下存储数字的部分，再处理完 $cnt$ 后，将 $[start, end)$ 部分进行翻转，并更新 `j` 指针；\n4. 更新 `i` 为 `idx`，代表循环处理下一字符。\n\n代码：\n```Java []\nclass Solution {\n    public int compress(char[] cs) {\n        int n = cs.length;\n        int i = 0, j = 0;\n        while (i < n) {\n            int idx = i;\n            while (idx < n && cs[idx] == cs[i]) idx++;\n            int cnt = idx - i;\n            cs[j++] = cs[i];\n            if (cnt > 1) {\n                int start = j, end = start;\n                while (cnt != 0) {\n                    cs[end++] = (char)((cnt % 10) + '0');\n                    cnt /= 10;\n                }\n                reverse(cs, start, end - 1);\n                j = end;\n            }\n            i = idx;\n        }\n        return j;\n    }\n    void reverse(char[] cs, int start, int end) {\n        while (start < end) {\n            char t = cs[start];\n            cs[start] = cs[end];\n            cs[end] = t;\n            start++; end--;\n        }\n    }\n}\n```\n* 时间复杂度：$O(n)$\n* 空间复杂度：$O(1)$\n\n---\n\n## 最后\n\n**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ (\"▔□▔)/**\n\n也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png)（公主号后台回复「送书」即可参与长期看题解学算法送实体书活动）或 加入[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。\n\n所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~ "
}