{
	"titleSlug": "bulb-switcher-ii",
	"slug": "deng-pao-kai-guan-ii-by-leetcode-solutio-he7o",
	"url": "https://leetcode-cn.com/problems/bulb-switcher-ii/solution/deng-pao-kai-guan-ii-by-leetcode-solutio-he7o/",
	"content": "#### 方法一：降低搜索空间\n\n**思路**\n\n如果不进行任何优化进行搜索，需要按 $\\textit{presses}$ 次，每次有 $4$ 种选择，那么一共有 $4^\\textit{presses}$ 种按动选择，每种选择消耗 $O(n)$ 时间计算状态，则最终的时间复杂度为 $O(n \\times 4^\\textit{presses})$。经过思考，可以从以下角度降低搜索空间。\n\n首先，不需要考虑按钮按动的顺序，而只需要考虑每个按钮被按了几次，在按钮按动次数一样的情况下，顺序不影响灯泡最后的状态。更进一步地，不需要考虑每个按钮具体被按了几次，而只需要考虑被按了奇数次还是偶数次即可，某个键每多按或少按 $2$ 次及其倍数次，也不影响最后的状态。\n\n其次，观察每个按钮的效果，可以发现所有按钮可以根据编号划分为以下 $4$ 组，周期为 $6$，下列编号中 $k \\geq 0$：\n- 编号为 $6k+1$，受按钮 $1,3,4$ 影响；\n- 编号为 $6k+2, 6k+6$，受按钮 $1,2$ 影响；\n- 编号为 $6k+3, 6k+5$，受按钮 $1,3$ 影响；\n- 编号为 $6k+4$，受按钮 $1,2,4$ 影响。\n\n因此，只需要考虑四个灯泡，即可知道所有灯泡最后的状态了。\n\n编写代码时，可以用一个长度为 $4$ 数组 $\\textit{pressArr}$ 表示 $4$ 个按钮的按动情况。一个整数 $\\textit{status}$ 表示四组灯泡亮灭的状态。最后计算遇到过几种不同的状态即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def flipLights(self, n: int, presses: int) -> int:\n        seen = set()\n        for i in range(2**4):\n            pressArr = [(i >> j) & 1 for j in range(4)]\n            if sum(pressArr) % 2 == presses % 2 and sum(pressArr) <= presses:\n                status = pressArr[0] ^ pressArr[2] ^ pressArr[3]\n                if n >= 2:\n                    status |= (pressArr[0] ^ pressArr[1]) << 1\n                if n >= 3:\n                    status |= (pressArr[0] ^ pressArr[2]) << 2\n                if n >= 4:\n                    status |= (pressArr[0] ^ pressArr[1] ^ pressArr[3]) << 3\n                seen.add(status)\n        return len(seen)\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int flipLights(int n, int presses) {\n        Set<Integer> seen = new HashSet<Integer>();\n        for (int i = 0; i < 1 << 4; i++) {\n            int[] pressArr = new int[4];\n            for (int j = 0; j < 4; j++) {\n                pressArr[j] = (i >> j) & 1;\n            }\n            int sum = Arrays.stream(pressArr).sum();\n            if (sum % 2 == presses % 2 && sum <= presses) {\n                int status = pressArr[0] ^ pressArr[2] ^ pressArr[3];\n                if (n >= 2) {\n                    status |= (pressArr[0] ^ pressArr[1]) << 1;\n                }\n                if (n >= 3) {\n                    status |= (pressArr[0] ^ pressArr[2]) << 2;\n                }\n                if (n >= 4) {\n                    status |= (pressArr[0] ^ pressArr[1] ^ pressArr[3]) << 3;\n                }\n                seen.add(status);\n            }\n        }\n        return seen.size();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FlipLights(int n, int presses) {\n        ISet<int> seen = new HashSet<int>();\n        for (int i = 0; i < 1 << 4; i++) {\n            int[] pressArr = new int[4];\n            for (int j = 0; j < 4; j++) {\n                pressArr[j] = (i >> j) & 1;\n            }\n            int sum = pressArr.Sum();\n            if (sum % 2 == presses % 2 && sum <= presses) {\n                int status = pressArr[0] ^ pressArr[2] ^ pressArr[3];\n                if (n >= 2) {\n                    status |= (pressArr[0] ^ pressArr[1]) << 1;\n                }\n                if (n >= 3) {\n                    status |= (pressArr[0] ^ pressArr[2]) << 2;\n                }\n                if (n >= 4) {\n                    status |= (pressArr[0] ^ pressArr[1] ^ pressArr[3]) << 3;\n                }\n                seen.Add(status);\n            }\n        }\n        return seen.Count;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int flipLights(int n, int presses) {\n        unordered_set<int> seen;\n        for (int i = 0; i < 1 << 4; i++) {\n            vector<int> pressArr(4);\n            for (int j = 0; j < 4; j++) {\n                pressArr[j] = (i >> j) & 1;\n            }\n            int sum = accumulate(pressArr.begin(), pressArr.end(), 0);\n            if (sum % 2 == presses % 2 && sum <= presses) {\n                int status = pressArr[0] ^ pressArr[2] ^ pressArr[3];\n                if (n >= 2) {\n                    status |= (pressArr[0] ^ pressArr[1]) << 1;\n                }\n                if (n >= 3) {\n                    status |= (pressArr[0] ^ pressArr[2]) << 2;\n                }\n                if (n >= 4) {\n                    status |= (pressArr[0] ^ pressArr[1] ^ pressArr[3]) << 3;\n                }\n                seen.emplace(status);\n            }\n        }\n        return seen.size();\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    UT_hash_handle hh;\n} HashItem; \n\nHashItem *hashFindItem(HashItem **obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nbool hashAddItem(HashItem **obj, int key) {\n    if (hashFindItem(obj, key)) {\n        return false;\n    }\n    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = key;\n    HASH_ADD_INT(*obj, key, pEntry);\n    return true;\n}\n\nvoid hashFree(HashItem **obj) {\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);             \n    }\n}\n\nint flipLights(int n, int presses){\n    HashItem *seen = NULL;\n    for (int i = 0; i < 1 << 4; i++) {\n        int pressArr[4], sum = 0;\n        for (int j = 0; j < 4; j++) {\n            pressArr[j] = (i >> j) & 1;\n            sum += pressArr[j];\n        }\n        if (sum % 2 == presses % 2 && sum <= presses) {\n            int status = pressArr[0] ^ pressArr[2] ^ pressArr[3];\n            if (n >= 2) {\n                status |= (pressArr[0] ^ pressArr[1]) << 1;\n            }\n            if (n >= 3) {\n                status |= (pressArr[0] ^ pressArr[2]) << 2;\n            }\n            if (n >= 4) {\n                status |= (pressArr[0] ^ pressArr[1] ^ pressArr[3]) << 3;\n            }\n            hashAddItem(&seen, status);\n        }\n    }\n    int ret = HASH_COUNT(seen);\n    hashFree(&seen);\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar flipLights = function(n, presses) {\n    const seen = new Set();\n    for (let i = 0; i < 1 << 4; i++) {\n        const pressArr = new Array(4).fill(0);\n        for (let j = 0; j < 4; j++) {\n            pressArr[j] = (i >> j) & 1;\n        }\n        const sum = _.sum(pressArr);\n        if (sum % 2 === presses % 2 && sum <= presses) {\n            let status = pressArr[0] ^ pressArr[2] ^ pressArr[3];\n            if (n >= 2) {\n                status |= (pressArr[0] ^ pressArr[1]) << 1;\n            }\n            if (n >= 3) {\n                status |= (pressArr[0] ^ pressArr[2]) << 2;\n            }\n            if (n >= 4) {\n                status |= (pressArr[0] ^ pressArr[1] ^ pressArr[3]) << 3;\n            }\n            seen.add(status);\n        }\n    }\n    return seen.size;\n};\n```\n\n```go [sol1-Golang]\nfunc flipLights(n, presses int) int {\n    seen := map[int]struct{}{}\n    for i := 0; i < 1<<4; i++ {\n        pressArr := [4]int{}\n        sum := 0\n        for j := 0; j < 4; j++ {\n            pressArr[j] = i >> j & 1\n            sum += pressArr[j]\n        }\n        if sum%2 == presses%2 && sum <= presses {\n            status := pressArr[0] ^ pressArr[2] ^ pressArr[3]\n            if n >= 2 {\n                status |= (pressArr[0] ^ pressArr[1]) << 1\n            }\n            if n >= 3 {\n                status |= (pressArr[0] ^ pressArr[2]) << 2\n            }\n            if n >= 4 {\n                status |= (pressArr[0] ^ pressArr[1] ^ pressArr[3]) << 3\n            }\n            seen[status] = struct{}{}\n        }\n    }\n    return len(seen)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$。只需要使用常数时间即可完成计算。\n\n- 空间复杂度：$O(1)$。只需要使用常数空间即可完成计算。"
}