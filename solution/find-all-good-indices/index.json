{
	"titleSlug": "find-all-good-indices",
	"slug": "zhao-dao-suo-you-hao-xia-biao-by-leetcod-w5ar",
	"url": "https://leetcode-cn.com/problems/find-all-good-indices/solution/zhao-dao-suo-you-hao-xia-biao-by-leetcod-w5ar/",
	"content": "#### 方法一：动态规划\n\n**思路**\n\n下标 $i$ 是好下标需满足：下标 $i$ 前连续 $k$ 个元素都是非递增与下标 $i$ 后连续 $k$ 个元素都是非递减。只需要预先计算出下标 $i$ 前元素连续非递增的个数以及下标 $i$ 后元素连续非递减的个数即可判断下标 $i$ 是否为好下标。对于下标 $j$，设下标 $j$ 及之前元素连续非递增的个数为 $\\textit{left}_j$，下标 $j$ 及之后元素连续非递减的个数为 $\\textit{right}_j$。当下标 $i$ 同时满足 $\\textit{left}_{i - 1} \\ge k,\\textit{right}_{i + 1} \\ge k$ 时，下标 $i$ 为好下标。计算连续非递增和非递减的个数的方法如下：\n\n+ 如果下标 $i$ 的元素小于等于下标 $i-1$ 的元素，假设已知下标 $i-1$ 及之前有 $j$ 个元素连续非递增，则此时满足 $\\textit{nums}_{i-1} \\le \\textit{nums}_{i-2} \\cdots \\le \\textit{nums}_{i-j}$，已知 $\\textit{nums}_i \\le \\textit{nums}_{i-1}$，可推出 $\\textit{nums}_{i} \\le \\textit{nums}_{i-1} \\cdots \\le \\textit{nums}_{i-j}$，则此时 $\\textit{left}_i = j + 1 = \\textit{left}_{i-1} + 1$；如果下标 $i$ 的元素大于下标 $i-1$ 的元素，则此时 $\\textit{left}_i = 1$。\n\n+ 如果下标 $i$ 的元素小于等于下标 $i+1$ 的元素，假设已知下标 $i+1$ 及之后有 $j$ 个元素连续非递减，则此时满足 $\\textit{nums}_{i+1} \\le \\textit{nums}_{i+2} \\cdots \\le \\textit{nums}_{i+j}$，已知 $\\textit{nums}_i \\le \\textit{nums}_{i+1}$，可推出 $\\textit{nums}_{i} \\le \\textit{nums}_{i+1} \\cdots \\le \\textit{nums}_{i+j}$，则此时 $\\textit{right}_i = j + 1 = \\textit{right}_{i+1} + 1$；如果下标 $i$ 的元素大于下标 $i+1$ 的元素，则此时 $\\textit{right}_i = 1$。\n\n依次检测所有的下标，即可得到所有好下标。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        left = [1] * n\n        right = [1] * n\n        for i in range(1, n):\n            if nums[i] <= nums[i - 1]:\n                left[i] = left[i - 1] + 1\n            if nums[n - i - 1] <= nums[n - i]:\n                right[n - i - 1] = right[n - i] + 1\n        return [i for i in range(k, n - k) if left[i - 1] >= k and right[i + 1] >= k]\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> goodIndices(int[] nums, int k) {\n        int n = nums.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Arrays.fill(left, 1);\n        Arrays.fill(right, 1);\n        for (int i = 1; i < n; i++) {\n            if (nums[i] <= nums[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n            if (nums[n - i - 1] <= nums[n - i]) {\n                right[n - i - 1] = right[n - i] + 1;\n            }\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i = k; i < n - k; i++) {\n            if (left[i - 1] >= k && right[i + 1] >= k) {\n                ans.add(i);    \n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> goodIndices(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> left(n, 1);\n        vector<int> right(n, 1);\n        for (int i = 1; i < n; i++) {\n            if (nums[i] <= nums[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n            if (nums[n - i - 1] <= nums[n - i]) {\n                right[n - i - 1] = right[n - i] + 1;\n            }\n        }\n\n        vector<int> ans;\n        for (int i = k; i < n - k; i++) {\n            if (left[i - 1] >= k && right[i + 1] >= k) {\n                ans.emplace_back(i);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> GoodIndices(int[] nums, int k) {\n        int n = nums.Length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Array.Fill(left, 1);\n        Array.Fill(right, 1);\n        for (int i = 1; i < n; i++) {\n            if (nums[i] <= nums[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n            if (nums[n - i - 1] <= nums[n - i]) {\n                right[n - i - 1] = right[n - i] + 1;\n            }\n        }\n\n        IList<int> ans = new List<int>();\n        for (int i = k; i < n - k; i++) {\n            if (left[i - 1] >= k && right[i + 1] >= k) {\n                ans.Add(i);    \n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\nint* goodIndices(int* nums, int numsSize, int k, int* returnSize) {\n    int * left = (int *)malloc(sizeof(int) * numsSize);\n    int * right = (int *)malloc(sizeof(int) * numsSize);\n    memset(left, 0, sizeof(int) * numsSize);\n    memset(right, 0, sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        left[i] = right[i] = 1;\n    }\n    for (int i = 1; i < numsSize; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            left[i] = left[i - 1] + 1;\n        }\n        if (nums[numsSize - i - 1] <= nums[numsSize - i]) {\n            right[numsSize - i - 1] = right[numsSize - i] + 1;\n        }\n    }\n\n    int * ans = (int *)malloc(sizeof(int) * numsSize);\n    int pos = 0;\n    for (int i = k; i < numsSize - k; i++) {\n        if (left[i - 1] >= k && right[i + 1] >= k) {\n            ans[pos++] = i;\n        }\n    }\n    free(left);\n    free(right);\n    *returnSize = pos;\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar goodIndices = function(nums, k) {\n    const n = nums.length;\n    const left = new Array(n).fill(1);\n    const right = new Array(n).fill(1);\n    for (let i = 1; i < n; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            left[i] = left[i - 1] + 1;\n        }\n        if (nums[n - i - 1] <= nums[n - i]) {\n            right[n - i - 1] = right[n - i] + 1;\n        }\n    }\n\n    const ans = [];\n    for (let i = k; i < n - k; i++) {\n        if (left[i - 1] >= k && right[i + 1] >= k) {\n            ans.push(i);    \n        }\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc goodIndices(nums []int, k int) (ans []int) {\n    n := len(nums)\n    left := make([]int, n)\n    right := make([]int, n)\n    for i := 0; i < n; i++ {\n        left[i] = 1\n        right[i] = 1\n    }\n    for i := 1; i < n; i++ {\n        if nums[i] <= nums[i-1] {\n            left[i] = left[i-1] + 1\n        }\n        if nums[n-i-1] <= nums[n-i] {\n            right[n-i-1] = right[n-i] + 1\n        }\n    }\n\n    for i := k; i < n-k; i++ {\n        if left[i-1] >= k && right[i+1] >= k {\n            ans = append(ans, i)\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度。需要遍历数组求出下标 $i$ 及之前连续非递增的个数与下标 $i$ 及之后连续非递减的个数，然后再遍历数组检测下标 $i$ 是否为好下标。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度。需要 $O(n)$ 的空间来存储下标 $i$ 及之前连续非递增的个数与下标 $i$ 及之后连续非递减的个数。"
}