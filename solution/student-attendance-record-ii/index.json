{
	"titleSlug": "student-attendance-record-ii",
	"slug": "xue-sheng-chu-qin-ji-lu-ii-by-leetcode-s-kdlm",
	"url": "https://leetcode-cn.com/problems/student-attendance-record-ii/solution/xue-sheng-chu-qin-ji-lu-ii-by-leetcode-s-kdlm/",
	"content": "#### 方法一：动态规划\n\n可以使用动态规划计算可奖励的出勤记录的数量。\n\n由于可奖励的出勤记录要求缺勤次数少于 $2$ 和连续迟到次数少于 $3$，因此动态规划的状态由总天数、缺勤次数和结尾连续迟到次数决定（由于不会记录连续迟到次数等于或多于 $3$ 的情况，因此非结尾的连续迟到次数一定少于 $3$，只需要记录结尾连续迟到次数即可）。\n\n定义 $\\textit{dp}[i][j][k]$ 表示前 $i$ 天有 $j$ 个 $\\text{`A'}$ 且结尾有连续 $k$ 个 $\\text{`L'}$ 的可奖励的出勤记录的数量，其中 $0 \\le i \\le n$，$0 \\le j \\le 1$，$0 \\le k \\le 2$。\n\n当 $i=0$ 时，没有任何出勤记录，此时 $\\text{`A'}$ 的数量和结尾连续 $\\text{`L'}$ 的数量一定是 $0$，因此动态规划的边界情况是 $\\textit{dp}[0][0][0] = 1$。\n\n当 $1 \\le i \\le n$ 时，$\\textit{dp}[i][][]$ 的值从 $\\textit{dp}[i-1][][]$ 的值转移得到，计算每个状态的值需要考虑第 $i$ 天的出勤记录：\n\n- 如果第 $i$ 天的出勤记录是 $\\text{`P'}$，则前 $i$ 天和前 $i-1$ 天的出勤记录相比，$\\text{`A'}$ 的数量不变，结尾连续 $\\text{`L'}$ 的数量清零，因此对 $0 \\le j \\le 1$，有\n\n$$\n\\textit{dp}[i][j][0] := \\textit{dp}[i][j][0] + \\sum_{k=0}^2 \\textit{dp}[i-1][j][k]\n$$\n\n- 如果第 $i$ 天的出勤记录是 $\\text{`A'}$，则前 $i$ 天和前 $i-1$ 天的出勤记录相比，$\\text{`A'}$ 的数量加 $1$，结尾连续 $\\text{`L'}$ 的数量清零，此时要求前 $i-1$ 天的出勤记录记录中的 $\\text{`A'}$ 的数量必须为 $0$，否则前 $i$ 天的出勤记录至少有 $2$ 个 $\\text{`A'}$，不满足可奖励的条件，因此有\n\n$$\n\\textit{dp}[i][1][0] := \\textit{dp}[i][1][0] + \\sum_{k=0}^2 \\textit{dp}[i-1][0][k]\n$$\n\n- 如果第 $i$ 天的出勤记录是 $\\text{`L'}$，则前 $i$ 天和前 $i-1$ 天的出勤记录相比，$\\text{`A'}$ 的数量不变，结尾连续 $\\text{`L'}$ 的数量加 $1$，此时要求前 $i-1$ 天的出勤记录记录中的结尾连续 $\\text{`L'}$ 的数量不超过 $1$，否则前 $i$ 天的出勤记录的结尾至少有 $3$ 个 $\\text{`L'}$，不满足可奖励的条件，因此对 $0 \\le j \\le 1$ 和 $1 \\le k \\le 2$，有\n\n$$\n\\textit{dp}[i][j][k] := \\textit{dp}[i][j][k] + \\textit{dp}[i-1][j][k-1]\n$$\n\n上述状态转移方程对于 $i=1$ 也适用。\n\n计算长度为 $n$ 的所有可奖励的出勤记录的数量，即为计算 $\\textit{dp}[n][][]$ 的所有元素之和。计算过程中需要将结果对 $10^9+7$ 取模。\n\n根据上述思路，可以得到时间复杂度和空间复杂度都是 $O(n)$ 的实现。\n\n```Java [sol11-Java]\nclass Solution {\n    public int checkRecord(int n) {\n        final int MOD = 1000000007;\n        int[][][] dp = new int[n + 1][2][3]; // 长度，A 的数量，结尾连续 L 的数量\n        dp[0][0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            // 以 P 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 0; k <= 2; k++) {\n                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD;\n                }\n            }\n            // 以 A 结尾的数量\n            for (int k = 0; k <= 2; k++) {\n                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD;\n            }\n            // 以 L 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 1; k <= 2; k++) {\n                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD;\n                }\n            }\n        }\n        int sum = 0;\n        for (int j = 0; j <= 1; j++) {\n            for (int k = 0; k <= 2; k++) {\n                sum = (sum + dp[n][j][k]) % MOD;\n            }\n        }\n        return sum;\n    }\n}\n```\n\n```C# [sol11-C#]\npublic class Solution {\n    public int CheckRecord(int n) {\n        const int MOD = 1000000007;\n        int[,,] dp = new int[n + 1, 2, 3]; // 长度，A 的数量，结尾连续 L 的数量\n        dp[0, 0, 0] = 1;\n        for (int i = 1; i <= n; i++) {\n            // 以 P 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 0; k <= 2; k++) {\n                    dp[i, j, 0] = (dp[i, j, 0] + dp[i - 1, j, k]) % MOD;\n                }\n            }\n            // 以 A 结尾的数量\n            for (int k = 0; k <= 2; k++) {\n                dp[i, 1, 0] = (dp[i, 1, 0] + dp[i - 1, 0, k]) % MOD;\n            }\n            // 以 L 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 1; k <= 2; k++) {\n                    dp[i, j, k] = (dp[i, j, k] + dp[i - 1, j, k - 1]) % MOD;\n                }\n            }\n        }\n        int sum = 0;\n        for (int j = 0; j <= 1; j++) {\n            for (int k = 0; k <= 2; k++) {\n                sum = (sum + dp[n, j, k]) % MOD;\n            }\n        }\n        return sum;\n    }\n}\n```\n\n```JavaScript [sol11-JavaScript]\nvar checkRecord = function(n) {\n    const MOD = 1000000007;\n    const dp = new Array(n + 1).fill(2).map(() => new Array(2).fill(0).map(() => new Array(3).fill(0))); // 长度，A 的数量，结尾连续 L 的数量\n    dp[0][0][0] = 1;\n    for (let i = 1; i <= n; i++) {\n        // 以 P 结尾的数量\n        for (let j = 0; j <= 1; j++) {\n            for (let k = 0; k <= 2; k++) {\n                dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD;\n            }\n        }\n        // 以 A 结尾的数量\n        for (let k = 0; k <= 2; k++) {\n            dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD;\n        }\n        // 以 L 结尾的数量\n        for (let j = 0; j <= 1; j++) {\n            for (let k = 1; k <= 2; k++) {\n                dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD;\n            }\n        }\n    }\n    let sum = 0;\n    for (let j = 0; j <= 1; j++) {\n        for (let k = 0; k <= 2; k++) {\n            sum = (sum + dp[n][j][k]) % MOD;\n        }\n    }\n    return sum;\n};\n```\n\n```Python [sol11-Python3]\nclass Solution:\n    def checkRecord(self, n: int) -> int:\n        MOD = 10**9 + 7\n        # 长度，A 的数量，结尾连续 L 的数量\n        dp = [[[0, 0, 0], [0, 0, 0]] for _ in range(n + 1)]\n        dp[0][0][0] = 1\n\n        for i in range(1, n + 1):\n            # 以 P 结尾的数量\n            for j in range(0, 2):\n                for k in range(0, 3):\n                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD\n            \n            # 以 A 结尾的数量\n            for k in range(0, 3):\n                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD\n            \n            # 以 L 结尾的数量\n            for j in range(0, 2):\n                for k in range(1, 3):\n                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD\n        \n        total = 0\n        for j in range(0, 2):\n            for k in range(0, 3):\n                total += dp[n][j][k]\n        \n        return total % MOD\n```\n\n```C++ [sol11-C++]\nclass Solution {\npublic:\n    static constexpr int MOD = 1'000'000'007;\n\n    int checkRecord(int n) {\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2, vector<int>(3)));  // 长度，A 的数量，结尾连续 L 的数量\n        dp[0][0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            // 以 P 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 0; k <= 2; k++) {\n                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD;\n                }\n            }\n            // 以 A 结尾的数量\n            for (int k = 0; k <= 2; k++) {\n                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD;\n            }\n            // 以 L 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 1; k <= 2; k++) {\n                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD;\n                }\n            }\n        }\n        int sum = 0;\n        for (int j = 0; j <= 1; j++) {\n            for (int k = 0; k <= 2; k++) {\n                sum = (sum + dp[n][j][k]) % MOD;\n            }\n        }\n        return sum;\n    }\n};\n```\n\n```C [sol11-C]\nconst int MOD = 1000000007;\n\nint checkRecord(int n) {\n    int dp[n + 1][2][3];  // 长度，A 的数量，结尾连续 L 的数量\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        // 以 P 结尾的数量\n        for (int j = 0; j <= 1; j++) {\n            for (int k = 0; k <= 2; k++) {\n                dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD;\n            }\n        }\n        // 以 A 结尾的数量\n        for (int k = 0; k <= 2; k++) {\n            dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD;\n        }\n        // 以 L 结尾的数量\n        for (int j = 0; j <= 1; j++) {\n            for (int k = 1; k <= 2; k++) {\n                dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD;\n            }\n        }\n    }\n    int sum = 0;\n    for (int j = 0; j <= 1; j++) {\n        for (int k = 0; k <= 2; k++) {\n            sum = (sum + dp[n][j][k]) % MOD;\n        }\n    }\n    return sum;\n}\n```\n\n```go [sol11-Golang]\nfunc checkRecord(n int) (ans int) {\n    const mod int = 1e9 + 7\n    dp := make([][2][3]int, n+1) // 三个维度分别表示：长度，A 的数量，结尾连续 L 的数量\n    dp[0][0][0] = 1\n    for i := 1; i <= n; i++ {\n        // 以 P 结尾的数量\n        for j := 0; j <= 1; j++ {\n            for k := 0; k <= 2; k++ {\n                dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][k]) % mod\n            }\n        }\n        // 以 A 结尾的数量\n        for k := 0; k <= 2; k++ {\n            dp[i][1][0] = (dp[i][1][0] + dp[i-1][0][k]) % mod\n        }\n        // 以 L 结尾的数量\n        for j := 0; j <= 1; j++ {\n            for k := 1; k <= 2; k++ {\n                dp[i][j][k] = (dp[i][j][k] + dp[i-1][j][k-1]) % mod\n            }\n        }\n    }\n    for j := 0; j <= 1; j++ {\n        for k := 0; k <= 2; k++ {\n            ans = (ans + dp[n][j][k]) % mod\n        }\n    }\n    return ans\n}\n```\n\n注意到 $\\textit{dp}[i][][]$ 只会从 $\\textit{dp}[i-1][][]$ 转移得到。因此可以将 $\\textit{dp}$ 中的总天数的维度省略，将空间复杂度优化到 $O(1)$。\n\n```Java [sol12-Java]\nclass Solution {\n    public int checkRecord(int n) {\n        final int MOD = 1000000007;\n        int[][] dp = new int[2][3]; // A 的数量，结尾连续 L 的数量\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            int[][] dpNew = new int[2][3];\n            // 以 P 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 0; k <= 2; k++) {\n                    dpNew[j][0] = (dpNew[j][0] + dp[j][k]) % MOD;\n                }\n            }\n            // 以 A 结尾的数量\n            for (int k = 0; k <= 2; k++) {\n                dpNew[1][0] = (dpNew[1][0] + dp[0][k]) % MOD;\n            }\n            // 以 L 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 1; k <= 2; k++) {\n                    dpNew[j][k] = (dpNew[j][k] + dp[j][k - 1]) % MOD;\n                }\n            }\n            dp = dpNew;\n        }\n        int sum = 0;\n        for (int j = 0; j <= 1; j++) {\n            for (int k = 0; k <= 2; k++) {\n                sum = (sum + dp[j][k]) % MOD;\n            }\n        }\n        return sum;\n    }\n}\n```\n\n```C# [sol12-C#]\npublic class Solution {\n    public int CheckRecord(int n) {\n        const int MOD = 1000000007;\n        int[,] dp = new int[2, 3]; // A 的数量，结尾连续 L 的数量\n        dp[0, 0] = 1;\n        for (int i = 1; i <= n; i++) {\n            int[,] dpNew = new int[2, 3];\n            // 以 P 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 0; k <= 2; k++) {\n                    dpNew[j, 0] = (dpNew[j, 0] + dp[j, k]) % MOD;\n                }\n            }\n            // 以 A 结尾的数量\n            for (int k = 0; k <= 2; k++) {\n                dpNew[1, 0] = (dpNew[1, 0] + dp[0, k]) % MOD;\n            }\n            // 以 L 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 1; k <= 2; k++) {\n                    dpNew[j, k] = (dpNew[j, k] + dp[j, k - 1]) % MOD;\n                }\n            }\n            dp = dpNew;\n        }\n        int sum = 0;\n        for (int j = 0; j <= 1; j++) {\n            for (int k = 0; k <= 2; k++) {\n                sum = (sum + dp[j, k]) % MOD;\n            }\n        }\n        return sum;\n    }\n}\n```\n\n```JavaScript [sol12-JavaScript]\nvar checkRecord = function(n) {\n    const MOD = 1000000007;\n    let dp = new Array(2).fill(0).map(() => new Array(3).fill(0)); // A 的数量，结尾连续 L 的数量\n    dp[0][0] = 1;\n    for (let i = 1; i <= n; i++) {\n        const dpNew = new Array(2).fill(0).map(() => new Array(3).fill(0));\n        // 以 P 结尾的数量\n        for (let j = 0; j <= 1; j++) {\n            for (let k = 0; k <= 2; k++) {\n                dpNew[j][0] = (dpNew[j][0] + dp[j][k]) % MOD;\n            }\n        }\n        // 以 A 结尾的数量\n        for (let k = 0; k <= 2; k++) {\n            dpNew[1][0] = (dpNew[1][0] + dp[0][k]) % MOD;\n        }\n        // 以 L 结尾的数量\n        for (let j = 0; j <= 1; j++) {\n            for (let k = 1; k <= 2; k++) {\n                dpNew[j][k] = (dpNew[j][k] + dp[j][k - 1]) % MOD;\n            }\n        }\n        dp = dpNew;\n    }\n    let sum = 0;\n    for (let j = 0; j <= 1; j++) {\n        for (let k = 0; k <= 2; k++) {\n            sum = (sum + dp[j][k]) % MOD;\n        }\n    }\n    return sum;\n};\n```\n\n```Python [sol12-Python3]\nclass Solution:\n    def checkRecord(self, n: int) -> int:\n        MOD = 10**9 + 7\n        # A 的数量，结尾连续 L 的数量\n        dp = [[0, 0, 0], [0, 0, 0]]\n        dp[0][0] = 1\n\n        for i in range(1, n + 1):\n            dpNew = [[0, 0, 0], [0, 0, 0]]\n\n            # 以 P 结尾的数量\n            for j in range(0, 2):\n                for k in range(0, 3):\n                    dpNew[j][0] = (dpNew[j][0] + dp[j][k]) % MOD\n            \n            # 以 A 结尾的数量\n            for k in range(0, 3):\n                dpNew[1][0] = (dpNew[1][0] + dp[0][k]) % MOD\n            \n            # 以 L 结尾的数量\n            for j in range(0, 2):\n                for k in range(1, 3):\n                    dpNew[j][k] = (dpNew[j][k] + dp[j][k - 1]) % MOD\n            \n            dp = dpNew\n        \n        total = 0\n        for j in range(0, 2):\n            for k in range(0, 3):\n                total += dp[j][k]\n        \n        return total % MOD\n```\n\n```C++ [sol12-C++]\nclass Solution {\npublic:\n    static constexpr int MOD = 1'000'000'007;\n\n    int checkRecord(int n) {\n        int dp[2][3];  // A 的数量，结尾连续 L 的数量\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            int dpNew[2][3];  // A 的数量，结尾连续 L 的数量\n            memset(dpNew, 0, sizeof(dpNew));\n            // 以 P 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 0; k <= 2; k++) {\n                    dpNew[j][0] = (dpNew[j][0] + dp[j][k]) % MOD;\n                }\n            }\n            // 以 A 结尾的数量\n            for (int k = 0; k <= 2; k++) {\n                dpNew[1][0] = (dpNew[1][0] + dp[0][k]) % MOD;\n            }\n            // 以 L 结尾的数量\n            for (int j = 0; j <= 1; j++) {\n                for (int k = 1; k <= 2; k++) {\n                    dpNew[j][k] = (dpNew[j][k] + dp[j][k - 1]) % MOD;\n                }\n            }\n            memcpy(dp, dpNew, sizeof(dp));\n        }\n        int sum = 0;\n        for (int j = 0; j <= 1; j++) {\n            for (int k = 0; k <= 2; k++) {\n                sum = (sum + dp[j][k]) % MOD;\n            }\n        }\n        return sum;\n    }\n};\n```\n\n```C [sol12-C]\nconst int MOD = 1000000007;\n\nint checkRecord(int n) {\n    int dp[2][3];  // A 的数量，结尾连续 L 的数量\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        int dpNew[2][3];  // A 的数量，结尾连续 L 的数量\n        memset(dpNew, 0, sizeof(dpNew));\n        // 以 P 结尾的数量\n        for (int j = 0; j <= 1; j++) {\n            for (int k = 0; k <= 2; k++) {\n                dpNew[j][0] = (dpNew[j][0] + dp[j][k]) % MOD;\n            }\n        }\n        // 以 A 结尾的数量\n        for (int k = 0; k <= 2; k++) {\n            dpNew[1][0] = (dpNew[1][0] + dp[0][k]) % MOD;\n        }\n        // 以 L 结尾的数量\n        for (int j = 0; j <= 1; j++) {\n            for (int k = 1; k <= 2; k++) {\n                dpNew[j][k] = (dpNew[j][k] + dp[j][k - 1]) % MOD;\n            }\n        }\n        memcpy(dp, dpNew, sizeof(dp));\n    }\n    int sum = 0;\n    for (int j = 0; j <= 1; j++) {\n        for (int k = 0; k <= 2; k++) {\n            sum = (sum + dp[j][k]) % MOD;\n        }\n    }\n    return sum;\n}\n```\n\n```go [sol12-Golang]\nfunc checkRecord(n int) (ans int) {\n    const mod int = 1e9 + 7\n    dp := [2][3]int{} // A 的数量，结尾连续 L 的数量\n    dp[0][0] = 1\n    for i := 1; i <= n; i++ {\n        dpNew := [2][3]int{}\n        // 以 P 结尾的数量\n        for j := 0; j <= 1; j++ {\n            for k := 0; k <= 2; k++ {\n                dpNew[j][0] = (dpNew[j][0] + dp[j][k]) % mod\n            }\n        }\n        // 以 A 结尾的数量\n        for k := 0; k <= 2; k++ {\n            dpNew[1][0] = (dpNew[1][0] + dp[0][k]) % mod\n        }\n        // 以 L 结尾的数量\n        for j := 0; j <= 1; j++ {\n            for k := 1; k <= 2; k++ {\n                dpNew[j][k] = (dpNew[j][k] + dp[j][k-1]) % mod\n            }\n        }\n        dp = dpNew\n    }\n    for j := 0; j <= 1; j++ {\n        for k := 0; k <= 2; k++ {\n            ans = (ans + dp[j][k]) % mod\n        }\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。动态规划需要计算 $n$ 天的状态，每天的状态有 $2 \\times 3 = 6$ 个，每天的状态需要 $O(1)$ 的时间计算。\n\n- 空间复杂度：$O(1)$。使用空间优化的实现，空间复杂度是 $O(1)$。\n\n#### 方法二：矩阵快速幂\n\n我们还可以使用矩阵快速幂来求解，该方法可以将方法一的时间复杂度由 $O(n)$ 降为 $O(\\log n)$。\n\n为了使用矩阵快速幂，需要将方法一的动态规划表示中的 $j$ 和 $k$ 合并到一个维度，即动态规划的状态为：$\\textit{dp}[i][j \\times 3 + k]$ 表示前 $i$ 天有 $j$ 个 $\\text{`A'}$ 且结尾有连续 $k$ 个 $\\text{`L'}$ 的可奖励的出勤记录的数量，其中 $0 \\le i \\le n$，$0 \\le j \\le 1$，$0 \\le k \\le 2$，$0 \\le j \\times 3 + k < 6$。\n\n在新的动态规划状态定义下，边界情况是 $\\textit{dp}[0][0] = 1$，当 $1 \\le i \\le n$ 时，状态转移方程如下：\n\n$$\n\\begin{cases}\n\\textit{dp}[i][0] = \\textit{dp}[i - 1][0] + \\textit{dp}[i - 1][1] + \\textit{dp}[i - 1][2] \\\\\n\\textit{dp}[i][1] = \\textit{dp}[i - 1][0] \\\\\n\\textit{dp}[i][2] = \\textit{dp}[i - 1][1] \\\\\n\\textit{dp}[i][3] = \\textit{dp}[i - 1][0] + \\textit{dp}[i - 1][1] + \\textit{dp}[i - 1][2] + \\textit{dp}[i - 1][3] + \\textit{dp}[i - 1][4] + \\textit{dp}[i - 1][5] \\\\\n\\textit{dp}[i][4] = \\textit{dp}[i - 1][3] \\\\\n\\textit{dp}[i][5] = \\textit{dp}[i - 1][4]\n\\end{cases}\n$$\n\n令 $\\textit{dp}[n]$ 表示包含 $6$ 个元素的行向量：\n\n$$\n\\textit{dp}[n] = \\left[\n\\begin{matrix}\n    \\textit{dp}[n][0] & \\textit{dp}[n][1] & \\textit{dp}[n][2] & \\textit{dp}[n][3] & \\textit{dp}[n][4] & \\textit{dp}[n][5]\n\\end{matrix}\n\\right]\n$$\n\n我们可以构建这样一个递推关系：\n\n$$\n\\textit{dp}[n] = \n\\textit{dp}[n - 1] \\times\n\\left[\n\\begin{matrix}\n    1 & 1 & 0 & 1 & 0 & 0 \\\\\n    1 & 0 & 1 & 1 & 0 & 0 \\\\\n    1 & 0 & 0 & 1 & 0 & 0 \\\\\n    0 & 0 & 0 & 1 & 1 & 0 \\\\\n    0 & 0 & 0 & 1 & 0 & 1 \\\\\n    0 & 0 & 0 & 1 & 0 & 0\n\\end{matrix}\n\\right]\n$$\n\n因此：\n\n$$\n\\textit{dp}[n] = \\textit{dp}[0] \\times\n\\left[\n\\begin{matrix}\n    1 & 1 & 0 & 1 & 0 & 0 \\\\\n    1 & 0 & 1 & 1 & 0 & 0 \\\\\n    1 & 0 & 0 & 1 & 0 & 0 \\\\\n    0 & 0 & 0 & 1 & 1 & 0 \\\\\n    0 & 0 & 0 & 1 & 0 & 1 \\\\\n    0 & 0 & 0 & 1 & 0 & 0\n\\end{matrix}\n\\right]^n\n$$\n\n令：\n\n$$\nM = \\left[\n\\begin{matrix}\n    1 & 1 & 0 & 1 & 0 & 0 \\\\\n    1 & 0 & 1 & 1 & 0 & 0 \\\\\n    1 & 0 & 0 & 1 & 0 & 0 \\\\\n    0 & 0 & 0 & 1 & 1 & 0 \\\\\n    0 & 0 & 0 & 1 & 0 & 1 \\\\\n    0 & 0 & 0 & 1 & 0 & 0\n\\end{matrix}\n\\right]\n$$\n\n因此只要我们能快速计算矩阵 $M$ 的 $n$ 次幂，就可以得到 $\\textit{dp}[n]$ 的值，然后计算可奖励的出勤记录的数量。如果直接求取 $M^n$，时间复杂度是 $O(n)$，可以定义矩阵乘法，然后用快速幂算法来加速这里 $M^n$ 的求取。计算过程中需要将结果对 $10^9+7$ 取模。\n\n```Java [sol2-Java]\nclass Solution {\n    static final int MOD = 1000000007;\n\n    public int checkRecord(int n) {\n        long[][] mat = {{1, 1, 0, 1, 0, 0},\n                        {1, 0, 1, 1, 0, 0},\n                        {1, 0, 0, 1, 0, 0},\n                        {0, 0, 0, 1, 1, 0},\n                        {0, 0, 0, 1, 0, 1},\n                        {0, 0, 0, 1, 0, 0}};\n        long[][] res = pow(mat, n);\n        long sum = Arrays.stream(res[0]).sum();\n        return (int) (sum % MOD);\n    }\n\n    public long[][] pow(long[][] mat, int n) {\n        long[][] ret = {{1, 0, 0, 0, 0, 0}};\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ret = multiply(ret, mat);\n            }\n            n >>= 1;\n            mat = multiply(mat, mat);\n        }\n        return ret;\n    }\n\n    public long[][] multiply(long[][] a, long[][] b) {\n        int rows = a.length, columns = b[0].length, temp = b.length;\n        long[][] c = new long[rows][columns];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < columns; j++) {\n                for (int k = 0; k < temp; k++) {\n                    c[i][j] += a[i][k] * b[k][j];\n                    c[i][j] %= MOD;\n                }\n            }\n        }\n        return c;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    const int MOD = 1000000007;\n\n    public int CheckRecord(int n) {\n        long[,] mat = {{1, 1, 0, 1, 0, 0},\n                       {1, 0, 1, 1, 0, 0},\n                       {1, 0, 0, 1, 0, 0},\n                       {0, 0, 0, 1, 1, 0},\n                       {0, 0, 0, 1, 0, 1},\n                       {0, 0, 0, 1, 0, 0}};\n        long[,] res = Pow(mat, n);\n        int sum = 0;\n        for (int i = 0; i < 6; i++) {\n            sum = (sum + (int) res[0, i]) % MOD;\n        }\n        return sum;\n    }\n\n    public long[,] Pow(long[,] mat, int n) {\n        long[,] ret = {{1, 0, 0, 0, 0, 0},\n                       {0, 1, 0, 0, 0, 0},\n                       {0, 0, 1, 0, 0, 0},\n                       {0, 0, 0, 1, 0, 0},\n                       {0, 0, 0, 0, 1, 0},\n                       {0, 0, 0, 0, 0, 1}};\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ret = Multiply(ret, mat);\n            }\n            n >>= 1;\n            mat = Multiply(mat, mat);\n        }\n        return ret;\n    }\n\n    public long[,] Multiply(long[,] a, long[,] b) {\n        int rows = a.GetLength(0), columns = b.GetLength(1), temp = b.GetLength(0);\n        long[,] c = new long[rows, columns];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < columns; j++) {\n                for (int k = 0; k < temp; k++) {\n                    c[i, j] += a[i, k] * b[k, j];\n                    c[i, j] %= MOD;\n                }\n            }\n        }\n        return c;\n    }\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar checkRecord = function(n) {\n    const MOD = BigInt(1000000007);\n    \n    const pow = (mat, n) => {\n        let ret = [[1, 0, 0, 0, 0, 0]];\n        while (n > 0) {\n            if ((n & 1) === 1) {\n                ret = multiply(ret, mat);\n            }\n            n >>= 1;\n            mat = multiply(mat, mat);\n        }\n        return ret;\n    }\n\n    const multiply = (a, b) => {\n        const rows = a.length, columns = b[0].length, temp = b.length;\n        const c = new Array(rows).fill(0).map(() => new Array(columns).fill(BigInt(0)));\n        for (let i = 0; i < rows; i++) {\n            for (let j = 0; j < columns; j++) {\n                for (let k = 0; k < temp; k++) {\n                    c[i][j] += BigInt(BigInt(a[i][k]) * BigInt(b[k][j]));\n                    c[i][j] %= MOD;\n                }\n            }\n        }\n        return c;\n    }\n\n    const mat = [[1, 1, 0, 1, 0, 0],\n                 [1, 0, 1, 1, 0, 0],\n                 [1, 0, 0, 1, 0, 0],\n                 [0, 0, 0, 1, 1, 0],\n                 [0, 0, 0, 1, 0, 1],\n                 [0, 0, 0, 1, 0, 0]];\n    const res = pow(mat, n);\n    const sum = BigInt(eval(res[0].join(\"+\")));\n    return sum % MOD;\n};\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def checkRecord(self, n: int) -> int:\n        MOD = 10**9 + 7\n        mat = [\n            [1, 1, 0, 1, 0, 0],\n            [1, 0, 1, 1, 0, 0],\n            [1, 0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1, 0],\n            [0, 0, 0, 1, 0, 1],\n            [0, 0, 0, 1, 0, 0],\n        ]\n        \n        def multiply(a: List[List[int]], b: List[List[int]]) -> List[List[int]]:\n            rows, columns, temp = len(a), len(b[0]), len(b)\n            c = [[0] * columns for _ in range(rows)]\n            for i in range(rows):\n                for j in range(columns):\n                    for k in range(temp):\n                        c[i][j] += a[i][k] * b[k][j]\n                        c[i][j] %= MOD\n            return c\n        \n        def matrixPow(mat: List[List[int]], n: int) -> List[List[int]]:\n            ret = [[1, 0, 0, 0, 0, 0]]\n            while n > 0:\n                if (n & 1) == 1:\n                    ret = multiply(ret, mat)\n                n >>= 1\n                mat = multiply(mat, mat)\n            return ret\n\n        res = matrixPow(mat, n)\n        ans = sum(res[0])\n        return ans % MOD\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    static constexpr int MOD = 1'000'000'007;\n\n    vector<vector<long>> pow(vector<vector<long>> mat, int n) {\n        vector<vector<long>> ret = {{1, 0, 0, 0, 0, 0}};\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ret = multiply(ret, mat);\n            }\n            n >>= 1;\n            mat = multiply(mat, mat);\n        }\n        return ret;\n    }\n\n    vector<vector<long>> multiply(vector<vector<long>> a, vector<vector<long>> b) {\n        int rows = a.size(), columns = b[0].size(), temp = b.size();\n        vector<vector<long>> c(rows, vector<long>(columns));\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < columns; j++) {\n                for (int k = 0; k < temp; k++) {\n                    c[i][j] += a[i][k] * b[k][j];\n                    c[i][j] %= MOD;\n                }\n            }\n        }\n        return c;\n    }\n\n    int checkRecord(int n) {\n        vector<vector<long>> mat = {{1, 1, 0, 1, 0, 0}, {1, 0, 1, 1, 0, 0}, {1, 0, 0, 1, 0, 0}, {0, 0, 0, 1, 1, 0}, {0, 0, 0, 1, 0, 1}, {0, 0, 0, 1, 0, 0}};\n        vector<vector<long>> res = pow(mat, n);\n        long sum = accumulate(res[0].begin(), res[0].end(), 0ll);\n        return (int)(sum % MOD);\n    }\n};\n```\n\n```C [sol2-C]\nconst int MOD = 1000000007;\n\nstruct Matrix {\n    long mat[6][6];\n    int row, col;\n};\n\nstruct Matrix multiply(struct Matrix a, struct Matrix b) {\n    int rows = a.row, columns = b.col, temp = b.row;\n    struct Matrix c;\n    memset(c.mat, 0, sizeof(c.mat));\n    c.row = rows, c.col = columns;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            for (int k = 0; k < temp; k++) {\n                c.mat[i][j] += a.mat[i][k] * b.mat[k][j];\n                c.mat[i][j] %= MOD;\n            }\n        }\n    }\n    return c;\n}\n\nstruct Matrix matricPow(struct Matrix mat, int n) {\n    struct Matrix ret = {{{1, 0, 0, 0, 0, 0}}, 1, 6};\n    while (n > 0) {\n        if ((n & 1) == 1) {\n            ret = multiply(ret, mat);\n        }\n        n >>= 1;\n        mat = multiply(mat, mat);\n    }\n    return ret;\n}\n\nint checkRecord(int n) {\n    struct Matrix mat = {{{1, 1, 0, 1, 0, 0}, {1, 0, 1, 1, 0, 0}, {1, 0, 0, 1, 0, 0}, {0, 0, 0, 1, 1, 0}, {0, 0, 0, 1, 0, 1}, {0, 0, 0, 1, 0, 0}}, 6, 6};\n    struct Matrix res = matricPow(mat, n);\n    long sum = 0;\n    for (int i = 0; i < res.col; i++) {\n        sum += res.mat[0][i];\n    }\n    return (int)(sum % MOD);\n}\n```\n\n```go [sol2-Golang]\nconst mod int = 1e9 + 7\n\ntype matrix [6][6]int\n\nfunc (a matrix) mul(b matrix) matrix {\n    c := matrix{}\n    for i, row := range a {\n        for j := range b[0] {\n            for k, v := range row {\n                c[i][j] = (c[i][j] + v*b[k][j]) % mod\n            }\n        }\n    }\n    return c\n}\n\nfunc (a matrix) pow(n int) matrix {\n    res := matrix{}\n    for i := range res {\n        res[i][i] = 1\n    }\n    for ; n > 0; n >>= 1 {\n        if n&1 > 0 {\n            res = res.mul(a)\n        }\n        a = a.mul(a)\n    }\n    return res\n}\n\nfunc checkRecord(n int) (ans int) {\n    m := matrix{\n        {1, 1, 0, 1, 0, 0},\n        {1, 0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0, 0},\n        {0, 0, 0, 1, 1, 0},\n        {0, 0, 0, 1, 0, 1},\n        {0, 0, 0, 1, 0, 0},\n    }\n    res := m.pow(n)\n    for _, v := range res[0] {\n        ans = (ans + v) % mod\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$。\n\n- 空间复杂度：$O(1)$。"
}