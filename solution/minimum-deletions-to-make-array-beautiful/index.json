{
	"titleSlug": "minimum-deletions-to-make-array-beautiful",
	"slug": "liang-chong-jie-fa-by-tsreaper-02yo",
	"url": "https://leetcode-cn.com/problems/minimum-deletions-to-make-array-beautiful/solution/liang-chong-jie-fa-by-tsreaper-02yo/",
	"content": "## 解法 1：贪心\r\n如果当前数可以作为数对中的第二个数就保留，它的下一个数直接作为下一个数对中的第一个数。复杂度 $\\mathcal{O}(n)$。\r\n\r\n关于该贪心算法的证明见下文。\r\n\r\n## 参考代码（c++）\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int minDeletion(vector<int>& nums) {\r\n        int n = nums.size();\r\n        int ans = 0;\r\n        for (int i = 0; i + 1 < n; i++) {\r\n            if (nums[i] == nums[i + 1]) ans++;\r\n            else i++;\r\n        }\r\n        if ((n - ans) % 2) ans++;\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 2：dp\r\n贪心不会证，想写不敢写？我们也可以直接 dp。记 $f_x$ 表示 $x$ 作为数对中的第一个数时，最多保留几个数；$g_x$ 表示 $x$ 作为数对中的第二个数时，最多保留几个数。考虑数 $x$ 时，有如下 dp 方程：\r\n* $f_x = \\max (g_y) + 1$；\r\n* $g_x = \\max_{y \\ne x} (f_y) + 1$。\r\n\r\n答案就是 $\\max (g_x)$。\r\n\r\n因此我们可以用一个变量维护 $\\max (g_x)$，用 map + multiset 维护 $\\max (f_x)$。复杂度 $\\mathcal{O}(n \\log n)$。\r\n\r\n## 参考代码（c++）\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int minDeletion(vector<int>& nums) {\r\n        // 作为第二个数时，最多保留几个数\r\n        int ans = 0;\r\n        // 作为第一个数时，最多保留几个数\r\n        map<int, int> mp;\r\n        multiset<int> st;\r\n        for (int x : nums) {\r\n            // 剔除 x 作为第一个数的情况，以满足第二个数不能与第一个数相同\r\n            if (mp.count(x)) st.erase(st.find(mp[x]));\r\n            // x 作为第一个数，前一个数任意\r\n            mp[x] = max(mp[x], ans + 1);\r\n            // x 作为第二个数，前一个数不能是 x，我们已经从 st 里剔除了\r\n            if (!st.empty()) ans = max(ans, *(st.rbegin()) + 1);\r\n            // 更新 x 作为第一个数的情况\r\n            st.insert(mp[x]);\r\n        }\r\n        return nums.size() - ans;\r\n    }\r\n};\r\n```\r\n\r\n## 贪心的证明\r\n显然最佳答案中同一个数不会连续出现三次及以上，因此我们先考虑同一个数连续出现不超过两次时，贪心算法是否正确。\r\n\r\n在该简化问题中，如果同一个数 $a_i$ 和 $a_{i + 1}$ 连续出现两次，而且这两个数都要保留，那么 $i$ 必须是奇数（下标从 $0$ 开始）。如果 $i$ 是偶数，那么我们必须从小等于 $(i + 1)$ 的下标里删掉一个。当删除下标 $j$ 时，原下标大于 $j$ 的数都会受影响（原本连续出现的两个数都能保留的，结果前面删了一下，下标的奇偶性改变了）。这个影响只会让答案不优，因此为了最小化影响，我们直接删除下标 $(i + 1)$ 就好。我们的贪心算法在简化问题中就在做这个事。\r\n\r\n回到原问题，如果出现同一个数 $a_i, a_{i + 1}, a_{i + 2}, \\cdots$ 连续出现超过两次，当 $i$ 是奇数时，贪心算法会删掉下标大等于 $(i + 2)$ 的部分；当 $i$ 是偶数时，贪心算法会删掉下标大等于 $(i + 1)$ 的部分。其实就是把连续出现的数减到两次，以及简化问题中的操作这两个步骤结合起来一起做。因此贪心算法正确。"
}