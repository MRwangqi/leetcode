{
	"titleSlug": "shortest-path-to-get-all-keys",
	"slug": "huo-qu-suo-you-yao-chi-de-zui-duan-lu-jing-by-leet",
	"url": "https://leetcode-cn.com/problems/shortest-path-to-get-all-keys/solution/huo-qu-suo-you-yao-chi-de-zui-duan-lu-jing-by-leet/",
	"content": "#### 方法一：暴力 + 枚举\n\n**思路和算法**\n\n遍历所有可能的获取钥匙的顺序。如果钥匙为 `'abcdef'`，有一种可能的顺序就是  `'bafedc'`，之后计算一下这种取法的代价，即 `'@' -> 'b' -> 'a' -> 'f' -> 'e' -> 'd' -> 'c'` 这条路径的长度。\n\n每取走一把钥匙都需要标记取过的状态，用标记的状态来判断哪些锁可以通过。\n\n```java [solution1-Java]\nimport java.awt.Point;\n\nclass Solution {\n    int INF = Integer.MAX_VALUE;\n    String[] grid;\n    int R, C;\n    Map<Character, Point> location;\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n\n    public int shortestPathAllKeys(String[] grid) {\n        this.grid = grid;\n        R = grid.length;\n        C = grid[0].length();\n\n        //location['a'] = the coordinates of 'a' on the grid, etc.\n        location = new HashMap();\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                char v = grid[r].charAt(c);\n                if (v != '.' && v != '#')\n                    location.put(v, new Point(r, c));\n            }\n\n        int ans = INF;\n        int num_keys = location.size() / 2;\n        String[] alphabet = new String[num_keys];\n        for (int i = 0; i < num_keys; ++i)\n            alphabet[i] = Character.toString((char)('a' + i));\n        //alphabet = [\"a\", \"b\", \"c\"], if there were 3 keys\n\n        search: for (String cand: permutations(alphabet, 0, num_keys)) {\n            //bns : the built candidate answer, consisting of the sum\n            //of distances of the segments from '@' to cand[0] to cand[1] etc.\n            int bns = 0;\n            for (int i = 0; i < num_keys; ++i) {\n                char source = i > 0 ? cand.charAt(i-1) : '@';\n                char target = cand.charAt(i);\n\n                //keymask : an integer with the 0-th bit set if we picked up\n                // key 'a', the 1-th bit set if we picked up key 'b', etc.\n                int keymask = 0;\n                for (int j = 0; j < i; ++j)\n                    keymask |= 1 << (cand.charAt(j) - 'a');\n                int d = bfs(source, target, keymask);\n                if (d == INF) continue search;\n                bns += d;\n                if (bns >= ans) continue search;\n            }\n            ans = bns;\n        }\n\n        return ans < INF ? ans : -1;\n    }\n\n    public int bfs(char source, char target, int keymask) {\n        int sr = location.get(source).x;\n        int sc = location.get(source).y;\n        int tr = location.get(target).x;\n        int tc = location.get(target).y;\n        boolean[][] seen = new boolean[R][C];\n        seen[sr][sc] = true;\n        int curDepth = 0;\n        Queue<Point> queue = new LinkedList();\n        queue.offer(new Point(sr, sc));\n        queue.offer(null);\n\n        while (!queue.isEmpty()) {\n            Point p = queue.poll();\n            if (p == null) {\n                curDepth++;\n                if (!queue.isEmpty())\n                    queue.offer(null);\n                continue;\n            }\n            int r = p.x, c = p.y;\n            if (r == tr && c == tc) return curDepth;\n            for (int i = 0; i < 4; ++i) {\n                int cr = r + dr[i];\n                int cc = c + dc[i];\n                if (0 <= cr && cr < R && 0 <= cc && cc < C && !seen[cr][cc]){\n                    char cur = grid[cr].charAt(cc);\n                    if (cur != '#') {\n                        if (Character.isUpperCase(cur) && (((1 << (cur - 'A')) & keymask) <= 0))\n                            continue; // at lock and don't have key\n\n                        queue.offer(new Point(cr, cc));\n                        seen[cr][cc] = true;\n                    }\n                }\n            }\n        }\n\n        return INF;\n    }\n\n    public List<String> permutations(String[] alphabet, int used, int size) {\n        List<String> ans = new ArrayList();\n        if (size == 0) {\n            ans.add(new String(\"\"));\n            return ans;\n        }\n\n        for (int b = 0; b < alphabet.length; ++b)\n            if (((used >> b) & 1) == 0)\n                for (String rest: permutations(alphabet, used | (1 << b), size - 1))\n                    ans.add(alphabet[b] + rest);\n        return ans;\n    }\n}\n```\n\n```python [solution1-Python]\nclass Solution(object):\n    def shortestPathAllKeys(self, grid):\n        R, C = len(grid), len(grid[0])\n        # location['a'] = the coordinates of 'a' on the grid, etc.\n        location = {v: (r, c)\n                    for r, row in enumerate(grid)\n                    for c, v in enumerate(row)\n                    if v not in '.#'}\n\n        def neighbors(r, c):\n            for cr, cc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):\n                if 0 <= cr < R and 0 <= cc < C:\n                    yield cr, cc\n\n        def bfs(source, target, keys = ()):\n            sr, sc = location[source]\n            tr, tc = location[target]\n            seen = [[False] * C for _ in xrange(R)]\n            seen[sr][sc] = True\n            queue = collections.deque([(sr, sc, 0)])\n            while queue:\n                r, c, d = queue.popleft()\n                if r == tr and c == tc: return d\n                for cr, cc in neighbors(r, c):\n                    if not seen[cr][cc] and grid[cr][cc] != '#':\n                        if grid[cr][cc].isupper() and grid[cr][cc].lower() not in keys:\n                            continue\n                        queue.append((cr,cc,d+1))\n                        seen[cr][cc] = True\n            return float('inf')\n\n        ans = float('inf')\n        keys = \"\".join(chr(ord('a') + i) for i in xrange(len(location) / 2))\n        for cand in itertools.permutations(keys):\n            # bns : the built candidate answer, consisting of the sum\n            # of distances of the segments from '@' to cand[0] to cand[1] etc.\n            bns = 0\n            for i, target in enumerate(cand):\n                source = cand[i-1] if i > 0 else '@'\n                d = bfs(source, target, cand[:i])\n                bns += d\n                if bns >= ans: break\n            else:\n                ans = bns\n\n        return ans if ans < float('inf') else -1\n```\n\n\n**复杂度分析**\n\n* 时间复杂度： $O(R * C * A * A!)$，其中 $R, C$ 为表格的长宽，（$A$ 为钥匙的数量）。深度优先搜索最多执行 $A * A!$ 次。\n\n* 空间复杂度： $O(R * C + A!)$，$R * C$ 为深度优先搜索占用的空间，$A！$ 为全排序数组占用的空间。\n\n#### 方法二： 关键点  + Dijkstra\n\n**思路和算法**\n\n显然钥匙，锁，起点是图中的关键节点。先用深度优先搜索计算所有关键节点之间的距离，再用Dijkstra 算法找到每一种状态下的最小代价。\n\n```java [solution2-Java]\nimport java.awt.Point;\n\nclass Solution {\n    int INF = Integer.MAX_VALUE;\n    String[] grid;\n    int R, C;\n    Map<Character, Point> location;\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n\n    public int shortestPathAllKeys(String[] grid) {\n        this.grid = grid;\n        R = grid.length;\n        C = grid[0].length();\n\n        //location : the points of interest\n        location = new HashMap();\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                char v = grid[r].charAt(c);\n                if (v != '.' && v != '#')\n                    location.put(v, new Point(r, c));\n            }\n\n        int targetState = (1 << (location.size() / 2)) - 1;\n        Map<Character, Map<Character, Integer>> dists = new HashMap();\n        for (char place: location.keySet())\n            dists.put(place, bfsFrom(place));\n\n        //Dijkstra\n        PriorityQueue<ANode> pq = new PriorityQueue<ANode>((a, b) ->\n                Integer.compare(a.dist, b.dist));\n        pq.offer(new ANode(new Node('@', 0), 0));\n        Map<Node, Integer> finalDist = new HashMap();\n        finalDist.put(new Node('@', 0), 0);\n\n        while (!pq.isEmpty()) {\n            ANode anode = pq.poll();\n            Node node = anode.node;\n            int d = anode.dist;\n            if (finalDist.getOrDefault(node, INF) < d) continue;\n            if (node.state == targetState) return d;\n\n            for (char destination: dists.get(node.place).keySet()) {\n                int d2 = dists.get(node.place).get(destination);\n                int state2 = node.state;\n                if (Character.isLowerCase(destination)) //key\n                    state2 |= (1 << (destination - 'a'));\n                if (Character.isUpperCase(destination)) //lock\n                    if ((node.state & (1 << (destination - 'A'))) == 0) // no key\n                        continue;\n\n                if (d + d2 < finalDist.getOrDefault(new Node(destination, state2), INF)) {\n                    finalDist.put(new Node(destination, state2), d + d2);\n                    pq.offer(new ANode(new Node(destination, state2), d+d2));\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    public Map<Character, Integer> bfsFrom(char source) {\n        int sr = location.get(source).x;\n        int sc = location.get(source).y;\n        boolean[][] seen = new boolean[R][C];\n        seen[sr][sc] = true;\n        int curDepth = 0;\n        Queue<Point> queue = new LinkedList();\n        queue.offer(new Point(sr, sc));\n        queue.offer(null);\n        Map<Character, Integer> dist = new HashMap();\n\n        while (!queue.isEmpty()) {\n            Point p = queue.poll();\n            if (p == null) {\n                curDepth++;\n                if (!queue.isEmpty())\n                    queue.offer(null);\n                continue;\n            }\n\n            int r = p.x, c = p.y;\n            if (grid[r].charAt(c) != source && grid[r].charAt(c) != '.') {\n                dist.put(grid[r].charAt(c), curDepth);\n                continue; // Stop walking from here if we reach a point of interest\n            }\n\n            for (int i = 0; i < 4; ++i) {\n                int cr = r + dr[i];\n                int cc = c + dc[i];\n                if (0 <= cr && cr < R && 0 <= cc && cc < C && !seen[cr][cc]){\n                    if (grid[cr].charAt(cc) != '#') {\n                        queue.offer(new Point(cr, cc));\n                        seen[cr][cc] = true;\n                    }\n                }\n            }\n        }\n\n        return dist;\n    }\n}\n\n// ANode: Annotated Node\nclass ANode {\n    Node node;\n    int dist;\n\n    ANode(Node n, int d) {\n        node = n;\n        dist = d;\n    }\n}\n\nclass Node {\n    char place;\n    int state;\n\n    Node(char p, int s) {\n        place = p;\n        state = s;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Node)) return false;\n        Node other = (Node) o;\n        return (place == other.place && state == other.state);\n    }\n\n    @Override\n    public int hashCode() {\n        return 256 * state + place;\n    }\n}\n```\n\n```python [solution2-Python]\nclass Solution(object):\n    def shortestPathAllKeys(self, grid):\n        R, C = len(grid), len(grid[0])\n\n        # The points of interest\n        location = {v: (r, c)\n                    for r, row in enumerate(grid)\n                    for c, v in enumerate(row)\n                    if v not in '.#'}\n\n        def neighbors(r, c):\n            for cr, cc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):\n                if 0 <= cr < R and 0 <= cc < C:\n                    yield cr, cc\n\n        # The distance from source to each point of interest\n        def bfs_from(source):\n            r, c = location[source]\n            seen = [[False] * C for _ in xrange(R)]\n            seen[r][c] = True\n            queue = collections.deque([(r, c, 0)])\n            dist = {}\n            while queue:\n                r, c, d = queue.popleft()\n                if source != grid[r][c] != '.':\n                    dist[grid[r][c]] = d\n                    continue # Stop walking from here if we reach a point of interest\n                for cr, cc in neighbors(r, c):\n                    if grid[cr][cc] != '#' and not seen[cr][cc]:\n                        seen[cr][cc] = True\n                        queue.append((cr, cc, d+1))\n            return dist        \n\n        dists = {place: bfs_from(place) for place in location}\n        target_state = 2 ** sum(p.islower() for p in location) - 1\n\n        #Dijkstra\n        pq = [(0, '@', 0)]\n        final_dist = collections.defaultdict(lambda: float('inf'))\n        final_dist['@', 0] = 0\n        while pq:\n            d, place, state = heapq.heappop(pq)\n            if final_dist[place, state] < d: continue\n            if state == target_state: return d\n            for destination, d2 in dists[place].iteritems():\n                state2 = state\n                if destination.islower(): #key\n                    state2 |= (1 << (ord(destination) - ord('a')))\n                elif destination.isupper(): #lock\n                    if not(state & (1 << (ord(destination) - ord('A')))): #no key\n                        continue\n\n                if d + d2 < final_dist[destination, state2]:\n                    final_dist[destination, state2] = d + d2\n                    heapq.heappush(pq, (d+d2, destination, state2))\n\n        return -1\n```\n\n\n**复杂度分析**\n\n* 时间复杂度： $O(RC(2A + 1) + E\\log{N})$，其中 $R, C$ 是表格的长宽， $A$ 为钥匙总数，$RC(2A + 1$ 为深度优先遍历的复杂度。$N = (2A + 1) * 2^A$ 为 Dijkstra 遍历最大节点数，$E = N * (2A + 1)$ 为 Dijkstra 遍历最大边数，$E\\log{N}$ 为 Dijkstra 算法复杂度。"
}