{
	"titleSlug": "minimum-number-of-operations-to-reinitialize-a-permutation",
	"slug": "shu-xue-on-suan-fa-by-arsenal-591-xatz",
	"url": "https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution/shu-xue-on-suan-fa-by-arsenal-591-xatz/",
	"content": "感谢 [@zerotrac2](/u/zerotrac2/) 提供的绝妙思路。\r\n\r\n对于原排列中第 $i$ 个元素，设 $f(i)$ 为进行一次操作后，该元素的新的下标。根据题意：\r\n- 当 $i < n/2$ 时，$f(i)=2i$（第一条规则）\r\n- 当 $i \\ge n/2$ 时，$f(i)=2i-(n-1)$（第二条规则）\r\n\r\n原排列中的第 $0$ 和 $n-1$ 个元素的下标是不会变化的，我们无需进行考虑。\r\n对于其余元素 $i \\in [1, n-1)$，都有 $f(i) \\equiv 2i \\bmod (n-1)$。\r\n\r\n下面，记 $f^k(i)$ 为原排列中第 $i$ 个元素操作 $k$ 次后的下标，即 $f^2(i) = f(f(i)), f^3(i) = f(f(f(i)))$ 等等，那么我们有\r\n\r\n$$\r\nf^k(i) \\equiv 2^ki \\bmod (n-1)\r\n$$\r\n\r\n这意味着：**为了让排列还原到初始值，必须有 $f^k(i) \\equiv 2^ki \\equiv i \\bmod (n-1)$**。\r\n\r\n当 $i=1$ 时，我们有\r\n\r\n$$\r\nf^k(1) \\equiv 2^k \\equiv 1 \\bmod (n-1)\r\n$$\r\n\r\n如果存在 $k$ 满足上式，那么将上式两侧同乘 $i$，得到 $f^k(i) \\equiv i \\bmod (n-1)$ 即对于 $i \\in [1, n-1)$ 恒成立。因此，原题等价于寻找最小的 $k$，使得 $2^k \\equiv 1 \\bmod (n-1)$。\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int reinitializePermutation(int n) {\r\n        if (n == 2) {\r\n            return 1;\r\n        }\r\n        int k = 1;\r\n        int pow2 = 2;\r\n        while (pow2 != 1) {\r\n            k++;\r\n            pow2 = pow2 * 2 % (n - 1);\r\n        }\r\n        return k;\r\n    }\r\n};\r\n```\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def reinitializePermutation(self, n: int) -> int:\r\n        if n == 2:\r\n            return 1\r\n        \r\n        k, pow2 = 1, 2\r\n        while pow2 != 1:\r\n            k += 1\r\n            pow2 = pow2 * 2 % (n - 1)\r\n        \r\n        return k\r\n```\r\n\r\n由于 $n-1$ 是奇数，$2$ 和 $n-1$ 互质，那么根据 [欧拉定理](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA))\r\n\r\n$$\r\n2^{\\varphi(n-1)} \\equiv 1 \\bmod (n-1)\r\n$$\r\n\r\n即 $k=\\varphi(n-1)$ 一定是一个解，其中 $\\varphi$ 为 [欧拉函数](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0)。因此，最小的 $k$ 一定小于等于 $\\varphi(n-1)$。而后者是 $O(n-1) = O(n)$ 的，因此总的时间复杂度为 $O(n)$。\r\n\r\n**注记 1**：题面中给出的是新数组中下标为 $i$ 的元素来源自原数组中的哪个元素，即为 $f$ 的反函数。为了从反函数中求解出 $f$，可以利用换元法。\r\n**注记 2**：为了推导出 $i \\in [1, n-1)$，都有 $f(i) = 2i \\bmod (n-1)$，需要对两种情况做分类讨论。\r\n**注记 3**：本思路来自网站 [Project Euler](https://projecteuler.net) 的题目 [Riffle Shuffles](https://projecteuler.net/problem=622)。"
}