{
	"titleSlug": "all-divisions-with-the-highest-score-of-a-binary-array",
	"slug": "fen-zu-de-fen-zui-gao-de-suo-you-xia-bia-7pqp",
	"url": "https://leetcode-cn.com/problems/all-divisions-with-the-highest-score-of-a-binary-array/solution/fen-zu-de-fen-zui-gao-de-suo-you-xia-bia-7pqp/",
	"content": "#### 方法一：一次遍历\n\n**思路与算法**\n\n如果我们根据下标 $i$ 将 $\\textit{nums}$ 拆分成两个数组，那么左半部分 $0$ 的个数即为：\n\n$$\n\\sum_{k=0}^{i-1} ( 1 - \\textit{nums}[i] )\n$$\n\n右半部分 $1$ 的个数即为：\n\n$$\n\\sum_{k=i}^{n-1} \\textit{nums}[i]\n$$\n\n总和即为：\n\n$$\n\\begin{aligned}\n& \\sum_{k=0}^{i-1} ( 1 - \\textit{nums}[i] ) + \\sum_{k=i}^{n-1} \\textit{nums}[i] \\\\\n\\Leftrightarrow \\quad & \\sum_{k=0}^{i-1} ( 1 - 2 \\cdot \\textit{nums}[i] ) + \\sum_{k=0}^{n-1} \\textit{nums}[i] \\tag{1}\n\\end{aligned}\n$$\n\n由于我们希望得分最高，因此目标为最大化 $(1)$ 式的值。注意到 $\\sum\\limits_{k=0}^{n-1} \\textit{nums}[i]$ 是定值，那么目标等价于最大化 $\\sum\\limits_{k=0}^{i-1} ( 1 - 2 \\cdot \\textit{nums}[i] )$：\n\n> 当 $\\textit{nums}[i] = 0$ 时，$1 - 2 \\cdot \\textit{nums}[i] = 1$；\n> 当 $\\textit{nums}[i] = 1$ 时，$1 - 2 \\cdot \\textit{nums}[i] = -1$；\n\n因此我们只需要对数组进行一次遍历，并维护前缀和即可。前缀和的定义为：如果遇到 $0$ 就增加 $1$，否则减少 $1$。\n\n对于当前遍历到的位置 $i$，如果前缀和大于历史最大值，那么就对历史最大值进行更新，并重置历史最大值对应的下标为 $i$；如果 $\\sum\\limits_{k=0}^{i-1} \\textit{nums}[i]$ 等于历史最大值，那么只需要将 $i$ 加入历史最大值的下标集合即可。\n\n**细节**\n\n当 $\\textit{nums}[i] = 1$ 时，$1 - 2 \\cdot \\textit{nums}[i] = -1$，此时前缀和会减少，因此必定不会大于或等于历史最大值，我们可以省去比较操作。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> maxScoreIndices(vector<int>& nums) {\n        int n = nums.size();\n        // best 为历史最大值\n        int presum = 0, best = 0;\n        // ans 为历史最大值的下标\n        vector<int> ans = {0};\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                ++presum;\n                if (presum > best) {\n                    best = presum;\n                    ans = {i + 1};\n                }\n                else if (presum == best) {\n                    ans.push_back(i + 1);\n                }\n            }\n            else {\n                --presum;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\n        # best 为历史最大值\n        presum = best = 0\n        # ans 为历史最大值的下标\n        ans = [0]\n\n        for i, num in enumerate(nums):\n            if num == 0:\n                presum += 1\n                if presum > best:\n                    best = presum\n                    ans = [i + 1]\n                elif presum == best:\n                    ans.append(i + 1)\n            else:\n                presum -= 1\n        \n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。\n\n- 空间复杂度：$O(1)$。"
}