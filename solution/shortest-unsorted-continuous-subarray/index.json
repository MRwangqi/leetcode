{
	"titleSlug": "shortest-unsorted-continuous-subarray",
	"slug": "si-lu-qing-xi-ming-liao-kan-bu-dong-bu-cun-zai-de-",
	"url": "https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/si-lu-qing-xi-ming-liao-kan-bu-dong-bu-cun-zai-de-/",
	"content": "**分析**\r\n\r\n我们可以假设把这个数组分成三段，`左段`和`右段`是标准的升序数组，`中段`数组虽是无序的，但满足最小值大于`左段`的最大值，最大值小于`右段`的最小值。\r\n![微信截图_20200921203355.png](https://pic.leetcode-cn.com/1600691648-ZCYlql-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200921203355.png)\r\n\r\n\r\n那么我们目标就很明确了，找中段的左右边界，我们分别定义为`begin `和 `end`;\r\n分两头开始遍历:\r\n- 从左到右维护一个最大值`max,`在进入右段之前，那么遍历到的`nums[i]`都是小于`max`的，我们要求的`end`就是遍历中最后一个小于`max`元素的位置；\r\n- 同理，从右到左维护一个最小值`min`，在进入左段之前，那么遍历到的nums[i]也都是大于`min`的，要求的`begin`也就是最后一个大于`min`元素的位置。\r\n\r\n**代码**\r\n```java []\r\nclass Solution {\r\n    public int findUnsortedSubarray(int[] nums) {\r\n        //初始化\r\n        int len = nums.length;\r\n        int min = nums[len-1];\r\n        int max = nums[0];\r\n        int begin = 0, end = -1;\r\n        //遍历\r\n        for(int i = 0; i < len; i++){\r\n            if(nums[i] < max){      //从左到右维持最大值，寻找右边界end\r\n                end = i;\r\n            }else{\r\n                max = nums[i];\r\n            }\r\n            \r\n            if(nums[len-i-1] > min){    //从右到左维持最小值，寻找左边界begin\r\n                begin = len-i-1;\r\n            }else{\r\n                min = nums[len-i-1];\r\n            }            \r\n        }\r\n        return end-begin+1;\r\n    }\r\n}\r\n```\r\n\r\n![微信图片_20200919202337.jpg](https://pic.leetcode-cn.com/1600692988-LCxvvb-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200919202337.jpg)\r\n\r\n"
}