{
	"titleSlug": "prefix-and-suffix-search",
	"slug": "qian-zhui-he-hou-zhui-sou-suo-by-leetcod-i3ec",
	"url": "https://leetcode-cn.com/problems/prefix-and-suffix-search/solution/qian-zhui-he-hou-zhui-sou-suo-by-leetcod-i3ec/",
	"content": "#### 方法一：计算每个单词的前缀后缀组合可能性\n\n**思路**\n\n预先计算出每个单词的前缀后缀组合可能性，用特殊符号连接，作为键，对应的最大下标作为值保存入哈希表。检索时，同样用特殊符号连接前后缀，在哈希表中进行搜索。\n\n**代码**\n\n```Python [sol1-Python3]\nclass WordFilter:\n\n    def __init__(self, words: List[str]):\n        self.d = {}\n        for i, word in enumerate(words):\n            m = len(word)\n            for prefixLength in range(1, m + 1):\n                for suffixLength in range(1, m + 1):\n                    self.d[word[:prefixLength] + '#' + word[-suffixLength:]] = i\n\n\n    def f(self, pref: str, suff: str) -> int:\n        return self.d.get(pref + '#' + suff, -1)\n```\n\n```Java [sol1-Java]\nclass WordFilter {\n    Map<String, Integer> dictionary;\n\n    public WordFilter(String[] words) {\n        dictionary = new HashMap<String, Integer>();\n        for (int i = 0; i < words.length; i++) {\n            String word = words[i];\n            int m = word.length();\n            for (int prefixLength = 1; prefixLength <= m; prefixLength++) {\n                for (int suffixLength = 1; suffixLength <= m; suffixLength++) {\n                    dictionary.put(word.substring(0, prefixLength) + \"#\" + word.substring(m - suffixLength), i);\n                }\n            }\n        }\n    }\n\n    public int f(String pref, String suff) {\n        return dictionary.getOrDefault(pref + \"#\" + suff, -1);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class WordFilter {\n    Dictionary<string, int> dictionary;\n\n    public WordFilter(string[] words) {\n        dictionary = new Dictionary<string, int>();\n        for (int i = words.Length - 1; i >= 0; i--) {\n            string word = words[i];\n            int m = word.Length;\n            for (int prefixLength = 1; prefixLength <= m; prefixLength++) {\n                for (int suffixLength = 1; suffixLength <= m; suffixLength++) {\n                    dictionary.TryAdd(word.Substring(0, prefixLength) + \"#\" + word.Substring(m - suffixLength), i);\n                }\n            }\n        }\n    }\n\n    public int F(string pref, string suff) {\n        if (dictionary.ContainsKey(pref + \"#\" + suff)) {\n            return dictionary[pref + \"#\" + suff];\n        }\n        return -1;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass WordFilter {\nprivate:\n    unordered_map<string, int> dict;\npublic:\n    WordFilter(vector<string>& words) {\n        for (int i = 0; i < words.size(); i++) {\n            int m = words[i].size();\n            string word = words[i];\n            for (int prefixLength = 1; prefixLength <= m; prefixLength++) {\n                for (int suffixLength = 1; suffixLength <= m; suffixLength++) {\n                    string key = word.substr(0, prefixLength) + '#' + word.substr(m - suffixLength);\n                    dict[key] = i;\n                }\n            }\n        }\n    }\n    \n    int f(string pref, string suff) {\n        string target = pref + '#' + suff;\n        return dict.count(target) ? dict[target] : -1;\n    }\n};\n```\n\n```C [sol1-C]\n#define MAX_STR_LEN 16\n\ntypedef struct {\n    char key[MAX_STR_LEN];\n    int val;\n    UT_hash_handle hh;\n} HashItem;\n\ntypedef struct {\n    HashItem *dict;\n} WordFilter;\n\nWordFilter* wordFilterCreate(char ** words, int wordsSize) {\n    WordFilter *obj = (WordFilter *)malloc(sizeof(WordFilter));\n    obj->dict = NULL;\n    for (int i = 0; i < wordsSize; i++) {\n        int m = strlen(words[i]);\n        for (int prefixLength = 1; prefixLength <= m; prefixLength++) {\n            for (int suffixLength = 1; suffixLength <= m; suffixLength++) {\n                char key[MAX_STR_LEN];\n                strncpy(key, words[i], prefixLength);\n                key[prefixLength] = '#';\n                strcpy(key + prefixLength + 1, words[i] + m - suffixLength);\n                key[prefixLength + 1 + suffixLength] = '\\0';\n                HashItem *pEntry = NULL;\n                HASH_FIND_STR(obj->dict, key, pEntry);\n                if (NULL == pEntry) {\n                    pEntry = (HashItem *)malloc(sizeof(HashItem));\n                    strcpy(pEntry->key, key);\n                    HASH_ADD_STR(obj->dict, key, pEntry);\n                }\n                pEntry->val = i;\n            }\n        }\n    }\n    return obj;\n}\n\nint wordFilterF(WordFilter* obj, char * pref, char * suff) {\n    char target[MAX_STR_LEN];\n    sprintf(target, \"%s#%s\", pref, suff);\n    HashItem *pEntry = NULL;\n    HASH_FIND_STR(obj->dict, target, pEntry);\n    if (NULL == pEntry) {\n        return -1;\n    }\n    return pEntry->val;\n}\n\nvoid wordFilterFree(WordFilter* obj) {\n    HashItem *curr, *tmp;\n    HASH_ITER(hh, obj->dict, curr, tmp) {\n        HASH_DEL(obj->dict, curr);  \n        free(curr);          \n    }\n    free(obj);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar WordFilter = function(words) {\n    this.dictionary = new Map();\n    for (let i = 0; i < words.length; i++) {\n        const word = words[i];\n        const m = word.length;\n        for (let prefixLength = 1; prefixLength <= m; prefixLength++) {\n            for (let suffixLength = 1; suffixLength <= m; suffixLength++) {\n                this.dictionary.set(word.substring(0, prefixLength) + \"#\" + word.substring(m - suffixLength), i);\n            }\n        }\n    }\n};\n\nWordFilter.prototype.f = function(pref, suff) {\n    if (this.dictionary.has(pref + \"#\" + suff)) {\n        return this.dictionary.get(pref + \"#\" + suff);\n    }\n    return -1;\n};\n```\n\n```go [sol1-Golang]\ntype WordFilter map[string]int\n\nfunc Constructor(words []string) WordFilter {\n    wf := WordFilter{}\n    for i, word := range words {\n        for j, n := 1, len(word); j <= n; j++ {\n            for k := 0; k < n; k++ {\n                wf[word[:j]+\"#\"+word[k:]] = i\n            }\n        }\n    }\n    return wf\n}\n\nfunc (wf WordFilter) F(pref, suff string) int {\n    if i, ok := wf[pref+\"#\"+suff]; ok {\n        return i\n    }\n    return -1\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化消耗 $O(\\sum\\limits_{i=0}^{n-1}w_i^3)$ 时间，其中 $w_i$ 是每个单词的字符数。每次检索消耗 $O(p + s)$，其中 $p$ 和 $s$ 分别是输入的 $\\textit{pref}$ 和 $\\textit{suff}$ 的长度。\n\n- 空间复杂度：初始化消耗 $O(\\sum\\limits_{i=0}^{n-1}w_i^3)$ 空间，每次检索消耗 $O(p + s)$ 空间。\n\n#### 方法二：字典树\n\n**思路**\n\n调用 $f$ 时，如果前缀和后缀的长度相同，那么此题可以用字典树来解决。初始化时，只需将单词正序和倒序后得到的单词对依次插入字典树即可。比如要插入 $\\text{``apple\"}$ 时，只需依次插入 $\\text{(`a', `e'), (`p', `l'), (`p', `p'), (`l', `p'), (`e', `a')}$ 即可。这样初始化后，对于前缀和后缀相同的检索，也只需要在字典树上检索前缀和后缀倒序得到的单词对。但是调用 $f$ 时，还有可能遇到前缀和后缀长度不同的情况。为了应对这一情况，可以将短的字符串用特殊字符补足，使得前缀和后缀长度相同。而在初始化时，也需要考虑到这个情况，特殊字符组成的单词对，也要插入字典树中。\n\n**代码**\n\n```Python [sol2-Python3]\nclass WordFilter:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.weightKey = ('#', '#')\n        for i, word in enumerate(words):\n            cur = self.trie\n            m = len(word)\n            for j in range(m):\n                tmp = cur\n                for k in range(j, m):\n                    key = (word[k], '#')\n                    if key not in tmp:\n                        tmp[key] = {}\n                    tmp = tmp[key]\n                    tmp[self.weightKey] = i\n                tmp = cur\n                for k in range(j, m):\n                    key = ('#', word[-k - 1])\n                    if key not in tmp:\n                        tmp[key] = {}\n                    tmp = tmp[key]\n                    tmp[self.weightKey] = i\n                key = (word[j], word[-j - 1])\n                if key not in cur:\n                    cur[key] = {}\n                cur = cur[key]\n                cur[self.weightKey] = i\n                \n    def f(self, pref: str, suff: str) -> int:\n        cur = self.trie\n        for key in zip_longest(pref, suff[::-1], fillvalue='#'):\n            if key not in cur: \n                return -1\n            cur = cur[key]\n        return cur[self.weightKey]\n```\n\n```Java [sol2-Java]\nclass WordFilter {\n    Trie trie;\n    String weightKey;\n\n    public WordFilter(String[] words) {\n        trie = new Trie();\n        weightKey = \"##\";\n        for (int i = 0; i < words.length; i++) {\n            String word = words[i];\n            Trie cur = trie;\n            int m = word.length();\n            for (int j = 0; j < m; j++) {\n                Trie tmp = cur;\n                for (int k = j; k < m; k++) {\n                    String key = new StringBuilder().append(word.charAt(k)).append('#').toString();\n                    if (!tmp.children.containsKey(key)) {\n                        tmp.children.put(key, new Trie());\n                    }\n                    tmp = tmp.children.get(key);\n                    tmp.weight.put(weightKey, i);\n                }\n                tmp = cur;\n                for (int k = j; k < m; k++) {\n                    String key = new StringBuilder().append('#').append(word.charAt(m - k - 1)).toString();\n                    if (!tmp.children.containsKey(key)) {\n                        tmp.children.put(key, new Trie());\n                    }\n                    tmp = tmp.children.get(key);\n                    tmp.weight.put(weightKey, i);\n                }\n                String key = new StringBuilder().append(word.charAt(j)).append(word.charAt(m - j - 1)).toString();\n                if (!cur.children.containsKey(key)) {\n                    cur.children.put(key, new Trie());\n                }\n                cur = cur.children.get(key);\n                cur.weight.put(weightKey, i);\n            }\n        }\n    }\n\n    public int f(String pref, String suff) {\n        Trie cur = trie;\n        int m = Math.max(pref.length(), suff.length());\n        for (int i = 0; i < m; i++) {\n            char c1 = i < pref.length() ? pref.charAt(i) : '#';\n            char c2 = i < suff.length() ? suff.charAt(suff.length() - 1 - i) : '#';\n            String key = new StringBuilder().append(c1).append(c2).toString();\n            if (!cur.children.containsKey(key)) {\n                return -1;\n            }\n            cur = cur.children.get(key);\n        }\n        return cur.weight.get(weightKey);\n    }\n}\n\nclass Trie {\n    Map<String, Trie> children;\n    Map<String, Integer> weight;\n\n    public Trie() {\n        children = new HashMap<String, Trie>();\n        weight = new HashMap<String, Integer>();\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class WordFilter {\n    Trie trie;\n    string weightKey;\n\n    public WordFilter(string[] words) {\n        trie = new Trie();\n        weightKey = \"##\";\n        for (int i = words.Length - 1; i >= 0; i--) {\n            string word = words[i];\n            Trie cur = trie;\n            string key;\n            int m = word.Length;\n            for (int j = 0; j < m; j++) {\n                Trie tmp = cur;\n                for (int k = j; k < m; k++) {\n                    key = new StringBuilder().Append(word[k]).Append('#').ToString();\n                    if (!tmp.Children.ContainsKey(key)) {\n                        tmp.Children.TryAdd(key, new Trie());\n                    }\n                    tmp = tmp.Children[key];\n                    tmp.Weight.TryAdd(weightKey, i);\n                }\n                tmp = cur;\n                for (int k = j; k < m; k++) {\n                    key = new StringBuilder().Append('#').Append(word[m - k - 1]).ToString();\n                    if (!tmp.Children.ContainsKey(key)) {\n                        tmp.Children.TryAdd(key, new Trie());\n                    }\n                    tmp = tmp.Children[key];\n                    tmp.Weight.TryAdd(weightKey, i);\n                }\n                key = new StringBuilder().Append(word[j]).Append(word[m - j - 1]).ToString();\n                if (!cur.Children.ContainsKey(key)) {\n                    cur.Children.TryAdd(key, new Trie());\n                }\n                cur = cur.Children[key];\n                cur.Weight.TryAdd(weightKey, i);\n            }\n        }\n    }\n\n    public int F(string pref, string suff) {\n        Trie cur = trie;\n        int m = Math.Max(pref.Length, suff.Length);\n        for (int i = 0; i < m; i++) {\n            char c1 = i < pref.Length ? pref[i] : '#';\n            char c2 = i < suff.Length ? suff[suff.Length - 1 - i] : '#';\n            string key = new StringBuilder().Append(c1).Append(c2).ToString();\n            if (!cur.Children.ContainsKey(key)) {\n                return -1;\n            }\n            cur = cur.Children[key];\n        }\n        return cur.Weight[weightKey];\n    }\n}\n\npublic class Trie {\n    public Dictionary<string, Trie> Children;\n    public Dictionary<string, int> Weight;\n\n    public Trie() {\n        Children = new Dictionary<string, Trie>();\n        Weight = new Dictionary<string, int>();\n    }\n}\n```\n\n```C++ [sol2-C++]\nstruct Trie {\n    unordered_map<string, Trie *> children;\n    int weight;\n};\n\nclass WordFilter {\nprivate:\n    Trie *trie;\n\npublic:\n    WordFilter(vector<string>& words) {\n        trie = new Trie();\n        for (int i = 0; i < words.size(); i++) {\n            string word = words[i];\n            Trie *cur = trie;\n            int m = word.size();\n            for (int j = 0; j < m; j++) {\n                Trie *tmp = cur;\n                for (int k = j; k < m; k++) {\n                    string key({word[k], '#'});\n                    if (!tmp->children.count(key)) {\n                        tmp->children[key] = new Trie();\n                    }\n                    tmp = tmp->children[key];\n                    tmp->weight = i;\n                }\n                tmp = cur;\n                for (int k = j; k < m; k++) {\n                    string key({'#', word[m - k - 1]});\n                    if (!tmp->children.count(key)) {\n                        tmp->children[key] = new Trie();\n                    }\n                    tmp = tmp->children[key];\n                    tmp->weight = i;\n                }\n                string key({word[j], word[m - j - 1]});\n                if (!cur->children.count(key)) {\n                    cur->children[key] = new Trie();\n                }\n                cur = cur->children[key];\n                cur->weight = i;\n            }\n        }\n    }\n    \n    int f(string pref, string suff) {\n        Trie *cur = trie;\n        int m = max(pref.size(), suff.size());\n        for (int i = 0; i < m; i++) {\n            char c1 = i < pref.size() ? pref[i] : '#';\n            char c2 = i < suff.size() ? suff[suff.size() - 1 - i] : '#';\n            string key({c1, c2});\n            if (!cur->children.count(key)) {\n                return -1;\n            }\n            cur = cur->children[key];\n        }\n        return cur->weight;\n    }\n};\n```\n\n```C [sol2-C]\n#define MAX_STR_LEN 4\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nstruct Trie;\n\ntypedef struct HashItem {\n    int key;\n    struct Trie *val;\n    UT_hash_handle hh;\n} HashItem;\n\ntypedef struct Trie {\n    HashItem *children;\n    int weight;\n} Trie;\n\ntypedef struct {\n    Trie *trie;\n} WordFilter;\n\nWordFilter* wordFilterCreate(char ** words, int wordsSize) {\n    WordFilter *obj = (WordFilter *)malloc(sizeof(WordFilter));\n    obj->trie = (Trie *)malloc(sizeof(Trie));\n    obj->trie->children = NULL;\n    for (int i = 0; i < wordsSize; i++) {\n        char *word = words[i];\n        Trie *cur = obj->trie;\n        int m = strlen(word);\n        for (int j = 0; j < m; j++) {\n            Trie *tmp = cur;\n            for (int k = j; k < m; k++) {\n                int key = (word[k] << 8) + '#';\n                HashItem *pEntry = NULL;\n                HASH_FIND_INT(tmp->children, &key, pEntry);\n                if (NULL == pEntry) {\n                    pEntry = (HashItem *)malloc(sizeof(HashItem));\n                    pEntry->key = key;\n                    pEntry->val = (Trie *)malloc(sizeof(Trie));\n                    pEntry->val->children = NULL;\n                    HASH_ADD_INT(tmp->children, key, pEntry);\n                }\n                tmp = pEntry->val;\n                tmp->weight = i;\n            }\n            tmp = cur;\n            for (int k = j; k < m; k++) {\n                int key = ('#' << 8) + word[m - k - 1];\n                HashItem *pEntry = NULL;\n                HASH_FIND_INT(tmp->children, &key, pEntry);\n                if (NULL == pEntry) {\n                    pEntry = (HashItem *)malloc(sizeof(HashItem));\n                    pEntry->key = key;\n                    pEntry->val = (Trie *)malloc(sizeof(Trie));\n                    pEntry->val->children = NULL;\n                    HASH_ADD_INT(tmp->children, key, pEntry);\n                }\n                tmp = pEntry->val;\n                tmp->weight = i;\n            }\n            int key = (word[j] << 8) + word[m - j - 1];\n            HashItem *pEntry = NULL;\n            HASH_FIND_INT(cur->children, &key, pEntry);\n            if (NULL == pEntry) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                pEntry->key = key;\n                pEntry->val = (Trie *)malloc(sizeof(Trie));\n                pEntry->val->children = NULL;\n                HASH_ADD_INT(cur->children, key, pEntry);\n            }\n            cur = pEntry->val;\n            cur->weight = i;\n        }\n    }\n    return obj;\n}\n\nint wordFilterF(WordFilter* obj, char * pref, char * suff) {\n    Trie *cur = obj->trie;\n    int prefSize = strlen(pref);\n    int suffSize = strlen(suff);\n    int m = MAX(prefSize, suffSize);\n    for (int i = 0; i < m; i++) {\n        char c1 = i < prefSize ? pref[i] : '#';\n        char c2 = i < suffSize ? suff[suffSize - 1 - i] : '#';\n        int key = (c1 << 8) + c2;\n        HashItem *pEntry = NULL;\n        HASH_FIND_INT(cur->children, &key, pEntry);\n        if (NULL == pEntry) {\n            return -1;\n        }\n        cur = pEntry->val;\n    }\n    return cur->weight;\n}\n\nvoid freeTrie(Trie *obj) {\n    HashItem *cur, *tmp;\n    HASH_ITER(hh, obj->children, cur, tmp) {\n        HASH_DEL(obj->children, cur);\n        freeTrie(cur->val);\n        free(cur);\n    }\n    free(obj);\n}\n\nvoid wordFilterFree(WordFilter* obj) {\n    freeTrie(obj->trie);\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化消耗 $O(\\sum\\limits_{i=0}^{n-1}w_i^2)$ 时间，其中 $w_i$ 是每个单词的字符数。每次检索消耗 $O(\\max(p, s))$，其中 $p$ 和 $s$ 分别是输入的 $\\textit{pref}$ 和 $\\textit{suff}$ 的长度。\n\n- 空间复杂度：初始化消耗 $O(\\sum\\limits_{i=0}^{n-1}w_i^2)$ 空间，每次检索消耗 $O(1)$ 空间。"
}