{
	"titleSlug": "serialize-and-deserialize-bst",
	"slug": "xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-5m9r4",
	"url": "https://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-5m9r4/",
	"content": "#### 前言\n\n二叉搜索树是一种特殊的二叉树，序列化和反序列化过程也可以参照「[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/)」的过程。二叉搜索树的特殊之处在于其中序遍历是有序的，可以利用这一点来优化时间和空间复杂度。\n\n#### 方法一：后序遍历\n\n**思路**\n\n给定一棵二叉树的「先序遍历」和「中序遍历」可以恢复这颗二叉树。给定一棵二叉树的「后序遍历」和「中序遍历」也可以恢复这颗二叉树。而对于二叉搜索树，给定「先序遍历」或者「后序遍历」，对其经过排序即可得到「中序遍历」。因此，仅对二叉搜索树做「先序遍历」或者「后序遍历」，即可达到序列化和反序列化的要求。此题解采用「后序遍历」的方法。\n\n序列化时，只需要对二叉搜索树进行后序遍历，再将数组编码成字符串即可。\n\n反序列化时，需要先将字符串解码成后序遍历的数组。在将后序遍历的数组恢复成二叉搜索树时，不需要先排序得到中序遍历的数组再根据中序和后序遍历的数组来恢复二叉树，而可以根据有序性直接由后序遍历的数组恢复二叉搜索树。后序遍历得到的数组中，根结点的值位于数组末尾，左子树的节点均小于根节点的值，右子树的节点均大于根节点的值，可以根据这些性质设计递归函数恢复二叉搜索树。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Codec:\n    def serialize(self, root: TreeNode) -> str:\n        arr = []\n        def postOrder(root: TreeNode) -> None:\n            if root is None:\n                return\n            postOrder(root.left)\n            postOrder(root.right)\n            arr.append(root.val)\n        postOrder(root)\n        return ' '.join(map(str, arr))\n\n    def deserialize(self, data: str) -> TreeNode:\n        arr = list(map(int, data.split()))\n        def construct(lower: int, upper: int) -> TreeNode:\n            if arr == [] or arr[-1] < lower or arr[-1] > upper:\n                return None\n            val = arr.pop()\n            root = TreeNode(val)\n            root.right = construct(val, upper)\n            root.left = construct(lower, val)\n            return root\n        return construct(-inf, inf)\n```\n\n```Java [sol1-Java]\npublic class Codec {\n    public String serialize(TreeNode root) {\n        List<Integer> list = new ArrayList<Integer>();\n        postOrder(root, list);\n        String str = list.toString();\n        return str.substring(1, str.length() - 1);\n    }\n\n    public TreeNode deserialize(String data) {\n        if (data.isEmpty()) {\n            return null;\n        }\n        String[] arr = data.split(\", \");\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        int length = arr.length;\n        for (int i = 0; i < length; i++) {\n            stack.push(Integer.parseInt(arr[i]));\n        }\n        return construct(Integer.MIN_VALUE, Integer.MAX_VALUE, stack);\n    }\n\n    private void postOrder(TreeNode root, List<Integer> list) {\n        if (root == null) {\n            return;\n        }\n        postOrder(root.left, list);\n        postOrder(root.right, list);\n        list.add(root.val);\n    }\n\n    private TreeNode construct(int lower, int upper, Deque<Integer> stack) {\n        if (stack.isEmpty() || stack.peek() < lower || stack.peek() > upper) {\n            return null;\n        }\n        int val = stack.pop();\n        TreeNode root = new TreeNode(val);\n        root.right = construct(val, upper, stack);\n        root.left = construct(lower, val, stack);\n        return root;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Codec {\n    public string serialize(TreeNode root) {\n        IList<int> list = new List<int>();\n        PostOrder(root, list);\n        return string.Join(\",\", list);\n    }\n\n    public TreeNode deserialize(string data) {\n        if (data.Length == 0) {\n            return null;\n        }\n        string[] arr = data.Split(\",\");\n        Stack<int> stack = new Stack<int>();\n        int length = arr.Length;\n        for (int i = 0; i < length; i++) {\n            stack.Push(int.Parse(arr[i]));\n        }\n        return Construct(int.MinValue, int.MaxValue, stack);\n    }\n\n    private void PostOrder(TreeNode root, IList<int> list) {\n        if (root == null) {\n            return;\n        }\n        PostOrder(root.left, list);\n        PostOrder(root.right, list);\n        list.Add(root.val);\n    }\n\n    private TreeNode Construct(int lower, int upper, Stack<int> stack) {\n        if (stack.Count == 0 || stack.Peek() < lower || stack.Peek() > upper) {\n            return null;\n        }\n        int val = stack.Pop();\n        TreeNode root = new TreeNode(val);\n        root.right = Construct(val, upper, stack);\n        root.left = Construct(lower, val, stack);\n        return root;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Codec {\npublic:\n    string serialize(TreeNode* root) {\n        string res;\n        vector<int> arr;\n        postOrder(root, arr);\n        if (arr.size() == 0) {\n            return res;\n        }\n        for (int i = 0; i < arr.size() - 1; i++) {\n            res.append(to_string(arr[i]) + \",\");\n        }\n        res.append(to_string(arr.back()));\n        return res;\n    }\n\n    vector<string> split(const string &str, char dec) {\n        int pos = 0;\n        int start = 0;\n        vector<string> res;\n        while (pos < str.size()) {\n            while (pos < str.size() && str[pos] == dec) {\n                pos++;\n            }\n            start = pos;\n            while (pos < str.size() && str[pos] != dec) {\n                pos++;\n            }\n            if (start < str.size()) {\n                res.emplace_back(str.substr(start, pos - start));\n            }\n        }\n        return res;\n    }\n\n    TreeNode* deserialize(string data) {\n        if (data.size() == 0) {\n            return nullptr;\n        }\n        vector<string> arr = split(data, ',');\n        stack<int> st;\n        for (auto & str : arr) {\n            st.emplace(stoi(str));\n        }\n        return construct(INT_MIN, INT_MAX, st);\n    }\n\n    void postOrder(TreeNode *root,vector<int> & arr) {\n        if (root == nullptr) {\n            return;\n        }\n        postOrder(root->left, arr);\n        postOrder(root->right, arr);\n        arr.emplace_back(root->val);\n    }\n\n    TreeNode * construct(int lower, int upper, stack<int> & st) {\n        if (st.size() == 0 || st.top() < lower || st.top() > upper) {\n            return nullptr;\n        }\n        int val = st.top();\n        st.pop();\n        TreeNode *root = new TreeNode(val);\n        root->right = construct(val, upper, st);\n        root->left = construct(lower, val, st);\n        return root;\n    }\n};\n```\n\n```C [sol1-C]\n#define MAX_NODE_SIZE 10000\n\nvoid postOrder(struct TreeNode *root, int *arr, int *pos) {\n    if (root == NULL) {\n        return;\n    }\n    postOrder(root->left, arr, pos);\n    postOrder(root->right, arr, pos);\n    arr[(*pos)++] = root->val;\n}\n\nstruct TreeNode * construct(int lower, int upper, int *stack, int *top) {\n    if (*top == 0 || stack[*top - 1] < lower || stack[*top - 1] > upper) {\n        return NULL;\n    }\n    int val = stack[*top - 1];\n    (*top)--;\n    struct TreeNode *root = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n    root->val = val;\n    root->right = construct(val, upper, stack, top);\n    root->left = construct(lower, val, stack, top);\n    return root;\n}\n\nchar* serialize(struct TreeNode* root) {\n    char *res = NULL;\n    int *arr = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    int pos = 0;\n    postOrder(root, arr, &pos);\n    if (pos == 0) {\n        return \"\";\n    }\n    res = (char *)malloc(sizeof(char) * pos * 6);\n    int len = 0;\n    for (int i = 0; i < pos - 1; i++) {\n        len += sprintf(res + len, \"%d,\", arr[i]);\n    }\n    sprintf(res + len, \"%d\", arr[pos - 1]);\n    free(arr);\n    return res;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    int len = strlen(data);\n    if (len == 0) {\n        return NULL;\n    }\n    int *stack = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    int pos = 0;\n    int top = 0;\n    while (pos < len) {\n        while (pos < len && data[pos] == ',') {\n            pos++;\n        }\n        int val = 0;\n        int start = pos;\n        while (pos < len && data[pos] != ',') {\n            val = val * 10 + data[pos] - '0';\n            pos++;\n        }\n        if (start < pos) {\n            stack[top++] = val;\n        }\n    }\n    struct TreeNode *root = construct(INT_MIN, INT_MAX, stack, &top);\n    free(stack);\n    return root;\n}\n```\n\n```go [sol1-Golang]\ntype Codec struct{}\n\nfunc Constructor() (_ Codec) { return }\n\nfunc (Codec) serialize(root *TreeNode) string {\n    arr := []string{}\n    var postOrder func(*TreeNode)\n    postOrder = func(node *TreeNode) {\n        if node == nil {\n            return\n        }\n        postOrder(node.Left)\n        postOrder(node.Right)\n        arr = append(arr, strconv.Itoa(node.Val))\n    }\n    postOrder(root)\n    return strings.Join(arr, \" \")\n}\n\nfunc (Codec) deserialize(data string) *TreeNode {\n    if data == \"\" {\n        return nil\n    }\n    arr := strings.Split(data, \" \")\n    var construct func(int, int) *TreeNode\n    construct = func(lower, upper int) *TreeNode {\n        if len(arr) == 0 {\n            return nil\n        }\n        val, _ := strconv.Atoi(arr[len(arr)-1])\n        if val < lower || val > upper {\n            return nil\n        }\n        arr = arr[:len(arr)-1]\n        return &TreeNode{Val: val, Right: construct(val, upper), Left: construct(lower, val)}\n    }\n    return construct(math.MinInt32, math.MaxInt32)\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar serialize = function(root) {\n    const list = [];\n\n    const postOrder = (root, list) => {\n        if (!root) {\n            return;\n        }\n        postOrder(root.left, list);\n        postOrder(root.right, list);\n        list.push(root.val);\n    }\n\n    postOrder(root, list);\n    const str = list.join(',');\n    return str;\n};\n\nvar deserialize = function(data) {\n    if (data.length === 0) {\n        return null;\n    }\n    let arr = data.split(',');\n    const length = arr.length;\n    const stack = [];\n    for (let i = 0; i < length; i++) {\n        stack.push(parseInt(arr[i]));\n    }\n\n    const construct = (lower, upper, stack) => {\n        if (stack.length === 0 || stack[stack.length - 1] < lower || stack[stack.length - 1] > upper) {\n            return null;\n        }\n        const val = stack.pop();\n        const root = new TreeNode(val);\n        root.right = construct(val, upper, stack);\n        root.left = construct(lower, val, stack);\n        return root;\n    }\n\n    return construct(-Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, stack);\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是树的节点数。$\\textit{serialize}$ 需要 $O(n)$ 时间遍历每个点。$\\textit{deserialize}$ 需要 $O(n)$ 时间恢复每个点。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是树的节点数。$\\textit{serialize}$ 需要 $O(n)$ 空间用数组保存每个点的值，递归的深度最深也为 $O(n)$。$\\textit{deserialize}$ 需要 $O(n)$ 空间用数组保存每个点的值，递归的深度最深也为 $O(n)$。"
}