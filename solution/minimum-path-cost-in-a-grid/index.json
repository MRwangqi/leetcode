{
	"titleSlug": "minimum-path-cost-in-a-grid",
	"slug": "by-endlesscheng-lnwn",
	"url": "https://leetcode-cn.com/problems/minimum-path-cost-in-a-grid/solution/by-endlesscheng-lnwn/",
	"content": "题目求什么就把状态定义成什么。\r\n\r\n定义 $f[i][j]$ 表示从第一行出发到达第 $i$ 行第 $j$ 列时的最小路径代价。\r\n\r\n应该从哪些状态转移过来呢？\r\n\r\n这里有一个技巧，就是考虑当前状态的「相邻」状态，或者说哪些状态可以「一步」到达当前状态。因为从更远的状态转移到当前状态，是必须要经过这些相邻的状态的，那么直接从这些相邻状态转移过来，就能算出正确的结果。\r\n\r\n当你这样思考的时候，就会自然地想到从第 $i-1$ 行转移过来了。\r\n\r\n枚举从第 $i-1$ 行的第 $k$ 列转移过来，取最小值，则有\r\n\r\n$$\r\nf[i][j] = \\textit{grid}[i][j] + \\min_{k=0}^{n-1} f[i-1][k] + \\textit{moveCost}[\\textit{grid}[i-1][k]][j]\r\n$$\r\n\r\n答案为 $\\min(f[m-1])$。\r\n\r\n代码实现时可以用滚动数组优化。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\r\n        f = grid[0]\r\n        for pre, cur in pairwise(grid):\r\n            f = [g + min(f[k] + moveCost[v][j] for k, v in enumerate(pre)) for j, g in enumerate(cur)]\r\n        return min(f)\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc minPathCost(grid [][]int, moveCost [][]int) int {\r\n\tm, n := len(grid), len(grid[0])\r\n\tpre := grid[0]\r\n\tf := make([]int, n)\r\n\tfor i := 1; i < m; i++ {\r\n\t\tfor j, g := range grid[i] {\r\n\t\t\tf[j] = math.MaxInt32\r\n\t\t\tfor k, v := range grid[i-1] {\r\n\t\t\t\tf[j] = min(f[j], pre[k]+moveCost[v][j])\r\n\t\t\t}\r\n\t\t\tf[j] += g\r\n\t\t}\r\n\t\tpre, f = f, pre\r\n\t}\r\n\tans := math.MaxInt32\r\n\tfor _, v := range pre {\r\n\t\tans = min(ans, v)\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc min(a, b int) int { if a > b { return b }; return a }\r\n```\r\n"
}