{
	"titleSlug": "binary-tree-tilt",
	"slug": "er-cha-shu-de-po-du-by-leetcode-solution-7rha",
	"url": "https://leetcode-cn.com/problems/binary-tree-tilt/solution/er-cha-shu-de-po-du-by-leetcode-solution-7rha/",
	"content": "#### 方法一：深度优先搜索\n\n**思路和算法**\n\n根据题意，我们需要累计二叉树中所有结点的左子树结点之和与右子树结点之和的差的绝对值。因此，我们可以使用深度优先搜索，在遍历每个结点时，累加其左子树结点之和与右子树结点之和的差的绝对值，并返回以其为根结点的树的结点之和。\n\n具体地，我们实现算法如下：\n\n* 从根结点开始遍历，设当前遍历的结点为 $\\textit{node}$；\n* 遍历 $\\textit{node}$ 的左子结点，得到左子树结点之和 $\\textit{sum\\_left}$；遍历 $\\textit{node}$ 的右子结点，得到右子树结点之和 $\\textit{sum\\_right}$；\n* 将左子树结点之和与右子树结点之和的差的绝对值累加到结果变量 $\\textit{ans}$；\n* 返回以 $\\textit{node}$ 作为根结点的树的结点之和 $\\textit{sum\\_left} + \\textit{sum\\_right} + \\textit{node}.\\textit{val}$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def __init__(self):\n        self.ans = 0\n\n    def findTilt(self, root: TreeNode) -> int:\n        self.dfs(root)\n        return self.ans\n\n    def dfs(self, node):\n        if not node:\n            return 0\n        sum_left = self.dfs(node.left)\n        sum_right = self.dfs(node.right)\n        self.ans += abs(sum_left - sum_right)\n        return sum_left + sum_right + node.val\n```\n\n```Java [sol1-Java]\nclass Solution {\n    int ans = 0;\n\n    public int findTilt(TreeNode root) {\n        dfs(root);\n        return ans;\n    }\n\n    public int dfs(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        int sumLeft = dfs(node.left);\n        int sumRight = dfs(node.right);\n        ans += Math.abs(sumLeft - sumRight);\n        return sumLeft + sumRight + node.val;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    int ans = 0;\n\n    public int FindTilt(TreeNode root) {\n        DFS(root);\n        return ans;\n    }\n\n    public int DFS(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        int sumLeft = DFS(node.left);\n        int sumRight = DFS(node.right);\n        ans += Math.Abs(sumLeft - sumRight);\n        return sumLeft + sumRight + node.val;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int ans = 0;\n\n    int findTilt(TreeNode* root) {\n        dfs(root);\n        return ans;\n    }\n\n    int dfs(TreeNode* node) {\n        if (node == nullptr) {\n            return 0;\n        }\n        int sumLeft = dfs(node->left);\n        int sumRight = dfs(node->right);\n        ans += abs(sumLeft - sumRight);\n        return sumLeft + sumRight + node->val;\n    } \n};\n```\n\n```JavaScript [sol1-JavaScript]\nvar findTilt = function(root) {\n    let ans = 0;\n\n    const dfs = (node) => {\n        if (!node) {\n            return 0;\n        }\n        const sumLeft = dfs(node.left);\n        const sumRight = dfs(node.right);\n        ans += Math.abs(sumLeft - sumRight);\n        return sumLeft + sumRight + node.val;\n    }\n\n    dfs(root);\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc findTilt(root *TreeNode) (ans int) {\n    var dfs func(*TreeNode) int\n    dfs = func(node *TreeNode) int {\n        if node == nil {\n            return 0\n        }\n        sumLeft := dfs(node.Left)\n        sumRight := dfs(node.Right)\n        ans += abs(sumLeft - sumRight)\n        return sumLeft + sumRight + node.Val\n    }\n    dfs(root)\n    return\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为二叉树中结点总数。我们需要遍历每一个结点。\n\n- 空间复杂度：$O(n)$。在最坏情况下， 当树为线性二叉树（即所有结点都只有左子结点或没有结点）时，树的高度为 $n - 1$，在递归时我们需要存储 $n$ 个结点。"
}