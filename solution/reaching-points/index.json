{
	"titleSlug": "reaching-points",
	"slug": "dao-da-zhong-dian-by-leetcode-solution-77fo",
	"url": "https://leetcode-cn.com/problems/reaching-points/solution/dao-da-zhong-dian-by-leetcode-solution-77fo/",
	"content": "#### 方法一：反向计算\n\n如果从 $(\\textit{sx}, \\textit{sy})$ 开始正向计算，则可能的情况非常多，会超出时间限制。注意到 $\\textit{sx}, \\textit{sy}, \\textit{tx}, \\textit{ty}$ 都是正整数，因此对于给定的状态 $(\\textit{tx}, \\textit{ty})$，只有当 $\\textit{tx} \\ne \\textit{ty}$ 时才存在上一个状态，且上一个状态唯一，可能的情况如下：\n\n- 如果 $\\textit{tx} = \\textit{ty}$，不存在上一个状态，状态 $(\\textit{tx}, \\textit{ty})$ 即为起点状态；\n\n- 如果 $\\textit{tx} > \\textit{ty}$，则上一个状态是 $(\\textit{tx} - \\textit{ty}, \\textit{ty})$；\n\n- 如果 $\\textit{tx} < \\textit{ty}$，则上一个状态是 $(\\textit{tx}, \\textit{ty} - \\textit{tx})$。\n\n因此可以从 $(\\textit{tx}, \\textit{ty})$ 开始反向计算，判断是否可以到达状态 $(\\textit{sx}, \\textit{sy})$。当 $\\textit{tx} > \\textit{sx}, \\textit{ty} > \\textit{sy}, \\textit{tx} \\ne \\textit{ty}$ 三个条件同时成立时，执行反向操作，每一步操作更新 $(\\textit{tx}, \\textit{ty})$ 的值，直到反向操作的条件不成立。\n\n由于每一步反向操作一定是将 $\\textit{tx}$ 和 $\\textit{ty}$ 中的较大的值减小，因此当 $\\textit{tx} > \\textit{ty}$ 时可以直接将 $\\textit{tx}$ 的值更新为 $\\textit{tx} \\bmod \\textit{ty}$，当 $\\textit{tx} < \\textit{ty}$ 时可以直接将 $\\textit{ty}$ 的值更新为 $\\textit{ty} \\bmod \\textit{tx}$。\n\n当反向操作的条件不成立时，根据 $\\textit{tx}$ 和 $\\textit{ty}$ 的不同情况分别判断是否可以从起点转换到终点。\n\n- 如果 $\\textit{tx} = \\textit{sx}$ 且 $\\textit{ty} = \\textit{sy}$，则已经到达起点状态，因此可以从起点转换到终点。\n\n- 如果 $\\textit{tx} = \\textit{sx}$ 且 $\\textit{ty} \\ne \\textit{sy}$，则 $\\textit{tx}$ 不能继续减小，只能减小 $\\textit{ty}$，因此只有当 $\\textit{ty} > \\textit{sy}$ 且 $(\\textit{ty} - \\textit{sy}) \\bmod \\textit{tx} = 0$ 时可以从起点转换到终点。\n\n- 如果 $\\textit{ty} = \\textit{sy}$ 且 $\\textit{tx} \\ne \\textit{sx}$，则 $\\textit{ty}$ 不能继续减小，只能减小 $\\textit{tx}$，因此只有当 $\\textit{tx} > \\textit{sx}$ 且 $(\\textit{tx} - \\textit{sx}) \\bmod \\textit{ty} = 0$ 时可以从起点转换到终点。\n\n- 如果 $\\textit{tx} \\ne \\textit{sx}$ 且 $\\textit{ty} \\ne \\textit{sy}$，则不可以从起点转换到终点。\n\n```Python [sol1-Python3]\nclass Solution:\n    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:\n        while sx < tx != ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        if tx == sx and ty == sy:\n            return True\n        elif tx == sx:\n            return ty > sy and (ty - sy) % tx == 0\n        elif ty == sy:\n            return tx > sx and (tx - sx) % ty == 0\n        else:\n            return False\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\n        while (tx > sx && ty > sy && tx != ty) {\n            if (tx > ty) {\n                tx %= ty;\n            } else {\n                ty %= tx;\n            }\n        }\n        if (tx == sx && ty == sy) {\n            return true;\n        } else if (tx == sx) {\n            return ty > sy && (ty - sy) % tx == 0;\n        } else if (ty == sy) {\n            return tx > sx && (tx - sx) % ty == 0;\n        } else {\n            return false;\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool ReachingPoints(int sx, int sy, int tx, int ty) {\n        while (tx > sx && ty > sy && tx != ty) {\n            if (tx > ty) {\n                tx %= ty;\n            } else {\n                ty %= tx;\n            }\n        }\n        if (tx == sx && ty == sy) {\n            return true;\n        } else if (tx == sx) {\n            return ty > sy && (ty - sy) % tx == 0;\n        } else if (ty == sy) {\n            return tx > sx && (tx - sx) % ty == 0;\n        } else {\n            return false;\n        }\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool reachingPoints(int sx, int sy, int tx, int ty) {\n        while (tx > sx && ty > sy && tx != ty) {\n            if (tx > ty) {\n                tx %= ty;\n            } else {\n                ty %= tx;\n            }\n        }\n        if (tx == sx && ty == sy) {\n            return true;\n        } else if (tx == sx) {\n            return ty > sy && (ty - sy) % tx == 0;\n        } else if (ty == sy) {\n            return tx > sx && (tx - sx) % ty == 0;\n        } else {\n            return false;\n        }\n    }\n};\n```\n\n```C [sol1-C]\nbool reachingPoints(int sx, int sy, int tx, int ty) {\n    while (tx > sx && ty > sy && tx != ty) {\n        if (tx > ty) {\n            tx %= ty;\n        } else {\n            ty %= tx;\n        }\n    }\n    if (tx == sx && ty == sy) {\n        return true;\n    } else if (tx == sx) {\n        return ty > sy && (ty - sy) % tx == 0;\n    } else if (ty == sy) {\n        return tx > sx && (tx - sx) % ty == 0;\n    } else {\n        return false;\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar reachingPoints = function(sx, sy, tx, ty) {\n    while (tx > sx && ty > sy && tx != ty) {\n        if (tx > ty) {\n            tx %= ty;\n        } else {\n            ty %= tx;\n        }\n    }\n    if (tx === sx && ty === sy) {\n        return true;\n    } else if (tx === sx) {\n        return ty > sy && (ty - sy) % tx === 0;\n    } else if (ty === sy) {\n        return tx > sx && (tx - sx) % ty === 0;\n    } else {\n        return false;\n    }\n};\n```\n\n```go [sol1-Golang]\nfunc reachingPoints(sx, sy, tx, ty int) bool {\n    for tx > sx && ty > sy && tx != ty {\n        if tx > ty {\n            tx %= ty\n        } else {\n            ty %= tx\n        }\n    }\n    switch {\n    case tx == sx && ty == sy:\n        return true\n    case tx == sx:\n        return ty > sy && (ty-sy)%tx == 0\n    case ty == sy:\n        return tx > sx && (tx-sx)%ty == 0\n    default:\n        return false\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log \\max(\\textit{tx}, \\textit{ty}))$，其中 $\\textit{tx}$ 和 $\\textit{ty}$ 是终点值。反向计算的过程与辗转相除法相似，时间复杂度是 $O(\\log \\max(\\textit{tx}, \\textit{ty}))$。\n\n- 空间复杂度：$O(1)$。"
}