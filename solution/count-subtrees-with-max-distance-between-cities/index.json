{
	"titleSlug": "count-subtrees-with-max-distance-between-cities",
	"slug": "by-wangzhizhi-9xjn",
	"url": "https://leetcode-cn.com/problems/count-subtrees-with-max-distance-between-cities/solution/by-wangzhizhi-9xjn/",
	"content": "> Problem: [1617. 统计子树中城市之间最大距离](https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/description/)\n\n##### 方法：二进制枚举+树的直径\n注意到$2\\leq n\\leq 15$，可以考虑枚举子树（枚举边的位编码），然后对子树求**树的直径**。要注意检查枚举子树的合法性，即**检查节点数是否等于边数加一**。\n\n##### 代码实现\n```C++ []\nclass Solution {\npublic:\n    vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {\n        int m = n - 1;\n        int mask = 1 << m;\n        vector<vector<int>> graph(n + 1);\n        map<pair<int, int>, int> rec;\n        for (int i = 0; i < m; i++) {\n            // 记录一下边和下标的对应关系\n            rec[{edges[i][0], edges[i][1]}] = i;\n            rec[{edges[i][1], edges[i][0]}] = i;\n            graph[edges[i][0]].emplace_back(edges[i][1]);\n            graph[edges[i][1]].emplace_back(edges[i][0]);\n        }\n        vector<int> res(m, 0);\n        for (int s = 1; s < mask; s++) {\n            // 计算用了几条边，1 的话可以跳过，2 的话判断是否联通以后也可以跳过\n            int bits = __builtin_popcount(s);\n            if (bits == 1) {\n                res[0]++;\n                continue;\n            }\n            // x 用来标记一个点，用作求树的直径的起点\n            int x = 0;\n            // counter 用来标记用到的点数（也是位编码）\n            int counter = 0;\n            for (int i = 0; i < m; i++) {\n                if (s & (1 << i)) {\n                    x = edges[i][0];\n                    counter |= (1 << edges[i][0]);\n                    counter |= (1 << edges[i][1]);\n                }\n            }\n            // 检查点数是否等于边数 + 1\n            if (bits != __builtin_popcount(counter) - 1)\n                continue;\n            if (bits == 2) {\n                res[1]++;\n                continue;\n            }\n            // 从任意一点 x 先求最远距离的点，然后再从这个点开始求最远距离就是直径\n            vector<int> dp(n + 1, 0);\n            function<void(int, int)> traverse = [&] (int u, int parent) {\n                for (int v : graph[u]) {\n                    if (v == parent)\n                        continue;\n                    if (s & (1 << rec[{u, v}])) {\n                        dp[v] = dp[u] + 1;\n                        traverse(v, u);\n                    }\n                }\n            };\n            // 先从任意一点 x 开始\n            traverse(x, 0);\n            x = 0;\n            for (int i = 1; i <= n; i++)\n                if (dp[i] > dp[x])\n                    x = i;\n            // 将 x 标记为一次 DFS 以后的最远点\n            fill(dp.begin(), dp.end(), 0);\n            // 再次求最远点\n            traverse(x, 0);\n            // 直径就是最远距离\n            int diameter = 0;\n            for (int i = 1; i <= n; i++)\n                diameter = max(diameter, dp[i]);\n            res[diameter - 1]++;\n        }\n        return res;\n    }\n};\n```\n"
}