{
	"titleSlug": "find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k",
	"slug": "he-wei-k-de-zui-shao-fei-bo-na-qi-shu-zi-shu-mu-by",
	"url": "https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/he-wei-k-de-zui-shao-fei-bo-na-qi-shu-zi-shu-mu-by/",
	"content": "#### 方法一：贪心\n\n**思路**\n\n首先找到所有不超过 $k$ 的斐波那契数字，然后每次贪心地选取不超过 $k$ 的最大斐波那契数字，将 $k$ 减去该斐波那契数字，重复该操作直到 $k$ 变为 $0$，此时选取的斐波那契数字满足和为 $k$ 且数目最少。\n\n**证明**\n\n为了证明上述方案选取的斐波那契数字数目最少，只需要证明存在一种选取斐波那契数字数目最少的方案，该方案选取了不超过 $k$ 的最大斐波那契数字。\n\n1. 当选取斐波那契数字数目最少时，不可能选取两个相邻的斐波那契数。\n\n   假设选取了两个相邻的斐波那契数字 $F_x$ 和 $F_{x + 1}$，则根据斐波那契数字的定义，这两个斐波那契数字之和为后一个斐波那契数字：\n\n   $$F_{x + 2} = F_x + F_{x + 1}$$\n\n   因此可以用 $F_{x + 2}$ 代替 $F_x$ 和 $F_{x + 1}$，选取的斐波那契数字的总和不变，选取的斐波那契数字的数目减少 $1$ 个，比选取 $F_x$ 和 $F_{x + 1}$ 的方案更优。\n\n2. 一定存在一种选取斐波那契数字数目最少的方案，使得选取的每个斐波那契数字各不相同。\n\n   假设 $F_x$ 被选取了两次。当 $x \\le 2$ 时，$F_x = 1$，可以用 $F_3 = 2$ 代替两个 $F_x$，此时选取的斐波那契数字的数目减少 $1$ 个。当 $x > 2$ 时，存在以下关系：\n\n   $$2 \\times F_x = (F_{x - 2} + F_{x - 1}) + F_x = F_{x - 2} + (F_{x - 1} + F_x) = F_{x - 2} + F_{x + 1}$$\n\n   因此当 $x > 2$ 时，如果 $F_x$ 被选取了两次，则可以换成 $F_{x - 2}$ 和 $F_{x + 1}$。\n\n3. 根据上述两个结论，必须选取不超过 $k$ 的最大斐波那契数字，才能使得选取的斐波那契数字满足和为 $k$ 且数目最少。\n\n   用 $F_m$ 表示不超过 $k$ 的最大斐波那契数字。如果不选择 $F_m$，则考虑选取的斐波那契数字之和可能的最大值，记为 $N$。根据上述两个结论，选取的斐波那契数字中不存在相邻的斐波那契数字，也不存在重复的斐波那契数字，因此可以得到 $N$ 的表达式：\n\n   $$\n   N = \\begin{cases}\n   F_{m - 1} + F_{m - 3} + \\ldots + F_4 + F_2, &m~是奇数 \\\\\n   F_{m - 1} + F_{m - 3} + \\ldots + F_3 + F_1, &m~是偶数\n   \\end{cases}\n   $$\n\n   当 $m$ 是奇数时，$N$ 的值计算如下：\n\n   $$\n   \\begin{aligned}\n   N &= F_{m - 1} + F_{m - 3} + \\ldots + F_4 + F_2 \\\\\n   &= F_{m - 1} + F_{m - 3} + \\ldots + F_4 + F_2 + F_1 - F_1 \\\\\n   &= F_{m - 1} + F_{m - 3} + \\ldots + F_4 + F_3 - F_1 \\\\\n   &= F_{m - 1} + F_{m - 3} + \\ldots + F_5 - F_1 \\\\\n   &= \\ldots \\\\\n   &= F_{m - 1} + F_{m - 2} - F_1 \\\\\n   &= F_m - 1 \\\\\n   &< F_m\n   \\end{aligned}\n   $$\n\n   此时 $N < F_m$，由于 $F_m \\le k$，因此 $N < k$。如果不选择 $F_m$，则选取的斐波那契数字之和一定小于 $k$，因此必须选择 $F_m$。\n\n   当 $m$ 是偶数时，$N$ 的值计算如下：\n\n   $$\n   \\begin{aligned}\n   N &= F_{m - 1} + F_{m - 3} + \\ldots + F_3 + F_1 \\\\\n   &= F_{m - 1} + F_{m - 3} + \\ldots + F_3 + F_2 \\\\\n   &= F_{m - 1} + F_{m - 3} + \\ldots + F_4 \\\\\n   &= \\ldots \\\\\n   &= F_{m - 1} + F_{m - 2} \\\\\n   &= F_m\n   \\end{aligned}\n   $$\n\n   此时 $N = F_m$，$\\dfrac{m}{2}$ 个斐波那契数字之和等于 $F_m$，用一个 $F_m$ 替换 $\\dfrac{m}{2}$ 个斐波那契数字，选取的斐波那契数字数目不变或减少（只有当 $m = 2$ 时，选取的斐波那契数字数目不变）。\n\n   综上所述，无论 $m$ 是奇数还是偶数，都需要选取 $F_m$，即不超过 $k$ 的最大斐波那契数字，才能使得选取的斐波那契数字满足和为 $k$ 且数目最少。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findMinFibonacciNumbers(self, k: int) -> int:\n        f = [1, 1]\n        while f[-1] < k:\n            f.append(f[-1] + f[-2])\n        ans, i = 0, len(f) - 1\n        while k:\n            if k >= f[i]:\n                k -= f[i]\n                ans += 1\n            i -= 1\n        return ans\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findMinFibonacciNumbers(int k) {\n        List<Integer> f = new ArrayList<Integer>();\n        f.add(1);\n        int a = 1, b = 1;\n        while (a + b <= k) {\n            int c = a + b;\n            f.add(c);\n            a = b;\n            b = c;\n        }\n        int ans = 0;\n        for (int i = f.size() - 1; i >= 0 && k > 0; i--) {\n            int num = f.get(i);\n            if (k >= num) {\n                k -= num;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindMinFibonacciNumbers(int k) {\n        IList<int> f = new List<int>();\n        f.Add(1);\n        int a = 1, b = 1;\n        while (a + b <= k) {\n            int c = a + b;\n            f.Add(c);\n            a = b;\n            b = c;\n        }\n        int ans = 0;\n        for (int i = f.Count - 1; i >= 0 && k > 0; i--) {\n            int num = f[i];\n            if (k >= num) {\n                k -= num;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findMinFibonacciNumbers(int k) {\n        vector<int> f;\n        f.emplace_back(1);\n        int a = 1, b = 1;\n        while (a + b <= k) {\n            int c = a + b;\n            f.emplace_back(c);\n            a = b;\n            b = c;\n        }\n        int ans = 0;\n        for (int i = f.size() - 1; i >= 0 && k > 0; i--) {\n            int num = f[i];\n            if (k >= num) {\n                k -= num;\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C [sol1-C]\nint findMinFibonacciNumbers(int k){\n    int f[100];\n    int pos = 0;\n    f[pos++] = 1;\n    int a = 1, b = 1;\n    while (a + b <= k) {\n        int c = a + b;\n        f[pos++] = c;\n        a = b;\n        b = c;\n    }\n    int ans = 0;\n    for (int i = pos - 1; i >= 0 && k > 0; i--) {\n        int num = f[i];\n        if (k >= num) {\n            k -= num;\n            ans++;\n        }\n    }\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc findMinFibonacciNumbers(k int) (ans int) {\n    f := []int{1, 1}\n    for f[len(f)-1] < k {\n        f = append(f, f[len(f)-1]+f[len(f)-2])\n    }\n    for i := len(f) - 1; k > 0; i-- {\n        if k >= f[i] {\n            k -= f[i]\n            ans++\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findMinFibonacciNumbers = function(k) {\n    const f = [1];\n    let a = 1, b = 1;\n    while (a + b <= k) {\n        let c = a + b;\n        f.push(c);\n        a = b;\n        b = c;\n    }\n    let ans = 0;\n    for (let i = f.length - 1; i >= 0 && k > 0; i--) {\n        const num = f[i];\n        if (k >= num) {\n            k -= num;\n            ans++;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log k)$，其中 $k$ 为给定的整数。需要找到所有不超过 $k$ 的斐波那契数字，然后计算和为 $k$ 的最少斐波那契数字数目，不超过 $k$ 的斐波那契数字的个数是 $O(\\log k)$ 个。\n\n- 空间复杂度：$O(\\log k)$，其中 $k$ 为给定的整数。需要 $O(\\log k)$ 的空间存储所有不超过 $k$ 的斐波那契数字。"
}