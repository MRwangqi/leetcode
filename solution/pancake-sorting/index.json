{
	"titleSlug": "pancake-sorting",
	"slug": "jian-bing-pai-xu-by-leetcode-solution-rzzu",
	"url": "https://leetcode-cn.com/problems/pancake-sorting/solution/jian-bing-pai-xu-by-leetcode-solution-rzzu/",
	"content": "#### 前言\n\n煎饼排序的相关背景内容可以参考百度百科「[煎饼排序](https://baike.baidu.com/item/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F)」。2011年，劳伦特·比尔托（Laurent Bulteau）、纪尧姆·佛丁（Guillaume Fertin）和伊雷娜·鲁苏（Irena Rusu）证明了给定一叠煎饼的长度分布，找到最短解法是 NP 困难的，参考论文「[Bulteau, Laurent; Fertin, Guillaume; Rusu, Irena. Pancake Flipping Is Hard. Journal of Computer and System Sciences: 1556–1574.](https://arxiv.org/abs/1111.0434v1)」。\n\n#### 方法一：类选择排序\n\n**思路与算法**\n\n设一个元素的下标是 $\\textit{index}$，我们可以通过两次煎饼排序将它放到尾部：\n\n+ 第一步选择 $k = \\textit{index} + 1$，然后反转子数组 $\\textit{arr}[0 ... k - 1]$，此时该元素已经被放到首部。\n\n+ 第二步选择 $k = \\textit{n}$，其中 $\\textit{n}$ 是数组 $\\textit{arr}$ 的长度，然后反转整个数组，此时该元素已经被放到尾部。\n\n通过以上两步操作，我们可以将当前数组的最大值放到尾部，然后将去掉尾部元素的数组作为新的处理对象，重复以上操作，直到处理对象的长度等于一，此时原数组已经完成排序，且需要的总操作数是 $2 \\times (n - 1)$，符合题目要求。如果最大值已经在尾部，我们可以省略对应的操作。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> pancakeSort(vector<int>& arr) {\n        vector<int> ret;\n        for (int n = arr.size(); n > 1; n--) {\n            int index = max_element(arr.begin(), arr.begin() + n) - arr.begin();\n            if (index == n - 1) {\n                continue;\n            }\n            reverse(arr.begin(), arr.begin() + index + 1);\n            reverse(arr.begin(), arr.begin() + n);\n            ret.push_back(index + 1);\n            ret.push_back(n);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> pancakeSort(int[] arr) {\n        List<Integer> ret = new ArrayList<Integer>();\n        for (int n = arr.length; n > 1; n--) {\n            int index = 0;\n            for (int i = 1; i < n; i++) {\n                if (arr[i] >= arr[index]) {\n                    index = i;\n                }\n            }\n            if (index == n - 1) {\n                continue;\n            }\n            reverse(arr, index);\n            reverse(arr, n - 1);\n            ret.add(index + 1);\n            ret.add(n);\n        }\n        return ret;\n    }\n\n    public void reverse(int[] arr, int end) {\n        for (int i = 0, j = end; i < j; i++, j--) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> PancakeSort(int[] arr) {\n        IList<int> ret = new List<int>();\n        for (int n = arr.Length; n > 1; n--) {\n            int index = 0;\n            for (int i = 1; i < n; i++) {\n                if (arr[i] >= arr[index]) {\n                    index = i;\n                }\n            }\n            if (index == n - 1) {\n                continue;\n            }\n            Reverse(arr, index);\n            Reverse(arr, n - 1);\n            ret.Add(index + 1);\n            ret.Add(n);\n        }\n        return ret;\n    }\n\n    public void Reverse(int[] arr, int end) {\n        for (int i = 0, j = end; i < j; i++, j--) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n}\n```\n\n```C [sol1-C]\nvoid reverse(int *arr, int arrSize) {\n    for (int left = 0, right = arrSize - 1; left < right; left++, right--) {\n        int tmp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = tmp;\n    }\n}\n\nint *pancakeSort(int *arr, int arrSize, int *returnSize){\n    int *ret = (int *)malloc(sizeof(int) * (arrSize - 1) * 2);\n    int retSize = 0;\n    for (int n = arrSize; n > 1; n--) {\n        int index = 0;\n        for (int i = 1; i < n; i++) {\n            if (arr[i] >= arr[index]) {\n                index = i;\n            }\n        }\n        if (index == n - 1) {\n            continue;\n        }\n        reverse(arr, index + 1);\n        reverse(arr, n);\n        ret[retSize++] = index + 1;\n        ret[retSize++] = n;\n    }\n    *returnSize = retSize;\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar pancakeSort = function(arr) {\n    const ret = [];\n    for (let n = arr.length; n > 1; n--) {\n        let index = 0;\n        for (let i = 1; i < n; i++) {\n            if (arr[i] >= arr[index]) {\n                index = i;\n            }\n        }\n        if (index === n - 1) {\n            continue;\n        }\n        reverse(arr, index);\n        reverse(arr, n - 1);\n        ret.push(index + 1);\n        ret.push(n);\n    }\n    return ret;\n}\n\nconst reverse = (arr, end) => {\n    for (let i = 0, j = end; i < j; i++, j--) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        ans = []\n        for n in range(len(arr), 1, -1):\n            index = 0\n            for i in range(n):\n                if arr[i] > arr[index]:\n                    index = i\n            if index == n - 1:\n                continue\n            m = index\n            for i in range((m + 1) // 2):\n                arr[i], arr[m - i] = arr[m - i], arr[i]  # 原地反转\n            for i in range(n // 2):\n                arr[i], arr[n - 1 - i] = arr[n - 1 - i], arr[i]  # 原地反转\n            ans.append(index + 1)\n            ans.append(n)\n        return ans\n```\n\n```go [sol1-Golang]\nfunc pancakeSort(arr []int) (ans []int) {\n    for n := len(arr); n > 1; n-- {\n        index := 0\n        for i, v := range arr[:n] {\n            if v > arr[index] {\n                index = i\n            }\n        }\n        if index == n-1 {\n            continue\n        }\n        for i, m := 0, index; i < (m+1)/2; i++ {\n            arr[i], arr[m-i] = arr[m-i], arr[i]\n        }\n        for i := 0; i < n/2; i++ {\n            arr[i], arr[n-1-i] = arr[n-1-i], arr[i]\n        }\n        ans = append(ans, index+1, n)\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n^2)$，其中 $n$ 是数组 $\\textit{arr}$ 的大小。总共执行至多 $n - 1$ 次查找最大值，至多 $2 \\times (n - 1)$ 次反转数组，而查找最大值的时间复杂度是 $O(n)$，反转数组的时间复杂度是 $O(n)$，因此总时间复杂度是 $O(n^2)$。\n\n+ 空间复杂度：$O(1)$。返回值不计入空间复杂度。"
}