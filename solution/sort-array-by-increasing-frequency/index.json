{
	"titleSlug": "sort-array-by-increasing-frequency",
	"slug": "an-zhao-pin-lu-jiang-shu-zu-sheng-xu-pai-z2db",
	"url": "https://leetcode-cn.com/problems/sort-array-by-increasing-frequency/solution/an-zhao-pin-lu-jiang-shu-zu-sheng-xu-pai-z2db/",
	"content": "#### 方法一：模拟\n\n**思路**\n\n按着题目的要求，先算出数组 $\\textit{nums}$ 中各元素的频率，然后按照元素频率和数值对数组进行排序即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def frequencySort(self, nums: List[int]) -> List[int]:\n        cnt = Counter(nums)\n        nums.sort(key=lambda x: (cnt[x], -x))\n        return nums\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] frequencySort(int[] nums) {\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            cnt.put(num, cnt.getOrDefault(num, 0) + 1);\n        }\n        List<Integer> list = new ArrayList<Integer>();\n        for (int num : nums) {\n            list.add(num);\n        }\n        Collections.sort(list, (a, b) -> {\n            int cnt1 = cnt.get(a), cnt2 = cnt.get(b);\n            return cnt1 != cnt2 ? cnt1 - cnt2 : b - a;\n        });\n        int length = nums.length;\n        for (int i = 0; i < length; i++) {\n            nums[i] = list.get(i);\n        }\n        return nums;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] FrequencySort(int[] nums) {\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        foreach (int num in nums) {\n            cnt.TryAdd(num, 0);\n            cnt[num]++;\n        }\n        List<int> list = new List<int>();\n        foreach (int num in nums) {\n            list.Add(num);\n        }\n        list.Sort((a, b) => {\n            int cnt1 = cnt[a], cnt2 = cnt[b];\n            return cnt1 != cnt2 ? cnt1 - cnt2 : b - a;\n        });\n        return list.ToArray();\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> frequencySort(vector<int>& nums) {\n        unordered_map<int, int> cnt;\n        for (int num : nums) {\n            cnt[num]++;\n        }\n        sort(nums.begin(), nums.end(), [&](const int a, const int b) {\n            if (cnt[a] != cnt[b]) {\n                return cnt[a] < cnt[b];\n            }\n            return a > b;\n        });\n        return nums;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} HashItem; \n\nHashItem *hashFindItem(HashItem **obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nbool hashAddItem(HashItem **obj, int key, int val) {\n    if (hashFindItem(obj, key)) {\n        return false;\n    }\n    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = key;\n    pEntry->val = val;\n    HASH_ADD_INT(*obj, key, pEntry);\n    return true;\n}\n\nbool hashSetItem(HashItem **obj, int key, int val) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        hashAddItem(obj, key, val);\n    } else {\n        pEntry->val = val;\n    }\n    return true;\n}\n\nint hashGetItem(HashItem **obj, int key, int defaultVal) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        return defaultVal;\n    }\n    return pEntry->val;\n}\n\nvoid hashFree(HashItem **obj) {\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);             \n    }\n}\n\nHashItem *cnt = NULL;\n\nstatic inline int cmp(const void *pa, const void *pb) {\n    int a = *(int *)pa;\n    int b = *(int *)pb;\n    int cnta = hashGetItem(&cnt, a, 0);\n    int cntb = hashGetItem(&cnt, b, 0);\n    if (cnta != cntb) {\n        return cnta - cntb;\n    }\n    return b - a;\n}\n\nint* frequencySort(int* nums, int numsSize, int* returnSize) {\n    cnt = NULL;\n    for (int i = 0; i < numsSize; i++) {\n        hashSetItem(&cnt, nums[i], hashGetItem(&cnt, nums[i], 0) + 1);\n    }\n    qsort(nums, numsSize, sizeof(int), cmp);\n    hashFree(&cnt);\n    *returnSize = numsSize;\n    return nums;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar frequencySort = function(nums) {\n    const cnt = new Map();\n    for (const num of nums) {\n        cnt.set(num, (cnt.get(num) || 0) + 1);\n    }\n    const list = [...nums];\n    list.sort((a, b) => {\n        const cnt1 = cnt.get(a), cnt2 = cnt.get(b);\n        return cnt1 !== cnt2 ? cnt1 - cnt2 : b - a;\n    });\n    const length = nums.length;\n    for (let i = 0; i < length; i++) {\n        nums[i] = list[i];\n    }\n    return nums;\n};\n```\n\n```go [sol1-Golang]\nfunc frequencySort(nums []int) []int {\n    cnt := map[int]int{}\n    for _, x := range nums {\n        cnt[x]++\n    }\n    sort.Slice(nums, func(i, j int) bool {\n        a, b := nums[i], nums[j]\n        return cnt[a] < cnt[b] || cnt[a] == cnt[b] && a > b\n    })\n    return nums\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。排序消耗 $O(n \\log n)$ 时间。\n\n- 空间复杂度：$O(n)$，存储数组元素频率的哈希表消耗 $O(n)$ 空间。"
}