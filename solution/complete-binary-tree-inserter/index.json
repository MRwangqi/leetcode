{
	"titleSlug": "complete-binary-tree-inserter",
	"slug": "wan-quan-er-cha-shu-cha-ru-qi-by-leetcod-lf8t",
	"url": "https://leetcode-cn.com/problems/complete-binary-tree-inserter/solution/wan-quan-er-cha-shu-cha-ru-qi-by-leetcod-lf8t/",
	"content": "#### 方法一：队列\n\n**思路与算法**\n\n对于一棵完全二叉树而言，其除了最后一层之外都是完全填充的，并且最后一层的节点全部在最左侧。那么，只有倒数第二层（如果存在）最右侧的若干个节点，以及最后一层的全部节点可以再添加子节点，其余的节点都已经拥有两个子节点。\n\n因此，我们可以使用一个队列存储上述提到的这些可以添加子节点的节点。队列中的存储顺序为：首先「从左往右」存储倒数第二层最右侧的节点，再「从左往右」存储最后一层的全部节点。这一步可以使用广度优先搜索来完成，因为广度优先搜索就是按照层优先进行遍历的。\n\n随后，当我们每次调用 $\\text{insert(val)}$ 时，我们就创建出一个节点 $\\textit{child}$，并将它作为队列的队首节点的子节点。在这之后，我们需要把 $\\textit{child}$ 加入队尾，并且如果对队首节点已经有两个子节点，我们需要将其从队列中移除。\n\n**代码**\n\n```C++ [sol1-C++]\nclass CBTInserter {\npublic:\n    CBTInserter(TreeNode* root) {\n        this->root = root;\n\n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while (!q.empty()) {\n            TreeNode* node = q.front();\n            q.pop();\n            if (node->left) {\n                q.push(node->left);\n            }\n            if (node->right) {\n                q.push(node->right);\n            }\n            if (!(node->left && node->right)) {\n                candidate.push(node);\n            }\n        }\n    }\n    \n    int insert(int val) {\n        TreeNode* child = new TreeNode(val);\n        TreeNode* node = candidate.front();\n        int ret = node->val;\n        if (!node->left) {\n            node->left = child;\n        }\n        else {\n            node->right = child;\n            candidate.pop();\n        }\n        candidate.push(child);\n        return ret;\n    }\n    \n    TreeNode* get_root() {\n        return root;\n    }\n\nprivate:\n    queue<TreeNode*> candidate;\n    TreeNode* root;\n};\n```\n\n```Java [sol1-Java]\nclass CBTInserter {\n    Queue<TreeNode> candidate;\n    TreeNode root;\n\n    public CBTInserter(TreeNode root) {\n        this.candidate = new ArrayDeque<TreeNode>();\n        this.root = root;\n\n        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node.left != null) {\n                queue.offer(node.left);\n            }\n            if (node.right != null) {\n                queue.offer(node.right);\n            }\n            if (!(node.left != null && node.right != null)) {\n                candidate.offer(node);\n            }\n        }\n    }\n\n    public int insert(int val) {\n        TreeNode child = new TreeNode(val);\n        TreeNode node = candidate.peek();\n        int ret = node.val;\n        if (node.left == null) {\n            node.left = child;\n        } else {\n            node.right = child;\n            candidate.poll();\n        }\n        candidate.offer(child);\n        return ret;\n    }\n\n    public TreeNode get_root() {\n        return root;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class CBTInserter {\n    Queue<TreeNode> candidate;\n    TreeNode root;\n\n    public CBTInserter(TreeNode root) {\n        this.candidate = new Queue<TreeNode>();\n        this.root = root;\n\n        Queue<TreeNode> queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n\n        while (queue.Count > 0) {\n            TreeNode node = queue.Dequeue();\n            if (node.left != null) {\n                queue.Enqueue(node.left);\n            }\n            if (node.right != null) {\n                queue.Enqueue(node.right);\n            }\n            if (!(node.left != null && node.right != null)) {\n                candidate.Enqueue(node);\n            }\n        }\n    }\n\n    public int Insert(int val) {\n        TreeNode child = new TreeNode(val);\n        TreeNode node = candidate.Peek();\n        int ret = node.val;\n        if (node.left == null) {\n            node.left = child;\n        } else {\n            node.right = child;\n            candidate.Dequeue();\n        }\n        candidate.Enqueue(child);\n        return ret;\n    }\n\n    public TreeNode Get_root() {\n        return root;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass CBTInserter:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.candidate = deque()\n\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n            if not (node.left and node.right):\n                self.candidate.append(node)\n\n    def insert(self, val: int) -> int:\n        candidate_ = self.candidate\n\n        child = TreeNode(val)\n        node = candidate_[0]\n        ret = node.val\n        \n        if not node.left:\n            node.left = child\n        else:\n            node.right = child\n            candidate_.popleft()\n        \n        candidate_.append(child)\n        return ret\n\n    def get_root(self) -> TreeNode:\n        return self.root\n```\n\n```C [sol1-C]\ntypedef struct DLinkListNode {\n    struct TreeNode *val;\n    struct DLinkListNode *prev, *next;\n} DLinkListNode;\n\ntypedef struct {\n    DLinkListNode *head, *tail;\n    int size;\n} Deque;\n\nDLinkListNode * dLinkListNodeCreat(struct TreeNode* val) {\n    DLinkListNode *obj = (DLinkListNode *)malloc(sizeof(DLinkListNode));\n    obj->val = val;\n    obj->prev = NULL;\n    obj->next = NULL;\n    return obj;\n} \n\nDeque* dequeCreate() {\n    Deque *obj = (Deque *)malloc(sizeof(Deque));\n    obj->size = 0;\n    obj->head = obj->tail = NULL;\n    return obj;\n}\n\nbool dequeInsertFront(Deque* obj, struct TreeNode* value) {\n    DLinkListNode *node = dLinkListNodeCreat(value);\n    if (obj->size == 0) {\n        obj->head = obj->tail = node;\n    } else {\n        node->next = obj->head;\n        obj->head->prev = node;\n        obj->head = node;\n    }\n    obj->size++;\n    return true;\n}\n\nbool dequeInsertLast(Deque* obj, struct TreeNode* value) {\n    DLinkListNode *node = dLinkListNodeCreat(value);\n    if (obj->size == 0) {\n        obj->head = obj->tail = node;\n    } else {\n        obj->tail->next = node;\n        node->prev = obj->tail;\n        obj->tail = node;\n    }\n    obj->size++;\n    return true;\n}\n\nbool dequeDeleteFront(Deque* obj) {\n    if (obj->size == 0) {\n        return false;\n    }\n    DLinkListNode *node = obj->head;\n    obj->head = obj->head->next;\n    if (obj->head) {\n        obj->head->prev = NULL;\n    }\n    free(node);\n    obj->size--;\n    return true;\n}\n\nbool dequeDeleteLast(Deque* obj) {\n    if (obj->size == 0) {\n        return false;\n    }\n    DLinkListNode *node = obj->tail;\n    obj->tail = obj->tail->prev;\n    if (obj->tail) {\n        obj->tail->next = NULL;\n    }\n    free(node);\n    obj->size--;\n    return true;\n}\n\nstruct TreeNode* dequeGetFront(Deque* obj) {\n    if (obj->size == 0) {\n        return NULL;\n    }\n    return obj->head->val;\n}\n\nstruct TreeNode* dequeGetRear(Deque* obj) {\n    if (obj->size == 0) {\n        return NULL;\n    }\n    return obj->tail->val;\n}\n\nbool dequeIsEmpty(Deque* obj) {\n    return obj->size == 0;\n}\n\nvoid dequeFree(Deque* obj) {\n    for (DLinkListNode *curr = obj->head; curr;) {\n        DLinkListNode *node = curr;\n        curr = curr->next;\n        free(node);\n    }\n    free(obj);\n}\n\ntypedef struct {\n    Deque* candidate;\n    struct TreeNode* root;\n} CBTInserter;\n\n\nCBTInserter* cBTInserterCreate(struct TreeNode* root) {\n    CBTInserter *obj = (CBTInserter *)malloc(sizeof(CBTInserter));\n    obj->candidate = dequeCreate();\n    obj->root = root;\n    Deque *q = dequeCreate();\n    dequeInsertLast(q, root);\n    while (!dequeIsEmpty(q)) {\n        struct TreeNode* node = dequeGetFront(q);\n        dequeDeleteFront(q);\n        if (node->left) {\n            dequeInsertLast(q, node->left);\n        }\n        if (node->right) {\n            dequeInsertLast(q, node->right);\n        }\n        if (!(node->left && node->right)) {\n            dequeInsertLast(obj->candidate, node);\n        }\n    }\n    return obj;\n}\n\nint cBTInserterInsert(CBTInserter* obj, int val) {\n    struct TreeNode* child = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n    child->val = val;\n    child->left = NULL;\n    child->right = NULL;\n    struct TreeNode* node = dequeGetFront(obj->candidate);\n    int ret = node->val;\n    if (!node->left) {\n        node->left = child;\n    } else {\n        node->right = child;\n        dequeDeleteFront(obj->candidate);\n    }\n    dequeInsertLast(obj->candidate, child);\n    return ret;\n}\n\nstruct TreeNode* cBTInserterGet_root(CBTInserter* obj) {\n    return obj->root;\n}\n\nvoid cBTInserterFree(CBTInserter* obj) {\n    dequeFree(obj->candidate);\n    free(obj);\n}\n```\n\n```go [sol1-Golang]\ntype CBTInserter struct {\n    root      *TreeNode\n    candidate []*TreeNode\n}\n\nfunc Constructor(root *TreeNode) CBTInserter {\n    q := []*TreeNode{root}\n    candidate := []*TreeNode{}\n    for len(q) > 0 {\n        node := q[0]\n        q = q[1:]\n        if node.Left != nil {\n            q = append(q, node.Left)\n        }\n        if node.Right != nil {\n            q = append(q, node.Right)\n        }\n        if node.Left == nil || node.Right == nil {\n            candidate = append(candidate, node)\n        }\n    }\n    return CBTInserter{root, candidate}\n}\n\nfunc (c *CBTInserter) Insert(val int) int {\n    child := &TreeNode{Val: val}\n    node := c.candidate[0]\n    if node.Left == nil {\n        node.Left = child\n    } else {\n        node.Right = child\n        c.candidate = c.candidate[1:]\n    }\n    c.candidate = append(c.candidate, child)\n    return node.Val\n}\n\nfunc (c *CBTInserter) Get_root() *TreeNode {\n    return c.root\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar CBTInserter = function(root) {\n    this.candidate = [];\n    this.root = root;\n\n    const queue = [];\n    queue.push(root);\n\n    while (queue.length) {\n        const node = queue.shift();\n        if (node.left) {\n            queue.push(node.left);\n        }\n        if (node.right) {\n            queue.push(node.right);\n        }\n        if (!(node.left && node.right)) {\n            this.candidate.push(node);\n        }\n    }\n};\n\nCBTInserter.prototype.insert = function(val) {\n    const child = new TreeNode(val);\n    const node = this.candidate[0];\n    let ret = node.val;\n    if (!node.left) {\n        node.left = child;\n    } else {\n        node.right = child;\n        this.candidate.shift();\n    }\n    this.candidate.push(child);\n    return ret;\n};\n\nCBTInserter.prototype.get_root = function() {\n    return this.root;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化 $\\text{CBTInserter(root)}$ 需要的时间为 $O(n)$，其中 $n$ 是给定的初始完全二叉树的节点个数。$\\text{insert(v)}$ 和 $\\text{get\\_root()}$ 的时间复杂度均为 $O(1)$。\n\n- 空间复杂度：$O(n+q)$，其中 $q$ 是 $\\text{insert(v)}$ 的调用次数。在调用了 $q$ 次 $\\text{insert(v)}$ 后，完全二叉树中有 $n+q$ 个节点，其中有一半的节点在队列中，需要 $O(n+q)$ 的空间。\n\n#### 方法二：二进制表示\n\n**思路与算法**\n\n如果我们将完全二叉树的每个节点进行编号，其中：\n\n- 根节点的编号为 $1$；\n\n- 如果某个节点的编号为 $x$，那么其左子节点的编号为 $2x$，右子节点的编号为 $2x+1$。\n\n那么我们可以发现，按照广度优先搜索的顺序，完全二叉树中的所有节点的编号是连续的。这可以用二进制表示看出：完全二叉树的第 $i (i \\geq 1)$ 层有 $2^{i-1}$ 个节点，它们的编号恰好对应着 $i$ 位的二进制表示，共有 $2^{i-1}$ 个（最高位必须为 $1$）。当某个节点编号为 $x$ 时，左子节点的编号 $2x$ 即为将 $x$ 的二进制表示左移一位后在最低位补 $0$，右子节点的编号即为将 $x$ 的二进制表示右移一位后在最低位补 $1$。\n\n因此，在初始化时，我们只需要使用深度优先搜索或者广度优先搜索，得到初始完全二叉树中的节点个数。在调用 $\\text{insert(v)}$ 时，我们可以知道它的编号 $x$，那么就可以从高到低遍历 $x$ 的每一个二进制位（忽略最高位的 $1$），如果为 $0$ 就往左子节点移动，否则往右子节点移动，这样就可以到达节点需要被插入的位置。\n\n**代码**\n\n```C++ [sol2-C++]\nclass CBTInserter {\npublic:\n    CBTInserter(TreeNode* root) {\n        this->root = root;\n\n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while (!q.empty()) {\n            ++cnt;\n            TreeNode* node = q.front();\n            q.pop();\n            if (node->left) {\n                q.push(node->left);\n            }\n            if (node->right) {\n                q.push(node->right);\n            }\n        }\n    }\n    \n    int insert(int val) {\n        ++cnt;\n        TreeNode* child = new TreeNode(val);\n        TreeNode* node = root;\n        int highbit = 31 - __builtin_clz(cnt);\n        for (int i = highbit - 1; i >= 1; --i) {\n            if (cnt & (1 << i)) {\n                node = node->right;\n            }\n            else {\n                node = node->left;\n            }\n        }\n        if (cnt & 1) {\n            node->right = child;\n        }\n        else {\n            node->left = child;\n        }\n        return node->val;\n    }\n    \n    TreeNode* get_root() {\n        return root;\n    }\n\nprivate:\n    int cnt = 0;\n    TreeNode* root;\n};\n```\n\n```Java [sol2-Java]\nclass CBTInserter {\n    int cnt;\n    TreeNode root;\n\n    public CBTInserter(TreeNode root) {\n        this.cnt = 0;\n        this.root = root;\n\n        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();\n        queue.offer(root);\n        \n        while (!queue.isEmpty()) {\n            ++cnt;\n            TreeNode node = queue.poll();\n            if (node.left != null) {\n                queue.offer(node.left);\n            }\n            if (node.right != null) {\n                queue.offer(node.right);\n            }\n        }\n    }\n\n    public int insert(int val) {\n        ++cnt;\n        TreeNode child = new TreeNode(val);\n        TreeNode node = root;\n        int highbit = 31 - Integer.numberOfLeadingZeros(cnt);\n        for (int i = highbit - 1; i >= 1; --i) {\n            if ((cnt & (1 << i)) != 0) {\n                node = node.right;\n            } else {\n                node = node.left;\n            }\n        }\n        if ((cnt & 1) != 0) {\n            node.right = child;\n        } else {\n            node.left = child;\n        }\n        return node.val;\n    }\n\n    public TreeNode get_root() {\n        return root;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass CBTInserter:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.cnt = 0\n\n        q = deque([root])\n        while q:\n            self.cnt += 1\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    def insert(self, val: int) -> int:\n        self.cnt += 1\n\n        child = TreeNode(val)\n        node = self.root\n        highbit = self.cnt.bit_length() - 1\n\n        for i in range(highbit - 1, 0, -1):\n            if self.cnt & (1 << i):\n                node = node.right\n            else:\n                node = node.left\n        \n        if self.cnt & 1:\n            node.right = child\n        else:\n            node.left = child\n        \n        return node.val\n\n    def get_root(self) -> TreeNode:\n        return self.root\n```\n\n```C [sol2-C]\n#define MAX_NODE_SIZE 1000\n\ntypedef struct {\n    int cnt;\n    struct TreeNode* root;\n} CBTInserter;\n\nCBTInserter* cBTInserterCreate(struct TreeNode* root) {\n    CBTInserter *obj = (CBTInserter *)malloc(sizeof(CBTInserter));\n    obj->root = root;\n    obj->cnt = 0;\n    struct TreeNode **queue = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * MAX_NODE_SIZE);\n    int head = 0, tail = 0;\n    queue[tail++] = root;\n    while (head != tail) {\n        ++obj->cnt;\n        struct TreeNode* node = queue[head++];\n        if (node->left) {\n            queue[tail++] = node->left;\n        }\n        if (node->right) {\n            queue[tail++] = node->right;\n        }\n    }\n    free(queue);\n    return obj;\n}\n\nint cBTInserterInsert(CBTInserter* obj, int val) {\n    ++obj->cnt;\n    struct TreeNode* child = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    child->val = val;\n    child->left = NULL;\n    child->right = NULL;\n    struct TreeNode* node = obj->root;\n    int highbit = 31 - __builtin_clz(obj->cnt);\n    for (int i = highbit - 1; i >= 1; --i) {\n        if (obj->cnt & (1 << i)) {\n            node = node->right;\n        }\n        else {\n            node = node->left;\n        }\n    }\n    if (obj->cnt & 1) {\n        node->right = child;\n    }\n    else {\n        node->left = child;\n    }\n    return node->val;\n}\n\nstruct TreeNode* cBTInserterGet_root(CBTInserter* obj) {\n    return obj->root;\n}\n\nvoid cBTInserterFree(CBTInserter* obj) {\n    free(obj);\n}\n```\n\n```go [sol2-Golang]\ntype CBTInserter struct {\n    root *TreeNode\n    cnt  int\n}\n\nfunc Constructor(root *TreeNode) CBTInserter {\n    q := []*TreeNode{root}\n    cnt := 0\n    for len(q) > 0 {\n        cnt++\n        node := q[0]\n        q = q[1:]\n        if node.Left != nil {\n            q = append(q, node.Left)\n        }\n        if node.Right != nil {\n            q = append(q, node.Right)\n        }\n    }\n    return CBTInserter{root, cnt}\n}\n\nfunc (c *CBTInserter) Insert(val int) int {\n    c.cnt++\n    child := &TreeNode{Val: val}\n    node := c.root\n    for i := bits.Len(uint(c.cnt)) - 2; i > 0; i-- {\n        if c.cnt>>i&1 == 0 {\n            node = node.Left\n        } else {\n            node = node.Right\n        }\n    }\n    if c.cnt&1 == 0 {\n        node.Left = child\n    } else {\n        node.Right = child\n    }\n    return node.Val\n}\n\nfunc (c *CBTInserter) Get_root() *TreeNode {\n    return c.root\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar CBTInserter = function(root) {\n    this.cnt = 0;\n    this.root = root;\n\n    const queue = [];\n    queue.push(root);\n    \n    while (queue.length) {\n        ++this.cnt;\n        const node = queue.shift();\n        if (node.left) {\n            queue.push(node.left);\n        }\n        if (node.right) {\n            queue.push(node.right);\n        }\n    }\n};\n\nCBTInserter.prototype.insert = function(val) {\n    ++this.cnt;\n    const child = new TreeNode(val);\n    let node = this.root;\n    const highbit = ('' + this.cnt.toString(2)).length - 1;\n    for (let i = highbit - 1; i >= 1; --i) {\n        if ((this.cnt & (1 << i)) !== 0) {\n            node = node.right;\n        } else {\n            node = node.left;\n        }\n    }\n    if ((this.cnt & 1) !== 0) {\n        node.right = child;\n    } else {\n        node.left = child;\n    }\n    return node.val;\n};\n\nCBTInserter.prototype.get_root = function() {\n    return this.root;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化 $\\text{CBTInserter(root)}$ 需要的时间为 $O(n)$，其中 $n$ 是给定的初始完全二叉树的节点个数。这里也可以通过 [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/) 中的方法优化到 $O(\\log^2 n)$。$\\text{insert(v)}$ 需要的时间为 $O(\\log (n+q))$，其中 $q$ 是 $\\text{insert(v)}$ 的调用次数。$\\text{get\\_root()}$ 的时间复杂度为 $O(1)$。\n\n- 空间复杂度：初始化 $\\text{CBTInserter(root)}$ 需要的空间为 $O(n)$。如果使用优化方法，空间可以降低到 $O(\\log n)$。其它所有函数调用都只需要 $O(1)$ 的空间。"
}