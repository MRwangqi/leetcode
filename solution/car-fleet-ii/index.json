{
	"titleSlug": "car-fleet-ii",
	"slug": "by-cold-code-e-15m5",
	"url": "https://leetcode-cn.com/problems/car-fleet-ii/solution/by-cold-code-e-15m5/",
	"content": "# 前置题目\r\n853.车队 链接：https://leetcode.cn/problems/car-fleet/\r\n\r\n# 思考过程 **（比思路更重要的是如何产生这个思路）**\r\n## 题干理解\r\n1. 由于先做过前置题目*853.车队*因此惯性思维想到继续使用**单调栈**\r\n2. 关于“下一辆车”有两种理解，两种都是正确的，只是在不同场景下不同的理解可使问题更简单\r\n    - 理解一：由于相遇的车都会合并成一个车队，因此不会存在超车的现象，所以我们可以认为题目要求的“第i辆车与下一辆车相遇”直接理解为第i辆车与第i+1辆车相遇；这种理解有利于分析第i辆与第i+1辆拥有不同速度关系时能否追上\r\n    - 理解二：由于第i+1辆车可能被其前方速度慢的车挡住导致降速（假设这辆车是第k辆），则此时第i辆追到的第i+1辆是与第k辆同属一个车队的，因此相当于追上第k辆车，若第k辆是这个车队的车头，则说明只有它是以原速在行驶的，后面的车都是被它挡下后降速的；这种理解便于后续计算相遇时间\r\n## 相遇条件分析\r\n1. 本题对比于853.车队区别在于没有设置终点，因此，只要第i辆车的车速大于第i+1辆（即第i辆的下一辆），那么一定早晚能追上\r\n2. 那么若第i辆车的车速**小于等于**第i+1辆时是否一定追不上呢？不一定，是有追上的可能的，只要在第i+1前方的车辆中存在**车速小于第i辆**的，即可使第i辆车追上第i+1辆，原因如下：\r\n    - 假设从第i辆车向前进方向查找，**第一辆**速度小于Vi的车是第x辆，其车速为Vx\r\n    - 已知Vi<=Vi+1, Vi>Vx，那么Vi+1一定大于Vx，第i+1辆早晚会追上第x辆，并且速度降为和x相同（i+1与x之间速度比Vi+1大的都会被x拦下，速度比Vi+1小的都会被i+1追上）\r\n    - 当第i+1辆的速度降为和x相同（即为Vx）时，其速度就小于第i辆了，因此第i辆早晚能追上第i+1辆\r\n3. 根据上述分析，我们可以很快筛出相遇不了的车，并将其答案赋为-1；而能相遇的车的相遇时间的计算一定是距离差/速度差，关键在于它究竟与哪辆**按原速行驶的车**（即车队中的车头）相遇了（此处使用对于“下一辆车”的理解二）\r\n4. 这里强调找“按原速行驶的车”是为了准确计算距离差和速度差，因为只有这辆车的速度是没有变的，只要找到第i辆车与车队相遇时的车队的车头，则距离差就是第i辆与车头在出发时position的差；此处的核心是理解“每一辆车的速度都会不受其后方车辆的影响”，所以当某车排在第一个时，它的速度是没有变过的\r\n5. 因此，一句话总结相遇与否的规律：除非前面所有车车速均大于当前的车i，否则i一定早晚会追上前面的车\r\n## 思路一\r\n1. 分析至此，我们产生了一个基础思路（注：该思路存在漏洞，但hard题很难一步想到位，后面会分析该漏洞的发现&完善过程）\r\n    - 对于车i，从其位置向前进方向遍历，查找*第一辆比它速度慢的车*，用距离差/速度差求出时间\r\n    - 若前进方向不存在速度小于Vi的车，则说明不会相遇，答案为-1.00000\r\n### 漏洞：**第一辆比它速度慢的车≠相遇时按原速行驶的车**\r\n1. 发现契机：按上述思路完成的代码可以通过示例1，但挂在示例2上（cars = [[3,4],[5,4],[6,3],[9,1]]），预期答案是[2.00000,1.00000,1.50000,-1.00000]，但实际运行结果是[3.00000,1.00000,1.50000,-1.00000]\r\n2. 令该示例中的车从左至右为ABCD，推演该示例中出问题的A车发现，按上述思路，A车前进方向第一辆比它速度小的车是C，因此相遇时间是AC的距离差（6-3=3）除以AC的速度差（4-3=1），因此是3；但在这3秒内C车也是往前追赶的，C与D的距离差是3，速度差为2，相遇时间为1.5，小于A与C的相遇时间，因此在A追上C之前，C早已因为追上了D而降速了\r\n3. 至此，我们找到了上述思路中漏洞出现的原因，即前进方向小于当前车车速的第一辆车，并不一定是相遇时按原速行驶的车，因为它的前方也可能存在速度更小的车使其被拦下导致降速\r\n### 漏洞修补\r\n1. 在修补漏洞之前，我们首先要看，具备什么特征的示例会掉进这个漏洞中：首先，示例1没有出现过改问题；另外，如果我们将示例2改成cars = [[3,4],[5,4],[6,3],[39,1]]也不会出现问题，因为在A追上C时，C由于和D之间的距离较大，因此并没有因为追上D而降速。\r\n2. 所以我们假设相遇的两辆车是x追上y，追上的耗时是Txy，y的前进方向还有一辆z\r\n    - 如果x追上y时，y没有因追上其他的车导致降速，那么x与下一辆车相遇的时间就是x追上y所花费的时间，即Txy\r\n    - 若x追上y时，y已经因为追上z而降速，那么对于x来说，其与y的相遇时间又是多少呢？\r\n3. 一种方法：在每辆车车速和初始位置已知的情况，可以通过计算y与z相遇的时间得到y开始降速的时间，再用原始速度和新速度算出x追上y的时间\r\n4. 此方法虽然能计算出正确答案，但比较复杂，尤其是若z在被y追上前也追上了其他的车导致降速，前面的车不断追上更前的车，速度变化的次数太多会使计算愈发复杂，因此不如换一角度思考\r\n5. 方法二：我们回归最初的目的——找到相遇时**按原速行驶的车**，即找到**车头**，通过上述的分析，我们得知，相遇时车队的车头（原速的车）一定是某些车沿行驶方向找到的第一辆速度小于它们自身的车，即，相遇时的车头∈第一辆速度小的车\r\n6. 基于基础的单调栈思路，每当我们找到第一辆速度小的车时我们可以获取到这辆车的下标，这个下标就可以帮我们将整个车队用关键的几个点串起来，直到车头\r\n    - 比如A车找到的前进方向第一辆小于A车速度的车是C，C车找到E，E找到G，G则追不上下一辆车的话，G就是这段车队的车头\r\n7. 这样找到车头后，我们就又可以使用距离差/速度差来计算相遇时间了\r\n8. 需要注意的是，计算时需逆序进行，是因为影响原思路计算结果的就是前向的车是否曾经降过速，所以需要先计算最前方的车；而“后方的车永远不会影响前方车的车速”这一特征，这也保证了逆序计算的稳定性\r\n\r\n# 实现思路\r\n## 初始化\r\n1. 声明列表t，作为最终返回的答案，存储每辆车与下一辆车相遇的时间，长度等于cars，初始化为-1.00000\r\n    - 这样最终栈中剩余没能与下一辆相遇的车就不需要再做处理，可以直接是-1.00000\r\n2. 声明列表catch，存储每辆车相遇时其前进方向第一个速度小的车的下标，用于串起整个车队，从而找到车头，初始化为n\r\n    - 由于车下标从0开始，在处理后最终仍保持默认值n的就代表不会与前车相遇的，即为车头\r\n3. 声明列表stack，作为处理本题的核心数据结构——单调栈\r\n## 初步计算\r\n1. 遍历car列表（此处正序处理），针对每辆车i，在stack中从栈顶不断查找车速大于车i的车\r\n    1) 每找到一辆，就将该下标pop出（设为变量index），说明找到了第index辆车前进方向第一辆速度小于index的车，就是第i辆车\r\n    2) 计算index与i相遇的时间，存储在t[index]中\r\n    3) 将i存储在catch[index]中，用于后续查找车队车头\r\n    4) 将车i也加入单调栈stack中\r\n## 优化计算\r\n1. 逆序遍历cars列表，计算能相遇的车的真正相遇时间，令当前车的下标为i\r\n    1) 若t[i]==-1.00000，不用处理，因为这辆车不会与下一辆相遇\r\n    2) 若t[i]!=-1.00000，但t[catch[i]]==-1.00000，也不用处理，因为catch[i]表示当前车前向第一辆速度小的车（设这辆车为x），则t[x]zz则表示车x相遇的时间，当这个时间为-1.00000时，表示x不能与下一辆相遇，说明x已经是车头了，上一轮正序的计算时得到的答案就已经是i车相遇的真实时间，故不需要再次处理\r\n    3) 剩余需处理的情况为t[i]!=-1.00000 and t[catch[i]]!=-1.00000，表示车i会与前面的车catch[i]相遇，而车catch[i]也会与更前面的车相遇\r\n    4) 我们并不知道车i的前向究竟有多少辆车相遇过，因此这里使用不固定次数的while循环\r\n    5) 循环的终止条件：\r\n        ① 当找到某辆车的相遇时间是-1.00000时终止，说明我们找到了车头，或者\r\n        ② 当i的相遇时间早于（小于）catch[i]的相遇时间时终止，说明是i车先追上catch[i]的，即catch[i]被追上时就是车头，catch[i]追前车导致的降速发生在被i追上之后，因此并不影响i的相遇时间\r\n    6) 循环中的操作：通过catch不断往前找“车头”，每找到一个都更新t[i]的值，表示和更前面的“车头”的相遇时间，同时更新catch[i]，直到终止条件跳出循环\r\n2. 最终结束逆序遍历后返回列表t\r\n\r\n```\r\nclass Solution:\r\n    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:\r\n        n = len(cars)\r\n        t, catch = [-1.00000 for _ in range(n)], [n for _ in range(n)]\r\n        stack = list()\r\n        for i in range(n):\r\n            while stack and cars[stack[len(stack)-1]][1] > cars[i][1]:\r\n                index = stack.pop()\r\n                t[index] = float((cars[i][0]-cars[index][0])/(cars[index][1]-cars[i][1]))\r\n                catch[index] = i\r\n            stack.append(i)\r\n        for i in range(n-1, -1, -1):\r\n            if t[i] != -1.00000 and t[catch[i]] != -1.00000:\r\n                while t[catch[i]] < t[i] and t[catch[i]] != -1:\r\n                    t[i] = float((cars[ catch[catch[i]] ][0]-cars[i][0])/(cars[i][1]-cars[catch[catch[i]]][1]))\r\n                    catch[i] = catch[catch[i]]\r\n        return t\r\n```\r\n"
}