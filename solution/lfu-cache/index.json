{
	"titleSlug": "lfu-cache",
	"slug": "lfuhuan-cun-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/lfu-cache/solution/lfuhuan-cun-by-leetcode-solution/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![460. LFUç¼“å­˜.mp4](1e5e9b82-4b02-4e11-ab0c-cd51b31d5653)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n\n#### æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨ + å¹³è¡¡äºŒå‰æ ‘\n\n**è¯´æ˜**\n\næœ¬æ–¹æ³•éœ€è¦ä½¿ç”¨åˆ°ã€Œå¹³è¡¡äºŒå‰æ ‘ã€ã€‚åœ¨ C++ è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ `std::set` ç±»ä½œä¸ºå¹³è¡¡äºŒå‰æ ‘ï¼›åŒæ ·åœ¨ Java è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ `TreeSet`ã€‚ä½†æ˜¯åœ¨ Python è¯­è¨€ä¸­ï¼Œå¹¶æ²¡æœ‰å†…ç½®çš„åº“å¯ä»¥ç”¨æ¥æ¨¡æ‹Ÿå¹³è¡¡äºŒå‰æ ‘ã€‚\n\n**æ€è·¯å’Œç®—æ³•**\n\né¦–å…ˆæˆ‘ä»¬å®šä¹‰ç¼“å­˜çš„æ•°æ®ç»“æ„ï¼š\n\n```C++\nstruct Node {\n    int cnt;\n    int time;\n    int key, value;\n    \n    // æˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ª Node ç±»çš„æ¯”è¾ƒå‡½æ•°\n    // å°† cntï¼ˆä½¿ç”¨é¢‘ç‡ï¼‰ä½œä¸ºç¬¬ä¸€å…³é”®å­—ï¼Œtimeï¼ˆæœ€è¿‘ä¸€æ¬¡ä½¿ç”¨çš„æ—¶é—´ï¼‰ä½œä¸ºç¬¬äºŒå…³é”®å­—\n    // ä¸‹é¢æ˜¯ C++ è¯­è¨€çš„ä¸€ä¸ªæ¯”è¾ƒå‡½æ•°çš„ä¾‹å­\n    bool operator< (const Node& rhs) const {\n        return cnt == rhs.cnt ? time < rhs.time : cnt < rhs.cnt;\n    }\n};\n```\n\nå…¶ä¸­ `cnt` è¡¨ç¤ºç¼“å­˜ä½¿ç”¨çš„é¢‘ç‡ï¼Œ`time` è¡¨ç¤ºç¼“å­˜çš„ä½¿ç”¨æ—¶é—´ï¼Œ`key` å’Œ `value` è¡¨ç¤ºç¼“å­˜çš„é”®å€¼ã€‚\n\næ¯”è¾ƒç›´è§‚çš„æƒ³æ³•å°±æ˜¯æˆ‘ä»¬ç”¨å“ˆå¸Œè¡¨ `key_table` ä»¥é”® `key` ä¸ºç´¢å¼•å­˜å‚¨ç¼“å­˜ï¼Œå»ºç«‹ä¸€ä¸ªå¹³è¡¡äºŒå‰æ ‘ `S` æ¥ä¿æŒç¼“å­˜æ ¹æ® `(cntï¼Œtime)` åŒå…³é”®å­—ç”±äºã€‚åœ¨ C++ ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ STL æä¾›çš„ `std::set` ç±»ï¼Œ`set` èƒŒåçš„å®ç°æ˜¯çº¢é»‘æ ‘ï¼š\n\n- å¯¹äº `get(key)` æ“ä½œï¼Œæˆ‘ä»¬åªè¦æŸ¥çœ‹ä¸€ä¸‹å“ˆå¸Œè¡¨ `key_table` æ˜¯å¦æœ‰ `key` è¿™ä¸ªé”®å³å¯ï¼Œæœ‰çš„è¯éœ€è¦åŒæ—¶æ›´æ–°å“ˆå¸Œè¡¨å’Œé›†åˆä¸­è¯¥ç¼“å­˜çš„ä½¿ç”¨é¢‘ç‡ä»¥åŠä½¿ç”¨æ—¶é—´ï¼Œå¦åˆ™è¿”å› `-1`ã€‚ \n\n- å¯¹äº `put(key, value)` æ“ä½œï¼Œé¦–å…ˆéœ€è¦æŸ¥çœ‹ `key_table` ä¸­æ˜¯å¦å·²æœ‰å¯¹åº”çš„é”®å€¼ã€‚å¦‚æœæœ‰çš„è¯æ“ä½œåŸºæœ¬ç­‰åŒäº `get(key)`ï¼Œä¸åŒçš„æ˜¯éœ€è¦æ›´æ–°ç¼“å­˜çš„ `value` å€¼ã€‚å¦‚æœæ²¡æœ‰çš„è¯ç›¸å½“äºæ˜¯æ–°æ’å…¥ä¸€ä¸ªç¼“å­˜ï¼Œè¿™æ—¶å€™éœ€è¦å…ˆæŸ¥çœ‹æ˜¯å¦è¾¾åˆ°ç¼“å­˜å®¹é‡ `capacity`ï¼Œå¦‚æœè¾¾åˆ°äº†çš„è¯ï¼Œéœ€è¦åˆ é™¤æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„ç¼“å­˜ï¼Œå³å¹³è¡¡äºŒå‰æ ‘ä¸­æœ€å·¦è¾¹çš„ç»“ç‚¹ï¼ŒåŒæ—¶åˆ é™¤ `key_table` ä¸­å¯¹åº”çš„ç´¢å¼•ï¼Œæœ€åå‘ `key_table` å’Œ `S` æ’å…¥æ–°çš„ç¼“å­˜ä¿¡æ¯å³å¯ã€‚\n\n```C++ [sol1-C++]\nstruct Node {\n    int cnt, time, key, value;\n\n    Node(int _cnt, int _time, int _key, int _value):cnt(_cnt), time(_time), key(_key), value(_value){}\n    \n    bool operator < (const Node& rhs) const {\n        return cnt == rhs.cnt ? time < rhs.time : cnt < rhs.cnt;\n    }\n};\nclass LFUCache {\n    // ç¼“å­˜å®¹é‡ï¼Œæ—¶é—´æˆ³\n    int capacity, time;\n    unordered_map<int, Node> key_table;\n    set<Node> S;\npublic:\n    LFUCache(int _capacity) {\n        capacity = _capacity;\n        time = 0;\n        key_table.clear();\n        S.clear();\n    }\n    \n    int get(int key) {\n        if (capacity == 0) return -1;\n        auto it = key_table.find(key);\n        // å¦‚æœå“ˆå¸Œè¡¨ä¸­æ²¡æœ‰é”® keyï¼Œè¿”å› -1\n        if (it == key_table.end()) return -1;\n        // ä»å“ˆå¸Œè¡¨ä¸­å¾—åˆ°æ—§çš„ç¼“å­˜\n        Node cache = it -> second;\n        // ä»å¹³è¡¡äºŒå‰æ ‘ä¸­åˆ é™¤æ—§çš„ç¼“å­˜\n        S.erase(cache);\n        // å°†æ—§ç¼“å­˜æ›´æ–°\n        cache.cnt += 1;\n        cache.time = ++time;\n        // å°†æ–°ç¼“å­˜é‡æ–°æ”¾å…¥å“ˆå¸Œè¡¨å’Œå¹³è¡¡äºŒå‰æ ‘ä¸­\n        S.insert(cache);\n        it -> second = cache;\n        return cache.value;\n    }\n    \n    void put(int key, int value) {\n        if (capacity == 0) return;\n        auto it = key_table.find(key);\n        if (it == key_table.end()) {\n            // å¦‚æœåˆ°è¾¾ç¼“å­˜å®¹é‡ä¸Šé™\n            if (key_table.size() == capacity) {\n                // ä»å“ˆå¸Œè¡¨å’Œå¹³è¡¡äºŒå‰æ ‘ä¸­åˆ é™¤æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„ç¼“å­˜\n                key_table.erase(S.begin() -> key);\n                S.erase(S.begin());\n            }\n            // åˆ›å»ºæ–°çš„ç¼“å­˜\n            Node cache = Node(1, ++time, key, value);\n            // å°†æ–°ç¼“å­˜æ”¾å…¥å“ˆå¸Œè¡¨å’Œå¹³è¡¡äºŒå‰æ ‘ä¸­\n            key_table.insert(make_pair(key, cache));\n            S.insert(cache);\n        }\n        else {\n            // è¿™é‡Œå’Œ get() å‡½æ•°ç±»ä¼¼\n            Node cache = it -> second;\n            S.erase(cache);\n            cache.cnt += 1;\n            cache.time = ++time;\n            cache.value = value;\n            S.insert(cache);\n            it -> second = cache;\n        }\n    }\n};\n```\n```Java [sol1-Java]\nclass LFUCache {\n    // ç¼“å­˜å®¹é‡ï¼Œæ—¶é—´æˆ³\n    int capacity, time;\n    Map<Integer, Node> key_table;\n    TreeSet<Node> S;\n\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n        this.time = 0;\n        key_table = new HashMap<Integer, Node>();\n        S = new TreeSet<Node>();\n    }\n    \n    public int get(int key) {\n        if (capacity == 0) {\n            return -1;\n        }\n        // å¦‚æœå“ˆå¸Œè¡¨ä¸­æ²¡æœ‰é”® keyï¼Œè¿”å› -1\n        if (!key_table.containsKey(key)) {\n            return -1;\n        }\n        // ä»å“ˆå¸Œè¡¨ä¸­å¾—åˆ°æ—§çš„ç¼“å­˜\n        Node cache = key_table.get(key);\n        // ä»å¹³è¡¡äºŒå‰æ ‘ä¸­åˆ é™¤æ—§çš„ç¼“å­˜\n        S.remove(cache);\n        // å°†æ—§ç¼“å­˜æ›´æ–°\n        cache.cnt += 1;\n        cache.time = ++time;\n        // å°†æ–°ç¼“å­˜é‡æ–°æ”¾å…¥å“ˆå¸Œè¡¨å’Œå¹³è¡¡äºŒå‰æ ‘ä¸­\n        S.add(cache);\n        key_table.put(key, cache);\n        return cache.value;\n    }\n    \n    public void put(int key, int value) {\n        if (capacity == 0) {\n            return;\n        }\n        if (!key_table.containsKey(key)) {\n            // å¦‚æœåˆ°è¾¾ç¼“å­˜å®¹é‡ä¸Šé™\n            if (key_table.size() == capacity) {\n                // ä»å“ˆå¸Œè¡¨å’Œå¹³è¡¡äºŒå‰æ ‘ä¸­åˆ é™¤æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„ç¼“å­˜\n                key_table.remove(S.first().key);\n                S.remove(S.first());\n            }\n            // åˆ›å»ºæ–°çš„ç¼“å­˜\n            Node cache = new Node(1, ++time, key, value);\n            // å°†æ–°ç¼“å­˜æ”¾å…¥å“ˆå¸Œè¡¨å’Œå¹³è¡¡äºŒå‰æ ‘ä¸­\n            key_table.put(key, cache);\n            S.add(cache);\n        } else {\n            // è¿™é‡Œå’Œ get() å‡½æ•°ç±»ä¼¼\n            Node cache = key_table.get(key);\n            S.remove(cache);\n            cache.cnt += 1;\n            cache.time = ++time;\n            cache.value = value;\n            S.add(cache);\n            key_table.put(key, cache);\n        }\n    }\n}\n\nclass Node implements Comparable<Node> {\n    int cnt, time, key, value;\n\n    Node(int cnt, int time, int key, int value) {\n        this.cnt = cnt;\n        this.time = time;\n        this.key = key;\n        this.value = value;\n    }\n\n    public boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof Node) {\n            Node rhs = (Node) anObject;\n            return this.cnt == rhs.cnt && this.time == rhs.time;\n        }\n        return false;\n    }\n\n    public int compareTo(Node rhs) {\n        return cnt == rhs.cnt ? time - rhs.time : cnt - rhs.cnt;\n    }\n\n    public int hashCode() {\n        return cnt * 1000000007 + time;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š`get` æ—¶é—´å¤æ‚åº¦ $O(\\log n)$ï¼Œ`put` æ—¶é—´å¤æ‚åº¦ $O(\\log n)$ï¼Œæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ç“¶é¢ˆåœ¨äºå¹³è¡¡äºŒå‰æ ‘çš„æ’å…¥åˆ é™¤å‡éœ€è¦ $O(\\log n)$ çš„æ—¶é—´ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(\\textit{capacity})$ï¼Œå…¶ä¸­ $\\textit{capacity}$ ä¸º `LFU` çš„ç¼“å­˜å®¹é‡ã€‚å“ˆå¸Œè¡¨å’Œå¹³è¡¡äºŒå‰æ ‘ä¸ä¼šå­˜æ”¾è¶…è¿‡ç¼“å­˜å®¹é‡çš„é”®å€¼å¯¹ã€‚\n\n\n#### æ–¹æ³•äºŒï¼šåŒå“ˆå¸Œè¡¨\n\n**æ€è·¯å’Œç®—æ³•**\n\næˆ‘ä»¬å®šä¹‰ä¸¤ä¸ªå“ˆå¸Œè¡¨ï¼Œç¬¬ä¸€ä¸ª `freq_table` ä»¥é¢‘ç‡ `freq` ä¸ºç´¢å¼•ï¼Œæ¯ä¸ªç´¢å¼•å­˜æ”¾ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œè¿™ä¸ªé“¾è¡¨é‡Œå­˜æ”¾æ‰€æœ‰ä½¿ç”¨é¢‘ç‡ä¸º `freq` çš„ç¼“å­˜ï¼Œç¼“å­˜é‡Œå­˜æ”¾ä¸‰ä¸ªä¿¡æ¯ï¼Œåˆ†åˆ«ä¸ºé”® `key`ï¼Œå€¼ `value`ï¼Œä»¥åŠä½¿ç”¨é¢‘ç‡ `freq`ã€‚ç¬¬äºŒä¸ª `key_table` ä»¥é”®å€¼ `key` ä¸ºç´¢å¼•ï¼Œæ¯ä¸ªç´¢å¼•å­˜æ”¾å¯¹åº”ç¼“å­˜åœ¨ `freq_table` ä¸­é“¾è¡¨é‡Œçš„å†…å­˜åœ°å€ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½åˆ©ç”¨ä¸¤ä¸ªå“ˆå¸Œè¡¨æ¥ä½¿å¾—ä¸¤ä¸ªæ“ä½œçš„æ—¶é—´å¤æ‚åº¦å‡ä¸º $O(1)$ã€‚åŒæ—¶éœ€è¦è®°å½•ä¸€ä¸ªå½“å‰ç¼“å­˜æœ€å°‘ä½¿ç”¨çš„é¢‘ç‡ `minFreq`ï¼Œè¿™æ˜¯ä¸ºäº†åˆ é™¤æ“ä½œæœåŠ¡çš„ã€‚\n\nå¯¹äº `get(key)` æ“ä½œï¼Œæˆ‘ä»¬èƒ½é€šè¿‡ç´¢å¼• `key` åœ¨ `key_table` ä¸­æ‰¾åˆ°ç¼“å­˜åœ¨ `freq_table` ä¸­çš„é“¾è¡¨çš„å†…å­˜åœ°å€ï¼Œå¦‚æœä¸å­˜åœ¨ç›´æ¥è¿”å› `-1`ï¼Œå¦åˆ™æˆ‘ä»¬èƒ½è·å–åˆ°å¯¹åº”ç¼“å­˜çš„ç›¸å…³ä¿¡æ¯ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½çŸ¥é“ç¼“å­˜çš„é”®å€¼è¿˜æœ‰ä½¿ç”¨é¢‘ç‡ï¼Œç›´æ¥è¿”å› `key` å¯¹åº”çš„å€¼å³å¯ã€‚\n\nä½†æ˜¯æˆ‘ä»¬æ³¨æ„åˆ° `get` æ“ä½œåè¿™ä¸ªç¼“å­˜çš„ä½¿ç”¨é¢‘ç‡åŠ ä¸€äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ›´æ–°ç¼“å­˜åœ¨å“ˆå¸Œè¡¨ `freq_table` ä¸­çš„ä½ç½®ã€‚å·²çŸ¥è¿™ä¸ªç¼“å­˜çš„é”® `key`ï¼Œå€¼ `value`ï¼Œä»¥åŠä½¿ç”¨é¢‘ç‡ `freq`ï¼Œé‚£ä¹ˆè¯¥ç¼“å­˜åº”è¯¥å­˜æ”¾åˆ° `freq_table` ä¸­ `freq + 1` ç´¢å¼•ä¸‹çš„é“¾è¡¨ä¸­ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨å½“å‰é“¾è¡¨ä¸­ $O(1)$ åˆ é™¤è¯¥ç¼“å­˜å¯¹åº”çš„èŠ‚ç‚¹ï¼Œæ ¹æ®æƒ…å†µæ›´æ–° `minFreq` å€¼ï¼Œç„¶åå°†å…¶$O(1)$ æ’å…¥åˆ° `freq + 1` ç´¢å¼•ä¸‹çš„é“¾è¡¨å¤´å®Œæˆæ›´æ–°ã€‚è¿™å…¶ä¸­çš„æ“ä½œå¤æ‚åº¦å‡ä¸º $O(1)$ã€‚ä½ å¯èƒ½ä¼šç–‘æƒ‘æ›´æ–°çš„æ—¶å€™ä¸ºä»€ä¹ˆæ˜¯æ’å…¥åˆ°é“¾è¡¨å¤´ï¼Œè¿™å…¶å®æ˜¯ä¸ºäº†ä¿è¯ç¼“å­˜åœ¨å½“å‰é“¾è¡¨ä¸­ä»é“¾è¡¨å¤´åˆ°é“¾è¡¨å°¾çš„**æ’å…¥æ—¶é—´æ˜¯æœ‰åºçš„**ï¼Œä¸ºä¸‹é¢çš„åˆ é™¤æ“ä½œæœåŠ¡ã€‚ \n\nå¯¹äº `put(key, value)` æ“ä½œï¼Œæˆ‘ä»¬å…ˆé€šè¿‡ç´¢å¼• `key`åœ¨ `key_table` ä¸­æŸ¥çœ‹æ˜¯å¦æœ‰å¯¹åº”çš„ç¼“å­˜ï¼Œå¦‚æœæœ‰çš„è¯ï¼Œå…¶å®æ“ä½œç­‰ä»·äº `get(key)` æ“ä½œï¼Œå”¯ä¸€çš„åŒºåˆ«å°±æ˜¯æˆ‘ä»¬éœ€è¦å°†å½“å‰çš„ç¼“å­˜é‡Œçš„å€¼æ›´æ–°ä¸º `value`ã€‚å¦‚æœæ²¡æœ‰çš„è¯ï¼Œç›¸å½“äºæ˜¯æ–°åŠ å…¥çš„ç¼“å­˜ï¼Œå¦‚æœç¼“å­˜å·²ç»åˆ°è¾¾å®¹é‡ï¼Œéœ€è¦å…ˆåˆ é™¤æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„ç¼“å­˜ï¼Œå†è¿›è¡Œæ’å…¥ã€‚\n\nå…ˆè€ƒè™‘æ’å…¥ï¼Œç”±äºæ˜¯æ–°æ’å…¥çš„ï¼Œæ‰€ä»¥ç¼“å­˜çš„ä½¿ç”¨é¢‘ç‡ä¸€å®šæ˜¯ `1`ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ç¼“å­˜çš„ä¿¡æ¯æ’å…¥åˆ° `freq_table` ä¸­ `1` ç´¢å¼•ä¸‹çš„åˆ—è¡¨å¤´å³å¯ï¼ŒåŒæ—¶æ›´æ–° `key_table[key]` çš„ä¿¡æ¯ï¼Œä»¥åŠæ›´æ–° `minFreq = 1`ã€‚\n\né‚£ä¹ˆå‰©ä¸‹çš„å°±æ˜¯åˆ é™¤æ“ä½œäº†ï¼Œç”±äºæˆ‘ä»¬å®æ—¶ç»´æŠ¤äº† `minFreq`ï¼Œæ‰€ä»¥æˆ‘ä»¬èƒ½å¤ŸçŸ¥é“ `freq_table` é‡Œç›®å‰æœ€å°‘ä½¿ç”¨é¢‘ç‡çš„ç´¢å¼•ï¼ŒåŒæ—¶å› ä¸ºæˆ‘ä»¬ä¿è¯äº†é“¾è¡¨ä¸­ä»é“¾è¡¨å¤´åˆ°é“¾è¡¨å°¾çš„æ’å…¥æ—¶é—´æ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥ `freq_table[minFreq]` çš„é“¾è¡¨ä¸­é“¾è¡¨å°¾çš„èŠ‚ç‚¹å³ä¸ºä½¿ç”¨é¢‘ç‡æœ€å°ä¸”æ’å…¥æ—¶é—´æœ€æ—©çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬åˆ é™¤å®ƒåŒæ—¶æ ¹æ®æƒ…å†µæ›´æ–° `minFreq` ï¼Œæ•´ä¸ªæ—¶é—´å¤æ‚åº¦å‡ä¸º $O(1)$ã€‚\n\nå¦‚ä¸‹å›¾å±•ç¤ºäº†æ ·ä¾‹çš„å…¨éƒ¨æ“ä½œè¿‡ç¨‹ï¼š\n\n<![460_fig1.PNG](https://pic.leetcode-cn.com/9a528dbe009db486bd3211d85cdc16ed065ac246910800fdf8323672f67c6c18-460_fig1.PNG),![460_fig2.PNG](https://pic.leetcode-cn.com/7785efe871e48ea8971e8f097e1d6a91e98a4a8c6ef9b6832fd679b41e052f09-460_fig2.PNG),![460_fig3.PNG](https://pic.leetcode-cn.com/1fd0070ff3c311b36d2df0cf2a8d3dac86f5263d068f2ab80d9ca91988913394-460_fig3.PNG),![460_fig4.PNG](https://pic.leetcode-cn.com/e0268524f5484ae54332fd14ed5417e9e09b700f170e2854b381bf562fa8fd09-460_fig4.PNG),![460_fig5.PNG](https://pic.leetcode-cn.com/2b88cb8fdf0a294196aebb91c6c7a1895821b30cf0526ea4a64589dedd1546e6-460_fig5.PNG),![460_fig6.PNG](https://pic.leetcode-cn.com/857216ccedacc885dd7dc23f8641fa16a54f3f0387d0542cdf5432c0268b62ea-460_fig6.PNG),![460_fig7.PNG](https://pic.leetcode-cn.com/284dbd56dee83433599abfd8dcfd6ef64a0af678da092d781c9a39f2034ebd08-460_fig7.PNG),![460_fig8.PNG](https://pic.leetcode-cn.com/52c7ed8a33bb2b5818f04f80cd3130a96b02fc766c4d6d854ec8bd09734beaa8-460_fig8.PNG),![460_fig9.PNG](https://pic.leetcode-cn.com/e0ed80aa2a514d4aab82c53817d68b653517cc615212ea7ded6806c4672b2c9d-460_fig9.PNG),![460_fig10.PNG](https://pic.leetcode-cn.com/8cb941356d2fafb73d67b407a815e5b9cd10919809bbbcc6b81b6e835165dedd-460_fig10.PNG)>\n\n```C++ [sol2-C++]\n// ç¼“å­˜çš„èŠ‚ç‚¹ä¿¡æ¯\nstruct Node {\n    int key, val, freq;\n    Node(int _key,int _val,int _freq): key(_key), val(_val), freq(_freq){}\n};\nclass LFUCache {\n    int minfreq, capacity;\n    unordered_map<int, list<Node>::iterator> key_table;\n    unordered_map<int, list<Node>> freq_table;\npublic:\n    LFUCache(int _capacity) {\n        minfreq = 0;\n        capacity = _capacity;\n        key_table.clear();\n        freq_table.clear();\n    }\n    \n    int get(int key) {\n        if (capacity == 0) return -1;\n        auto it = key_table.find(key);\n        if (it == key_table.end()) return -1;\n        list<Node>::iterator node = it -> second;\n        int val = node -> val, freq = node -> freq;\n        freq_table[freq].erase(node);\n        // å¦‚æœå½“å‰é“¾è¡¨ä¸ºç©ºï¼Œæˆ‘ä»¬éœ€è¦åœ¨å“ˆå¸Œè¡¨ä¸­åˆ é™¤ï¼Œä¸”æ›´æ–°minFreq\n        if (freq_table[freq].size() == 0) {\n            freq_table.erase(freq);\n            if (minfreq == freq) minfreq += 1;\n        }\n        // æ’å…¥åˆ° freq + 1 ä¸­\n        freq_table[freq + 1].push_front(Node(key, val, freq + 1));\n        key_table[key] = freq_table[freq + 1].begin();\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if (capacity == 0) return;\n        auto it = key_table.find(key);\n        if (it == key_table.end()) {\n            // ç¼“å­˜å·²æ»¡ï¼Œéœ€è¦è¿›è¡Œåˆ é™¤æ“ä½œ\n            if (key_table.size() == capacity) {\n                // é€šè¿‡ minFreq æ‹¿åˆ° freq_table[minFreq] é“¾è¡¨çš„æœ«å°¾èŠ‚ç‚¹\n                auto it2 = freq_table[minfreq].back();\n                key_table.erase(it2.key);\n                freq_table[minfreq].pop_back();\n                if (freq_table[minfreq].size() == 0) {\n                    freq_table.erase(minfreq);\n                }\n            } \n            freq_table[1].push_front(Node(key, value, 1));\n            key_table[key] = freq_table[1].begin();\n            minfreq = 1;\n        } else {\n            // ä¸ get æ“ä½œåŸºæœ¬ä¸€è‡´ï¼Œé™¤äº†éœ€è¦æ›´æ–°ç¼“å­˜çš„å€¼\n            list<Node>::iterator node = it -> second;\n            int freq = node -> freq;\n            freq_table[freq].erase(node);\n            if (freq_table[freq].size() == 0) {\n                freq_table.erase(freq);\n                if (minfreq == freq) minfreq += 1;\n            }\n            freq_table[freq + 1].push_front(Node(key, value, freq + 1));\n            key_table[key] = freq_table[freq + 1].begin();\n        }\n    }\n};\n```\n```Java [sol2-Java]\nclass LFUCache {\n    int minfreq, capacity;\n    Map<Integer, Node> keyTable;\n    Map<Integer, DoublyLinkedList> freqTable;\n\n    public LFUCache(int capacity) {\n        this.minfreq = 0;\n        this.capacity = capacity;\n        keyTable = new HashMap<Integer, Node>();\n        freqTable = new HashMap<Integer, DoublyLinkedList>();\n    }\n    \n    public int get(int key) {\n        if (capacity == 0) {\n            return -1;\n        }\n        if (!keyTable.containsKey(key)) {\n            return -1;\n        }\n        Node node = keyTable.get(key);\n        int val = node.val, freq = node.freq;\n        freqTable.get(freq).remove(node);\n        // å¦‚æœå½“å‰é“¾è¡¨ä¸ºç©ºï¼Œæˆ‘ä»¬éœ€è¦åœ¨å“ˆå¸Œè¡¨ä¸­åˆ é™¤ï¼Œä¸”æ›´æ–°minFreq\n        if (freqTable.get(freq).size == 0) {\n            freqTable.remove(freq);\n            if (minfreq == freq) {\n                minfreq += 1;\n            }\n        }\n        // æ’å…¥åˆ° freq + 1 ä¸­\n        DoublyLinkedList list = freqTable.getOrDefault(freq + 1, new DoublyLinkedList());\n        list.addFirst(new Node(key, val, freq + 1));\n        freqTable.put(freq + 1, list);\n        keyTable.put(key, freqTable.get(freq + 1).getHead());\n        return val;\n    }\n    \n    public void put(int key, int value) {\n        if (capacity == 0) {\n            return;\n        }\n        if (!keyTable.containsKey(key)) {\n            // ç¼“å­˜å·²æ»¡ï¼Œéœ€è¦è¿›è¡Œåˆ é™¤æ“ä½œ\n            if (keyTable.size() == capacity) {\n                // é€šè¿‡ minFreq æ‹¿åˆ° freqTable[minFreq] é“¾è¡¨çš„æœ«å°¾èŠ‚ç‚¹\n                Node node = freqTable.get(minfreq).getTail();\n                keyTable.remove(node.key);\n                freqTable.get(minfreq).remove(node);\n                if (freqTable.get(minfreq).size == 0) {\n                    freqTable.remove(minfreq);\n                }\n            }\n            DoublyLinkedList list = freqTable.getOrDefault(1, new DoublyLinkedList());\n            list.addFirst(new Node(key, value, 1));\n            freqTable.put(1, list);\n            keyTable.put(key, freqTable.get(1).getHead());\n            minfreq = 1;\n        } else {\n            // ä¸ get æ“ä½œåŸºæœ¬ä¸€è‡´ï¼Œé™¤äº†éœ€è¦æ›´æ–°ç¼“å­˜çš„å€¼\n            Node node = keyTable.get(key);\n            int freq = node.freq;\n            freqTable.get(freq).remove(node);\n            if (freqTable.get(freq).size == 0) {\n                freqTable.remove(freq);\n                if (minfreq == freq) {\n                    minfreq += 1;\n                }\n            }\n            DoublyLinkedList list = freqTable.getOrDefault(freq + 1, new DoublyLinkedList());\n            list.addFirst(new Node(key, value, freq + 1));\n            freqTable.put(freq + 1, list);\n            keyTable.put(key, freqTable.get(freq + 1).getHead());\n        }\n    }\n}\n\nclass Node {\n    int key, val, freq;\n    Node prev, next;\n\n    Node() {\n        this(-1, -1, 0);\n    }\n\n    Node(int key, int val, int freq) {\n        this.key = key;\n        this.val = val;\n        this.freq = freq;\n    }\n}\n\nclass DoublyLinkedList {\n    Node dummyHead, dummyTail;\n    int size;\n\n    DoublyLinkedList() {\n        dummyHead = new Node();\n        dummyTail = new Node();\n        dummyHead.next = dummyTail;\n        dummyTail.prev = dummyHead;\n        size = 0;\n    }\n\n    public void addFirst(Node node) {\n        Node prevHead = dummyHead.next;\n        node.prev = dummyHead;\n        dummyHead.next = node;\n        node.next = prevHead;\n        prevHead.prev = node;\n        size++;\n    }\n\n    public void remove(Node node) {\n        Node prev = node.prev, next = node.next;\n        prev.next = next;\n        next.prev = prev;\n        size--;\n    }\n\n    public Node getHead() {\n        return dummyHead.next;\n    }\n\n    public Node getTail() {\n        return dummyTail.prev;\n    }\n}\n```\n```Python [sol2-Python3]\nclass Node:\n    def __init__(self, key, val, pre=None, nex=None, freq=0):\n        self.pre = pre\n        self.nex = nex\n        self.freq = freq\n        self.val = val\n        self.key = key\n        \n    def insert(self, nex):\n        nex.pre = self\n        nex.nex = self.nex\n        self.nex.pre = nex\n        self.nex = nex\n    \ndef create_linked_list():\n    head = Node(0, 0)\n    tail = Node(0, 0)\n    head.nex = tail\n    tail.pre = head\n    return (head, tail)\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.size = 0\n        self.minFreq = 0\n        self.freqMap = collections.defaultdict(create_linked_list)\n        self.keyMap = {}\n\n    def delete(self, node):\n        if node.pre:\n            node.pre.nex = node.nex\n            node.nex.pre = node.pre\n            if node.pre is self.freqMap[node.freq][0] and node.nex is self.freqMap[node.freq][-1]:\n                self.freqMap.pop(node.freq)\n        return node.key\n        \n    def increase(self, node):\n        node.freq += 1\n        self.delete(node)\n        self.freqMap[node.freq][-1].pre.insert(node)\n        if node.freq == 1:\n            self.minFreq = 1\n        elif self.minFreq == node.freq - 1:\n            head, tail = self.freqMap[node.freq - 1]\n            if head.nex is tail:\n                self.minFreq = node.freq\n\n    def get(self, key: int) -> int:\n        if key in self.keyMap:\n            self.increase(self.keyMap[key])\n            return self.keyMap[key].val\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity != 0:\n            if key in self.keyMap:\n                node = self.keyMap[key]\n                node.val = value\n            else:\n                node = Node(key, value)\n                self.keyMap[key] = node\n                self.size += 1\n            if self.size > self.capacity:\n                self.size -= 1\n                deleted = self.delete(self.freqMap[self.minFreq][0].nex)\n                self.keyMap.pop(deleted)\n            self.increase(node)\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š`get` æ—¶é—´å¤æ‚åº¦ $O(1)$ï¼Œ`put` æ—¶é—´å¤æ‚åº¦ $O(1)$ã€‚ç”±äºä¸¤ä¸ªæ“ä½œä»å¤´è‡³å°¾éƒ½åªåˆ©ç”¨äº†å“ˆå¸Œè¡¨çš„æ’å…¥åˆ é™¤è¿˜æœ‰é“¾è¡¨çš„æ’å…¥åˆ é™¤ï¼Œä¸”å®ƒä»¬çš„æ—¶é—´å¤æ‚åº¦å‡ä¸º $O(1)$ï¼Œæ‰€ä»¥ä¿è¯äº†ä¸¤ä¸ªæ“ä½œçš„æ—¶é—´å¤æ‚åº¦å‡ä¸º $O(1)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(\\textit{capacity})$ï¼Œå…¶ä¸­ $\\textit{capacity}$ ä¸º `LFU` çš„ç¼“å­˜å®¹é‡ã€‚å“ˆå¸Œè¡¨ä¸­ä¸ä¼šå­˜æ”¾è¶…è¿‡ç¼“å­˜å®¹é‡çš„é”®å€¼å¯¹ã€‚"
}