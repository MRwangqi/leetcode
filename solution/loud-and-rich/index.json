{
	"titleSlug": "loud-and-rich",
	"slug": "xuan-nao-he-fu-you-by-leetcode-solution-jnzm",
	"url": "https://leetcode-cn.com/problems/loud-and-rich/solution/xuan-nao-he-fu-you-by-leetcode-solution-jnzm/",
	"content": "#### 方法一：深度优先搜索\n\n我们可以根据 $\\textit{richer}$ 构建一张有向图：把人看成点，如果 $a_i$ 比 $b_i$ 更有钱，那么就从 $b_i$ 向 $a_i$ 连一条有向边。由于题目保证 $\\textit{richer}$ 中所给出的数据逻辑自恰，我们得到的是一张有向无环图。\n\n因此我们从图上任意一点（设为 $x$）出发，沿着有向边所能访问到的点，都比 $x$ 更有钱。\n\n题目需要计算拥有的钱肯定不少于 $x$ 的人中，最安静的人。我们可以分为拥有的钱肯定与 $x$ 相等，以及拥有的钱肯定比 $x$ 多两种情况。对于前者，根据题目所给信息，我们只知道 $x$ 拥有的钱肯定与自己相等，无法知道是否有其他人拥有的钱肯定与 $x$ 相等；对于后者，我们可以先计算出 $x$ 的邻居的 $\\textit{answer}$ 值，再取这些 $\\textit{answer}$ 值中的最小值为结果，这是因为从 $x$ 的邻居出发所能访问到的点，并上 $x$ 的邻居后所得到的点集，就是从 $x$ 出发所能访问到的点。总的来说，最安静的人要么是 $x$ 自己，要么是 $x$ 的邻居的 $\\textit{answer}$ 中最安静的人。\n\n计算 $x$ 的每个邻居的 $\\textit{answer}$ 值是一个递归的过程，我们可以用深度优先搜索来实现。为避免重复运算，在已经计算出 $\\textit{answer}[x]$ 的情况下可以直接返回。\n\n```Python [sol1-Python3]\nclass Solution:\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\n        n = len(quiet)\n        g = [[] for _ in range(n)]\n        for r in richer:\n            g[r[1]].append(r[0])\n\n        ans = [-1] * n\n        def dfs(x: int):\n            if ans[x] != -1:\n                return\n            ans[x] = x\n            for y in g[x]:\n                dfs(y)\n                if quiet[ans[y]] < quiet[ans[x]]:\n                    ans[x] = ans[y]\n        for i in range(n):\n            dfs(i)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> loudAndRich(vector<vector<int>> &richer, vector<int> &quiet) {\n        int n = quiet.size();\n        vector<vector<int>> g(n);\n        for (auto &r : richer) {\n            g[r[1]].emplace_back(r[0]);\n        }\n\n        vector<int> ans(n, -1);\n        function<void(int)> dfs = [&](int x) {\n            if (ans[x] != -1) {\n                return;\n            }\n            ans[x] = x;\n            for (int y : g[x]) {\n                dfs(y);\n                if (quiet[ans[y]] < quiet[ans[x]]) {\n                    ans[x] = ans[y];\n                }\n            }\n        };\n        for (int i = 0; i < n; ++i) {\n            dfs(i);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        int n = quiet.length;\n        List<Integer>[] g = new List[n];\n        for (int i = 0; i < n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        for (int[] r : richer) {\n            g[r[1]].add(r[0]);\n        }\n\n        int[] ans = new int[n];\n        Arrays.fill(ans, -1);\n        for (int i = 0; i < n; ++i) {\n            dfs(i, quiet, g, ans);\n        }\n        return ans;\n    }\n\n    public void dfs(int x, int[] quiet, List<Integer>[] g, int[] ans) {\n        if (ans[x] != -1) {\n            return;\n        }\n        ans[x] = x;\n        for (int y : g[x]) {\n            dfs(y, quiet, g, ans);\n            if (quiet[ans[y]] < quiet[ans[x]]) {\n                ans[x] = ans[y];\n            }\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] LoudAndRich(int[][] richer, int[] quiet) {\n        int n = quiet.Length;\n        IList<int>[] g = new List<int>[n];\n        for (int i = 0; i < n; ++i) {\n            g[i] = new List<int>();\n        }\n        foreach (int[] r in richer) {\n            g[r[1]].Add(r[0]);\n        }\n\n        int[] ans = new int[n];\n        Array.Fill(ans, -1);\n        for (int i = 0; i < n; ++i) {\n            DFS(i, quiet, g, ans);\n        }\n        return ans;\n    }\n\n    public void DFS(int x, int[] quiet, IList<int>[] g, int[] ans) {\n        if (ans[x] != -1) {\n            return;\n        }\n        ans[x] = x;\n        foreach (int y in g[x]) {\n            DFS(y, quiet, g, ans);\n            if (quiet[ans[y]] < quiet[ans[x]]) {\n                ans[x] = ans[y];\n            }\n        }\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc loudAndRich(richer [][]int, quiet []int) []int {\n    n := len(quiet)\n    g := make([][]int, n)\n    for _, r := range richer {\n        g[r[1]] = append(g[r[1]], r[0])\n    }\n\n    ans := make([]int, n)\n    for i := range ans {\n        ans[i] = -1\n    }\n    var dfs func(int)\n    dfs = func(x int) {\n        if ans[x] != -1 {\n            return\n        }\n        ans[x] = x\n        for _, y := range g[x] {\n            dfs(y)\n            if quiet[ans[y]] < quiet[ans[x]] {\n                ans[x] = ans[y]\n            }\n        }\n    }\n    for i := 0; i < n; i++ {\n        dfs(i)\n    }\n    return ans\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar loudAndRich = function(richer, quiet) {\n    const n = quiet.length;\n    const g = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        g[i] = [];\n    }\n    for (const r of richer) {\n        g[r[1]].push(r[0]);\n    }\n\n    const ans = new Array(n).fill(-1);\n    for (let i = 0; i < n; ++i) {\n        dfs(i, quiet, g, ans);\n    }\n    return ans;\n};\n\nconst dfs = (x, quiet, g, ans) => {\n    if (ans[x] !== -1) {\n        return;\n    }\n    ans[x] = x;\n    for (const y of g[x]) {\n        dfs(y, quiet, g, ans);\n        if (quiet[ans[y]] < quiet[ans[x]]) {\n            ans[x] = ans[y];\n        }\n    }\n}\n```\n\n```C [sol1-C]\nvoid dfs(int x, const int* quiet, const int** graph, const int* graphColSize, int* ans) {\n    if (ans[x] != -1) {\n        return;\n    }\n    ans[x] = x;\n    for (int i = 0; i < graphColSize[x]; ++i) {\n        int y = graph[x][i];\n        dfs(y, quiet, graph, graphColSize, ans);\n        if (quiet[ans[y]] < quiet[ans[x]]) {\n            ans[x] = ans[y];\n        }\n    }\n}\n\nint* loudAndRich(int** richer, int richerSize, int* richerColSize, int* quiet, int quietSize, int* returnSize){\n    int** graph = (int **)malloc(sizeof(int *) * quietSize);\n    int* graphColSize = (int *)malloc(sizeof(int) * quietSize);\n    int* ans = (int *)malloc(sizeof(int) * quietSize);\n\n    for (int i = 0; i < quietSize; ++i) {\n        graph[i] = (int *)malloc(sizeof(int) * quietSize);\n        ans[i] = -1;\n        graphColSize[i] = 0; \n    }\n    for (int i = 0; i < richerSize; ++i) {\n        int x = richer[i][0];\n        int y = richer[i][1];\n        graph[y][graphColSize[y]] = x;\n        graphColSize[y]++;\n    }\n    for (int i = 0; i < quietSize; ++i) {\n        dfs(i, quiet, graph, graphColSize, ans);\n    }\n    for (int i = 0; i < quietSize; ++i) {\n        free(graph[i]);\n    }\n    free(graphColSize);\n    *returnSize = quietSize;\n    return ans;\n}\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n+m)$，其中 $n$ 是数组 $\\textit{quiet}$ 的长度，$m$ 是数组 $\\textit{richer}$ 的长度。建图和 DFS 的时间复杂度均为 $O(n+m)$。\n\n- 空间复杂度：$O(n+m)$。我们需要 $O(n+m)$ 的空间来记录图中所有的点和边。\n\n#### 方法二：拓扑排序\n\n我们可以将方法一中的图的边全部反向，即如果 $a_i$ 比 $b_i$ 更有钱，我们从 $a_i$ 向 $b_i$ 连一条有向边。\n\n这同样得到的是一张有向无环图，因此我们从图上任意一点（设为 $x$）出发，沿着有向边所能访问到的点，拥有的钱都比 $x$ 少。这意味着我们可以在计算出 $\\textit{answer}[x]$ 后，用 $\\textit{answer}[x]$ 去更新 $x$ 所能访问到的点的 $\\textit{answer}$ 值。\n\n要实现这一算法，我们可以将每个 $\\textit{answer}[x]$ 初始化为 $x$，然后对这张图执行一遍拓扑排序，并按照拓扑序去更新 $x$ 的邻居的 $\\textit{answer}$ 值。通过这一方式我们就能将 $\\textit{answer}[x]$ 的值「传播」到 $x$ 所能访问到的点上。\n\n```Python [sol2-Python3]\nclass Solution:\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\n        n = len(quiet)\n        g = [[] for _ in range(n)]\n        inDeg = [0] * n\n        for r in richer:\n            g[r[0]].append(r[1])\n            inDeg[r[1]] += 1\n\n        ans = list(range(n))\n        q = deque(i for i, deg in enumerate(inDeg) if deg == 0)\n        while q:\n            x = q.popleft()\n            for y in g[x]:\n                if quiet[ans[x]] < quiet[ans[y]]:\n                    ans[y] = ans[x]  # 更新 x 的邻居的答案\n                inDeg[y] -= 1\n                if inDeg[y] == 0:\n                    q.append(y)\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> loudAndRich(vector<vector<int>> &richer, vector<int> &quiet) {\n        int n = quiet.size();\n        vector<vector<int>> g(n);\n        vector<int> inDeg(n);\n        for (auto &r : richer) {\n            g[r[0]].emplace_back(r[1]);\n            ++inDeg[r[1]];\n        }\n\n        vector<int> ans(n);\n        iota(ans.begin(), ans.end(), 0);\n        queue<int> q;\n        for (int i = 0; i < n; ++i) {\n            if (inDeg[i] == 0) {\n                q.emplace(i);\n            }\n        }\n        while (!q.empty()) {\n            int x = q.front();\n            q.pop();\n            for (int y : g[x]) {\n                if (quiet[ans[x]] < quiet[ans[y]]) {\n                    ans[y] = ans[x]; // 更新 x 的邻居的答案\n                }\n                if (--inDeg[y] == 0) {\n                    q.emplace(y);\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        int n = quiet.length;\n        List<Integer>[] g = new List[n];\n        for (int i = 0; i < n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        int[] inDeg = new int[n];\n        for (int[] r : richer) {\n            g[r[0]].add(r[1]);\n            ++inDeg[r[1]];\n        }\n\n        int[] ans = new int[n];\n        for (int i = 0; i < n; ++i) {\n            ans[i] = i;\n        }\n        Queue<Integer> q = new ArrayDeque<Integer>();\n        for (int i = 0; i < n; ++i) {\n            if (inDeg[i] == 0) {\n                q.offer(i);\n            }\n        }\n        while (!q.isEmpty()) {\n            int x = q.poll();\n            for (int y : g[x]) {\n                if (quiet[ans[x]] < quiet[ans[y]]) {\n                    ans[y] = ans[x]; // 更新 x 的邻居的答案\n                }\n                if (--inDeg[y] == 0) {\n                    q.offer(y);\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int[] LoudAndRich(int[][] richer, int[] quiet) {\n        int n = quiet.Length;\n        IList<int>[] g = new List<int>[n];\n        for (int i = 0; i < n; ++i) {\n            g[i] = new List<int>();\n        }\n        int[] inDeg = new int[n];\n        foreach (int[] r in richer) {\n            g[r[0]].Add(r[1]);\n            ++inDeg[r[1]];\n        }\n\n        int[] ans = new int[n];\n        for (int i = 0; i < n; ++i) {\n            ans[i] = i;\n        }\n        Queue<int> q = new Queue<int>();\n        for (int i = 0; i < n; ++i) {\n            if (inDeg[i] == 0) {\n                q.Enqueue(i);\n            }\n        }\n        while (q.Count > 0) {\n            int x = q.Dequeue();\n            foreach (int y in g[x]) {\n                if (quiet[ans[x]] < quiet[ans[y]]) {\n                    ans[y] = ans[x]; // 更新 x 的邻居的答案\n                }\n                if (--inDeg[y] == 0) {\n                    q.Enqueue(y);\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc loudAndRich(richer [][]int, quiet []int) []int {\n    n := len(quiet)\n    g := make([][]int, n)\n    inDeg := make([]int, n)\n    for _, r := range richer {\n        g[r[0]] = append(g[r[0]], r[1])\n        inDeg[r[1]]++\n    }\n\n    ans := make([]int, n)\n    for i := range ans {\n        ans[i] = i\n    }\n    q := make([]int, 0, n)\n    for i, deg := range inDeg {\n        if deg == 0 {\n            q = append(q, i)\n        }\n    }\n    for len(q) > 0 {\n        x := q[0]\n        q = q[1:]\n        for _, y := range g[x] {\n            if quiet[ans[x]] < quiet[ans[y]] {\n                ans[y] = ans[x] // 更新 x 的邻居的答案\n            }\n            inDeg[y]--\n            if inDeg[y] == 0 {\n                q = append(q, y)\n            }\n        }\n    }\n    return ans\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar loudAndRich = function(richer, quiet) {\n    const n = quiet.length;\n    const g = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        g[i] = [];\n    }\n    const inDeg = new Array(n).fill(0);\n    for (const r of richer) {\n        g[r[0]].push(r[1]);\n        ++inDeg[r[1]];\n    }\n\n    const ans = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        ans[i] = i;\n    }\n    const q = [];\n    for (let i = 0; i < n; ++i) {\n        if (inDeg[i] === 0) {\n            q.push(i);\n        }\n    }\n    while (q.length) {\n        const x = q.shift();\n        for (const y of g[x]) {\n            if (quiet[ans[x]] < quiet[ans[y]]) {\n                ans[y] = ans[x]; // 更新 x 的邻居的答案\n            }\n            if (--inDeg[y] === 0) {\n                q.push(y);\n            }\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n+m)$，其中 $n$ 是数组 $\\textit{quiet}$ 的长度，$m$ 是数组 $\\textit{richer}$ 的长度。建图和拓扑排序的时间复杂度均为 $O(n+m)$。\n\n- 空间复杂度：$O(n+m)$。我们需要 $O(n+m)$ 的空间来记录图中所有的点和边。"
}