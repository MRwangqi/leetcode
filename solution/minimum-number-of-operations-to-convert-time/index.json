{
	"titleSlug": "minimum-number-of-operations-to-convert-time",
	"slug": "zhuan-hua-shi-jian-xu-yao-de-zui-shao-ca-jzf4",
	"url": "https://leetcode-cn.com/problems/minimum-number-of-operations-to-convert-time/solution/zhuan-hua-shi-jian-xu-yao-de-zui-shao-ca-jzf4/",
	"content": "#### 方法一：贪心\n\n**思路与算法**\n\n为了方便计算，我们用整数 $\\textit{time}_1$ 与 $\\textit{time}_2$ 分别表示 $\\textit{current}$ 和 $\\textit{correct}$ 距离 $00:00$ 过去的分钟数，并用 $\\textit{diff} = \\textit{time}_2 - \\textit{time}_1$ 表示我们需要增加的分钟数。\n\n由于我们希望增加操作的次数最少，同时对于 $[1, 5, 15, 60]$ 这四个增加的数量，每一个数都**可以整除它前面（如有）的所有元素**，因此**尽可能使用右边的操作**替代对应次数左边的操作一定会使得操作次数更少。\n\n我们用 $\\textit{res}$ 来维护按照上述方案所需的操作数。同时，我们**从大到小**遍历单次操作可以增加的时间 $t$，则该操作可以进行的次数即为 $\\lfloor \\textit{diff} / t \\rfloor$（其中 $\\lfloor \\dots \\rfloor$ 代表向下取整），我们将 $\\textit{res}$ 加上该数值，并修改操作结束后剩余的时间差，即 $\\textit{diff} = \\textit{diff} \\bmod t$。最终，$\\textit{res}$ 即为最少操作次数，我们返回该数值作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int convertTime(string current, string correct) {\n        int time1 = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3, 2));\n        int time2 = stoi(correct.substr(0, 2)) * 60 + stoi(correct.substr(3, 2));\n        int diff = time2 - time1;   // 需要增加的分钟数\n        int res = 0;\n        // 尽可能优先使用增加数值更大的操作\n        vector<int> ops = {60, 15, 5, 1};\n        for (int t: ops) {\n            res += diff / t;\n            diff %= t;\n        }\n        return res;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def convertTime(self, current: str, correct: str) -> int:\n        time1 = int(current[:2]) * 60 + int(current[3:])\n        time2 = int(correct[:2]) * 60 + int(correct[3:])\n        diff = time2 - time1   # 需要增加的分钟数\n        res = 0\n        # 尽可能优先使用增加数值更大的操作\n        for t in [60, 15, 5, 1]:\n            res += diff // t\n            diff %= t\n        return res\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$。\n\n- 空间复杂度：$O(1)$。"
}