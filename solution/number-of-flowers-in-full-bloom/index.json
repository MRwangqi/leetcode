{
	"titleSlug": "number-of-flowers-in-full-bloom",
	"slug": "chai-fen-pythonjavacgo-by-endlesscheng-wz35",
	"url": "https://leetcode-cn.com/problems/number-of-flowers-in-full-bloom/solution/chai-fen-pythonjavacgo-by-endlesscheng-wz35/",
	"content": "### 方法一：差分\r\n\r\n#### 提示\r\n\r\n把 $\\textit{flowers}_i$ 看成是将区间 $[\\textit{start}_i,\\textit{end}_i]$ 上的每个时间点都增加一朵花。\r\n\r\n那么对于第 $i$ 个人，我们就需要计算出 $\\textit{person}_i$ 时间点上有多少朵花。\r\n\r\n#### 算法\r\n\r\n用变化量表示一段区间上的更新，即在时间点 $\\textit{start}_i$ 变化量增加了 $1$，在时间点 $\\textit{end}_i+1$ 变化量减少了 $1$（类比导数的概念）。\r\n\r\n遍历 $\\textit{flowers}$，统计这些区间端点产生的变化量，记录在有序集合 $\\textit{diff}$ 中。\r\n\r\n然后从小到大遍历 $\\textit{diff}$，累加变化量（类比积分的概念）。第 $i$ 个人到达时，花的数目即为不超过 $\\textit{person}_i$ 时间点的变化量的累加值。\r\n\r\n为了快速计算每个人的答案，我们需要将 $\\textit{person}$ 从小到大排序，这样可以在遍历 $\\textit{person}$ 的同时从小到大遍历 $\\textit{diff}$。\r\n\r\n- 时间复杂度：$O(n\\log n + m\\log m)$，其中 $n$ 是 $\\textit{flowers}$ 的长度，$m$ 是 $\\textit{persons}$ 的长度。\r\n- 空间复杂度：$O(n+m)$。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:\r\n        diff = defaultdict(int)  # 也可以用 SortedDict\r\n        for start, end in flowers:\r\n            diff[start] += 1\r\n            diff[end + 1] -= 1\r\n        times = sorted(diff.keys())\r\n\r\n        n = len(persons)\r\n        ans = [0] * n\r\n        i = sum = 0\r\n        for p, id in sorted(zip(persons, range(n))):\r\n            while i < len(times) and times[i] <= p:\r\n                sum += diff[times[i]]  # 累加变化量\r\n                i += 1\r\n            ans[id] = sum\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int[] fullBloomFlowers(int[][] flowers, int[] persons) {\r\n        var diff = new HashMap<Integer, Integer>();\r\n        for (var f : flowers) {\r\n            diff.put(f[0], diff.getOrDefault(f[0], 0) + 1);\r\n            diff.put(f[1] + 1, diff.getOrDefault(f[1] + 1, 0) - 1);\r\n        }\r\n        var times = diff.keySet().stream().mapToInt(Integer::intValue).sorted().toArray();\r\n\r\n        var n = persons.length;\r\n        var ids = IntStream.range(0, n).boxed().toArray(Integer[]::new);\r\n        Arrays.sort(ids, (i, j) -> persons[i] - persons[j]);\r\n\r\n        var ans = new int[n];\r\n        int i = 0, sum = 0;\r\n        for (var id : ids) {\r\n            while (i < times.length && times[i] <= persons[id])\r\n                sum += diff.get(times[i++]); // 累加变化量\r\n            ans[id] = sum;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    vector<int> fullBloomFlowers(vector<vector<int>> &flowers, vector<int> &persons) {\r\n        map<int, int> diff;\r\n        for (auto &f : flowers) {\r\n            ++diff[f[0]];\r\n            --diff[f[1] + 1];\r\n        }\r\n\r\n        int n = persons.size();\r\n        vector<int> id(n);\r\n        iota(id.begin(), id.end(), 0);\r\n        sort(id.begin(), id.end(), [&](int i, int j) { return persons[i] < persons[j]; });\r\n\r\n        vector<int> ans(n);\r\n        auto it = diff.begin();\r\n        int sum = 0;\r\n        for (int i : id) {\r\n            while (it != diff.end() && it->first <= persons[i])\r\n                sum += it++->second; // 累加变化量\r\n            ans[i] = sum;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc fullBloomFlowers(flowers [][]int, persons []int) []int {\r\n\tdiff := map[int]int{}\r\n\tfor _, f := range flowers {\r\n\t\tdiff[f[0]]++\r\n\t\tdiff[f[1]+1]--\r\n\t}\r\n\r\n\tn := len(diff)\r\n\ttimes := make([]int, 0, n)\r\n\tfor t := range diff {\r\n\t\ttimes = append(times, t)\r\n\t}\r\n\tsort.Ints(times)\r\n\r\n\tfor i, p := range persons {\r\n\t\tpersons[i] = p<<32 | i\r\n\t}\r\n\tsort.Ints(persons)\r\n\r\n\tans := make([]int, len(persons))\r\n\ti, sum := 0, 0\r\n\tfor _, p := range persons {\r\n\t\tfor ; i < n && times[i] <= p>>32; i++ {\r\n\t\t\tsum += diff[times[i]] // 累加变化量\r\n\t\t}\r\n\t\tans[uint32(p)] = sum\r\n\t}\r\n\treturn ans\r\n}\r\n```\r\n\r\n### 方法二：转换 + 二分\r\n\r\n第 $i$ 个人能看到的花的数目，等价于 $\\textit{start}$ 不晚于 $\\textit{persons}_i$ 的花的数目，减去 $\\textit{end}$ 早于 $\\textit{persons}_i$ 的花的数目，即开花数减去凋落数。\r\n\r\n所以单独统计开花时间和凋落时间，排序后二分就得到了答案。\r\n\r\n- 时间复杂度：$O((n+m)\\log n)$，其中 $n$ 是 $\\textit{flowers}$ 的长度，$m$ 是 $\\textit{persons}$ 的长度。\r\n- 空间复杂度：$O(n)$。不计返回值的空间。\r\n\r\n```Python [sol2-Python3]\r\nclass Solution:\r\n    def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:\r\n        starts = sorted(s for s, _ in flowers)\r\n        ends = sorted(e for _, e in flowers)\r\n        return [bisect_right(starts, p) - bisect_left(ends, p) for p in persons]\r\n```\r\n\r\n```java [sol2-Java]\r\nclass Solution {\r\n    public int[] fullBloomFlowers(int[][] flowers, int[] persons) {\r\n        var starts = Arrays.stream(flowers).mapToInt(f -> f[0]).sorted().toArray();\r\n        var ends = Arrays.stream(flowers).mapToInt(f -> f[1]).sorted().toArray();\r\n        return Arrays.stream(persons).map(p -> lowerBound(starts, p + 1) - lowerBound(ends, p)).toArray();\r\n    }\r\n\r\n    int lowerBound(int[] arr, int x) {\r\n        int left = 0, right = arr.length;\r\n        while (left < right) {\r\n            var mid = (left + right) / 2;\r\n            if (arr[mid] >= x) right = mid;\r\n            else left = mid + 1;\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol2-C++]\r\nclass Solution {\r\npublic:\r\n    vector<int> fullBloomFlowers(vector<vector<int>> &flowers, vector<int> &persons) {\r\n        int n = flowers.size();\r\n        vector<int> starts(n), ends(n);\r\n        for (int i = 0; i < n; ++i) {\r\n            starts[i] = flowers[i][0];\r\n            ends[i] = flowers[i][1];\r\n        }\r\n        sort(starts.begin(), starts.end());\r\n        sort(ends.begin(), ends.end());\r\n\r\n        n = persons.size();\r\n        vector<int> ans(n);\r\n        for (int i = 0; i < n; ++i)\r\n            ans[i] = (upper_bound(starts.begin(), starts.end(), persons[i]) - starts.begin()) -\r\n                     (lower_bound(ends.begin(), ends.end(), persons[i]) - ends.begin());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\nfunc fullBloomFlowers(flowers [][]int, persons []int) []int {\r\n\tn := len(flowers)\r\n\tstarts := make([]int, n)\r\n\tends := make([]int, n)\r\n\tfor i, f := range flowers {\r\n\t\tstarts[i] = f[0]\r\n\t\tends[i] = f[1]\r\n\t}\r\n\tsort.Ints(starts)\r\n\tsort.Ints(ends)\r\n\r\n\tans := make([]int, len(persons))\r\n\tfor i, p := range persons {\r\n\t\tans[i] = sort.SearchInts(starts, p+1) - sort.SearchInts(ends, p)\r\n\t}\r\n\treturn ans\r\n}\r\n```\r\n"
}