{
	"titleSlug": "number-of-ways-to-separate-numbers",
	"slug": "by-iancn-90gl",
	"url": "https://leetcode-cn.com/problems/number-of-ways-to-separate-numbers/solution/by-iancn-90gl/",
	"content": "> 一个大坑：这道题卡 python 的不在于字符串比较，而在于遍历了 n^2 还是 n^2//2 次。\r\npython 加上 lcp 耗时更长，所以容易掉坑里出不来。。。\r\n\r\n## #1\r\n\r\n令 dp[i][j] 代表 num[:i] 中最后一个数长度 j 的方案数量，可以递推：\r\n- 若 num[i-j]=='0'，显然为 0\r\n- 考虑 k<j，dp[i-j][k] 的有效方案再加上 num[i-j:i] 依然有效\r\n- 然后判断 dp[i-j][j] 的方案加上 num[i-j:i] 是否有效，需要比较 num[i-2*j:i-j] 和 num[i-j:i]\r\n\r\n> 为了最终的通过，这里只考虑 j<=i 时的状态\r\n\r\n```python []\r\ndef numberOfCombinations(self, num: str) -> int:\r\n    n, mod = len(num), 10**9+7\r\n    dp = [[0]*(i+1) for i in range(n+1)]\r\n    dp[0][0] = 1\r\n    for i in range(1, n+1):\r\n        for j in range(1, i+1):\r\n            if num[i-j] != '0':\r\n                dp[i][j] = sum(dp[i-j][k] for k in range(min(j, i-j+1)))\r\n                if i-2*j>=0 and num[i-j:i]>=num[i-2*j:i-j]:\r\n                    dp[i][j] += dp[i-j][j]\r\n                dp[i][j] %= mod\r\n    return sum(dp[-1]) % mod\r\n```\r\n超时了\r\n\r\n## #2\r\n\r\n观察发现 dp[i][j] 依赖于 dp[i-j] 的前 min(j-1, i-j) 项之和，因此可以保存 dp[i] 的前缀和，优化时间。\r\n\r\n```python []\r\ndef numberOfCombinations(self, num: str) -> int:\r\n    n, mod = len(num), 10**9+7\r\n    dp = [[0]*(i+1) for i in range(n+1)]\r\n    dp[0][0] = 1\r\n    pre = [row[:] for row in dp]\r\n    for i in range(1, n+1):\r\n        for j in range(1, i+1):\r\n            if num[i-j] != '0':\r\n                dp[i][j] = pre[i-j][min(j-1, i-j)] \r\n                if i-2*j>=0 and num[i-j:i]>=num[i-2*j:i-j]:\r\n                    dp[i][j] += dp[i-j][j]\r\n                dp[i][j] %= mod\r\n            pre[i][j] = (pre[i][j-1]+dp[i][j])%mod\r\n    return pre[-1][-1]\r\n```\r\n5972 ms\r\n\r\n## #3\r\n\r\n进一步观察发现，其实用不着 dp 数组，可以直接递推 pre 数组。\r\n\r\n\r\n```python []\r\ndef numberOfCombinations(self, num: str) -> int:\r\n    n, mod = len(num), 10**9+7\r\n    pre = [[0]*(i+1) for i in range(n+1)]\r\n    pre[0][0] = 1\r\n    for i in range(1, n+1):\r\n        for j in range(1, i+1):\r\n            cur = 0\r\n            if num[i-j] != '0':\r\n                if i-2*j>=0 and num[i-j:i]>=num[i-2*j:i-j]:\r\n                    cur = pre[i-j][j]\r\n                else:\r\n                    cur = pre[i-j][min(j-1,i-j)]\r\n            pre[i][j] = (pre[i][j-1]+cur)%mod\r\n    return pre[-1][-1]\r\n```\r\n3368 ms"
}