{
	"titleSlug": "solve-the-equation",
	"slug": "qiu-jie-fang-cheng-by-leetcode-solution-knct",
	"url": "https://leetcode-cn.com/problems/solve-the-equation/solution/qiu-jie-fang-cheng-by-leetcode-solution-knct/",
	"content": "#### 方法一：解析\n\n我们将等式右边的项都移到等式左边，那么等式右边的项的默认系数为 $-1$。我们依次解析方程的项，并将同类项进行合并，使用 $\\textit{factor}$ 表示变量的系数，$\\textit{val}$ 表示常量值。\n\n初始时默认系数 $\\textit{sign}_1 = 1$，当我们解析到等号时，说明解析到等式右边的项，令 $\\textit{sign}_1 = -1$。使用变量 $\\textit{sign}_2$ 表示项的符号，初始时 $\\textit{sign}_2 = \\textit{sign}_1$，如果我们解析到 $\\text{`+'}$ 或 $\\text{`-'}$，那么相应的更改 $\\textit{sign}_2$。使用 $\\textit{number}$ 记录数字，$\\textit{valid}$ 表示 $\\textit{number}$ 是否有效（变量 $x$ 前面可能没有数字），如果我们解析到的项是变量项，那么相应的更改 $\\textit{factor}$；如果我们解析到的项是常量项，那么相应的更改 $\\textit{val}$。\n\n如果 $\\textit{factor} = 0$ 成立，说明变量 $x$ 对方程无影响，然后判断 $\\textit{val} = 0$ 是否成立，成立则说明方程有无数解，返回 $\\text{``Infinite solutions\"}$，否则返回 $\\text{``No solution\"}$。其他情况直接返回对应的整数解 $x = \\dfrac{-\\textit{val}}{\\textit{factor}}$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def solveEquation(self, equation: str) -> str:\n        factor = val = 0\n        i, n, sign = 0, len(equation), 1  # 等式左边默认系数为正\n        while i < n:\n            if equation[i] == '=':\n                sign = -1\n                i += 1\n                continue\n\n            s = sign\n            if equation[i] == '+':  # 去掉前面的符号\n                i += 1\n            elif equation[i] == '-':\n                s = -s\n                i += 1\n\n            num, valid = 0, False\n            while i < n and equation[i].isdigit():\n                valid = True\n                num = num * 10 + int(equation[i])\n                i += 1\n\n            if i < n and equation[i] == 'x':  # 变量\n                factor += s * num if valid else s\n                i += 1\n            else:  # 数值\n                val += s * num\n\n        if factor == 0:\n            return \"No solution\" if val else \"Infinite solutions\"\n        return f\"x={-val // factor}\"\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string solveEquation(string equation) {\n        int factor = 0, val = 0;\n        int index = 0, n = equation.size(), sign1 = 1; // 等式左边默认系数为正\n        while (index < n) {\n            if (equation[index] == '=') {\n                sign1 = -1; // 等式右边默认系数为负\n                index++;\n                continue;\n            }\n\n            int sign2 = sign1, number = 0;\n            bool valid = false; // 记录 number 是否有效\n            if (equation[index] == '-' || equation[index] == '+') { // 去掉前面的符号\n                sign2 = (equation[index] == '-') ? -sign1 : sign1;\n                index++;\n            }\n            while (index < n && isdigit(equation[index])) {\n                number = number * 10 + (equation[index] - '0');\n                index++;\n                valid = true;\n            }\n\n            if (index < n && equation[index] == 'x') { // 变量\n                factor += valid ? sign2 * number : sign2;\n                index++;\n            } else { // 数值\n                val += sign2 * number;\n            }\n        }\n\n        if (factor == 0) {\n            return val == 0 ? \"Infinite solutions\" : \"No solution\";\n        }\n        return string(\"x=\") + to_string(-val / factor);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String solveEquation(String equation) {\n        int factor = 0, val = 0;\n        int index = 0, n = equation.length(), sign1 = 1; // 等式左边默认系数为正\n        while (index < n) {\n            if (equation.charAt(index) == '=') {\n                sign1 = -1; // 等式右边默认系数为负\n                index++;\n                continue;\n            }\n\n            int sign2 = sign1, number = 0;\n            boolean valid = false; // 记录 number 是否有效\n            if (equation.charAt(index) == '-' || equation.charAt(index) == '+') { // 去掉前面的符号\n                sign2 = (equation.charAt(index) == '-') ? -sign1 : sign1;\n                index++;\n            }\n            while (index < n && Character.isDigit(equation.charAt(index))) {\n                number = number * 10 + (equation.charAt(index) - '0');\n                index++;\n                valid = true;\n            }\n\n            if (index < n && equation.charAt(index) == 'x') { // 变量\n                factor += valid ? sign2 * number : sign2;\n                index++;\n            } else { // 数值\n                val += sign2 * number;\n            }\n        }\n\n        if (factor == 0) {\n            return val == 0 ? \"Infinite solutions\" : \"No solution\";\n        }\n        return \"x=\" + (-val / factor);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string SolveEquation(string equation) {\n        int factor = 0, val = 0;\n        int index = 0, n = equation.Length, sign1 = 1; // 等式左边默认系数为正\n        while (index < n) {\n            if (equation[index] == '=') {\n                sign1 = -1; // 等式右边默认系数为负\n                index++;\n                continue;\n            }\n\n            int sign2 = sign1, number = 0;\n            bool valid = false; // 记录 number 是否有效\n            if (equation[index] == '-' || equation[index] == '+') { // 去掉前面的符号\n                sign2 = (equation[index] == '-') ? -sign1 : sign1;\n                index++;\n            }\n            while (index < n && char.IsDigit(equation[index])) {\n                number = number * 10 + (equation[index] - '0');\n                index++;\n                valid = true;\n            }\n\n            if (index < n && equation[index] == 'x') { // 变量\n                factor += valid ? sign2 * number : sign2;\n                index++;\n            } else { // 数值\n                val += sign2 * number;\n            }\n        }\n\n        if (factor == 0) {\n            return val == 0 ? \"Infinite solutions\" : \"No solution\";\n        }\n        return \"x=\" + (-val / factor);\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX_EXPRESSION_LEN 32\n\nchar * solveEquation(char * equation) {\n    int factor = 0, val = 0;\n    int index = 0, n = strlen(equation), sign1 = 1; // 等式左边默认系数为正\n    while (index < n) {\n        if (equation[index] == '=') {\n            sign1 = -1; // 等式右边默认系数为负\n            index++;\n            continue;\n        }\n\n        int sign2 = sign1, number = 0;\n        bool valid = false; // 记录 number 是否有效\n        if (equation[index] == '-' || equation[index] == '+') { // 去掉前面的符号\n            sign2 = (equation[index] == '-') ? -sign1 : sign1;\n            index++;\n        }\n        while (index < n && isdigit(equation[index])) {\n            number = number * 10 + (equation[index] - '0');\n            index++;\n            valid = true;\n        }\n\n        if (index < n && equation[index] == 'x') { // 变量\n            factor += valid ? sign2 * number : sign2;\n            index++;\n        } else { // 数值\n            val += sign2 * number;\n        }\n    }\n\n    if (factor == 0) {\n        return val == 0 ? \"Infinite solutions\" : \"No solution\";\n    }\n    char *ans = (char *)malloc(sizeof(char) * MAX_EXPRESSION_LEN);\n    sprintf(ans, \"x=%d\", -val / factor);\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar solveEquation = function(equation) {\n    let factor = 0, val = 0;\n    let index = 0, n = equation.length, sign1 = 1; // 等式左边默认系数为正\n    while (index < n) {\n        if (equation[index] === '=') {\n            sign1 = -1; // 等式右边默认系数为负\n            index++;\n            continue;\n        }\n\n        let sign2 = sign1, number = 0;\n        let valid = false; // 记录 number 是否有效\n        if (equation[index] === '-' || equation[index] === '+') { // 去掉前面的符号\n            sign2 = (equation[index] === '-') ? -sign1 : sign1;\n            index++;\n        }\n        while (index < n && isDigit(equation[index])) {\n            number = number * 10 + (equation[index].charCodeAt() - '0'.charCodeAt());\n            index++;\n            valid = true;\n        }\n\n        if (index < n && equation[index] === 'x') { // 变量\n            factor += valid ? sign2 * number : sign2;\n            index++;\n        } else { // 数值\n            val += sign2 * number;\n        }\n    }\n\n    if (factor === 0) {\n        return val === 0 ? \"Infinite solutions\" : \"No solution\";\n    }\n    return \"x=\" + (-val / factor);\n};\n\nconst isDigit = (ch) => {\n    return parseFloat(ch).toString() === \"NaN\" ? false : true;\n}\n```\n\n```go [sol1-Golang]\nfunc solveEquation(equation string) string {\n    factor, val := 0, 0\n    i, n, sign := 0, len(equation), 1 // 等式左边默认系数为正\n    for i < n {\n        if equation[i] == '=' {\n            sign = -1 // 等式右边默认系数为负\n            i++\n            continue\n        }\n\n        s := sign\n        if equation[i] == '+' { // 去掉前面的符号\n            i++\n        } else if equation[i] == '-' {\n            s = -s\n            i++\n        }\n\n        num, valid := 0, false\n        for i < n && unicode.IsDigit(rune(equation[i])) {\n            valid = true\n            num = num*10 + int(equation[i]-'0')\n            i++\n        }\n\n        if i < n && equation[i] == 'x' { // 变量\n            if valid {\n                s *= num\n            }\n            factor += s\n            i++\n        } else { // 数值\n            val += s * num\n        }\n    }\n\n    if factor == 0 {\n        if val == 0 {\n            return \"Infinite solutions\"\n        }\n        return \"No solution\"\n    }\n    return \"x=\" + strconv.Itoa(-val/factor)\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是字符串 $\\textit{equation}$ 的长度。\n\n+ 空间复杂度：$O(1)$。"
}