{
	"titleSlug": "largest-merge-of-two-strings",
	"slug": "by-trusting-6rothendieckuf6-wfaa",
	"url": "https://leetcode-cn.com/problems/largest-merge-of-two-strings/solution/by-trusting-6rothendieckuf6-wfaa/",
	"content": "### 解题思路\n看了很多的其他算法，发现基本上都用了**substr（）**函数，这种方法在复制字符串时会花费较多时间，下面这种方法使用了类似于**双指针**的办法，并且也用自己的方法重写了**compare（）**函数能达到的效果。\n整体的思路是比较两个字符串位于相同位置的大小\n\n如果比较结果为两个大小不相等，那么就将更大的那个字符对应的字符串序号加1，并且用string的成员函数push_back来存储这个数。\n\n比较麻烦的是两个字符相等的情况。\n一开始我想，反正两个数相等，任意取一个字符串的一个字符存入string类中，然后令其序号加1，然而问题并没有那么简单。这个时候选择两个字符串的哪一个非常重要，我们必须提前知晓对哪一个字符串进行这种操作得到的最终结果会满足题意。为此，我写了一个循环\nwhile (word1[i + num] == word2[j + num]) {\n                        sign = true;\n                        num++;\n                        if (i + num == word1.size() || j + num == word2.size()) {\n                            \n                            num--;\n                            break;\n                        }\n                    }\n其目的就在与在实际添加元素之前得知用哪一个数组有最大的字典序。通过这个循环得到的结果，我分为后续字母的位置没有越战（加上num）后的值和越栈（并没有实际越栈，只是位于边界处）后两个情况进行讨论。通过这样的提前预知，我们获取了正确的数组操作方向，以利于得到正确的结果。\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    string largestMerge(string word1, string word2) {\n        string result;\n        int i = 0, j = 0;\n        for (i = 0, j = 0; i < word1.size() && j < word2.size();) {\n            bool equal = false;\n            if (result.size() == 1)\n                i = i * 1;\n            if (word1[i] > word2[j]) {\n                result.push_back(word1[i++]);\n                \n\n            }\n            else if (word1[i] < word2[j]) {\n                result.push_back(word2[j++]);\n\n            }\n            else if (word1[i] == word2[j]) {\n                if (i + 1 == word1.size() && j + 1 != word2.size()) {\n                    \n                        result.push_back(word1[i]);\n                        j++;\n                    \n                }\n                else if (j + 1 == word2.size() && i + 1 != word1.size()) {\n                    result.push_back(word1[i]);\n                    i++;\n                }\n                else if (j + 1 != word2.size() && i + 1 != word1.size()) {\n                    int num = 1;\n                    bool sign = false;\n                    while (word1[i + num] == word2[j + num]) {\n                        sign = true;\n                        num++;\n                        if (i + num == word1.size() || j + num == word2.size()) {\n                            \n                            num--;\n                            break;\n                        }\n                    }\n                    if (word1[i + num] > word2[j + num]) {\n                        //if (j + num == word2.size() - 1 && sign) \n                        {\n                            result.push_back(word1[i]);\n                            i++;\n                        }\n                    }\n                   \n                    else if(word1[i + num] < word2[j + num]){\n                        result.push_back(word2[j]);\n                        j++;\n                    }\n                    else if (word1[i + num] == word2[j + num]) {\n                        if (i + num == word1.size()-1) {\n                            result.push_back(word2[j]);\n                            j++;\n                        }\n                        else if (j + num == word2.size() - 1) {\n                            result.push_back(word1[i]);\n                            i++;\n                        }\n                    }\n                }\n                else {\n                    result.push_back(word1[i]);\n                    j++;\n                }\n            }\n\n           \n        }\n        if (i == word1.size()) {\n            for (;j<word2.size();j++) {\n                result.push_back(word2[j]);\n            }\n        }\n        if (j == word2.size()) {\n            for (;i<word1.size();i++) {\n                result.push_back(word1[i]);\n            }\n        }\n\n        return result;\n    }\n    \n};\n```\n![QQ截图20220918203628.png](https://pic.leetcode-cn.com/1663504602-oDIngQ-QQ%E6%88%AA%E5%9B%BE20220918203628.png)\n\n"
}