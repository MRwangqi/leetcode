{
	"titleSlug": "build-a-matrix-with-conditions",
	"slug": "by-endlesscheng-gpev",
	"url": "https://leetcode-cn.com/problems/build-a-matrix-with-conditions/solution/by-endlesscheng-gpev/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1mG411V7fj) 已出炉，包括本题**拓扑排序的原理**，欢迎素质三连，在评论区分享你对这场周赛的看法~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n数字之间的约束只发生在行与行、列于列，而行与列之间没有直接约束。\r\n\r\n因此我们可以分别处理行与列中数字的相对顺序，如何求出这个相对顺序呢？\r\n\r\n#### 提示 2\r\n\r\n拓扑排序。\r\n\r\n#### 提示 3\r\n\r\n对于 $\\textit{rowConditions}$，我们可以从 $\\textit{above}_i$ 向 $\\textit{below}_i$ 连一条有向边，得到一张有向图。在这张图上跑拓扑排序，得到的拓扑序就是行与行中数字的相对顺序，这样我们就知道了每一行要填哪个数字。如果得到的拓扑序长度不足 $k$，说明图中有环，无法构造，答案不存在。\r\n\r\n对 $\\textit{colConditions}$ 也执行上述过程，得到每一列要填哪个数字，进而得到每个数字要填到哪一列中，这样我们就知道每一行的数字要填到哪一列了。\r\n\r\n#### 答疑\r\n\r\nQ：下面拓扑排序的代码，是怎么处理孤立点（没有连边的点，对于本题来说是没有受到任何约束的数字）的？\r\nA：孤立点入度为 $0$，在一开始就入队了，进而在后续的循环中加到了拓扑序中。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(k^2+n+m)$，其中 $n$ 为 $\\textit{rowConditions}$ 的长度， $m$ 为 $\\textit{colConditions}$ 的长度。\r\n- 空间复杂度：$O(k+n+m)$。忽略返回值占用的空间复杂度。\r\n\r\n\r\n\r\n#### 相关题目\r\n\r\n- [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)\r\n- [310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)\r\n- [更多题目](https://leetcode.cn/tag/topological-sort/)\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\r\n        def topo_sort(edges: List[List[int]]) -> List[int]:\r\n            g = [[] for _ in range(k)]\r\n            in_deg = [0] * k\r\n            for x, y in edges:\r\n                g[x - 1].append(y - 1)  # 顶点编号从 0 开始，方便计算\r\n                in_deg[y - 1] += 1\r\n            order = []\r\n            q = deque(i for i, d in enumerate(in_deg) if d == 0)\r\n            while q:\r\n                x = q.popleft()\r\n                order.append(x)\r\n                for y in g[x]:\r\n                    in_deg[y] -= 1\r\n                    if in_deg[y] == 0:\r\n                        q.append(y)\r\n            return order if len(order) == k else None\r\n\r\n        if (row := topo_sort(rowConditions)) is None or (col := topo_sort(colConditions)) is None:\r\n            return []\r\n        pos = {x: i for i, x in enumerate(col)}\r\n        ans = [[0] * k for _ in range(k)]\r\n        for i, x in enumerate(row):\r\n            ans[i][pos[x]] = x + 1\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    int[] topoSort(int k, int[][] edges) {\r\n        List<Integer>[] g = new ArrayList[k];\r\n        Arrays.setAll(g, e -> new ArrayList<>());\r\n        var inDeg = new int[k];\r\n        for (var e : edges) {\r\n            int x = e[0] - 1, y = e[1] - 1; // 顶点编号从 0 开始，方便计算\r\n            g[x].add(y);\r\n            ++inDeg[y];\r\n        }\r\n\r\n        var order = new ArrayList<Integer>();\r\n        var q = new ArrayDeque<Integer>();\r\n        for (var i = 0; i < k; ++i)\r\n            if (inDeg[i] == 0) q.push(i);\r\n        while (!q.isEmpty()) {\r\n            var x = q.pop();\r\n            order.add(x);\r\n            for (var y : g[x])\r\n                if (--inDeg[y] == 0) q.push(y);\r\n        }\r\n        return order.stream().mapToInt(x -> x).toArray();\r\n    }\r\n\r\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\r\n        int[] row = topoSort(k, rowConditions), col = topoSort(k, colConditions);\r\n        if (row.length < k || col.length < k) return new int[][]{};\r\n        var pos = new int[k];\r\n        for (var i = 0; i < k; ++i)\r\n            pos[col[i]] = i;\r\n        var ans = new int[k][k];\r\n        for (var i = 0; i < k; ++i)\r\n            ans[i][pos[row[i]]] = row[i] + 1;\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\n    vector<int> topo_sort(int k, vector<vector<int>> &edges) {\r\n        vector<vector<int>> g(k);\r\n        vector<int> in_deg(k);\r\n        for (auto &e : edges) {\r\n            int x = e[0] - 1, y = e[1] - 1; // 顶点编号从 0 开始，方便计算\r\n            g[x].push_back(y);\r\n            ++in_deg[y];\r\n        }\r\n\r\n        vector<int> order;\r\n        queue<int> q;\r\n        for (int i = 0; i < k; ++i)\r\n            if (in_deg[i] == 0)\r\n                q.push(i);\r\n        while (!q.empty()) {\r\n            int x = q.front();\r\n            q.pop();\r\n            order.push_back(x);\r\n            for (int y : g[x])\r\n                if (--in_deg[y] == 0)\r\n                    q.push(y);\r\n        }\r\n        return order;\r\n    }\r\n\r\npublic:\r\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>> &rowConditions, vector<vector<int>> &colConditions) {\r\n        auto row = topo_sort(k, rowConditions), col = topo_sort(k, colConditions);\r\n        if (row.size() < k || col.size() < k) return {};\r\n        vector<int> pos(k);\r\n        for (int i = 0; i < k; ++i)\r\n            pos[col[i]] = i;\r\n        vector<vector<int>> ans(k, vector<int>(k));\r\n        for (int i = 0; i < k; ++i)\r\n            ans[i][pos[row[i]]] = row[i] + 1;\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc topoSort(k int, edges [][]int) []int {\r\n\tg := make([][]int, k)\r\n\tinDeg := make([]int, k)\r\n\tfor _, e := range edges {\r\n\t\tx, y := e[0]-1, e[1]-1 // 顶点编号从 0 开始，方便计算\r\n\t\tg[x] = append(g[x], y)\r\n\t\tinDeg[y]++\r\n\t}\r\n\tq := make([]int, 0, k)\r\n\torders := q // 复用队列作为拓扑序\r\n\tfor i, d := range inDeg {\r\n\t\tif d == 0 {\r\n\t\t\tq = append(q, i)\r\n\t\t}\r\n\t}\r\n\tfor len(q) > 0 {\r\n\t\tx := q[0]\r\n\t\tq = q[1:]\r\n\t\tfor _, y := range g[x] {\r\n\t\t\tif inDeg[y]--; inDeg[y] == 0 {\r\n\t\t\t\tq = append(q, y)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif cap(q) > 0 {\r\n\t\treturn nil\r\n\t}\r\n\treturn orders[:k]\r\n}\r\n\r\nfunc buildMatrix(k int, rowConditions, colConditions [][]int) [][]int {\r\n\trow := topoSort(k, rowConditions)\r\n\tcol := topoSort(k, colConditions)\r\n\tif row == nil || col == nil {\r\n\t\treturn nil\r\n\t}\r\n\tpos := make([]int, k)\r\n\tfor i, v := range col {\r\n\t\tpos[v] = i\r\n\t}\r\n\tans := make([][]int, k)\r\n\tfor i, x := range row {\r\n\t\tans[i] = make([]int, k)\r\n\t\tans[i][pos[x]] = x + 1\r\n\t}\r\n\treturn ans\r\n}\r\n```\r\n\r\n#### 思考题\r\n\r\n如果问题变成一个三维的立方格，再添加一个 $z$ 轴上的数字约束，要怎么做？\r\n"
}