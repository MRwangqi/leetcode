{
	"titleSlug": "crawler-log-folder",
	"slug": "wen-jian-jia-cao-zuo-ri-zhi-sou-ji-qi-by-6unr",
	"url": "https://leetcode-cn.com/problems/crawler-log-folder/solution/wen-jian-jia-cao-zuo-ri-zhi-sou-ji-qi-by-6unr/",
	"content": "#### 方法一：直接模拟\n\n根据题意可知返回主文件夹的操作为连续退回到上一层目录，直到返回主目录为止，在这种操作下使用的操作数最少。我们用一个变量记录 $\\textit{depth}$ 当前目录的层次深度，$\\textit{depth}$ 初始化为 $0$，根据题意可知：\n+ 如果当前的操作为 $\\texttt{\"../\"}$：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则继续停留在当前文件夹。则此时如果层次深度 $\\textit{depth} > 0$ 则将 $\\textit{depth}$ 减 $1$，否则 $\\textit{depth}$ 保持不变；\n+ 如果当前的操作为 $\\texttt{\"./\"}$：继续停留在当前文件夹，此时 $\\textit{depth}$ 保持不变；\n+ 如果当前的操作为 $\\texttt{\"x/\"}$：移动到下一层名为 $\\textit{x}$ 的子文件夹中。则此时将 $\\textit{depth}$ 加 $1$。\n\n最终返回当前的文件层次深度 $\\textit{depth}$ 即可。\n\n```Python [sol1-Python3]\nclass Solution:\n    def minOperations(self, logs: List[str]) -> int:\n        depth = 0\n        for log in logs:\n            if log == \"./\":\n                continue\n            if log != \"../\":\n                depth += 1\n            elif depth:\n                depth -= 1\n        return depth\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minOperations(vector<string>& logs) {\n        int depth = 0;\n        for (auto & log : logs) {\n            if (log == \"./\") {\n                continue;\n            } else if (log == \"../\") {\n                if (depth > 0) {\n                    depth--;\n                }\n            } else {\n                depth++;\n            }\n        }\n        return depth;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minOperations(String[] logs) {\n        int depth = 0;\n        for (String log : logs) {\n            if (\"./\".equals(log)) {\n                continue;\n            } else if (\"../\".equals(log)) {\n                if (depth > 0) {\n                    depth--;\n                }\n            } else {\n                depth++;\n            }\n        }\n        return depth;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinOperations(string[] logs) {\n        int depth = 0;\n        foreach (string log in logs) {\n            if (\"./\".Equals(log)) {\n                continue;\n            } else if (\"../\".Equals(log)) {\n                if (depth > 0) {\n                    depth--;\n                }\n            } else {\n                depth++;\n            }\n        }\n        return depth;\n    }\n}\n```\n\n```C [sol1-C]\nint minOperations(char ** logs, int logsSize) {\n    int depth = 0;\n    for (int i = 0; i < logsSize; i++) {\n        if (!strcmp(logs[i], \"./\")) {\n            continue;\n        } else if (!strcmp(logs[i], \"../\")) {\n            if (depth > 0) {\n                depth--;\n            }\n        } else {\n            depth++;\n        }\n    }\n    return depth;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minOperations = function(logs) {\n    let depth = 0;\n    for (const log of logs) {\n        if ('./' === log) {\n            continue;\n        } else if ('../' === log) {\n            if (depth > 0) {\n                depth--;\n            }\n        } else {\n            depth++;\n        }\n    }\n    return depth;\n};\n```\n\n```go [sol1-Golang]\nfunc minOperations(logs []string) (depth int) {\n    for _, log := range logs {\n        if log == \"./\" {\n            continue\n        }\n        if log != \"../\" {\n            depth++\n        } else if depth > 0 {\n            depth--\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为字符串数组的长度。只需遍历一遍字符串数组即可。\n\n- 空间复杂度：$O(1)$。"
}