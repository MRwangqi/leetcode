{
	"titleSlug": "count-number-of-ways-to-place-houses",
	"slug": "d-by-endlesscheng-gybx",
	"url": "https://leetcode-cn.com/problems/count-number-of-ways-to-place-houses/solution/d-by-endlesscheng-gybx/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1pW4y1r7xs) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n单独考虑一侧的房子，定义 $f[i]$ 表示前 $i$ 个地块的放置方案数，其中第 $i$ 个地块可以放房子，也可以不放房子。\r\n\r\n考虑第 $i$ 个地块：\r\n\r\n- 若不放房子，那么第 $i-1$ 个地块可放可不放，则有 $f[i] = f[i-1]$；\r\n- 若放房子，那么第 $i-1$ 个地块无法放房子，第 $i-2$ 个地块可放可不放，则有 $f[i] = f[i-2]$。\r\n\r\n因此\r\n\r\n$$\r\nf[i] = f[i-1] + f[i-2]\r\n$$\r\n\r\n边界为\r\n\r\n- $f[0]=1$，空也是一种方案；\r\n- $f[1]=2$，放与不放两种方案。\r\n\r\n由于两侧的房屋互相独立，根据乘法原理，答案为 $f[n]^2$。\r\n\r\n```py [sol1-Python3]\r\nMOD = 10 ** 9 + 7\r\nf = [1, 2]\r\nfor _ in range(10 ** 4 - 1):\r\n    f.append((f[-1] + f[-2]) % MOD)\r\n\r\nclass Solution:\r\n    def countHousePlacements(self, n: int) -> int:\r\n        return f[n] ** 2 % MOD\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    static final int MOD = (int) 1e9 + 7, MX = (int) 1e4 + 1;\r\n    static final int[] f = new int[MX];\r\n\r\n    static {\r\n        f[0] = 1;\r\n        f[1] = 2;\r\n        for (var i = 2; i < MX; ++i)\r\n            f[i] = (f[i - 1] + f[i - 2]) % MOD;\r\n    }\r\n\r\n    public int countHousePlacements(int n) {\r\n        return (int) ((long) f[n] * f[n] % MOD);\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nconst int MOD = 1e9 + 7, MX = 1e4 + 1;\r\nint f[MX] = {1, 2};\r\nint init = []() {\r\n    for (int i = 2; i < MX; ++i)\r\n        f[i] = (f[i - 1] + f[i - 2]) % MOD;\r\n    return 0;\r\n}();\r\n\r\nclass Solution {\r\npublic:\r\n    int countHousePlacements(int n) {\r\n        return (long) f[n] * f[n] % MOD;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nconst mod int = 1e9 + 7\r\nvar f = [1e4 + 1]int{1, 2}\r\nfunc init() {\r\n\tfor i := 2; i <= 1e4; i++ {\r\n\t\tf[i] = (f[i-1] + f[i-2]) % mod\r\n\t}\r\n}\r\n\r\nfunc countHousePlacements(n int) int {\r\n\treturn f[n] * f[n] % mod\r\n}\r\n```"
}