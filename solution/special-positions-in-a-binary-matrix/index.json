{
	"titleSlug": "special-positions-in-a-binary-matrix",
	"slug": "er-jin-zhi-ju-zhen-zhong-de-te-shu-wei-z-kan4",
	"url": "https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix/solution/er-jin-zhi-ju-zhen-zhong-de-te-shu-wei-z-kan4/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n题目给定了一个大小为 $m \\times n$ 的矩阵 $\\textit{mat}$，并满足矩阵中的任意元素为 $1$ 或者 $0$。现在给出**特殊位置**的定义：如果 $\\textit{mat}[i][j] = 1, i \\in [0,m),j \\in [0, n)$，并且第 $i$ 行和第 $j$ 列的其他元素均为 $0$，则位置 $(i,j)$ 为**特殊位置**。那么我们枚举每一个位置，然后按照特殊位置的定义来判断该位置是否满足要求，又因为矩阵中的每一个元素只能为 $1$ 或者 $0$，所以我们可以预处理出每一行和列的和来快速的得到每一行和列中的 $1$ 的个数。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        rows_sum = [sum(row) for row in mat]\n        cols_sum = [sum(col) for col in zip(*mat)]\n        res = 0\n        for i, row in enumerate(mat):\n            for j, x in enumerate(row):\n                if x == 1 and rows_sum[i] == 1 and cols_sum[j] == 1:\n                    res += 1\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int numSpecial(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[] rowsSum = new int[m];\n        int[] colsSum = new int[n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                rowsSum[i] += mat[i][j];\n                colsSum[j] += mat[i][j];\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1 && rowsSum[i] == 1 && colsSum[j] == 1) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int NumSpecial(int[][] mat) {\n        int m = mat.Length, n = mat[0].Length;\n        int[] rowsSum = new int[m];\n        int[] colsSum = new int[n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                rowsSum[i] += mat[i][j];\n                colsSum[j] += mat[i][j];\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1 && rowsSum[i] == 1 && colsSum[j] == 1) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int numSpecial(vector<vector<int>>& mat) {\n        int m = mat.size(), n = mat[0].size();\n        vector<int> rowsSum(m);\n        vector<int> colsSum(n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                rowsSum[i] += mat[i][j];\n                colsSum[j] += mat[i][j];\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1 && rowsSum[i] == 1 && colsSum[j] == 1) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\nint numSpecial(int** mat, int matSize, int* matColSize) {\n    int m = matSize, n = matColSize[0];\n    int *rowsSum = (int *)malloc(sizeof(int) * m);\n    int *colsSum = (int *)malloc(sizeof(int) * n);\n    memset(rowsSum, 0, sizeof(int) * m);\n    memset(colsSum, 0, sizeof(int) * n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            rowsSum[i] += mat[i][j];\n            colsSum[j] += mat[i][j];\n        }\n    }\n    int res = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] == 1 && rowsSum[i] == 1 && colsSum[j] == 1) {\n                res++;\n            }\n        }\n    }\n    free(rowsSum);\n    free(colsSum);\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar numSpecial = function(mat) {\n    const m = mat.length, n = mat[0].length;\n    const rowsSum = new Array(m).fill(0);\n    const colsSum = new Array(n).fill(0);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            rowsSum[i] += mat[i][j];\n            colsSum[j] += mat[i][j];\n        }\n    }\n    let res = 0;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (mat[i][j] === 1 && rowsSum[i] === 1 && colsSum[j] === 1) {\n                res++;\n            }\n        }\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc numSpecial(mat [][]int) (ans int) {\n    rowsSum := make([]int, len(mat))\n    colsSum := make([]int, len(mat[0]))\n    for i, row := range mat {\n        for j, x := range row {\n            rowsSum[i] += x\n            colsSum[j] += x\n        }\n    }\n    for i, row := range mat {\n        for j, x := range row {\n            if x == 1 && rowsSum[i] == 1 && colsSum[j] == 1 {\n                ans++\n            }\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m \\times n)$，其中 $m$ 为矩阵 $\\textit{mat}$ 的行数，$n$ 为矩阵 $\\textit{mat}$ 的列数。\n- 空间复杂度：$O(m + n)$，主要为预处理每一行和列的空间开销。\n\n#### 方法二：列的标记值\n\n在方法一的基础上，我们可以看到对于 $(i,j)$，它为特殊位置的条件为 $\\textit{mat}[i][j]=1$ 且该行和该列中 $1$ 的数量都为 $1$。据此，定义第 $j$ 列的**标记值**为：该列所有 $1$ 所在行中的 $1$ 的数量之和。下面证明，$(i,j)$ 为特殊位置的充要条件是，第 $j$ 列的标记值恰好为 $1$：\n\n+ 如果 $(i,j)$ 为特殊位置，则说明第 $j$ 列只有一个 $1$，这一个 $1$ 所在的第 $i$ 行也只有它这一个 $1$，那么按照标记值的定义可得，第 $j$ 列的标记值为 $1$。\n+ 如果第 $j$ 列的标记值为 $1$，那么说明该列只能有一个 $1$。反证：如果有 $x$ 个 $1$（$x > 1$），则第 $j$ 列的标记值一定 $\\ge x$。既然只能有一个 $1$，设其在第 $i$ 行，那么标记值也是第 $i$ 行中的 $1$ 的数量，即：第 $i$ 行也有且仅有这个 $1$。所以 $(i,j)$ 为特殊位置。\n\n那么整个矩阵的特殊位置的数量就是最后标记值为 $1$ 的列的数量。\n\n进一步地，我们可以用原始矩阵的第一行来作为我们标记列的额外空间，从而使空间复杂度降至 $O(1)$。\n\n```Python [sol2-Python3]\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        for i, row in enumerate(mat):\n            cnt1 = sum(row) - (i == 0)\n            if cnt1:\n                for j, x in enumerate(row):\n                    if x == 1:\n                        mat[0][j] += cnt1\n        return sum(x == 1 for x in mat[0])\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int numSpecial(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        for (int i = 0; i < m; i++) {\n            int cnt1 = 0;\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1) {\n                    cnt1++;\n                }\n            }\n            if (i == 0) {\n                cnt1--;\n            }\n            if (cnt1 > 0) {\n                for (int j = 0; j < n; j++) {\n                    if (mat[i][j] == 1) {\n                        mat[0][j] += cnt1;\n                    }\n                }\n            }\n        }\n        int sum = 0;\n        for (int num : mat[0]) {\n            if (num == 1) {\n                sum++;\n            }\n        }\n        return sum;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int NumSpecial(int[][] mat) {\n        int m = mat.Length, n = mat[0].Length;\n        for (int i = 0; i < m; i++) {\n            int cnt1 = 0;\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1) {\n                    cnt1++;\n                }\n            }\n            if (i == 0) {\n                cnt1--;\n            }\n            if (cnt1 > 0) {\n                for (int j = 0; j < n; j++) {\n                    if (mat[i][j] == 1) {\n                        mat[0][j] += cnt1;\n                    }\n                }\n            }\n        }\n        int sum = 0;\n        foreach (int num in mat[0]) {\n            if (num == 1) {\n                sum++;\n            }\n        }\n        return sum;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int numSpecial(vector<vector<int>>& mat) {\n        int m = mat.size(), n = mat[0].size();\n        for (int i = 0; i < m; i++) {\n            int cnt1 = 0;\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1) {\n                    cnt1++;\n                }\n            }\n            if (i == 0) {\n                cnt1--;\n            }\n            if (cnt1 > 0) {\n                for (int j = 0; j < n; j++) {\n                    if (mat[i][j] == 1) {\n                        mat[0][j] += cnt1;\n                    }\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (mat[0][i] == 1) {\n                sum++;\n            }\n        }\n        return sum;\n    }\n};\n```\n\n```C [sol2-C]\nint numSpecial(int** mat, int matSize, int* matColSize) {\n    int m = matSize, n = matColSize[0];\n    for (int i = 0; i < m; i++) {\n        int cnt1 = 0;\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] == 1) {\n                cnt1++;\n            }\n        }\n        if (i == 0) {\n            cnt1--;\n        }\n        if (cnt1 > 0) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1) {\n                    mat[0][j] += cnt1;\n                }\n            }\n        }\n    }\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        if (mat[0][i] == 1) {\n            sum++;\n        }\n    }\n    return sum;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar numSpecial = function(mat) {\n    const m = mat.length, n = mat[0].length;\n    for (let i = 0; i < m; i++) {\n        let cnt1 = 0;\n        for (let j = 0; j < n; j++) {\n            if (mat[i][j] === 1) {\n                cnt1++;\n            }\n        }\n        if (i === 0) {\n            cnt1--;\n        }\n        if (cnt1 > 0) {\n            for (let j = 0; j < n; j++) {\n                if (mat[i][j] === 1) {\n                    mat[0][j] += cnt1;\n                }\n            }\n        }\n    }\n    let sum = 0;\n    for (const num of mat[0]) {\n        if (num === 1) {\n            sum++;\n        }\n    }\n    return sum;\n};\n```\n\n```go [sol2-Golang]\nfunc numSpecial(mat [][]int) (ans int) {\n    for i, row := range mat {\n        cnt1 := 0\n        for _, x := range row {\n            cnt1 += x\n        }\n        if i == 0 {\n            cnt1--\n        }\n        if cnt1 > 0 {\n            for j, x := range row {\n                if x == 1 {\n                    mat[0][j] += cnt1\n                }\n            }\n        }\n    }\n    for _, x := range mat[0] {\n        if x == 1 {\n            ans++\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m \\times n)$，其中 $m$ 为矩阵 $\\textit{mat}$ 的行数，$n$ 为矩阵 $\\textit{mat}$ 的列数。\n- 空间复杂度：$O(1)$，由于用了原始矩阵的空间来作为我们的辅助空间，所以我们仅使用常量空间。"
}