{
	"titleSlug": "find-xor-sum-of-all-pairs-bitwise-and",
	"slug": "find-xor-sum-of-all-pairs-bitwise-and-by-sok6",
	"url": "https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/solution/find-xor-sum-of-all-pairs-bitwise-and-by-sok6/",
	"content": "#### 方法一：依次确定答案的每一位\n\n**提示 $1$**\n\n我们需要计算的表达式只包含位运算（即按位与运算以及按位异或运算），那么我们是否可以依次确定答案的二进制表示中的每一位？\n\n**思路与算法**\n\n记 $\\textit{und}(i, j) = \\textit{arr}_1[i] \\wedge \\textit{arr}_2[j]$，其中 $\\wedge$ 表示按位与运算，那么我们需要求出的答案即为\n\n$$\n\\underset{\\substack{0\\leq i < m \\\\ 0\\leq j < n}}{{\\LARGE \\oplus}} und(i, j)\n$$\n\n其中 $\\oplus$ 表示按位异或运算，以类似求和 $\\Sigma$ 的形式写在左侧，即表示对所有的 $\\textit{und}(i, j)$ 按照按位异或运算的要求进行求和。\n\n考虑答案的二进制表示的第 $k$ 位，那么 $und(i, j) = 1$ 当且仅当 $\\textit{arr}_1[i]$ 和 $\\textit{arr}_2[j]$ 的二进制表示的第 $k$ 位均为 $1$。除此之外，$\\textit{und}(i, j) = 0$。\n\n当我们对所有 $\\textit{und}(i, j)$ 进行求和时，实际上是对若干个 $1$ 以及若干个 $0$ 进行求和。根据异或运算的性质，一个数与 $0$ 进行异或运算，它的值不改变，因此如果有奇数个 $1$ 进行异或运算，那么最终答案为 $1$，否则为 $0$。\n\n这样一来，我们只要求出数组 $\\textit{arr}_1$ 中二进制表示第 $k$ 位为 $1$ 的元素个数 $\\textit{cnt}_1[k]$，以及数组 $\\textit{arr}_2$ 中二进制表示第 $k$ 位为 $1$ 的元素个数 $\\textit{cnt}_2[k]$，那么就会有 $\\textit{cnt}_1[k] \\times \\textit{cnt}_2[k]$ 个 $1$ 进行异或运算，这样就确定了答案的第 $k$ 位。\n\n**细节**\n\n注意 $\\textit{cnt}_1[k] \\times \\textit{cnt}_2[k]$ 可能会溢出 $32$ 位有符号整数的范围。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int getXORSum(vector<int>& arr1, vector<int>& arr2) {\n        int m = arr1.size();\n        int n = arr2.size();\n        int ans = 0;\n        // 依次确定答案二进制表示中的每一位\n        for (int k = 30; k >= 0; --k) {\n            int cnt1 = 0;\n            for (int num: arr1) {\n                if (num & (1 << k)) {\n                    ++cnt1;\n                }\n            }\n            int cnt2 = 0;\n            for (int num: arr2) {\n                if (num & (1 << k)) {\n                    ++cnt2;\n                }\n            }\n            // 如果 cnt1 和 cnt2 都是奇数，那么答案的第 k 位为 1\n            if (cnt1 % 2 == 1 && cnt2 % 2 == 1) {\n                ans |= (1 << k);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:\n        m, n = len(arr1), len(arr2)\n        ans = 0\n        \n        # 依次确定答案二进制表示中的每一位\n        for k in range(30, -1, -1):\n            cnt1 = sum(1 for num in arr1 if num & (1 << k))\n            cnt2 = sum(1 for num in arr2 if num & (1 << k))\n            # 如果 cnt1 和 cnt2 都是奇数，那么答案的第 k 位为 1\n            if cnt1 % 2 == 1 and cnt2 % 2 == 1:\n                ans |= (1 << k)\n\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O((m + n) \\log C)$，其中 $m$ 和 $n$ 分别是数组 $\\textit{arr}_1$ 和 $\\textit{arr}_2$ 的长度，$C$ 是数组中的元素范围，在本题中 $C \\leq 10^9$。每个数的二进制表示有 $O(\\log C)$ 位，需要枚举 $O(\\log C)$ 次，每一次枚举的过程中需要对两个数组进行依次遍历，时间复杂度为 $O(m + n)$。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：直接确定答案\n\n**提示 $1$**\n\n「且」连接词和按位与运算息息相关。\n「奇偶性」和按位异或运算息息相关。\n\n**思路与算法**\n\n我们进行如下的推导：\n\n- 答案的第 $k$ 位为 $1$\n\n等价于\n\n- $\\textit{cnt}_1[k]$ 为奇数且 $\\textit{cnt}_2[k]$ 为奇数\n\n等价于\n\n- 数组 $\\textit{arr}_1$ 中二进制表示第 $k$ 位的异或和为 $1$ 且数组 $\\textit{arr}_2$ 中二进制表示第 $k$ 位的异或和为 $1$\n\n等价于\n\n- 数组 $\\textit{arr}_1$ 中二进制表示第 $k$ 位的异或和 $\\wedge$ 数组 $\\textit{arr}_2$ 中二进制表示第 $k$ 位的异或和 $=1$\n\n这样一来，我们将数组 $\\textit{arr}_1$ 中的所有元素的异或和记为 $\\textit{tot}_1$，将数组 $\\textit{arr}_2$ 中的所有元素的异或和记为 $\\textit{tot}_2$，答案即为\n\n$$\n\\textit{tot}_1 \\wedge \\textit{tot}_2\n$$\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int getXORSum(vector<int>& arr1, vector<int>& arr2) {\n        int tot1 = accumulate(arr1.begin(), arr1.end(), 0, bit_xor<int>());\n        int tot2 = accumulate(arr2.begin(), arr2.end(), 0, bit_xor<int>());\n        return tot1 & tot2;\n    }\n};\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:\n        tot1 = reduce(xor, arr1)\n        tot2 = reduce(xor, arr2)\n        return tot1 & tot2\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m+n)$。\n\n- 空间复杂度：$O(1)$。"
}