{
	"titleSlug": "find-original-array-from-doubled-array",
	"slug": "2007-cong-shuang-bei-shu-zu-zhong-huan-y-7ym2",
	"url": "https://leetcode-cn.com/problems/find-original-array-from-doubled-array/solution/2007-cong-shuang-bei-shu-zu-zhong-huan-y-7ym2/",
	"content": "### 解题思路\n\n排序，贪心，双针\n排序：原数组和原数组的双倍数顺序一致。\n贪心：能当做原数组两倍用，就当作两倍用。\n双针：原数组待配对的左针l，原数组可追加数字的右针r\n\n排序后的数组，原始数组和双倍数组都是按照对应的顺序出现的。\n\n如果当前数字是还没配对的最前原始数的二倍，当作他的二倍，当前数跳过，下一个配对。\n如果不是二倍追加到原数组尾部。\n\n只有原数组写满并且排序数组用光，返回期待的原数组，否则都是空数组。\n\n-----\n\n [中等] 1877. 数组中最大数对和的最小值【贪心】【数组】【排序】【双指针】[[贪心 排序 双指针](https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/solution/1877-shu-zu-zhong-zui-da-shu-dui-he-de-z-ra8y/)] [[1877. 数组中最大数对和的最小值](https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/)]\n\n\n\n\n### 代码\n\n```java\nclass Solution {\n\tpublic int[] findOriginalArray(int[] changed) {\n\t\tint len = changed.length;\n\t\tif ((len & 1) == 1) {\n\t\t\treturn new int[] {};\n\t\t}\n\t\tint[] ans = new int[len >> 1];\n\t\tint l = 0, r = 0;\n\t\tArrays.sort(changed);\n\t\tArrays.fill(ans, -1);\n\t\tint i = 0;\n\t\twhile (i < len) {\n\t\t\tint num = changed[i];\n\t\t\tif (num == ans[l] * 2) {\n\t\t\t\tl++;\n\t\t\t} else {\n\t\t\t\tif (r < (len >> 1)) {\n\t\t\t\t\tans[r++] = num;\n\t\t\t\t} else {\n\t\t\t\t\treturn new int[] {};\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (l == r && i == len) {\n\t\t\treturn ans;\n\t\t}\n\t\treturn new int[] {};\n\t}\n}\n```"
}