{
	"titleSlug": "number-of-steps-to-reduce-a-number-to-zero",
	"slug": "jiang-shu-zi-bian-cheng-0-de-cao-zuo-ci-ucaa4",
	"url": "https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/solution/jiang-shu-zi-bian-cheng-0-de-cao-zuo-ci-ucaa4/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n将 $\\textit{num}$ 与 $1$ 进行位运算来判断 $\\textit{num}$ 的奇偶性。\n\n记录操作次数时：\n\n* 如果 $\\textit{num}$ 是奇数，我们需要加上一次减 $1$ 的操作。\n\n* 如果 $\\textit{num} > 1$，我们需要加上一次除以 $2$ 的操作。\n\n然后使 $\\textit{num}$ 的值变成 $\\Big\\lfloor\\dfrac{\\textit{num}}{2}\\Big\\rfloor$。重复以上操作直到 $\\textit{num} = 0$ 时结束操作。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int numberOfSteps(int num) {\n        int ret = 0;\n        while (num) {\n            ret += (num > 1 ? 1 : 0) + (num & 0x01);\n            num >>= 1;\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int numberOfSteps(int num) {\n        int ret = 0;\n        while (num > 0) {\n            ret += (num > 1 ? 1 : 0) + (num & 0x01);\n            num >>= 1;\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int NumberOfSteps(int num) {\n        int ret = 0;\n        while (num > 0) {\n            ret += (num > 1 ? 1 : 0) + (num & 0x01);\n            num >>= 1;\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol1-C]\nint numberOfSteps(int num) {\n    int ret = 0;\n    while (num) {\n        ret += (num > 1 ? 1 : 0) + (num & 0x01);\n        num >>= 1;\n    }\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar numberOfSteps = function(num) {\n    let ret = 0;\n    while (num > 0) {\n        ret += (num > 1 ? 1 : 0) + (num & 0x01);\n        num >>= 1;\n    }\n    return ret;\n};\n```\n\n```go [sol1-Golang]\nfunc numberOfSteps(num int) (ans int) {\n    for ; num > 0; num >>= 1 {\n        ans += num & 1\n        if num > 1 {\n            ans++\n        }\n    }\n    return\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def numberOfSteps(self, num: int) -> int:\n        ans = 0\n        while num:\n            ans += num & 1\n            if num > 1:\n                ans += 1\n            num >>= 1\n        return ans\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(\\log \\textit{num})$，其中 $\\textit{num}$ 是输入数值。每次循环都将 $num$ 的数值减半，因此时间复杂度为 $O(\\log \\textit{num})$。\n\n+ 空间复杂度：$O(1)$。只需要常数空间。\n\n#### 方法二：直接计算\n\n**思路与算法**\n\n由方法一的步骤可知，当 $\\textit{num} > 0$ 时，总操作次数等于总减 $1$ 的操作数与总除以 $2$ 的操作数之和。总减 $1$ 的操作数等于 $\\textit{num}$ 二进制位 $1$ 的个数，总除以 $2$ 的操作数等于 $\\textit{num}$ 二进制数长度减 $1$，即最高位右移到最低位的距离。\n\n二进制数长度 $\\textit{len}$ 可以通过前导零数目 $\\textit{clz}$ 间接求解，即 $\\textit{len} = W - clz$，其中 $W = 32$ 是 $\\texttt{int}$ 类型的位数。\n\nC++ 等语言可以用 `__builtin_clz` 和 `__builtin_popcount` 这类函数来求出二进制前导零数目和二进制位 $1$ 的个数，下面介绍其原理及实现。\n\n使用二分法加速求解前导零数目，算法如下：\n\n> 首先判断 $\\textit{num}$ 前半部分是否全为零，如果是，则将 $\\textit{clz}$ 加上前半部分的长度，然后将后半部分作为处理对象，否则将前半部分作为处理对象。重复以上操作直到处理的对象长度为 $1$，直接判断是否有零，有则将 $\\textit{clz}$ 加 $1$。\n\n使用分治法来加速求解二进制数位 $1$ 的个数，算法如下：\n\n> 对二进制数 $\\textit{num}$，它的位 $1$ 的个数等于所有位的值相加的结果，比如 $10110101_{(2)} = 1 + 0 + 1 + 1 + 0 + 1 + 0 + 1$。我们可以将 $8$ 个位的求和分解成 $4$ 个相邻的位的求和，然后将 $4$ 个中间结果分解成 $2$ 个相邻的求和，即 $10110101_{(2)} = (1 + 0) + (1 + 1) + (0 + 1) + (0 + 1) = ((1 + 0) + (1 + 1)) + ((0 + 1) + (0 + 1)) = 5$。$32$ 位数的求解过程同理。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int length(uint num) {\n        uint clz = 0;\n        if ((num >> 16) == 0) {\n            clz += 16;\n            num <<= 16;\n        }\n        if ((num >> 24) == 0) {\n            clz += 8;\n            num <<= 8;\n        }\n        if ((num >> 28) == 0) {\n            clz += 4;\n            num <<= 4;\n        }\n        if ((num >> 30) == 0) {\n            clz += 2;\n            num <<= 2;\n        }\n        if ((num >> 31) == 0) {\n            clz += 1;\n        }\n        return 32 - clz;\n    }\n\n    int count(int num) {\n        num = (num & 0x55555555) + ((num >> 1) & 0x55555555);\n        num = (num & 0x33333333) + ((num >> 2) & 0x33333333);\n        num = (num & 0x0F0F0F0F) + ((num >> 4) & 0x0F0F0F0F);\n        num = (num & 0x00FF00FF) + ((num >> 8) & 0x00FF00FF);\n        num = (num & 0x0000FFFF) + ((num >> 16) & 0x0000FFFF);\n        return num;\n    }\n\n    int numberOfSteps(int num) {\n        return num == 0 ? 0 : length(num) - 1 + count(num);\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int numberOfSteps(int num) {\n        return num == 0 ? 0 : length(num) - 1 + count(num);\n    }\n\n    public int length(int num) {\n        int clz = 0;\n        if ((num >> 16) == 0) {\n            clz += 16;\n            num <<= 16;\n        }\n        if ((num >> 24) == 0) {\n            clz += 8;\n            num <<= 8;\n        }\n        if ((num >> 28) == 0) {\n            clz += 4;\n            num <<= 4;\n        }\n        if ((num >> 30) == 0) {\n            clz += 2;\n            num <<= 2;\n        }\n        if ((num >> 31) == 0) {\n            clz += 1;\n        }\n        return 32 - clz;\n    }\n\n    public int count(int num) { \n        num = (num & 0x55555555) + ((num >> 1) & 0x55555555);\n        num = (num & 0x33333333) + ((num >> 2) & 0x33333333);\n        num = (num & 0x0F0F0F0F) + ((num >> 4) & 0x0F0F0F0F);\n        num = (num & 0x00FF00FF) + ((num >> 8) & 0x00FF00FF);\n        num = (num & 0x0000FFFF) + ((num >> 16) & 0x0000FFFF);\n        return num;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int NumberOfSteps(int num) {\n        return num == 0 ? 0 : Length(num) - 1 + Count(num);\n    }\n\n    public int Length(int num) {\n        int clz = 0;\n        if ((num >> 16) == 0) {\n            clz += 16;\n            num <<= 16;\n        }\n        if ((num >> 24) == 0) {\n            clz += 8;\n            num <<= 8;\n        }\n        if ((num >> 28) == 0) {\n            clz += 4;\n            num <<= 4;\n        }\n        if ((num >> 30) == 0) {\n            clz += 2;\n            num <<= 2;\n        }\n        if ((num >> 31) == 0) {\n            clz += 1;\n        }\n        return 32 - clz;\n    }\n\n    public int Count(int num) { \n        num = (num & 0x55555555) + ((num >> 1) & 0x55555555);\n        num = (num & 0x33333333) + ((num >> 2) & 0x33333333);\n        num = (num & 0x0F0F0F0F) + ((num >> 4) & 0x0F0F0F0F);\n        num = (num & 0x00FF00FF) + ((num >> 8) & 0x00FF00FF);\n        num = (num & 0x0000FFFF) + ((num >> 16) & 0x0000FFFF);\n        return num;\n    }\n}\n```\n\n```C [sol2-C]\nint length(uint num) {\n    uint clz = 0;\n    if ((num >> 16) == 0) {\n        clz += 16;\n        num <<= 16;\n    }\n    if ((num >> 24) == 0) {\n        clz += 8;\n        num <<= 8;\n    }\n    if ((num >> 28) == 0) {\n        clz += 4;\n        num <<= 4;\n    }\n    if ((num >> 30) == 0) {\n        clz += 2;\n        num <<= 2;\n    }\n    if ((num >> 31) == 0) {\n        clz += 1;\n    }\n    return 32 - clz;\n}\n\nint count(int num) {\n    num = (num & 0x55555555) + ((num >> 1) & 0x55555555);\n    num = (num & 0x33333333) + ((num >> 2) & 0x33333333);\n    num = (num & 0x0F0F0F0F) + ((num >> 4) & 0x0F0F0F0F);\n    num = (num & 0x00FF00FF) + ((num >> 8) & 0x00FF00FF);\n    num = (num & 0x0000FFFF) + ((num >> 16) & 0x0000FFFF);\n    return num;\n}\n\nint numberOfSteps(int num) {\n    return num == 0 ? 0 : length(num) - 1 + count(num);\n}\n```\n\n```go [sol2-Golang]\nfunc bitsLen(x uint) int {\n    clz := 0\n    if x>>16 == 0 {\n        clz += 16\n        x <<= 16\n    }\n    if x>>24 == 0 {\n        clz += 8\n        x <<= 8\n    }\n    if x>>28 == 0 {\n        clz += 4\n        x <<= 4\n    }\n    if x>>30 == 0 {\n        clz += 2\n        x <<= 2\n    }\n    if x>>31 == 0 {\n        clz++\n    }\n    return 32 - clz\n}\n\nfunc onesCount(num uint) int {\n    num = num&0x55555555 + num>>1&0x55555555\n    num = num&0x33333333 + num>>2&0x33333333\n    num = num&0x0F0F0F0F + num>>4&0x0F0F0F0F\n    num = num&0x00FF00FF + num>>8&0x00FF00FF\n    num = num&0x0000FFFF + num>>16&0x0000FFFF\n    return int(num)\n}\n\nfunc numberOfSteps(num int) (ans int) {\n    if num == 0 {\n        return 0\n    }\n    return bitsLen(uint(num)) - 1 + onesCount(uint(num))\n}\n```\n\n```Python [sol2-Python3]\ndef length(num: int) -> int:\n    clz = 0\n    if (num >> 16) == 0:\n        clz += 16\n        num <<= 16\n    if (num >> 24) == 0:\n        clz += 8\n        num <<= 8\n    if (num >> 28) == 0:\n        clz += 4\n        num <<= 4\n    if (num >> 30) == 0:\n        clz += 2\n        num <<= 2\n    if (num >> 31) == 0:\n        clz += 1\n    return 32 - clz\n\ndef count(num: int) -> int:\n    num = (num & 0x55555555) + ((num >> 1) & 0x55555555)\n    num = (num & 0x33333333) + ((num >> 2) & 0x33333333)\n    num = (num & 0x0F0F0F0F) + ((num >> 4) & 0x0F0F0F0F)\n    num = (num & 0x00FF00FF) + ((num >> 8) & 0x00FF00FF)\n    num = (num & 0x0000FFFF) + ((num >> 16) & 0x0000FFFF)\n    return num\n\nclass Solution:\n    def numberOfSteps(self, num: int) -> int:\n        return length(num) - 1 + count(num) if num else 0\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(\\log W)$，其中 $W = 32$ 是 $\\texttt{int}$ 类型的位数。计算二进制长度算法的时间复杂度为 $O(\\log W)$；统计二进制数位 $1$ 的个数算法的时间复杂度为 $O(\\log W)$。\n\n+ 空间复杂度：$O(1)$。只需要常数空间。"
}