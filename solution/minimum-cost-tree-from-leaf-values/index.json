{
	"titleSlug": "minimum-cost-tree-from-leaf-values",
	"slug": "wei-shi-yao-dan-diao-di-jian-zhan-de-suan-fa-ke-xi",
	"url": "https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values/solution/wei-shi-yao-dan-diao-di-jian-zhan-de-suan-fa-ke-xi/",
	"content": "### 解题思路\n首先，想让 mct 值最小，那么值较小的叶子节点就要尽量放到底部，值较大的叶子节点要尽量放到靠上的部分。因为越是底部的叶子节点，被用来做乘法的次数越多。这就决定了我们有必要去寻找一个极小值。通过维护一个单调递减栈就可以找到一个极小值，因为既然是单调递减栈，左侧节点一定大于栈顶节点，而当前节点（右侧）也大于栈顶节点（因为当前节点小于栈顶的话，就被直接入栈了）。\n\n然后找到这个极小值后，就需要左右看看，左边和右边哪个值更小，因为我们的目的是把较小的值尽量放到底部。还有一点，构造出来的二叉树一定是形如下面图一的样子，比如 `[6,2,3,4]` 构成的二叉树：\n\n图一 (最小 mct 一定形如以下的样子)：\nmct: 24 + 12 + 6 = 42\n```\n  24\n /  \\\n6    12\n    /  \\\n   6    4\n  / \\\n 2   3\n```\n\n图二 (这个容易想到，但是一定不是最小 mct)：\nmct: 24 + 12 + 12 = 48\n```\n     24\n    /  \\\n  12    12\n / \\    / \\\n6   2  3   4\n```\n\n<br>\n\n-----\n\n在栈 `st` 的栈底，我们可以放一个 `Integer.MAX_VALUE`，方便做比较，分析一遍 `[6,2,3,4]` 的运行过程：\n1. `[Integer.MAX_VALUE], 6` => 入栈\n2. `[Integer.MAX_VALUE, 6], 2` => 入栈\n3. `[Integer.MAX_VALUE, 6, 2], 3` => 先取出 2，与 3 组合(左 6 右 3 中取较小的一个)，然后把 3 入栈(3 会作为一侧最大值，参与后续乘法):\n    `mct += st.pop() * Math.min(st.peek(), arr[i]);`\n\n    ```\n      6\n     / \\\n    2   3\n    ```\n\n4. `[Integer.MAX_VALUE, 6, 3], 4` => 3，出栈，4 入栈，最终结果 mct 会加上 3 * 4 的值:\n    `mct += st.pop() * Math.min(st.peek(), arr[i]);`\n    ```\n        12\n       /  \\\n      6    4\n     / \\\n    2   3\n    ```\n\n5. `[Integer.MAX_VALUE, 6, 4]` => 源数组已遍历完，栈中还有较多数据，那么依次出栈做计算：\n`while (st.size() > 2) mct += st.pop() * st.peek();`\n    ```\n      24\n     /  \\\n    6    12\n        /  \\\n       6    4\n      / \\\n     2   3\n    ```\n    \n可见，栈顶存的一直是当时能找到的最小值，也是二叉树某侧的叶子节点最大值，可以直接参与乘法运算。\n\n-----\n\n再随便看一下全部递增和全部递减的数据的构造过程：\n**[1,2,3,4]**:\n\n`[Integer.MAX_VALUE, 1], 2` =>\n`while (arr[i] >= st.peek()) mct += st.pop() * Math.min(st.peek(), arr[i]);`\n```\n  2\n / \\\n1   2\n```\n\n`[Integer.MAX_VALUE, 2], 3` =>\n`while (arr[i] >= st.peek()) mct += st.pop() * Math.min(st.peek(), arr[i]);`\n```\n    6\n   / \\\n  2   3\n / \\\n1   2\n```\n\n`[Integer.MAX_VALUE, 3], 4` =>\n`while (arr[i] >= st.peek()) mct += st.pop() * Math.min(st.peek(), arr[i]);`\n```\n      12\n     /  \\\n    6    4\n   / \\\n  2   3\n / \\\n1   2\n```\n\n-----\n\n**[4,3,2,1]**:\n\n`[Integer.MAX_VALUE, 4, 3, 2, 1]` =>\n`while (st.size() > 2) mct += st.pop() * st.peek();`\n```\n  2\n / \\\n2   1\n```\n\n`[Integer.MAX_VALUE, 4, 3, 2]` =>\n`while (st.size() > 2) mct += st.pop() * st.peek();`\n```\n  6\n / \\\n3   2\n   / \\\n  2   1\n```\n\n`[Integer.MAX_VALUE, 4, 3]` =>\n`while (st.size() > 2) mct += st.pop() * st.peek();`\n```\n  12\n /  \\\n4    6\n    / \\\n   3   2\n      / \\\n     2   1\n```\n \n都能正确构造出正确的最小 mct 树。\n其余情况其实最终都可以归并到这些情况之中。\n\n### 代码\n\n```java\nclass Solution {\n    public int mctFromLeafValues(int[] arr) {\n        Stack<Integer> st = new Stack();\n        st.push(Integer.MAX_VALUE);\n        int mct = 0;\n        for (int i = 0; i < arr.length; i++) {\n            while (arr[i] >= st.peek()) {\n                mct += st.pop() * Math.min(st.peek(), arr[i]);\n            }\n            st.push(arr[i]);\n        }\n        while (st.size() > 2) {\n            mct += st.pop() * st.peek();\n        }\n        return mct;\n    }\n}\n```"
}