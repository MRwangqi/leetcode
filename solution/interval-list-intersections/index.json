{
	"titleSlug": "interval-list-intersections",
	"slug": "qu-jian-lie-biao-de-jiao-ji-by-leetcode",
	"url": "https://leetcode-cn.com/problems/interval-list-intersections/solution/qu-jian-lie-biao-de-jiao-ji-by-leetcode/",
	"content": "#### 方法：归并区间\n\n**思路**\n\n我们称 `b` 为区间 `[a, b]` 的末端点。\n\n在两个数组给定的所有区间中，假设拥有最小末端点的区间是 `A[0]`。（为了不失一般性，该区间出现在数组 A 中)\n\n然后，在数组 `B` 的区间中， `A[0]` 只可能与数组 `B` 中的至多一个区间相交。（如果 `B` 中存在两个区间均与 `A[0]` 相交，那么它们将共同包含 `A[0]` 的末端点，但是 `B` 中的区间应该是不相交的，所以存在矛盾）\n\n**算法**\n\n如果 `A[0]` 拥有最小的末端点，那么它只可能与 `B[0]` 相交。然后我们就可以删除区间 `A[0]`，因为它不能与其他任何区间再相交了。\n\n相似的，如果 `B[0]` 拥有最小的末端点，那么它只可能与区间 `A[0]` 相交，然后我们就可以将 `B[0]` 删除，因为它无法再与其他区间相交了。\n\n我们用两个指针 `i` 与 `j` 来模拟完成删除 `A[0]` 或 `B[0]` 的操作。\n\n```java [solution-Java]\nclass Solution {\n  public int[][] intervalIntersection(int[][] A, int[][] B) {\n    List<int[]> ans = new ArrayList();\n    int i = 0, j = 0;\n\n    while (i < A.length && j < B.length) {\n      // Let's check if A[i] intersects B[j].\n      // lo - the startpoint of the intersection\n      // hi - the endpoint of the intersection\n      int lo = Math.max(A[i][0], B[j][0]);\n      int hi = Math.min(A[i][1], B[j][1]);\n      if (lo <= hi)\n        ans.add(new int[]{lo, hi});\n\n      // Remove the interval with the smallest endpoint\n      if (A[i][1] < B[j][1])\n        i++;\n      else\n        j++;\n    }\n\n    return ans.toArray(new int[ans.size()][]);\n  }\n}\n```\n\n```python [solution-python]\nclass Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        ans = []\n        i = j = 0\n\n        while i < len(A) and j < len(B):\n            # Let's check if A[i] intersects B[j].\n            # lo - the startpoint of the intersection\n            # hi - the endpoint of the intersection\n            lo = max(A[i][0], B[j][0])\n            hi = min(A[i][1], B[j][1])\n            if lo <= hi:\n                ans.append([lo, hi])\n\n            # Remove the interval with the smallest endpoint\n            if A[i][1] < B[j][1]:\n                i += 1\n            else:\n                j += 1\n\n        return ans\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(M + N)$，其中 $M, N$ 分别是数组 `A` 和 `B` 的长度。\n\n* 空间复杂度：$O(M + N)$，答案中区间数量的上限。"
}