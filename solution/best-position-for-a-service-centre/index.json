{
	"titleSlug": "best-position-for-a-service-centre",
	"slug": "fu-wu-zhong-xin-de-zui-jia-wei-zhi-by-leetcode-sol",
	"url": "https://leetcode-cn.com/problems/best-position-for-a-service-centre/solution/fu-wu-zhong-xin-de-zui-jia-wei-zhi-by-leetcode-sol/",
	"content": "#### 前言\n\n比起普通的算法题，本题更像是机器学习岗位面试中的一道数学题。题目中给定的函数是一个凸函数（convex function），因此这是一个凸优化问题，「局部最小值」就等于「全局最小值」。\n\n需要注意的是，最终的结果 $(x_c, y_c)$ 是给定的 $\\{x_i\\}$ 和 $\\{y_i\\}$ 的「几何中位数」。几何中位数并没有解析解，我们无法直接求出「全局最小值」。但我们可以使用求解「局部最小值」的方法，得到的结果就等于「全局最小值」。\n\n> 为了叙述方便，本题解用 $(x_c, y_c)$ 表示题目描述中的 $(x_{center}, y_{center})$。\n\n本题解会简单科普一些常用的求解「局部最小值」的算法。由于大部分算法为迭代法，因此不给出复杂度分析。凸函数的证明过程可参考文末的「凸函数证明」部分。\n\n#### 方法一：梯度下降法\n\n「梯度下降法」是机器学习中常用的一种求解局部最小值的算法。对于给定的点 $(x, y)$，它的梯度方向是函数值上升最快的方向，因此梯度反向就是函数值下降最快的方向。本题中需要优化的函数为：\n\n$$\nf(x_c, y_c) = \\sum_{i=0}^{n-1} \\sqrt{(x_c-x_i)^2 + (y_c-y_i)^2}\n$$\n\n它的导数为：\n\n$$\n\\left\\{\n\\begin{aligned}\n\\frac{\\partial f}{\\partial x} = \\sum_{i=0}^{n-1} \\frac{x_c-x_i}{\\sqrt{(x_c-x_i)^2 + (y_c-y_i)^2}} \\\\\n\\frac{\\partial f}{\\partial y} = \\sum_{i=0}^{n-1} \\frac{y_c-y_i}{\\sqrt{(x_c-x_i)^2 + (y_c-y_i)^2}}\n\\end{aligned}\n\\right.\n$$\n\n那么梯度反向 $-\\nabla f = (-\\dfrac{\\partial f}{\\partial x}, -\\dfrac{\\partial f}{\\partial y})$。我们从一个初始点 $(x_{start}, y_{start})$ 开始进行迭代，每次令\n\n$$\n\\left\\{\n\\begin{aligned}\nx'_{start} = x_{start} - \\alpha \\cdot \\frac{\\partial f}{\\partial x} \\\\\ny'_{start} = y_{start} - \\alpha \\cdot \\frac{\\partial f}{\\partial y}\n\\end{aligned}\n\\right.\n$$\n\n得到一个新的点 $(x'_{start}, y'_{start})$，其中 $\\alpha$ 为学习率（learning rate）。当迭代了一定次数之后，当前的点会非常接近真正的最小值点，如果我们的学习速率保持不变，迭代的结果将会在最小值点的周围来回「震荡」，无法继续接近最小值点。因此，我们需要设置学习率衰减（learning rate decay），在迭代的过程中逐步减小学习率，向最小值点逼近。\n\n我们也可以使用机器学习中的一些技巧，例如「小批量梯度下降法」等，每次只对一批 $(x_i, y_i)$ 进行求导并更新答案。在下面的代码中，我们令：\n\n- 初始点 $(x_{start}, y_{start}) = \\left(\\dfrac{\\sum_{i=0}^{n-1} x_i}{n}, \\dfrac{\\sum_{i=0}^{n-1} y_i}{n} \\right)$，即算术平均值；\n\n- 学习率 $\\alpha = 1$；\n\n- 学习率衰减 $\\eta = 10^{-3}$；\n\n- 当 $(x_{start}, y_{start})$ 与 $(x'_{start}, y'_{start})$ 的距离小于 $10^{-7}$ 时结束迭代。\n\n对于下面的代码，当批大小 $\\text{batchSize} = n$，为「批量梯度下降法」，可以通过本题；当 $n=8/16$ 等常用值时，为「小批量梯度下降法」，由于具有随机性，可能得到的解并不精确，但有较高概率可以通过本题。\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    double getMinDistSum(vector<vector<int>>& positions) {\n        double eps = 1e-7;\n        double alpha = 1;\n        double decay = 1e-3;\n        \n        int n = positions.size();\n        // 调整批大小\n        int batchSize = n;\n        \n        double x = 0.0, y = 0.0;\n        for (const auto& pos: positions) {\n            x += pos[0];\n            y += pos[1];\n        }\n        x /= n;\n        y /= n;\n        \n        // 计算服务中心 (xc, yc) 到客户的欧几里得距离之和\n        auto getDist = [&](double xc, double yc) {\n            double ans = 0;\n            for (const auto& pos: positions) {\n                ans += sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc));\n            }\n            return ans;\n        };\n        \n        mt19937 gen{random_device{}()};\n\n        while (true) {\n            // 将数据随机打乱\n            shuffle(positions.begin(), positions.end(), gen);\n            double xPrev = x;\n            double yPrev = y;\n\n            for (int i = 0; i < n; i += batchSize) {\n                int j = min(i + batchSize, n);\n                double dx = 0.0, dy = 0.0;\n                // 计算导数，注意处理分母为零的情况\n                for (int k = i; k < j; ++k) {\n                    const auto& pos = positions[k];\n                    dx += (x - pos[0]) / (sqrt((x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1])) + eps);\n                    dy += (y - pos[1]) / (sqrt((x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1])) + eps);\n                }\n                x -= alpha * dx;\n                y -= alpha * dy;\n\n                // 每一轮迭代后，将学习率进行衰减\n                alpha *= (1.0 - decay);\n            }\n            \n            // 判断是否结束迭代\n            if (sqrt((x - xPrev) * (x - xPrev) + (y - yPrev) * (y - yPrev)) < eps) {\n                break;\n            }\n        }\n        \n        return getDist(x, y);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public double getMinDistSum(int[][] positions) {\n        double eps = 1e-7;\n        double alpha = 1;\n        double decay = 1e-3;\n        \n        int n = positions.length;\n        // 调整批大小\n        int batchSize = n;\n        \n        double x = 0.0, y = 0.0;\n        for (int[] pos : positions) {\n            x += pos[0];\n            y += pos[1];\n        }\n        x /= n;\n        y /= n;\n        \n        while (true) {\n            // 将数据随机打乱\n            shuffle(positions);\n            double xPrev = x;\n            double yPrev = y;\n\n            for (int i = 0; i < n; i += batchSize) {\n                int j = Math.min(i + batchSize, n);\n                double dx = 0.0, dy = 0.0;\n                // 计算导数，注意处理分母为零的情况\n                for (int k = i; k < j; ++k) {\n                    int[] pos = positions[k];\n                    dx += (x - pos[0]) / (Math.sqrt((x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1])) + eps);\n                    dy += (y - pos[1]) / (Math.sqrt((x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1])) + eps);\n                }\n                x -= alpha * dx;\n                y -= alpha * dy;\n\n                // 每一轮迭代后，将学习率进行衰减\n                alpha *= (1.0 - decay);\n            }\n            \n            // 判断是否结束迭代\n            if (Math.sqrt((x - xPrev) * (x - xPrev) + (y - yPrev) * (y - yPrev)) < eps) {\n                break;\n            }\n        }\n        \n        return getDist(x, y, positions);\n    }\n\n    public void shuffle(int[][] positions) {\n        Random rand = new Random();\n        int n = positions.length;\n        for (int i = 0; i < n; i++) {\n            int x = positions[i][0], y = positions[i][1];\n            int randIndex = rand.nextInt(n);\n            positions[i][0] = positions[randIndex][0];\n            positions[i][1] = positions[randIndex][1];\n            positions[randIndex][0] = x;\n            positions[randIndex][1] = y;\n        }\n    }\n\n    // 计算服务中心 (xc, yc) 到客户的欧几里得距离之和\n    public double getDist(double xc, double yc, int[][] positions) {\n        double ans = 0;\n        for (int[] pos : positions) {\n            ans += Math.sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc));\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def getMinDistSum(self, positions: List[List[int]]) -> float:\n        eps = 1e-7\n        alpha = 1.0\n        decay = 1e-3\n\n        n = len(positions)\n        # 调整批大小\n        batchSize = n\n\n        x = sum(pos[0] for pos in positions) / n\n        y = sum(pos[1] for pos in positions) / n\n        \n        # 计算服务中心 (xc, yc) 到客户的欧几里得距离之和\n        getDist = lambda xc, yc: sum(((x - xc) ** 2 + (y - yc) ** 2) ** 0.5 for x, y in positions)\n        \n        while True:\n            # 将数据随机打乱\n            random.shuffle(positions)\n            xPrev, yPrev = x, y\n\n            for i in range(0, n, batchSize):\n                j = min(i + batchSize, n)\n                dx, dy = 0.0, 0.0\n\n                # 计算导数，注意处理分母为零的情况\n                for k in range(i, j):\n                    pos = positions[k]\n                    dx += (x - pos[0]) / (sqrt((x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1])) + eps)\n                    dy += (y - pos[1]) / (sqrt((x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1])) + eps)\n                \n                x -= alpha * dx\n                y -= alpha * dy\n\n                # 每一轮迭代后，将学习率进行衰减\n                alpha *= (1.0 - decay)\n            \n            # 判断是否结束迭代\n            if ((x - xPrev) ** 2 + (y - yPrev) ** 2) ** 0.5 < eps:\n                break\n\n        return getDist(x, y)\n```\n\n```C [sol1-C]\ndouble getDist(int** positions, int positionsSize, double xc, double yc) {\n    double ans = 0;\n    for (int i = 0; i < positionsSize; i++) {\n        int* pos = positions[i];\n        ans += sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc));\n    }\n    return ans;\n};\n\nvoid shuffle(int** positions, int positionsSize) {\n    for (int i = positionsSize - 1; i >= 0; i--) {\n        int add = rand() % (i + 1);\n        int tmp[2] = {positions[add][0], positions[add][1]};\n        positions[add][0] = positions[i][0];\n        positions[add][1] = positions[i][1];\n        positions[i][0] = tmp[0];\n        positions[i][1] = tmp[1];\n    }\n}\n\ndouble getMinDistSum(int** positions, int positionsSize, int* positionsColSize) {\n    double eps = 1e-7;\n    double alpha = 1;\n    double decay = 1e-3;\n\n    int batchSize = positionsSize;\n\n    double x = 0.0, y = 0.0;\n    for (int i = 0; i < positionsSize; i++) {\n        int* pos = positions[i];\n        x += pos[0];\n        y += pos[1];\n    }\n    x /= positionsSize;\n    y /= positionsSize;\n\n    srand(time(0));\n\n    while (true) {\n        // 将数据随机打乱\n        shuffle(positions, positionsSize);\n        double xPrev = x;\n        double yPrev = y;\n\n        for (int i = 0; i < positionsSize; i += batchSize) {\n            int j = fmin(i + batchSize, positionsSize);\n            double dx = 0.0, dy = 0.0;\n            // 计算导数，注意处理分母为零的情况\n            for (int k = i; k < j; ++k) {\n                int* pos = positions[k];\n                dx += (x - pos[0]) / (sqrt((x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1])) + eps);\n                dy += (y - pos[1]) / (sqrt((x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1])) + eps);\n            }\n            x -= alpha * dx;\n            y -= alpha * dy;\n\n            // 每一轮迭代后，将学习率进行衰减\n            alpha *= (1.0 - decay);\n        }\n\n        // 判断是否结束迭代\n        if (sqrt((x - xPrev) * (x - xPrev) + (y - yPrev) * (y - yPrev)) < eps) {\n            break;\n        }\n    }\n\n    return getDist(positions, positionsSize, x, y);\n}\n```\n\n#### 方法二：爬山法\n\n如果给定的凸函数很难进行求导（或者读者懒得求导）怎么办？注意到梯度反向 $-\\nabla f = (-\\dfrac{\\partial f}{\\partial x}, -\\dfrac{\\partial f}{\\partial y})$ 实际上可以拆分成：\n\n$$\n\\begin{aligned}\n(-\\dfrac{\\partial f}{\\partial x}, -\\dfrac{\\partial f}{\\partial y}) &= (-\\dfrac{\\partial f}{\\partial x}, 0) + (0, -\\dfrac{\\partial f}{\\partial y}) \\\\\n&= -\\dfrac{\\partial f}{\\partial x} \\cdot (1, 0)  -\\dfrac{\\partial f}{\\partial y} \\cdot (0, 1)\n\\end{aligned}\n$$\n\n即我们「横向」移动若干个单位长度，「纵向」移动若干个单位长度，也可以得到和梯度下降一样的结果。因此我们只需要考虑四个方向，即单位向量 $(1, 0)$，$(-1, 0)$，$(0, 1)$ 和 $(0, -1)$。\n\n初始时，我们选择一个「步长」$\\text{step}$，表示每次移动的距离。如果我们当前在位置 $(x, y)$，我们就依次枚举四个方向 $(d_x, d_y)$，并判断 $(x + \\text{step} \\cdot d_x, y + \\text{step} \\cdot d_y)$ 对应的函数值是否更小。如果找到一个满足要求的方向，我们就进行移动；否则说明我们当前的「步长」较大，直接越过了最值点，因此调整步长为原来的一半，直到步长小于给定的阈值 $\\epsilon$。\n\n在下面的代码中，我们令：\n\n- 初始点 $(x_{start}, y_{start}) = \\left(\\dfrac{\\sum_{i=0}^{n-1} x_i}{n}, \\dfrac{\\sum_{i=0}^{n-1} y_i}{n} \\right)$，即算术平均值；\n\n- 步长 $\\text{step} = 1$；\n\n- 步长阈值 $\\epsilon = 10^{-7}$；\n\n就可以通过本题。\n\n这种方法叫做「爬山法」：如果我们将一个凸函数倒过来看，它会形成一个类似「山峰」的形状。在我们攀登顶峰（找到最大值点）的过程中，我们可能并不知道顶峰在哪里。但如果我们每一步都环顾四周，走向更高的地方（检查四个方向的函数值是否更大），那么我们最终总能到达山峰。\n\n```C++ [sol2-C++]\nclass Solution {\nprivate:\n    static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\npublic:\n    double getMinDistSum(vector<vector<int>>& positions) {\n        double eps = 1e-7;\n        double step = 1;\n        double decay = 0.5;\n        \n        int n = positions.size();\n        \n        double x = 0.0, y = 0.0;\n        for (const auto& pos: positions) {\n            x += pos[0];\n            y += pos[1];\n        }\n        x /= n;\n        y /= n;\n        \n        // 计算服务中心 (xc, yc) 到客户的欧几里得距离之和\n        auto getDist = [&](double xc, double yc) {\n            double ans = 0;\n            for (const auto& pos: positions) {\n                ans += sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc));\n            }\n            return ans;\n        };\n        \n        while (step > eps) {\n            bool modified = false;\n            for (int i = 0; i < 4; ++i) {\n                double xNext = x + step * dirs[i][0];\n                double yNext = y + step * dirs[i][1];\n                if (getDist(xNext, yNext) < getDist(x, y)) {\n                    x = xNext;\n                    y = yNext;\n                    modified = true;\n                    break;\n                }\n            }\n            if (!modified) {\n                step *= (1.0 - decay);\n            }\n        }\n        \n        return getDist(x, y);\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    private static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public double getMinDistSum(int[][] positions) {\n        double eps = 1e-7;\n        double step = 1;\n        double decay = 0.5;\n        \n        int n = positions.length;\n        \n        double x = 0.0, y = 0.0;\n        for (int[] pos : positions) {\n            x += pos[0];\n            y += pos[1];\n        }\n        x /= n;\n        y /= n;\n        \n        while (step > eps) {\n            boolean modified = false;\n            for (int i = 0; i < 4; ++i) {\n                double xNext = x + step * dirs[i][0];\n                double yNext = y + step * dirs[i][1];\n                if (getDist(xNext, yNext, positions) < getDist(x, y, positions)) {\n                    x = xNext;\n                    y = yNext;\n                    modified = true;\n                    break;\n                }\n            }\n            if (!modified) {\n                step *= (1.0 - decay);\n            }\n        }\n        \n        return getDist(x, y, positions);\n    }\n\n    // 计算服务中心 (xc, yc) 到客户的欧几里得距离之和\n    public double getDist(double xc, double yc, int[][] positions) {\n        double ans = 0;\n        for (int[] pos : positions) {\n            ans += Math.sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc));\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def getMinDistSum(self, positions: List[List[int]]) -> float:\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        eps = 1e-7\n        step = 1.0\n        decay = 0.5\n\n        n = len(positions)\n\n        x = sum(pos[0] for pos in positions) / n\n        y = sum(pos[1] for pos in positions) / n\n        \n        # 计算服务中心 (xc, yc) 到客户的欧几里得距离之和\n        getDist = lambda xc, yc: sum(((x - xc) ** 2 + (y - yc) ** 2) ** 0.5 for x, y in positions)\n        \n        while step > eps:\n            modified = False\n            for dx, dy in dirs:\n                xNext = x + step * dx\n                yNext = y + step * dy\n                if getDist(xNext, yNext) < getDist(x, y):\n                    x, y = xNext, yNext\n                    modified = True\n                    break\n            if not modified:\n                step *= (1.0 - decay)\n\n        return getDist(x, y)\n```\n\n```C [sol2-C]\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\ndouble getDist(int** positions, int positionsSize, double xc, double yc) {\n    double ans = 0;\n    for (int i = 0; i < positionsSize; i++) {\n        int* pos = positions[i];\n        ans += sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc));\n    }\n    return ans;\n};\n\nconst int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\ndouble getMinDistSum(int** positions, int positionsSize, int* positionsColSize) {\n    double eps = 1e-7;\n    double step = 1;\n    double decay = 0.5;\n\n    int batchSize = positionsSize;\n\n    double x = 0.0, y = 0.0;\n    for (int i = 0; i < positionsSize; i++) {\n        int* pos = positions[i];\n        x += pos[0];\n        y += pos[1];\n    }\n    x /= positionsSize;\n    y /= positionsSize;\n\n    while (step > eps) {\n        bool modified = false;\n        for (int i = 0; i < 4; ++i) {\n            double xNext = x + step * dirs[i][0];\n            double yNext = y + step * dirs[i][1];\n            if (getDist(positions, positionsSize, xNext, yNext) < getDist(positions, positionsSize, x, y)) {\n                x = xNext;\n                y = yNext;\n                modified = true;\n                break;\n            }\n        }\n        if (!modified) {\n            step *= (1.0 - decay);\n        }\n    }\n\n    return getDist(positions, positionsSize, x, y);\n}\n```\n\n#### 方法三：三分查找\n\n除了寻找下降的方向之外，我们也可以使用「三分查找」，逐步缩小范围，找到最小值点。\n\n考虑一个 $\\mathbb{R}$ 上的凸函数 $y = f(x)$，它的定义域为 $[L, R]$，我们可以用三分查找的方式将不可能包含最小值点的范围排除：\n\n- 我们取两个点 $x_1, x_2$，满足 $L < x_1 < x_2 < R$，记 $y_1 = f(x_1)$，$y_2 = f(x_2)$；\n\n- 如果 $y_1 > y_2$，那么最小值点一定不在 $[L, x_1]$ 内；如果 $y_1 < y_2$，那么最小值点一定不在 $[x_2, R]$ 内。\n\n证明也很容易，只需要用到凸函数的定义。假设最小值点在 $[L, x_1]$ 内，记为 $x_m$。由于 $y_1 > y_2$，那么最小值点显然不为 $x_1$，即 $x_1 \\neq x_m$。因此有 $x_m < x_1 < x_2$ 且 $f(x_m) < f(x_1)$，$f(x_2) < f(x_1)$。由于 $f$ 是凸函数，使用定比分点可以得到：\n\n$$\n\\frac{x_2-x_1}{x_2-x_m} f(x_m) + \\frac{x_1-x_m}{x_2-x_m} f(x_2) \\geq f\\left( \\frac{x_2-x_1}{x_2-x_m} \\cdot x_m + \\frac{x_1-x_m}{x_2-x_m} \\cdot x_2 \\right)= f(x_1)\n$$\n\n然而：\n\n$$\n\\frac{x_2-x_1}{x_2-x_m} f(x_m) + \\frac{x_1-x_m}{x_2-x_m} f(x_2) < \\frac{x_2-x_1}{x_2-x_m} f(x_1) + \\frac{x_1-x_m}{x_2-x_m} f(x_1) = f(x_1)\n$$\n\n产生了矛盾！因此最小值点一定不在 $[L, x_1]$ 内。对于 $y_1 < y_2$ 的情况同理。\n\n我们可以取 $x_1, x_2$ 为 $[L, R]$ 的三等分点，即：\n\n$$\n\\left\\{\n\\begin{aligned}\n& x_1 = \\frac{2L + R}{3} \\\\\n& x_2 = \\frac{L + 2R}{3}\n\\end{aligned}\n\\right.\n$$\n\n这样我们每次就可以排除三分之一的定义域。当定义域的宽度 $R-L$ 收敛至给定的阈值 $\\epsilon$ 时，就可以结束三分查找。此时 $L$ 和 $R$ 足够接近，可以将 $[L, R]$ 内的所有值都视作极值点。\n\n题目中的函数 $f(x_c, y_c)$ 是二元函数，我们可以使用「三分查找」套「三分查找」的方法。外层的三分查找用来确定 $x_c$ 的范围，每次三分查找时，取定义域 $[x_L, x_R]$ 中的两个三等分点 $x_1, x_2$，并分别固定 $x_c$ 的值为 $x_1$ 和 $x_2$，对 $y_c$ 进行三分查找。将得到的最优解进行比较，以此选择忽略 $[x_L, x_1]$ 或 $[x_2, x_R]$。\n\n每一层的三分查找都会在定义域的宽度小于给定的阈值 $\\epsilon$ 时结束。在下面的代码中，我们令：\n\n- 区间宽度阈值 $\\epsilon = 10^{-7}$；\n\n就可以通过本题。\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    double getMinDistSum(vector<vector<int>>& positions) {\n        double eps = 1e-7;\n\n        // 计算服务中心 (xc, yc) 到客户的欧几里得距离之和\n        auto getDist = [&](double xc, double yc) {\n            double ans = 0;\n            for (const auto& pos: positions) {\n                ans += sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc));\n            }\n            return ans;\n        };\n\n        // 固定 xc，使用三分法找出最优的 yc\n        auto checkOptimal = [&](double xc) {\n            double yLeft = 0.0, yRight = 100.0;\n            while (yRight - yLeft > eps) {\n                double yFirst = (yLeft + yLeft + yRight) / 3;\n                double ySecond = (yLeft + yRight + yRight) / 3;\n                if (getDist(xc, yFirst) < getDist(xc, ySecond)) {\n                    yRight = ySecond;\n                }\n                else {\n                    yLeft = yFirst;\n                }\n            }\n            return getDist(xc, yLeft);\n        };\n        \n        double xLeft = 0.0, xRight = 100.0;\n        while (xRight - xLeft > eps) {\n            // 左 1/3 点\n            double xFirst = (xLeft + xLeft + xRight) / 3;\n            // 右 1/3 点\n            double xSecond = (xLeft + xRight + xRight) / 3;\n            if (checkOptimal(xFirst) < checkOptimal(xSecond)) {\n                xRight = xSecond;\n            }\n            else {\n                xLeft = xFirst;\n            }\n        }\n\n        return checkOptimal(xLeft);\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public double getMinDistSum(int[][] positions) {\n        double eps = 1e-7;\n\n        double xLeft = 0.0, xRight = 100.0;\n        while (xRight - xLeft > eps) {\n            // 左 1/3 点\n            double xFirst = (xLeft + xLeft + xRight) / 3;\n            // 右 1/3 点\n            double xSecond = (xLeft + xRight + xRight) / 3;\n            if (checkOptimal(xFirst, positions, eps) < checkOptimal(xSecond, positions, eps)) {\n                xRight = xSecond;\n            } else {\n                xLeft = xFirst;\n            }\n        }\n\n        return checkOptimal(xLeft, positions, eps);\n    }\n\n    // 计算服务中心 (xc, yc) 到客户的欧几里得距离之和\n    public double getDist(double xc, double yc, int[][] positions) {\n        double ans = 0;\n        for (int[] pos : positions) {\n            ans += Math.sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc));\n        }\n        return ans;\n    }\n\n    // 固定 xc，使用三分法找出最优的 yc\n    public double checkOptimal(double xc, int[][] positions, double eps) {\n        double yLeft = 0.0, yRight = 100.0;\n        while (yRight - yLeft > eps) {\n            double yFirst = (yLeft + yLeft + yRight) / 3;\n            double ySecond = (yLeft + yRight + yRight) / 3;\n            if (getDist(xc, yFirst, positions) < getDist(xc, ySecond, positions)) {\n                yRight = ySecond;\n            } else {\n                yLeft = yFirst;\n            }\n        }\n        return getDist(xc, yLeft, positions);\n    }    \n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def getMinDistSum(self, positions: List[List[int]]) -> float:\n        eps = 1e-7\n\n        # 计算服务中心 (xc, yc) 到客户的欧几里得距离之和\n        getDist = lambda xc, yc: sum(((x - xc) ** 2 + (y - yc) ** 2) ** 0.5 for x, y in positions)\n\n        # 固定 xc，使用三分法找出最优的 yc\n        def checkOptimal(xc: float) -> float:\n            yLeft, yRight = 0.0, 100.0\n            while yRight - yLeft > eps:\n                yFirst = (yLeft + yLeft + yRight) / 3\n                ySecond = (yLeft + yRight + yRight) / 3\n                if getDist(xc, yFirst) < getDist(xc, ySecond):\n                    yRight = ySecond\n                else:\n                    yLeft = yFirst\n            return getDist(xc, yLeft)\n        \n        xLeft, xRight = 0.0, 100.0\n        while xRight - xLeft > eps:\n            # 左 1/3 点\n            xFirst = (xLeft + xLeft + xRight) / 3\n            # 右 1/3 点\n            xSecond = (xLeft + xRight + xRight) / 3\n            if checkOptimal(xFirst) < checkOptimal(xSecond):\n                xRight = xSecond\n            else:\n                xLeft = xFirst\n\n        return checkOptimal(xLeft)\n```\n\n```C [sol3-C]\ndouble eps = 1e-7;\n\ndouble getDist(int** positions, int positionsSize, double xc, double yc) {\n    double ans = 0;\n    for (int i = 0; i < positionsSize; i++) {\n        int* pos = positions[i];\n        ans += sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc));\n    }\n    return ans;\n};\n\ndouble checkOptimal(int** positions, int positionsSize, double xc) {\n    double yLeft = 0.0, yRight = 100.0;\n    while (yRight - yLeft > eps) {\n        double yFirst = (yLeft + yLeft + yRight) / 3;\n        double ySecond = (yLeft + yRight + yRight) / 3;\n        if (getDist(positions, positionsSize, xc, yFirst) < getDist(positions, positionsSize, xc, ySecond)) {\n            yRight = ySecond;\n        } else {\n            yLeft = yFirst;\n        }\n    }\n    return getDist(positions, positionsSize, xc, yLeft);\n};\n\ndouble getMinDistSum(int** positions, int positionsSize, int* positionsColSize) {\n    int batchSize = positionsSize;\n\n    double x = 0.0, y = 0.0;\n    for (int i = 0; i < positionsSize; i++) {\n        int* pos = positions[i];\n        x += pos[0];\n        y += pos[1];\n    }\n    x /= positionsSize;\n    y /= positionsSize;\n\n    double xLeft = 0.0, xRight = 100.0;\n    while (xRight - xLeft > eps) {\n        // 左 1/3 点\n        double xFirst = (xLeft + xLeft + xRight) / 3;\n        // 右 1/3 点\n        double xSecond = (xLeft + xRight + xRight) / 3;\n        if (checkOptimal(positions, positionsSize, xFirst) < checkOptimal(positions, positionsSize, xSecond)) {\n            xRight = xSecond;\n        } else {\n            xLeft = xFirst;\n        }\n    }\n\n    return checkOptimal(positions, positionsSize, xLeft);\n}\n```\n\n#### 凸函数证明\n\n给定 $x_0, \\cdots, x_{n-1} \\in \\mathbb{R}$ 以及 $y_0, \\cdots, y_{n-1} \\in \\mathbb{R}$，证明\n\n$$\nf(x, y) = \\sum_{i=0}^{n-1} \\sqrt{(x-x_i)^2 + (y-y_i)^2}\n$$\n\n是 $\\mathbb{R}^2$ 上的凸函数（convex function）。\n\n**证明**\n\n记 $f_i(x, y) = \\sqrt{(x-x_i)^2 + (y-y_i)^2}$，显然 $f_i(x, y)$ 连续可导。一阶导数为：\n$$\n\\left\\{\n\\begin{aligned}\n\\frac{\\partial f_i}{\\partial x} = \\frac{x-x_i}{\\sqrt{(x-x_i)^2 + (y-y_i)^2}} \\\\\n\\frac{\\partial f_i}{\\partial y} = \\frac{y-y_i}{\\sqrt{(x-x_i)^2 + (y-y_i)^2}}\n\\end{aligned}\n\\right.\n$$\n\n二阶导数为：\n\n$$\n\\left\\{\n\\begin{aligned}\n& \\frac{\\partial^2 f_i}{\\partial x^2} = \\frac{(y-y_i)^2}{\\big((x-x_i)^2 + (y-y_i)^2\\big)^{\\frac{3}{2}}} \\\\\n& \\frac{\\partial^2 f_i}{\\partial y^2} = \\frac{(x-x_i)^2}{\\big((x-x_i)^2 + (y-y_i)^2\\big)^{\\frac{3}{2}}} \\\\\n& \\frac{\\partial^2 f_i}{\\partial x \\partial y} = \\frac{\\partial^2 f_i}{\\partial y \\partial x} = -\\frac{(x-x_i)(y-y_i)}{\\big((x-x_i)^2 + (y-y_i)^2\\big)^{\\frac{3}{2}}}\n\\end{aligned}\n\\right.\n$$\n\n对应的 Hessian 矩阵\n\n$$\nH(f_i) = \\left[\n\\begin{array}{cc}\n\\dfrac{\\partial^2 f_i}{\\partial x^2} & \\dfrac{\\partial^2 f_i}{\\partial x \\partial y} \\\\ \\\\\n\\dfrac{\\partial^2 f_i}{\\partial y \\partial x} & \\dfrac{\\partial^2 f_i}{\\partial y^2}\n\\end{array}\n\\right]\n$$\n\n的主子式\n\n$$\n\\left\\{\n\\begin{aligned}\n& \\frac{\\partial^2 f_i}{\\partial x^2} \\geq 0 \\\\ \\\\\n& \\frac{\\partial^2 f_i}{\\partial y^2} \\geq 0 \\\\ \\\\\n& \\frac{\\partial^2 f_i}{\\partial x^2} \\frac{\\partial^2 f_i}{\\partial y^2} - \\frac{\\partial^2 f_i}{\\partial x \\partial y} \\frac{\\partial^2 f_i}{\\partial y \\partial x} = 0\n\\end{aligned}\n\\right.\n$$\n\n均大于等于零。因此 Hessian 矩阵为半正定矩阵，即 $f_i(x, y)$ 是凸函数。\n\n因此 $f = \\sum\\limits_{i=0}^{n-1} f_i$ 也是凸函数。"
}