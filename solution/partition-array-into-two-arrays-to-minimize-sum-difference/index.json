{
	"titleSlug": "partition-array-into-two-arrays-to-minimize-sum-difference",
	"slug": "zui-jie-jin-mu-biao-zhi-de-zi-xu-lie-he-m0sq3",
	"url": "https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solution/zui-jie-jin-mu-biao-zhi-de-zi-xu-lie-he-m0sq3/",
	"content": "![20211010164511.png](https://pic.leetcode-cn.com/1633855540-jYGijU-20211010164511.png)\n\n\n### 解题思路\n\n1. 如果数组长度特别大，但是数组的和不大 (sum<=10^5)，我们可以使用**背包问题**的方式来解决，其中dp[i]表示是否能组成容量为 i 的背包\n [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/submissions/)\n```typescript []\nfunction lastStoneWeightII(stones: number[]): number {\n  const sum = stones.reduce((pre, cur) => pre + cur, 0)\n  const volumn = sum >> 1\n  // dp[i] 表示若干块石头中能否选出一些组成重量和为 i\n  const dp = Array(volumn + 1).fill(false)\n  dp[0] = true\n\n  for (let i = 0; i < stones.length; i++) {\n    for (let j = volumn; j >= 0; j--) {\n      j >= stones[i] && (dp[j] = dp[j] || dp[j - stones[i]])\n    }\n  }\n\n  const maxWeight = dp.lastIndexOf(true)\n  return sum - 2 * maxWeight\n};\n```\n2. 如果数组长度不大(n<=20)，但是数值特别大的话，使用**枚举子集的方法**。(如果数组长度大于20，例如 40，直接枚举子集2^40会超时,需要折半查找)\n[1755. 最接近目标值的子序列和](https://leetcode-cn.com/problems/closest-subsequence-sum/)\n[5897. 将数组分成两个数组并最小化数组和的差](https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/)\n   步骤：\n   1. 将数组分成两部分\n   2. 枚举出两个数组的所有子序列和，并排序\n   3. 有序的 twoSum 问题 => 双指针\n\n### 代码\n`1755. 最接近目标值的子序列和`\n```typescript []\n// 给你一个整数数组 nums 和一个目标值 goal 。\n// 你需要从 nums 中选出一个子序列，使子序列元素总和最接近 goal\n// 1 <= nums.length <= 40\n// -107 <= nums[i] <= 107\n// -109 <= goal <= 109\nfunction minAbsDifference(nums: number[], goal: number): number {\n  const mid = nums.length >> 1\n  const left = getSubArraySumFrom(nums.slice(0, mid)).sort((a, b) => a - b)\n  const right = getSubArraySumFrom(nums.slice(mid)).sort((a, b) => a - b)\n  return twoSum(left, right, goal)\n}\n\n/**\n * @description 计算nums全部子序列和\n * @summary 时间复杂度O(2^n) \n */\nfunction getSubArraySumFrom(nums: number[]): number[] {\n  const n = nums.length\n  const res = Array<number>(1 << n).fill(0)\n\n  // 外层遍历数组每个元素\n  for (let i = 0; i < n; i++) {\n    // 内层遍历从0到外层元素之间的每一个元素\n    for (let j = 0; j < 1 << i; j++) {\n      res[(1 << i) + j] = res[j] + nums[i]\n    }\n  }\n\n  return res\n}\n\n/**\n * @description\n * 单调不减的数组nums1和nums2分别找到两个数，其和与target的差最小 返回这个最小差值\n */\nfunction twoSum(nums1: number[], nums2: number[], target: number) {\n  let l = 0\n  let r = nums2.length - 1\n  let res = Infinity\n\n  while (l < nums1.length && r > -1) {\n    const sum = nums1[l] + nums2[r]\n    res = Math.min(res, Math.abs(target - sum))\n    if (sum === target) return 0\n    else if (sum > target) r--\n    else l++\n  }\n\n  return res\n}\n```\n\n`5897. 将数组分成两个数组并最小化数组和的差`\n```typescript []\n/**\n *\n * @param nums\n * @returns\n * 1 <= n <= 15\n   给你一个长度为 2 * n 的整数数组。你需要将 nums 分成 两个 长度为 n 的数组，分别求出两个数组的和，\n   并 最小化 两个数组和之 差的绝对值 。nums 中每个元素都需要放入两个数组之一。\n   @description\n   1.将原数组中所有数变为两倍。这样可以保证我们的目标值sum/2是一个整数。\n   2.枚举出前一半数和后一半数的全部选举情况后再拼接在一起，问题变成了从16组两个元素个数不超过C(7,15)的列表中找出和最接近原来总和一半的方案\n */\nfunction minimumDifference(nums: number[]): number {\n  nums = nums.map(num => num * 2)\n  const midIndex = nums.length / 2\n  const leftSubArraySum = getSubArraySumFrom(nums.slice(0, midIndex))\n  const rightSubArraySum = getSubArraySumFrom(nums.slice(midIndex))\n  const target = nums.reduce((pre, cur) => pre + cur, 0) / 2\n\n  let res = Infinity\n  for (let leftCount = 0; leftCount <= midIndex; leftCount++) {\n    const left = leftSubArraySum[leftCount].sort((a, b) => a - b)\n    const right = rightSubArraySum[midIndex - leftCount].sort((a, b) => a - b)\n    res = Math.min(res, twoSum(left, right, target))\n  }\n  return res\n\n  /**\n   * @description 计算nums的子序列和 下标表示由多少个数组成\n   * @summary 时间复杂度O(2^n)\n   */\n  function getSubArraySumFrom(nums: number[]): number[][] {\n    const n = nums.length\n    const res = Array.from<number, number[]>({ length: nums.length + 1 }, () => [])\n    for (let i = 0; i < 1 << n; i++) {\n      const index = count(i)\n      let sum = 0\n      for (let j = 0; j < n; j++) {\n        if (i & (1 << j)) sum += nums[j]\n      }\n      res[index].push(sum)\n    }\n\n    return res\n\n    /**\n     * @description\n     * 二进制位1的个数\n     */\n    function count(num: number) {\n      let res = 0\n      while (num) {\n        num &= num - 1\n        res++\n      }\n      return res\n    }\n  }\n\n  /**\n   * @description\n   * 单调不减的数组nums1和nums2分别找到两个数，其和与target的差最小 返回这个最小差值\n   */\n  function twoSum(nums1: number[], nums2: number[], target: number): number {\n    let l = 0\n    let r = nums2.length - 1\n    let res = Infinity\n\n    while (l < nums1.length && r > -1) {\n      const sum = nums1[l] + nums2[r]\n      res = Math.min(res, Math.abs(target - sum))\n      if (sum === target) return 0\n      else if (sum > target) r--\n      else l++\n    }\n\n    return res\n  }\n}\n```\n"
}