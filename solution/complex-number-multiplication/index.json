{
	"titleSlug": "complex-number-multiplication",
	"slug": "fu-shu-cheng-fa-by-leetcode-solution-163i",
	"url": "https://leetcode-cn.com/problems/complex-number-multiplication/solution/fu-shu-cheng-fa-by-leetcode-solution-163i/",
	"content": "#### 方法一：模拟\n\n复数可以写成 $a + b\\mathrm{i}$ 的形式，其中 $a,b \\in \\mathbb{R}$，$a$ 是实部，$b$ 是虚部，$\\mathrm{i}$ 是虚数单位，$\\mathrm{i}^2 = -1$。\n\n对于给定的两个复数 $\\textit{num}_1$ 和 $\\textit{num}_2$，首先分别得到两个复数的实部和虚部，然后计算两个复数的乘法。用 $\\textit{real}_1$ 和 $\\textit{imag}_1$ 分别表示 $\\textit{num}_1$ 的实部和虚部，用 $\\textit{real}_2$ 和 $\\textit{imag}_2$ 分别表示 $\\textit{num}_2$ 的实部和虚部，则两个复数的乘法计算如下：\n\n$$\n\\begin{aligned}\n\\quad~ &~(\\textit{real}_1 + \\textit{imag}_1 \\times \\mathrm{i}) \\times (\\textit{real}_2 + \\textit{imag}_2 \\times \\mathrm{i}) \\\\\n= &~\\textit{real}_1 \\times \\textit{real}_2 + \\textit{real}_1 \\times \\textit{imag}_2 \\times \\mathrm{i} + \\textit{imag}_1 \\times \\textit{real}_2 \\times \\mathrm{i} + \\textit{imag}_1 \\times \\textit{imag}_2 \\times \\mathrm{i}^2 \\\\\n= &~\\textit{real}_1 \\times \\textit{real}_2 + \\textit{real}_1 \\times \\textit{imag}_2 \\times \\mathrm{i} + \\textit{imag}_1 \\times \\textit{real}_2 \\times \\mathrm{i} - \\textit{imag}_1 \\times \\textit{imag}_2 \\\\\n= &~(\\textit{real}_1 \\times \\textit{real}_2 - \\textit{imag}_1 \\times \\textit{imag}_2) + (\\textit{real}_1 \\times \\textit{imag}_2 + \\textit{imag}_1 \\times \\textit{real}_2) \\times \\mathrm{i}\n\\end{aligned}\n$$\n\n得到两个复数的乘积之后，将乘积转换成复数格式的字符串并返回。\n\n```Python [sol1-Python3]\nclass Solution:\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\n        real1, imag1 = map(int, num1[:-1].split('+'))\n        real2, imag2 = map(int, num2[:-1].split('+'))\n        return f'{real1 * real2 - imag1 * imag2}+{real1 * imag2 + imag1 * real2}i'\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String complexNumberMultiply(String num1, String num2) {\n        String[] complex1 = num1.split(\"\\\\+|i\");\n        String[] complex2 = num2.split(\"\\\\+|i\");\n        int real1 = Integer.parseInt(complex1[0]);\n        int imag1 = Integer.parseInt(complex1[1]);\n        int real2 = Integer.parseInt(complex2[0]);\n        int imag2 = Integer.parseInt(complex2[1]);\n        return String.format(\"%d+%di\", real1 * real2 - imag1 * imag2, real1 * imag2 + imag1 * real2);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string ComplexNumberMultiply(string num1, string num2) {\n        string[] complex1 = num1.Split(new char[2]{'+','i'});\n        string[] complex2 = num2.Split(new char[2]{'+','i'});\n        int real1 = int.Parse(complex1[0]);\n        int imag1 = int.Parse(complex1[1]);\n        int real2 = int.Parse(complex2[0]);\n        int imag2 = int.Parse(complex2[1]);\n        return string.Format(\"{0}+{1}i\", real1 * real2 - imag1 * imag2, real1 * imag2 + imag1 * real2);\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string complexNumberMultiply(string num1, string num2) {\n        regex re(\"\\\\+|i\"); \n        vector<string> complex1(sregex_token_iterator(num1.begin(), num1.end(), re, -1), std::sregex_token_iterator());\n        vector<string> complex2(sregex_token_iterator(num2.begin(), num2.end(), re, -1), std::sregex_token_iterator());\n        int real1 = stoi(complex1[0]);\n        int imag1 = stoi(complex1[1]);\n        int real2 = stoi(complex2[0]);\n        int imag2 = stoi(complex2[1]);\n        return to_string(real1 * real2 - imag1 * imag2) + \"+\" + to_string(real1 * imag2 + imag1 * real2) + \"i\";\n    }\n};\n```\n\n```C [sol1-C]\nbool parseComplexNumber(const char * num, int * real, int * image) {\n    char *token = strtok(num, \"+\");\n    *real = atoi(token);\n    token = strtok(NULL, \"i\");\n    *image = atoi(token);\n    return true;\n};\n\nchar * complexNumberMultiply(char * num1, char * num2){\n    int real1 = 0, imag1 = 0;\n    int real2 = 0, imag2 = 0;\n    char * res = (char *)malloc(sizeof(char) * 20);\n    parseComplexNumber(num1, &real1, &imag1);\n    parseComplexNumber(num2, &real2, &imag2);\n    snprintf(res, 20, \"%d+%di\", real1 * real2 - imag1 * imag2, real1 * imag2 + imag1 * real2);\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar complexNumberMultiply = function(num1, num2) {\n    const complex1 = [num1.split(\"+\")[0], num1.split(\"+\")[1].split(\"i\")[0]];\n    const complex2 = [num2.split(\"+\")[0], num2.split(\"+\")[1].split(\"i\")[0]];\n    const real1 = parseInt(complex1[0]);\n    const imag1 = parseInt(complex1[1]);\n    const real2 = parseInt(complex2[0]);\n    const imag2 = parseInt(complex2[1]);\n    return '' + real1 * real2 - imag1 * imag2 + '+' + (real1 * imag2 + imag1 * real2) + 'i';\n};\n```\n\n```go [sol1-Golang]\nfunc parseComplexNumber(num string) (real, imag int) {\n    i := strings.IndexByte(num, '+')\n    real, _ = strconv.Atoi(num[:i])\n    imag, _ = strconv.Atoi(num[i+1 : len(num)-1])\n    return\n}\n\nfunc complexNumberMultiply(num1, num2 string) string {\n    real1, imag1 := parseComplexNumber(num1)\n    real2, imag2 := parseComplexNumber(num2)\n    return fmt.Sprintf(\"%d+%di\", real1*real2-imag1*imag2, real1*imag2+imag1*real2)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$。由于两个复数字符串的长度都很小，因此可以将字符串处理的时间视为常数。\n\n- 空间复杂度：$O(1)$。"
}