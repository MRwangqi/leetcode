{
	"titleSlug": "adding-two-negabinary-numbers",
	"slug": "by-stormsunshine-xru4",
	"url": "https://leetcode-cn.com/problems/adding-two-negabinary-numbers/solution/by-stormsunshine-xru4/",
	"content": "# 解法\r\n\r\n## 思路和算法\r\n\r\n这道题要求计算两个负二进制数的加法。负二进制数的每一位都是 $0$ 或 $1$，进位规则是逢二进一，但是由于进制数是负数，因此处理进位时可能影响到当前位的前两位。\r\n\r\n对于 $k \\ge 0$，从低到高第 $k$ 位表示 $(-2)^k$。如果第 $k$ 位的值大于 $1$ 则发生进位，两种处理进位的方式如下。\r\n\r\n1. 由于 $2 \\times (-2)^k = -(-2)^{k + 1}$，因此可以将第 $k$ 位减 $2$，将第 $k + 1$ 位减 $1$，即可完成进位的处理。\r\n\r\n2. 由于 $2 \\times (-2)^k = (-2)^{k + 2} + (-2)^{k + 1}$，因此可以将第 $k$ 位减 $2$，将第 $k + 1$ 位和第 $k + 2$ 位各加 $1$，即可完成进位的处理。\r\n\r\n为了确保负二进制数的每一位都是 $0$ 或 $1$，应该优先使用第 1 种方式。如果第 $k + 1$ 位大于 $0$ 则使用第 1 种方式，如果第 $k + 1$ 位等于 $0$ 则使用第 2 种方式。\r\n\r\n由于处理进位时需要考虑到当前位的前两位，处理当前位的前两位的进位时还可能需要考虑到前两位，因此结果数组的最大长度为数组 $\\textit{arr}_1$ 和 $\\textit{arr}_2$ 中的较长数组的长度加 $4$。用 $\\textit{arrSum}$ 表示结果数组。\r\n\r\n用 $\\textit{index}_1$、$\\textit{index}_2$ 和 $\\textit{indexSum}$ 分别表示数组 $\\textit{arr}_1$、$\\textit{arr}_2$ 和 $\\textit{arrSum}$ 遍历到的下标，初始时 $\\textit{index}_1$、$\\textit{index}_2$ 和 $\\textit{indexSum}$ 分别指向数组 $\\textit{arr}_1$、$\\textit{arr}_2$ 和 $\\textit{arrSum}$ 的最大下标。\r\n\r\n当 $\\textit{index}_1 \\ge 0$、$\\textit{index}_2 \\ge 0$ 和 $\\textit{arrSum}[\\textit{indexSum}] \\ne 0$ 三个条件中至少有一个条件成立时，对于每一位，执行如下操作，直到三个条件都不成立。\r\n\r\n1. 记 $\\textit{digit}_1$ 和 $\\textit{digit}_2$ 分别为 $\\textit{arr}_1[\\textit{index}_1]$ 和 $\\textit{arr}_2[\\textit{index}_2]$ 对应的数字。特别地，如果 $\\textit{index}_1 < 0$ 则 $\\textit{digit}_1 = 0$，如果 $\\textit{index}_2 < 0$ 则 $\\textit{digit}_2 = 0$。\r\n\r\n2. 将 $\\textit{arrSum}[\\textit{indexSum}]$ 的值增加 $\\textit{digit}_1 + \\textit{digit}_2$。\r\n\r\n3. 使用第 1 种方式处理进位。令 $\\textit{reduce} = \\min(\\Big\\lfloor \\dfrac{\\textit{arrSum}[\\textit{indexSum}]}{2} \\Big\\rfloor, \\textit{arrSum}[\\textit{indexSum} - 1])$，将 $\\textit{arrSum}[\\textit{indexSum}]$ 的值减少 $\\textit{reduce} \\times 2$，将 $\\textit{arrSum}[\\textit{indexSum} - 1]$ 的值减少 $\\textit{reduce}$。\r\n\r\n4. 使用第 2 种方式处理进位。令 $\\textit{carry} = \\Big\\lfloor \\dfrac{\\textit{arrSum}[\\textit{indexSum}]}{2} \\Big\\rfloor$，将 $\\textit{arrSum}[\\textit{indexSum}]$ 的值减少 $\\textit{carry} \\times 2$，将 $\\textit{arrSum}[\\textit{indexSum} - 1]$ 和 $\\textit{arrSum}[\\textit{indexSum} - 2]$ 的值各增加 $\\textit{carry}$。\r\n\r\n5. 将 $\\textit{index}_1$、$\\textit{index}_2$ 和 $\\textit{indexSum}$ 分别向左移动一位。\r\n\r\n操作结束时，数组 $\\textit{arrSum}$ 为 $\\textit{arr}_1$ 与 $\\textit{arr}_2$ 相加的结果。由于结果数组不能有前导零，因此将下标 $\\textit{indexSum}$ 向右移动，直到遇到不为零的元素或到达数组 $\\textit{arrSum}$ 的末尾，将数组 $\\textit{arrSum}$ 从下标 $\\textit{indexSum}$ 到末尾的子数组作为结果数组返回。\r\n\r\n考虑一个例子：$\\textit{arr}_1 = [1, 1, 1]$，$\\textit{arr}_2 = [1, 1, 1]$。\r\n\r\n数组 $\\textit{arr}_1$ 和 $\\textit{arr}_2$ 的长度都是 $3$，创建长度为 $\\max(3, 3) + 4 = 7$ 的数组 $\\textit{arrSum}$。初始时 $\\textit{index}_1 = 2$，$\\textit{index}_2 = 2$，$\\textit{indexSum} = 6$。\r\n\r\n1. 下标值为 $\\textit{index}_1 = 2$，$\\textit{index}_2 = 2$，$\\textit{indexSum} = 6$。\r\n\r\n   1. 两个二进制整数的当前位的值为 $\\textit{digit}_1 = 1$，$\\textit{digit}_2 = 1$。\r\n\r\n   2. 将 $\\textit{arrSum}[6]$ 的值增加 $1 + 1 = 2$，此时 $\\textit{arrSum} = [0, 0, 0, 0, 0, 0, 2]$。\r\n\r\n   3. 此时 $\\textit{reduce} = \\min(\\Big\\lfloor \\dfrac{\\textit{arrSum}[6]}{2} \\Big\\rfloor, \\textit{arrSum}[5]) = 0$，使用第 1 种方式处理进位之后，$\\textit{arrSum}$ 不变。\r\n\r\n   4. 此时 $\\textit{carry} = \\Big\\lfloor \\dfrac{\\textit{arrSum}[6]}{2} \\Big\\rfloor = 1$，使用第 2 种方式处理进位，将 $\\textit{arrSum}[6]$ 的值减少 $2$，将 $\\textit{arrSum}[5]$ 和 $\\textit{arrSum}[4]$ 的值各增加 $1$，此时 $\\textit{arrSum} = [0, 0, 0, 0, 1, 1, 0]$。\r\n\r\n   5. 将 $\\textit{index}_1$、$\\textit{index}_2$ 和 $\\textit{indexSum}$ 分别向左移动一位。\r\n\r\n2. 下标值为 $\\textit{index}_1 = 1$，$\\textit{index}_2 = 1$，$\\textit{indexSum} = 5$。\r\n\r\n   1. 两个二进制整数的当前位的值为 $\\textit{digit}_1 = 1$，$\\textit{digit}_2 = 1$。\r\n\r\n   2. 将 $\\textit{arrSum}[5]$ 的值增加 $1 + 1 = 2$，此时 $\\textit{arrSum} = [0, 0, 0, 0, 1, 3, 0]$。\r\n\r\n   3. 此时 $\\textit{reduce} = \\min(\\Big\\lfloor \\dfrac{\\textit{arrSum}[5]}{2} \\Big\\rfloor, \\textit{arrSum}[4]) = 1$，使用第 1 种方式处理进位，将 $\\textit{arrSum}[5]$ 的值减少 $2$，将 $\\textit{arrSum}[4]$ 的值减少 $1$，此时 $\\textit{arrSum} = [0, 0, 0, 0, 0, 1, 0]$。\r\n\r\n   4. 此时 $\\textit{carry} = \\Big\\lfloor \\dfrac{\\textit{arrSum}[5]}{2} \\Big\\rfloor = 0$，使用第 2 种方式处理进位之后，$\\textit{arrSum}$ 不变。\r\n\r\n   5. 将 $\\textit{index}_1$、$\\textit{index}_2$ 和 $\\textit{indexSum}$ 分别向左移动一位。\r\n\r\n3. 下标值为 $\\textit{index}_1 = 0$，$\\textit{index}_2 = 0$，$\\textit{indexSum} = 4$。\r\n\r\n   1. 两个二进制整数的当前位的值为 $\\textit{digit}_1 = 1$，$\\textit{digit}_2 = 1$。\r\n\r\n   2. 将 $\\textit{arrSum}[4]$ 的值增加 $1 + 1 = 2$，此时 $\\textit{arrSum} = [0, 0, 0, 0, 2, 1, 0]$。\r\n\r\n   3. 此时 $\\textit{reduce} = \\min(\\Big\\lfloor \\dfrac{\\textit{arrSum}[4]}{2} \\Big\\rfloor, \\textit{arrSum}[3]) = 0$，使用第 1 种方式处理进位之后，$\\textit{arrSum}$ 不变。\r\n\r\n   4. 此时 $\\textit{carry} = \\Big\\lfloor \\dfrac{\\textit{arrSum}[4]}{2} \\Big\\rfloor = 1$，使用第 2 种方式处理进位，将 $\\textit{arrSum}[4]$ 的值减少 $2$，将 $\\textit{arrSum}[3]$ 和 $\\textit{arrSum}[2]$ 的值各增加 $1$，此时 $\\textit{arrSum} = [0, 0, 1, 1, 0, 1, 0]$。\r\n\r\n   5. 将 $\\textit{index}_1$、$\\textit{index}_2$ 和 $\\textit{indexSum}$ 分别向左移动一位。\r\n\r\n4. 下标值为 $\\textit{index}_1 = -1$，$\\textit{index}_2 = -1$，$\\textit{indexSum} = 3$。\r\n\r\n   1. 两个二进制整数的当前位的值为 $\\textit{digit}_1 = 0$，$\\textit{digit}_2 = 0$。\r\n\r\n   2. 将 $\\textit{arrSum}[3]$ 的值增加 $0 + 0 = 0$，此时 $\\textit{arrSum} = [0, 0, 1, 1, 0, 1, 0]$。\r\n\r\n   3. 此时 $\\textit{reduce} = \\min(\\Big\\lfloor \\dfrac{\\textit{arrSum}[3]}{2} \\Big\\rfloor, \\textit{arrSum}[2]) = 0$，使用第 1 种方式处理进位之后，$\\textit{arrSum}$ 不变。\r\n\r\n   4. 此时 $\\textit{carry} = \\Big\\lfloor \\dfrac{\\textit{arrSum}[3]}{2} \\Big\\rfloor = 0$，使用第 2 种方式处理进位之后，$\\textit{arrSum}$ 不变。\r\n\r\n   5. 将 $\\textit{index}_1$、$\\textit{index}_2$ 和 $\\textit{indexSum}$ 分别向左移动一位。\r\n\r\n5. 下标值为 $\\textit{index}_1 = -2$，$\\textit{index}_2 = -2$，$\\textit{indexSum} = 2$。\r\n\r\n   1. 两个二进制整数的当前位的值为 $\\textit{digit}_1 = 0$，$\\textit{digit}_2 = 0$。\r\n\r\n   2. 将 $\\textit{arrSum}[2]$ 的值增加 $0 + 0 = 0$，此时 $\\textit{arrSum} = [0, 0, 1, 1, 0, 1, 0]$。\r\n\r\n   3. 此时 $\\textit{reduce} = \\min(\\Big\\lfloor \\dfrac{\\textit{arrSum}[2]}{2} \\Big\\rfloor, \\textit{arrSum}[1]) = 0$，使用第 1 种方式处理进位之后，$\\textit{arrSum}$ 不变。\r\n\r\n   4. 此时 $\\textit{carry} = \\Big\\lfloor \\dfrac{\\textit{arrSum}[2]}{2} \\Big\\rfloor = 0$，使用第 2 种方式处理进位之后，$\\textit{arrSum}$ 不变。\r\n\r\n   5. 将 $\\textit{index}_1$、$\\textit{index}_2$ 和 $\\textit{indexSum}$ 分别向左移动一位。\r\n\r\n6. 下标值为 $\\textit{index}_1 = -3$，$\\textit{index}_2 = -3$，$\\textit{indexSum} = 1$。由于 $\\textit{index}_1 \\ge 0$、$\\textit{index}_2 \\ge 0$ 和 $\\textit{arrSum}[\\textit{indexSum}] \\ne 0$ 三个条件都不成立，因此操作结束。\r\n\r\n7. 将 $\\textit{indexSum}$ 向右移动，直到 $\\textit{indexSum} = 2$ 时，$\\textit{arrSum}[\\textit{indexSum}] \\ne 0$，返回数组 $[1, 1, 0, 1, 0]$。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public int[] addNegabinary(int[] arr1, int[] arr2) {\r\n        int length1 = arr1.length, length2 = arr2.length;\r\n        int lengthSum = Math.max(length1, length2) + 4;\r\n        int[] arrSum = new int[lengthSum];\r\n        int index1 = length1 - 1, index2 = length2 - 1, indexSum = lengthSum - 1;\r\n        while (index1 >= 0 || index2 >= 0 || arrSum[indexSum] != 0) {\r\n            int digit1 = index1 >= 0 ? arr1[index1] : 0;\r\n            int digit2 = index2 >= 0 ? arr2[index2] : 0;\r\n            arrSum[indexSum] += digit1 + digit2;\r\n            int reduce = Math.min(arrSum[indexSum] / 2, arrSum[indexSum - 1]);\r\n            arrSum[indexSum] -= reduce * 2;\r\n            arrSum[indexSum - 1] -= reduce;\r\n            int carry = arrSum[indexSum] / 2;\r\n            arrSum[indexSum] -= carry * 2;\r\n            arrSum[indexSum - 1] += carry;\r\n            arrSum[indexSum - 2] += carry;\r\n            index1--;\r\n            index2--;\r\n            indexSum--;\r\n        }\r\n        while (indexSum < lengthSum - 1 && arrSum[indexSum] == 0) {\r\n            indexSum++;\r\n        }\r\n        return Arrays.copyOfRange(arrSum, indexSum, lengthSum);\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public int[] AddNegabinary(int[] arr1, int[] arr2) {\r\n        int length1 = arr1.Length, length2 = arr2.Length;\r\n        int lengthSum = Math.Max(length1, length2) + 4;\r\n        int[] arrSum = new int[lengthSum];\r\n        int index1 = length1 - 1, index2 = length2 - 1, indexSum = lengthSum - 1;\r\n        while (index1 >= 0 || index2 >= 0 || arrSum[indexSum] != 0) {\r\n            int digit1 = index1 >= 0 ? arr1[index1] : 0;\r\n            int digit2 = index2 >= 0 ? arr2[index2] : 0;\r\n            arrSum[indexSum] += digit1 + digit2;\r\n            int reduce = Math.Min(arrSum[indexSum] / 2, arrSum[indexSum - 1]);\r\n            arrSum[indexSum] -= reduce * 2;\r\n            arrSum[indexSum - 1] -= reduce;\r\n            int carry = arrSum[indexSum] / 2;\r\n            arrSum[indexSum] -= carry * 2;\r\n            arrSum[indexSum - 1] += carry;\r\n            arrSum[indexSum - 2] += carry;\r\n            index1--;\r\n            index2--;\r\n            indexSum--;\r\n        }\r\n        while (indexSum < lengthSum - 1 && arrSum[indexSum] == 0) {\r\n            indexSum++;\r\n        }\r\n        int length = lengthSum - indexSum;\r\n        int[] sum = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            sum[i] = arrSum[i + indexSum];\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(\\max(m, n))$，其中 $m$ 和 $n$ 分别是数组 $\\textit{arr}_1$ 和 $\\textit{arr}_2$ 的长度。需要遍历两个数组的每个元素，对于结果数组中的每个元素的计算为 $O(1)$ 的时间，由于是同时遍历，因此时间复杂度取决于较长的数组长度。\r\n\r\n- 空间复杂度：$O(\\max(m, n))$，其中 $m$ 和 $n$ 分别是数组 $\\textit{arr}_1$ 和 $\\textit{arr}_2$ 的长度。需要使用长度为 $\\max(m, n) + 4$ 的数组记录结果。"
}