{
	"titleSlug": "distribute-repeating-integers",
	"slug": "zi-ji-mei-ju-jing-dian-tao-lu-zhuang-ya-dp-by-arse",
	"url": "https://leetcode-cn.com/problems/distribute-repeating-integers/solution/zi-ji-mei-ju-jing-dian-tao-lu-zhuang-ya-dp-by-arse/",
	"content": "#### 状态压缩\r\n\r\n首先，容易发现 $\\textit{nums}$ 的具体取值是不重要的：只有每个取值出现的次数是重要的。因此，我们构造 $\\textit{nums}$ 的频次数组 $\\textit{cnt}$，代表了原数组中每个数字出现的次数。\r\n\r\n例如，在数组 $[3,2,2,5]$ 中，只有数字 $2$ 出现了 $2$ 次，故频次数组为 $[1,2,1]$（其顺序无关紧要）。\r\n\r\n考虑到订单数目最多为 $10$，故使用状态压缩动态规划解决本题：用一个 $0 - 2^{10}(=1024)$ 的整数代表 $m$ 个顾客的一个子集。随后，用 $dp[i][j]$ 表示：$\\textit{cnt}$ 数组中的前 $i$ 个元素，能否满足顾客的子集合 $j$ 的订单需求。\r\n\r\n考虑 $dp[i][j]$ 时，为了满足子集 $j$ 的需求，我们可以让 $\\textit{cnt}[i]$ 满足 $j$ 的某个子集 $s$， 并让 $\\textit{cnt}[0..i-1]$ 满足子集 $j-s$。对于特定的某个子集 $s$ 而言，该种方案如果可行，必然有 $dp[i-1][j-s]$ 为 $true$，且子集 $s$ 的订单需求总和不超过 $cnt[i]$。\r\n\r\n因此，当且仅当能找到这样的子集 $s$ 时，$dp[i][j]=true$。\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\r\n        unordered_map<int, int> cache;\r\n        for (int x: nums) {\r\n            cache[x]++;\r\n        }\r\n        vector<int> cnt;\r\n        for (auto& kv: cache) {\r\n            cnt.push_back(kv.second);\r\n        }\r\n        \r\n        int n = cnt.size(), m = quantity.size();\r\n        vector<int> sum(1 << m, 0);\r\n        for (int i = 1; i < (1 << m); i++) {\r\n            for (int j = 0; j < m; j++) {\r\n                if ((i & (1 << j)) != 0) {\r\n                    int left = i - (1 << j);\r\n                    sum[i] = sum[left] + quantity[j];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n        vector<vector<bool>> dp(n, vector<bool>(1 << m, false));\r\n        for (int i = 0; i < n; i++) {\r\n            dp[i][0] = true;\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < (1 << m); j++) {\r\n                if (i > 0 && dp[i-1][j]) {\r\n                    dp[i][j] = true;\r\n                    continue;\r\n                }\r\n                for (int s = j; s != 0; s = ((s - 1) & j)) { // 子集枚举，详见 https://oi-wiki.org/math/bit/#_14\r\n                    int prev = j - s; // 前 i-1 个元素需要满足子集 prev = j-s\r\n                    bool last = (i == 0) ? (prev == 0): dp[i-1][prev]; // cnt[0..i-1] 能否满足子集 prev\r\n                    bool need = sum[s] <= cnt[i]; // cnt[i] 能否满足子集 s\r\n                    if (last && need) {\r\n                        dp[i][j] = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dp[n-1][(1<<m)-1];\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：$O(n\\cdot 3^m)$，其中 $n$ 为 $\\textit{nums}$ 中不同整数的数量，$m$ 为 $\\textit{quantity}$ 的大小。\r\n- 空间复杂度：$O(n \\cdot 2^m)$。"
}