{
	"titleSlug": "find-kth-largest-xor-coordinate-value",
	"slug": "zhao-chu-di-k-da-de-yi-huo-zuo-biao-zhi-mgick",
	"url": "https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/solution/zhao-chu-di-k-da-de-yi-huo-zuo-biao-zhi-mgick/",
	"content": "#### å‰è¨€\n\n**æ€è·¯ä¸ç®—æ³•**\n\næˆ‘ä»¬ç”¨ $\\oplus$ è¡¨ç¤ºæŒ‰ä½å¼‚æˆ–è¿ç®—ã€‚\n\nç”±äºã€ŒæŒ‰ä½å¼‚æˆ–è¿ç®—ã€ä¸ã€ŒåŠ æ³•è¿ç®—ã€æœ‰ç€ååˆ†ç›¸ä¼¼çš„æ€§è´¨ï¼Œå®ƒä»¬éƒ½æ»¡è¶³äº¤æ¢å¾‹ï¼š\n\n$$\na \\oplus b = b \\oplus a\n$$\n\nä»¥åŠç»“åˆå¾‹ï¼š\n\n$$\n(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)\n$$\n\nå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ã€Œå‰ç¼€å’Œã€è¿™ä¸€æŠ€å·§å¯¹æŒ‰ä½å¼‚æˆ–è¿ç®—çš„ç»“æœè¿›è¡Œç»´æŠ¤ã€‚ç”±äºæœ¬é¢˜ä¸­ç»™å®šçš„çŸ©é˜µ $\\textit{matrix}$ æ˜¯äºŒç»´çš„ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä½¿ç”¨äºŒç»´å‰ç¼€å’Œã€‚\n\nè®¾äºŒç»´å‰ç¼€å’Œ $\\textit{pre}(i, j)$ è¡¨ç¤ºçŸ©é˜µ $\\textit{matrix}$ ä¸­æ‰€æœ‰æ»¡è¶³ $0 \\leq x < i$ ä¸” $0 \\leq y < j$ çš„å…ƒç´ æ‰§è¡ŒæŒ‰ä½å¼‚æˆ–è¿ç®—çš„ç»“æœã€‚ä¸ä¸€ç»´å‰ç¼€å’Œç±»ä¼¼ï¼Œè¦æƒ³å¿«é€Ÿå¾—åˆ° $\\textit{pre}(i, j)$ï¼Œæˆ‘ä»¬éœ€è¦å·²ç»çŸ¥é“ $\\textit{pre}(i-1, j)$ï¼Œ$\\textit{pre}(i, j-1)$ ä»¥åŠ $\\textit{pre}(i-1,j-1)$ çš„ç»“æœï¼Œå³ï¼š\n\n$$\n\\textit{pre}(i, j) = \\textit{pre}(i-1, j) \\oplus \\textit{pre}(i, j-1) \\oplus \\textit{pre}(i-1, j-1) \\oplus \\textit{matrix}(i, j)\n$$\n\nä¸‹å›¾ç»™å‡ºäº†è¯¥äºŒç»´å‰ç¼€å’Œé€’æ¨å¼çš„å¯è§†åŒ–å±•ç¤ºã€‚\n\n![fig1](https://assets.leetcode-cn.com/solution-static/1738/1.png)\n\nå½“æˆ‘ä»¬å°† $\\textit{pre}(i-1, j)$ å’Œ $\\textit{pre}(i, j-1)$ è¿›è¡ŒæŒ‰ä½å¼‚æˆ–è¿ç®—åï¼Œç”±äºå¯¹ä¸€ä¸ªæ•° $x$ å¼‚æˆ–ä¸¤æ¬¡ $y$ï¼Œç»“æœä»ç„¶ä¸º $x$ æœ¬èº«ï¼Œå³ï¼š\n\n$$\nx \\oplus y \\oplus y = x\n$$\n\nå› æ­¤ $\\textit{pre}(i-1, j-1)$ å¯¹åº”åŒºåŸŸçš„æŒ‰ä½å¼‚æˆ–ç»“æœè¢«æŠµæ¶ˆï¼Œæˆ‘ä»¬éœ€è¦å°†å…¶è¡¥ä¸Šï¼Œå¹¶å¯¹ä½ç½® $(i, j)$ çš„å…ƒç´ è¿›è¡ŒæŒ‰ä½å¼‚æˆ–è¿ç®—ï¼Œè¿™æ ·å°±å¾—åˆ°äº† $\\textit{pre}(i, j)$ã€‚\n\nåœ¨å¾—åˆ°äº†æ‰€æœ‰çš„äºŒç»´å‰ç¼€å’Œä¹‹åï¼Œæˆ‘ä»¬åªéœ€è¦æ‰¾å‡ºå…¶ä¸­ç¬¬ $k$ å¤§çš„å…ƒç´ å³ä¸ºç­”æ¡ˆã€‚è¿™ä¸€æ­¥æˆ‘ä»¬å¯ä»¥ç›´æ¥å°† $mn$ ä¸ªäºŒç»´å‰ç¼€å’Œè¿›è¡Œæ’åºåè¿”ç¬¬ $k$ å¤§çš„å…ƒç´ ï¼Œä¹Ÿå¯ä»¥å‚è€ƒã€Œ[215. æ•°ç»„ä¸­çš„ç¬¬ K ä¸ªæœ€å¤§å…ƒç´ çš„å®˜æ–¹é¢˜è§£](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/)ã€ä¸­æ—¶é—´å¤æ‚åº¦æ›´ä½çš„åšæ³•ã€‚\n\nä¸‹é¢çš„æ–¹æ³•ä¸€ç»™å‡ºçš„æ˜¯åŸºäºæ’åºçš„è§£æ³•ï¼Œæ–¹æ³•äºŒç»™å‡ºçš„æ˜¯åŸºäºå¿«é€Ÿæ’åºæ€è·¯çš„ã€æ—¶é—´å¤æ‚åº¦æ›´ä½çš„å¿«é€Ÿé€‰æ‹©ç®—æ³•çš„è§£æ³•ã€‚\n\n**ç»†èŠ‚**\n\nåœ¨äºŒç»´å‰ç¼€å’Œçš„è®¡ç®—è¿‡ç¨‹ä¸­ï¼Œå¦‚æœæˆ‘ä»¬æ­£åœ¨è®¡ç®—é¦–è¡Œæˆ–è€…é¦–åˆ—ï¼Œå³ $i=0$ æˆ– $j=0$ï¼Œæ­¤æ—¶ä¾‹å¦‚ $\\textit{pre}(i-1,j-1)$ æ˜¯ä¸€ä¸ªè¶…å‡ºä¸‹æ ‡èŒƒå›´çš„ç»“æœã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ª $(m+1) \\times (n+1)$ çš„äºŒç»´çŸ©é˜µï¼Œå°†é¦–è¡Œå’Œé¦–åˆ—ç©ºå‡ºæ¥èµ‹äºˆé»˜è®¤å€¼ $0$ï¼Œå¹¶ä½¿ç”¨æ¥ä¸‹æ¥çš„ $m$ è¡Œå’Œ $n$ åˆ—å­˜å‚¨äºŒç»´å‰ç¼€å’Œï¼Œè¿™æ ·å°±ä¸å¿…è¿›è¡Œä¸‹æ ‡èŒƒå›´çš„åˆ¤æ–­äº†ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šäºŒç»´å‰ç¼€å’Œ + æ’åº\n\n**ä»£ç **\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int kthLargestValue(vector<vector<int>>& matrix, int k) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<vector<int>> pre(m + 1, vector<int>(n + 1));\n        vector<int> results;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n                results.push_back(pre[i][j]);\n            }\n        }\n\n        sort(results.begin(), results.end(), greater<int>());\n        return results[k - 1];\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int kthLargestValue(int[][] matrix, int k) {\n        int m = matrix.length, n = matrix[0].length;\n        int[][] pre = new int[m + 1][n + 1];\n        List<Integer> results = new ArrayList<Integer>();\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n                results.add(pre[i][j]);\n            }\n        }\n\n        Collections.sort(results, new Comparator<Integer>() {\n            public int compare(Integer num1, Integer num2) {\n                return num2 - num1;\n            }\n        });\n        return results.get(k - 1);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int KthLargestValue(int[][] matrix, int k) {\n        int m = matrix.Length, n = matrix[0].Length;\n        int[,] pre = new int[m + 1, n + 1];\n        List<int> results = new List<int>();\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                pre[i, j] = pre[i - 1, j] ^ pre[i, j - 1] ^ pre[i - 1, j - 1] ^ matrix[i - 1][j - 1];\n                results.Add(pre[i, j]);\n            }\n        }\n\n        results.Sort(\n            delegate(int num1, int num2) {\n                return num2 - num1;\n            }\n        );\n        return results[k - 1];\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        pre = [[0] * (n + 1) for _ in range(m + 1)]\n        results = list()\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1]\n                results.append(pre[i][j])\n\n        results.sort(reverse=True)\n        return results[k - 1]\n```\n\n```go [sol1-Golang]\nfunc kthLargestValue(matrix [][]int, k int) int {\n    m, n := len(matrix), len(matrix[0])\n    results := make([]int, 0, m*n)\n    pre := make([][]int, m+1)\n    pre[0] = make([]int, n+1)\n    for i, row := range matrix {\n        pre[i+1] = make([]int, n+1)\n        for j, val := range row {\n            pre[i+1][j+1] = pre[i+1][j] ^ pre[i][j+1] ^ pre[i][j] ^ val\n            results = append(results, pre[i+1][j+1])\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(results)))\n    return results[k-1]\n}\n```\n\n```C [sol1-C]\nint cmp(int* a, int* b) {\n    return *b - *a;\n}\n\nint kthLargestValue(int** matrix, int matrixSize, int* matrixColSize, int k) {\n    int m = matrixSize, n = matrixColSize[0];\n    int pre[m + 1][n + 1];\n    memset(pre, 0, sizeof(pre));\n    int results[m * n], resultsSize = 0;\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n            results[resultsSize++] = pre[i][j];\n        }\n    }\n\n    qsort(results, resultsSize, sizeof(int), cmp);\n    return results[k - 1];\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar kthLargestValue = function(matrix, k) {\n    const m = matrix.length, n = matrix[0].length;\n    const pre = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    const results = [];\n    for (let i = 1; i < m + 1; i++) {\n        for (let j = 1; j < n + 1; j++) {\n            pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n            results.push(pre[i][j]);\n        }\n    }\n    results.sort((a, b) => b - a);\n    return results[k - 1];\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(mn \\log (mn))$ã€‚è®¡ç®—äºŒç»´å‰ç¼€å’Œçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(mn)$ï¼Œæ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(mn \\log (mn))$ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(mn \\log (mn))$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(mn)$ï¼Œå³ä¸ºå­˜å‚¨äºŒç»´å‰ç¼€å’Œéœ€è¦çš„ç©ºé—´ã€‚\n\n#### æ–¹æ³•äºŒï¼šäºŒç»´å‰ç¼€å’Œ + å¿«é€Ÿé€‰æ‹©ç®—æ³•\n\n**ä»£ç **\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int kthLargestValue(vector<vector<int>>& matrix, int k) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<vector<int>> pre(m + 1, vector<int>(n + 1));\n        vector<int> results;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n                results.push_back(pre[i][j]);\n            }\n        }\n\n        nth_element(results.begin(), results.begin() + k - 1, results.end(), greater<int>());\n        return results[k - 1];\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int kthLargestValue(int[][] matrix, int k) {\n        int m = matrix.length, n = matrix[0].length;\n        int[][] pre = new int[m + 1][n + 1];\n        List<Integer> results = new ArrayList<Integer>();\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n                results.add(pre[i][j]);\n            }\n        }\n\n        nthElement(results, 0, k - 1, results.size() - 1);\n        return results.get(k - 1);\n    }\n\n    public void nthElement(List<Integer> results, int left, int kth, int right) {\n        if (left == right) {\n            return;\n        }\n        int pivot = (int) (left + Math.random() * (right - left + 1));\n        swap(results, pivot, right);\n        // ä¸‰è·¯åˆ’åˆ†ï¼ˆthree-way partitionï¼‰\n        int sepl = left - 1, sepr = left - 1;\n        for (int i = left; i <= right; i++) {\n            if (results.get(i) > results.get(right)) {\n                swap(results, ++sepr, i);\n                swap(results, ++sepl, sepr);\n            } else if (results.get(i) == results.get(right)) {\n                swap(results, ++sepr, i);\n            }\n        }\n        if (sepl < left + kth && left + kth <= sepr) {\n            return;\n        } else if (left + kth <= sepl) {\n            nthElement(results, left, kth, sepl);\n        } else {\n            nthElement(results, sepr + 1, kth - (sepr - left + 1), right);\n        }\n    }\n\n    public void swap(List<Integer> results, int index1, int index2) {\n        int temp = results.get(index1);\n        results.set(index1, results.get(index2));\n        results.set(index2, temp);\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    Random random = new Random();\n\n    public int KthLargestValue(int[][] matrix, int k) {\n        int m = matrix.Length, n = matrix[0].Length;\n        int[,] pre = new int[m + 1, n + 1];\n        List<int> results = new List<int>();\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                pre[i, j] = pre[i - 1, j] ^ pre[i, j - 1] ^ pre[i - 1, j - 1] ^ matrix[i - 1][j - 1];\n                results.Add(pre[i, j]);\n            }\n        }\n\n        NthElement(results, 0, k - 1, results.Count - 1);\n        return results[k - 1];\n    }\n\n    public void NthElement(List<int> results, int left, int kth, int right) {\n        if (left == right) {\n            return;\n        }\n        int pivot = random.Next(left, right + 1);\n        Swap(results, pivot, right);\n        // ä¸‰è·¯åˆ’åˆ†ï¼ˆthree-way partitionï¼‰\n        int sepl = left - 1, sepr = left - 1;\n        for (int i = left; i <= right; i++) {\n            if (results[i] > results[right]) {\n                Swap(results, ++sepr, i);\n                Swap(results, ++sepl, sepr);\n            } else if (results[i] == results[right]) {\n                Swap(results, ++sepr, i);\n            }\n        }\n        if (sepl < left + kth && left + kth <= sepr) {\n            return;\n        } else if (left + kth <= sepl) {\n            NthElement(results, left, kth, sepl);\n        } else {\n            NthElement(results, sepr + 1, kth - (sepr - left + 1), right);\n        }\n    }\n\n    public void Swap(List<int> results, int index1, int index2) {\n        int temp = results[index1];\n        results[index1] = results[index2];\n        results[index2] = temp;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        pre = [[0] * (n + 1) for _ in range(m + 1)]\n        results = list()\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1]\n                results.append(pre[i][j])\n        \n        def nth_element(left: int, kth: int, right: int, op: Callable[[int, int], bool]):\n            if left == right:\n                return\n            \n            pivot = random.randint(left, right)\n            results[pivot], results[right] = results[right], results[pivot]\n\n            # ä¸‰è·¯åˆ’åˆ†ï¼ˆthree-way partitionï¼‰\n            sepl = sepr = left - 1\n            for i in range(left, right + 1):\n                if op(results[i], results[right]):\n                    sepr += 1\n                    if sepr != i:\n                        results[sepr], results[i] = results[i], results[sepr]\n                    sepl += 1\n                    if sepl != sepr:\n                        results[sepl], results[sepr] = results[sepr], results[sepl]\n                elif results[i] == results[right]:\n                    sepr += 1\n                    if sepr != i:\n                        results[sepr], results[i] = results[i], results[sepr]\n            \n            if sepl < left + kth <= sepr:\n                return\n            elif left + kth <= sepl:\n                nth_element(left, kth, sepl, op)\n            else:\n                nth_element(sepr + 1, kth - (sepr - left + 1), right, op)\n\n        nth_element(0, k - 1, len(results) - 1, operator.gt)\n        return results[k - 1]\n```\n\n```go [sol2-Golang]\nfunc quickSelect(a []int, k int) int {\n    rand.Shuffle(len(a), func(i, j int) { a[i], a[j] = a[j], a[i] })\n    for l, r := 0, len(a)-1; l < r; {\n        v := a[l]\n        i, j := l, r+1\n        for {\n            for i++; i < r && a[i] < v; i++ {\n            }\n            for j--; j > l && a[j] > v; j-- {\n            }\n            if i >= j {\n                break\n            }\n            a[i], a[j] = a[j], a[i]\n        }\n        a[l], a[j] = a[j], v\n        if j == k {\n            break\n        } else if j < k {\n            l = j + 1\n        } else {\n            r = j - 1\n        }\n    }\n    return a[k]\n}\n\nfunc kthLargestValue(matrix [][]int, k int) int {\n    m, n := len(matrix), len(matrix[0])\n    results := make([]int, 0, m*n)\n    pre := make([][]int, m+1)\n    pre[0] = make([]int, n+1)\n    for i, row := range matrix {\n        pre[i+1] = make([]int, n+1)\n        for j, val := range row {\n            pre[i+1][j+1] = pre[i+1][j] ^ pre[i][j+1] ^ pre[i][j] ^ val\n            results = append(results, pre[i+1][j+1])\n        }\n    }\n    return quickSelect(results, m*n-k)\n}\n```\n\n```C [sol2-C]\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b, *b = t;\n}\n\nint cmp(int a, int b) {\n    return a > b;\n}\n\nvoid nth_element(int* arr, int left, int kth, int right) {\n    if (left == right) {\n        return;\n    }\n    int pivot = left + rand() % (right - left);\n    swap(&arr[pivot], &arr[right]);\n    // ä¸‰è·¯åˆ’åˆ†ï¼ˆthree-way partitionï¼‰\n    int sepl = left - 1, sepr = left - 1;\n    for (int i = left; i <= right; i++) {\n        if (arr[i] > arr[right]) {\n            swap(&arr[++sepr], &arr[i]);\n            swap(&arr[++sepl], &arr[sepr]);\n        } else if (arr[i] == arr[right]) {\n            swap(&arr[++sepr], &arr[i]);\n        }\n    }\n    if (sepl < left + kth && left + kth <= sepr) {\n        return;\n    } else if (left + kth <= sepl) {\n        nth_element(arr, left, kth, sepl);\n    } else {\n        nth_element(arr, sepr + 1, kth - (sepr - left + 1), right);\n    }\n}\n\nint kthLargestValue(int** matrix, int matrixSize, int* matrixColSize, int k) {\n    int m = matrixSize, n = matrixColSize[0];\n    int pre[m + 1][n + 1];\n    memset(pre, 0, sizeof(pre));\n    int results[m * n], resultsSize = 0;\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n            results[resultsSize++] = pre[i][j];\n        }\n    }\n    nth_element(results, 0, k - 1, resultsSize - 1);\n    return results[k - 1];\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar kthLargestValue = function(matrix, k) {\n    const m = matrix.length, n = matrix[0].length;\n    const pre = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    const results = [];\n    for (let i = 1; i <= m; ++i) {\n        for (let j = 1; j <= n; ++j) {\n            pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n            results.push(pre[i][j]);\n        }\n    }\n    nthElement(results, 0, k - 1, results.length - 1);\n    return results[k - 1];\n}\n\nconst nthElement = (results, left, kth, right) => {\n    if (left === right) {\n        return;\n    }\n    const pivot = parseInt(Math.random() * (right - left) + left);\n    swap(results, pivot, right);\n    // ä¸‰è·¯åˆ’åˆ†ï¼ˆthree-way partitionï¼‰\n    let sepl = left - 1, sepr = left - 1;\n    for (let i = left; i <= right; i++) {\n        if (results[i] > results[right]) {\n            swap(results, ++sepr, i);\n            swap(results, ++sepl, sepr);\n        } else if (results[i] === results[right]) {\n            swap(results, ++sepr, i);\n        }\n    }\n    if (sepl < left + kth && left + kth <= sepr) {\n        return;\n    } else if (left + kth <= sepl) {\n        nthElement(results, left, kth, sepl);\n    } else {\n        nthElement(results, sepr + 1, kth - (sepr - left + 1), right);\n    }\n}\n\nconst swap = (results, index1, index2) => {\n    const temp = results[index1];\n    results[index1] = results[index2];\n    results[index2] = temp;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(mn)$ã€‚è®¡ç®—äºŒç»´å‰ç¼€å’Œçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(mn)$ï¼Œå¿«é€Ÿé€‰æ‹©æ‰¾å‡ºç¬¬ $k$ å¤§çš„å…ƒç´ çš„æœŸæœ›æ—¶é—´å¤æ‚åº¦ä¸º $O(mn)$ï¼Œæœ€åæƒ…å†µä¸‹æ—¶é—´å¤æ‚åº¦ä¸º $O((mn)^2)$ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(mn)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(mn)$ï¼Œå³ä¸ºå­˜å‚¨äºŒç»´å‰ç¼€å’Œéœ€è¦çš„ç©ºé—´ã€‚\n\n---\n## âœ¨æ‰£å‹å¸®å¸®å›¢ - äº’åŠ¨ç­”ç–‘\n\n[![è®¨è®º.jpg](https://pic.leetcode-cn.com/1621178600-MKHFrl-%E8%AE%A8%E8%AE%BA.jpg){:width=260px}](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)\n\n\nå³æ—¥èµ· - 5 æœˆ 30 æ—¥ï¼Œç‚¹å‡»Â [è¿™é‡Œ](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)Â å‰å¾€ã€Œ[æ‰£å‹å¸®å¸®å›¢](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)ã€æ´»åŠ¨é¡µï¼ŒæŠŠä½ é‡åˆ°çš„é—®é¢˜å¤§èƒ†åœ°æå‡ºæ¥ï¼Œè®©æ‰£å‹ä¸ºä½ è§£ç­”ï½\n\n### ğŸ å¥–åŠ±è§„åˆ™\nè¢«é‡‡çº³æ•°é‡æ’å 1ï½3 åï¼šã€ŒåŠ›æ‰£æå®¢å¥—è£…ã€ *1 å¹¶å°†è·å¾—ã€ŒåŠ›æ‰£ç¥ç§˜åº”æ´å›¢ã€å†…æµ‹èµ„æ ¼\nè¢«é‡‡çº³æ•°é‡æ’å 4ï½10 åï¼šã€ŒåŠ›æ‰£é¼ æ ‡å«ã€ *1 å¹¶å°†è·å¾—ã€ŒåŠ›æ‰£ç¥ç§˜åº”æ´å›¢ã€å†…æµ‹èµ„æ ¼\nã€Œè¯²äººä¸å€¦ã€ï¼šæ´»åŠ¨æœŸé—´ã€Œè§£æƒ‘è€…ã€åªè¦æœ‰ 1 ä¸ªå›ç­”è¢«é‡‡çº³ï¼Œå³å¯è·å¾— 20 LeetCoins å¥–åŠ±ï¼\nã€Œæ±‚çŸ¥è‹¥æ¸´ã€ï¼šæ´»åŠ¨æœŸé—´ã€Œæ±‚çŸ¥è€…ã€åœ¨æ´»åŠ¨é¡µå‘èµ·ä¸€æ¬¡ç¬¦åˆè¦æ±‚çš„ç–‘é—®å¸–å¹¶è‡³å°‘é‡‡çº³ä¸€æ¬¡ã€Œè§£æƒ‘è€…ã€çš„å›ç­”ï¼Œå³å¯è·å¾— 20 LeetCoins å¥–åŠ±ï¼\n\næ´»åŠ¨è¯¦æƒ…çŒ›æˆ³é“¾æ¥äº†è§£æ›´å¤šï¼š[æ´»åŠ¨ï½œä½ æœ‰ BUG æˆ‘æ¥å¸® - åŠ›æ‰£äº’åŠ¨ç­”ç–‘å­£](https://leetcode-cn.com/circle/discuss/xtliW6/)"
}