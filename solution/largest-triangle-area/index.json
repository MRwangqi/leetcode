{
	"titleSlug": "largest-triangle-area",
	"slug": "zui-da-san-jiao-xing-mian-ji-by-leetcode-yefh",
	"url": "https://leetcode-cn.com/problems/largest-triangle-area/solution/zui-da-san-jiao-xing-mian-ji-by-leetcode-yefh/",
	"content": "#### 方法一：枚举\n\n**思路与算法**\n\n关于求解三角形面积的公式可以参考百度百科「[三角形面积公式](https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F)」。\n\n我们可以枚举所有的三角形，然后计算三角形的面积并找出最大的三角形面积。设三角形三个顶点的坐标为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$，则三角形面积 $S$ 可以用行列式的绝对值表示：\n\n$$S = \\frac{1}{2} \\left| \\begin{vmatrix} x_1 & y_1 & 1 \\\\ x_2 & y_2 & 1 \\\\ x_3 & y_3 &1 \\end{vmatrix} \\right| = \\frac{1}{2} \\lvert x_1 y_2 + x_2 y_3 + x_3 y_1 - x_1 y_3 - x_2 y_1 - x_3 y_2 \\rvert$$\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        def triangleArea(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> float:\n            return abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2) / 2\n        return max(triangleArea(x1, y1, x2, y2, x3, y3) for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3))\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    double triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\n        return 0.5 * abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n    }\n\n    double largestTriangleArea(vector<vector<int>> & points) {\n        int n = points.size();\n        double ret = 0.0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    ret = max(ret, triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public double largestTriangleArea(int[][] points) {\n        int n = points.length;\n        double ret = 0.0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    ret = Math.max(ret, triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));\n                }\n            }\n        }\n        return ret;\n    }\n\n    public double triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\n        return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public double LargestTriangleArea(int[][] points) {\n        int n = points.Length;\n        double ret = 0.0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    ret = Math.Max(ret, TriangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));\n                }\n            }\n        }\n        return ret;\n    }\n\n    public double TriangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\n        return 0.5 * Math.Abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n    }\n}\n```\n\n```C [sol1-C]\nstatic inline double max(double a, double b) {\n    return a > b ? a : b;\n}\n\ndouble triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\n    return 0.5 * abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n}\n\ndouble largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\n    double ret = 0.0;\n    for (int i = 0; i < pointsSize; i++) {\n        for (int j = i + 1; j < pointsSize; j++) {\n            for (int k = j + 1; k < pointsSize; k++) {\n                double area = triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]);\n                ret = max(ret, area);\n            }\n        }\n    }\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar largestTriangleArea = function(points) {\n    const n = points.length;\n    let ret = 0.0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                ret = Math.max(ret, triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));\n            }\n        }\n    }\n    return ret;\n};\n\nconst triangleArea = (x1, y1, x2, y2, x3, y3) => {\n    return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n}\n```\n\n```go [sol1-Golang]\nfunc triangleArea(x1, y1, x2, y2, x3, y3 int) float64 {\n    return math.Abs(float64(x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2)) / 2\n}\n\nfunc largestTriangleArea(points [][]int) (ans float64) {\n    for i, p := range points {\n        for j, q := range points[:i] {\n            for _, r := range points[:j] {\n                ans = math.Max(ans, triangleArea(p[0], p[1], q[0], q[1], r[0], r[1]))\n            }\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n^3)$，其中 $n$ 是数组 $\\textit{points}$ 的长度。三重循环需要 $O(n^3)$。\n\n+ 空间复杂度：$O(1)$。\n\n#### 方法二：凸包\n\n**思路与算法**\n\n我们先使用 $\\text{Andrew}$ 算法求出所有点对应的凸包 $\\textit{convexHull}$，参考官方题解「[587. 安装栅栏](https://leetcode-cn.com/problems/erect-the-fence/solution/an-zhuang-zha-lan-by-leetcode-solution-75s3/)」的凸包算法。\n\n> 如果三角形的某一点不在凸包上，我们以其余两点的边为底，那么我们总可以在凸包上找到一个点，使得该点到此边的高大于原来的点到此边的高，因此面积最大的三角形的三个点都在凸包上。\n\n在凸包 $\\textit{convexHull}$ 上枚举三角形，先枚举点 $i$，然后枚举点 $j$，最后枚举点 $k$，其中 $i \\lt j \\lt k$。\n\n> 在固定点 $i$ 和 $j$ 后，三角形的面积与 $k$ 的关系是一个凸曲线，因此三角形只在 $k$ 为极点时面积最大。在固定点 $i$ 时，该极点在随点 $j$ 增大而增大，因此在搜索极点只需要从上次的极点位置开始搜索。\n\n所以我们不需要枚举点 $k$，只需要搜索点 $i$ 和 $j$ 对应的极点，然后求解三角形面积。返回最大的三角形面积。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def getConvexHull(self, points: List[List[int]]) -> List[List[int]]:\n        def cross(p: List[int], q: List[int], r: List[int]) -> int:\n            return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0])\n\n        n = len(points)\n        if n < 4:\n            return points\n\n        # 按照 x 从小到大排序，如果 x 相同，则按照 y 从小到大排序\n        points.sort()\n\n        hull = []\n        # 求凸包的下半部分\n        for i, p in enumerate(points):\n            while len(hull) > 1 and cross(hull[-2], hull[-1], p) <= 0:\n                hull.pop()\n            hull.append(p)\n        # 求凸包的上半部分\n        m = len(hull)\n        for i in range(n - 2, -1, -1):\n            while len(hull) > m and cross(hull[-2], hull[-1], points[i]) <= 0:\n                hull.pop()\n            hull.append(points[i])\n        hull.pop()  # hull[0] 同时参与凸包的上半部分检测，因此需去掉重复的 hull[0]\n        return hull\n\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        def triangleArea(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> float:\n            return abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2) / 2\n\n        convexHull = self.getConvexHull(points)\n        ans, n = 0, len(convexHull)\n        for i, p in enumerate(convexHull):\n            k = i + 2\n            for j in range(i + 1, n - 1):\n                q = convexHull[j]\n                while k + 1 < n:\n                    curArea = triangleArea(p[0], p[1], q[0], q[1], convexHull[k][0], convexHull[k][1])\n                    nextArea = triangleArea(p[0], p[1], q[0], q[1], convexHull[k + 1][0], convexHull[k + 1][1])\n                    if curArea >= nextArea:\n                        break\n                    k += 1\n                ans = max(ans, triangleArea(p[0], p[1], q[0], q[1], convexHull[k][0], convexHull[k][1]))\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\nprivate:\n    int cross(const vector<int> & p, const vector<int> & q, const vector<int> & r) {\n        return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]);\n    }\n\n    vector<vector<int>> getConvexHull(vector<vector<int>>& points) {\n        int n = points.size();\n        if (n < 4) {\n            return points;\n        }\n        /* 按照 x 大小进行排序，如果 x 相同，则按照 y 的大小进行排序 */\n        sort(points.begin(), points.end(), [](const vector<int> & a, const vector<int> & b) {\n            if (a[0] == b[0]) {\n                return a[1] < b[1];\n            }\n            return a[0] < b[0];\n        });\n        vector<vector<int>> hull;\n        /* 求出凸包的下半部分 */\n        for (int i = 0; i < n; i++) {\n            while (hull.size() > 1 && cross(hull[hull.size() - 2], hull.back(), points[i]) <= 0) {\n                hull.pop_back();\n            }\n            hull.emplace_back(points[i]);\n        }\n        int m = hull.size();\n        /* 求出凸包的上半部分 */\n        for (int i = n - 2; i >= 0; i--) {\n            while (hull.size() > m && cross(hull[hull.size() - 2], hull.back(), points[i]) <= 0) {\n                hull.pop_back();\n            }\n            hull.emplace_back(points[i]);\n        }\n        /* hull[0] 同时参与凸包的上半部分检测，因此需去掉重复的 hull[0] */\n        hull.pop_back();\n        return hull;\n    }\n\n    double triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\n        return 0.5 * abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n    }\n\npublic:\n    double largestTriangleArea(vector<vector<int>> & points) {\n        auto convexHull = getConvexHull(points);\n        int n = convexHull.size();\n        double ret = 0.0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1, k = i + 2; j + 1 < n; j++) {\n                while (k + 1 < n) {\n                    double curArea = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);\n                    double nextArea = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k + 1][0], convexHull[k + 1][1]);\n                    if (curArea >= nextArea) {\n                        break;\n                    }\n                    k++;\n                }\n                double area = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);\n                ret = max(ret, area);\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public double largestTriangleArea(int[][] points) {\n        int[][] convexHull = getConvexHull(points);\n        int n = convexHull.length;\n        double ret = 0.0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1, k = i + 2; j + 1 < n; j++) {\n                while (k + 1 < n) {\n                    double curArea = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);\n                    double nextArea = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k + 1][0], convexHull[k + 1][1]);\n                    if (curArea >= nextArea) {\n                        break;\n                    }\n                    k++;\n                }\n                double area = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);\n                ret = Math.max(ret, area);\n            }\n        }\n        return ret;\n    }\n\n    public int[][] getConvexHull(int[][] points) {\n        int n = points.length;\n        if (n < 4) {\n            return points;\n        }\n        /* 按照 x 大小进行排序，如果 x 相同，则按照 y 的大小进行排序 */\n        Arrays.sort(points, (a, b) -> {\n            if (a[0] == b[0]) {\n                return a[1] - b[1];\n            }\n            return a[0] - b[0];\n        });\n        List<int[]> hull = new ArrayList<int[]>();\n        /* 求出凸包的下半部分 */\n        for (int i = 0; i < n; i++) {\n            while (hull.size() > 1 && cross(hull.get(hull.size() - 2), hull.get(hull.size() - 1), points[i]) <= 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(points[i]);\n        }\n        int m = hull.size();\n        /* 求出凸包的上半部分 */\n        for (int i = n - 2; i >= 0; i--) {\n            while (hull.size() > m && cross(hull.get(hull.size() - 2), hull.get(hull.size() - 1), points[i]) <= 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(points[i]);\n        }\n        /* hull[0] 同时参与凸包的上半部分检测，因此需去掉重复的 hull[0] */\n        hull.remove(hull.size() - 1);\n        m = hull.size();\n        int[][] hullArr = new int[m][];\n        for (int i = 0; i < m; i++) {\n            hullArr[i] = hull.get(i);\n        }\n        return hullArr;\n    }\n\n    public double triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\n        return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n    }\n\n    public int cross(int[] p, int[] q, int[] r) {\n        return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]);\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public double LargestTriangleArea(int[][] points) {\n        int[][] convexHull = getConvexHull(points);\n        int n = convexHull.Length;\n        double ret = 0.0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1, k = i + 2; j + 1 < n; j++) {\n                while (k + 1 < n) {\n                    double curArea = TriangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);\n                    double nextArea = TriangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k + 1][0], convexHull[k + 1][1]);\n                    if (curArea >= nextArea) {\n                        break;\n                    }\n                    k++;\n                }\n                double area = TriangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);\n                ret = Math.Max(ret, area);\n            }\n        }\n        return ret;\n    }\n\n    public int[][] getConvexHull(int[][] points) {\n        int n = points.Length;\n        if (n < 4) {\n            return points;\n        }\n        /* 按照 x 大小进行排序，如果 x 相同，则按照 y 的大小进行排序 */\n        Array.Sort(points, (a, b) => {\n            if (a[0] == b[0]) {\n                return a[1] - b[1];\n            }\n            return a[0] - b[0];\n        });\n        IList<int[]> hull = new List<int[]>();\n        /* 求出凸包的下半部分 */\n        for (int i = 0; i < n; i++) {\n            while (hull.Count > 1 && Cross(hull[hull.Count - 2], hull[hull.Count - 1], points[i]) <= 0) {\n                hull.RemoveAt(hull.Count - 1);\n            }\n            hull.Add(points[i]);\n        }\n        int m = hull.Count;\n        /* 求出凸包的上半部分 */\n        for (int i = n - 2; i >= 0; i--) {\n            while (hull.Count > m && Cross(hull[hull.Count - 2], hull[hull.Count - 1], points[i]) <= 0) {\n                hull.RemoveAt(hull.Count - 1);\n            }\n            hull.Add(points[i]);\n        }\n        /* hull[0] 同时参与凸包的上半部分检测，因此需去掉重复的 hull[0] */\n        hull.RemoveAt(hull.Count - 1);\n        m = hull.Count;\n        int[][] hullArr = new int[m][];\n        for (int i = 0; i < m; i++) {\n            hullArr[i] = hull[i];\n        }\n        return hullArr;\n    }\n\n    public double TriangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\n        return 0.5 * Math.Abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n    }\n\n    public int Cross(int[] p, int[] q, int[] r) {\n        return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]);\n    }\n}\n```\n\n```C [sol2-C]\n\nstatic int cross(const int * p, const int * q, const int * r) {\n    return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]);\n}\n\nstatic int cmp(const void * pa, const void * pb) {\n    int *a = *((int **)pa);\n    int *b = *((int **)pb);\n    if (a[0] == b[0]) {\n        return a[1] - b[1];\n    }\n    return a[0] - b[0];\n}\n\nstatic int** getConvexHull(int** points, int pointsSize, int* pointsColSize, int* returnSize) {\n    int **res = (int **)malloc(sizeof(int *) * pointsSize);\n    int pos = 0;\n    if (pointsSize < 4) {\n        for (int i = 0; i < pointsSize; i++) {\n            res[i] = (int *)malloc(sizeof(int) * 2);\n            res[i][0] = points[i][0];\n            res[i][1] = points[i][1];\n        }\n        *returnSize = pointsSize;\n        return res;\n    }\n    \n    qsort(points, pointsSize, sizeof(int *), cmp);\n    int * hull = (int *)malloc(sizeof(int) * (pointsSize + 1));\n    int * used = (int *)malloc(sizeof(int) * pointsSize);\n    /* hull[0] 需要入栈两次 */\n    hull[pos++] = 0;\n    /* 求出凸包的下半部分 */\n    for (int i = 1; i < pointsSize; i++) {\n        while (pos > 1 && cross(points[hull[pos - 2]], points[hull[pos - 1]], points[i]) <= 0) {\n            pos--;\n        }\n        hull[pos++] = i;\n    }\n    int m = pos;\n    /* 求出凸包的上半部分 */\n    for (int i = pointsSize - 2; i >= 0; i--) {\n        while (pos > m && cross(points[hull[pos - 2]], points[hull[pos - 1]], points[i]) <= 0) {\n            pos--;\n        }\n        hull[pos++] = i;\n    }\n    /* hull[0] 同时参与凸包的上半部分检测，因此需去掉重复的 hull[0] */\n    pos--;\n    *returnSize = pos;\n    for (int i = 0; i < pos; i++) {\n        res[i] = (int *)malloc(sizeof(int) * 2);\n        memcpy(res[i], points[hull[i]], sizeof(int) * 2);\n    }\n    free(used);\n    free(hull);\n    return res;\n}\n\nstatic inline double max(double a, double b) {\n    return a > b ? a : b;\n}\n\ndouble triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\n    return 0.5 * abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n}\n\ndouble largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\n    int hullSize = 0;\n    int **convexHull = getConvexHull(points, pointsSize, pointsColSize, &hullSize);\n    double ret = 0.0;\n    for (int i = 0; i < hullSize; i++) {\n        for (int j = i + 1, k = i + 2; j + 1 < hullSize; j++) {\n            while (k + 1 < hullSize) {\n                double curArea = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);\n                double nextArea = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k + 1][0], convexHull[k + 1][1]);\n                if (curArea >= nextArea) {\n                    break;\n                }\n                k++;\n            }\n            double area = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);\n            ret = max(ret, area);\n        }\n    }\n    for (int i = 0; i < hullSize; i++) {\n        free(convexHull[i]);\n    }\n    free(convexHull);\n    return ret;\n}\n```\n\n```go [sol2-Golang]\nfunc cross(p, q, r []int) int {\n    return (q[0]-p[0])*(r[1]-q[1]) - (q[1]-p[1])*(r[0]-q[0])\n}\n\nfunc getConvexHull(points [][]int) [][]int {\n    n := len(points)\n    if n < 4 {\n        return points\n    }\n\n    // 按照 x 从小到大排序，如果 x 相同，则按照 y 从小到大排序\n    sort.Slice(points, func(i, j int) bool { a, b := points[i], points[j]; return a[0] < b[0] || a[0] == b[0] && a[1] < b[1] })\n\n    hull := [][]int{}\n    // 求凸包的下半部分\n    for _, p := range points {\n        for len(hull) > 1 && cross(hull[len(hull)-2], hull[len(hull)-1], p) <= 0 {\n            hull = hull[:len(hull)-1]\n        }\n        hull = append(hull, p)\n    }\n    // 求凸包的上半部分\n    m := len(hull)\n    for i := n - 1; i >= 0; i-- {\n        for len(hull) > m && cross(hull[len(hull)-2], hull[len(hull)-1], points[i]) <= 0 {\n            hull = hull[:len(hull)-1]\n        }\n        hull = append(hull, points[i])\n    }\n    // hull[0] 同时参与凸包的上半部分检测，因此需去掉重复的 hull[0]\n    return hull[:len(hull)-1]\n}\n\nfunc triangleArea(x1, y1, x2, y2, x3, y3 int) float64 {\n    return math.Abs(float64(x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2)) / 2\n}\n\nfunc largestTriangleArea(points [][]int) (ans float64) {\n    convexHull := getConvexHull(points)\n    n := len(convexHull)\n    for i, p := range convexHull {\n        for j, k := i+1, i+2; j+1 < n; j++ {\n            q := convexHull[j]\n            for ; k+1 < n; k++ {\n                curArea := triangleArea(p[0], p[1], q[0], q[1], convexHull[k][0], convexHull[k][1])\n                nextArea := triangleArea(p[0], p[1], q[0], q[1], convexHull[k+1][0], convexHull[k+1][1])\n                if curArea >= nextArea {\n                    break\n                }\n            }\n            ans = math.Max(ans, triangleArea(p[0], p[1], q[0], q[1], convexHull[k][0], convexHull[k][1]))\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar largestTriangleArea = function(points) {\n    const convexHull = getConvexHull(points);\n    const n = convexHull.length;\n    let ret = 0.0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1, k = i + 2; j + 1 < n; j++) {\n            while (k + 1 < n) {\n                const curArea = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);\n                const nextArea = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k + 1][0], convexHull[k + 1][1]);\n                if (curArea >= nextArea) {\n                    break;\n                }\n                k++;\n            }\n            const area = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);\n            ret = Math.max(ret, area);\n        }\n    }\n    return ret;\n}\n\nconst getConvexHull = (points) => {\n    const n = points.length;\n    if (n < 4) {\n        return points;\n    }\n    /* 按照 x 大小进行排序，如果 x 相同，则按照 y 的大小进行排序 */\n    points.sort((a, b) => {\n        if (a[0] === b[0]) {\n            return a[1] - b[1];\n        }\n        return a[0] - b[0];\n    });\n    const hull = [];\n    /* 求出凸包的下半部分 */\n    for (let i = 0; i < n; i++) {\n        while (hull.length > 1 && cross(hull[hull.length - 2], hull[hull.length - 1], points[i]) <= 0) {\n            hull.pop();\n        }\n        hull.push(points[i]);\n    }\n    let m = hull.length;\n    /* 求出凸包的上半部分 */\n    for (let i = n - 2; i >= 0; i--) {\n        while (hull.length > m && cross(hull[hull.length - 2], hull[hull.length - 1], points[i]) <= 0) {\n            hull.pop();\n        }\n        hull.push(points[i]);\n    }\n    /* hull[0] 同时参与凸包的上半部分检测，因此需去掉重复的 hull[0] */\n    hull.pop();\n    m = hull.length;\n    const hullArr = new Array(m).fill(0);\n    for (let i = 0; i < m; i++) {\n        hullArr[i] = hull[i];\n    }\n    return hullArr;\n}\n\nconst triangleArea = (x1, y1, x2, y2, x3, y3) => {\n    return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n}\n\nconst cross = (p, q, r) => {\n    return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]);\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n^2)$，其中 $n$ 是数组 $\\textit{points}$ 的长度。$\\text{Andrew}$ 算法的时间复杂度为 $O(n \\log n)$，在凸包上枚举三角形的时间复杂度为 $O(n^2)$。\n\n+ 空间复杂度：$O(n)$。$\\text{Andrew}$ 算法的空间复杂度为 $O(n)$，保存凸包需要 $O(n)$ 的空间。"
}