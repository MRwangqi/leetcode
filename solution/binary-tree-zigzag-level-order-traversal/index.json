{
	"titleSlug": "binary-tree-zigzag-level-order-traversal",
	"slug": "er-cha-shu-de-ju-chi-xing-ceng-xu-bian-l-qsun",
	"url": "https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/solution/er-cha-shu-de-ju-chi-xing-ceng-xu-bian-l-qsun/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†.mp4](7bceca28-6f60-4f58-b52c-b59d3d7b8b91)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆéå†\n\næ­¤é¢˜æ˜¯ã€Œ[102. äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)ã€çš„å˜ç§ï¼Œæœ€åè¾“å‡ºçš„è¦æ±‚æœ‰æ‰€å˜åŒ–ï¼Œè¦æ±‚æˆ‘ä»¬æŒ‰å±‚æ•°çš„å¥‡å¶æ¥å†³å®šæ¯ä¸€å±‚çš„è¾“å‡ºé¡ºåºã€‚è§„å®šäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ä¸ºç¬¬ $0$ å±‚ï¼Œå¦‚æœå½“å‰å±‚æ•°æ˜¯å¶æ•°ï¼Œ**ä»å·¦è‡³å³**è¾“å‡ºå½“å‰å±‚çš„èŠ‚ç‚¹å€¼ï¼Œå¦åˆ™ï¼Œ**ä»å³è‡³å·¦**è¾“å‡ºå½“å‰å±‚çš„èŠ‚ç‚¹å€¼ã€‚\n\næˆ‘ä»¬ä¾ç„¶å¯ä»¥æ²¿ç”¨ç¬¬ 102 é¢˜çš„æ€æƒ³ï¼Œä¿®æ”¹å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œå¯¹æ ‘è¿›è¡Œé€å±‚éå†ï¼Œç”¨é˜Ÿåˆ—ç»´æŠ¤å½“å‰å±‚çš„æ‰€æœ‰å…ƒç´ ï¼Œå½“é˜Ÿåˆ—ä¸ä¸ºç©ºçš„æ—¶å€™ï¼Œæ±‚å¾—å½“å‰é˜Ÿåˆ—çš„é•¿åº¦ $\\textit{size}$ï¼Œæ¯æ¬¡ä»é˜Ÿåˆ—ä¸­å–å‡º $\\textit{size}$ ä¸ªå…ƒç´ è¿›è¡Œæ‹“å±•ï¼Œç„¶åè¿›è¡Œä¸‹ä¸€æ¬¡è¿­ä»£ã€‚\n\nä¸ºäº†æ»¡è¶³é¢˜ç›®è¦æ±‚çš„**è¿”å›å€¼**ä¸ºã€Œå…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦ã€äº¤æ›¿è¾“å‡ºçš„é”¯é½¿å½¢ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ã€ŒåŒç«¯é˜Ÿåˆ—ã€çš„æ•°æ®ç»“æ„æ¥ç»´æŠ¤å½“å‰å±‚èŠ‚ç‚¹å€¼è¾“å‡ºçš„é¡ºåºã€‚\n\nåŒç«¯é˜Ÿåˆ—æ˜¯ä¸€ä¸ªå¯ä»¥åœ¨é˜Ÿåˆ—ä»»æ„ä¸€ç«¯æ’å…¥å…ƒç´ çš„é˜Ÿåˆ—ã€‚åœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢éå†å½“å‰å±‚èŠ‚ç‚¹æ‹“å±•ä¸‹ä¸€å±‚èŠ‚ç‚¹çš„æ—¶å€™æˆ‘ä»¬ä»ç„¶ä»å·¦å¾€å³æŒ‰é¡ºåºæ‹“å±•ï¼Œä½†æ˜¯å¯¹å½“å‰å±‚èŠ‚ç‚¹çš„å­˜å‚¨æˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ªå˜é‡ $\\textit{isOrderLeft}$ è®°å½•æ˜¯ä»å·¦è‡³å³è¿˜æ˜¯ä»å³è‡³å·¦çš„ï¼š\n\n- å¦‚æœä»å·¦è‡³å³ï¼Œæˆ‘ä»¬æ¯æ¬¡å°†è¢«éå†åˆ°çš„å…ƒç´ æ’å…¥è‡³åŒç«¯é˜Ÿåˆ—çš„æœ«å°¾ã€‚\n\n- å¦‚æœä»å³è‡³å·¦ï¼Œæˆ‘ä»¬æ¯æ¬¡å°†è¢«éå†åˆ°çš„å…ƒç´ æ’å…¥è‡³åŒç«¯é˜Ÿåˆ—çš„å¤´éƒ¨ã€‚\n\nå½“éå†ç»“æŸçš„æ—¶å€™æˆ‘ä»¬å°±å¾—åˆ°äº†ç­”æ¡ˆæ•°ç»„ã€‚\n\n<![ppt1](https://assets.leetcode-cn.com/solution-static/103/1.png),![ppt2](https://assets.leetcode-cn.com/solution-static/103/2.png),![ppt3](https://assets.leetcode-cn.com/solution-static/103/3.png),![ppt4](https://assets.leetcode-cn.com/solution-static/103/4.png),![ppt5](https://assets.leetcode-cn.com/solution-static/103/5.png),![ppt6](https://assets.leetcode-cn.com/solution-static/103/6.png),![ppt7](https://assets.leetcode-cn.com/solution-static/103/7.png),![ppt8](https://assets.leetcode-cn.com/solution-static/103/8.png),![ppt9](https://assets.leetcode-cn.com/solution-static/103/9.png),![ppt10](https://assets.leetcode-cn.com/solution-static/103/10.png),![ppt11](https://assets.leetcode-cn.com/solution-static/103/11.png),![ppt12](https://assets.leetcode-cn.com/solution-static/103/12.png)>\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        if (!root) {\n            return ans;\n        }\n\n        queue<TreeNode*> nodeQueue;\n        nodeQueue.push(root);\n        bool isOrderLeft = true;\n\n        while (!nodeQueue.empty()) {\n            deque<int> levelList;\n            int size = nodeQueue.size();\n            for (int i = 0; i < size; ++i) {\n                auto node = nodeQueue.front();\n                nodeQueue.pop();\n                if (isOrderLeft) {\n                    levelList.push_back(node->val);\n                } else {\n                    levelList.push_front(node->val);\n                }\n                if (node->left) {\n                    nodeQueue.push(node->left);\n                }\n                if (node->right) {\n                    nodeQueue.push(node->right);\n                }\n            }\n            ans.emplace_back(vector<int>{levelList.begin(), levelList.end()});\n            isOrderLeft = !isOrderLeft;\n        }\n\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> ans = new LinkedList<List<Integer>>();\n        if (root == null) {\n            return ans;\n        }\n\n        Queue<TreeNode> nodeQueue = new ArrayDeque<TreeNode>();\n        nodeQueue.offer(root);\n        boolean isOrderLeft = true;\n\n        while (!nodeQueue.isEmpty()) {\n            Deque<Integer> levelList = new LinkedList<Integer>();\n            int size = nodeQueue.size();\n            for (int i = 0; i < size; ++i) {\n                TreeNode curNode = nodeQueue.poll();\n                if (isOrderLeft) {\n                    levelList.offerLast(curNode.val);\n                } else {\n                    levelList.offerFirst(curNode.val);\n                }\n                if (curNode.left != null) {\n                    nodeQueue.offer(curNode.left);\n                }\n                if (curNode.right != null) {\n                    nodeQueue.offer(curNode.right);\n                }\n            }\n            ans.add(new LinkedList<Integer>(levelList));\n            isOrderLeft = !isOrderLeft;\n        }\n\n        return ans;\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar zigzagLevelOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const ans = [];\n    const nodeQueue = [root];\n\n    let isOrderLeft = true;\n\n    while (nodeQueue.length) {\n        let levelList = [];\n        const size = nodeQueue.length;\n        for (let i = 0; i < size; ++i) {\n            const node = nodeQueue.shift();\n            if (isOrderLeft) {\n                levelList.push(node.val);\n            } else {\n                levelList.unshift(node.val);\n            }\n            if (node.left !== null) {\n                nodeQueue.push(node.left);\n            }\n            if (node.right !== null) {\n                nodeQueue.push(node.right);\n            }\n        }            \n        ans.push(levelList);\n        isOrderLeft = !isOrderLeft;\n    }\n\n    return ans;\n};\n```\n\n```Go [sol1-Golang]\nfunc zigzagLevelOrder(root *TreeNode) (ans [][]int) {\n    if root == nil {\n        return\n    }\n    queue := []*TreeNode{root}\n    for level := 0; len(queue) > 0; level++ {\n        vals := []int{}\n        q := queue\n        queue = nil\n        for _, node := range q {\n            vals = append(vals, node.Val)\n            if node.Left != nil {\n                queue = append(queue, node.Left)\n            }\n            if node.Right != nil {\n                queue = append(queue, node.Right)\n            }\n        }\n        // æœ¬è´¨ä¸Šå’Œå±‚åºéå†ä¸€æ ·ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠå¥‡æ•°å±‚çš„å…ƒç´ ç¿»è½¬å³å¯\n        if level%2 == 1 {\n            for i, n := 0, len(vals); i < n/2; i++ {\n                vals[i], vals[n-1-i] = vals[n-1-i], vals[i]\n            }\n        }\n        ans = append(ans, vals)\n    }\n    return\n}\n```\n\n```C [sol1-C]\n#define N 2000\n\nint** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0;\n    if (root == NULL) {\n        return NULL;\n    }\n    int** ans = malloc(sizeof(int*) * N);\n    *returnColumnSizes = malloc(sizeof(int) * N);\n    struct TreeNode* nodeQueue[N];\n    int left = 0, right = 0;\n    nodeQueue[right++] = root;\n    bool isOrderLeft = true;\n\n    while (left < right) {\n        int levelList[N * 2];\n        int front = N, rear = N;\n        int size = right - left;\n        for (int i = 0; i < size; ++i) {\n            struct TreeNode* node = nodeQueue[left++];\n            if (isOrderLeft) {\n                levelList[rear++] = node->val;\n            } else {\n                levelList[--front] = node->val;\n            }\n            if (node->left) {\n                nodeQueue[right++] = node->left;\n            }\n            if (node->right) {\n                nodeQueue[right++] = node->right;\n            }\n        }\n        int* tmp = malloc(sizeof(int) * (rear - front));\n        for (int i = 0; i < rear - front; i++) {\n            tmp[i] = levelList[i + front];\n        }\n        ans[*returnSize] = tmp;\n        (*returnColumnSizes)[*returnSize] = rear - front;\n        (*returnSize)++;\n        isOrderLeft = !isOrderLeft;\n    }\n    return ans;\n} \n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ ä¸ºäºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚æ¯ä¸ªèŠ‚ç‚¹ä¼šä¸”ä»…ä¼šè¢«éå†ä¸€æ¬¡ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ã€‚æˆ‘ä»¬éœ€è¦ç»´æŠ¤å­˜å‚¨èŠ‚ç‚¹çš„é˜Ÿåˆ—å’Œå­˜å‚¨èŠ‚ç‚¹å€¼çš„åŒç«¯é˜Ÿåˆ—ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(N)$ã€‚"
}