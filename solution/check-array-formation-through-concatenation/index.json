{
	"titleSlug": "check-array-formation-through-concatenation",
	"slug": "neng-fou-lian-jie-xing-cheng-shu-zu-by-l-rnkn",
	"url": "https://leetcode-cn.com/problems/check-array-formation-through-concatenation/solution/neng-fou-lian-jie-xing-cheng-shu-zu-by-l-rnkn/",
	"content": "#### 方法一：哈希表\n\n因为数组 $\\textit{arr}$ 每个整数互不相同，且 $\\textit{pieces}$ 的整数也互不相同，所以我们可以通过 $\\textit{arr}$ 固定 $\\textit{pieces}$ 的放置。使用哈希表 $\\textit{index}$ 记录 $\\textit{pieces}$ 各个数组的**首元素**与数组下标的对应关系。\n\n我们不断地将 $\\textit{pieces}$ 中的数组与数组 $\\textit{arr}$ 相对应，对于当前遍历的元素 $\\textit{arr}[i]$，如果它不存在于哈希表中，说明我们无法将 $\\textit{pieces}$ 与数组 $\\textit{arr}$ 相对应，直接返回 $\\text{false}$；否则我们找到对应的数组 $\\textit{pieces}[j]$，然后将它与 $\\textit{arr}[i]$ 及之后的整数进行比较（在比较过程中，如果判断相等不成立，直接返回 $\\text{false}$），判断都相等后，将 $i$ 相应地向后移。全部 $\\textit{pieces}$ 都匹配成功后，返回 $\\text{true}$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        index = {p[0]: i for i, p in enumerate(pieces)}\n        i = 0\n        while i < len(arr):\n            if arr[i] not in index:\n                return False\n            p = pieces[index[arr[i]]]\n            if arr[i: i + len(p)] != p:\n                return False\n            i += len(p)\n        return True\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool canFormArray(vector<int> &arr, vector<vector<int>> &pieces) {\n        unordered_map<int, int> index;\n        for (int i = 0; i < pieces.size(); i++) {\n            index[pieces[i][0]] = i;\n        }\n        for (int i = 0; i < arr.size();) {\n            auto it = index.find(arr[i]);\n            if (it == index.end()) {\n                return false;\n            }\n            for (int x : pieces[it->second]) {\n                if (arr[i++] != x) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean canFormArray(int[] arr, int[][] pieces) {\n        int n = arr.length, m = pieces.length;\n        Map<Integer, Integer> index = new HashMap<Integer, Integer>();\n        for (int i = 0; i < m; i++) {\n            index.put(pieces[i][0], i);\n        }\n        for (int i = 0; i < n;) {\n            if (!index.containsKey(arr[i])) {\n                return false;\n            }\n            int j = index.get(arr[i]), len = pieces[j].length;\n            for (int k = 0; k < len; k++) {\n                if (arr[i + k] != pieces[j][k]) {\n                    return false;\n                }\n            }\n            i = i + len;\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool CanFormArray(int[] arr, int[][] pieces) {\n        int n = arr.Length, m = pieces.Length;\n        Dictionary<int, int> index = new Dictionary<int, int>();\n        for (int i = 0; i < m; i++) {\n            index.Add(pieces[i][0], i);\n        }\n        for (int i = 0; i < n;) {\n            if (!index.ContainsKey(arr[i])) {\n                return false;\n            }\n            int j = index[arr[i]], len = pieces[j].Length;\n            for (int k = 0; k < len; k++) {\n                if (arr[i + k] != pieces[j][k]) {\n                    return false;\n                }\n            }\n            i = i + len;\n        }\n        return true;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} HashItem; \n\nHashItem *hashFindItem(HashItem **obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nbool hashAddItem(HashItem **obj, int key, int val) {\n    if (hashFindItem(obj, key)) {\n        return false;\n    }\n    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = key;\n    pEntry->val = val;\n    HASH_ADD_INT(*obj, key, pEntry);\n    return true;\n}\n\nbool hashSetItem(HashItem **obj, int key, int val) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        hashAddItem(obj, key, val);\n    } else {\n        pEntry->val = val;\n    }\n    return true;\n}\n\nint hashGetItem(HashItem **obj, int key, int defaultVal) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        return defaultVal;\n    }\n    return pEntry->val;\n}\n\nvoid hashFree(HashItem **obj) {\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);             \n    }\n}\n\nbool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\n    int n = arrSize, m = piecesSize;\n    HashItem *index = NULL;\n    for (int i = 0; i < m; i++) {\n        hashAddItem(&index, pieces[i][0], i);\n    }\n    for (int i = 0; i < n;) {\n        if (!hashFindItem(&index, arr[i])) {\n            hashFree(&index);\n            return false;\n        }\n        int j = hashGetItem(&index, arr[i], 0);\n        int len = piecesColSize[j];\n        for (int k = 0; k < len; k++) {\n            if (arr[i + k] != pieces[j][k]) {\n                hashFree(&index);\n                return false;\n            }\n        }\n        i = i + len;\n    }\n    hashFree(&index);\n    return true;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar canFormArray = function(arr, pieces) {\n    const n = arr.length, m = pieces.length;\n    const index = new Map();\n    for (let i = 0; i < m; i++) {\n        index.set(pieces[i][0], i);\n    }\n    for (let i = 0; i < n;) {\n        if (!index.has(arr[i])) {\n            return false;\n        }\n        const j = index.get(arr[i]), len = pieces[j].length;\n        for (let k = 0; k < len; k++) {\n            if (arr[i + k] != pieces[j][k]) {\n                return false;\n            }\n        }\n        i = i + len;\n    }\n    return true;\n};\n```\n\n```go [sol1-Golang]\nfunc canFormArray(arr []int, pieces [][]int) bool {\n    index := make(map[int]int, len(pieces))\n    for i, p := range pieces {\n        index[p[0]] = i\n    }\n    for i := 0; i < len(arr); {\n        j, ok := index[arr[i]]\n        if !ok {\n            return false\n        }\n        for _, x := range pieces[j] {\n            if arr[i] != x {\n                return false\n            }\n            i++\n        }\n    }\n    return true\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度。\n\n+ 空间复杂度：$O(n)$。保存哈希表需要 $O(n)$ 的空间。"
}