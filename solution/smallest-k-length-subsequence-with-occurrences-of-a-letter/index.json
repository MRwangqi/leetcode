{
	"titleSlug": "smallest-k-length-subsequence-with-occurrences-of-a-letter",
	"slug": "java-by-fei-xiao-r-3bgk",
	"url": "https://leetcode-cn.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/solution/java-by-fei-xiao-r-3bgk/",
	"content": "1. 第一步：先不考虑k和要求letter有repetition个的情况下找出最小字典序序子字符：\r\n- 这里我们利用单调栈维护一个单调递增的子字符，这样我们就找到了s的最小字典序子字符sb；\r\n2. 第二步：找到的最小字典序子字符sb很可能不符合我们的要求的长度k;\r\n- 如果sb.length() >= k 这样很好解决将多出来的去掉就好了；\r\n- 如果sb.length() < k的话：我们就需要在维护单调递增的时候适当的将长度维护在 >= k的范围了；如果当前位置后面的字符数 + 栈中字符数 大于 k 则可以进行抛出；否则不行；\r\n3. 第三步：当sb满足第二步的条件时候，也有可能sb中 letter 字符数 < repetition;\r\n- 这里其实很第二步一样将维护单调栈时候，适当的将letter数量维护在 >= repetition的范围；如果当前位置后面的letter数量 + 栈中letter数量 == repetition 将不抛出；\r\n- 这里用前缀和sums记录i位置之后的letter数量；\r\n4. 第四步：得到的sb长度有可能 > k;当大于k时候，当栈中当前位置之后的sb缺少letter数量等于sb缺少的长度，证明当前位置之后的字符全部都应该是letter；\r\n\r\n\r\n```\r\nclass Solution {\r\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\r\n        //单调栈\r\n        StringBuilder sb = new StringBuilder();\r\n        if(k == repetition){\r\n            while(repetition-- > 0) sb.append(letter);\r\n            return sb.toString();\r\n        }\r\n        Deque<Character> stack = new LinkedList<>();\r\n        char[] chs = s.toCharArray();\r\n        int[] sums = new int[chs.length];\r\n        sums[chs.length-1] = chs[chs.length-1] == letter ? 1 : 0;\r\n        for(int i=chs.length-2; i>=0; i--) sums[i] = sums[i+1] + (chs[i] == letter ? 1 : 0);\r\n        int n = chs.length , f = 0;\r\n        for(int i=0; i<n; i++){\r\n            int j = k - (n - i) , r = repetition - sums[i];\r\n            //第一步 ： stack.peek() > chs[i];\r\n            //第二步 ： stack.size() > j;\r\n            while(!stack.isEmpty() && stack.size() > j && stack.peek() > chs[i]){\r\n                //第三步 ：f <= r;\r\n                if(stack.peek() == letter){\r\n                    if(f <= r)break;\r\n                    else f--;\r\n                } \r\n                stack.pop();\r\n            }\r\n            if(chs[i] == letter) f++;\r\n            stack.push(chs[i]);\r\n        }\r\n        f = 0;\r\n        while(k-- > 0){\r\n            sb.append(stack.peekLast());\r\n            if(stack.pollLast() == letter) f++;\r\n            //第四步 ： repetition - f == k;\r\n            if(repetition - f == k) break;\r\n        }\r\n        while(repetition - f > 0){\r\n            sb.append(letter);\r\n            f++;\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n"
}