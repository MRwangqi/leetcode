{
	"titleSlug": "final-prices-with-a-special-discount-in-a-shop",
	"slug": "shang-pin-zhe-kou-hou-de-zui-zhong-jie-g-ind3",
	"url": "https://leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop/solution/shang-pin-zhe-kou-hou-de-zui-zhong-jie-g-ind3/",
	"content": "#### 方法一：直接遍历\n\n对于第 $i$ 件商品的价格为 $\\textit{prices}[i]$，我们需要查找到相应可能的折扣。按照题目要求，我们从第 $i + 1$ 件商品开始依次向后遍历，直到找到第一个满足 $\\textit{prices}[j] \\le \\textit{prices}[i]$ 的下标 $j$ 即可求出该物品的最终折扣价格。我们按照题目要求依次遍历即可。\n\n```Python [sol1-Python3]\nclass Solution:\n    def finalPrices(self, prices: List[int]) -> List[int]:\n        n = len(prices)\n        ans = [0] * n\n        for i, p in enumerate(prices):\n            discount = 0\n            for j in range(i + 1, n):\n                if prices[j] <= p:\n                    discount = prices[j]\n                    break\n            ans[i] = p - discount\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> finalPrices(vector<int>& prices) {\n        int n = prices.size();\n        vector<int> ans;\n        for (int i = 0; i < n; ++i) {\n            int discount = 0;\n            for (int j = i + 1; j < n; ++j) {\n                if(prices[j] <= prices[i]){\n                    discount = prices[j];\n                    break;\n                }\n            }\n            ans.emplace_back(prices[i] - discount);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] finalPrices(int[] prices) {\n        int n = prices.length;\n        int[] ans = new int[n];\n        for (int i = 0; i < n; ++i) {\n            int discount = 0;\n            for (int j = i + 1; j < n; ++j) {\n                if(prices[j] <= prices[i]){\n                    discount = prices[j];\n                    break;\n                }\n            }\n            ans[i] = prices[i] - discount;\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] FinalPrices(int[] prices) {\n        int n = prices.Length;\n        int[] ans = new int[n];\n        for (int i = 0; i < n; ++i) {\n            int discount = 0;\n            for (int j = i + 1; j < n; ++j) {\n                if(prices[j] <= prices[i]){\n                    discount = prices[j];\n                    break;\n                }\n            }\n            ans[i] = prices[i] - discount;\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\nint* finalPrices(int* prices, int pricesSize, int* returnSize) {\n    int *ans = (int *)malloc(sizeof(int) * pricesSize);\n    for (int i = 0; i < pricesSize; ++i) {\n        int discount = 0;\n        for (int j = i + 1; j < pricesSize; ++j) {\n            if(prices[j] <= prices[i]){\n                discount = prices[j];\n                break;\n            }\n        }\n        ans[i] = prices[i] - discount;\n    }\n    *returnSize = pricesSize;\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar finalPrices = function(prices) {\n    const n = prices.length;\n    const ans = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        let discount = 0;\n        for (let j = i + 1; j < n; ++j) {\n            if(prices[j] <= prices[i]){\n                discount = prices[j];\n                break;\n            }\n        }\n        ans[i] = prices[i] - discount;\n    }\n    return ans;\n};  \n```\n\n```go [sol1-Golang]\nfunc finalPrices(prices []int) []int {\n    ans := make([]int, len(prices))\n    for i, p := range prices {\n        discount := 0\n        for _, q := range prices[i+1:] {\n            if q <= p {\n                discount = q\n                break\n            }\n        }\n        ans[i] = p - discount\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n ^ 2)$，其中 $n$ 为数组的长度。对于每个商品，我们需要遍历一遍数组查找符合题目要求的折扣。\n\n- 空间复杂度：$O(1)$。返回值不计入空间复杂度。\n\n#### 方法二：单调栈\n\n本题可以采用「[单调栈](https://oi-wiki.org/ds/monotonous-stack/)」的解法，可以参考「[496. 下一个更大元素 I 的官方题解](https://leetcode.cn/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode-bfcoj/)」。使用单调栈先预处理 $\\textit{prices}$，使得查询 $\\textit{prices}$ 中每个元素对应位置的右边的第一个更小的元素值时不需要再遍历 $\\textit{prices}$。解法的重点在于考虑如何更高效地计算 $\\textit{prices}$ 中每个元素右边第一个更小的值。倒序遍历 $\\textit{prices}$，并用单调栈中维护当前位置右边的更小的元素列表，从栈底到栈顶的元素是单调递增的。具体每次我们移动到数组中一个新的位置 $i$，就将单调栈中所有大于 $\\textit{prices}[i]$ 的元素弹出单调栈，当前位置右边的第一个小于等于 $\\textit{prices}[i]$ 的元素即为栈顶元素，如果栈为空则说明当前位置右边没有更大的元素，随后我们将位置 $i$ 的元素入栈。\n\n当遍历第 $i$ 个元素 $\\textit{prices}[i]$ 时：\n\n+ 如果当前栈顶的元素大于 $\\textit{prices}[i]$，则将栈顶元素出栈，直到栈顶的元素小于等于 $\\textit{prices}[i]$，栈顶的元素即为右边第一个小于 $\\textit{prices}[i]$ 的元素；\n\n+ 如果当前栈顶的元素小于等于 $\\textit{prices}[i]$，此时可以知道当前栈顶元素即为 $i$ 的右边第一个小于等于 $\\textit{prices}[i]$ 的元素，此时第 $i$ 个物品折后的价格为 $\\textit{prices}[i]$  与栈顶的元素的差。\n\n+ 如果当前栈中的元素为空，则此时折扣为 $0$，商品的价格为原价 $\\textit{prices}[i]$；\n\n+ 将 $\\textit{prices}[i]$ 压入栈中，保证 $\\textit{prices}[i]$ 为当前栈中的最大值；\n\n```Python [sol2-Python3]\nclass Solution:\n    def finalPrices(self, prices: List[int]) -> List[int]:\n        n = len(prices)\n        ans = [0] * n\n        st = [0]\n        for i in range(n - 1, -1, -1):\n            p = prices[i]\n            while len(st) > 1 and st[-1] > p:\n                st.pop()\n            ans[i] = p - st[-1]\n            st.append(p)\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> finalPrices(vector<int>& prices) {\n        int n = prices.size();\n        vector<int> ans(n);\n        stack<int> st;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!st.empty() && st.top() > prices[i]) {\n                st.pop();\n            }\n            ans[i] = st.empty() ? prices[i] : prices[i] - st.top();\n            st.emplace(prices[i]);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int[] finalPrices(int[] prices) {\n        int n = prices.length;\n        int[] ans = new int[n];\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && stack.peek() > prices[i]) {\n                stack.pop();\n            }\n            ans[i] = stack.isEmpty() ? prices[i] : prices[i] - stack.peek();\n            stack.push(prices[i]);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int[] FinalPrices(int[] prices) {\n        int n = prices.Length;\n        int[] ans = new int[n];\n        Stack<int> stack = new Stack<int>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (stack.Count > 0 && stack.Peek() > prices[i]) {\n                stack.Pop();\n            }\n            ans[i] = stack.Count == 0 ? prices[i] : prices[i] - stack.Peek();\n            stack.Push(prices[i]);\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol2-C]\nint* finalPrices(int* prices, int pricesSize, int* returnSize) {\n    int *ans = (int *)malloc(sizeof(int) * pricesSize);\n    int *stack = (int *)malloc(sizeof(int) * pricesSize);\n    int top = 0;\n    for (int i = pricesSize - 1; i >= 0; i--) {\n        while (top > 0 && stack[top - 1] > prices[i]) {\n            top--;\n        }\n        ans[i] = top == 0 ? prices[i] : prices[i] - stack[top - 1];\n        stack[top++] = prices[i];\n    }\n    *returnSize = pricesSize;\n    free(stack);\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar finalPrices = function(prices) {\n    const n = prices.length;\n    const ans = new Array(n).fill(0);\n    const stack = [];\n    for (let i = n - 1; i >= 0; i--) {\n        while (stack.length && stack[stack.length - 1] > prices[i]) {\n            stack.pop();\n        }\n        ans[i] = stack.length === 0 ? prices[i] : prices[i] - stack[stack.length - 1];\n        stack.push(prices[i]);\n    }\n    return ans;\n};  \n```\n\n```go [sol2-Golang]\nfunc finalPrices(prices []int) []int {\n    n := len(prices)\n    ans := make([]int, n)\n    st := []int{0}\n    for i := n - 1; i >= 0; i-- {\n        p := prices[i]\n        for len(st) > 1 && st[len(st)-1] > p {\n            st = st[:len(st)-1]\n        }\n        ans[i] = p - st[len(st)-1]\n        st = append(st, p)\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组的长度。只需遍历一遍数组即可。\n\n- 空间复杂度：$O(n)$。需要栈空间存储中间变量，需要的空间为 $O(n)$。"
}