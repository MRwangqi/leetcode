{
	"titleSlug": "minimum-difference-in-sums-after-removal-of-elements",
	"slug": "shan-chu-yuan-su-hou-he-de-zui-xiao-chai-ah0j",
	"url": "https://leetcode-cn.com/problems/minimum-difference-in-sums-after-removal-of-elements/solution/shan-chu-yuan-su-hou-he-de-zui-xiao-chai-ah0j/",
	"content": "#### 方法一：优先队列\n\n**思路与算法**\n\n题目中的要求等价于：\n\n- 在 $[n, 2n]$ 中选择一个正整数 $k$；\n\n- 数组 $\\textit{nums}$ 的前 $k$ 个数属于第一部分，但只能保留 $n$ 个；\n\n- 数组 $\\textit{nums}$ 的后 $3n-k$ 个数属于第二部分，但只能保留 $n$ 个；\n\n- 需要最小化第一部分和与第二部分和的差值。\n\n其中 $k \\in [n, 2n]$ 的原因是需要保证每一部分都至少有 $n$ 个元素。\n\n由于我们需要「最小化第一部分和与第二部分和的差值」，那么就需要第一部分的和尽可能小，第二部分的和尽可能大，也就是说：\n\n> 我们需要在第一部分中选择 $n$ 个最小的元素，第二部分中选择 $n$ 个最大的元素。\n\n因此我们可以使用优先队列来进行选择。对于第一部分而言，我们首先将 $\\textit{nums}[0 .. n-1]$ 全部放入大根堆中，随后遍历 $[n, 2n)$，记当前的下标为 $i$，那么将 $\\textit{nums}[i]$ 放入大根堆后再取出堆顶的元素，剩余堆中的元素即为 $\\textit{num}[0 .. i]$ 中的 $n$ 个最小的元素。\n\n对于第二部分而言，类似地，我们首先将 $\\textit{nums}[2n .. 3n-1]$ 全部放入小根堆中，随后**逆序**遍历 $[n, 2n)$，记当前的下标为 $i$，那么将 $\\textit{nums}[i]$ 放入小根堆后再取出堆顶的元素，剩余堆中的元素即为 $\\textit{num}[i .. 3n-1]$ 中的 $n$ 个最大的元素。\n\n在对优先队列进行操作时，我们还需要维护当前所有在优先队列中的元素之和。当元素被放入堆时，我们加上元素的值；当元素被从堆顶取出时，我们减去元素的值。这样一来，我们就可以得到 $\\textit{part}_1[n-1], \\cdots \\textit{part}_1[2n-1]$ 以及 $\\textit{part}_2[n], \\cdots \\textit{part}_2[2n]$，其中 $\\textit{part}_1[i]$ 表示 $\\textit{nums}[0..i]$ 中 $n$ 个最小的元素之和，$\\textit{part}_2[i]$ 表示 $\\textit{nums}[i..3n-1]$ 中 $n$ 个最大的元素之和。\n\n最终所有 $\\textit{part}_1[i] - \\textit{part}_2[i+1]$ 中的最小值即为答案。需要保证 $i \\in [n-1, 2n)$。\n\n**细节**\n\n我们可以将 $\\textit{part}_1$ 的下标全部减去 $n-1$，$\\textit{part}_2$ 的下标全部减去 $n$，这样它们的下标范围都是 $[0, n)$，我们只需要使用两个长度为 $n+1$ 的数组进行存储。\n\n更进一步，在计算 $\\textit{part}_2$ 时，我们无需使用数组进行存储，只需要使用一个变量。当下标为 $i$ 时，我们需要的 $\\textit{part}_1$ 项是 $\\textit{part}_1[i-1]$，下标减去 $n-1$ 变为 $\\textit{part}_1[i-n]$，那么使用 $\\textit{part}_1[i-n] - \\textit{part}_2$ 更新答案即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    long long minimumDifference(vector<int>& nums) {\n        int n3 = nums.size(), n = n3 / 3;\n        \n        vector<long long> part1(n + 1);\n        long long sum = 0;\n        // 大根堆\n        priority_queue<int> ql;\n        for (int i = 0; i < n; ++i) {\n            sum += nums[i];\n            ql.push(nums[i]);\n        }\n        part1[0] = sum;\n        for (int i = n; i < n * 2; ++i) {\n            sum += nums[i];\n            ql.push(nums[i]);\n            sum -= ql.top();\n            ql.pop();\n            part1[i - (n - 1)] = sum;\n        }\n        \n        long long part2 = 0;\n        // 小根堆\n        priority_queue<int, vector<int>, greater<int>> qr;\n        for (int i = n * 3 - 1; i >= n * 2; --i) {\n            part2 += nums[i];\n            qr.push(nums[i]);\n        }\n        long long ans = part1[n] - part2;\n        for (int i = n * 2 - 1; i >= n; --i) {\n            part2 += nums[i];\n            qr.push(nums[i]);\n            part2 -= qr.top();\n            qr.pop();\n            ans = min(ans, part1[i - n] - part2);\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimumDifference(self, nums: List[int]) -> int:\n        n3, n = len(nums), len(nums) // 3\n\n        part1 = [0] * (n + 1)\n        # 大根堆\n        total = sum(nums[:n])\n        ql = [-x for x in nums[:n]]\n        heapq.heapify(ql)\n        part1[0] = total\n\n        for i in range(n, n * 2):\n            total += nums[i]\n            heapq.heappush(ql, -nums[i])\n            total -= -heapq.heappop(ql)\n            part1[i - (n - 1)] = total\n        \n        # 小根堆\n        part2 = sum(nums[n * 2:])\n        qr = nums[n * 2:]\n        heapq.heapify(qr)\n        ans = part1[n] - part2\n\n        for i in range(n * 2 - 1, n - 1, -1):\n            part2 += nums[i]\n            heapq.heappush(qr, nums[i])\n            part2 -= heapq.heappop(qr)\n            ans = min(ans, part1[i - n] - part2)\n        \n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$。优先队列中包含 $n$ 个元素，单次操作时间复杂度为 $O(\\log n)$，操作次数为 $O(n)$。\n\n- 空间复杂度：$O(n)$，即为优先队列和数组 $\\textit{part}_1$ 需要使用的空间。"
}