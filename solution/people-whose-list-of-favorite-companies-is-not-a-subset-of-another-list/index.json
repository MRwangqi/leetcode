{
	"titleSlug": "people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list",
	"slug": "-by-wa-pian-d-tqyr",
	"url": "https://leetcode-cn.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/solution/-by-wa-pian-d-tqyr/",
	"content": "### 解题思路\n\n思路：\n\n大集合包含小集合，相同长度集合之间肯定不包含，这是`用户收藏的公司清单也 各不相同 ，也就是说，即便我们按字母顺序排序每个清单， favoriteCompanies[i] != favoriteCompanies[j] 仍然成立。`\n1. 先检查数量大的集合\n\n对于每个被检查的集合，每一个字符串出现在某些大集合中，这些出现记录的交集如果不为空，说明每一个字符串都出现在了同一个集合中。如果为空，说明这个集合不为任何一个集合的子集。\n\n求交集啊，笨招，招呼了。瞅瞅别人的吧。\n\n\n\n### 代码\n\n```java\nclass Solution {\n\n\tpublic List<Integer> peopleIndexes(List<List<String>> favoriteCompanies) {\n\t\tint size = favoriteCompanies.size();\n\t\tInteger[] idxs = new Integer[size];\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tidxs[i] = i;\n\t\t}\n\t\tArrays.sort(idxs, (a, b) -> {\n\t\t\treturn favoriteCompanies.get(b).size() - favoriteCompanies.get(a).size();\n\t\t});\n\t\tMap<String, List<Integer>> map = new HashMap<>();\n\t\tList<Integer> ans = new ArrayList<>();\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tint id = idxs[i];\n\t\t\tList<String> fc = favoriteCompanies.get(id);\n\t\t\tSet<Integer> set = new HashSet<>();\n\t\t\tfor (int j = 0; j < fc.size(); j++) {\n\t\t\t\tString f = fc.get(j);\n\t\t\t\tList<Integer> ids = map.getOrDefault(f, new ArrayList<>());\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tset.addAll(ids);\n\t\t\t\t} else {\n\t\t\t\t\tSet<Integer> cur = new HashSet<>();\n\t\t\t\t\tfor (int is : ids) {\n\t\t\t\t\t\tif (set.contains(is)) {\n\t\t\t\t\t\t\tcur.add(is);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tset = cur;\n\t\t\t\t}\n\t\t\t\tmap.computeIfAbsent(f, key -> new ArrayList<>()).add(id);\n\t\t\t}\n\t\t\tif (set.isEmpty()) {\n\t\t\t\tans.add(id);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(ans);\n\t\treturn ans;\n\t}\n\n}\n```"
}