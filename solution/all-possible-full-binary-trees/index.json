{
	"titleSlug": "all-possible-full-binary-trees",
	"slug": "suo-you-ke-neng-de-man-er-cha-shu-by-leetcode",
	"url": "https://leetcode-cn.com/problems/all-possible-full-binary-trees/solution/suo-you-ke-neng-de-man-er-cha-shu-by-leetcode/",
	"content": "#### 方法：递归\n\n**思路与算法**\n\n令 $\\text{FBT}(N)$ 作为所有含 $N$ 个结点的可能的满二叉树的列表。\n\n每个满二叉树 $T$ 含有 3 个或更多结点，在其根结点处有 2 个子结点。这些子结点 `left` 和 `right` 本身就是满二叉树。\n\n因此，对于 $N \\geq 3$，我们可以设定如下的递归策略：$\\text{FBT}(N) =$ [对于所有的 $x$，所有的树的左子结点来自 $\\text{FBT}(x)$ 而右子结点来自 $\\text{FBT}(N-1-x)$]。\n\n此外，通过简单的计数参数，没有满二叉树具有正偶数个结点。\n\n最后，我们应该缓存函数 $\\text{FBT}$ 之前的结果，这样我们就不必在递归中重新计算它们。\n\n```java [SVf3cp4a-Java]\nclass Solution {\n    Map<Integer, List<TreeNode>> memo = new HashMap();\n\n    public List<TreeNode> allPossibleFBT(int N) {\n        if (!memo.containsKey(N)) {\n            List<TreeNode> ans = new LinkedList();\n            if (N == 1) {\n                ans.add(new TreeNode(0));\n            } else if (N % 2 == 1) {\n                for (int x = 0; x < N; ++x) {\n                    int y = N - 1 - x;\n                    for (TreeNode left: allPossibleFBT(x))\n                        for (TreeNode right: allPossibleFBT(y)) {\n                            TreeNode bns = new TreeNode(0);\n                            bns.left = left;\n                            bns.right = right;\n                            ans.add(bns);\n                        }\n                }\n            }\n            memo.put(N, ans);\n        }\n\n        return memo.get(N);\n    }\n}\n```\n```python [SVf3cp4a-Python]\nclass Solution(object):\n    memo = {0: [], 1: [TreeNode(0)]}\n\n    def allPossibleFBT(self, N):\n        if N not in Solution.memo:\n            ans = []\n            for x in xrange(N):\n                y = N - 1 - x\n                for left in self.allPossibleFBT(x):\n                    for right in self.allPossibleFBT(y):\n                        bns = TreeNode(0)\n                        bns.left = left\n                        bns.right = right\n                        ans.append(bns)\n            Solution.memo[N] = ans\n\n        return Solution.memo[N]\n```\n\n\n**复杂度分析**\n\n* 时间复杂度：$O(2^N)$，对于 $N$ 是奇数的情况，令 $N = 2k + 1$。然后，$\\Big| \\text{FBT}(N) \\Big| = C_k$，第 $k$ 个卡特兰数（Catalan Number）；以及 $\\sum\\limits_{k < \\frac{N}{2}} C_k$（计算中间结果所涉及的复杂度） 限制在 $O(2^N)$内。但是，证明超出了本文的范围。\n\n* 空间复杂度：$O(2^N)$。"
}