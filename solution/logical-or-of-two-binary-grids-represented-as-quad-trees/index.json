{
	"titleSlug": "logical-or-of-two-binary-grids-represented-as-quad-trees",
	"slug": "si-cha-shu-jiao-ji-by-leetcode-solution-wy1u",
	"url": "https://leetcode-cn.com/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/solution/si-cha-shu-jiao-ji-by-leetcode-solution-wy1u/",
	"content": "#### 方法一：分治\n\n**思路与算法**\n\n题目给出两棵「四叉树」——$\\textit{quadTree}_1$，和 $\\textit{quadTree}_2$，它们分别代表一个 $n \\times n$ 的矩阵，且每一个子节点都是父节点对应矩阵区域的 $\\dfrac{1}{4}$ 区域：\n\n- $\\textit{topLeft}$ 节点为其父节点对应的矩阵区域左上角的 $\\dfrac{1}{4}$ 区域。\n- $\\textit{topRight}$ 节点为其父节点对应的矩阵区域右上角的 $\\dfrac{1}{4}$ 区域。\n- $\\textit{bottomLeft}$ 节点为其父节点对应的矩阵区域左下角的 $\\dfrac{1}{4}$ 区域。\n- $\\textit{bottomRight}$ 节点为其父节点对应的矩阵区域右下角的 $\\dfrac{1}{4}$ 区域。\n\n我们需要把这两个矩阵中的对应位置的值进行「或」操作，然后返回操作后的矩阵即可。对于 $\\forall x \\in \\{0,1\\}$，有 $0 ~|~ x = x$ 和 $1 ~|~ x = 1$ 成立。那么我们按照两棵树的对应的节点来进行合并操作，假设当前我们操作的两个节点分别为 $\\textit{node}_1$ 和 $\\textit{node}_2$，记节点的合并操作为 $\\textit{node}_1 ~|~ \\textit{node}_2$：\n\n1. $\\textit{node}_1$ 为叶子节点时：\n   - 如果 $\\textit{node}_1$ 的值为 $1$，那么 $\\textit{node}_1 ~|~ \\textit{node}_2 = \\textit{node}_1$。\n   - 否则 $\\textit{node}_1 ~|~ \\textit{node}_2 = \\textit{node}_2$。\n2. $\\textit{node}_2$ 为叶子节点时：\n   - 如果 $\\textit{node}_2$ 的值为 $1$，那么 $\\textit{node}_1 ~|~ \\textit{node}_2 = \\textit{node}_2$。\n   - 否则 $\\textit{node}_1 ~|~ \\textit{node}_2 = \\textit{node}_1$。\n3. 两者都不是叶子节点时：那么分别对两者的四个子节点来进行对应的分治处理——分别进行合并操作，然后再判断合并后的四个子节点的对应区域是否都为一个全 $0$ 或者全 $1$ 区域，如果是则原节点为叶子节点，否则原节点不是叶子节点，且四个子节点为上面合并操作后的四个对应子节点。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':\n        if quadTree1.isLeaf:\n            return Node(True, True) if quadTree1.val else quadTree2\n        if quadTree2.isLeaf:\n            return self.intersect(quadTree2, quadTree1)\n        o1 = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\n        o2 = self.intersect(quadTree1.topRight, quadTree2.topRight)\n        o3 = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\n        o4 = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\n        if o1.isLeaf and o2.isLeaf and o3.isLeaf and o4.isLeaf and o1.val == o2.val == o3.val == o4.val:\n            return Node(o1.val, True)\n        return Node(False, False, o1, o2, o3, o4)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\n        if (quadTree1->isLeaf) {\n            if (quadTree1->val) {\n                return new Node(true, true);\n            }\n            return new Node(quadTree2->val, quadTree2->isLeaf, quadTree2->topLeft, quadTree2->topRight, quadTree2->bottomLeft, quadTree2->bottomRight);\n        }\n        if (quadTree2->isLeaf) {\n            return intersect(quadTree2, quadTree1);\n        }\n        Node* o1 = intersect(quadTree1->topLeft, quadTree2->topLeft);\n        Node* o2 = intersect(quadTree1->topRight, quadTree2->topRight);\n        Node* o3 = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\n        Node* o4 = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\n        if (o1->isLeaf && o2->isLeaf && o3->isLeaf && o4->isLeaf && o1->val == o2->val && o1->val == o3->val && o1->val == o4->val) {\n            return new Node(o1->val, true);\n        }\n        return new Node(false, false, o1, o2, o3, o4);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public Node intersect(Node quadTree1, Node quadTree2) {\n        if (quadTree1.isLeaf) {\n            if (quadTree1.val) {\n                return new Node(true, true);\n            }\n            return new Node(quadTree2.val, quadTree2.isLeaf, quadTree2.topLeft, quadTree2.topRight, quadTree2.bottomLeft, quadTree2.bottomRight);\n        }\n        if (quadTree2.isLeaf) {\n            return intersect(quadTree2, quadTree1);\n        }\n        Node o1 = intersect(quadTree1.topLeft, quadTree2.topLeft);\n        Node o2 = intersect(quadTree1.topRight, quadTree2.topRight);\n        Node o3 = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\n        Node o4 = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\n        if (o1.isLeaf && o2.isLeaf && o3.isLeaf && o4.isLeaf && o1.val == o2.val && o1.val == o3.val && o1.val == o4.val) {\n            return new Node(o1.val, true);\n        }\n        return new Node(false, false, o1, o2, o3, o4);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public Node Intersect(Node quadTree1, Node quadTree2) {\n        if (quadTree1.isLeaf) {\n            if (quadTree1.val) {\n                return new Node(true, true);\n            }\n            return new Node(quadTree2.val, quadTree2.isLeaf, quadTree2.topLeft, quadTree2.topRight, quadTree2.bottomLeft, quadTree2.bottomRight);\n        }\n        if (quadTree2.isLeaf) {\n            return Intersect(quadTree2, quadTree1);\n        }\n        Node o1 = Intersect(quadTree1.topLeft, quadTree2.topLeft);\n        Node o2 = Intersect(quadTree1.topRight, quadTree2.topRight);\n        Node o3 = Intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\n        Node o4 = Intersect(quadTree1.bottomRight, quadTree2.bottomRight);\n        if (o1.isLeaf && o2.isLeaf && o3.isLeaf && o4.isLeaf && o1.val == o2.val && o1.val == o3.val && o1.val == o4.val) {\n            return new Node(o1.val, true);\n        }\n        return new Node(false, false, o1, o2, o3, o4);\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc intersect(quadTree1, quadTree2 *Node) *Node {\n    if quadTree1.IsLeaf {\n        if quadTree1.Val {\n            return &Node{Val: true, IsLeaf: true}\n        }\n        return quadTree2\n    }\n    if quadTree2.IsLeaf {\n        return intersect(quadTree2, quadTree1)\n    }\n    o1 := intersect(quadTree1.TopLeft, quadTree2.TopLeft)\n    o2 := intersect(quadTree1.TopRight, quadTree2.TopRight)\n    o3 := intersect(quadTree1.BottomLeft, quadTree2.BottomLeft)\n    o4 := intersect(quadTree1.BottomRight, quadTree2.BottomRight)\n    if o1.IsLeaf && o2.IsLeaf && o3.IsLeaf && o4.IsLeaf && o1.Val == o2.Val && o1.Val == o3.Val && o1.Val == o4.Val {\n        return &Node{Val: o1.Val, IsLeaf: true}\n    }\n    return &Node{false, false, o1, o2, o3, o4}\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar intersect = function(quadTree1, quadTree2) {\n    if (quadTree1.isLeaf) {\n        if (quadTree1.val) {\n            return new Node(true, true);\n        }\n        return new Node(quadTree2.val, quadTree2.isLeaf, quadTree2.topLeft, quadTree2.topRight, quadTree2.bottomLeft, quadTree2.bottomRight);\n    }\n    if (quadTree2.isLeaf) {\n        return intersect(quadTree2, quadTree1);\n    }\n    const o1 = intersect(quadTree1.topLeft, quadTree2.topLeft);\n    const o2 = intersect(quadTree1.topRight, quadTree2.topRight);\n    const o3 = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\n    const o4 = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\n    if (o1.isLeaf && o2.isLeaf && o3.isLeaf && o4.isLeaf && o1.val === o2.val && o1.val === o3.val && o1.val === o4.val) {\n        return new Node(o1.val, true);\n    }\n    return new Node(false, false, o1, o2, o3, o4);\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 是四叉树 $\\textit{quadTree}_1$ 和 $\\textit{quadTree}_2$ 对应矩阵的边长。最坏的情况下，整个矩阵都会被遍历。\n\n- 空间复杂度：$O(\\log n)$，其中 $n$ 是四叉树 $\\textit{quadTree}_1$ 和 $\\textit{quadTree}_2$ 对应矩阵的边长。空间开销主要为递归的空间开销。"
}