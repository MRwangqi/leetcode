{
	"titleSlug": "binary-subarrays-with-sum",
	"slug": "he-xiang-tong-de-er-yuan-zi-shu-zu-by-le-5caf",
	"url": "https://leetcode-cn.com/problems/binary-subarrays-with-sum/solution/he-xiang-tong-de-er-yuan-zi-shu-zu-by-le-5caf/",
	"content": "#### 方法一：哈希表\n\n**思路及算法**\n\n假设原数组的前缀和数组为 $\\textit{sum}$，且子数组 $(i,j]$ 的区间和为 $\\textit{goal}$，那么 $\\textit{sum}[j]-\\textit{sum}[i]=\\textit{goal}$。因此我们可以枚举 $j$ ，每次查询满足该等式的 $i$ 的数量。\n\n具体地，我们用哈希表记录每一种前缀和出现的次数，假设我们当前枚举到元素 $\\textit{nums}[j]$，我们只需要查询哈希表中元素 $\\textit{sum}[j]-\\textit{goal}$ 的数量即可，这些元素的数量即对应了以当前 $j$ 值为右边界的满足条件的子数组的数量。最后这些元素的总数量即为所有和为 $\\textit{goal}$ 的子数组数量。\n\n在实际代码中，我们实时地更新哈希表，以防止出现 $i \\geq j$ 的情况。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int numSubarraysWithSum(vector<int>& nums, int goal) {\n        int sum = 0;\n        unordered_map<int, int> cnt;\n        int ret = 0;\n        for (auto& num : nums) {\n            cnt[sum]++;\n            sum += num;\n            ret += cnt[sum - goal];\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int numSubarraysWithSum(int[] nums, int goal) {\n        int sum = 0;\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        int ret = 0;\n        for (int num : nums) {\n            cnt.put(sum, cnt.getOrDefault(sum, 0) + 1);\n            sum += num;\n            ret += cnt.getOrDefault(sum - goal, 0);\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int NumSubarraysWithSum(int[] nums, int goal) {\n        int sum = 0;\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        int ret = 0;\n        foreach (int num in nums) {\n            if (cnt.ContainsKey(sum)) {\n                cnt[sum]++;\n            } else {\n                cnt.Add(sum, 1);\n            }\n            sum += num;\n            int val = 0;\n            cnt.TryGetValue(sum - goal, out val);\n            ret += val;\n        }\n        return ret;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc numSubarraysWithSum(nums []int, goal int) (ans int) {\n    cnt := map[int]int{}\n    sum := 0\n    for _, num := range nums {\n        cnt[sum]++\n        sum += num\n        ans += cnt[sum-goal]\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar numSubarraysWithSum = function(nums, goal) {\n    let sum = 0;\n    const cnt = new Map();\n    let ret = 0;\n    for (const num of nums) {\n        cnt.set(sum, (cnt.get(sum) || 0) + 1);\n        sum += num;\n        ret += cnt.get(sum - goal) || 0;\n    }\n    return ret;\n};\n```\n\n```C [sol1-C]\nstruct HashTable {\n    int key, val;\n    UT_hash_handle hh;\n};\n\nint numSubarraysWithSum(int* nums, int numsSize, int goal) {\n    int sum = 0;\n    struct HashTable* cnt = NULL;\n    int ret = 0;\n    for (int i = 0; i < numsSize; i++) {\n        struct HashTable* tmp;\n        HASH_FIND_INT(cnt, &sum, tmp);\n        if (tmp == NULL) {\n            tmp = malloc(sizeof(struct HashTable));\n            tmp->key = sum, tmp->val = 1;\n            HASH_ADD_INT(cnt, key, tmp);\n        } else {\n            tmp->val++;\n        }\n        sum += nums[i];\n        int target = sum - goal;\n        HASH_FIND_INT(cnt, &target, tmp);\n        if (tmp != NULL) {\n            ret += tmp->val;\n        }\n    }\n    return ret;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为给定数组的长度。对于数组中的每个元素，我们至多只需要插入到哈希表中中一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为给定数组的长度。哈希表中至多只存储 $O(n)$ 个元素。\n\n#### 方法二：滑动窗口\n\n**思路及算法**\n\n注意到对于方法一中每一个 $j$，满足 $\\textit{sum}[j]-\\textit{sum}[i]=\\textit{goal}$ 的 $i$ 总是落在一个连续的区间中，$i$ 值取区间中每一个数都满足条件。并且随着 $j$ 右移，其对应的区间的左右端点也将右移，这样我们即可使用滑动窗口解决本题。\n\n具体地，我们令滑动窗口右边界为 $\\textit{right}$，使用两个左边界 $\\textit{left}_1$ 和 $\\textit{left}_2$ 表示左区间 $[\\textit{left}_1,\\textit{left}_2)$，此时有  $\\textit{left}_2-\\textit{left}_1$ 个区间满足条件。\n\n在实际代码中，我们需要注意 $\\textit{left}_1 \\leq \\textit{left}_2 \\leq \\textit{right} + 1$，因此需要在代码中限制 $\\textit{left}_1$ 和 $\\textit{left}_2$ 不超出范围。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int numSubarraysWithSum(vector<int>& nums, int goal) {\n        int n = nums.size();\n        int left1 = 0, left2 = 0, right = 0;\n        int sum1 = 0, sum2 = 0;\n        int ret = 0;\n        while (right < n) {\n            sum1 += nums[right];\n            while (left1 <= right && sum1 > goal) {\n                sum1 -= nums[left1];\n                left1++;\n            }\n            sum2 += nums[right];\n            while (left2 <= right && sum2 >= goal) {\n                sum2 -= nums[left2];\n                left2++;\n            }\n            ret += left2 - left1;\n            right++;\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int numSubarraysWithSum(int[] nums, int goal) {\n        int n = nums.length;\n        int left1 = 0, left2 = 0, right = 0;\n        int sum1 = 0, sum2 = 0;\n        int ret = 0;\n        while (right < n) {\n            sum1 += nums[right];\n            while (left1 <= right && sum1 > goal) {\n                sum1 -= nums[left1];\n                left1++;\n            }\n            sum2 += nums[right];\n            while (left2 <= right && sum2 >= goal) {\n                sum2 -= nums[left2];\n                left2++;\n            }\n            ret += left2 - left1;\n            right++;\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int NumSubarraysWithSum(int[] nums, int goal) {\n        int n = nums.Length;\n        int left1 = 0, left2 = 0, right = 0;\n        int sum1 = 0, sum2 = 0;\n        int ret = 0;\n        while (right < n) {\n            sum1 += nums[right];\n            while (left1 <= right && sum1 > goal) {\n                sum1 -= nums[left1];\n                left1++;\n            }\n            sum2 += nums[right];\n            while (left2 <= right && sum2 >= goal) {\n                sum2 -= nums[left2];\n                left2++;\n            }\n            ret += left2 - left1;\n            right++;\n        }\n        return ret;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc numSubarraysWithSum(nums []int, goal int) (ans int) {\n    left1, left2 := 0, 0\n    sum1, sum2 := 0, 0\n    for right, num := range nums {\n        sum1 += num\n        for left1 <= right && sum1 > goal {\n            sum1 -= nums[left1]\n            left1++\n        }\n        sum2 += num\n        for left2 <= right && sum2 >= goal {\n            sum2 -= nums[left2]\n            left2++\n        }\n        ans += left2 - left1\n    }\n    return\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar numSubarraysWithSum = function(nums, goal) {\n    const n = nums.length;\n    let left1 = 0, left2 = 0, right = 0;\n    let sum1 = 0, sum2 = 0;\n    let ret = 0;\n    while (right < n) {\n        sum1 += nums[right];\n        while (left1 <= right && sum1 > goal) {\n            sum1 -= nums[left1];\n            left1++;\n        }\n        sum2 += nums[right];\n        while (left2 <= right && sum2 >= goal) {\n            sum2 -= nums[left2];\n            left2++;\n        }\n        ret += left2 - left1;\n        right++;\n    }\n    return ret;\n};\n```\n\n```C [sol2-C]\nint numSubarraysWithSum(int* nums, int numsSize, int goal) {\n    int left1 = 0, left2 = 0, right = 0;\n    int sum1 = 0, sum2 = 0;\n    int ret = 0;\n    while (right < numsSize) {\n        sum1 += nums[right];\n        while (left1 <= right && sum1 > goal) {\n            sum1 -= nums[left1];\n            left1++;\n        }\n        sum2 += nums[right];\n        while (left2 <= right && sum2 >= goal) {\n            sum2 -= nums[left2];\n            left2++;\n        }\n        ret += left2 - left1;\n        right++;\n    }\n    return ret;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为给定数组的长度。我们至多只需要遍历一次该数组。\n\n- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。"
}