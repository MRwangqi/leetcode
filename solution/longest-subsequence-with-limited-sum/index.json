{
	"titleSlug": "longest-subsequence-with-limited-sum",
	"slug": "by-may-hanjing-xhlm",
	"url": "https://leetcode-cn.com/problems/longest-subsequence-with-limited-sum/solution/by-may-hanjing-xhlm/",
	"content": "![image.png](https://pic.leetcode-cn.com/1665739309-mNvLFB-image.png)\n\n 先对数组进行排序，形成一个前缀和，然后就变成了找最小的一个比目标值的过程\n\n\n### 代码\n\n```Java []\nclass Solution {\n    public int[] answerQueries(int[] nums, int[] queries) {\n     int len = nums.length;\n     Arrays.sort(nums);\n     \n     for(int i = 1;i<len;i++){\n         nums[i] = nums[i-1]+nums[i];\n     }\n     int[] res = new int[queries.length];\n     for(int i = 0;i<queries.length;i++){\n         int target = queries[i];\n         int left = 0;\n         int right = len-1;\n         int index = -1;\n         while(left<=right){\n             int mid = (right-left)/2+left;\n             if(nums[mid]<=target){\n                 index = mid;\n                  left = mid + 1;\n                 \n                  }else if(nums[mid]>target){\n                       right = mid - 1;\n                  }\n         }\n         queries[i] = index+1;\n     }\n     return queries;\n    }\n}\n```\n```Golang []\nfunc answerQueries(nums []int, queries []int) []int {\n\tsort.Ints(nums)\n\tn := len(nums)\n\tfor i := 1; i < n; i++ {\n\t\tnums[i] = nums[i]+nums[i-1]\n\t}\n\tfor i := 0; i < len(queries); i++ {\n\t\ttemp := queries[i]\n\t\tleft := 0\n\t\trigh := n - 1\n\t\tindex := -1\n\t\tfor left <= righ {\n\t\t\tmid := (righ-left)/2 + left\n\t\t\tif nums[mid] <= temp {\n\t\t\t\tindex = mid\n\t\t\t\tleft = mid + 1\n\t\t\t} else {\n\t\t\t\trigh = mid - 1\n\t\t\t}\n\t\t}\n\t\tqueries[i] = index + 1\n\t}\n\treturn queries\n}\n```\n```JavaScript []\nvar answerQueries = function(nums, queries) {\n    let len = nums.length;\n    nums.sort((a,b)=>{\n        return a-b;\n    });\n    for (let i = 1; i < len; i++) {\n        nums[i] = nums[i]+nums[i-1];\n    }\n    for (let i = 0; i < queries.length; i++) {\n        let target = queries[i];\n        let left = 0;\n        let right = len-1;\n        let index = -1;\n        while (left<=right){\n            let mid = Math.floor((right-left)/2)+left;\n            if(nums[mid]<=target){\n                index = mid;\n                left = mid + 1;\n            }else{\n                right = mid-1;\n            }\n        }\n        queries[i] = index+1;\n    }\n    return queries;\n};\n```\n"
}