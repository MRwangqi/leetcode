{
	"titleSlug": "minimum-add-to-make-parentheses-valid",
	"slug": "shi-gua-hao-you-xiao-de-zui-shao-tian-ji-gcxu",
	"url": "https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/solution/shi-gua-hao-you-xiao-de-zui-shao-tian-ji-gcxu/",
	"content": "#### 方法一：贪心\n\n这道题是括号匹配的题目。每个左括号必须对应一个右括号，而且左括号必须在对应的右括号之前。\n\n对于括号匹配的题目，常用的做法是使用栈进行匹配，栈具有后进先出的特点，因此可以保证右括号和最近的左括号进行匹配。其实，这道题可以使用计数代替栈，进行匹配时每次都取距离当前位置最近的括号，就可以确保平衡。\n\n从左到右遍历字符串，在遍历过程中维护左括号的个数以及添加次数。\n\n如果遇到左括号，则将左括号的个数加 $1$。\n\n如果遇到右括号，则需要和前面的左括号进行匹配，具体做法如下：\n\n- 如果左括号的个数大于 $0$，则前面有左括号可以匹配，因此将左括号的个数减 $1$，表示有一个左括号和当前右括号匹配；\n\n- 如果左括号的个数等于 $0$，则前面没有左括号可以匹配，需要添加一个左括号才能匹配，因此将添加次数加 $1$。\n\n遍历结束后，需要检查左括号的个数是否为 $0$。如果不为 $0$，则说明还有剩下的左括号没有匹配，对于每个剩下的左括号都需要添加一个右括号才能匹配，此时需要添加的右括号个数为剩下的左括号个数，将需要添加的右括号个数加到添加次数。\n\n无论是哪种添加的情况，都是在遇到括号无法进行匹配的情况下才进行添加，因此上述做法得到的添加次数是最少的。\n\n```Python [sol1-Python3]\nclass Solution:\n    def minAddToMakeValid(self, s: str) -> int:\n        ans = cnt = 0\n        for c in s:\n            if c == '(':\n                cnt += 1\n            elif cnt > 0:\n                cnt -= 1\n            else:\n                ans += 1\n        return ans + cnt\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minAddToMakeValid(String s) {\n        int ans = 0;\n        int leftCount = 0;\n        int length = s.length();\n        for (int i = 0; i < length; i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                leftCount++;\n            } else {\n                if (leftCount > 0) {\n                    leftCount--;\n                } else {\n                    ans++;\n                }\n            }\n        }\n        ans += leftCount;\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinAddToMakeValid(string s) {\n        int ans = 0;\n        int leftCount = 0;\n        int length = s.Length;\n        for (int i = 0; i < length; i++) {\n            char c = s[i];\n            if (c == '(') {\n                leftCount++;\n            } else {\n                if (leftCount > 0) {\n                    leftCount--;\n                } else {\n                    ans++;\n                }\n            }\n        }\n        ans += leftCount;\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minAddToMakeValid(string s) {\n        int ans = 0;\n        int leftCount = 0;\n        for (auto &c : s) {\n            if (c == '(') {\n                leftCount++;\n            } else {\n                if (leftCount > 0) {\n                    leftCount--;\n                } else {\n                    ans++;\n                }\n            }\n        }\n        ans += leftCount;\n        return ans;\n    }\n};\n```\n\n```C [sol1-C]\nint minAddToMakeValid(char * s){\n    int ans = 0;\n    int leftCount = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        char c = s[i];\n        if (c == '(') {\n            leftCount++;\n        } else {\n            if (leftCount > 0) {\n                leftCount--;\n            } else {\n                ans++;\n            }\n        }\n    }\n    ans += leftCount;\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minAddToMakeValid = function(s) {\n    let ans = 0;\n    let leftCount = 0;\n    let length = s.length;\n    for (let i = 0; i < length; i++) {\n        const c = s[i];\n        if (c === '(') {\n            leftCount++;\n        } else {\n            if (leftCount > 0) {\n                leftCount--;\n            } else {\n                ans++;\n            }\n        }\n    }\n    ans += leftCount;\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc minAddToMakeValid(s string) (ans int) {\n    cnt := 0\n    for _, c := range s {\n        if c == '(' {\n            cnt++\n        } else if cnt > 0 {\n            cnt--\n        } else {\n            ans++\n        }\n    }\n    return ans + cnt\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串的长度。遍历字符串一次。\n\n- 空间复杂度：$O(1)$。只需要维护常量的额外空间。"
}