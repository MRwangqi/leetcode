{
	"titleSlug": "maximum-performance-of-a-team",
	"slug": "zui-da-de-tuan-dui-biao-xian-zhi-by-leetcode-solut",
	"url": "https://leetcode-cn.com/problems/maximum-performance-of-a-team/solution/zui-da-de-tuan-dui-biao-xian-zhi-by-leetcode-solut/",
	"content": "#### 方法一：堆\n\n**思路**\n\n题目要求我们最优化「速度和」和「效率最小值」的乘积。变化的量有两个，一个是「速度」，一个是「效率」，这看起来有些棘手。我们不妨采用「动一个，定一个」的策略——即我们可以枚举效率的最小值 $e_{\\min}$，在所有效率大于 $e_{\\min}$ 的工程师中选取不超过 $k - 1$ 个，让他们的速度和最大。\n\n**思考：为什么是 $k - 1$ 个而不是 $k$ 个？** 因为最小值 $e_{\\min}$ 代表的工程师是必选，加起来一共 $k$ 个，所以剩下只要选 $k - 1$ 个。 \n\n**思考：如何满足速度和最大？** 因为 `speed[i] > 0`，所以只需要选效率大于 $e_{\\min}$ 中速度最大的 $k - 1$ 个，如果效率大于 $e_{\\min}$ 的元素小于 $k - 1$，就全取。\n\n具体地，我们可以对工程师先按照「效率」从高到低的规则排序，然后从前往后枚举这个序列中的元素作为 $e_{\\min}$，这样可以保证前面的元素的效率都比当前这个工程师高，然后维护一个以「速度」为关键字的小根堆，存放前面已经枚举过的元素中速度前 $k - 1$ 大的，动态维护这个堆的速度和，一轮枚举后，我们可以得到乘积最大值。\n\n**思考：为什么是小根堆？** 因为我们要动态维护前 $k - 1$ 大的元素，当堆内的元素超过 $k - 1$ 的时候，我们可以从堆顶 `pop` 掉比较小的元素，保证最大的 $k - 1$ 个元素还在堆中。\n\n代码实现如下。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    using LL = long long;\n\n    struct Staff {\n        int s, e;\n        bool operator < (const Staff& rhs) const {\n            return s > rhs.s;\n        }\n    };\n\n    int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {\n        vector<Staff> v;\n        priority_queue<Staff> q;\n        for (int i = 0; i < n; ++i) {\n            v.push_back({speed[i], efficiency[i]});\n        }\n        sort(v.begin(), v.end(), [] (const Staff& u, const Staff& v) { return u.e > v.e; });\n        LL ans = 0, sum = 0;\n        for (int i = 0; i < n; ++i) {\n            LL minE = v[i].e;\n            LL sumS = sum + v[i].s;\n            ans = max(ans, sumS * minE);\n            q.push(v[i]); \n            sum += v[i].s;\n            if (q.size() == k) {\n                sum -= q.top().s;\n                q.pop();\n            }\n        }\n        return ans % (int(1E9) + 7);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    class Staff {\n        int s, e;\n\n        public Staff(int s, int e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {\n        final int MODULO = 1000000007;\n        List<Staff> list = new ArrayList<Staff>();\n        PriorityQueue<Staff> queue = new PriorityQueue<Staff>(new Comparator<Staff>() {\n            public int compare(Staff staff1, Staff staff2) {\n                return staff1.s - staff2.s;\n            }\n        });\n        for (int i = 0; i < n; ++i) {\n            list.add(new Staff(speed[i], efficiency[i]));\n        }\n        Collections.sort(list, new Comparator<Staff>() {\n            public int compare(Staff staff1, Staff staff2) {\n                return staff2.e - staff1.e;\n            }\n        });\n        long ans = 0, sum = 0;\n        for (int i = 0; i < n; ++i) {\n            Staff staff = list.get(i);\n            long minE = staff.e;\n            long sumS = sum + staff.s;\n            ans = Math.max(ans, sumS * minE);\n            queue.offer(staff); \n            sum += staff.s;\n            if (queue.size() == k) {\n                sum -= queue.poll().s;\n            }\n        }\n        return (int) (ans % MODULO);\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    class Staff:\n        def __init__(self, s, e):\n            self.s = s\n            self.e = e\n        \n        def __lt__(self, that):\n            return self.s < that.s\n        \n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        v = list()\n        for i in range(n):\n            v.append(Solution.Staff(speed[i], efficiency[i]))\n        v.sort(key=lambda x: -x.e)\n\n        q = list()\n        ans, total = 0, 0\n        for i in range(n):\n            minE, totalS = v[i].e, total + v[i].s\n            ans = max(ans, minE * totalS)\n            heapq.heappush(q, v[i])\n            total += v[i].s\n            if len(q) == k:\n                item = heapq.heappop(q)\n                total -= item.s\n        return ans % (10**9 + 7)\n```\n\n**复杂度分析**\n\n- 时间复杂度：排序的时间代价为 $O(n \\log n)$，后面的操作中每个元素进出堆的次数最多一次，所以总的时间代价是 $O(n \\log n)$。故渐进时间复杂度为 $O(n \\log n)$。\n\n- 空间复杂度：这里用了堆和一个辅助数组存放工程师信息，故渐进空间复杂度为 $O(n)$。"
}