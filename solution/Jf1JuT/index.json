{
	"titleSlug": "Jf1JuT",
	"slug": "wai-xing-wen-zi-dian-by-leetcode-solutio-to66",
	"url": "https://leetcode-cn.com/problems/Jf1JuT/solution/wai-xing-wen-zi-dian-by-leetcode-solutio-to66/",
	"content": "#### 前言\n\n这道题是拓扑排序问题。外星文字典中的字母和字母顺序可以看成有向图，字典顺序即为所有字母的一种排列，满足每一条有向边的起点字母和终点字母的顺序都和这两个字母在排列中的顺序相同，该排列即为有向图的拓扑排序。\n\n只有当有向图中无环时，才有拓扑排序，且拓扑排序可能不止一种。如果有向图中有环，则环内的字母不存在符合要求的排列，因此没有拓扑排序。\n\n使用拓扑排序求解时，将外星文字典中的每个字母看成一个节点，将字母之间的顺序关系看成有向边。对于外星文字典中的两个相邻单词，同时从左到右遍历，当遇到第一个不相同的字母时，该位置的两个字母之间即存在顺序关系。\n\n以下两种情况不存在合法字母顺序：\n\n- 字母之间的顺序关系存在由至少 $2$ 个字母组成的环，例如 $\\textit{words} = [\\text{``a\"}, \\text{``b\"}, \\text{``a\"}]$；\n\n- 相邻两个单词满足后面的单词是前面的单词的前缀，且后面的单词的长度小于前面的单词的长度，例如 $\\textit{words} = [\\text{``ab\"}, \\text{``a\"}]$。\n\n其余情况下都存在合法字母顺序，可以使用拓扑排序得到字典顺序。\n\n拓扑排序可以使用深度优先搜索或广度优先搜索实现，以下分别介绍两种实现方法。\n\n#### 方法一：拓扑排序 + 深度优先搜索\n\n使用深度优先搜索实现拓扑排序的总体思想是：对于一个特定节点，如果该节点的所有相邻节点都已经搜索完成，则该节点也会变成已经搜索完成的节点，在拓扑排序中，该节点位于其所有相邻节点的前面。一个节点的相邻节点指的是从该节点出发通过一条有向边可以到达的节点。\n\n由于拓扑排序的顺序和搜索完成的顺序相反，因此需要使用一个栈存储所有已经搜索完成的节点。深度优先搜索的过程中需要维护每个节点的状态，每个节点的状态可能有三种情况：「未访问」、「访问中」和「已访问」。初始时，所有节点的状态都是「未访问」。\n\n每一轮搜索时，任意选取一个「未访问」的节点 $u$，从节点 $u$ 开始深度优先搜索。将节点 $u$ 的状态更新为「访问中」，对于每个与节点 $u$ 相邻的节点 $v$，判断节点 $v$ 的状态，执行如下操作：\n\n- 如果节点 $v$ 的状态是「未访问」，则继续搜索节点 $v$；\n\n- 如果节点 $v$ 的状态是「访问中」，则找到有向图中的环，因此不存在拓扑排序；\n\n- 如果节点 $v$ 的状态是「已访问」，则节点 $v$ 已经搜索完成并入栈，节点 $u$ 尚未入栈，因此节点 $u$ 的拓扑顺序一定在节点 $v$ 的前面，不需要执行任何操作。\n\n当节点 $u$ 的所有相邻节点的状态都是「已访问」时，将节点 $u$ 的状态更新为「已访问」，并将节点 $u$ 入栈。\n\n当所有节点都访问结束之后，如果没有找到有向图中的环，则存在拓扑排序，所有节点从栈顶到栈底的顺序即为拓扑排序。\n\n实现方面，由于每个节点是一个字母，因此可以使用字符数组代替栈，当节点入栈时，在字符数组中按照从后往前的顺序依次填入每个字母。当所有节点都访问结束之后，将字符数组转成字符串，即为字典顺序。\n\n<![ppt0](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/0.PNG),![ppt1](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/1.PNG),![ppt2](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/2.PNG),![ppt3](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/3.PNG),![ppt4](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/4.PNG),![ppt5](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/5.PNG),![ppt6](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/6.PNG),![ppt7](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/7.PNG),![ppt8](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/8.PNG),![ppt9](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/9.PNG),![ppt10](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/10.PNG)>\n\n```Python [sol1-Python3]\nclass Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        g = {}\n        for c in words[0]:\n            g[c] = []\n        for s, t in pairwise(words):\n            for c in t:\n                g.setdefault(c, [])\n            for u, v in zip(s, t):\n                if u != v:\n                    g[u].append(v)\n                    break\n            else:\n                if len(s) > len(t):\n                    return \"\"\n\n        VISITING, VISITED = 1, 2\n        states = {}\n        order = []\n        def dfs(u: str) -> bool:\n            states[u] = VISITING\n            for v in g[u]:\n                if v not in states:\n                    if not dfs(v):\n                        return False\n                elif states[v] == VISITING:\n                    return False\n            order.append(u)\n            states[u] = VISITED\n            return True\n\n        return ''.join(reversed(order)) if all(dfs(u) for u in g if u not in states) else \"\"\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static final int VISITING = 1, VISITED = 2;\n    Map<Character, List<Character>> edges = new HashMap<Character, List<Character>>();\n    Map<Character, Integer> states = new HashMap<Character, Integer>();\n    boolean valid = true;\n    char[] order;\n    int index;\n\n    public String alienOrder(String[] words) {\n        int length = words.length;\n        for (String word : words) {\n            int wordLength = word.length();\n            for (int j = 0; j < wordLength; j++) {\n                char c = word.charAt(j);\n                edges.putIfAbsent(c, new ArrayList<Character>());\n            }\n        }\n        for (int i = 1; i < length && valid; i++) {\n            addEdge(words[i - 1], words[i]);\n        }\n        order = new char[edges.size()];\n        index = edges.size() - 1;\n        Set<Character> letterSet = edges.keySet();\n        for (char u : letterSet) {\n            if (!states.containsKey(u)) {\n                dfs(u);\n            }\n        }\n        if (!valid) {\n            return \"\";\n        }\n        return new String(order);\n    }\n\n    public void addEdge(String before, String after) {\n        int length1 = before.length(), length2 = after.length();\n        int length = Math.min(length1, length2);\n        int index = 0;\n        while (index < length) {\n            char c1 = before.charAt(index), c2 = after.charAt(index);\n            if (c1 != c2) {\n                edges.get(c1).add(c2);\n                break;\n            }\n            index++;\n        }\n        if (index == length && length1 > length2) {\n            valid = false;\n        }\n    }\n\n    public void dfs(char u) {\n        states.put(u, VISITING);\n        List<Character> adjacent = edges.get(u);\n        for (char v : adjacent) {\n            if (!states.containsKey(v)) {\n                dfs(v);\n                if (!valid) {\n                    return;\n                }\n            } else if (states.get(v) == VISITING) {\n                valid = false;\n                return;\n            }\n        }\n        states.put(u, VISITED);\n        order[index] = u;\n        index--;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    const int VISITING = 1, VISITED = 2;\n    Dictionary<char, IList<char>> edges = new Dictionary<char, IList<char>>();\n    Dictionary<char, int> states = new Dictionary<char, int>();\n    bool valid = true;\n    char[] order;\n    int index;\n\n    public string AlienOrder(string[] words) {\n        int length = words.Length;\n        foreach (string word in words) {\n            foreach (char c in word) {\n                if (!edges.ContainsKey(c)) {\n                    edges.Add(c, new List<char>());\n                }\n            }\n        }\n        for (int i = 1; i < length && valid; i++) {\n            AddEdge(words[i - 1], words[i]);\n        }\n        order = new char[edges.Count];\n        index = edges.Count - 1;\n        Dictionary<char, IList<char>>.KeyCollection letterSet = edges.Keys;\n        foreach (char u in letterSet) {\n            if (!states.ContainsKey(u)) {\n                DFS(u);\n            }\n        }\n        if (!valid) {\n            return \"\";\n        }\n        return new string(order);\n    }\n\n    public void AddEdge(string before, string after) {\n        int length1 = before.Length, length2 = after.Length;\n        int length = Math.Min(length1, length2);\n        int index = 0;\n        while (index < length) {\n            char c1 = before[index], c2 = after[index];\n            if (c1 != c2) {\n                edges[c1].Add(c2);\n                break;\n            }\n            index++;\n        }\n        if (index == length && length1 > length2) {\n            valid = false;\n        }\n    }\n\n    public void DFS(char u) {\n        states.Add(u, VISITING);\n        IList<char> adjacent = edges[u];\n        foreach (char v in adjacent) {\n            if (!states.ContainsKey(v)) {\n                DFS(v);\n                if (!valid) {\n                    return;\n                }\n            } else if (states[v] == VISITING) {\n                valid = false;\n                return;\n            }\n        }\n        states[u] = VISITED;\n        order[index] = u;\n        index--;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    const int VISITING = 1, VISITED = 2;\n    unordered_map<char, vector<char>> edges;\n    unordered_map<char, int> states;\n    bool valid = true;\n    string order;\n    int index;\n\n    string alienOrder(vector<string>& words) {\n        int length = words.size();\n        for (string & word : words) {\n            int wordLength = word.size();\n            for (int j = 0; j < wordLength; j++) {\n                char c = word[j];\n                if (!edges.count(c)) {\n                    edges[c] = vector<char>();\n                }\n            }\n        }\n        for (int i = 1; i < length && valid; i++) {\n            addEdge(words[i - 1], words[i]);\n        }\n        order = string(edges.size(), ' ');\n        index = edges.size() - 1;\n        for (auto [u, _] : edges) {\n            if (!states.count(u)) {\n                dfs(u);\n            }\n        }\n        if (!valid) {\n            return \"\";\n        }\n        return order;\n    }\n\n    void addEdge(string before, string after) {\n        int length1 = before.size(), length2 = after.size();\n        int length = min(length1, length2);\n        int index = 0;\n        while (index < length) {\n            char c1 = before[index], c2 = after[index];\n            if (c1 != c2) {\n                edges[c1].emplace_back(c2);\n                break;\n            }\n            index++;\n        }\n        if (index == length && length1 > length2) {\n            valid = false;\n        }\n    }\n\n    void dfs(char u) {\n        states[u] = VISITING;\n        for (char v : edges[u]) {\n            if (!states.count(v)) {\n                dfs(v);\n                if (!valid) {\n                    return;\n                }\n            } else if (states[v] == VISITING) {\n                valid = false;\n                return;\n            }\n        }\n        states[u] = VISITED;\n        order[index] = u;\n        index--;\n    }\n};\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define VISITING 1\n#define VISITED 2\n\nvoid addEdge(const char *before, const char *after, int **edges, bool *valid) {\n    int length1 = strlen(before), length2 = strlen(after);\n    int length = MIN(length1, length2);\n    int index = 0;\n    while (index < length) {\n        char c1 = before[index], c2 = after[index];\n        if (c1 != c2) {\n            edges[c1 - 'a'][c2 - 'a'] = 1;\n            break;\n        }\n        index++;\n    }\n    if (index == length && length1 > length2) {\n        *valid = false;\n    }\n}\n\nvoid dfs(int u, char *order, int *index, int **edges, int *states, bool *valid) {\n    states[u] = VISITING;\n    if (edges[u]) {\n        for (int i = 0; i < 26; i++) {\n            if (edges[u][i]) {\n                if (!states[i]) {\n                    dfs(i, order, index, edges, states, valid);\n                    if (!valid) {\n                        return;\n                    }\n                } else if (states[i] == VISITING) {\n                    *valid = false;\n                    return;\n                }\n            }\n        }\n    }\n    states[u] = VISITED;\n    order[*index] = 'a' + u;\n    (*index)--;\n}\n\nchar * alienOrder(char ** words, int wordsSize) {\n    int edgesSize = 0;\n    int *edges[26];\n    int states[26];\n    bool valid = true;\n    for (int i = 0; i < 26; i++) {\n        edges[i] = NULL;\n    }\n    memset(states, 0, sizeof(states));\n    for (int i = 0; i < wordsSize; i++) {\n        int wordLength = strlen(words[i]);\n        for (int j = 0; j < wordLength; j++) {\n            char c = words[i][j];\n            if (!edges[c - 'a']) {\n                edges[c - 'a'] = (int *)malloc(sizeof(int) * 26);\n                memset(edges[c - 'a'], 0, sizeof(int) * 26);\n                edgesSize++;\n            }\n        }\n    }\n    for (int i = 1; i < wordsSize && valid; i++) {\n        addEdge(words[i - 1], words[i], edges, &valid);\n    }\n    char *order = (char *)malloc(sizeof(char) * (edgesSize + 1));\n    memset(order, ' ', sizeof(char) * edgesSize);\n    order[edgesSize] = '\\0';\n    int index = edgesSize - 1;\n    for (int i = 0; i < 26; i++) {\n        if (edges[i] && !states[i]) {\n            dfs(i, order, &index, edges, states, &valid);\n        }\n    }\n    for (int i = 0; i < 26; i++) {\n        if (edges[i]) {\n            free(edges[i]);\n        }\n    }\n    if (!valid) {\n        order[0] = '\\0';\n    }\n    return order;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar alienOrder = function(words) {\n    const VISITING = 1, VISITED = 2;\n    let valid = true;\n    const edges = new Map();\n    const states = new Map();\n    const length = words.length;\n    for (const word of words) {\n        const wordLength = word.length;\n        for (let j = 0; j < wordLength; j++) {\n            const c = word[j];\n            if (!edges.has(c)) {\n                edges.set(c, []);\n            }\n        }\n    }\n\n    const addEdge = (before, after) => {\n        const length1 = before.length, length2 = after.length;\n        const length = Math.min(length1, length2);\n        let index = 0;\n        while (index < length) {\n            const c1 = before[index], c2 = after[index];\n            if (c1 !== c2) {\n                edges.get(c1).push(c2);\n                break;\n            }\n            index++;\n        }\n        if (index === length && length1 > length2) {\n            valid = false;\n        }\n    }\n\n    const dfs = (u) => {\n        states.set(u, VISITING);\n        const adjacent = edges.get(u);\n        for (const v of adjacent) {\n            if (!states.has(v)) {\n                dfs(v);\n                if (!valid) {\n                    return;\n                }\n            } else if (states.get(v) === VISITING) {\n                valid = false;\n                return;\n            }\n        }\n        states.set(u, VISITED);\n        order[index] = u;\n        index--;\n    }\n\n    for (let i = 1; i < length && valid; i++) {\n        addEdge(words[i - 1], words[i]);\n    }\n    const order = new Array(edges.size).fill(0);\n    let index = edges.size - 1;\n    const letterSet = edges.keys();\n    for (const u of letterSet) {\n        if (!states.has(u)) {\n            dfs(u);\n        }\n    }\n    if (!valid) {\n        return \"\";\n    }\n    return order.join('');\n\n    \n};\n```\n\n```go [sol1-Golang]\nfunc alienOrder(words []string) string {\n    g := map[byte][]byte{}\n    for _, c := range words[0] {\n        g[byte(c)] = nil\n    }\nnext:\n    for i := 1; i < len(words); i++ {\n        s, t := words[i-1], words[i]\n        for _, c := range t {\n            g[byte(c)] = g[byte(c)]\n        }\n        for j := 0; j < len(s) && j < len(t); j++ {\n            if s[j] != t[j] {\n                g[s[j]] = append(g[s[j]], t[j])\n                continue next\n            }\n        }\n        if len(s) > len(t) {\n            return \"\"\n        }\n    }\n\n    const visiting, visited = 1, 2\n    order := make([]byte, len(g))\n    i := len(g) - 1\n    state := map[byte]int{}\n    var dfs func(u byte) bool\n    dfs = func(u byte) bool {\n        state[u] = visiting\n        for _, v := range g[u] {\n            if state[v] == 0 {\n                if !dfs(v) {\n                    return false\n                }\n            } else if state[v] == visiting {\n                return false\n            }\n        }\n        order[i] = u\n        i--\n        state[u] = visited\n        return true\n    }\n    for u := range g {\n        if state[u] == 0 && !dfs(u) {\n            return \"\"\n        }\n    }\n    return string(order)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times L + |\\Sigma|)$，其中 $n$ 是数组 $\\textit{words}$ 的长度，即字典中的单词数，$L$ 是字典中的平均单词长度，$\\Sigma$ 是字典中的字母集合。遍历字典构造有向图需要 $O(n \\times L)$ 的时间，由于有向图包含最多 $n - 1$ 条边和 $|\\Sigma|$ 个节点，因此深度优先搜索需要 $O(n + |\\Sigma|)$ 的时间，总时间复杂度是 $O(n \\times L + n + |\\Sigma|) = O(n \\times L + |\\Sigma|)$。\n\n- 空间复杂度：$O(n + |\\Sigma|)$，其中 $n$ 是数组 $\\textit{words}$ 的长度，即字典中的单词数，$\\Sigma$ 是字典中的字母集合。空间复杂度主要取决于存储有向图需要的空间，有向图包含最多 $n - 1$ 条边和 $|\\Sigma|$ 个节点。\n\n#### 方法二：拓扑排序 + 广度优先搜索\n\n方法一使用深度优先搜索实现拓扑排序，根据每个节点搜索完成的顺序反向得到拓扑排序。使用广度优先搜索实现拓扑排序，则可以正向得到拓扑排序。\n\n首先计算每个节点的入度，只有入度为 $0$ 的节点可能是拓扑排序中最前面的节点。当一个节点加入拓扑排序之后，该节点的所有相邻节点的入度都减 $1$，表示相邻节点少了一条入边。当一个节点的入度变成 $0$，则该节点前面的节点都已经加入拓扑排序，该节点也可以加入拓扑排序。\n\n具体做法是，使用队列存储可以加入拓扑排序的节点，初始时将所有入度为 $0$ 的节点入队列。每次将一个节点出队列并加入拓扑排序中，然后将该节点的所有相邻节点的入度都减 $1$，如果一个相邻节点的入度变成 $0$，则将该相邻节点入队列。重复上述操作，直到队列为空时，广度优先搜索结束。\n\n如果有向图中无环，则每个节点都将加入拓扑排序，因此拓扑排序的长度等于字典中的字母个数。如果有向图中有环，则环中的节点不会加入拓扑排序，因此拓扑排序的长度小于字典中的字母个数。广度优先搜索结束时，判断拓扑排序的长度是否等于字典中的字母个数，即可判断有向图中是否有环。\n\n- 如果拓扑排序的长度等于字典中的字母个数，则拓扑排序包含字典中的所有字母，返回拓扑排序；\n\n- 如果拓扑排序的长度小于字典中的字母个数，则有向图中有环，不存在拓扑排序。\n\n<![p1](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p1.PNG),![p2](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p2.PNG),![p3](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p3.PNG),![p4](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p4.PNG),![p5](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p5.PNG),![p6](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p6.PNG),![p7](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p7.PNG),![p8](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p8.PNG),![p9](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p9.PNG),![p10](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p10.PNG),![p11](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p11.PNG),![p12](https://assets.leetcode-cn.com/solution-static/jianzhi_II_114/p12.PNG)>\n\n```Python [sol2-Python3]\nclass Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        g = defaultdict(list)\n        inDeg = {c: 0 for c in words[0]}\n        for s, t in pairwise(words):\n            for c in t:\n                inDeg.setdefault(c, 0)\n            for u, v in zip(s, t):\n                if u != v:\n                    g[u].append(v)\n                    inDeg[v] += 1\n                    break\n            else:\n                if len(s) > len(t):\n                    return \"\"\n\n        q = [u for u, d in inDeg.items() if d == 0]\n        for u in q:\n            for v in g[u]:\n                inDeg[v] -= 1\n                if inDeg[v] == 0:\n                    q.append(v)\n        return ''.join(q) if len(q) == len(inDeg) else \"\"\n```\n\n```Java [sol2-Java]\nclass Solution {\n    Map<Character, List<Character>> edges = new HashMap<Character, List<Character>>();\n    Map<Character, Integer> indegrees = new HashMap<Character, Integer>();\n    boolean valid = true;\n\n    public String alienOrder(String[] words) {\n        int length = words.length;\n        for (String word : words) {\n            int wordLength = word.length();\n            for (int j = 0; j < wordLength; j++) {\n                char c = word.charAt(j);\n                edges.putIfAbsent(c, new ArrayList<Character>());\n            }\n        }\n        for (int i = 1; i < length && valid; i++) {\n            addEdge(words[i - 1], words[i]);\n        }\n        if (!valid) {\n            return \"\";\n        }\n        Queue<Character> queue = new ArrayDeque<Character>();\n        Set<Character> letterSet = edges.keySet();\n        for (char u : letterSet) {\n            if (!indegrees.containsKey(u)) {\n                queue.offer(u);\n            }\n        }\n        StringBuffer order = new StringBuffer();\n        while (!queue.isEmpty()) {\n            char u = queue.poll();\n            order.append(u);\n            List<Character> adjacent = edges.get(u);\n            for (char v : adjacent) {\n                indegrees.put(v, indegrees.get(v) - 1);\n                if (indegrees.get(v) == 0) {\n                    queue.offer(v);\n                }\n            }\n        }\n        return order.length() == edges.size() ? order.toString() : \"\";\n    }\n\n    public void addEdge(String before, String after) {\n        int length1 = before.length(), length2 = after.length();\n        int length = Math.min(length1, length2);\n        int index = 0;\n        while (index < length) {\n            char c1 = before.charAt(index), c2 = after.charAt(index);\n            if (c1 != c2) {\n                edges.get(c1).add(c2);\n                indegrees.put(c2, indegrees.getOrDefault(c2, 0) + 1);\n                break;\n            }\n            index++;\n        }\n        if (index == length && length1 > length2) {\n            valid = false;\n        }\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    Dictionary<char, IList<char>> edges = new Dictionary<char, IList<char>>();\n    Dictionary<char, int> indegrees = new Dictionary<char, int>();\n    bool valid = true;\n\n    public string AlienOrder(string[] words) {\n        int length = words.Length;\n        foreach (string word in words) {\n            foreach (char c in word) {\n                if (!edges.ContainsKey(c)) {\n                    edges.Add(c, new List<char>());\n                }\n            }\n        }\n        for (int i = 1; i < length && valid; i++) {\n            AddEdge(words[i - 1], words[i]);\n        }\n        if (!valid) {\n            return \"\";\n        }\n        Queue<char> queue = new Queue<char>();\n        Dictionary<char, IList<char>>.KeyCollection letterSet = edges.Keys;\n        foreach (char u in letterSet) {\n            if (!indegrees.ContainsKey(u)) {\n                queue.Enqueue(u);\n            }\n        }\n        StringBuilder order = new StringBuilder();\n        while (queue.Count > 0) {\n            char u = queue.Dequeue();\n            order.Append(u);\n            IList<char> adjacent = edges[u];\n            foreach (char v in adjacent) {\n                indegrees[v]--;\n                if (indegrees[v] == 0) {\n                    queue.Enqueue(v);\n                }\n            }\n        }\n        return order.Length == edges.Count ? order.ToString() : \"\";\n    }\n\n    public void AddEdge(string before, string after) {\n        int length1 = before.Length, length2 = after.Length;\n        int length = Math.Min(length1, length2);\n        int index = 0;\n        while (index < length) {\n            char c1 = before[index], c2 = after[index];\n            if (c1 != c2) {\n                edges[c1].Add(c2);\n                if (!indegrees.ContainsKey(c2)) {\n                    indegrees.Add(c2, 0);\n                }\n                indegrees[c2]++;\n                break;\n            }\n            index++;\n        }\n        if (index == length && length1 > length2) {\n            valid = false;\n        }\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    unordered_map<char, vector<char>> edges;\n    unordered_map<char, int> indegrees;\n    bool valid = true;\n\n    string alienOrder(vector<string>& words) {\n        int length = words.size();\n        for (auto word : words) {\n            int wordLength = word.size();\n            for (int j = 0; j < wordLength; j++) {\n                char c = word[j];\n                if (!edges.count(c)) {\n                    edges[c] = vector<char>();\n                }\n            }\n        }\n        for (int i = 1; i < length && valid; i++) {\n            addEdge(words[i - 1], words[i]);\n        }\n        if (!valid) {\n            return \"\";\n        }\n        queue<char> qu;\n        for (auto [u, _] : edges) {\n            if (!indegrees.count(u)) {\n                qu.emplace(u);\n            }\n        }\n        string order;\n        while (!qu.empty()) {\n            char u = qu.front();\n            qu.pop();\n            order.push_back(u);\n            for (char v : edges[u]) {\n                indegrees[v]--;\n                if (indegrees[v] == 0) {\n                    qu.emplace(v);\n                }\n            }\n        }\n        return order.size() == edges.size() ? order : \"\";\n    }\n\n    void addEdge(string before, string after) {\n        int length1 = before.size(), length2 = after.size();\n        int length = min(length1, length2);\n        int index = 0;\n        while (index < length) {\n            char c1 = before[index], c2 = after[index];\n            if (c1 != c2) {\n                edges[c1].emplace_back(c2);\n                indegrees[c2] += 1;\n                break;\n            }\n            index++;\n        }\n        if (index == length && length1 > length2) {\n            valid = false;\n        }\n    }\n};\n```\n\n```C [sol2-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nvoid addEdge(const char *before, const char *after, int **edges, int *indegrees, bool *valid) {\n    int length1 = strlen(before), length2 = strlen(after);\n    int length = MIN(length1, length2);\n    int index = 0;\n    while (index < length) {\n        char c1 = before[index], c2 = after[index];\n        if (c1 != c2 ) {\n            if (edges[c1 - 'a'][c2 - 'a'] == 0) {\n                edges[c1 - 'a'][c2 - 'a'] = 1;\n                indegrees[c2 - 'a']++;\n            }\n            break;\n        }\n        index++;\n    }\n    if (index == length && length1 > length2) {\n        *valid = false;\n    }\n}\n\nchar * alienOrder(char ** words, int wordsSize) {\n    int edgesSize = 0;\n    int *edges[26];\n    int indegrees[26];\n    bool valid = true;\n    memset(indegrees, 0, sizeof(indegrees));\n    for (int i = 0; i < 26; i++) {\n        edges[i] = NULL;\n    }\n    for (int i = 0; i < wordsSize; i++) {\n        int wordLength = strlen(words[i]);\n        for (int j = 0; j < wordLength; j++) {\n            char c = words[i][j];\n            if (!edges[c - 'a']) {\n                edges[c - 'a'] = (int *)malloc(sizeof(int) * 26);\n                memset(edges[c - 'a'], 0, sizeof(int) * 26);\n                edgesSize++;\n            }\n        }\n    }\n    for (int i = 1; i < wordsSize && valid; i++) {\n        addEdge(words[i - 1], words[i], edges, indegrees, &valid);\n    }\n    char *order = (char *)malloc(sizeof(char) * (edgesSize + 1));\n    order[edgesSize] = '\\0';\n    int * queue = (int *)malloc(sizeof(int) * 26);\n    int head = 0;\n    int tail = 0;\n    int pos = 0;\n    for (int i = 0; i < 26; i++) {\n        if (edges[i] && !indegrees[i]) {\n            queue[tail++] = i;\n        }\n    }\n    while (head != tail) {\n        int u = queue[head++];\n        order[pos++] = 'a' + u;\n        for (int i = 0; i < 26; i++) {\n            if (edges[u][i]) {\n                indegrees[i]--;\n                if (indegrees[i] == 0) {\n                    queue[tail++] = i;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 26; i++) {\n        if (edges[i]) {\n            free(edges[i]);\n        }\n    }\n    free(queue);\n    if (!valid || pos != edgesSize) {\n        order[0] = '\\0';\n    }\n    return order;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar alienOrder = function(words) {\n    let valid = true;\n    const edges = new Map();\n    const indegrees = new Map();\n    const length = words.length;\n    for (const word of words) {\n        const wordLength = word.length;\n        for (let j = 0; j < wordLength; j++) {\n            const c = word[j];\n            if (!edges.has(c)) {\n                edges.set(c, []);\n            }\n        }\n    }\n\n    const addEdge = (before, after) => {\n        const length1 = before.length, length2 = after.length;\n        const length = Math.min(length1, length2);\n        let index = 0;\n        while (index < length) {\n            const c1 = before[index], c2 = after[index];\n            if (c1 !== c2) {\n                edges.get(c1).push(c2);\n                indegrees.set(c2, (indegrees.get(c2) || 0) + 1);\n                break;\n            }\n            index++;\n        }\n        if (index === length && length1 > length2) {\n            valid = false;\n        }\n    }\n\n    for (let i = 1; i < length && valid; i++) {\n        addEdge(words[i - 1], words[i]);\n    }\n    if (!valid) {\n        return \"\";\n    }\n    const queue = [];\n    const letterSet = edges.keys();\n    for (const u of letterSet) {\n        if (!indegrees.has(u)) {\n            queue.push(u);\n        }\n    }\n    const order = [];\n    while (queue.length) {\n        const u = queue.shift();\n        order.push(u);\n        const adjacent = edges.get(u);\n        for (const v of adjacent) {\n            indegrees.set(v, indegrees.get(v) - 1);\n            if (indegrees.get(v) === 0) {\n                queue.push(v);\n            }\n        }\n    }\n    return order.length === edges.size ? order.join('') : \"\";\n};\n```\n\n```go [sol2-Golang]\nfunc alienOrder(words []string) string {\n    g := map[byte][]byte{}\n    inDeg := map[byte]int{}\n    for _, c := range words[0] {\n        inDeg[byte(c)] = 0\n    }\nnext:\n    for i := 1; i < len(words); i++ {\n        s, t := words[i-1], words[i]\n        for _, c := range t {\n            inDeg[byte(c)] += 0\n        }\n        for j := 0; j < len(s) && j < len(t); j++ {\n            if s[j] != t[j] {\n                g[s[j]] = append(g[s[j]], t[j])\n                inDeg[t[j]]++\n                continue next\n            }\n        }\n        if len(s) > len(t) {\n            return \"\"\n        }\n    }\n\n    order := make([]byte, len(inDeg))\n    q := order[:0]\n    for u, d := range inDeg {\n        if d == 0 {\n            q = append(q, u)\n        }\n    }\n    for len(q) > 0 {\n        u := q[0]\n        q = q[1:]\n        for _, v := range g[u] {\n            if inDeg[v]--; inDeg[v] == 0 {\n                q = append(q, v)\n            }\n        }\n    }\n    if cap(q) == 0 {\n        return string(order)\n    }\n    return \"\"\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times L + |\\Sigma|)$，其中 $n$ 是数组 $\\textit{words}$ 的长度，即字典中的单词数，$L$ 是字典中的平均单词长度，$\\Sigma$ 是字典中的字母集合。遍历字典构造有向图需要 $O(n \\times L)$ 的时间，由于有向图包含最多 $n - 1$ 条边和 $|\\Sigma|$ 个节点，因此广度优先搜索需要 $O(n + |\\Sigma|)$ 的时间，总时间复杂度是 $O(n \\times L + n + |\\Sigma|) = O(n \\times L + |\\Sigma|)$。\n\n- 空间复杂度：$O(n + |\\Sigma|)$，其中 $n$ 是数组 $\\textit{words}$ 的长度，即字典中的单词数，$\\Sigma$ 是字典中的字母集合。空间复杂度主要取决于存储有向图需要的空间，有向图包含最多 $n - 1$ 条边和 $|\\Sigma|$ 个节点。"
}