{
	"titleSlug": "reverse-prefix-of-word",
	"slug": "fan-zhuan-dan-ci-qian-zhui-by-leetcode-s-ruaj",
	"url": "https://leetcode-cn.com/problems/reverse-prefix-of-word/solution/fan-zhuan-dan-ci-qian-zhui-by-leetcode-s-ruaj/",
	"content": "#### 方法一：直接反转\n\n**思路与算法**\n\n首先查找 $\\textit{ch}$ 在字符串 $\\textit{word}$ 的位置，如果找到，则将字符串从下标 $0$ 开始，到查找到的 $\\textit{ch}$ 所在位置为止的那段字符串进行反转，否则直接返回原字符串。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def reversePrefix(self, word: str, ch: str) -> str:\n        i = word.find(ch) + 1\n        return word[:i][::-1] + word[i:]\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string reversePrefix(string word, char ch) {\n        int index = word.find(ch);\n        if (index != string::npos) {\n            reverse(word.begin(), word.begin() + index + 1);\n        }\n        return word;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String reversePrefix(String word, char ch) {\n        int index = word.indexOf(ch);\n        if (index >= 0) {\n            char[] arr = word.toCharArray();\n            int left = 0, right = index;\n            while (left < right) {\n                char temp = arr[left];\n                arr[left] = arr[right];\n                arr[right] = temp;\n                left++;\n                right--;\n            }\n            word = new String(arr);\n        }\n        return word;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string ReversePrefix(string word, char ch) {\n        int index = word.IndexOf(ch);\n        if (index >= 0) {\n            char[] arr = word.ToCharArray();\n            int left = 0, right = index;\n            while (left < right) {\n                char temp = arr[left];\n                arr[left] = arr[right];\n                arr[right] = temp;\n                left++;\n                right--;\n            }\n            word = new string(arr);\n        }\n        return word;\n    }\n}\n```\n\n```C [sol1-C]\nchar * reversePrefix(char * word, char ch){\n    char *p2 = strchr(word, ch);\n    if (p2 != NULL) {\n        char *p1 = word;\n        while (p1 < p2) {\n            char tmp = *p1;\n            *p1 = *p2;\n            *p2 = tmp;\n            p1++;\n            p2--;\n        }\n    }\n    return word;\n}\n```\n\n```go [sol1-Golang]\nfunc reversePrefix(word string, ch byte) string {\n    right := strings.IndexByte(word, ch)\n    if right < 0 {\n        return word\n    }\n    s := []byte(word)\n    for left := 0; left < right; left++ {\n        s[left], s[right] = s[right], s[left]\n        right--\n    }\n    return string(s)\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar reversePrefix = function(word, ch) {\n    const index = word.indexOf(ch);\n    if (index >= 0) {\n        const arr = [...word];\n        let left = 0, right = index;\n        while (left < right) {\n            const temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n        word = arr.join('');\n    }\n    return word;\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是字符串 $\\textit{word}$ 的长度。查找和反转都需要 $O(n)$。\n\n+ 空间复杂度：$O(1)$ 或 $O(n)$。取决于语言实现，对于字符串不可变的语言，空间复杂度为 $O(n)$。"
}