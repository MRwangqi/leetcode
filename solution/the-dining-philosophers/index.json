{
	"titleSlug": "the-dining-philosophers",
	"slug": "1ge-semaphore-1ge-reentrantlockshu-zu-by-gfu",
	"url": "https://leetcode-cn.com/problems/the-dining-philosophers/solution/1ge-semaphore-1ge-reentrantlockshu-zu-by-gfu/",
	"content": "这道题本质上其实是想考察**如何避免死锁**。\r\n易知：当 $5$ 个哲学家都拿着其左边(或右边)的叉子时，会进入死锁。\r\n\r\nPS：死锁的 $4$ 个必要条件：\r\n1. 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。\r\n2. 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\r\n3. 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。\r\n4. 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系。\r\n\r\n故**最多**只允许 $4$ 个哲学家去持有叉子，可保证至少有 $1$ 个哲学家能吃上意大利面（即获得到 $2$ 个叉子）。\r\n因为最差情况下是：$4$ 个哲学家都各自持有1个叉子，此时还 **剩余 $1$ 个叉子** 可供使用，这 $4$ 个哲学家中必然有1人能获取到这个 **剩余的 $1$ 个叉子**，从而手持 $2$ 个叉子，可以吃意大利面。\r\n即：$4$ 个人中，$1$ 个人有 $2$ 个叉子，$3$ 个人各持 $1$ 个叉子，共计 $5$ 个叉子。\r\n\r\n既然**最多**只允许4个哲学家去持有叉子，那么如果只允许3个哲学家去持有叉子是否可行呢？\r\n\r\n当然可行，$3$个哲学家可以先都各自持有$1$把叉子，此时还剩余$2$把叉子；\r\n\r\n当这$3$个哲学家刚好都相邻(比如：编号为图中的`0, 1, 2`)，可能会造成只有$1$个哲学家能吃到意面的情况，具体而言即`0`号哲学家拿到了其左侧的叉子(编号为`1`)，`1`号哲学家也拿到了其左侧的叉子(编号为`2`)，`2`号哲学家也拿到了其左侧的叉子(编号为`3`)，此时只有`0`号哲学家能拿到其右侧的叉子(编号为`0`)，因此只有`0`号哲学家能吃到意面。\r\n而其余情况下，`3`个哲学家中都能有`2`人吃到意面。\r\n即：$3$ 个人中，$2$ 个人各自持有 $2$ 个叉子，$1$ 个人持有 $1$ 个叉子，共计 $5$ 个叉子。\r\n\r\n并且仔细想想，叉子的数目是**固定**的(个数为`5`)，直觉上来讲`3`个人去抢`5`个叉子 比 `4`个人去抢`5`个叉子效率高。\r\n\r\n用`Semaphore`去实现上述的限制：`Semaphore eatLimit = new Semaphore(4);`\r\n一共有5个叉子，视为5个`ReentrantLock`，并将它们全放入1个数组中。\r\n\r\n给叉子编号 $0, 1, 2, 3, 4$（对应数组下标）。\r\n具体编号我是如下图这般设计的：\r\n\r\n![哲学家问题图.png](https://pic.leetcode-cn.com/30159b01ce754904bbc76bb81e52cfb5751b074f811ba88919bb3a0b861e02d8-%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98%E5%9B%BE.png){:width=300}\r\n\r\n\r\n有了这些思路，代码实现就变得清晰起来。\r\n\r\n代码具体实现：\r\n```java [-方法1]\r\nclass DiningPhilosophers {\r\n    //1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中\r\n    private final ReentrantLock[] lockList = {new ReentrantLock(),\r\n            new ReentrantLock(),\r\n            new ReentrantLock(),\r\n            new ReentrantLock(),\r\n            new ReentrantLock()};\r\n\r\n    //限制 最多只有4个哲学家去持有叉子\r\n    private Semaphore eatLimit = new Semaphore(4);\r\n\r\n    public DiningPhilosophers() {\r\n\r\n    }\r\n\r\n    // call the run() method of any runnable to execute its code\r\n    public void wantsToEat(int philosopher,\r\n                           Runnable pickLeftFork,\r\n                           Runnable pickRightFork,\r\n                           Runnable eat,\r\n                           Runnable putLeftFork,\r\n                           Runnable putRightFork) throws InterruptedException {\r\n\r\n        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号\r\n        int rightFork = philosopher;    //右边的叉子 的编号\r\n\r\n        eatLimit.acquire();    //限制的人数 -1\r\n\r\n        lockList[leftFork].lock();    //拿起左边的叉子\r\n        lockList[rightFork].lock();    //拿起右边的叉子\r\n\r\n        pickLeftFork.run();    //拿起左边的叉子 的具体执行\r\n        pickRightFork.run();    //拿起右边的叉子 的具体执行\r\n\r\n        eat.run();    //吃意大利面 的具体执行\r\n\r\n        putLeftFork.run();    //放下左边的叉子 的具体执行\r\n        putRightFork.run();    //放下右边的叉子 的具体执行\r\n\r\n        lockList[leftFork].unlock();    //放下左边的叉子\r\n        lockList[rightFork].unlock();    //放下右边的叉子\r\n\r\n        eatLimit.release();//限制的人数 +1\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n接下来的2个方法转自：\r\n作者：mike-meng\r\n链接：[https://leetcode-cn.com/problems/the-dining-philosophers/solution/zhe-xue-jia-jiu-can-wen-ti-by-mike-meng/](https://leetcode-cn.com/problems/the-dining-philosophers/solution/zhe-xue-jia-jiu-can-wen-ti-by-mike-meng/)\r\n\r\n他是用C++实现的，将其转为Java代码如下：\r\n\r\n**方法 $2$：**\r\n设置 $1$ 个临界区以实现 $1$ 个哲学家 “**同时**”拿起左右  **$2$ 把叉子**的效果。\r\n即进入临界区之后，保证**成功获取**到左右 **$2$ 把叉子** 并 执行相关代码后，才退出临界区。\r\n\r\n评论区看到有题友说方法2就是“只让1个哲学家就餐”的思路，无需将叉子视为`ReentrantLock`。\r\n\r\n下面我也给出了“只允许1个哲学家就餐”的代码。\r\n\r\n但是2者之间还是有**细微**的**差别**：\r\n方法2是在成功**拿起左右叉子之后**就退出临界区，而“只让1个哲学家就餐”是在**拿起左右叉子 + 吃意面 + 放下左右叉子** 一套流程走完之后才退出临界区。\r\n\r\n前者的情况可大概分为2种，举具体例子说明(可参照上面给出的图片)：\r\n1. `1`号哲学家拿起左右叉子(`1`号叉子 + `2`号叉子)后就退出临界区，此时`4`号哲学家成功挤进临界区，他也成功拿起了左右叉子(`0`号叉子和`4`号叉子)，然后就退出临界区。\r\n2. `1`号哲学家拿起左右叉子(`1`号叉子 + `2`号叉子)后就退出临界区，此时`2`号哲学家成功挤进临界区，他需要拿起`2`号叉子和`3`号叉子，但`2`号叉子有一定的概率还被`1`号哲学家持有(`1`号哲学家意面还没吃完)，因此`2`号哲学家进入临界区后还需要等待`2`号叉子。至于`3`号叉子，根本没其他人跟`2`号哲学家争夺，因此可以将该种情况视为“`2`号哲学家只拿起了1只叉子，在等待另1只叉子”的情况。\r\n\r\n总之，第1种情况即**先后进入临界区**的**2位哲学家**的左右叉子不存在竞争情况，因此先后进入临界区的2位哲学家进入临界区后都不用等待叉子，直接就餐。此时可视为2个哲学家在同时就餐(当然前1个哲学家有可能已经吃完了，但姑且当作是2个人同时就餐)。\r\n\r\n第2种情况即先后进入临界区的2位哲学家的左右叉子存在竞争情况(说明这2位哲学家的**编号相邻**)，因此**后进入临界区**的哲学家还需要等待1只叉子，才能就餐。此时可视为只有1个哲学家在就餐。\r\n\r\n至于“只允许1个哲学家就餐”的代码，很好理解，每次严格地只让1个哲学家就餐，由于过于严格，以至于都不需要将叉子视为`ReentrantLock`。\r\n\r\n方法`2`有一定的概率是“并行”，“只允许1个哲学家就餐”是严格的“串行”。\r\n\r\n代码如下：\r\n```java [-方法2]\r\nclass DiningPhilosophers {\r\n    //1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中\r\n    private final ReentrantLock[] lockList = {new ReentrantLock(),\r\n            new ReentrantLock(),\r\n            new ReentrantLock(),\r\n            new ReentrantLock(),\r\n            new ReentrantLock()};\r\n\r\n    //让 1个哲学家可以 “同时”拿起2个叉子(搞个临界区)\r\n    private ReentrantLock pickBothForks = new ReentrantLock();\r\n\r\n    public DiningPhilosophers() {\r\n\r\n    }\r\n\r\n    // call the run() method of any runnable to execute its code\r\n    public void wantsToEat(int philosopher,\r\n                           Runnable pickLeftFork,\r\n                           Runnable pickRightFork,\r\n                           Runnable eat,\r\n                           Runnable putLeftFork,\r\n                           Runnable putRightFork) throws InterruptedException {\r\n\r\n        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号\r\n        int rightFork = philosopher;    //右边的叉子 的编号\r\n\r\n        pickBothForks.lock();    //进入临界区\r\n\r\n        lockList[leftFork].lock();    //拿起左边的叉子\r\n        lockList[rightFork].lock();    //拿起右边的叉子\r\n\r\n        pickLeftFork.run();    //拿起左边的叉子 的具体执行\r\n        pickRightFork.run();    //拿起右边的叉子 的具体执行\r\n\r\n        pickBothForks.unlock();    //退出临界区\r\n\r\n        eat.run();    //吃意大利面 的具体执行\r\n\r\n        putLeftFork.run();    //放下左边的叉子 的具体执行\r\n        putRightFork.run();    //放下右边的叉子 的具体执行\r\n\r\n        lockList[leftFork].unlock();    //放下左边的叉子\r\n        lockList[rightFork].unlock();    //放下右边的叉子\r\n    }\r\n}\r\n```\r\n```java [-只允许1个哲学家就餐]\r\nclass DiningPhilosophers {\r\n    //只允许1个哲学家就餐\r\n    private ReentrantLock pickBothForks = new ReentrantLock();\r\n\r\n    public DiningPhilosophers() {\r\n\r\n    }\r\n\r\n    // call the run() method of any runnable to execute its code\r\n    public void wantsToEat(int philosopher,\r\n                           Runnable pickLeftFork,\r\n                           Runnable pickRightFork,\r\n                           Runnable eat,\r\n                           Runnable putLeftFork,\r\n                           Runnable putRightFork) throws InterruptedException {\r\n\r\n        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号\r\n        int rightFork = philosopher;    //右边的叉子 的编号\r\n\r\n        pickBothForks.lock();    //进入临界区\r\n\r\n        pickLeftFork.run();    //拿起左边的叉子 的具体执行\r\n        pickRightFork.run();    //拿起右边的叉子 的具体执行\r\n\r\n        eat.run();    //吃意大利面 的具体执行\r\n\r\n        putLeftFork.run();    //放下左边的叉子 的具体执行\r\n        putRightFork.run();    //放下右边的叉子 的具体执行\r\n\r\n        pickBothForks.unlock();    //退出临界区\r\n    }\r\n}\r\n```\r\n\r\n\r\n**方法 $3$：**\r\n前面说过，该题的本质是考察 **如何避免死锁**。\r\n而当5个哲学家都**左手持有**其**左边的叉子** 或 当5个哲学家都**右手持有**其**右边的叉子**时，会发生**死锁**。\r\n故只需设计1个避免发生上述情况发生的策略即可。\r\n\r\n即可以让**一部分哲学家**优先去获取其左边的叉子，再去获取其右边的叉子；再让**剩余哲学家**优先去获取其右边的叉子，再去获取其左边的叉子。\r\n\r\n代码如下：\r\n```java [-方法3]\r\nclass DiningPhilosophers {\r\n    //1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中\r\n    private final ReentrantLock[] lockList = {new ReentrantLock(),\r\n            new ReentrantLock(),\r\n            new ReentrantLock(),\r\n            new ReentrantLock(),\r\n            new ReentrantLock()};\r\n\r\n    public DiningPhilosophers() {\r\n\r\n    }\r\n\r\n    // call the run() method of any runnable to execute its code\r\n    public void wantsToEat(int philosopher,\r\n                           Runnable pickLeftFork,\r\n                           Runnable pickRightFork,\r\n                           Runnable eat,\r\n                           Runnable putLeftFork,\r\n                           Runnable putRightFork) throws InterruptedException {\r\n\r\n        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号\r\n        int rightFork = philosopher;    //右边的叉子 的编号\r\n\r\n        //编号为偶数的哲学家，优先拿起左边的叉子，再拿起右边的叉子\r\n        if (philosopher % 2 == 0) {\r\n            lockList[leftFork].lock();    //拿起左边的叉子\r\n            lockList[rightFork].lock();    //拿起右边的叉子\r\n        }\r\n        //编号为奇数的哲学家，优先拿起右边的叉子，再拿起左边的叉子\r\n        else {\r\n            lockList[rightFork].lock();    //拿起右边的叉子\r\n            lockList[leftFork].lock();    //拿起左边的叉子\r\n        }\r\n\r\n        pickLeftFork.run();    //拿起左边的叉子 的具体执行\r\n        pickRightFork.run();    //拿起右边的叉子 的具体执行\r\n\r\n        eat.run();    //吃意大利面 的具体执行\r\n\r\n        putLeftFork.run();    //放下左边的叉子 的具体执行\r\n        putRightFork.run();    //放下右边的叉子 的具体执行\r\n\r\n        lockList[leftFork].unlock();    //放下左边的叉子\r\n        lockList[rightFork].unlock();    //放下右边的叉子\r\n    }\r\n}\r\n```\r\n\r\n# 改进:\r\n**位运算**就可以表示`5`个叉子的**使用状态**，只需用1个`volatile`修饰的`int`变量即可 + `CAS`操作即可。\r\n而`volatile`修饰的`int`变量 + `CAS`操作 `->` `AtomicInteger`类\r\n\r\n```java [-改进的方法1]\r\nclass DiningPhilosophers {\r\n    //初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用\r\n    private AtomicInteger fork = new AtomicInteger(0);\r\n    //每个叉子的int值(即二进制的00001, 00010, 00100, 01000, 10000)\r\n    private final int[] forkMask = new int[]{1, 2, 4, 8, 16};\r\n    //限制 最多只有4个哲学家去持有叉子\r\n    private Semaphore eatLimit = new Semaphore(4);\r\n\r\n    public DiningPhilosophers() {\r\n\r\n    }\r\n\r\n    // call the run() method of any runnable to execute its code\r\n    public void wantsToEat(int philosopher,\r\n                           Runnable pickLeftFork,\r\n                           Runnable pickRightFork,\r\n                           Runnable eat,\r\n                           Runnable putLeftFork,\r\n                           Runnable putRightFork) throws InterruptedException {\r\n\r\n        int leftMask = forkMask[(philosopher + 1) % 5], rightMask = forkMask[philosopher];\r\n        eatLimit.acquire();    //限制的人数 -1\r\n\r\n        while (!pickFork(leftMask)) Thread.sleep(1);    //拿起左边的叉子\r\n        while (!pickFork(rightMask)) Thread.sleep(1);   //拿起右边的叉子\r\n\r\n        pickLeftFork.run();    //拿起左边的叉子 的具体执行\r\n        pickRightFork.run();    //拿起右边的叉子 的具体执行\r\n\r\n        eat.run();    //吃意大利面 的具体执行\r\n\r\n        putLeftFork.run();    //放下左边的叉子 的具体执行\r\n        putRightFork.run();    //放下右边的叉子 的具体执行\r\n\r\n        while (!putFork(leftMask)) Thread.sleep(1);     //放下左边的叉子\r\n        while (!putFork(rightMask)) Thread.sleep(1);    //放下右边的叉子\r\n\r\n        eatLimit.release(); //限制的人数 +1\r\n    }\r\n\r\n    private boolean pickFork(int mask) {\r\n        int expect = fork.get();\r\n        return (expect & mask) > 0 ? false : fork.compareAndSet(expect, expect ^ mask);\r\n    }\r\n\r\n    private boolean putFork(int mask) {\r\n        int expect = fork.get();\r\n        return fork.compareAndSet(expect, expect ^ mask);\r\n    }\r\n}\r\n```\r\n```java [-改进的方法2]\r\nclass DiningPhilosophers {\r\n    //初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用\r\n    private AtomicInteger fork = new AtomicInteger(0), both = new AtomicInteger(0);\r\n    //每个叉子的int值(即二进制的00001, 00010, 00100, 01000, 10000)\r\n    private final int[] forkMask = new int[]{1, 2, 4, 8, 16};\r\n\r\n    public DiningPhilosophers() {\r\n\r\n    }\r\n\r\n    // call the run() method of any runnable to execute its code\r\n    public void wantsToEat(int philosopher,\r\n                           Runnable pickLeftFork,\r\n                           Runnable pickRightFork,\r\n                           Runnable eat,\r\n                           Runnable putLeftFork,\r\n                           Runnable putRightFork) throws InterruptedException {\r\n\r\n        int leftMask = forkMask[(philosopher + 1) % 5], rightMask = forkMask[philosopher];\r\n\r\n        while (!both.compareAndSet(0, 1)) Thread.sleep(1);     //进入临界区\r\n\r\n        while (!pickFork(leftMask)) Thread.sleep(1);    //拿起左边的叉子\r\n        while (!pickFork(rightMask)) Thread.sleep(1);   //拿起右边的叉子\r\n\r\n        pickLeftFork.run();    //拿起左边的叉子 的具体执行\r\n        pickRightFork.run();    //拿起右边的叉子 的具体执行\r\n\r\n        while (!both.compareAndSet(1, 0)) Thread.sleep(1);    //退出临界区\r\n\r\n        eat.run();    //吃意大利面 的具体执行\r\n\r\n        putLeftFork.run();    //放下左边的叉子 的具体执行\r\n        putRightFork.run();    //放下右边的叉子 的具体执行\r\n\r\n        while (!putFork(rightMask)) Thread.sleep(1);   //放下右边的叉子\r\n        while (!putFork(leftMask)) Thread.sleep(1);    //放下左边的叉子\r\n    }\r\n\r\n    private boolean pickFork(int mask) {\r\n        int expect = fork.get();\r\n        return (expect & mask) > 0 ? false : fork.compareAndSet(expect, expect ^ mask);\r\n    }\r\n\r\n    private boolean putFork(int mask) {\r\n        int expect = fork.get();\r\n        return fork.compareAndSet(expect, expect ^ mask);\r\n    }\r\n}\r\n```\r\n```java [-改进的方法3]\r\nclass DiningPhilosophers {\r\n    //初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用\r\n    private AtomicInteger fork = new AtomicInteger(0);\r\n    //每个叉子的int值(即二进制的00001, 00010, 00100, 01000, 10000)\r\n    private final int[] forkMask = new int[]{1, 2, 4, 8, 16};\r\n\r\n    public DiningPhilosophers() {\r\n\r\n    }\r\n\r\n    // call the run() method of any runnable to execute its code\r\n    public void wantsToEat(int philosopher,\r\n                           Runnable pickLeftFork,\r\n                           Runnable pickRightFork,\r\n                           Runnable eat,\r\n                           Runnable putLeftFork,\r\n                           Runnable putRightFork) throws InterruptedException {\r\n\r\n        int leftMask = forkMask[(philosopher + 1) % 5], rightMask = forkMask[philosopher];\r\n\r\n        //编号为偶数的哲学家，优先拿起左边的叉子，再拿起右边的叉子\r\n        if (philosopher % 2 == 0) {\r\n            while (!pickFork(leftMask)) Thread.sleep(1);     //拿起左边的叉子\r\n            while (!pickFork(rightMask)) Thread.sleep(1);    //拿起右边的叉子\r\n        }//编号为奇数的哲学家，优先拿起右边的叉子，再拿起左边的叉子\r\n        else {\r\n            while (!pickFork(rightMask)) Thread.sleep(1);    //拿起右边的叉子\r\n            while (!pickFork(leftMask)) Thread.sleep(1);     //拿起左边的叉子\r\n        }\r\n\r\n        pickLeftFork.run();    //拿起左边的叉子 的具体执行\r\n        pickRightFork.run();    //拿起右边的叉子 的具体执行\r\n\r\n        eat.run();    //吃意大利面 的具体执行\r\n\r\n        putLeftFork.run();    //放下左边的叉子 的具体执行\r\n        putRightFork.run();    //放下右边的叉子 的具体执行\r\n\r\n        while (!putFork(rightMask)) Thread.sleep(1);    //放下右边的叉子\r\n        while (!putFork(leftMask)) Thread.sleep(1);     //放下左边的叉子\r\n    }\r\n\r\n    private boolean pickFork(int mask) {\r\n        int expect = fork.get();\r\n        return (expect & mask) > 0 ? false : fork.compareAndSet(expect, expect ^ mask);\r\n    }\r\n\r\n    private boolean putFork(int mask) {\r\n        int expect = fork.get();\r\n        return fork.compareAndSet(expect, expect ^ mask);\r\n    }\r\n}\r\n```"
}