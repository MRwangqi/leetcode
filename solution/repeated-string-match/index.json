{
	"titleSlug": "repeated-string-match",
	"slug": "zhong-fu-die-jia-zi-fu-chuan-pi-pei-by-l-vnye",
	"url": "https://leetcode-cn.com/problems/repeated-string-match/solution/zhong-fu-die-jia-zi-fu-chuan-pi-pei-by-l-vnye/",
	"content": "#### 方法一：Rabin-Karp 算法\n\n**思路与算法**\n\n命题「存在重复叠加字符串 $s_1=a \\ldots a$，使得字符串 $b$ 成为叠加后的字符串 $s_1$ 的子串」等价于「字符串 $b$ 成为无限重复叠加字符串 $s_2=aa \\ldots$ 的子串」。而后者成立的前提是任一 $s_2[i:\\infty], 0 \\le i < \\textit{len}(a)$ 以 $b$ 为前缀，即 $b$ 可以从第一个叠加的 $a$ 开始匹配成功。\n\n因此我们可以分两种情况：\n\n+ $b$ 可以从第一个叠加的 $a$ 开始匹配成功，则明显匹配的下标越小，最终需要的叠加数目 $k$ 越小，记成功匹配的最小下标为 $\\textit{index}$，$0 \\le \\textit{index} < \\textit{len}(a)$，于是：\n\n    $$\n    k =\n    \\begin{cases}\n    1, & \\textit{len}(b) \\le \\textit{len}(a) - \\textit{index} \\\\\n    \\displaystyle{\\Big\\lceil \\frac{\\textit{len}(b) - [\\textit{len}(a) - \\textit{index}]}{\\textit{len}(a)} \\Big\\rceil} + 1, & \\textit{len}(b) > \\textit{len}(a) - \\textit{index}\n    \\end{cases}\n    $$\n\n+ $b$ 无法从第一个叠加的 $a$ 开始匹配成功，说明不存在重复叠加字符串 $s_1=a \\ldots a$，使得字符串 $b$ 成为叠加后的字符串 $s_1=a \\ldots a$ 的子串。\n\n在应用 Rabin-Karp 算法时，被匹配字符串是循环叠加的字符串，所以下标要进行取余操作，并且匹配终止的条件为 $b$ 开始匹配的位置超过第一个叠加的 $a$。我们采用随机数来生成 Rabin-Karp 算法的哈希函数，希望避免后续哈希冲突的发生。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int n = haystack.size(), m = needle.size();\n        if (m == 0) {\n            return 0;\n        }\n\n        long long k1 = 1e9 + 7;\n        long long k2 = 1337;\n        srand((unsigned)time(NULL));\n        long long kMod1 = rand() % k1 + k1;\n        long long kMod2 = rand() % k2 + k2;\n\n        long long hash_needle = 0;\n        for (auto c : needle) {\n            hash_needle = (hash_needle * kMod2 + c) % kMod1;\n        }\n        long long hash_haystack = 0, extra = 1;\n        for (int i = 0; i < m - 1; i++) {\n            hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;\n            extra = (extra * kMod2) % kMod1;\n        }\n        for (int i = m - 1; (i - m + 1) < n; i++) {\n            hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;\n            if (hash_haystack == hash_needle) {\n                return i - m + 1;\n            }\n            hash_haystack = (hash_haystack - extra * haystack[(i - m + 1) % n]) % kMod1;\n            hash_haystack = (hash_haystack + kMod1) % kMod1;\n        }\n        return -1;\n    }\n\n    int repeatedStringMatch(string a, string b) {\n        int an = a.size(), bn = b.size();\n        int index = strStr(a, b);\n        if (index == -1) {\n            return -1;\n        }\n        if (an - index >= bn) {\n            return 1;\n        }\n        return (bn + index - an - 1) / an + 2;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static final int kMod1 = 1000000007;\n    static final int kMod2 = 1337;\n\n    public int repeatedStringMatch(String a, String b) {\n        int an = a.length(), bn = b.length();\n        int index = strStr(a, b);\n        if (index == -1) {\n            return -1;\n        }\n        if (an - index >= bn) {\n            return 1;\n        }\n        return (bn + index - an - 1) / an + 2;\n    }\n\n    public int strStr(String haystack, String needle) {\n        int n = haystack.length(), m = needle.length();\n        if (m == 0) {\n            return 0;\n        }\n\n        int k1 = 1000000009;\n        int k2 = 1337;\n        Random random = new Random();\n        int kMod1 = random.nextInt(k1) + k1;\n        int kMod2 = random.nextInt(k2) + k2;\n\n        long hashNeedle = 0;\n        for (int i = 0; i < m; i++) {\n            char c = needle.charAt(i);\n            hashNeedle = (hashNeedle * kMod2 + c) % kMod1;\n        }\n        long hashHaystack = 0, extra = 1;\n        for (int i = 0; i < m - 1; i++) {\n            hashHaystack = (hashHaystack * kMod2 + haystack.charAt(i % n)) % kMod1;\n            extra = (extra * kMod2) % kMod1;\n        }\n        for (int i = m - 1; (i - m + 1) < n; i++) {\n            hashHaystack = (hashHaystack * kMod2 + haystack.charAt(i % n)) % kMod1;\n            if (hashHaystack == hashNeedle) {\n                return i - m + 1;\n            }\n            hashHaystack = (hashHaystack - extra * haystack.charAt((i - m + 1) % n)) % kMod1;\n            hashHaystack = (hashHaystack + kMod1) % kMod1;\n        }\n        return -1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int RepeatedStringMatch(string a, string b) {\n        int an = a.Length, bn = b.Length;\n        int index = StrStr(a, b);\n        if (index == -1) {\n            return -1;\n        }\n        if (an - index >= bn) {\n            return 1;\n        }\n        return (bn + index - an - 1) / an + 2;\n    }\n\n    public int StrStr(string haystack, string needle) {\n        int n = haystack.Length, m = needle.Length;\n        if (m == 0) {\n            return 0;\n        }\n\n        int k1 = 1000000009;\n        int k2 = 1337;\n        Random random = new Random();\n        int kMod1 = random.Next(k1, k1 * 2);\n        int kMod2 = random.Next(k2, k2 * 2);\n\n        long hashNeedle = 0;\n        for (int i = 0; i < m; i++) {\n            char c = needle[i];\n            hashNeedle = (hashNeedle * kMod2 + c) % kMod1;\n        }\n        long hashHaystack = 0, extra = 1;\n        for (int i = 0; i < m - 1; i++) {\n            hashHaystack = (hashHaystack * kMod2 + haystack[i % n]) % kMod1;\n            extra = (extra * kMod2) % kMod1;\n        }\n        for (int i = m - 1; (i - m + 1) < n; i++) {\n            hashHaystack = (hashHaystack * kMod2 + haystack[i % n]) % kMod1;\n            if (hashHaystack == hashNeedle) {\n                return i - m + 1;\n            }\n            hashHaystack = (hashHaystack - extra * haystack[(i - m + 1) % n]) % kMod1;\n            hashHaystack = (hashHaystack + kMod1) % kMod1;\n        }\n        return -1;\n    }\n}\n```\n\n```C [sol1-C]\nint strStr(char *haystack, int n, char *needle, int m) {\n    if (m == 0) {\n        return 0;\n    }\n\n    long long k1 = 1e9 + 7;\n    long long k2 = 1337;\n    srand((unsigned)time(NULL));\n    long long kMod1 = rand() % k1 + k1;\n    long long kMod2 = rand() % k2 + k2;\n\n    long long hash_needle = 0;\n    for (int i = 0; i < m; i++) {\n        hash_needle = (hash_needle * kMod2 + needle[i]) % kMod1;\n    }\n    long long hash_haystack = 0, extra = 1;\n    for (int i = 0; i < m - 1; i++) {\n        hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;\n        extra = (extra * kMod2) % kMod1;\n    }\n    for (int i = m - 1; (i - m + 1) < n; i++) {\n        hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;\n        if (hash_haystack == hash_needle) {\n            return i - m + 1;\n        }\n        hash_haystack = (hash_haystack - extra * haystack[(i - m + 1) % n]) % kMod1;\n        hash_haystack = (hash_haystack + kMod1) % kMod1;\n    }\n    return -1;\n}\n\nint repeatedStringMatch(char * a, char * b){\n    int an = strlen(a), bn = strlen(b);\n    int index = strStr(a, an, b, bn);\n    if (index == -1) {\n        return -1;\n    }\n    if (an - index >= bn) {\n        return 1;\n    }\n    return (bn + index - an - 1) / an + 2;\n}\n```\n\n```Go [sol1-Golang]\nfunc strStr(haystack, needle string) int {\n    n, m := len(haystack), len(needle)\n    if m == 0 {\n        return 0\n    }\n\n    var k1 int = 1000000000 + 7\n    var k2 int = 1337\n    rand.Seed(time.Now().Unix())\n    var kMod1 int64 = int64(rand.Intn(k1)) + int64(k1)\n    var kMod2 int64 = int64(rand.Intn(k2)) + int64(k2)\n\n    var hash_needle int64 = 0\n    for i := 0; i < m; i++ {\n        hash_needle = (hash_needle*kMod2 + int64(needle[i])) % kMod1\n    }\n    var hash_haystack int64 = 0\n    var extra int64 = 1\n    for i := 0; i < m-1; i++ {\n        hash_haystack = (hash_haystack*kMod2 + int64(haystack[i%n])) % kMod1\n        extra = (extra * kMod2) % kMod1\n    }\n    for i := m - 1; (i - m + 1) < n; i++ {\n        hash_haystack = (hash_haystack*kMod2 + int64(haystack[i%n])) % kMod1\n        if hash_haystack == hash_needle {\n            return i - m + 1\n        }\n        hash_haystack = (hash_haystack - extra*int64(haystack[(i-m+1)%n])) % kMod1\n        hash_haystack = (hash_haystack + kMod1) % kMod1\n    }\n    return -1\n}\n\nfunc repeatedStringMatch(a string, b string) int {\n    an, bn := len(a), len(b)\n    index := strStr(a, b)\n    if index == -1 {\n        return -1\n    }\n    if an-index >= bn {\n        return 1\n    }\n    return (bn+index-an-1)/an + 2\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst repeatedStringMatch = (a, b) => {\n    const an = a.length, bn = b.length;\n    const index = strStr(a, b);\n    if (index === -1) {\n        return -1;\n    }\n    if (an - index >= bn) {\n        return 1;\n    }\n    return Math.floor((bn + index - an - 1) / an) + 2;\n}\n\nconst strStr = (haystack, needle) => {\n    const n = haystack.length, m = needle.length;\n    if (m === 0) {\n        return 0;\n    }\n\n    let k1 = 1000000009;\n    let k2 = 1337;\n    let kMod1 = Math.floor(Math.random() * k1) + k1;\n    let kMod2 = Math.floor(Math.random() * k2) + k2;\n\n    let hashNeedle = 0;\n    for (let i = 0; i < m; i++) {\n        const c = needle[i].charCodeAt();\n        hashNeedle = (hashNeedle * kMod2 + c) % kMod1;\n    }\n    let hashHaystack = 0, extra = 1;\n    for (let i = 0; i < m - 1; i++) {\n        hashHaystack = (hashHaystack * kMod2 + haystack[i % n].charCodeAt()) % kMod1;\n        extra = (extra * kMod2) % kMod1;\n    }\n    for (let i = m - 1; (i - m + 1) < n; i++) {\n        hashHaystack = (hashHaystack * kMod2 + haystack[i % n].charCodeAt()) % kMod1;\n        if (hashHaystack === hashNeedle) {\n            return i - m + 1;\n        }\n        hashHaystack = (hashHaystack - extra * haystack[(i - m + 1) % n].charCodeAt()) % kMod1;\n        hashHaystack = (hashHaystack + kMod1) % kMod1;\n    }\n    return -1;\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def strstr(self, haystack: str, needle: str) -> int:\n        n, m = len(haystack), len(needle)\n        if m == 0:\n            return 0\n\n        k1 = 10 ** 9 + 7\n        k2 = 1337\n        mod1 = randrange(k1) + k1\n        mod2 = randrange(k2) + k2\n\n        hash_needle = 0\n        for c in needle:\n            hash_needle = (hash_needle * mod2 + ord(c)) % mod1\n        hash_haystack = 0\n        for i in range(m - 1):\n            hash_haystack = (hash_haystack * mod2 + ord(haystack[i % n])) % mod1\n        extra = pow(mod2, m - 1, mod1)\n        for i in range(m - 1, n + m - 1):\n            hash_haystack = (hash_haystack * mod2 + ord(haystack[i % n])) % mod1\n            if hash_haystack == hash_needle:\n                return i - m + 1\n            hash_haystack = (hash_haystack - extra * ord(haystack[(i - m + 1) % n])) % mod1\n            hash_haystack = (hash_haystack + mod1) % mod1\n        return -1\n\n    def repeatedStringMatch(self, a: str, b: str) -> int:\n        n, m = len(a), len(b)\n        index = self.strstr(a, b)\n        if index == -1:\n            return -1\n        if n - index >= m:\n            return 1\n        return (m + index - n - 1) // n + 2\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n + m)$, 其中 $n$ 为 $a$ 的长度，$m$ 为 $b$ 的长度。Rabin-Karp 算法的时间复杂度为 $O(n + m)$。\n\n+ 空间复杂度：$O(1)$。只需要常数空间保存参数。\n\n#### 方法二：Knuth-Morris-Pratt 算法\n\n**前言**\n\n关于 Knuth-Morris-Pratt 算法的具体实现，读者可以参阅官方题解「[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode-solution-ds6y/)」，笔者就不作详细介绍了。\n\n**思路与算法**\n\n类似于方法一，我们也可以使用 Knuth-Morris-Pratt 算法来实现字符串匹配的功能。在应用 Knuth-Morris-Pratt 算法时，被匹配字符串是循环叠加的字符串，所以下标要进行取余操作，并且匹配终止的条件为 $b$ 开始匹配的位置超过第一个叠加的 $a$。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int strStr(string &haystack, string &needle) {\n        int n = haystack.size(), m = needle.size();\n        if (m == 0) {\n            return 0;\n        }\n        vector<int> pi(m);\n        for (int i = 1, j = 0; i < m; i++) {\n            while (j > 0 && needle[i] != needle[j]) {\n                j = pi[j - 1];\n            }\n            if (needle[i] == needle[j]) {\n                j++;\n            }\n            pi[i] = j;\n        }\n        for (int i = 0, j = 0; i - j < n; i++) { // b 开始匹配的位置是否超过第一个叠加的 a\n            while (j > 0 && haystack[i % n] != needle[j]) { // haystack 是循环叠加的字符串，所以取 i % n\n                j = pi[j - 1];\n            }\n            if (haystack[i % n] == needle[j]) {\n                j++;\n            }\n            if (j == m) {\n                return i - m + 1;\n            }\n        }\n        return -1;\n    }\n\n    int repeatedStringMatch(string a, string b) {\n        int an = a.size(), bn = b.size();\n        int index = strStr(a, b);\n        if (index == -1) {\n            return -1;\n        }\n        if (an - index >= bn) {\n            return 1;\n        }\n        return (bn + index - an - 1) / an + 2;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int repeatedStringMatch(String a, String b) {\n        int an = a.length(), bn = b.length();\n        int index = strStr(a, b);\n        if (index == -1) {\n            return -1;\n        }\n        if (an - index >= bn) {\n            return 1;\n        }\n        return (bn + index - an - 1) / an + 2;\n    }\n\n    public int strStr(String haystack, String needle) {\n        int n = haystack.length(), m = needle.length();\n        if (m == 0) {\n            return 0;\n        }\n        int[] pi = new int[m];\n        for (int i = 1, j = 0; i < m; i++) {\n            while (j > 0 && needle.charAt(i) != needle.charAt(j)) {\n                j = pi[j - 1];\n            }\n            if (needle.charAt(i) == needle.charAt(j)) {\n                j++;\n            }\n            pi[i] = j;\n        }\n        for (int i = 0, j = 0; i - j < n; i++) { // b 开始匹配的位置是否超过第一个叠加的 a\n            while (j > 0 && haystack.charAt(i % n) != needle.charAt(j)) { // haystack 是循环叠加的字符串，所以取 i % n\n                j = pi[j - 1];\n            }\n            if (haystack.charAt(i % n) == needle.charAt(j)) {\n                j++;\n            }\n            if (j == m) {\n                return i - m + 1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int RepeatedStringMatch(string a, string b) {\n        int an = a.Length, bn = b.Length;\n        int index = StrStr(a, b);\n        if (index == -1) {\n            return -1;\n        }\n        if (an - index >= bn) {\n            return 1;\n        }\n        return (bn + index - an - 1) / an + 2;\n    }\n\n    public int StrStr(string haystack, string needle) {\n        int n = haystack.Length, m = needle.Length;\n        if (m == 0) {\n            return 0;\n        }\n        int[] pi = new int[m];\n        for (int i = 1, j = 0; i < m; i++) {\n            while (j > 0 && needle[i] != needle[j]) {\n                j = pi[j - 1];\n            }\n            if (needle[i] == needle[j]) {\n                j++;\n            }\n            pi[i] = j;\n        }\n        for (int i = 0, j = 0; i - j < n; i++) { // b 开始匹配的位置是否超过第一个叠加的 a\n            while (j > 0 && haystack[i % n] != needle[j]) { // haystack 是循环叠加的字符串，所以取 i % n\n                j = pi[j - 1];\n            }\n            if (haystack[i % n] == needle[j]) {\n                j++;\n            }\n            if (j == m) {\n                return i - m + 1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```C [sol2-C]\nint strStr(char * haystack, int n, char * needle, int m) {\n    if (m == 0) {\n        return 0;\n    }\n    int pi[m];\n    pi[0] = 0;\n    for (int i = 1, j = 0; i < m; i++) {\n        while (j > 0 && needle[i] != needle[j]) {\n            j = pi[j - 1];\n        }\n        if (needle[i] == needle[j]) {\n            j++;\n        }\n        pi[i] = j;\n    }\n    for (int i = 0, j = 0; i - j < n; i++) { // b 开始匹配的位置是否超过第一个叠加的 a\n        while (j > 0 && haystack[i % n] != needle[j]) { // haystack 是循环叠加的字符串，所以取 i % n\n            j = pi[j - 1];\n        }\n        if (haystack[i % n] == needle[j]) {\n            j++;\n        }\n        if (j == m) {\n            return i - m + 1;\n        }\n    }\n    return -1;\n}\nint repeatedStringMatch(char * a, char * b){\n    int an = strlen(a), bn = strlen(b);\n    int index = strStr(a, an, b, bn);\n    if (index == -1) {\n        return -1;\n    }\n    if (an - index >= bn) {\n        return 1;\n    }\n    return (bn + index - an - 1) / an + 2;\n}\n```\n\n```Go [sol2-Golang]\nfunc strStr(haystack, needle string) int {\n    n, m := len(haystack), len(needle)\n    if m == 0 {\n        return 0\n    }\n    pi := make([]int, m)\n    for i, j := 1, 0; i < m; i++ {\n        for j > 0 && needle[i] != needle[j] {\n            j = pi[j-1]\n        }\n        if needle[i] == needle[j] {\n            j++\n        }\n        pi[i] = j\n    }\n    for i, j := 0, 0; i-j < n; i++ { // b 开始匹配的位置是否超过第一个叠加的 a\n        for j > 0 && haystack[i%n] != needle[j] { // haystack 是循环叠加的字符串，所以取 i % n\n            j = pi[j-1]\n        }\n        if haystack[i%n] == needle[j] {\n            j++\n        }\n        if j == m {\n            return i - m + 1\n        }\n    }\n    return -1\n}\n\nfunc repeatedStringMatch(a string, b string) int {\n    an, bn := len(a), len(b)\n    index := strStr(a, b)\n    if index == -1 {\n        return -1\n    }\n    if an-index >= bn {\n        return 1\n    }\n    return (bn+index-an-1)/an + 2\n}\n```\n\n```JavaScript [sol2-JavaScript]\nconst repeatedStringMatch = (a, b) => {\n    const an = a.length, bn = b.length;\n    const index = strStr(a, b);\n    if (index === -1) {\n        return -1;\n    }\n    if (an - index >= bn) {\n        return 1;\n    }\n    return Math.floor((bn + index - an - 1) / an) + 2;\n}\n\nconst strStr = (haystack, needle) => {\n    const n = haystack.length, m = needle.length;\n    if (m === 0) {\n        return 0;\n    }\n    const pi = new Array(m).fill(0);\n    for (let i = 1, j = 0; i < m; i++) {\n        while (j > 0 && needle[i] !== needle[j]) {\n            j = pi[j - 1];\n        }\n        if (needle[i] === needle[j]) {\n            j++;\n        }\n        pi[i] = j;\n    }\n    for (let i = 0, j = 0; i - j < n; i++) { // b 开始匹配的位置是否超过第一个叠加的 a\n        while (j > 0 && haystack[i % n] !== needle[j]) { // haystack 是循环叠加的字符串，所以取 i % n\n            j = pi[j - 1];\n        }\n        if (haystack[i % n] == needle[j]) {\n            j++;\n        }\n        if (j === m) {\n            return i - m + 1;\n        }\n    }\n    return -1;\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def strstr(self, haystack: str, needle: str) -> int:\n        n, m = len(haystack), len(needle)\n        if m == 0:\n            return 0\n\n        pi = [0] * m\n        j = 0\n        for i in range(1, m):\n            while j > 0 and needle[i] != needle[j]:\n                j = pi[j - 1]\n            if needle[i] == needle[j]:\n                j += 1\n            pi[i] = j\n\n        i, j = 0, 0\n        while i - j < n:\n            while j > 0 and haystack[i % n] != needle[j]:\n                j = pi[j - 1]\n            if haystack[i % n] == needle[j]:\n                j += 1\n            if j == m:\n                return i - m + 1\n            i += 1\n        return -1\n\n    def repeatedStringMatch(self, a: str, b: str) -> int:\n        n, m = len(a), len(b)\n        index = self.strstr(a, b)\n        if index == -1:\n            return -1\n        if n - index >= m:\n            return 1\n        return (m + index - n - 1) // n + 2\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n + m)$，其中 $n$ 为 $a$ 的长度，$m$ 为 $b$ 的长度。Knuth-Morris-Pratt 算法的时间复杂度为 $O(n + m)$。\n\n+ 空间复杂度：$O(m)$。Knuth-Morris-Pratt 算法需要 $O(m)$ 的空间来保存 $\\pi$ 数组。"
}