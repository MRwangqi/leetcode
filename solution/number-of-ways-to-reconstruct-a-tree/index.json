{
	"titleSlug": "number-of-ways-to-reconstruct-a-tree",
	"slug": "zhong-gou-yi-ke-shu-de-fang-an-shu-by-le-36e1",
	"url": "https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/solution/zhong-gou-yi-ke-shu-de-fang-an-shu-by-le-36e1/",
	"content": "#### 方法一：直接模拟\n\n**思路**\n\n本题抽象思维难度较大，需要仔细考虑树的结构。题目给定的数对 $\\textit{pairs}[i] = [x_{i},y_{i}]$，且满足 $x_{i}$ 是 $y_{i}$ 的祖先或者 $y_{i}$ 是 $x_{i}$ 的祖先；树中所包含的所有节点值都在 $\\textit{pairs}$ 中，即 $\\textit{pairs}$ 包含树中所有可能构成祖先的数对。\n\n设树中节点数目为 $n$，$\\textit{pairs}$ 中包含节点 $x$ 的数对的数目为 $\\textit{degree}[x]$，节点 $x$ 的祖先和后代的节点集合为 $\\textit{adj}[x]$。\n\n下面来研究 $\\textit{degree}$ 的性质。\n\n+ 根节点为树中其余所有节点的祖先，根节点与其余所有节点都能构成数对。设根节点为 $\\textit{root}$，由于 $\\textit{pairs}$ 包含树中所有可能构成祖先的数对，因此 $\\textit{degree}[\\textit{root}] = n - 1$。如下图所示，根节点 $1$ 为其余节点的祖先，蓝色节点组成了 $\\textit{adj}[1]$。\n\n![1](https://assets.leetcode-cn.com/solution-static/1719/1719_1.png)\n\n+ 对于 $\\textit{pairs}$ 中的数对 $[x_{i},y_{i}]$，如果 $x_{i}$ 为 $y_{i}$ 的祖先，则一定满足 $\\textit{degree}[x_{i}] \\ge \\textit{degree}[y_{i}]$。如果节点 $y_j$ 为节点 $y_{i}$ 的后代节点，则节点 $y_j$ 一定同时也是节点 $x_{i}$ 的后代节点；如果节点 $y_j$ 为节点 $y_{i}$ 的祖先节点，则节点 $y_j$ 要么是节点 $x_{i}$ 的祖先节点，要么是节点 $x_{i}$ 的后代节点，所以一定满足  $\\textit{degree}[x_{i}] \\ge \\textit{degree}[y_{i}]$。此外，如果 $x_{i}$ 为 $y_{i}$ 的祖先，则一定满足  $\\textit{adj}[y_{i}] \\in \\textit{adj}[x_{i}]$。如下图所示，含有节点 $2$ 的数对数目一定大于含有节点 $3$ 的数对数目。\n\n![2](https://assets.leetcode-cn.com/solution-static/1719/1719_2.png)\n\n+ 对于 $\\textit{pairs}$ 中的数对 $[x_{i},y_{i}]$，如果 $x_{i}$ 为 $y_{i}$ 的祖先，且满足 $\\textit{degree}[x_{i}] = \\textit{degree}[y_{i}]$ 和 $adj[x_{i}] = adj[y_{i}]$，则 $x_{i}$ 到 $y_{i}$ 途径的所有节点均只有一个孩子节点。此时 $x_{i}$ 到 $y_{i}$ 之间的节点包含的数对关系是一样的，$x_{i}$ 到 $y_{i}$ 之间的节点是可以进行互相交换而不影响树的结构，则此时构成树的方案数一定不是唯一的。如下图所示，节点 $6,7,9$ 满足上述要求：\n\n![3](https://assets.leetcode-cn.com/solution-static/1719/1719_3.png)\n\n综上所述，对于 $\\textit{pairs}$ 中的数对 $[x_{i},y_{i}]$：\n\n- 若 $\\textit{degree}[x_{i}] > \\textit{degree}[y_{i}]$，则 $x_{i}$ 为 $y_{i}$ 的祖先节点；\n- 若 $\\textit{degree}[x_{i}] < \\textit{degree}[y_{i}]$，则 $y_{i}$ 为 $x_{i}$ 的祖先节点；\n- 若 $\\textit{degree}[x_{i}] = \\textit{degree}[y_{i}]$，则可能存在多种构造方法，$y_{i}$ 为 $x_{i}$ 的祖先或者 $x_{i}$ 为 $y_{i}$ 的祖先。\n\n通过以上分析结论，我们可以尝试进行重新建树，并检查建成的树是否合法。\n\n+ 首先我们需要找到根节点 $\\textit{root}$，通过上述结论，我们找到满足 $\\textit{degree}[\\textit{root}] = n - 1$ 的节点，如果不存在根节点，则认为其不能构成合法的树，返回 $0$。\n\n+ 我们需要利用上述的结论检测是构建的树是否合法，遍历每个节点 $\\textit{node}_i$，找到 $\\textit{node}_i$ 的祖先 $\\textit{parent}_{i}$，检测集合 $\\textit{adj}[\\textit{node}_i]$ 是否为 $\\textit{adj}[\\textit{\\textit{parent}}_i]$ 的子集。可以利用 $\\textit{degree}[\\textit{node}_i] \\le \\textit{degree}[\\textit{parent}_{i}]$ 找到所有属于 $\\textit{node}_i$ 的祖先节点，然后依次检测是否满足 $\\textit{adj}[\\textit{node}_i] \\in \\textit{adj}[\\textit{\\textit{parent}}_i]$，如果不满足要求，则认为构建的树为非法，返回 $0$。\n\n+ 实际检测过程中不必检测节点 $\\textit{node}_i$ 的所有祖先节点，只需要检测节点 $\\textit{node}_i$ 的父节点是否满足子集包含的要求即可。根据上述推论找到节点 $x$ 满足 $\\textit{degree}[x]$ 最小且 $\\textit{degree}[x] \\ge \\textit{degree}[\\textit{node}_i]$，则此时找到的节点为节点 $\\textit{node}_i$ 的父亲节点，此时只需检测父亲节点是否满足上述要求即可。  \n\n+ 设 $\\textit{node}_i$ 的父节点为 $\\textit{parent}$，若满足 $\\textit{degree}[\\textit{node}_i] = \\textit{degree}[\\textit{parent}]$ 则树的构造方式可以有多个，返回 $2$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def checkWays(self, pairs: List[List[int]]) -> int:\n        adj = defaultdict(set)\n        for x, y in pairs:\n            adj[x].add(y)\n            adj[y].add(x)\n\n        # 检测是否存在根节点\n        root = next((node for node, neighbours in adj.items() if len(neighbours) == len(adj) - 1), -1)\n        if root == -1:\n            return 0\n\n        ans = 1\n        for node, neighbours in adj.items():\n            if node == root:\n                continue\n\n            currDegree = len(neighbours)\n            parent = -1\n            parentDegree = maxsize\n            # 根据 degree 的大小找到 node 的父节点 parent\n            for neighbour in neighbours:\n                if currDegree <= len(adj[neighbour]) < parentDegree:\n                    parent = neighbour\n                    parentDegree = len(adj[neighbour])\n            # 检测 neighbours 是否为 adj[parent] 的子集\n            if parent == -1 or any(neighbour != parent and neighbour not in adj[parent] for neighbour in neighbours):\n                return 0\n\n            if parentDegree == currDegree:\n                ans = 2\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int checkWays(vector<vector<int>>& pairs) {\n        unordered_map<int, unordered_set<int>> adj;\n        for (auto &p : pairs) {\n            adj[p[0]].emplace(p[1]);\n            adj[p[1]].emplace(p[0]);\n        }\n        /* 检测是否存在根节点*/\n        int root = -1;\n        for (auto &[node, neighbours] : adj) {\n            if (neighbours.size() == adj.size() - 1) {\n                root = node;\n                break;\n            }\n        }\n        if (root == -1) {\n            return 0;\n        }\n\n        int res = 1;\n        for (auto &[node, neighbours] : adj) {\n            if (node == root) {\n                continue;\n            }\n            int currDegree = neighbours.size();\n            int parent = -1;\n            int parentDegree = INT_MAX;\n\n            /* 根据 degree 的大小找到 node 的父节点 parent */\n            for (auto &neighbour : neighbours) {\n                if (adj[neighbour].size() < parentDegree && adj[neighbour].size() >= currDegree) {\n                    parent = neighbour;\n                    parentDegree = adj[neighbour].size();\n                }\n            }\n            if (parent == -1) {\n                return 0;\n            }\n\n            /* 检测 neighbours 是否是 adj[parent] 的子集 */\n            for (auto &neighbour : neighbours) {\n                if (neighbour == parent) {\n                    continue;\n                }\n                if (!adj[parent].count(neighbour)) {\n                    return 0;\n                }\n            }\n            if (parentDegree == currDegree) {\n                res = 2;\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int checkWays(int[][] pairs) {\n        Map<Integer, Set<Integer>> adj = new HashMap<Integer, Set<Integer>>();\n        for (int[] p : pairs) {\n            adj.putIfAbsent(p[0], new HashSet<Integer>());\n            adj.putIfAbsent(p[1], new HashSet<Integer>());\n            adj.get(p[0]).add(p[1]);\n            adj.get(p[1]).add(p[0]);\n        }\n        /* 检测是否存在根节点*/\n        int root = -1;\n        Set<Map.Entry<Integer, Set<Integer>>> entries = adj.entrySet();\n        for (Map.Entry<Integer, Set<Integer>> entry : entries) {\n            int node = entry.getKey();\n            Set<Integer> neighbours = entry.getValue();\n            if (neighbours.size() == adj.size() - 1) {\n                root = node;\n            }\n        }\n        if (root == -1) {\n            return 0;\n        }\n\n        int res = 1;\n        for (Map.Entry<Integer, Set<Integer>> entry : entries) {\n            int node = entry.getKey();\n            Set<Integer> neighbours = entry.getValue();\n            if (node == root) {\n                continue;\n            }\n            int currDegree = neighbours.size();\n            int parent = -1;\n            int parentDegree = Integer.MAX_VALUE;\n\n            /* 根据 degree 的大小找到 node 的父节点 parent */\n            for (int neighbour : neighbours) {\n                if (adj.get(neighbour).size() < parentDegree && adj.get(neighbour).size() >= currDegree) {\n                    parent = neighbour;\n                    parentDegree = adj.get(neighbour).size();\n                }\n            }\n            if (parent == -1) {\n                return 0;\n            }\n\n            /* 检测 neighbours 是否是 adj[parent] 的子集 */\n            for (int neighbour : neighbours) {\n                if (neighbour == parent) {\n                    continue;\n                }\n                if (!adj.get(parent).contains(neighbour)) {\n                    return 0;\n                }\n            }\n            if (parentDegree == currDegree) {\n                res = 2;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int CheckWays(int[][] pairs) {\n        Dictionary<int, ISet<int>> adj = new Dictionary<int, ISet<int>>();\n        foreach (int[] p in pairs) {\n            if (!adj.ContainsKey(p[0])) {\n                adj.Add(p[0], new HashSet<int>());\n            }\n            if (!adj.ContainsKey(p[1])) {\n                adj.Add(p[1], new HashSet<int>());\n            }\n            adj[p[0]].Add(p[1]);\n            adj[p[1]].Add(p[0]);\n        }\n        /* 检测是否存在根节点*/\n        int root = -1;\n        foreach (KeyValuePair<int, ISet<int>> pair in adj) {\n            int node = pair.Key;\n            ISet<int> neighbours = pair.Value;\n            if (neighbours.Count == adj.Count - 1) {\n                root = node;\n            }\n        }\n        if (root == -1) {\n            return 0;\n        }\n\n        int res = 1;\n        foreach (KeyValuePair<int, ISet<int>> pair in adj) {\n            int node = pair.Key;\n            ISet<int> neighbours = pair.Value;\n            /* 如果当前节点为根节点 */\n            if (node == root) {\n                continue;\n            }\n            int currDegree = neighbours.Count;\n            int parent = -1;\n            int parentDegree = int.MaxValue;\n\n            /* 根据 degree 的大小找到 node 的父节点 parent */\n            foreach (int neighbour in neighbours) {\n                if (adj[neighbour].Count < parentDegree && adj[neighbour].Count >= currDegree) {\n                    parent = neighbour;\n                    parentDegree = adj[neighbour].Count;\n                }\n            }\n            if (parent == -1) {\n                return 0;\n            }\n\n            /* 检测父节点的集合是否包含所有的孩子节点 */\n            foreach (int neighbour in neighbours) {\n                if (neighbour == parent) {\n                    continue;\n                }\n                if (!adj[parent].Contains(neighbour)) {\n                    return 0;\n                }\n            }\n            if (parentDegree == currDegree) {\n                res = 2;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    UT_hash_handle hh;\n} HashEntry;\n\nvoid hashInsert(HashEntry ** obj, int key) {\n    HashEntry * pEntry = NULL;\n    HASH_FIND(hh, *obj, &key, sizeof(int), pEntry);\n    if (NULL == pEntry) {\n        pEntry = (HashEntry *)malloc(sizeof(HashEntry));\n        pEntry->key = key;\n        HASH_ADD(hh, *obj, key, sizeof(int), pEntry);\n    }\n}\n\nbool hashFind(HashEntry ** obj, int key) {\n    HashEntry * pEntry = NULL;\n    HASH_FIND(hh, *obj, &key, sizeof(int), pEntry);\n    if (NULL == pEntry) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nvoid hashFreeAll(HashEntry ** obj) {\n    HashEntry *curr, *next;\n    HASH_ITER(hh, *obj, curr, next) {\n        HASH_DEL(*obj, curr);  \n        free(curr);\n    }\n}\n\n#define MAX_NODE_SIZE 501\n\nint checkWays(int** pairs, int pairsSize, int* pairsColSize) {\n    HashEntry * adj[MAX_NODE_SIZE];\n    memset(adj, 0, sizeof(HashEntry *) * MAX_NODE_SIZE);\n    for (int i = 0; i < pairsSize; i++) {\n        hashInsert(&adj[pairs[i][0]], pairs[i][1]);\n        hashInsert(&adj[pairs[i][1]], pairs[i][0]);\n    }\n    int nodeSize = 0;\n    for (int i = 0; i < MAX_NODE_SIZE; i++) {\n        if (NULL != adj[i]) {\n            nodeSize++;\n        }\n    }\n    /* 检测是否存在根节点*/\n    int root = -1;\n    for (int i = 0; i < MAX_NODE_SIZE; i++) {\n        unsigned int degree = HASH_COUNT(adj[i]);\n        if (degree == nodeSize - 1) {\n            root = i;\n            break;\n        }\n    }\n    if (root == -1) {\n        return 0;\n    }\n\n    int res = 1;\n    for (int i = 0; i < MAX_NODE_SIZE; i++) {\n        if (root == i || NULL == adj[i]) {\n            continue;\n        }\n        int currDegree = HASH_COUNT(adj[i]);\n        int parent = -1;\n        int parentDegree = INT_MAX;\n\n        /* 根据 degree 的大小找到当前节点的父节点 */\n        HashEntry *curr = NULL, *next = NULL;\n        HASH_ITER(hh, adj[i], curr, next) {\n            if (HASH_COUNT(adj[curr->key]) < parentDegree && HASH_COUNT(adj[curr->key]) >= currDegree) {\n                parent = curr->key;\n                parentDegree = HASH_COUNT(adj[curr->key]);\n            }\n        }\n        if (parent == -1) {\n            return 0;\n        }\n        \n        /* 检测 adj[node] 是否是 adj[parent] 的子集 */\n        HASH_ITER(hh, adj[i], curr, next) {\n            if (curr->key == parent) {\n                continue;\n            }\n            if (!hashFind(&adj[parent], curr->key)) {\n                return 0;\n            }\n        }\n        if (parentDegree == currDegree) {\n            res = 2;\n        }\n    }\n    for (int i = 0; i < MAX_NODE_SIZE; i++) {\n        hashFreeAll(&adj[i]);\n    }\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar checkWays = function(pairs) {\n    const adj = new Map();\n    for (const p of pairs) {\n        if (!adj.has(p[0])) {\n            adj.set(p[0], new Set());\n        }\n        if (!adj.has(p[1])) {\n            adj.set(p[1], new Set());\n        }\n        adj.get(p[0]).add(p[1]);\n        adj.get(p[1]).add(p[0]);\n    }\n    /* 检测是否存在根节点*/\n    let root = -1;\n    const entries = new Set();\n    for (const entry of adj.entries()) {\n        entries.add(entry);\n    }\n    for (const [node, neg] of entries) {\n        if (neg.size === adj.size - 1) {\n            root = node;\n        }\n    }\n    if (root === -1) {\n        return 0;\n    }\n    let res = 1;\n    for (const [node, neg] of entries) {\n        /* 如果当前节点为根节点 */\n        if (root === node) {\n            continue;\n        }\n        const currDegree = neg.size;\n        let parentNode = -1;\n        let parentDegree = Number.MAX_SAFE_INTEGER;\n        /* 根据degree的大小找到当前节点的父节点 */\n        for (const neighbour of neg) {\n            if (adj.has(neighbour) && adj.get(neighbour).size < parentDegree && adj.get(neighbour).size >= currDegree) {\n                parentNode = neighbour;\n                parentDegree = adj.get(neighbour).size;\n            }\n        }\n        if (parentNode === -1) {\n            return 0;\n        }\n        /* 检测父节点的集合是否包含所有的孩子节点 */\n        for (const neighbour of neg) {\n            if (neighbour === parentNode) {\n                continue;\n            }\n            if (!adj.get(parentNode).has(neighbour)) {\n                return 0;\n            }\n        }\n        if (parentDegree === currDegree) {\n            res = 2;\n        }\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc checkWays(pairs [][]int) int {\n    adj := map[int]map[int]bool{}\n    for _, p := range pairs {\n        x, y := p[0], p[1]\n        if adj[x] == nil {\n            adj[x] = map[int]bool{}\n        }\n        adj[x][y] = true\n        if adj[y] == nil {\n            adj[y] = map[int]bool{}\n        }\n        adj[y][x] = true\n    }\n\n    // 检测是否存在根节点\n    root := -1\n    for node, neighbours := range adj {\n        if len(neighbours) == len(adj)-1 {\n            root = node\n            break\n        }\n    }\n    if root == -1 {\n        return 0\n    }\n\n    ans := 1\n    for node, neighbours := range adj {\n        if node == root {\n            continue\n        }\n\n        currDegree := len(neighbours)\n        parent := -1\n        parentDegree := math.MaxInt32\n        // 根据 degree 的大小找到 node 的父节点 parent\n        for neighbour := range neighbours {\n            if len(adj[neighbour]) < parentDegree && len(adj[neighbour]) >= currDegree {\n                parent = neighbour\n                parentDegree = len(adj[neighbour])\n            }\n        }\n        if parent == -1 {\n            return 0\n        }\n        // 检测 neighbours 是否为 adj[parent] 的子集\n        for neighbour := range neighbours {\n            if neighbour != parent && !adj[parent][neighbour] {\n                return 0\n            }\n        }\n\n        if parentDegree == currDegree {\n            ans = 2\n        }\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m + n^2)$，其中 $n$ 为树中节点的数目，$m$ 表示数组 $\\textit{pairs}$ 的长度。需要遍历 $\\textit{pairs}$ ，时间复杂度为 $O(m)$，然后遍历所有的节点，检测每个节点的父节点对应的集合是否包含当前节点的对应的集合，集合中最多有 $n$ 个元素，时间复杂度为 $O(n^2)$，因此总的时间复杂度为 $O(m + n^2)$。\n\n- 空间复杂度：$O(m)$，$m$ 表示数组 $\\textit{pairs}$ 的长度。需要 $O(m)$ 的空间来存储节点对应的集合关系。"
}