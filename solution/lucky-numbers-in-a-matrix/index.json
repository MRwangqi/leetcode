{
	"titleSlug": "lucky-numbers-in-a-matrix",
	"slug": "ju-zhen-zhong-de-xing-yun-shu-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/solution/ju-zhen-zhong-de-xing-yun-shu-by-leetcode-solution/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n遍历矩阵 $\\textit{matrix}$，判断 $\\textit{matrix}[i][j]$ 是否是它所在行的最小值和所在列的最大值，如果是，则加入返回结果。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def luckyNumbers(self, matrix: List[List[int]]) -> List[int]:\n        ans = []\n        for row in matrix:\n            for j, x in enumerate(row):\n                if max(r[j] for r in matrix) <= x <= min(row):\n                    ans.append(x)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> luckyNumbers (vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<int> ret;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                bool isMin = true, isMax = true;\n                for (int k = 0; k < n; k++) {\n                    if (matrix[i][k] < matrix[i][j]) {\n                        isMin = false;\n                        break;\n                    }\n                }\n                if (!isMin) {\n                    continue;\n                }\n                for (int k = 0; k < m; k++) {\n                    if (matrix[k][j] > matrix[i][j]) {\n                        isMax = false;\n                        break;\n                    }\n                }\n                if (isMax) {\n                    ret.push_back(matrix[i][j]);\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> luckyNumbers (int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        List<Integer> ret = new ArrayList<Integer>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                boolean isMin = true, isMax = true;\n                for (int k = 0; k < n; k++) {\n                    if (matrix[i][k] < matrix[i][j]) {\n                        isMin = false;\n                        break;\n                    }\n                }\n                if (!isMin) {\n                    continue;\n                }\n                for (int k = 0; k < m; k++) {\n                    if (matrix[k][j] > matrix[i][j]) {\n                        isMax = false;\n                        break;\n                    }\n                }\n                if (isMax) {\n                    ret.add(matrix[i][j]);\n                }\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> LuckyNumbers (int[][] matrix) {\n        int m = matrix.Length, n = matrix[0].Length;\n        IList<int> ret = new List<int>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                bool isMin = true, isMax = true;\n                for (int k = 0; k < n; k++) {\n                    if (matrix[i][k] < matrix[i][j]) {\n                        isMin = false;\n                        break;\n                    }\n                }\n                if (!isMin) {\n                    continue;\n                }\n                for (int k = 0; k < m; k++) {\n                    if (matrix[k][j] > matrix[i][j]) {\n                        isMax = false;\n                        break;\n                    }\n                }\n                if (isMax) {\n                    ret.Add(matrix[i][j]);\n                }\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol1-C]\nint *luckyNumbers (int **matrix, int matrixSize, int *matrixColSize, int *returnSize){\n    int *ret = (int *)malloc(sizeof(int) * matrixSize * matrixColSize[0]);\n    int retSize = 0;\n    for (int i = 0; i < matrixSize; i++) {\n        for (int j = 0; j < matrixColSize[0]; j++) {\n            bool isMin = true, isMax = true;\n            for (int k = 0; k < matrixColSize[0]; k++) {\n                if (matrix[i][k] < matrix[i][j]) {\n                    isMin = false;\n                    break;\n                }\n            }\n            if (!isMin) {\n                continue;\n            }\n            for (int k = 0; k < matrixSize; k++) {\n                if (matrix[k][j] > matrix[i][j]) {\n                    isMax = false;\n                    break;\n                }\n            }\n            if (isMax) {\n                ret[retSize++] = matrix[i][j];\n            }\n        }\n    *returnSize = retSize;\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar luckyNumbers  = function(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    const ret = [];\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let isMin = true, isMax = true;\n            for (let k = 0; k < n; k++) {\n                if (matrix[i][k] < matrix[i][j]) {\n                    isMin = false;\n                    break;\n                }\n            }\n            if (!isMin) {\n                continue;\n            }\n            for (let k = 0; k < m; k++) {\n                if (matrix[k][j] > matrix[i][j]) {\n                    isMax = false;\n                    break;\n                }\n            }\n            if (isMax) {\n                ret.push(matrix[i][j]);\n            }\n        }\n    }\n    return ret;\n};\n```\n\n```go [sol1-Golang]\nfunc luckyNumbers(matrix [][]int) (ans []int) {\n    for _, row := range matrix {\n    next:\n        for j, x := range row {\n            for _, y := range row {\n                if y < x {\n                    continue next\n                }\n            }\n            for _, r := range matrix {\n                if r[j] > x {\n                    continue next\n                }\n            }\n            ans = append(ans, x)\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(mn \\times (m + n))$，其中 $m$ 和 $n$ 分别是矩阵 $\\textit{matrix}$ 的行数和列数。遍历矩阵 $\\textit{matrix}$ 需要 $O(mn)$，查找行最小值需要 $O(n)$，查找列最大值需要 $O(m)$。\n\n+ 空间复杂度：$O(1)$。返回值不计算空间复杂度。\n\n#### 方法二：预处理 + 模拟\n\n**思路与算法**\n\n预处理出每行的最小值数组 $\\textit{minRow}$ 和每列的最大值数组 $\\textit{maxCol}$，其中 $\\textit{minRow}[i]$ 表示第 $i$ 行的最小值，$\\textit{maxCol}[j]$ 表示第 $j$ 列的最大值。遍历矩阵 $\\textit{matrix}$，如果 $\\textit{matrix}[i][j]$ 同时满足 $\\textit{matrix}[i][j]=\\textit{minRow}[i]$ 和 $\\textit{matrix}[i][j] = \\textit{maxCol}[j]$，那么 $\\textit{matrix}[i][j]$ 是矩阵中的幸运数，加入返回结果。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def luckyNumbers(self, matrix: List[List[int]]) -> List[int]:\n        minRow = [min(row) for row in matrix]\n        maxCol = [max(col) for col in zip(*matrix)]\n        ans = []\n        for i, row in enumerate(matrix):\n            for j, x in enumerate(row):\n                if x == minRow[i] == maxCol[j]:\n                    ans.append(x)\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> luckyNumbers (vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<int> minRow(m, INT_MAX), maxCol(n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                minRow[i] = min(minRow[i], matrix[i][j]);\n                maxCol[j] = max(maxCol[j], matrix[i][j]);\n            }\n        }\n        vector<int> ret;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == minRow[i] && matrix[i][j] == maxCol[j]) {\n                    ret.push_back(matrix[i][j]);\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public List<Integer> luckyNumbers (int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[] minRow = new int[m];\n        Arrays.fill(minRow, Integer.MAX_VALUE);\n        int[] maxCol = new int[n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                minRow[i] = Math.min(minRow[i], matrix[i][j]);\n                maxCol[j] = Math.max(maxCol[j], matrix[i][j]);\n            }\n        }\n        List<Integer> ret = new ArrayList<Integer>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == minRow[i] && matrix[i][j] == maxCol[j]) {\n                    ret.add(matrix[i][j]);\n                }\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public IList<int> LuckyNumbers (int[][] matrix) {\n        int m = matrix.Length, n = matrix[0].Length;\n        int[] minRow = new int[m];\n        Array.Fill(minRow, int.MaxValue);\n        int[] maxCol = new int[n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                minRow[i] = Math.Min(minRow[i], matrix[i][j]);\n                maxCol[j] = Math.Max(maxCol[j], matrix[i][j]);\n            }\n        }\n        IList<int> ret = new List<int>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == minRow[i] && matrix[i][j] == maxCol[j]) {\n                    ret.Add(matrix[i][j]);\n                }\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol2-C]\nstatic inline int max(int n1, int n2) {\n    return n1 > n2 ? n1 : n2;\n}\n\nstatic inline int min(int n1, int n2) {\n    return n1 < n2 ? n1 : n2;\n}\n\nint *luckyNumbers (int **matrix, int matrixSize, int *matrixColSize, int *returnSize){\n    int *ret = (int *)malloc(sizeof(int) * matrixSize * matrixColSize[0]);\n    int retSize = 0;\n    int *minRow = (int *)malloc(sizeof(int) * matrixSize), *maxCol = (int *)malloc(sizeof(int) * matrixColSize[0]);\n    memset(minRow, 0x3f, sizeof(int) * matrixSize);\n    memset(maxCol, 0, sizeof(int) * matrixColSize[0]);\n    for (int i = 0; i < matrixSize; i++) {\n        for (int j = 0; j < matrixColSize[0]; j++) {\n            minRow[i] = min(minRow[i], matrix[i][j]);\n            maxCol[j] = max(maxCol[j], matrix[i][j]);\n        }\n    }\n    for (int i = 0; i < matrixSize; i++) {\n        for (int j = 0; j < matrixColSize[0]; j++) {\n            if (matrix[i][j] == minRow[i] && matrix[i][j] == maxCol[j]) {\n                ret[retSize++] = matrix[i][j];\n            }\n        }\n    }\n    free(minRow);\n    free(maxCol);\n    *returnSize = retSize;\n    return ret;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar luckyNumbers  = function(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    const minRow = new Array(m).fill(Number.MAX_SAFE_INTEGER);\n    const maxCol = new Array(n).fill(0);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            minRow[i] = Math.min(minRow[i], matrix[i][j]);\n            maxCol[j] = Math.max(maxCol[j], matrix[i][j]);\n        }\n    }\n    const ret = [];\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (matrix[i][j] === minRow[i] && matrix[i][j] === maxCol[j]) {\n                ret.push(matrix[i][j]);\n            }\n        }\n    }\n    return ret;\n};\n```\n\n```go [sol2-Golang]\nfunc luckyNumbers(matrix [][]int) (ans []int) {\n    minRow := make([]int, len(matrix))\n    maxCol := make([]int, len(matrix[0]))\n    for i, row := range matrix {\n        minRow[i] = row[0]\n        for j, x := range row {\n            minRow[i] = min(minRow[i], x)\n            maxCol[j] = max(maxCol[j], x)\n        }\n    }\n    for i, row := range matrix {\n        for j, x := range row {\n            if x == minRow[i] && x == maxCol[j] {\n                ans = append(ans, x)\n            }\n        }\n    }\n    return\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是矩阵 $\\textit{matrix}$ 的行数和列数。预处理 $\\textit{minRow}$ 和 $\\textit{maxCol}$ 需要 $O(mn)$，查找幸运数需要 $O(mn)$。\n\n+ 空间复杂度：$O(m + n)$。保存 $\\textit{minRow}$ 和 $\\textit{maxCol}$ 需要 $O(m + n)$ 的额外空间，返回值不计入空间复杂度。\n\n#### 方法三：幸运数的性质\n\n**思路与算法**\n\n因为矩阵中的数字互不相同，我们可以推导出幸运数的一些性质：\n\n+ 如果 $\\textit{matrix}[i][j]$ 是幸运数，即 $\\textit{matrix}[i][j]=\\textit{minRow}[i]$ 且 $\\textit{matrix}[i][j] = \\textit{maxCol}[j]$，那么 $\\textit{minRow}[i]$ 是 $\\textit{minRow}$ 的最大值（记作 $\\textit{rowMax}$），$\\textit{maxCol}[j]$ 是 $\\textit{maxCol}$ 的最小值（记作 $\\textit{colMin}$）。\n\n   > 证明：如果 $\\textit{minRow}[i]$ 不是 $\\textit{minRow}$ 的最大值，那么假设最大值 $\\textit{rowMax} = \\textit{minRow}[k] = \\textit{matrix}[k][l]$，其中 $k \\ne i$。于是 $\\textit{matrix}[i][j] = \\textit{minRow}[i] \\lt \\textit{rowMax} = \\textit{minRow}[k] = \\textit{matrix}[k][l] \\lt \\textit{matrix}[k][j]$，所以 $\\textit{matrix}[i][j] \\ne \\textit{maxCol}[j]$，矛盾。因此 $\\textit{minRow}[i]$ 是 $\\textit{minRow}$ 的最大值。同理我们也可以证明 $\\textit{maxCol}[j]$ 是 $\\textit{maxCol}$ 的最小值。\n\n+ 幸运数不超过一个。\n\n   > 证明：如果存在两个幸运数 $a$ 和 $b$，那么 $a = b = \\textit{rowMax}$，与矩阵中的数字互不相同矛盾。\n\n如果存在幸运数，那么幸运数一定等于 $\\textit{rowMax}$。因此我们可以先求出 $\\textit{minRow}$ 的最大值 $\\textit{rowMax}$，并记录 $\\textit{rowMax}$ 所在的列 $k$，然后判断 $\\textit{rowMax}$ 是不是第 $k$ 列的最大值，如果是，则返回 $\\textit{rowMax}$。\n\n**代码**\n\n```go [sol3-Golang]\nclass Solution:\n    def luckyNumbers(self, matrix: List[List[int]]) -> List[int]:\n        rowMax, k = 0, 0\n        for row in matrix:\n            minRow = min(row)\n            if minRow > rowMax:\n                rowMax, k = minRow, row.index(minRow)\n        return [rowMax] if all(row[k] <= rowMax for row in matrix) else []\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    vector<int> luckyNumbers (vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int rowMax = 0, k;\n        for (int i = 0; i < m; i++) {\n            int c = min_element(matrix[i].begin(), matrix[i].end()) - matrix[i].begin();\n            if (rowMax < matrix[i][c]) {\n                rowMax = matrix[i][c];\n                k = c;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (rowMax < matrix[i][k]) {\n                return {};\n            }\n        }\n        return {rowMax};\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public List<Integer> luckyNumbers (int[][] matrix) {\n        List<Integer> ret = new ArrayList<Integer>();\n        int m = matrix.length, n = matrix[0].length;\n        int rowMax = 0, k = 0;\n        for (int i = 0; i < m; i++) {\n            int curMin = matrix[i][0];\n            int c = 0;\n            for (int j = 1; j < n; j++) {\n                if (curMin > matrix[i][j]) {\n                    curMin = matrix[i][j];\n                    c = j;\n                }\n            }\n            if (rowMax < curMin) {\n                rowMax = curMin;\n                k = c;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (rowMax < matrix[i][k]) {\n                return ret;\n            }\n        }\n        ret.add(rowMax);\n        return ret;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public IList<int> LuckyNumbers (int[][] matrix) {\n        IList<int> ret = new List<int>();\n        int m = matrix.Length, n = matrix[0].Length;\n        int rowMax = 0, k = 0;\n        for (int i = 0; i < m; i++) {\n            int curMin = matrix[i][0];\n            int c = 0;\n            for (int j = 1; j < n; j++) {\n                if (curMin > matrix[i][j]) {\n                    curMin = matrix[i][j];\n                    c = j;\n                }\n            }\n            if (rowMax < curMin) {\n                rowMax = curMin;\n                k = c;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (rowMax < matrix[i][k]) {\n                return ret;\n            }\n        }\n        ret.Add(rowMax);\n        return ret;\n    }\n}\n```\n\n```C [sol3-C]\nint *luckyNumbers (int **matrix, int matrixSize, int *matrixColSize, int *returnSize){\n    int m = matrixSize, n = matrixColSize[0];\n    int rowMax = 0, k;\n    for (int i = 0; i < m; i++) {\n        int index = 0;\n        for (int j = 1; j < n; j++) {\n            if (matrix[i][index] > matrix[i][j]) {\n                index = j;\n            }\n        }\n        if (rowMax < matrix[i][index]) {\n            rowMax = matrix[i][index];\n            k = index;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        if (rowMax < matrix[i][k]) {\n            *returnSize = 0;\n            return NULL;\n        }\n    }\n\n    int *ret = (int *)malloc(sizeof(int));\n    *ret = rowMax;\n    *returnSize = 1;\n    return ret;\n}\n```\n\n```go [sol3-Golang]\nfunc luckyNumbers(matrix [][]int) []int {\n    rowMax, k := 0, 0\n    for _, row := range matrix {\n        c := 0\n        for j, v := range row {\n            if v < row[c] {\n                c = j\n            }\n        }\n        if row[c] > rowMax {\n            rowMax = row[c]\n            k = c\n        }\n    }\n    for _, row := range matrix {\n        if row[k] > rowMax {\n            return nil\n        }\n    }\n    return []int{rowMax}\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar luckyNumbers  = function(matrix) {\n    const ret = [];\n    const m = matrix.length, n = matrix[0].length;\n    let rowMax = 0, k = 0;\n    for (let i = 0; i < m; i++) {\n        let curMin = matrix[i][0];\n        let c = 0;\n        for (let j = 1; j < n; j++) {\n            if (curMin > matrix[i][j]) {\n                curMin = matrix[i][j];\n                c = j;\n            }\n        }\n        if (rowMax < curMin) {\n            rowMax = curMin;\n            k = c;\n        }\n    }\n    for (let i = 0; i < m; i++) {\n        if (rowMax < matrix[i][k]) {\n            return ret;\n        }\n    }\n    ret.push(rowMax);\n    return ret;\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是矩阵 $\\textit{matrix}$ 的行数和列数。获取 $\\textit{rowMax}$ 需要 $O(mn)$，判断 $\\textit{rowMax}$ 是否是列最大值需要 $O(m)$。\n\n+ 空间复杂度：$O(1)$。"
}