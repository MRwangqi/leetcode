{
	"titleSlug": "find-all-possible-recipes-from-given-supplies",
	"slug": "cong-gei-ding-yuan-cai-liao-zhong-zhao-d-d02i",
	"url": "https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/solution/cong-gei-ding-yuan-cai-liao-zhong-zhao-d-d02i/",
	"content": "#### 方法一：拓扑排序\n\n**思路与算法**\n\n我们把每一种原材料（菜也算一种原材料）看成图上的一个节点，如果某一道菜需要一种原材料，就添加一条从原材料到菜的有向边。\n\n可以发现，如果图上的一个节点的入度为 $0$（即不存在以该节点为终点的边），那么该节点对应的原材料是可以直接使用的。特别地，如果该节点对应的原材料是一道菜，那么我们就可以做出这道菜。在这之后，我们将以该节点本身和以该节点为起点的边全部删除，这样就可能会有节点的入度变为 $0$，我们就可以不断重复这一过程，直到图中不存在节点，或所有剩余节点的入度均不为 $0$。\n\n上述过程实际上就是使用广度优先搜索进行拓扑排序的过程。\n\n**代码**\n\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\n        int n = recipes.size();\n        // 图\n        unordered_map<string, vector<string>> depend;\n        // 入度统计\n        unordered_map<string, int> cnt;\n        for (int i = 0; i < n; ++i) {\n            for (const string& ing: ingredients[i]) {\n                depend[ing].push_back(recipes[i]);\n            }\n            cnt[recipes[i]] = ingredients[i].size();\n        }\n        \n        vector<string> ans;\n        queue<string> q;\n        // 把初始的原材料放入队列\n        for (const string& sup: supplies) {\n            q.push(sup);\n        }\n        // 拓扑排序\n        while (!q.empty()) {\n            string cur = q.front();\n            q.pop();\n            if (depend.count(cur)) {\n                for (const string& rec: depend[cur]) {\n                    --cnt[rec];\n                    // 如果入度变为 0，说明可以做出这道菜\n                    if (cnt[rec] == 0) {\n                        ans.push_back(rec);\n                        q.push(rec);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        n = len(recipes)\n        # 图\n        depend = defaultdict(list)\n        # 入度统计\n        cnt = Counter()\n        for i in range(n):\n            for ing in ingredients[i]:\n                depend[ing].append(recipes[i])\n            cnt[recipes[i]] = len(ingredients[i])\n        \n        ans = list()\n        # 把初始的原材料放入队列\n        q = deque(supplies)\n        \n        # 拓扑排序\n        while q:\n            cur = q.popleft()\n            if cur in depend:\n                for rec in depend[cur]:\n                    cnt[rec] -= 1\n                    # 如果入度变为 0，说明可以做出这道菜\n                    if cnt[rec] == 0:\n                        ans.append(rec)\n                        q.append(rec)\n        return ans\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(dn + m)$，其中 $m$ 是数组 $\\textit{supplies}$ 的长度，$d$ 是数组 $\\textit{recipe}$ 中每一个元素（数组）的最大长度，并且我们把所有字符串的长度视为常数。图中会有 $n + m$ 个节点，并且会有不超过 $dn$ 条边，因此建立图以及拓扑排序的时间复杂度为 $O(n + m + dn) = O(dn + m)$。\n\n- 空间复杂度：$O(dn + m)$，即为存储图需要的空间。"
}