{
	"titleSlug": "battleships-in-a-board",
	"slug": "jia-ban-shang-de-zhan-jian-by-leetcode-s-kxpc",
	"url": "https://leetcode-cn.com/problems/battleships-in-a-board/solution/jia-ban-shang-de-zhan-jian-by-leetcode-s-kxpc/",
	"content": "#### 方法一：遍历扫描\n\n题目要求找到矩阵中战舰的数量，战舰用 $\\texttt{'X'}$ 表示，空位用 $\\texttt{'.'}$，而矩阵中的战舰的满足以下两个条件：\n\n- 战舰只能水平或者垂直放置。战舰只能由子矩阵 $1 \\times N$（$1$ 行，$N$ 列）组成，或者子矩阵 $N \\times 1$（$N$ 行, $1$ 列）组成，其中 $N$ 可以是任意大小。\n- 两艘战舰之间至少有一个水平或垂直的空位分隔，没有相邻的战舰。\n\n我们遍历矩阵中的每个位置 $(i,j)$ 且满足 $\\textit{board}[i][j] = \\texttt{'X'}$，并将以 $(i,j)$ 为起点的战舰的所有位置均设置为空位，从而我们即可统计出所有可能的战舰。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public int countBattleships(char[][] board) {\n        int row = board.length;\n        int col = board[0].length;\n        int ans = 0;\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (board[i][j] == 'X') {\n                    board[i][j] = '.';\n                    for (int k = j + 1; k < col && board[i][k] == 'X'; ++k) {\n                        board[i][k] = '.';\n                    }                    \n                    for (int k = i + 1; k < row && board[k][j] == 'X'; ++k) {\n                        board[k][j] = '.';\n                    }\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int countBattleships(vector<vector<char>>& board) {\n        int row = board.size();\n        int col = board[0].size();\n        int ans = 0;\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (board[i][j] == 'X') {\n                    board[i][j] = '.';\n                    for (int k = j + 1; k < col && board[i][k] == 'X'; ++k) {\n                        board[i][k] = '.';\n                    }                    \n                    for (int k = i + 1; k < row && board[k][j] == 'X'; ++k) {\n                        board[k][j] = '.';\n                    }\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int CountBattleships(char[][] board) {\n        int row = board.Length;\n        int col = board[0].Length;\n        int ans = 0;\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (board[i][j] == 'X') {\n                    board[i][j] = '.';\n                    for (int k = j + 1; k < col && board[i][k] == 'X'; ++k) {\n                        board[i][k] = '.';\n                    }                    \n                    for (int k = i + 1; k < row && board[k][j] == 'X'; ++k) {\n                        board[k][j] = '.';\n                    }\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\nint countBattleships(char** board, int boardSize, int* boardColSize){\n    int row = boardSize;\n    int col = boardColSize[0];\n    int ans = 0;\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < col; ++j) {\n            if (board[i][j] == 'X') {\n                board[i][j] = '.';\n                for (int k = j + 1; k < col && board[i][k] == 'X'; ++k) {\n                    board[i][k] = '.';\n                }                    \n                for (int k = i + 1; k < row && board[k][j] == 'X'; ++k) {\n                    board[k][j] = '.';\n                }\n                ans++;\n            }\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar countBattleships = function(board) {\n    const row = board.length;\n    const col = board[0].length;\n    let ans = 0;\n    for (let i = 0; i < row; ++i) {\n        for (let j = 0; j < col; ++j) {\n            if (board[i][j] === 'X') {\n                board[i][j] = '.';\n                for (let k = j + 1; k < col && board[i][k] === 'X'; ++k) {\n                    board[i][k] = '.';\n                }                    \n                for (let k = i + 1; k < row && board[k][j] === 'X'; ++k) {\n                    board[k][j] = '.';\n                }\n                ans++;\n            }\n        }\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc countBattleships(board [][]byte) (ans int) {\n    m, n := len(board), len(board[0])\n    for i, row := range board {\n        for j, ch := range row {\n            if ch == 'X' {\n                row[j] = '.'\n                for k := j + 1; k < n && row[k] == 'X'; k++ {\n                    row[k] = '.'\n                }\n                for k := i + 1; k < m && board[k][j] == 'X'; k++ {\n                    board[k][j] = '.'\n                }\n                ans++\n            }\n        }\n    }\n    return\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def countBattleships(self, board: List[List[str]]) -> int:\n        ans = 0\n        m, n = len(board), len(board[0])\n        for i, row in enumerate(board):\n            for j, ch in enumerate(row):\n                if ch == 'X':\n                    row[j] = '.'\n                    for k in range(j + 1, n):\n                        if row[k] != 'X':\n                            break\n                        row[k] = '.'\n                    for k in range(i + 1, m):\n                        if board[k][j] != 'X':\n                            break\n                        board[k][j] = '.'\n                    ans += 1\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m \\times n \\times \\max(m,n))$，其中 $m$ 是矩阵的行数，$n$ 是矩阵的列数，我们对于矩阵的每个位置都会遍历一遍以该位置所在的行和列。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：枚举起点\n\n题目进阶要求一次扫描算法，只使用 $O(1)$ 额外空间，并且不修改甲板的值。因为题目中给定的两艘战舰之间至少有一个水平或垂直的空位分隔，任意两个战舰之间是不相邻的，因此我们可以通过枚举每个战舰的左上顶点即可统计战舰的个数。假设矩阵的行数为 $\\textit{row}$，矩阵的列数 $\\textit{col}$，矩阵中的位置 $(i, j)$ 为战舰的左上顶点，需满足以下条件：\n\n- 满足当前位置所在的值 $\\textit{board}[i][j] = \\texttt{'X'}$；\n- 满足当前位置的左则为空位，即$\\textit{board}[i][j-1] = \\texttt{'.'}$；\n- 满足当前位置的上方为空位，即$\\textit{board}[i-1][j] = \\texttt{'.'}$；\n\n我们统计出所有战舰的左上顶点的个数即为所有战舰的个数。\n\n**代码**\n\n```Java [sol2-Java]\nclass Solution {\n    public int countBattleships(char[][] board) {\n        int row = board.length;\n        int col = board[0].length;\n        int ans = 0;\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (board[i][j] == 'X') {\n                    if (i > 0 && board[i - 1][j] == 'X') {\n                        continue;\n                    }\n                    if (j > 0 && board[i][j - 1] == 'X') {\n                        continue;\n                    }\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int countBattleships(vector<vector<char>>& board) {\n        int row = board.size();\n        int col = board[0].size();\n        int ans = 0;\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) { \n                if (board[i][j] == 'X') {\n                    if (i > 0 && board[i - 1][j] == 'X') {\n                        continue;\n                    }\n                    if (j > 0 && board[i][j - 1] == 'X') {\n                        continue;\n                    }\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int CountBattleships(char[][] board) {\n        int row = board.Length;\n        int col = board[0].Length;\n        int ans = 0;\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (board[i][j] == 'X') {\n                    if (i > 0 && board[i - 1][j] == 'X') {\n                        continue;\n                    }\n                    if (j > 0 && board[i][j - 1] == 'X') {\n                        continue;\n                    }\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol2-C]\nint countBattleships(char** board, int boardSize, int* boardColSize){\n    int row = boardSize;\n    int col = boardColSize[0];\n    int ans = 0;\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < col; ++j) {\n            if (board[i][j] == 'X') {\n                if (i > 0 && board[i - 1][j] == 'X') {\n                    continue;\n                }\n                if (j > 0 && board[i][j - 1] == 'X') {\n                    continue;\n                }\n                ans++;\n            }\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar countBattleships = function(board) {\n    const row = board.length;\n    const col = board[0].length;\n    let ans = 0;\n    for (let i = 0; i < row; ++i) {\n        for (let j = 0; j < col; ++j) {\n            if (board[i][j] === 'X') {\n                if (i > 0 && board[i - 1][j] === 'X') {\n                    continue;\n                }\n                if (j > 0 && board[i][j - 1] === 'X') {\n                    continue;\n                }\n                ans++;\n            }\n        }\n    }\n    return ans;\n};\n```\n\n```go [sol2-Golang]\nfunc countBattleships(board [][]byte) (ans int) {\n    for i, row := range board {\n        for j, ch := range row {\n            if ch == 'X' && !(i > 0 && board[i-1][j] == 'X' || j > 0 && board[i][j-1] == 'X') {\n                ans++\n            }\n        }\n    }\n    return\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def countBattleships(self, board: List[List[str]]) -> int:\n        return sum(ch == 'X' and not (i > 0 and board[i - 1][j] == 'X' or j > 0 and board[i][j - 1] == 'X')\n                   for i, row in enumerate(board) for j, ch in enumerate(row))\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m \\times n)$，其中 $m$ 是矩阵的行数，$n$ 是矩阵的列数，我们只需要遍历一遍矩阵中每个位置即可。\n\n- 空间复杂度：$O(1)$。"
}