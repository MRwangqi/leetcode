{
	"titleSlug": "time-needed-to-rearrange-a-binary-string",
	"slug": "by-endlesscheng-pq2x",
	"url": "https://leetcode-cn.com/problems/time-needed-to-rearrange-a-binary-string/solution/by-endlesscheng-pq2x/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1Kd4y1Z7Fv) 已出炉，欢迎点赞三连，在评论区分享你对这场双周赛的看法~\r\n\r\n---\r\n\r\n把 $s$ 看成是一条道路，$\\texttt{1}$ 看成车，替换操作看成是车往左移动（如果左侧为 $\\texttt{0}$ 的话）。\r\n\r\n定义 $f[i]$ 表示 $s$ 的前 $i$ 个字符中的车完成移动所需的秒数。\r\n\r\n如果 $s[i]=\\texttt{0}$，此处无车，则 $f[i]=f[i-1]$。\r\n\r\n如果 $s[i]=\\texttt{1}$，记前 $i$ 个字符中 $\\texttt{0}$ 的个数为 $\\textit{pre}_0[i]$，则 $f[i]$ 至少为 $\\textit{pre}_0[i]$。记 $s[i]$ 为 $B$，它左边那辆车为 $A$，如果 $B$ 在移动的过程中被 $A$ 堵住（两辆车紧贴），那么当 $A$ 到达 $A$ 的目标位置时，$B$ 不会也同时到达 $B$ 的目标位置（题目不允许两辆紧贴的车同时向左开），也不会与 $A$ 相距超过 $1$（$B$ 左边有空位时，下一秒就会立刻向左移动），因此 $B$ 恰好会在 $A$ 到达目标位置的下一秒到达 $B$ 的目标位置，即 $f[i]=f[i-1]+1$。\r\n\r\n这两者取最大值，即\r\n\r\n$$\r\nf[i] = \\max(f[i-1]+1, \\textit{pre}_0[i])\r\n$$\r\n\r\n答案为 $f[n-1]$。\r\n\r\n代码实现时 $f$ 和 $\\textit{pre}_0$ 都可以压缩成一个变量。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为 $s$ 的长度。\r\n- 空间复杂度：$O(1)$，仅用到若干变量。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def secondsToRemoveOccurrences(self, s: str) -> int:\r\n        f = pre0 = 0\r\n        for c in s:\r\n            if c == '0': pre0 += 1\r\n            elif pre0: f = max(f + 1, pre0)  # 前面有 0 的时候才会移动\r\n        return f\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int secondsToRemoveOccurrences(String s) {\r\n        int f = 0, pre0 = 0;\r\n        for (var i = 0; i < s.length(); i++)\r\n            if (s.charAt(i) == '0') ++pre0;\r\n            else if (pre0 > 0) f = Math.max(f + 1, pre0); // 前面有 0 的时候才会移动\r\n        return f;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int secondsToRemoveOccurrences(string &s) {\r\n        int f = 0, pre0 = 0;\r\n        for (char c : s)\r\n            if (c == '0') ++pre0;\r\n            else if (pre0) f = max(f + 1, pre0); // 前面有 0 的时候才会移动\r\n        return f;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc secondsToRemoveOccurrences(s string) (f int) {\r\n\tpre0 := 0\r\n\tfor _, c := range s {\r\n\t\tif c == '0' {\r\n\t\t\tpre0++\r\n\t\t} else if pre0 > 0 { // 前面有 0 的时候才会移动\r\n\t\t\tf = max(f+1, pre0)\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n"
}