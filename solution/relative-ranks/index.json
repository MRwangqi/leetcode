{
	"titleSlug": "relative-ranks",
	"slug": "xiang-dui-ming-ci-by-leetcode-solution-5sua",
	"url": "https://leetcode-cn.com/problems/relative-ranks/solution/xiang-dui-ming-ci-by-leetcode-solution-5sua/",
	"content": "#### 方法一：排序\n\n题目要求找到每个运动员的相对名次，并同时给前三名标记为 $\\texttt{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"}$，其余的运动员则标记为其相对名次。\n将所有的运动员按照成绩的高低进行排序，然后将按照名次进行标记即可。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n        int n = score.length;\n        String[] desc = {\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"};\n        int[][] arr = new int[n][2];\n\n        for (int i = 0; i < n; ++i) {\n            arr[i][0] = score[i];\n            arr[i][1] = i;\n        }\n        Arrays.sort(arr, (a, b) -> b[0] - a[0]);\n        String[] ans = new String[n];\n        for (int i = 0; i < n; ++i) {\n            if (i >= 3) {\n                ans[arr[i][1]] = Integer.toString(i + 1);\n            } else {\n                ans[arr[i][1]] = desc[i];\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        string desc[3] = {\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"};\n        vector<pair<int, int>> arr;\n\n        for (int i = 0; i < n; ++i) {\n            arr.emplace_back(make_pair(-score[i], i));\n        }\n        sort(arr.begin(), arr.end());\n        vector<string> ans(n);\n        for (int i = 0; i < n; ++i) {\n            if (i >= 3) {\n                ans[arr[i].second] = to_string(i + 1);\n            } else {\n                ans[arr[i].second] = desc[i];\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string[] FindRelativeRanks(int[] score) {\n        int n = score.Length;\n        string[] desc = {\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"};\n        int[][] arr = new int[n][];\n\n        for (int i = 0; i < n; ++i) {\n            arr[i] = new int[2];\n            arr[i][0] = score[i];\n            arr[i][1] = i;\n        }\n        Array.Sort(arr, (a, b) => b[0] - a[0]);\n        string[] ans = new string[n];\n        for (int i = 0; i < n; ++i) {\n            if (i >= 3) {\n                ans[arr[i][1]] = (i + 1).ToString();\n            } else {\n                ans[arr[i][1]] = desc[i];\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findRelativeRanks = function(score) {\n    const n = score.length;\n    const desc = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"];\n    const arr = new Array(n).fill(0).map(() => new Array(2).fill(0));\n\n    for (let i = 0; i < n; ++i) {\n        arr[i][0] = score[i];\n        arr[i][1] = i;\n    }\n    arr.sort((a, b) => b[0] - a[0]);\n    const ans = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        if (i >= 3) {\n            ans[arr[i][1]] = '' + (i + 1);\n        } else {\n            ans[arr[i][1]] = desc[i];\n        }\n    }\n    return ans;\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    desc = (\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\")\n\n    def findRelativeRanks(self, score: List[int]) -> List[str]:\n        ans = [\"\"] * len(score)\n        arr = sorted(enumerate(score), key=lambda x: -x[1])\n        for i, (idx, _) in enumerate(arr):\n            ans[idx] = self.desc[i] if i < 3 else str(i + 1)\n        return ans\n```\n\n```go [sol1-Golang]\nvar desc = [3]string{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"}\n\nfunc findRelativeRanks(score []int) []string {\n    n := len(score)\n    type pair struct{ score, idx int }\n    arr := make([]pair, n)\n    for i, s := range score {\n        arr[i] = pair{s, i}\n    }\n    sort.Slice(arr, func(i, j int) bool { return arr[i].score > arr[j].score })\n\n    ans := make([]string, n)\n    for i, p := range arr {\n        if i < 3 {\n            ans[p.idx] = desc[i]\n        } else {\n            ans[p.idx] = strconv.Itoa(i + 1)\n        }\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 为数组的长度。我们需要对数组进行一次排序，因此时间复杂度为 $O(n \\log n)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为数组的长度。"
}