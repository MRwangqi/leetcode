{
	"titleSlug": "baseball-game",
	"slug": "bang-qiu-bi-sai-by-leetcode-solution-gxab",
	"url": "https://leetcode-cn.com/problems/baseball-game/solution/bang-qiu-bi-sai-by-leetcode-solution-gxab/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n使用变长数组对栈进行模拟。\n\n+ 如果操作是 $+$，那么访问数组的后两个得分，将两个得分之和加到总得分，并且将两个得分之和入栈。\n\n+ 如果操作是 $\\text{D}$，那么访问数组的最后一个得分，将得分乘以 $2$ 加到总得分，并且将得分乘以 $2$ 入栈。\n\n+ 如果操作是 $\\text{C}$，那么访问数组的最后一个得分，将总得分减去该得分，并且将该得分出栈。\n\n+ 如果操作是整数，那么将该整数加到总得分，并且将该整数入栈。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def calPoints(self, ops: List[str]) -> int:\n        ans = 0\n        points = []\n        for op in ops:\n            if op == '+':\n                pt = points[-1] + points[-2]\n            elif op == 'D':\n                pt = points[-1] * 2\n            elif op == 'C':\n                ans -= points.pop()\n                continue\n            else:\n                pt = int(op)\n            ans += pt\n            points.append(pt)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int calPoints(vector<string>& ops) {\n        int ret = 0;\n        vector<int> points;\n        for (auto &op : ops) {\n            int n = points.size();\n            switch (op[0]) {\n                case '+':\n                    ret += points[n - 1] + points[n - 2];\n                    points.push_back(points[n - 1] + points[n - 2]);\n                    break;\n                case 'D':\n                    ret += 2 * points[n - 1];\n                    points.push_back(2 * points[n - 1]);\n                    break;\n                case 'C':\n                    ret -= points[n - 1];\n                    points.pop_back();\n                    break;\n                default:\n                    ret += stoi(op);\n                    points.push_back(stoi(op));\n                    break;\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int calPoints(String[] ops) {\n        int ret = 0;\n        List<Integer> points = new ArrayList<Integer>();\n        for (String op : ops) {\n            int n = points.size();\n            switch (op.charAt(0)) {\n                case '+':\n                    ret += points.get(n - 1) + points.get(n - 2);\n                    points.add(points.get(n - 1) + points.get(n - 2));\n                    break;\n                case 'D':\n                    ret += 2 * points.get(n - 1);\n                    points.add(2 * points.get(n - 1));\n                    break;\n                case 'C':\n                    ret -= points.get(n - 1);\n                    points.remove(n - 1);\n                    break;\n                default:\n                    ret += Integer.parseInt(op);\n                    points.add(Integer.parseInt(op));\n                    break;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int CalPoints(string[] ops) {\n        int ret = 0;\n        IList<int> points = new List<int>();\n        foreach (string op in ops) {\n            int n = points.Count;\n            switch (op[0]) {\n                case '+':\n                    ret += points[n - 1] + points[n - 2];\n                    points.Add(points[n - 1] + points[n - 2]);\n                    break;\n                case 'D':\n                    ret += 2 * points[n - 1];\n                    points.Add(2 * points[n - 1]);\n                    break;\n                case 'C':\n                    ret -= points[n - 1];\n                    points.RemoveAt(n - 1);\n                    break;\n                default:\n                    ret += int.Parse(op);\n                    points.Add(int.Parse(op));\n                    break;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol1-C]\nint calPoints(char ** ops, int opsSize){\n    int ret = 0;\n    int * points = (int *)malloc(sizeof(int) * opsSize);\n    int pos = 0;\n    for (int i = 0; i < opsSize; i++) {\n        switch (ops[i][0]) {\n            case '+':\n                ret += points[pos - 1] + points[pos - 2];\n                points[pos++] = points[pos - 1] + points[pos - 2];\n                break;\n            case 'D':\n                ret += 2 * points[pos - 1];\n                points[pos++] = 2 * points[pos - 1];\n                break;\n            case 'C':\n                ret -= points[pos - 1];\n                pos--;\n                break;\n            default:\n                ret += atoi(ops[i]);\n                points[pos++] = atoi(ops[i]);\n                break;\n        }\n    }\n    free(points);\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar calPoints = function(ops) {\n    let ret = 0;\n    const points = [];\n    for (const op of ops) {\n        const n = points.length;\n        switch (op[0]) {\n            case '+':\n                ret += points[n - 1] + points[n - 2];\n                points.push(points[n - 1] + points[n - 2]);\n                break;\n            case 'D':\n                ret += 2 * points[n - 1];\n                points.push(2 * points[n - 1]);\n                break;\n            case 'C':\n                ret -= points[n - 1];\n                points.pop();\n                break;\n            default:\n                ret += parseInt(op);\n                points.push(parseInt(op));\n                break;\n        }\n    }\n    return ret;\n};\n```\n\n```go [sol1-Golang]\nfunc calPoints(ops []string) (ans int) {\n    points := []int{}\n    for _, op := range ops {\n        n := len(points)\n        switch op[0] {\n        case '+':\n            ans += points[n-1] + points[n-2]\n            points = append(points, points[n-1]+points[n-2])\n        case 'D':\n            ans += points[n-1] * 2\n            points = append(points, 2*points[n-1])\n        case 'C':\n            ans -= points[n-1]\n            points = points[:len(points)-1]\n        default:\n            pt, _ := strconv.Atoi(op)\n            ans += pt\n            points = append(points, pt)\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{ops}$ 的大小。遍历整个 $\\textit{ops}$ 需要 $O(n)$。\n\n+ 空间复杂度：$O(n)$。变长数组最多保存 $O(n)$ 个元素。"
}