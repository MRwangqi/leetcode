{
	"titleSlug": "is-graph-bipartite",
	"slug": "pan-duan-er-fen-tu-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![785. åˆ¤æ–­äºŒåˆ†å›¾.mp4](1605a49e-55cc-4306-84da-79e7e53ce8af)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### å‰è¨€\n\nå¯¹äºå›¾ä¸­çš„ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ $u$ å’Œ $v$ï¼Œå¦‚æœå®ƒä»¬ä¹‹é—´æœ‰ä¸€æ¡è¾¹ç›´æ¥ç›¸è¿ï¼Œé‚£ä¹ˆ $u$ å’Œ $v$ å¿…é¡»å±äºä¸åŒçš„é›†åˆã€‚\n\nå¦‚æœç»™å®šçš„æ— å‘å›¾è¿é€šï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ä»»é€‰ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹ï¼Œç»™å®ƒæŸ“æˆçº¢è‰²ã€‚éšåæˆ‘ä»¬å¯¹æ•´ä¸ªå›¾è¿›è¡Œéå†ï¼Œå°†è¯¥èŠ‚ç‚¹ç›´æ¥ç›¸è¿çš„æ‰€æœ‰èŠ‚ç‚¹æŸ“æˆç»¿è‰²ï¼Œè¡¨ç¤ºè¿™äº›èŠ‚ç‚¹ä¸èƒ½ä¸èµ·å§‹èŠ‚ç‚¹å±äºåŒä¸€ä¸ªé›†åˆã€‚æˆ‘ä»¬å†å°†è¿™äº›ç»¿è‰²èŠ‚ç‚¹ç›´æ¥ç›¸è¿çš„æ‰€æœ‰èŠ‚ç‚¹æŸ“æˆçº¢è‰²ï¼Œä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°æ— å‘å›¾ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹å‡è¢«æŸ“è‰²ã€‚\n\nå¦‚æœæˆ‘ä»¬èƒ½å¤ŸæˆåŠŸæŸ“è‰²ï¼Œé‚£ä¹ˆçº¢è‰²å’Œç»¿è‰²çš„èŠ‚ç‚¹å„å±äºä¸€ä¸ªé›†åˆï¼Œè¿™ä¸ªæ— å‘å›¾å°±æ˜¯ä¸€ä¸ªäºŒåˆ†å›¾ï¼›å¦‚æœæˆ‘ä»¬æœªèƒ½æˆåŠŸæŸ“è‰²ï¼Œå³åœ¨æŸ“è‰²çš„è¿‡ç¨‹ä¸­ï¼ŒæŸä¸€æ—¶åˆ»è®¿é—®åˆ°äº†ä¸€ä¸ªå·²ç»æŸ“è‰²çš„èŠ‚ç‚¹ï¼Œå¹¶ä¸”å®ƒçš„é¢œè‰²ä¸æˆ‘ä»¬å°†è¦ç»™å®ƒæŸ“ä¸Šçš„é¢œè‰²ä¸ç›¸åŒï¼Œä¹Ÿå°±è¯´æ˜è¿™ä¸ªæ— å‘å›¾ä¸æ˜¯ä¸€ä¸ªäºŒåˆ†å›¾ã€‚\n\nç®—æ³•çš„æµç¨‹å¦‚ä¸‹ï¼š\n\n- æˆ‘ä»¬ä»»é€‰ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹ï¼Œå°†å…¶æŸ“æˆçº¢è‰²ï¼Œå¹¶ä»è¯¥èŠ‚ç‚¹å¼€å§‹å¯¹æ•´ä¸ªæ— å‘å›¾è¿›è¡Œéå†ï¼›\n\n- åœ¨éå†çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœæˆ‘ä»¬é€šè¿‡èŠ‚ç‚¹ $u$ éå†åˆ°äº†èŠ‚ç‚¹ $v$ï¼ˆå³ $u$ å’Œ $v$ åœ¨å›¾ä¸­æœ‰ä¸€æ¡è¾¹ç›´æ¥ç›¸è¿ï¼‰ï¼Œé‚£ä¹ˆä¼šæœ‰ä¸¤ç§æƒ…å†µï¼š\n\n    - å¦‚æœ $v$ æœªè¢«æŸ“è‰²ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†å…¶æŸ“æˆä¸ $u$ ä¸åŒçš„é¢œè‰²ï¼Œå¹¶å¯¹ $v$ ç›´æ¥ç›¸è¿çš„èŠ‚ç‚¹è¿›è¡Œéå†ï¼›\n\n    - å¦‚æœ $v$ è¢«æŸ“è‰²ï¼Œå¹¶ä¸”é¢œè‰²ä¸ $u$ ç›¸åŒï¼Œé‚£ä¹ˆè¯´æ˜ç»™å®šçš„æ— å‘å›¾ä¸æ˜¯äºŒåˆ†å›¾ã€‚æˆ‘ä»¬å¯ä»¥ç›´æ¥é€€å‡ºéå†å¹¶è¿”å› $\\text{false}$ ä½œä¸ºç­”æ¡ˆã€‚\n\n- å½“éå†ç»“æŸæ—¶ï¼Œè¯´æ˜ç»™å®šçš„æ— å‘å›¾æ˜¯äºŒåˆ†å›¾ï¼Œè¿”å› $\\text{true}$ ä½œä¸ºç­”æ¡ˆã€‚\n\næˆ‘ä»¬å¯ä»¥ä½¿ç”¨ã€Œæ·±åº¦ä¼˜å…ˆæœç´¢ã€æˆ–ã€Œå¹¿åº¦ä¼˜å…ˆæœç´¢ã€å¯¹æ— å‘å›¾è¿›è¡Œéå†ï¼Œä¸‹æ–‡åˆ†åˆ«ç»™å‡ºäº†è¿™ä¸¤ç§æœç´¢å¯¹åº”çš„ä»£ç ã€‚\n\næ³¨æ„ï¼šé¢˜ç›®ä¸­ç»™å®šçš„æ— å‘å›¾ä¸ä¸€å®šä¿è¯è¿é€šï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è¿›è¡Œå¤šæ¬¡éå†ï¼Œç›´åˆ°æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½è¢«æŸ“è‰²ï¼Œæˆ–ç¡®å®šç­”æ¡ˆä¸º $\\text{false}$ ä¸ºæ­¢ã€‚æ¯æ¬¡éå†å¼€å§‹æ—¶ï¼Œæˆ‘ä»¬ä»»é€‰ä¸€ä¸ªæœªè¢«æŸ“è‰²çš„èŠ‚ç‚¹ï¼Œå°†æ‰€æœ‰ä¸è¯¥èŠ‚ç‚¹ç›´æ¥æˆ–é—´æ¥ç›¸è¿çš„èŠ‚ç‚¹è¿›è¡ŒæŸ“è‰²ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    static constexpr int UNCOLORED = 0;\n    static constexpr int RED = 1;\n    static constexpr int GREEN = 2;\n    vector<int> color;\n    bool valid;\n\npublic:\n    void dfs(int node, int c, const vector<vector<int>>& graph) {\n        color[node] = c;\n        int cNei = (c == RED ? GREEN : RED);\n        for (int neighbor: graph[node]) {\n            if (color[neighbor] == UNCOLORED) {\n                dfs(neighbor, cNei, graph);\n                if (!valid) {\n                    return;\n                }\n            }\n            else if (color[neighbor] != cNei) {\n                valid = false;\n                return;\n            }\n        }\n    }\n\n    bool isBipartite(vector<vector<int>>& graph) {\n        int n = graph.size();\n        valid = true;\n        color.assign(n, UNCOLORED);\n        for (int i = 0; i < n && valid; ++i) {\n            if (color[i] == UNCOLORED) {\n                dfs(i, RED, graph);\n            }\n        }\n        return valid;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    private static final int UNCOLORED = 0;\n    private static final int RED = 1;\n    private static final int GREEN = 2;\n    private int[] color;\n    private boolean valid;\n\n    public boolean isBipartite(int[][] graph) {\n        int n = graph.length;\n        valid = true;\n        color = new int[n];\n        Arrays.fill(color, UNCOLORED);\n        for (int i = 0; i < n && valid; ++i) {\n            if (color[i] == UNCOLORED) {\n                dfs(i, RED, graph);\n            }\n        }\n        return valid;\n    }\n\n    public void dfs(int node, int c, int[][] graph) {\n        color[node] = c;\n        int cNei = c == RED ? GREEN : RED;\n        for (int neighbor : graph[node]) {\n            if (color[neighbor] == UNCOLORED) {\n                dfs(neighbor, cNei, graph);\n                if (!valid) {\n                    return;\n                }\n            } else if (color[neighbor] != cNei) {\n                valid = false;\n                return;\n            }\n        }\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        n = len(graph)\n        UNCOLORED, RED, GREEN = 0, 1, 2\n        color = [UNCOLORED] * n\n        valid = True\n\n        def dfs(node: int, c: int):\n            nonlocal valid\n            color[node] = c\n            cNei = (GREEN if c == RED else RED)\n            for neighbor in graph[node]:\n                if color[neighbor] == UNCOLORED:\n                    dfs(neighbor, cNei)\n                    if not valid:\n                        return\n                elif color[neighbor] != cNei:\n                    valid = False\n                    return\n\n        for i in range(n):\n            if color[i] == UNCOLORED:\n                dfs(i, RED)\n                if not valid:\n                    break\n        \n        return valid\n\n```\n\n```C [sol1-C]\nbool dfs(int node, int c, int* color, int** graph, int* graphColSize) {\n    color[node] = c;\n    int cNei = (c == 1 ? 2 : 1);\n    for (int i = 0; i < graphColSize[node]; ++i) {\n        int neighbor = graph[node][i];\n        if (color[neighbor] == 0) {\n            if (!dfs(neighbor, cNei, color, graph, graphColSize)) {\n                return false;\n            }\n        } else if (color[neighbor] != cNei) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool isBipartite(int** graph, int graphSize, int* graphColSize) {\n    int* color = (int*)malloc(sizeof(int) * graphSize);\n    memset(color, 0, sizeof(int) * graphSize);\n    for (int i = 0; i < graphSize; ++i) {\n        if (color[i] == 0) {\n            if (!dfs(i, 1, color, graph, graphColSize)) {\n                free(color);\n                return false;\n            }\n        }\n    }\n    free(color);\n    return true;\n}\n```\n\n```golang [sol1-Golang]\nvar (\n    UNCOLORED, RED, GREEN = 0, 1, 2\n    color []int\n    valid bool\n)\n\nfunc isBipartite(graph [][]int) bool {\n    n := len(graph)\n    valid = true\n    color = make([]int, n)\n    for i := 0; i < n && valid; i++ {\n        if color[i] == UNCOLORED {\n            dfs(i, RED, graph)\n        }\n    }\n    return valid\n}\n\nfunc dfs(node, c int, graph [][]int) {\n    color[node] = c\n    cNei := RED\n    if c == RED {\n        cNei = GREEN\n    }\n    for _, neighbor := range graph[node] {\n        if color[neighbor] == UNCOLORED {\n            dfs(neighbor, cNei, graph)\n            if !valid {\n                return \n            }\n        } else if color[neighbor] != cNei {\n            valid = false\n            return\n        }\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n+m)$ï¼Œå…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«æ˜¯æ— å‘å›¾ä¸­çš„ç‚¹æ•°å’Œè¾¹æ•°ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå­˜å‚¨èŠ‚ç‚¹é¢œè‰²çš„æ•°ç»„éœ€è¦ $O(n)$ çš„ç©ºé—´ï¼Œå¹¶ä¸”åœ¨æ·±åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œæ ˆçš„æ·±åº¦æœ€å¤§ä¸º $n$ï¼Œéœ€è¦ $O(n)$ çš„ç©ºé—´ã€‚\n\n#### æ–¹æ³•äºŒï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢\n\n```C++ [sol2-C++]\nclass Solution {\nprivate:\n    static constexpr int UNCOLORED = 0;\n    static constexpr int RED = 1;\n    static constexpr int GREEN = 2;\n    vector<int> color;\n\npublic:\n    bool isBipartite(vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<int> color(n, UNCOLORED);\n        for (int i = 0; i < n; ++i) {\n            if (color[i] == UNCOLORED) {\n                queue<int> q;\n                q.push(i);\n                color[i] = RED;\n                while (!q.empty()) {\n                    int node = q.front();\n                    int cNei = (color[node] == RED ? GREEN : RED);\n                    q.pop();\n                    for (int neighbor: graph[node]) {\n                        if (color[neighbor] == UNCOLORED) {\n                            q.push(neighbor);\n                            color[neighbor] = cNei;\n                        }\n                        else if (color[neighbor] != cNei) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    private static final int UNCOLORED = 0;\n    private static final int RED = 1;\n    private static final int GREEN = 2;\n    private int[] color;\n\n    public boolean isBipartite(int[][] graph) {\n        int n = graph.length;\n        color = new int[n];\n        Arrays.fill(color, UNCOLORED);\n        for (int i = 0; i < n; ++i) {\n            if (color[i] == UNCOLORED) {\n                Queue<Integer> queue = new LinkedList<Integer>();\n                queue.offer(i);\n                color[i] = RED;\n                while (!queue.isEmpty()) {\n                    int node = queue.poll();\n                    int cNei = color[node] == RED ? GREEN : RED;\n                    for (int neighbor : graph[node]) {\n                        if (color[neighbor] == UNCOLORED) {\n                            queue.offer(neighbor);\n                            color[neighbor] = cNei;\n                        } else if (color[neighbor] != cNei) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        n = len(graph)\n        UNCOLORED, RED, GREEN = 0, 1, 2\n        color = [UNCOLORED] * n\n        \n        for i in range(n):\n            if color[i] == UNCOLORED:\n                q = collections.deque([i])\n                color[i] = RED\n                while q:\n                    node = q.popleft()\n                    cNei = (GREEN if color[node] == RED else RED)\n                    for neighbor in graph[node]:\n                        if color[neighbor] == UNCOLORED:\n                            q.append(neighbor)\n                            color[neighbor] = cNei\n                        elif color[neighbor] != cNei:\n                            return False\n\n        return True\n```\n\n```C [sol2-C]\nbool isBipartite(int** graph, int graphSize, int* graphColSize) {\n    int* color = (int*)malloc(sizeof(int) * graphSize);\n    memset(color, 0, sizeof(int) * graphSize);\n\n    int* q = (int*)malloc(sizeof(int) * graphSize);\n    for (int i = 0; i < graphSize; ++i) {\n        if (color[i] == 0) {\n            int l = 0, r = 0;\n            q[0] = i;\n            color[i] = 1;\n            while (l <= r) {\n                int node = q[l++];\n                int cNei = (color[node] == 1 ? 2 : 1);\n                for (int j = 0; j < graphColSize[node]; ++j) {\n                    int neighbor = graph[node][j];\n                    if (color[neighbor] == 0) {\n                        q[++r] = neighbor;\n                        color[neighbor] = cNei;\n                    } else if (color[neighbor] != cNei) {\n                        free(color);\n                        free(q);\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    free(color);\n    free(q);\n    return true;\n}\n```\n\n```golang [sol2-Golang]\nvar (\n    UNCOLORED, RED, GREEN = 0, 1, 2\n)\n\nfunc isBipartite(graph [][]int) bool {\n    n := len(graph)\n    color := make([]int, n)\n    for i := 0; i < n; i++ {\n        if color[i] == UNCOLORED {\n            queue := []int{}\n            queue = append(queue, i)\n            color[i] = RED\n            for i := 0; i < len(queue); i++ {\n                node := queue[i]\n                cNei := RED\n                if color[node] == RED {\n                    cNei = GREEN\n                }\n                for _, neighbor := range graph[node] {\n                    if color[neighbor] == UNCOLORED {\n                        queue = append(queue, neighbor)\n                        color[neighbor] = cNei\n                    } else if color[neighbor] != cNei {\n                        return false\n                    } \n                }\n            }\n        }\n    }\n    return true\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n+m)$ï¼Œå…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«æ˜¯æ— å‘å›¾ä¸­çš„ç‚¹æ•°å’Œè¾¹æ•°ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå­˜å‚¨èŠ‚ç‚¹é¢œè‰²çš„æ•°ç»„éœ€è¦ $O(n)$ çš„ç©ºé—´ï¼Œå¹¶ä¸”åœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œé˜Ÿåˆ—ä¸­æœ€å¤šæœ‰ $n-1$ ä¸ªèŠ‚ç‚¹ï¼Œéœ€è¦ $O(n)$ çš„ç©ºé—´ã€‚"
}