{
	"titleSlug": "minimum-index-sum-of-two-lists",
	"slug": "liang-ge-lie-biao-de-zui-xiao-suo-yin-zo-5m9w",
	"url": "https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/solution/liang-ge-lie-biao-de-zui-xiao-suo-yin-zo-5m9w/",
	"content": "#### 方法一：哈希表\n\n**思路与算法**\n\n使用一个哈希表记录 $\\textit{list}_1$ 中每个餐厅对应的索引下标，然后遍历 $\\textit{list}_2$，如果 $\\textit{list}_2$ 中的餐厅存在于哈希表中，那么说明该餐厅是两人共同喜爱的，计算它的索引和。如果该索引和比最小索引和小，则清空结果，将该餐厅加入结果中，该索引和作为最小索引和；如果该索引和等于最小索引和，则直接将该餐厅加入结果中。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        index = {s: i for i, s in enumerate(list1)}\n        ans = []\n        indexSum = inf\n        for i, s in enumerate(list2):\n            if s in index:\n                j = index[s]\n                if i + j < indexSum:\n                    indexSum = i + j\n                    ans = [s]\n                elif i + j == indexSum:\n                    ans.append(s)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n        unordered_map<string, int> index;\n        for (int i = 0; i < list1.size(); i++) {\n            index[list1[i]] = i;\n        }\n\n        vector<string> ret;\n        int indexSum = INT_MAX;\n        for (int i = 0; i < list2.size(); i++) {\n            if (index.count(list2[i]) > 0) {\n                int j = index[list2[i]];\n                if (i + j < indexSum) {\n                    ret.clear();\n                    ret.push_back(list2[i]);\n                    indexSum = i + j;\n                } else if (i + j == indexSum) {\n                    ret.push_back(list2[i]);\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String[] findRestaurant(String[] list1, String[] list2) {\n        Map<String, Integer> index = new HashMap<String, Integer>();\n        for (int i = 0; i < list1.length; i++) {\n            index.put(list1[i], i);\n        }\n\n        List<String> ret = new ArrayList<String>();\n        int indexSum = Integer.MAX_VALUE;\n        for (int i = 0; i < list2.length; i++) {\n            if (index.containsKey(list2[i])) {\n                int j = index.get(list2[i]);\n                if (i + j < indexSum) {\n                    ret.clear();\n                    ret.add(list2[i]);\n                    indexSum = i + j;\n                } else if (i + j == indexSum) {\n                    ret.add(list2[i]);\n                }\n            }\n        }\n        return ret.toArray(new String[ret.size()]);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string[] FindRestaurant(string[] list1, string[] list2) {\n        Dictionary<string, int> index = new Dictionary<string, int>();\n        for (int i = 0; i < list1.Length; i++) {\n            index.Add(list1[i], i);\n        }\n\n        IList<string> ret = new List<string>();\n        int indexSum = int.MaxValue;\n        for (int i = 0; i < list2.Length; i++) {\n            if (index.ContainsKey(list2[i])) {\n                int j = index[list2[i]];\n                if (i + j < indexSum) {\n                    ret.Clear();\n                    ret.Add(list2[i]);\n                    indexSum = i + j;\n                } else if (i + j == indexSum) {\n                    ret.Add(list2[i]);\n                }\n            }\n        }\n        return ret.ToArray();\n    }\n}\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\ntypedef struct {\n  char *key;\n  int val;\n  UT_hash_handle hh;\n} HashItem;\n\nvoid freeHash(HashItem ** obj) {\n    HashItem * curr = NULL, * next = NULL;\n    HASH_ITER(hh, *obj, curr, next) {\n      HASH_DEL(*obj, curr);\n      free(curr);\n    } \n}\n\nchar ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize){\n    HashItem * index = NULL;\n    HashItem * pEntry = NULL;\n    for (int i = 0; i < list1Size; i++) {\n        HASH_FIND_STR(index, list1[i], pEntry);\n        if (NULL == pEntry) {\n            pEntry = (HashItem *)malloc(sizeof(HashItem));\n            pEntry->key = list1[i];\n            pEntry->val = i;\n            HASH_ADD_STR(index, key, pEntry);\n        }\n    }\n\n    char ** ret = (char **)malloc(sizeof(char *) * MIN(list1Size, list2Size));\n    int pos = 0;\n    int indexSum = INT_MAX;\n    for (int i = 0; i < list2Size; i++) {\n        HASH_FIND_STR(index, list2[i], pEntry);\n        if (NULL != pEntry) {\n            int j = pEntry->val;\n            if (i + j < indexSum) {\n                pos = 0;\n                ret[pos++] = list2[i];\n                indexSum = i + j;\n            } else if (i + j == indexSum) {\n                ret[pos++] = list2[i];\n            }\n        }\n    }\n    freeHash(&index);\n    *returnSize = pos;\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findRestaurant = function(list1, list2) {\n    const index = new Map();\n    for (let i = 0; i < list1.length; i++) {\n        index.set(list1[i], i);\n    }\n\n    const ret = [];\n    let indexSum = Number.MAX_VALUE;\n    for (let i = 0; i < list2.length; i++) {\n        if (index.has(list2[i])) {\n            const j = index.get(list2[i]);\n            if (i + j < indexSum) {\n                ret.length = 0;\n                ret.push(list2[i]);\n                indexSum = i + j;\n            } else if (i + j == indexSum) {\n                ret.push(list2[i]);\n            }\n        }\n    }\n    return ret;\n};\n```\n\n```go [sol1-Golang]\nfunc findRestaurant(list1, list2 []string) (ans []string) {\n    index := make(map[string]int, len(list1))\n    for i, s := range list1 {\n        index[s] = i\n    }\n\n    indexSum := math.MaxInt32\n    for i, s := range list2 {\n        if j, ok := index[s]; ok {\n            if i+j < indexSum {\n                indexSum = i + j\n                ans = []string{s}\n            } else if i+j == indexSum {\n                ans = append(ans, s)\n            }\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(\\sum_1 + \\sum_2)$，其中 $\\sum_1$ 和 $\\sum_2$ 分别表示 $\\textit{list}_1$ 和 $\\textit{list}_2$ 中的字符串长度之和。建立哈希表需要 $O(\\sum_1)$，遍历 $\\textit{list}_2$ 需要 $O(\\sum_2)$。\n\n+ 空间复杂度：$O(\\sum_1)$。保存哈希表需要 $O(\\sum_1)$ 的空间，返回结果不计算空间复杂度。"
}