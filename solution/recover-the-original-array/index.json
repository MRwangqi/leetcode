{
	"titleSlug": "recover-the-original-array",
	"slug": "huan-yuan-yuan-shu-zu-by-leetcode-soluti-nizi",
	"url": "https://leetcode-cn.com/problems/recover-the-original-array/solution/huan-yuan-yuan-shu-zu-by-leetcode-soluti-nizi/",
	"content": "#### 方法一：枚举 + 双指针\n\n**思路与算法**\n\n我们首先将数组 $\\textit{arr}$ 按照升序排序。\n\n根据题目的要求，$\\textit{arr}$ 可以拆分成两个长度为 $n$ 的数组，并且对于元素较小的那个数组 $\\textit{lower}$ 中的每一个元素，在元素较大的那个数组 $\\textit{upper}$ 中都**唯一对应**着一个恰好比它大 $2k$ 的元素。当 $\\textit{arr}$ 有序时，最小的那个元素 $\\textit{arr}[0]$ 一定是属于 $\\textit{lower}$ 的，这样一来，我们就可以枚举 $\\textit{arr}$ 中剩余的 $2n-1$ 个元素，分别作为 $\\textit{arr}[0]$ 在 $\\textit{upper}$ 中唯一对应的元素，并判断剩余元素的合法性。\n\n假设 $\\textit{arr}[0]$ 对应着 $\\textit{arr}[i]$，那么我们就可以得到 $k$ 的值：\n\n$$\nk = \\frac{arr[i] - arr[0]}{2}\n$$\n\n由于 $k$ 是整数并且 $k > 0$，因此我们必须要求 $\\textit{arr}[0]$ 与 $\\textit{arr}[i]$ 同奇偶，并且它们的值不相等。在求出 $k$ 的值后，我们可以使用双指针的方法判断剩余的元素是否满足要求：\n\n- 我们用两个指针 $\\textit{left}$ 和 $\\textit{right}$ 分别指向 $0$ 和 $i$，其中 $\\textit{left}$ 的作用的是每次找到剩余元素中最小的那一个，它一定是属于 $\\textit{lower}$ 的；$\\textit{right}$ 的作用是指向恰好等于 $\\textit{arr}[\\textit{left}] + 2k$ 的元素，并且将 $\\textit{left}$ 和 $\\textit{right}$ 对应起来；\n\n- 我们还需要一个长度为 $2n$ 的数组，记录每一个元素是否被使用过。如果指针到达了已经被使用过的元素，则无需处理当前元素；\n\n- 由于我们还剩余 $2n-2$ 个元素，因此需要进行 $n-1$ 次对应操作。每一次操作中，我们首先向右移动 $\\textit{left}$ 指针，直到指针指向的元素没有被使用过，此时 $\\textit{arr}[\\textit{left}]$ 就是最小的未被使用过的元素，它一定属于 $\\textit{lower}$。随后我们向右移动 $\\textit{right}$ 指针，直到 $\\textit{arr}[\\textit{left}] + 2k = \\textit{arr}[\\textit{right}]$ 成立并且 $\\textit{arr}$ 未被使用过。如果不存在这样的元素，那么我们就可以断定剩余的元素无法满足要求；否则，我们就将 $\\textit{arr}[\\textit{left}]$ 和 $\\textit{arr}[\\textit{right}]$ 标记为「使用过」，并将 $\\textit{arr}[\\textit{left}] + k$（或 $\\textit{arr}[\\textit{right}] - k$）加入答案。\n\n由于题目保证了「生成的测试用例保证存在至少一个有效数组」，因此上述双指针的方法也一定能找到一个正确的答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> recoverArray(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] == nums[0] || (nums[i] - nums[0]) % 2 != 0) {\n                continue;\n            }\n            \n            vector<int> used(n);\n            used[0] = used[i] = true;\n            int k = (nums[i] - nums[0]) / 2;\n            vector<int> ans;\n            ans.push_back(nums[0] + k);\n            \n            int left = 0, right = i;\n            for (int j = 2; j + j <= n; ++j) {\n                while (used[left]) {\n                    ++left;\n                }\n                while (right < n && (used[right] || nums[right] - nums[left] != k * 2)) {\n                    ++right;\n                }\n                if (right == n) {\n                    break;\n                }\n                ans.push_back(nums[left] + k);\n                used[left] = used[right] = true;\n            }\n            \n            if (ans.size() == n / 2) {\n                return ans;\n            }\n        }\n        \n        // 题目保证一定有解，不会到这一步\n        return {};\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def recoverArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        nums.sort()\n        for i in range(1, n):\n            if nums[i] == nums[0] or (nums[i] - nums[0]) % 2 != 0:\n                continue\n            \n            used = [False] * n\n            used[0] = used[i] = True\n            k = (nums[i] - nums[0]) // 2\n            ans = [nums[0] + k]\n            \n            left, right = 0, i\n            for j in range(1, n // 2):\n                while used[left]:\n                    left += 1\n                while right < n and (used[right] or nums[right] - nums[left] != k * 2):\n                    right += 1\n                if right == n:\n                    break\n                ans.append(nums[left] + k)\n                used[left] = used[right] = True\n            \n            if len(ans) == n // 2:\n                return ans\n        \n        # 题目保证一定有解，不会到这一步\n        return None\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$。排序需要的时间为 $O(n \\log n)$。枚举 $\\textit{arr}[i]$ 需要的时间为 $O(n)$，双指针判断需要的时间为 $O(n)$，这一部分的总时间为 $O(n^2)$。\n\n- 空间复杂度：$O(n)$。排序需要 $O(\\log n)$ 的栈空间。在每一次枚举 $\\textit{arr}[i]$ 的过程中，我们需要 $O(n)$ 的空间记录每个元素是否被使用过，但枚举之间是互相独立的，因此一共也只需要 $O(n)$ 的空间。"
}