{
	"titleSlug": "subsets",
	"slug": "c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-",
	"url": "https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/",
	"content": "### 解题思路：\r\n#### 1.DFS 和回溯算法区别\r\nDFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置\r\n#### 2.何时使用回溯算法\r\n**当问题需要 \"回头\"，以此来查找出所有的解的时候**，使用回溯算法。即满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试，直到找出所有解为止\r\n\r\n#### 3.怎么样写回溯算法(从上而下，※代表难点，根据题目而变化)\r\n- **①画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要**※\r\n- **②根据题意，确立结束条件**\r\n- **③找准选择列表(与函数参数相关),与第一步紧密关联**※\r\n- **④判断是否需要剪枝**\r\n- **⑤作出选择，递归调用，进入下一层**\r\n- **⑥撤销选择**\r\n\r\n#### 4.回溯问题的类型\r\n这里先给出，我总结的回溯问题类型，并给出相应的 leetcode题目(一直更新)，然后再说如何去编写。**特别关注搜索类型的**，搜索类的搞懂，你就真的搞懂回溯算法了,，是前面两类是基础，帮助你培养思维\r\n类型     | 题目链接\r\n-------- | -----\r\n子集、组合  | [子集](https://leetcode-cn.com/problems/subsets/)、[子集 II](https://leetcode-cn.com/problems/subsets-ii/)、[组合](https://leetcode-cn.com/problems/combinations/)、[组合总和](https://leetcode-cn.com/problems/combination-sum/)、[组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)\r\n全排列  | [全排列](https://leetcode-cn.com/problems/permutations/)、[全排列 II](https://leetcode-cn.com/problems/permutations-ii/)、[字符串的全排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)、[字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)\r\n**搜索** | [解数独](https://leetcode-cn.com/problems/sudoku-solver/)、[单词搜索](https://leetcode-cn.com/problems/word-search/)、[N皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)、[分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)、[二进制手表](https://leetcode-cn.com/problems/binary-watch/)\r\n**注意：子集、组合与排列是不同性质的概念。子集、组合是无关顺序的，而排列是和元素顺序有关的，如 `[1，2]` 和 `[2，1]` 是同一个组合(子集)，但 `[1,2]` 和 `[2,1]` 是两种不一样的排列！！！！因此被分为两类问题**\r\n####  5.回到子集、组合类型问题上来(ABC 三道例题)\r\n##### A、 [子集](https://leetcode-cn.com/problems/subsets/) - 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\r\n解题步骤如下\r\n#### ①递归树\r\n![子集问题递归树.png](https://pic.leetcode-cn.com/d8e07f0c876d9175df9f679fcb92505d20a81f09b1cb559afc59a20044cc3e8c-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E9%80%92%E5%BD%92%E6%A0%91.png)\r\n观察上图可得，**选择列表里的数，都是选择路径(红色框)后面的数**，比如[1]这条路径，他后面的选择列表只有\"2、3\"，[2]这条路径后面只有\"3\"这个选择，那么这个时候，就应该**使用一个参数start，来标识当前的选择列表的起始位置。也就是标识每一层的状态，因此被形象的称为\"状态变量\"**,最终函数签名如下\r\n\r\n```C++ []\r\n//nums为题目中的给的数组\r\n//path为路径结果，要把每一条 path 加入结果集\r\nvoid backtrack(vector<int>nums,vector<int>&path,int start)\r\n```\r\n#### ②找结束条件\r\n此题非常特殊，所有路径都应该加入结果集，所以不存在结束条件。或者说当 start 参数越过数组边界的时候，程序就自己跳过下一层递归了，因此不需要手写结束条件,直接加入结果集\r\n\r\n```C++ []\r\n**res为结果集，是全局变量vector<vector<int>>res,到时候要返回的\r\nres.push_back(path);//把每一条路径加入结果集\r\n```\r\n\r\n#### ③找选择列表\r\n在①中已经提到过了，子集问题的选择列表，是上一条选择路径之后的数,即\r\n\r\n\r\n```C++ []\r\nfor(int i=start;i<nums.size();i++)\r\n```\r\n#### ④判断是否需要剪枝\r\n从递归树中看到，路径没有重复的，也没有不符合条件的，所以不需要剪枝\r\n\r\n#### ⑤做出选择(即for 循环里面的)\r\n\r\n```C++ []\r\nvoid backtrack(vector<int>nums,vector<int>&path,int start)\r\n{\r\n    for(int i=start;i<nums.size();i++)\r\n    {\r\n        path.push_back(nums[i]);//做出选择\r\n        backtrack(nums,path,i+1);//递归进入下一层，注意i+1，标识下一个选择列表的开始位置，最重要的一步\r\n    }\r\n}\r\n```\r\n#### ⑤撤销选择\r\n整体的 backtrack 函数如下\r\n```C++ []\r\nvoid backtrack(vector<int>nums,vector<int>&path,int start)\r\n{\r\n    res.push_back(path);\r\n    for(int i=start;i<nums.size();i++)\r\n    {\r\n        path.push_back(nums[i]);//做出选择\r\n        backtrack(nums,path,i+1);//递归进入下一层，注意i+1，标识下一个选择列表的开始位置，最重要的一步\r\n        path.pop_back();//撤销选择\r\n    }\r\n}\r\n```\r\n##### B、[子集 II](https://leetcode-cn.com/problems/subsets-ii/)(剪枝思想)--问题描述:\r\n给定一个可能 **包含重复元素** 的整数数组 nums，返回该数组所有可能的子集（幂集）。\r\n输入: [1,2,2]\r\n输出:\r\n[\r\n  [2],\r\n  [1],\r\n  [1,2,2],\r\n  [2,2],\r\n  [1,2],\r\n  []\r\n]\r\n#### 解题步骤\r\n#### ①递归树\r\n![在这里插入图片描述](https://pic.leetcode-cn.com/1ccf07d0ab33b4b28c2bedb316e262f1d344dffefb4debde33fda98da1e8429e.png)\r\n可以发现，树中出现了大量重复的集合，②和③和第一个问题一样，不再赘述，我们直接看第四步\r\n#### ④判断是否需要剪枝，需要先对数组排序，使用排序函数 `sort(nums.begin(),nums.end())`\r\n显然我们需要去除重复的集合，即需要剪枝，把递归树上的某些分支剪掉。那么应去除哪些分支呢？又该如何编码呢？\r\n#### 观察上图不难发现，应该去除当前选择列表中，与上一个数重复的那个数，引出的分支，如 “2，2” 这个选择列表，第二个 “2” 是最后重复的，应该去除这个 “2” 引出的分支\r\n![在这里插入图片描述](https://pic.leetcode-cn.com/7dd0461942d17bc38860b05a2b6a6461feae54ad141c64bfaace9127e1a29651.png)\r\n(去除图中红色大框中的分支)\r\n\r\n编码呢，刚刚说到是 “去除当前选择列表中，与上一个数重复的那个数，引出的分支”，说明当前列表最少有两个数，当i>start时，做选择的之前，比较一下当前数，与上一个数 `(i-1)` 是不是相同，相同则 continue,\r\n\r\n```C++ []\r\nvoid backtrack(vector<int>& nums,vector<int>&path,int start)\r\n    {\r\n        res.push_back(path);\r\n        for(int i=start;i<nums.size();i++)\r\n        {\r\n            if(i>start&&nums[i]==nums[i-1])//剪枝去重\r\n                continue;\r\n        }\r\n    }\r\n```\r\n#### ⑤做出选择\r\n```C++ []\r\nvoid backtrack(vector<int>& nums,vector<int>&path,int start)\r\n    {\r\n        res.push_back(path);\r\n        for(int i=start;i<nums.size();i++)\r\n        {\r\n            if(i>start&&nums[i]==nums[i-1])//剪枝去重\r\n                continue;\r\n            temp.push_back(nums[i]);\r\n            backtrack(nums,path,i+1);\r\n        }\r\n    }\r\n```\r\n#### ⑥撤销选择\r\n整体的backtrack函数如下\r\n\r\n```C++ []\r\n** sort(nums.begin(),nums.end());\r\nvoid backtrack(vector<int>& nums,vector<int>&path,int start)\r\n    {\r\n        res.push_back(path);\r\n        for(int i=start;i<nums.size();i++)\r\n        {\r\n            if(i>start&&nums[i]==nums[i-1])//剪枝去重\r\n                continue;\r\n            temp.push_back(nums[i]);\r\n            backtrack(nums,path,i+1);\r\n            temp.pop_back();\r\n        }\r\n    }\r\n```\r\n\r\n---\r\n##### C、[组合总和](https://leetcode-cn.com/problems/combination-sum/) - 问题描述\r\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\r\ncandidates 中的数字可以**无限制重复被选取**。\r\n输入: candidates = [1,2,3], target = 3,\r\n所求解集为:\r\n[\r\n  [1,1,1],\r\n  [1,2],\r\n  [3]\r\n]\r\n#### <font color=red>解题步骤</font>\r\n#### ①递归树\r\n![在这里插入图片描述](https://pic.leetcode-cn.com/95513b4b31c8570d7c3b4b29cb09169e1ae981800602ec44ff3cfa20d662b72a.png)\r\n\r\n\r\n\r\n\r\n(绿色箭头上面的是路径，红色框[]则为结果，黄色框为选择列表)\r\n从上图看出，组合问题和子集问题一样，`1,2` 和 2,1 `是同一个组合，因此 **需要引入start参数标识，每个状态中选择列表的起始位置**。另外，**每个状态还需要一个 sum 变量，来记录当前路径的和**，函数签名如下\r\n\r\n```C++ []\r\nvoid backtrack(vector<int>& nums,vector<int>&path,int start,int sum,int target)\r\n```\r\n\r\n#### ②找结束条件\r\n由题意可得，当路径总和等于 target 时候，就应该把路径加入结果集，并 return\r\n\r\n```C++ []\r\n if(target==sum)\r\n        {\r\n            res.push_back(path);\r\n            return;\r\n        }\r\n```\r\n#### ③找选择列表\r\n```C++ []\r\n for(int i=start;i<nums.size();i++)\r\n```\r\n#### ④判断是否需要剪枝\r\n从①中的递归树中发现，当前状态的sum大于target的时候就应该剪枝，不用再递归下去了\r\n\r\n```C++ []\r\n   for(int i=start;i<nums.size();i++)\r\n        {\r\n            if(sum>target)//剪枝\r\n                continue;\r\n        }\r\n```\r\n#### ⑤做出选择\r\n题中说数可以无限次被选择，那么 `i` 就不用 `+1` 。即下一层的选择列表，从自身开始。并且要更新当前状态的sum\r\n\r\n```C++ []\r\n   for(int i=start;i<nums.size();i++)\r\n        {\r\n            if(sum>target)\r\n                continue;\r\n            path.push_back(nums[i]);\r\n            backtrack(nums,path,i,sum+nums[i],target);//i不用+1(重复利用)，并更新当前状态的sum\r\n        }\r\n```\r\n#### ⑤撤销选择\r\n整体的 backtrack 函数如下\r\n```C++ []\r\nvoid backtrack(vector<int>& nums,vector<int>&path,int start,int sum,int target)\r\n{\r\n   for(int i=start;i<nums.size();i++)\r\n        {\r\n            if(sum>target)\r\n                continue;\r\n            path.push_back(nums[i]);\r\n            backtrack(nums,path,i,sum+nums[i],target);//更新i和当前状态的sum\r\n            pacht.pop_back();\r\n        }\r\n}\r\n```\r\n\r\n### 总结：子集、组合类问题，关键是用一个 start 参数来控制选择列表！！最后回溯六步走：\r\n- **①画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要**※\r\n- **②根据题意，确立结束条件**\r\n- **③找准选择列表(与函数参数相关),与第一步紧密关联**※\r\n- **④判断是否需要剪枝**\r\n- **⑤作出选择，递归调用，进入下一层**\r\n- **⑥撤销选择**\r\n\r\n下一节，将讲解排列类的回溯问题：\r\n\r\n请看： [C++ 总结了回溯问题类型 带你搞懂回溯算法(排列篇)](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-ga-4/)"
}