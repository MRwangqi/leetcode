{
	"titleSlug": "longest-substring-of-one-repeating-character",
	"slug": "by-endlesscheng-qpbw",
	"url": "https://leetcode-cn.com/problems/longest-substring-of-one-repeating-character/solution/by-endlesscheng-qpbw/",
	"content": "本题可以用线段树来做。有关线段树的入门讲解可以看我的 [这个视频](https://www.bilibili.com/video/BV18t4y1p736?t=8m7s)。\r\n\r\n线段树的做法可以让时空复杂度均与字符集的大小（本题为 $26$）无关，且可以通过额外的代码，支持查询 $s$ 任意子串的最长重复子串的长度（本题查询的是整个 $s$）。\r\n\r\n做法类似求动态最大子段和（[洛谷 P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)），线段树的每个节点维护对应区间的：\r\n\r\n- 前缀最长连续字符个数 $\\textit{pre}$；\r\n- 后缀最长连续字符个数 $\\textit{suf}$；\r\n- 该区间最长连续字符个数 $\\textit{max}$。\r\n\r\n合并两个子区间时，如果前一个区间（记作 $a$）的末尾字符等于后一个区间（记作 $b$）的第一个字符，则可以合并这两个区间：\r\n\r\n- 如果 $a$ 的 $\\textit{suf}$ 等于 $a$ 的长度，那么就可以把 $b$ 的 $\\textit{pre}$ 加到 $a$ 的 $\\textit{pre}$ 上；\r\n- 如果 $b$ 的 $\\textit{pre}$ 等于 $b$ 的长度，那么就可以把 $a$ 的 $\\textit{suf}$ 加到 $b$ 的 $\\textit{suf}$ 上；\r\n- $\\textit{a.suf} + \\textit{b.pre}$ 可以考虑成为合并后的区间的 $\\textit{max}$。\r\n\r\n具体见代码实现，大部分为线段树模板，主要逻辑是 `maintain` 的写法。\r\n\r\n更多有关线段树的资料整理和代码见我的 [算法竞赛模板库](https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/segment_tree.go)。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n+k\\log n)$，其中 $n$ 为 $s$ 的长度，$k$ 为 $\\textit{queryCharacters}$ 的长度。\r\n- 空间复杂度：$O(n)$。返回值的空间复杂度不计。\r\n\r\n```py [sol1-Python]\r\nclass Solution:\r\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\r\n        s = list(s)\r\n        n = len(s)\r\n        pre = [0] * (4 * n)\r\n        suf = [0] * (4 * n)\r\n        mx = [0] * (4 * n)\r\n\r\n        def maintain(o: int, l: int, r: int) -> None:\r\n            pre[o] = pre[o * 2]\r\n            suf[o] = suf[o * 2 + 1]\r\n            mx[o] = max(mx[o * 2], mx[o * 2 + 1])\r\n            m = (l + r) // 2\r\n            if s[m - 1] == s[m]:  # 中间字符相同，可以合并\r\n                if suf[o * 2] == m - l + 1:\r\n                    pre[o] += pre[o * 2 + 1]\r\n                if pre[o * 2 + 1] == r - m:\r\n                    suf[o] += suf[o * 2]\r\n                mx[o] = max(mx[o], suf[o * 2] + pre[o * 2 + 1])\r\n\r\n        def build(o: int, l: int, r: int) -> None:\r\n            if l == r:\r\n                pre[o] = suf[o] = mx[o] = 1\r\n                return\r\n            m = (l + r) // 2\r\n            build(o * 2, l, m)\r\n            build(o * 2 + 1, m + 1, r)\r\n            maintain(o, l, r)\r\n\r\n        def update(o: int, l: int, r: int, i: int) -> None:\r\n            if l == r: return\r\n            m = (l + r) // 2\r\n            if i <= m:\r\n                update(o * 2, l, m, i)\r\n            else:\r\n                update(o * 2 + 1, m + 1, r, i)\r\n            maintain(o, l, r)\r\n\r\n        build(1, 1, n)\r\n        ans = []\r\n        for c, i in zip(queryCharacters, queryIndices):\r\n            s[i] = c\r\n            update(1, 1, n, i + 1)\r\n            ans.append(mx[1])\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    char[] s;\r\n    int[] pre, suf, max;\r\n\r\n    void maintain(int o, int l, int r) {\r\n        pre[o] = pre[o << 1];\r\n        suf[o] = suf[o << 1 | 1];\r\n        max[o] = Math.max(max[o << 1], max[o << 1 | 1]);\r\n        var m = (l + r) >> 1;\r\n        if (s[m - 1] == s[m]) { // 中间字符相同，可以合并\r\n            if (suf[o << 1] == m - l + 1) pre[o] += pre[o << 1 | 1];\r\n            if (pre[o << 1 | 1] == r - m) suf[o] += suf[o << 1];\r\n            max[o] = Math.max(max[o], suf[o << 1] + pre[o << 1 | 1]);\r\n        }\r\n    }\r\n\r\n    void build(int o, int l, int r) {\r\n        if (l == r) {\r\n            pre[o] = suf[o] = max[o] = 1;\r\n            return;\r\n        }\r\n        var m = (l + r) / 2;\r\n        build(o << 1, l, m);\r\n        build(o << 1 | 1, m + 1, r);\r\n        maintain(o, l, r);\r\n    }\r\n\r\n    void update(int o, int l, int r, int i) {\r\n        if (l == r) return;\r\n        var m = (l + r) / 2;\r\n        if (i <= m) update(o << 1, l, m, i);\r\n        else update(o << 1 | 1, m + 1, r, i);\r\n        maintain(o, l, r);\r\n    }\r\n\r\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\r\n        this.s = s.toCharArray();\r\n        int n = this.s.length, m = queryIndices.length;\r\n        pre = new int[n << 2];\r\n        suf = new int[n << 2];\r\n        max = new int[n << 2];\r\n        build(1, 1, n);\r\n        var ans = new int[m];\r\n        for (var i = 0; i < m; ++i) {\r\n            this.s[queryIndices[i]] = queryCharacters.charAt(i);\r\n            update(1, 1, n, queryIndices[i] + 1);\r\n            ans[i] = max[1];\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\n    string s;\r\n    vector<int> pre, suf, max;\r\n\r\n    void maintain(int o, int l, int r) {\r\n        pre[o] = pre[o << 1];\r\n        suf[o] = suf[o << 1 | 1];\r\n        max[o] = std::max(max[o << 1], max[o << 1 | 1]);\r\n        int m = (l + r) >> 1;\r\n        if (s[m - 1] == s[m]) { // 中间字符相同，可以合并\r\n            if (suf[o << 1] == m - l + 1) pre[o] += pre[o << 1 | 1];\r\n            if (pre[o << 1 | 1] == r - m) suf[o] += suf[o << 1];\r\n            max[o] = std::max(max[o], suf[o << 1] + pre[o << 1 | 1]);\r\n        }\r\n    }\r\n\r\n    void build(int o, int l, int r) {\r\n        if (l == r) {\r\n            pre[o] = suf[o] = max[o] = 1;\r\n            return;\r\n        }\r\n        int m = (l + r) / 2;\r\n        build(o << 1, l, m);\r\n        build(o << 1 | 1, m + 1, r);\r\n        maintain(o, l, r);\r\n    }\r\n\r\n    void update(int o, int l, int r, int i) {\r\n        if (l == r) return;\r\n        int m = (l + r) / 2;\r\n        if (i <= m) update(o << 1, l, m, i);\r\n        else update(o << 1 | 1, m + 1, r, i);\r\n        maintain(o, l, r);\r\n    }\r\n\r\npublic:\r\n    vector<int> longestRepeating(string &s, string &queryCharacters, vector<int> &queryIndices) {\r\n        this->s = s;\r\n        int n = s.length(), m = queryIndices.size();\r\n        pre.resize(n << 2);\r\n        suf.resize(n << 2);\r\n        max.resize(n << 2);\r\n        build(1, 1, n);\r\n        vector<int> ans(m);\r\n        for (int i = 0; i < m; ++i) {\r\n            this->s[queryIndices[i]] = queryCharacters[i];\r\n            update(1, 1, n, queryIndices[i] + 1);\r\n            ans[i] = max[1];\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nvar s []byte\r\n\r\ntype seg []struct{ l, r, pre, suf, max int }\r\n\r\nfunc (t seg) maintain(o int) {\r\n\tlo, ro := t[o<<1], t[o<<1|1]\r\n\tt[o].pre = lo.pre\r\n\tt[o].suf = ro.suf\r\n\tt[o].max = max(lo.max, ro.max)\r\n\tif s[lo.r-1] == s[lo.r] { // 中间字符相同，可以合并\r\n\t\tif lo.suf == lo.r-lo.l+1 {\r\n\t\t\tt[o].pre += ro.pre\r\n\t\t}\r\n\t\tif ro.pre == ro.r-ro.l+1 {\r\n\t\t\tt[o].suf += lo.suf\r\n\t\t}\r\n\t\tt[o].max = max(t[o].max, lo.suf+ro.pre)\r\n\t}\r\n}\r\n\r\nfunc (t seg) build(o, l, r int) {\r\n\tt[o].l, t[o].r = l, r\r\n\tif l == r {\r\n\t\tt[o].pre = 1\r\n\t\tt[o].suf = 1\r\n\t\tt[o].max = 1\r\n\t\treturn\r\n\t}\r\n\tm := (l + r) >> 1\r\n\tt.build(o<<1, l, m)\r\n\tt.build(o<<1|1, m+1, r)\r\n\tt.maintain(o)\r\n}\r\n\r\nfunc (t seg) update(o, i int) {\r\n\tif t[o].l == t[o].r {\r\n\t\treturn\r\n\t}\r\n\tm := (t[o].l + t[o].r) >> 1\r\n\tif i <= m {\r\n\t\tt.update(o<<1, i)\r\n\t} else {\r\n\t\tt.update(o<<1|1, i)\r\n\t}\r\n\tt.maintain(o)\r\n}\r\n\r\nfunc longestRepeating(S, queryCharacters string, queryIndices []int) []int {\r\n\ts = []byte(S)\r\n\tn := len(s)\r\n\tt := make(seg, n*4)\r\n\tt.build(1, 1, n)\r\n\tans := make([]int, len(queryIndices))\r\n\tfor i, index := range queryIndices {\r\n\t\ts[index] = queryCharacters[i]\r\n\t\tt.update(1, index+1)\r\n\t\tans[i] = t[1].max\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n"
}