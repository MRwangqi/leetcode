{
	"titleSlug": "replace-elements-in-an-array",
	"slug": "naojin-by-endlesscheng-aq0n",
	"url": "https://leetcode-cn.com/problems/replace-elements-in-an-array/solution/naojin-by-endlesscheng-aq0n/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1w34y1L7yu/) 已出炉，欢迎三连~\r\n\r\n---\r\n\r\n## 方法一：正序\r\n\r\n注意到 $\\textit{nums}$ 的元素互不相同，且每次操作总是将一个在 $\\textit{nums}$ 中的元素变成一个不在 $\\textit{nums}$ 中的元素，因此每次操作之后 $\\textit{nums}$ 的元素仍然互不相同。\r\n\r\n用哈希表存储每个元素的位置，然后遍历 $\\textit{operations}$ 数组模拟即可。\r\n\r\n```python [sol1-Python]\r\nclass Solution:\r\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\r\n        idx = {num: i for i, num in enumerate(nums)}\r\n        for x, y in operations:\r\n            i = idx[x]\r\n            nums[i] = y\r\n            del idx[x]\r\n            idx[y] = i\r\n        return nums\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc arrayChange(nums []int, operations [][]int) []int {\r\n\tidx := make(map[int]int, len(nums))\r\n\tfor i, num := range nums {\r\n\t\tidx[num] = i\r\n\t}\r\n\tfor _, op := range operations {\r\n\t\tx, y := op[0], op[1]\r\n\t\ti := idx[x]\r\n\t\tnums[i] = y\r\n\t\tdelete(idx, x)\r\n\t\tidx[y] = i\r\n\t}\r\n\treturn nums\r\n}\r\n```\r\n\r\n## 方法二：逆序\r\n\r\n如果 $\\textit{nums}$ 中有重复元素呢？有没有更加通用的做法？\r\n\r\n设 $x=\\textit{operations}[i][0]$，$y=\\textit{operations}[i][1]$，我们可以倒着遍历 $\\textit{operations}$，同时用一个哈希表 $\\textit{mp}$ 将 $x$ 映射到 $\\textit{mp}[y]$ 上，如果 $\\textit{mp}[y]$ 不存在则直接映射到 $y$ 上。\r\n\r\n例如，先把 $1$ 变成 $2$，再把 $2$ 变成 $3$，如果倒着来的话，就是 $2$ 变成 $3$，那么对于 $1$ 来说，可以直接知道**最终**是会变成 $3$ 的。\r\n\r\n```Python [sol2-Python3]\r\nclass Solution:\r\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\r\n        mp = {}\r\n        for x, y in reversed(operations):\r\n            mp[x] = mp.get(y, y)\r\n        return [mp.get(num, num) for num in nums]\r\n```\r\n\r\n```go [sol2-Go]\r\nfunc arrayChange(nums []int, operations [][]int) []int {\r\n\tmp := map[int]int{}\r\n\tfor i := len(operations) - 1; i >= 0; i-- {\r\n\t\tp := operations[i]\r\n\t\tx, y := p[0], p[1]\r\n\t\tif mpY, ok := mp[y]; ok {\r\n\t\t\ty = mpY\r\n\t\t}\r\n\t\tmp[x] = y\r\n\t}\r\n\tfor i, num := range nums {\r\n\t\tif m, ok := mp[num]; ok {\r\n\t\t\tnums[i] = m\r\n\t\t}\r\n\t}\r\n\treturn nums\r\n}\r\n```\r\n\r\n"
}