{
	"titleSlug": "number-of-increasing-paths-in-a-grid",
	"slug": "ji-yi-hua-sou-suo-pythonjavacgo-by-endle-xecc",
	"url": "https://leetcode-cn.com/problems/number-of-increasing-paths-in-a-grid/solution/ji-yi-hua-sou-suo-pythonjavacgo-by-endle-xecc/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1Yf4y1Z7Ac) 已出炉，包含本题可以使用记忆化搜索的原理，欢迎点赞三连~\r\n\r\n---\r\n\r\n根据题意，我们可以遍历每个格子，以这个格子为起点，往上下左右四个方向前进，如果下一个格子的值比当前格子的值大，则可以前进。\r\n\r\n定义 $f[i][j]$ 表示以第 $i$ 行第 $j$ 列的格子为起点的路径数。\r\n\r\n由于路径中的数字严格递增，状态无后效性，可以用动态规划解决。\r\n\r\n我们把四个方向可以走的格子所对应的状态 $f[i'][j']$ 累加起来，再加上 $1$，即当前格子组成的长度为 $1$ 的路径，即为 $f[i][j]$。\r\n\r\n代码实现时可以用记忆化搜索。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(mn)$。有 $O(mn)$ 个状态，每个状态有 $O(1)$ 个转移来源，计算所有状态的时间为 $O(mn)$。\r\n- 空间复杂度：$O(mn)$。\r\n\r\n#### 相似题目\r\n\r\n- [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def countPaths(self, grid: List[List[int]]) -> int:\r\n        MOD = 10 ** 9 + 7\r\n        m, n = len(grid), len(grid[0])\r\n        @cache\r\n        def dfs(i: int, j: int) -> int:\r\n            res = 1\r\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\r\n                if 0 <= x < m and 0 <= y < n and grid[x][y] > grid[i][j]:\r\n                    res += dfs(x, y)\r\n            return res % MOD\r\n        return sum(dfs(i, j) for i in range(m) for j in range(n)) % MOD\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    static final int MOD = (int) 1e9 + 7;\r\n    static final int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n    int m, n;\r\n    int[][] grid, f;\r\n\r\n    public int countPaths(int[][] grid) {\r\n        m = grid.length;\r\n        n = grid[0].length;\r\n        this.grid = grid;\r\n        f = new int[m][n];\r\n        for (int i = 0; i < m; i++) Arrays.fill(f[i], -1);\r\n        var ans = 0;\r\n        for (var i = 0; i < m; ++i)\r\n            for (var j = 0; j < n; ++j)\r\n                ans = (ans + dfs(i, j)) % MOD;\r\n        return ans;\r\n    }\r\n\r\n    int dfs(int i, int j) {\r\n        if (f[i][j] != -1) return f[i][j];\r\n        var res = 1;\r\n        for (var d : dirs) {\r\n            int x = i + d[0], y = j + d[1];\r\n            if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] > grid[i][j])\r\n                res = (res + (dfs(x, y))) % MOD;\r\n        }\r\n        return f[i][j] = res;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\n    const int MOD = 1e9 + 7;\r\n    const int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\npublic:\r\n    int countPaths(vector<vector<int>> &grid) {\r\n        int m = grid.size(), n = grid[0].size();\r\n        int f[m][n]; memset(f, -1, sizeof(f));\r\n        function<int(int, int)> dfs = [&](int i, int j) -> int {\r\n            if (f[i][j] != -1) return f[i][j];\r\n            int res = 1;\r\n            for (auto &d : dirs) {\r\n                int x = i + d[0], y = j + d[1];\r\n                if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] > grid[i][j])\r\n                    res = (res + (dfs(x, y))) % MOD;\r\n            }\r\n            return f[i][j] = res;\r\n        };\r\n        int ans = 0;\r\n        for (int i = 0; i < m; ++i)\r\n            for (int j = 0; j < n; ++j)\r\n                ans = (ans + dfs(i, j)) % MOD;\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nvar dirs = []struct{ x, y int }{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\r\n\r\nfunc countPaths(grid [][]int) (ans int) {\r\n\tconst mod int = 1e9 + 7\r\n\tm, n := len(grid), len(grid[0])\r\n\tf := make([][]int, m)\r\n\tfor i := range f {\r\n\t\tf[i] = make([]int, n)\r\n\t\tfor j := range f[i] {\r\n\t\t\tf[i][j] = -1\r\n\t\t}\r\n\t}\r\n\tvar dfs func(int, int) int\r\n\tdfs = func(i, j int) int {\r\n\t\tif f[i][j] != -1 {\r\n\t\t\treturn f[i][j]\r\n\t\t}\r\n\t\tres := 1\r\n\t\tfor _, d := range dirs {\r\n\t\t\tif x, y := i+d.x, j+d.y; 0 <= x && x < m && 0 <= y && y < n && grid[x][y] > grid[i][j] {\r\n\t\t\t\tres = (res + dfs(x, y)) % mod\r\n\t\t\t}\r\n\t\t}\r\n\t\tf[i][j] = res\r\n\t\treturn res\r\n\t}\r\n\tfor i, row := range grid {\r\n\t\tfor j := range row {\r\n\t\t\tans = (ans + dfs(i, j)) % mod\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n```\r\n"
}