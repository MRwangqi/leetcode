{
	"titleSlug": "contain-virus",
	"slug": "ge-chi-bing-du-by-leetcode-solution-vn9m",
	"url": "https://leetcode-cn.com/problems/contain-virus/solution/ge-chi-bing-du-by-leetcode-solution-vn9m/",
	"content": "#### 方法一：广度优先搜索\n\n**思路与算法**\n\n本题只需要根据题意进行模拟即可，但细节较多，需要仔细编写代码。\n\n我们首先可以对矩阵 $\\textit{isInfected}$ 进行广度优先搜索，具体地，当我们遍历到 $\\textit{isInfected}$ 中的一个 $1$ 时，就从这个 $1$ 对应的位置开始进行广度优先搜索，这样就可以得到连续的一块被病毒感染的区域。\n\n在搜索的过程中，如果当前是第 $\\textit{idx}~(\\textit{idx} \\geq 1)$ 块被病毒感染的区域，我们就把这些 $1$ 都赋值成 $-\\textit{idx}$，这样就可以防止重复搜索，并且可以和非病毒区域 $0$ 区分开来。同时，由于我们每次需要选择「对未感染区域的威胁最大」的区域设置防火墙，因此我们还需要存储：\n\n- 该区域相邻的未感染区域（即 $0$）的位置和个数；\n\n- 如果需要位该区域设置防火墙，那么需要防火墙的个数。\n\n对于前者，我们在广度优先搜索的过程中，只要在扩展 $1$ 时搜索相邻的 $0$，就可以把这个 $0$ 对应的位置放在一个哈希集合中。这里使用哈希集合的原因是同一个 $0$ 可能会和多个 $1$ 相邻，可以防止重复计算。同时，由于多个 $1$ 可能出现在不同的感染区域中，如果通过修改矩阵 $\\textit{isInfected}$ 的形式来标记这些 $0$，会使得代码编写较为麻烦。\n\n对于后者，计算的方法是类似的，在扩展 $1$ 时如果搜索到相邻的 $0$，那么我们就需要在 $1$ 和 $0$ 之间的这条网格边上建一个防火墙。同一个 $0$ 和多个 $1$ 相邻，就需要建立多个防火墙，因此我们只需要使用一个变量在广度优先搜索的过程中计数即可，无需考虑重复的情况。\n\n在广度优先搜索完成后，如果我们没有发现任何感染区域，说明区域内不存在病毒，我们直接返回 $0$ 作为答案。否则，我们需要找到「对未感染区域的威胁最大」的区域，这里只需要找出对应的哈希集合的大小最大的那块区域即可。\n\n在确定了区域（假设是第 $\\textit{idx}$ 块区域）后，我们把矩阵中所有的 $-\\textit{idx}$ 都变成 $2$，这样可以不影响任何搜索和判断；除此之外的所有负数都恢复成 $1$。此外，所有哈希集合中存储的（除了第 $\\textit{idx}$ 块区域对应的以外）所有相邻位置都需要从 $0$ 变成 $1$，表示病毒的传播。\n\n最后，如果我们发现区域一共只有一块，那么这次防火墙建立后，不会再有病毒传播，可以返回答案；否则我们还需要继续重复执行上述的所有步骤。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\npublic:\n    int containVirus(vector<vector<int>>& isInfected) {\n        auto pair_hash = [fn = hash<int>()](const pair<int, int>& o) {\n            return (fn(o.first) << 16) ^ fn(o.second);\n        };\n\n        int m = isInfected.size(), n = isInfected[0].size();\n        int ans = 0;\n        while (true) {\n            vector<unordered_set<pair<int, int>, decltype(pair_hash)>> neighbors;\n            vector<int> firewalls;\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (isInfected[i][j] == 1) {\n                        queue<pair<int, int>> q;\n                        unordered_set<pair<int, int>, decltype(pair_hash)> neighbor(0, pair_hash);\n                        int firewall = 0, idx = neighbors.size() + 1;\n                        q.emplace(i, j);\n                        isInfected[i][j] = -idx;\n\n                        while (!q.empty()) {\n                            auto [x, y] = q.front();\n                            q.pop();\n                            for (int d = 0; d < 4; ++d) {\n                                int nx = x + dirs[d][0];\n                                int ny = y + dirs[d][1];\n                                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                                    if (isInfected[nx][ny] == 1) {\n                                        q.emplace(nx, ny);\n                                        isInfected[nx][ny] = -idx;\n                                    }\n                                    else if (isInfected[nx][ny] == 0) {\n                                        ++firewall;\n                                        neighbor.emplace(nx, ny);\n                                    }\n                                }\n                            }\n                        }\n                        neighbors.push_back(move(neighbor));\n                        firewalls.push_back(firewall);\n                    }\n                }\n            }\n            \n            if (neighbors.empty()) {\n                break;\n            }\n\n            int idx = max_element(neighbors.begin(), neighbors.end(), [](const auto& v0, const auto& v1) { return v0.size() < v1.size(); }) - neighbors.begin();\n            ans += firewalls[idx];\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (isInfected[i][j] < 0) {\n                        if (isInfected[i][j] != -idx - 1) {\n                            isInfected[i][j] = 1;\n                        }\n                        else {\n                            isInfected[i][j] = 2;\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < neighbors.size(); ++i) {\n                if (i != idx) {\n                    for (const auto& [x, y]: neighbors[i]) {\n                        isInfected[x][y] = 1;\n                    }\n                }\n            }\n            if (neighbors.size() == 1) {\n                break;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public int containVirus(int[][] isInfected) {\n        int m = isInfected.length, n = isInfected[0].length;\n        int ans = 0;\n        while (true) {\n            List<Set<Integer>> neighbors = new ArrayList<Set<Integer>>();\n            List<Integer> firewalls = new ArrayList<Integer>();\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (isInfected[i][j] == 1) {\n                        Queue<int[]> queue = new ArrayDeque<int[]>();\n                        queue.offer(new int[]{i, j});\n                        Set<Integer> neighbor = new HashSet<Integer>();\n                        int firewall = 0, idx = neighbors.size() + 1;\n                        isInfected[i][j] = -idx;\n\n                        while (!queue.isEmpty()) {\n                            int[] arr = queue.poll();\n                            int x = arr[0], y = arr[1];\n                            for (int d = 0; d < 4; ++d) {\n                                int nx = x + dirs[d][0], ny = y + dirs[d][1];\n                                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                                    if (isInfected[nx][ny] == 1) {\n                                        queue.offer(new int[]{nx, ny});\n                                        isInfected[nx][ny] = -idx;\n                                    } else if (isInfected[nx][ny] == 0) {\n                                        ++firewall;\n                                        neighbor.add(getHash(nx, ny));\n                                    }\n                                }\n                            }\n                        }\n                        neighbors.add(neighbor);\n                        firewalls.add(firewall);\n                    }\n                }\n            }\n\n            if (neighbors.isEmpty()) {\n                break;\n            }\n\n            int idx = 0;\n            for (int i = 1; i < neighbors.size(); ++i) {\n                if (neighbors.get(i).size() > neighbors.get(idx).size()) {\n                    idx = i;\n                }\n            }\n            ans += firewalls.get(idx);\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (isInfected[i][j] < 0) {\n                        if (isInfected[i][j] != -idx - 1) {\n                            isInfected[i][j] = 1;\n                        } else {\n                            isInfected[i][j] = 2;\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < neighbors.size(); ++i) {\n                if (i != idx) {\n                    for (int val : neighbors.get(i)) {\n                        int x = val >> 16, y = val & ((1 << 16) - 1);\n                        isInfected[x][y] = 1;\n                    }\n                }\n            }\n            if (neighbors.size() == 1) {\n                break;\n            }\n        }\n        return ans;\n    }\n\n    public int getHash(int x, int y) {\n        return (x << 16) ^ y;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    static int[][] dirs = {new int[]{-1, 0}, new int[]{1, 0}, new int[]{0, -1}, new int[]{0, 1}};\n\n    public int ContainVirus(int[][] isInfected) {\n        int m = isInfected.Length, n = isInfected[0].Length;\n        int ans = 0;\n        while (true) {\n            IList<ISet<int>> neighbors = new List<ISet<int>>();\n            IList<int> firewalls = new List<int>();\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (isInfected[i][j] == 1) {\n                        Queue<Tuple<int, int>> queue = new Queue<Tuple<int, int>>();\n                        queue.Enqueue(new Tuple<int, int>(i, j));\n                        ISet<int> neighbor = new HashSet<int>();\n                        int firewall = 0, idx = neighbors.Count + 1;\n                        isInfected[i][j] = -idx;\n\n                        while (queue.Count > 0) {\n                            Tuple<int, int> tuple = queue.Dequeue();\n                            int x = tuple.Item1, y = tuple.Item2;\n                            for (int d = 0; d < 4; ++d) {\n                                int nx = x + dirs[d][0], ny = y + dirs[d][1];\n                                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                                    if (isInfected[nx][ny] == 1) {\n                                        queue.Enqueue(new Tuple<int, int>(nx, ny));\n                                        isInfected[nx][ny] = -idx;\n                                    } else if (isInfected[nx][ny] == 0) {\n                                        ++firewall;\n                                        neighbor.Add(GetHash(nx, ny));\n                                    }\n                                }\n                            }\n                        }\n                        neighbors.Add(neighbor);\n                        firewalls.Add(firewall);\n                    }\n                }\n            }\n\n            if (neighbors.Count == 0) {\n                break;\n            }\n\n            int maxIdx = 0;\n            for (int i = 1; i < neighbors.Count; ++i) {\n                if (neighbors[i].Count > neighbors[maxIdx].Count) {\n                    maxIdx = i;\n                }\n            }\n            ans += firewalls[maxIdx];\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (isInfected[i][j] < 0) {\n                        if (isInfected[i][j] != -maxIdx - 1) {\n                            isInfected[i][j] = 1;\n                        } else {\n                            isInfected[i][j] = 2;\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < neighbors.Count; ++i) {\n                if (i != maxIdx) {\n                    foreach (int val in neighbors[i]) {\n                        int x = val >> 16, y = val & ((1 << 16) - 1);\n                        isInfected[x][y] = 1;\n                    }\n                }\n            }\n            if (neighbors.Count == 1) {\n                break;\n            }\n        }\n        return ans;\n    }\n\n    public int GetHash(int x, int y) {\n        return (x << 16) ^ y;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def containVirus(self, isInfected: List[List[int]]) -> int:\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        m, n = len(isInfected), len(isInfected[0])\n        ans = 0\n\n        while True:\n            neighbors, firewalls = list(), list()\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        q = deque([(i, j)])\n                        neighbor = set()\n                        firewall, idx = 0, len(neighbors) + 1\n                        isInfected[i][j] = -idx\n\n                        while q:\n                            x, y = q.popleft()\n                            for d in range(4):\n                                nx, ny = x + dirs[d][0], y + dirs[d][1]\n                                if 0 <= nx < m and 0 <= ny < n:\n                                    if isInfected[nx][ny] == 1:\n                                        q.append((nx, ny))\n                                        isInfected[nx][ny] = -idx\n                                    elif isInfected[nx][ny] == 0:\n                                        firewall += 1\n                                        neighbor.add((nx, ny))\n                        \n                        neighbors.append(neighbor)\n                        firewalls.append(firewall)\n            \n            if not neighbors:\n                break\n\n            idx = 0\n            for i in range(1, len(neighbors)):\n                if len(neighbors[i]) > len(neighbors[idx]):\n                    idx = i\n                \n            ans += firewalls[idx]\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] < 0:\n                        if isInfected[i][j] != -idx - 1:\n                            isInfected[i][j] = 1\n                        else:\n                            isInfected[i][j] = 2\n            \n            for i, neighbor in enumerate(neighbors):\n                if i != idx:\n                    for x, y in neighbor:\n                        isInfected[x][y] = 1\n            \n            if len(neighbors) == 1:\n                break\n        \n        return ans\n```\n\n```C [sol1-C]\n#define HASH(x, y) (((x) << 16) ^ (y))\n\ntypedef struct {\n    int key;\n    UT_hash_handle hh;\n} HashItem;\n\nint containVirus(int** isInfected, int isInfectedSize, int* isInfectedColSize) {\n    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    int m = isInfectedSize, n = isInfectedColSize[0];\n    int ans = 0;\n    HashItem **neighbors = (HashItem **)malloc(sizeof(HashItem *) * m * n);\n    int *firewalls = (int *)malloc(sizeof(int) * m * n);\n    for (int i = 0; i < m * n; i++) {\n        neighbors[i] = NULL;\n    }\n    while (true) {\n        int neighborsSize = 0, firewallsSize = 0;\n        int *queue = (int *)malloc(sizeof(int) * m * n);          \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (isInfected[i][j] == 1) {                    \n                    int head = 0, tail = 0;\n                    HashItem *neighbor = NULL;\n                    int firewall = 0, idx = neighborsSize + 1;\n                    queue[tail++] = i * n + j;\n                    isInfected[i][j] = -idx;\n                    while (head != tail) {\n                        int x = queue[head] / n;\n                        int y = queue[head] % n;\n                        head++;\n                        for (int d = 0; d < 4; ++d) {\n                            int nx = x + dirs[d][0];\n                            int ny = y + dirs[d][1];\n                            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                                if (isInfected[nx][ny] == 1) {\n                                    queue[tail++] = nx * n + ny;\n                                    isInfected[nx][ny] = -idx;\n                                }\n                                else if (isInfected[nx][ny] == 0) {\n                                    ++firewall;\n                                    HashItem *pEntry = NULL;\n                                    int hashkey = HASH(nx, ny);\n                                    HASH_FIND_INT(neighbor, &hashkey, pEntry);\n                                    if (pEntry == NULL) {\n                                        HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n                                        pEntry->key = hashkey;\n                                        HASH_ADD_INT(neighbor, key, pEntry); \n                                    }\n                                }\n                            }\n                        }\n                    }\n                    neighbors[neighborsSize++] = neighbor;\n                    firewalls[firewallsSize++] = firewall;\n                }\n            }\n        }\n        free(queue);\n        if (neighborsSize == 0) {\n            break;\n        }\n        int idx = 0;\n        for (int i = 1; i < neighborsSize; i++) {\n            if (HASH_COUNT(neighbors[i]) > HASH_COUNT(neighbors[idx])) {\n                idx = i;\n            }\n        }\n        ans += firewalls[idx];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (isInfected[i][j] < 0) {\n                    if (isInfected[i][j] != -idx - 1) {\n                        isInfected[i][j] = 1;\n                    }\n                    else {\n                        isInfected[i][j] = 2;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < neighborsSize; ++i) {\n            if (i != idx) {\n                for (HashItem *pEntry = neighbors[i]; pEntry != NULL; pEntry = pEntry->hh.next) {\n                    int x = pEntry->key >> 16, y = pEntry->key & ((1 << 16) - 1);\n                    isInfected[x][y] = 1;\n                }\n            }\n        }\n        for (int i = 0; i < neighborsSize; i++) {\n            HashItem *cur, *tmp;\n            HASH_ITER(hh, neighbors[i], cur, tmp) {\n                HASH_DEL(neighbors[i], cur);  \n                free(cur);             \n            }\n            neighbors[i] = NULL;\n        }\n        if (neighborsSize == 1) {\n            break;\n        }\n    }\n    free(neighbors);\n    free(firewalls);\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\nvar containVirus = function(isInfected) {\n    const m = isInfected.length, n = isInfected[0].length;\n    let ans = 0;\n    while (true) {\n        const neighbors = [];\n        const firewalls = [];\n        for (let i = 0; i < m; ++i) {\n            for (let j = 0; j < n; ++j) {\n                if (isInfected[i][j] === 1) {\n                    const queue = [];\n                    queue.push([i, j]);\n                    const neighbor = new Set();\n                    let firewall = 0, idx = neighbors.length + 1;\n                    isInfected[i][j] = -idx;\n\n                    while (queue.length > 0) {\n                        const arr = queue.shift();\n                        let x = arr[0], y = arr[1];\n                        for (let d = 0; d < 4; ++d) {\n                            let nx = x + dirs[d][0], ny = y + dirs[d][1];\n                            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                                if (isInfected[nx][ny] === 1) {\n                                    queue.push([nx, ny]);\n                                    isInfected[nx][ny] = -idx;\n                                } else if (isInfected[nx][ny] === 0) {\n                                    ++firewall;\n                                    neighbor.add(getHash(nx, ny));\n                                }\n                            }\n                        }\n                    }\n                    neighbors.push(neighbor);\n                    firewalls.push(firewall);\n                }\n            }\n        }\n\n        if (neighbors.length === 0) {\n            break;\n        }\n\n        let idx = 0;\n        for (let i = 1; i < neighbors.length; ++i) {\n            if (neighbors[i].size > neighbors[idx].size) {\n                idx = i;\n            }\n        }\n        ans += firewalls[idx];\n        for (let i = 0; i < m; ++i) {\n            for (let j = 0; j < n; ++j) {\n                if (isInfected[i][j] < 0) {\n                    if (isInfected[i][j] !== -idx - 1) {\n                        isInfected[i][j] = 1;\n                    } else {\n                        isInfected[i][j] = 2;\n                    }\n                }\n            }\n        }\n        for (let i = 0; i < neighbors.length; ++i) {\n            if (i !== idx) {\n                for (const val of neighbors[i]) {\n                    let x = val >> 16, y = val & ((1 << 16) - 1);\n                    isInfected[x][y] = 1;\n                }\n            }\n        }\n        if (neighbors.length === 1) {\n            break;\n        }\n    }\n    return ans;\n}\n\nconst getHash = (x, y) => {\n    return (x << 16) ^ y;\n};\n```\n\n```go [sol1-Golang]\ntype pair struct{ x, y int }\nvar dirs = []pair{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\nfunc containVirus(isInfected [][]int) (ans int) {\n    m, n := len(isInfected), len(isInfected[0])\n    for {\n        neighbors := []map[pair]struct{}{}\n        firewalls := []int{}\n        for i, row := range isInfected {\n            for j, infected := range row {\n                if infected != 1 {\n                    continue\n                }\n                q := []pair{{i, j}}\n                neighbor := map[pair]struct{}{}\n                firewall, idx := 0, len(neighbors)+1\n                row[j] = -idx\n                for len(q) > 0 {\n                    p := q[0]\n                    q = q[1:]\n                    for _, d := range dirs {\n                        if x, y := p.x+d.x, p.y+d.y; 0 <= x && x < m && 0 <= y && y < n {\n                            if isInfected[x][y] == 1 {\n                                q = append(q, pair{x, y})\n                                isInfected[x][y] = -idx\n                            } else if isInfected[x][y] == 0 {\n                                firewall++\n                                neighbor[pair{x, y}] = struct{}{}\n                            }\n                        }\n                    }\n                }\n                neighbors = append(neighbors, neighbor)\n                firewalls = append(firewalls, firewall)\n            }\n        }\n\n        if len(neighbors) == 0 {\n            break\n        }\n\n        idx := 0\n        for i := 1; i < len(neighbors); i++ {\n            if len(neighbors[i]) > len(neighbors[idx]) {\n                idx = i\n            }\n        }\n\n        ans += firewalls[idx]\n        for _, row := range isInfected {\n            for j, v := range row {\n                if v < 0 {\n                    if v != -idx-1 {\n                        row[j] = 1\n                    } else {\n                        row[j] = 2\n                    }\n                }\n            }\n        }\n\n        for i, neighbor := range neighbors {\n            if i != idx {\n                for p := range neighbor {\n                    isInfected[p.x][p.y] = 1\n                }\n            }\n        }\n\n        if len(neighbors) == 1 {\n            break\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn(m+n))$。每一次广度优先搜索需要的时间为 $O(mn)$，而矩阵中任意两个位置的曼哈顿距离最大值为 $m+n-2$，因此在 $O(m+n)$ 次搜索后，所有还没有被隔离的病毒会连成一个整体。\n\n- 空间复杂度：$O(mn)$，即为广度优先搜索中的队列以及哈希集合需要使用的空间。"
}