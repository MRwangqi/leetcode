{
	"titleSlug": "find-the-k-sum-of-an-array",
	"slug": "zhuan-huan-dui-by-endlesscheng-8yiq",
	"url": "https://leetcode-cn.com/problems/find-the-k-sum-of-an-array/solution/zhuan-huan-dui-by-endlesscheng-8yiq/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1md4y1P75q) 已出炉，欢迎点赞三连，在评论区分享你对这场周赛的看法~\r\n\r\n---\r\n\r\n## 方法一：堆\r\n\r\n#### 提示 1\r\n\r\n记 $\\textit{nums}$ 中所有非负数的和为 $\\textit{sum}$。\r\n\r\n任意一个子序列的和，都等价于从 $\\textit{sum}$ 中减去某些非负数 / 加上某些负数得到。\r\n\r\n#### 提示 2\r\n\r\n将 $\\textit{nums}$ 所有数取绝对值，这样可以统一成从 $\\textit{sum}$ 中减去某些数。\r\n\r\n我们需要按照从小到大的顺序取出 $\\textit{sum}$ 要减去的子序列，如何做到？\r\n\r\n#### 提示 3-1\r\n\r\n将 $\\textit{nums}$ 所有数取绝对值后排序，然后用最大堆来实现。\r\n\r\n#### 提示 3-2\r\n\r\n具体来说，最大堆维护子序列的和，以及（后续需要减去的）数字的下标 $i$。\r\n\r\n初始时，将 $\\textit{sum}$ 和下标 $0$ 入堆。\r\n\r\n每次弹出堆顶时，将子序列的和减去 $\\textit{nums}[i]$，并考虑是否保留 $\\textit{nums}[i-1]$，从而满足子序列每个元素「选或不选」的要求。\r\n\r\n这一做法可以不重不漏地生成所有子序列的和，再配合堆，就可以从大到小生成。详细证明过程见 [视频讲解](https://www.bilibili.com/video/BV1md4y1P75q)。\r\n\r\n循环 $k-1$ 次后，堆顶的和就是答案。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\log n + k\\log k)$，其中 $n$ 为 $\\textit{nums}$ 的长度。\r\n- 空间复杂度：$O(k)$。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def kSum(self, nums: List[int], k: int) -> int:\r\n        sum = 0\r\n        for i, x in enumerate(nums):\r\n            if x >= 0: sum += x\r\n            else: nums[i] = -x\r\n        nums.sort()\r\n        h = [(-sum, 0)]  # 取负号变成最大堆\r\n        for _ in range(k - 1):\r\n            s, i = heappop(h)\r\n            if i < len(nums):\r\n                heappush(h, (s + nums[i], i + 1))  # 保留 nums[i-1]\r\n                if i: heappush(h, (s + nums[i] - nums[i - 1], i + 1))  # 不保留 nums[i-1]\r\n        return -h[0][0]\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public long kSum(int[] nums, int k) {\r\n        var sum = 0L;\r\n        for (var i = 0; i < nums.length; i++)\r\n            if (nums[i] >= 0) sum += nums[i];\r\n            else nums[i] = -nums[i];\r\n        Arrays.sort(nums);\r\n        var pq = new PriorityQueue<Pair<Long, Integer>>((a, b) -> Long.compare(b.getKey(), a.getKey()));\r\n        pq.offer(new Pair<>(sum, 0));\r\n        while (--k > 0) {\r\n            var p = pq.poll();\r\n            var s = p.getKey();\r\n            var i = p.getValue();\r\n            if (i < nums.length) {\r\n                pq.offer(new Pair<>(s - nums[i], i + 1)); // 保留 nums[i-1]\r\n                if (i > 0) pq.offer(new Pair<>(s - nums[i] + nums[i - 1], i + 1)); // 不保留 nums[i-1]，把之前减去的加回来\r\n            }\r\n        }\r\n        return pq.peek().getKey();\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    long long kSum(vector<int> &nums, int k) {\r\n        long sum = 0L;\r\n        for (int &x : nums)\r\n            if (x >= 0) sum += x;\r\n            else x = -x;\r\n        sort(nums.begin(), nums.end());\r\n        priority_queue<pair<long, int>> pq;\r\n        pq.emplace(sum, 0);\r\n        while (--k) {\r\n            auto[sum, i] = pq.top();\r\n            pq.pop();\r\n            if (i < nums.size()) {\r\n                pq.emplace(sum - nums[i], i + 1); // 保留 nums[i-1]\r\n                if (i) pq.emplace(sum - nums[i] + nums[i - 1], i + 1); // 不保留 nums[i-1]，把之前减去的加回来\r\n            }\r\n        }\r\n        return pq.top().first;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc kSum(nums []int, k int) int64 {\r\n\tn := len(nums)\r\n\tsum := 0\r\n\tfor i, x := range nums {\r\n\t\tif x >= 0 {\r\n\t\t\tsum += x\r\n\t\t} else {\r\n\t\t\tnums[i] = -x\r\n\t\t}\r\n\t}\r\n\tsort.Ints(nums)\r\n\th := &hp{{sum, 0}}\r\n\tfor ; k > 1; k-- {\r\n\t\tp := heap.Pop(h).(pair)\r\n\t\tif p.i < n {\r\n\t\t\theap.Push(h, pair{p.sum - nums[p.i], p.i + 1}) // 保留 nums[p.i-1]\r\n\t\t\tif p.i > 0 {\r\n\t\t\t\theap.Push(h, pair{p.sum - nums[p.i] + nums[p.i-1], p.i + 1}) // 不保留 nums[p.i-1]，把之前减去的加回来\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn int64((*h)[0].sum)\r\n}\r\n\r\ntype pair struct{ sum, i int }\r\ntype hp []pair\r\n\r\nfunc (h hp) Len() int            { return len(h) }\r\nfunc (h hp) Less(i, j int) bool  { return h[i].sum > h[j].sum }\r\nfunc (h hp) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\r\nfunc (h *hp) Push(v interface{}) { *h = append(*h, v.(pair)) }\r\nfunc (h *hp) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }\r\n```\r\n\r\n## 方法二：二分 + 搜索\r\n\r\n我们还可以用二分来求出从 $\\textit{sum}$ 中减去的第 $k-1$ 小的子序列和。\r\n\r\n依然是所有元素取绝对值，然后排序。\r\n\r\n二分子序列和，记作 $\\textit{limit}$，统计元素和 $s$ 不超过 $\\textit{limit}$ 的子序列个数 $\\textit{cnt}$。\r\n\r\n我们可以写一个简单的搜索，从小到大考虑每个 $\\textit{nums}[i]$ 选或者不选，如果遇到 $\\textit{cnt}\\ge k-1$ 或者 $s+\\textit{nums}[i]>\\textit{limit}$ 的情况就立刻返回。\r\n\r\n用 $\\textit{sum}$ 减去二分得到的值就是答案。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\log n + k\\log U)$，其中 $n$ 为 $\\textit{nums}$ 的长度，$U=\\sum\\limits_{i}|\\textit{nums}[i]|$。二分中 `check` 的时间复杂度取决于 `cnt++` 的次数，这至多有 $k-1$ 次。\r\n- 空间复杂度：$O(\\min(k,n))$。空间复杂度取决于递归的栈开销，而我们至多递归 $\\min(k,n)$ 层。\r\n\r\n```py [sol2-Python3]\r\nclass Solution:\r\n    def kSum(self, nums: List[int], k: int) -> int:\r\n        sum = tot = 0\r\n        for i, x in enumerate(nums):\r\n            if x >= 0:\r\n                sum += x\r\n                tot += x\r\n            else:\r\n                tot -= x\r\n                nums[i] = -x\r\n        nums.sort()\r\n\r\n        def count(limit: int) -> int:\r\n            cnt = 0\r\n            def f(i: int, s: int) -> None:\r\n                nonlocal cnt\r\n                if i == len(nums) or cnt >= k - 1 or s + nums[i] > limit:\r\n                    return\r\n                cnt += 1\r\n                f(i + 1, s + nums[i])  # 选\r\n                f(i + 1, s)  # 不选\r\n            f(0, 0)\r\n            return cnt\r\n        return sum - bisect_left(range(tot), k - 1, key=count)\r\n```\r\n\r\n```java [sol2-Java]\r\nclass Solution {\r\n    int[] nums;\r\n    long limit;\r\n    int k, cnt;\r\n\r\n    void f(int i, long s) {\r\n        if (i == nums.length || cnt >= k || s + nums[i] > limit) return;\r\n        ++cnt;\r\n        f(i + 1, s + nums[i]); // 选\r\n        f(i + 1, s); // 不选\r\n    }\r\n\r\n    public long kSum(int[] nums, int k) {\r\n        long sum = 0L, tot = 0L;\r\n        for (var i = 0; i < nums.length; i++) {\r\n            if (nums[i] >= 0) sum += nums[i];\r\n            else nums[i] = -nums[i];\r\n            tot += nums[i];\r\n        }\r\n        Arrays.sort(nums);\r\n\r\n        this.nums = nums;\r\n        this.k = k - 1;\r\n        long left = 0L, right = tot;\r\n        while (left < right) {\r\n            var mid = (left + right) / 2;\r\n            this.limit = mid;\r\n            cnt = 0;\r\n            f(0, 0L);\r\n            if (cnt >= k - 1) right = mid;\r\n            else left = mid + 1;\r\n        }\r\n        return sum - left;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol2-C++]\r\nclass Solution {\r\npublic:\r\n    long long kSum(vector<int> &nums, int k) {\r\n        long sum = 0L;\r\n        for (int &x : nums) {\r\n            if (x >= 0) sum += x;\r\n            else x = -x;\r\n        }\r\n        sort(nums.begin(), nums.end());\r\n\r\n        --k;\r\n        auto check = [&](long limit) -> bool {\r\n            int cnt = 0;\r\n            function<void(int, long)> f = [&](int i, long s) {\r\n                if (i == nums.size() || cnt >= k || s + nums[i] > limit) return;\r\n                ++cnt;\r\n                f(i + 1, s + nums[i]); // 选\r\n                f(i + 1, s); // 不选\r\n            };\r\n            f(0, 0L);\r\n            return cnt >= k;\r\n        };\r\n        long left = 0L, right = accumulate(nums.begin(), nums.end(), 0L);\r\n        while (left < right) {\r\n            long mid = (left + right) / 2;\r\n            if (check(mid)) right = mid;\r\n            else left = mid + 1;\r\n        }\r\n        return sum - left;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\nfunc kSum(nums []int, k int) int64 {\r\n\tn := len(nums)\r\n\tsum, tot := 0, 0\r\n\tfor i, x := range nums {\r\n\t\tif x >= 0 {\r\n\t\t\tsum += x\r\n\t\t\ttot += x\r\n\t\t} else {\r\n\t\t\ttot -= x\r\n\t\t\tnums[i] = -x\r\n\t\t}\r\n\t}\r\n\tsort.Ints(nums)\r\n\r\n\tk--\r\n\tkthSmallest := sort.Search(tot, func(limit int) bool {\r\n\t\tcnt := 0\r\n\t\tvar f func(int, int)\r\n\t\tf = func(i, s int) {\r\n\t\t\tif i == n || cnt >= k || s+nums[i] > limit {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tcnt++\r\n\t\t\tf(i+1, s+nums[i]) // 选\r\n\t\t\tf(i+1, s)         // 不选\r\n\t\t}\r\n\t\tf(0, 0)\r\n\t\treturn cnt >= k\r\n\t})\r\n\treturn int64(sum - kthSmallest)\r\n}\r\n```\r\n\r\n#### 相似题目\r\n\r\n- [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)\r\n"
}