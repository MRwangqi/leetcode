{
	"titleSlug": "contains-duplicate-ii",
	"slug": "cun-zai-zhong-fu-yuan-su-ii-by-leetcode-kluvk",
	"url": "https://leetcode-cn.com/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode-kluvk/",
	"content": "#### 方法一：哈希表\n\n从左到右遍历数组 $\\textit{nums}$，当遍历到下标 $i$ 时，如果存在下标 $j < i$ 使得 $\\textit{nums}[i] = \\textit{nums}[j]$，则当 $i - j \\le k$ 时即找到了两个符合要求的下标 $j$ 和 $i$。\n\n如果在下标 $i$ 之前存在多个元素都和 $\\textit{nums}[i]$ 相等，为了判断是否存在满足 $\\textit{nums}[i] = \\textit{nums}[j]$ 且 $i - j \\le k$ 的下标 $j$，应该在这些元素中寻找下标最大的元素，将最大下标记为 $j$，判断 $i - j \\le k$ 是否成立。\n\n如果 $i - j \\le k$，则找到了两个符合要求的下标 $j$ 和 $i$；如果 $i - j > k$，则在下标 $i$ 之前不存在任何元素满足与 $\\textit{nums}[i]$ 相等且下标差的绝对值不超过 $k$，理由如下。\n\n> 假设存在下标 $j'$ 满足 $j' < j < i$ 且 $\\textit{nums}[j'] = \\textit{nums}[j] = \\textit{nums}[i]$，则 $i - j' > i - j$，由于 $i - j > k$，因此必有 $i - j' > k$。\n\n因此，当遍历到下标 $i$ 时，如果在下标 $i$ 之前存在与 $\\textit{nums}[i]$ 相等的元素，应该在这些元素中寻找最大的下标 $j$，判断 $i - j \\le k$ 是否成立。\n\n可以使用哈希表记录每个元素的最大下标。从左到右遍历数组 $\\textit{nums}$，当遍历到下标 $i$ 时，进行如下操作：\n\n1. 如果哈希表中已经存在和 $\\textit{nums}[i]$ 相等的元素且该元素在哈希表中记录的下标 $j$ 满足 $i - j \\le k$，返回 $\\text{true}$；\n\n2. 将 $\\textit{nums}[i]$ 和下标 $i$ 存入哈希表，此时 $i$ 是 $\\textit{nums}[i]$ 的最大下标。\n\n上述两步操作的顺序不能改变，因为当遍历到下标 $i$ 时，只能在下标 $i$ 之前的元素中寻找与当前元素相等的元素及该元素的最大下标。\n\n当遍历结束时，如果没有遇到两个相等元素的下标差的绝对值不超过 $k$，返回 $\\text{false}$。\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        int length = nums.length;\n        for (int i = 0; i < length; i++) {\n            int num = nums[i];\n            if (map.containsKey(num) && i - map.get(num) <= k) {\n                return true;\n            }\n            map.put(num, i);\n        }\n        return false;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool ContainsNearbyDuplicate(int[] nums, int k) {\n        Dictionary<int, int> dictionary = new Dictionary<int, int>();\n        int length = nums.Length;\n        for (int i = 0; i < length; i++) {\n            int num = nums[i];\n            if (dictionary.ContainsKey(num) && i - dictionary[num] <= k) {\n                return true;\n            }\n            if (dictionary.ContainsKey(num)) {\n                dictionary[num] = i;\n            } else {\n                dictionary.Add(num, i);\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_map<int, int> dictionary;\n        int length = nums.size();\n        for (int i = 0; i < length; i++) {\n            int num = nums[i];\n            if (dictionary.count(num) && i - dictionary[num] <= k) {\n                return true;\n            }\n            dictionary[num] = i;\n        }\n        return false;\n    }\n};\n```\n\n```C [sol1-C]\nstruct HashEntry {\n    int key;                  \n    int val;\n    UT_hash_handle hh;         \n};\n\nvoid hashAddItem(struct HashEntry **obj, int key, int val) {\n    struct HashEntry *pEntry;\n    pEntry = malloc(sizeof(struct HashEntry));\n    pEntry->key = key;\n    pEntry->val = val;\n    HASH_ADD_INT(*obj, key, pEntry);\n} \n\nstruct HashEntry *hashFindItem(const struct HashEntry **obj, int key)\n{\n    struct HashEntry *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nvoid hashFreeAll(struct HashEntry **obj)\n{\n    struct HashEntry *curr, *next;\n    HASH_ITER(hh, *obj, curr, next)\n    {\n        HASH_DEL(*obj,curr);  \n        free(curr);      \n    }\n}\n\nbool containsNearbyDuplicate(int* nums, int numsSize, int k){\n    struct HashEntry *dictionary = NULL;\n    for (int i = 0; i < numsSize; i++) {\n        struct HashEntry * pEntry = hashFindItem(&dictionary, nums[i]);\n        if (NULL != pEntry && i - pEntry->val <= k) {\n            hashFreeAll(&dictionary);\n            return true;\n        }\n        hashAddItem(&dictionary, nums[i], i);\n    }\n    hashFreeAll(&dictionary);\n    return false;\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        pos = {}\n        for i, num in enumerate(nums):\n            if num in pos and i - pos[num] <= k:\n                return True\n            pos[num] = i\n        return False\n```\n\n```go [sol1-Golang]\nfunc containsNearbyDuplicate(nums []int, k int) bool {\n    pos := map[int]int{}\n    for i, num := range nums {\n        if p, ok := pos[num]; ok && i-p <= k {\n            return true\n        }\n        pos[num] = i\n    }\n    return false\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar containsNearbyDuplicate = function(nums, k) {\n    const map = new Map();\n    const length = nums.length;\n    for (let i = 0; i < length; i++) {\n        const num = nums[i];\n        if (map.has(num) && i - map.get(num) <= k) {\n            return true;\n        }\n        map.set(num, i);\n    }\n    return false;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。需要遍历数组一次，对于每个元素，哈希表的操作时间都是 $O(1)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。需要使用哈希表记录每个元素的最大下标，哈希表中的元素个数不会超过 $n$。\n\n#### 方法二：滑动窗口\n\n考虑数组 $\\textit{nums}$ 中的每个长度不超过 $k + 1$ 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过 $k$。如果存在一个滑动窗口，其中有重复元素，则存在两个不同的下标 $i$ 和 $j$ 满足 $\\textit{nums}[i] = \\textit{nums}[j]$ 且 $|i - j| \\le k$。如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可。\n\n如果一个滑动窗口的结束下标是 $i$，则该滑动窗口的开始下标是 $\\max(0, i - k)$。可以使用哈希集合存储滑动窗口中的元素。从左到右遍历数组 $\\textit{nums}$，当遍历到下标 $i$ 时，具体操作如下：\n\n1. 如果 $i > k$，则下标 $i - k - 1$ 处的元素被移出滑动窗口，因此将 $\\textit{nums}[i - k - 1]$ 从哈希集合中删除；\n\n2. 判断 $\\textit{nums}[i]$ 是否在哈希集合中，如果在哈希集合中则在同一个滑动窗口中有重复元素，返回 $\\text{true}$，如果不在哈希集合中则将其加入哈希集合。\n\n当遍历结束时，如果所有滑动窗口中都没有重复元素，返回 $\\text{false}$。\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Set<Integer> set = new HashSet<Integer>();\n        int length = nums.length;\n        for (int i = 0; i < length; i++) {\n            if (i > k) {\n                set.remove(nums[i - k - 1]);\n            }\n            if (!set.add(nums[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public bool ContainsNearbyDuplicate(int[] nums, int k) {\n        ISet<int> set = new HashSet<int>();\n        int length = nums.Length;\n        for (int i = 0; i < length; i++) {\n            if (i > k) {\n                set.Remove(nums[i - k - 1]);\n            }\n            if (!set.Add(nums[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_set<int> s;\n        int length = nums.size();\n        for (int i = 0; i < length; i++) {\n            if (i > k) {\n                s.erase(nums[i - k - 1]);\n            }\n            if (s.count(nums[i])) {\n                return true;\n            }\n            s.emplace(nums[i]);\n        }\n        return false;\n    }\n};\n```\n\n```C [sol2-C]\nstruct HashEntry {\n    int key;                  \n    int val;\n    UT_hash_handle hh;         \n};\n\nvoid hashAddItem(struct HashEntry **obj, int key, int val) {\n    struct HashEntry *pEntry;\n    pEntry = malloc(sizeof(struct HashEntry));\n    pEntry->key = key;\n    pEntry->val = val;\n    HASH_ADD_INT(*obj, key, pEntry);\n} \n\nstruct HashEntry *hashFindItem(const struct HashEntry **obj, int key)\n{\n    struct HashEntry *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nvoid hashEraseItem(struct HashEntry **obj, int key)\n{   \n    struct HashEntry *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    if (NULL != pEntry) {\n        HASH_DEL(*obj, pEntry);\n        free(pEntry);\n    } \n}\n\nvoid hashFreeAll(struct HashEntry **obj)\n{\n    struct HashEntry *curr, *next;\n    HASH_ITER(hh, *obj, curr, next)\n    {\n        HASH_DEL(*obj,curr);  \n        free(curr);      \n    }\n}\n\nbool containsNearbyDuplicate(int* nums, int numsSize, int k){\n    struct HashEntry *cnt = NULL;\n    for (int i = 0; i < numsSize; i++) {\n        if (i > k) {\n            hashEraseItem(&cnt, nums[i - k - 1]);\n        }\n        struct HashEntry * pEntry = hashFindItem(&cnt, nums[i]);\n        if (NULL != pEntry) {\n            return true;\n        }\n        hashAddItem(&cnt, nums[i], 1);\n    }\n    hashFreeAll(&cnt);\n    return false;\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        s = set()\n        for i, num in enumerate(nums):\n            if i > k:\n                s.remove(nums[i - k - 1])\n            if num in s:\n                return True\n            s.add(num)\n        return False\n```\n\n```go [sol2-Golang]\nfunc containsNearbyDuplicate(nums []int, k int) bool {\n    set := map[int]struct{}{}\n    for i, num := range nums {\n        if i > k {\n            delete(set, nums[i-k-1])\n        }\n        if _, ok := set[num]; ok {\n            return true\n        }\n        set[num] = struct{}{}\n    }\n    return false\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar containsNearbyDuplicate = function(nums, k) {\n    const set = new Set();\n    const length = nums.length;\n    for (let i = 0; i < length; i++) {\n        if (i > k) {\n            set.delete(nums[i - k - 1]);\n        }\n        if (set.has(nums[i])) {\n            return true;\n        }\n        set.add(nums[i])\n    }\n    return false;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。需要遍历数组一次，对于每个元素，哈希集合的操作时间都是 $O(1)$。\n\n- 空间复杂度：$O(k)$，其中 $k$ 是判断重复元素时允许的下标差的绝对值的最大值。需要使用哈希集合存储滑动窗口中的元素，任意时刻滑动窗口中的元素个数最多为 $k + 1$ 个。"
}