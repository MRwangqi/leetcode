{
	"titleSlug": "design-hashset",
	"slug": "by-nehzil-4vdc",
	"url": "https://leetcode-cn.com/problems/design-hashset/solution/by-nehzil-4vdc/",
	"content": "**哈希表的原理**\n哈希表的关键是使用*哈希函数*将键映射到存储桶。当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；\n**设计哈希表应该注意的问题：**\n**1. 哈希函数设计问题** \n哈希函数是尽可能将键分配到桶中，理想情况下，完美的哈希函数将是键和桶之间的一对一映射。但是在大多数情况下，哈希函数并不完美，它需要在桶的数量和桶的容量之间进行权衡。\n**2. 冲突解决**\n理想情况下，如果我们的哈希函数是完美的一对一映射将不需要处理冲突。但是在大多数情况下，冲突几乎是不可避免的。\n冲突解决算法应该解决以下几个问题：\n1. 如何组织在同一个桶中的值？\n2. 如果为同一个桶分配了太多的值，该怎么办？\n3. 如何在特定的桶中搜索目标值？\n\n**705. 设计哈希集合**\n```\n不使用任何内建的哈希表库设计一个哈希集合（HashSet）。\n实现 MyHashSet 类：\nvoid add(key) 向哈希集合中插入值 key 。\nbool contains(key) 返回哈希集合中是否存在这个值 key 。\nvoid remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。\n```\n```\n#define MAX_LEN 100000         \nclass MyHashSet {\nprivate:\n    vector<int> set[MAX_LEN];\n    \n    /* 返回相应的表索引 */\n    int getIndex(int key) {\n        return key % MAX_LEN;\n    }\n    \n    /* 搜索特定存储哈希表中的值。如果值不存在，则返回-1 */\n    int getPos(int key, int index) {\n        for (int i = 0; i < set[index].size(); ++i) {\n            if (set[index][i] == key) {\n                return i;\n            }\n        }\n        return -1;\n    }\npublic:\n    MyHashSet() {      \n    }\n    /* 向哈希集合中插入值key */\n    void add(int key) {\n        int index = getIndex(key);\n        int pos = getPos(key, index);\n        /* 如果不存在则添加新的数据进去 存在不做任何操作 */\n        if (pos < 0) {\n            set[index].push_back(key);\n        }\n    }\n    /* 将给定值key从哈希集合中删除 */\n    void remove(int key) {\n        int index = getIndex(key);\n        int pos = getPos(key, index);\n        if (pos >= 0) {\n            set[index].erase(set[index].begin() + pos);\n        }\n    }\n    \n    /** 返回哈希集合中是否存在这个值 key */\n    bool contains(int key) {\n        int index = getIndex(key);\n        int pos = getPos(key, index);\n        return pos >= 0;\n    }\n};\n```\n\n\n**706. 设计哈希映射**\n```\n不使用任何内建的哈希表库设计一个哈希映射（HashMap）。\n实现 MyHashMap 类：\nMyHashMap() 用空映射初始化对象\nvoid put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。\nint get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。\nvoid remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。\n```\n\n```\n#define MAX_LEN 100000            // the amount of buckets\n\nclass MyHashMap {\nprivate:\n    vector<pair<int, int>> map[MAX_LEN];     \n    \n    /** 定义散列函数返回存储数据的下标 */\n    int getIndex(int key) {\n        return key % MAX_LEN;\n    }\n    /* 查找数据在哈希表中的位置 */\n    int getPos(int key, int index) {\n        for (int i = 0; i < map[index].size(); ++i) {\n            if (map[index][i].first == key) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \npublic:\n    \n    MyHashMap() {   \n    }\n    /* 插入一个键值对key, value。如果key存在于映射中，则更新其对应的值value */\n    void put(int key, int value) {\n        int index = getIndex(key);\n        int pos = getPos(key, index);\n        if (pos < 0) {\n            map[index].push_back(make_pair(key, value));\n        } else {\n            map[index][pos].second = value;\n        }\n    }\n    /* 返回特定的key所映射的value；如果映射中不包含key的映射，返回 -1  */\n    int get(int key) {\n        int index = getIndex(key);\n        int pos = getPos(key, index);\n        if (pos < 0) {\n            return -1;\n        } else {\n            return map[index][pos].second;\n        }\n    }\n    \n    /** 如果映射中存在key的映射，则移除key和它所对应的value  */\n    void remove(int key) {\n        int index = getIndex(key);\n        int pos = getPos(key, index);\n        if (pos >= 0) {\n            map[index].erase(map[index].begin() + pos);\n        }\n    }\n};\n```\n\n\n**优化**\n- **问题分析**\n “删除” 操作：假设我们要删除第 i 个元素，并且数组列表的大小为 n。内置函数中使用的策略是把第 i 个元素后的所有元素向前移动一个位置。也就是说，你必须移动 n - i 次。因此，从数组列表中删除元素的时间复杂度将为 O(n)。\n- **解决办法** \n1. **交换**：我们可以使用一种巧妙的策略。首先，用存储桶中的最后一个元素交换要移除的元素。然后删除最后一个元素。通过这种方法，我们成功地在 O(1) 的时间复杂度中去除了元素。（这个基本思想在后main一道题目中就使用了\n`380. O(1) 时间插入、删除和获取随机元素`下面就是删除元素的代码）\n```\nint pos = map[val];\nswap(vec[pos], vec[vec.size()-1]);\nmap[vec[pos]] = pos;\nvec.pop_back();\nmap.erase(val);\n```\n\n1. **链表**：实现此目标的另一种方法是使用链表而不是数组列表。通过这种方式，我们可以在不修改列表中的顺序的情况下删除元素。该策略时间复杂度为 O(1)。"
}