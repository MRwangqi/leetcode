{
	"titleSlug": "1-bit-and-2-bit-characters",
	"slug": "1bi-te-yu-2bi-te-zi-fu-by-leetcode-solut-rhrh",
	"url": "https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/solution/1bi-te-yu-2bi-te-zi-fu-by-leetcode-solut-rhrh/",
	"content": "#### 方法一：正序遍历\n\n根据题意，第一种字符一定以 $0$ 开头，第二种字符一定以 $1$ 开头。\n\n我们可以对 $\\textit{bits}$ 数组从左到右遍历。当遍历到 $\\textit{bits}[i]$ 时，如果 $\\textit{bits}[i]=0$，说明遇到了第一种字符，将 $i$ 的值增加 $1$；如果 $\\textit{bits}[i]=1$，说明遇到了第二种字符，可以跳过 $\\textit{bits}[i+1]$（注意题目保证 $\\textit{bits}$ 一定以 $0$ 结尾，所以 $\\textit{bits}[i]$ 一定不是末尾比特，因此 $\\textit{bits}[i+1]$ 必然存在），将 $i$ 的值增加 $2$。\n\n上述流程也说明 $\\textit{bits}$ 的编码方式是唯一确定的，因此若遍历到 $i=n-1$，那么说明最后一个字符一定是第一种字符。\n\n```Python [sol1-Python3]\nclass Solution:\n    def isOneBitCharacter(self, bits: List[int]) -> bool:\n        i, n = 0, len(bits)\n        while i < n - 1:\n            i += bits[i] + 1\n        return i == n - 1\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool isOneBitCharacter(vector<int> &bits) {\n        int n = bits.size(), i = 0;\n        while (i < n - 1) {\n            i += bits[i] + 1;\n        }\n        return i == n - 1;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean isOneBitCharacter(int[] bits) {\n        int n = bits.length, i = 0;\n        while (i < n - 1) {\n            i += bits[i] + 1;\n        }\n        return i == n - 1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool IsOneBitCharacter(int[] bits) {\n        int n = bits.Length, i = 0;\n        while (i < n - 1) {\n            i += bits[i] + 1;\n        }\n        return i == n - 1;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc isOneBitCharacter(bits []int) bool {\n    i, n := 0, len(bits)\n    for i < n-1 {\n        i += bits[i] + 1\n    }\n    return i == n-1\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar isOneBitCharacter = function(bits) {\n    let i = 0, n = bits.length;\n    while (i < n - 1) {\n        i += bits[i] + 1;\n    }\n    return i === n - 1;\n};\n```\n\n```C [sol1-C]\nbool isOneBitCharacter(int* bits, int bitsSize){\n    int i = 0;\n    while (i < bitsSize - 1) {\n        i += bits[i] + 1;\n    }\n    return i == bitsSize - 1;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{bits}$ 的长度。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：倒序遍历\n\n根据题意，$0$ 一定是一个字符的结尾。\n\n我们可以找到 $\\textit{bits}$ 的倒数第二个 $0$ 的位置，记作 $i$（不存在时定义为 $-1$），那么 $\\textit{bits}[i+1]$ 一定是一个字符的开头，且从 $\\textit{bits}[i+1]$ 到 $\\textit{bits}[n-2]$ 的这 $n-2-i$ 个比特均为 $1$。\n\n- 如果 $n-2-i$ 为偶数，则这些比特 $1$ 组成了 $\\dfrac{n-2-i}{2}$ 个第二种字符，所以 $\\textit{bits}$ 的最后一个比特 $0$ 一定组成了第一种字符。\n- 如果 $n-2-i$ 为奇数，则这些比特 $1$ 的前 $n-3-i$ 个比特组成了 $\\dfrac{n-3-i}{2}$ 个第二种字符，多出的一个比特 $1$ 和 $\\textit{bits}$ 的最后一个比特 $0$ 组成第二种字符。\n\n由于 $n-i$ 和 $n-2-i$ 的奇偶性相同，我们可以通过判断 $n-i$ 是否为偶数来判断最后一个字符是否为第一种字符，若为偶数则返回 $\\texttt{true}$，否则返回 $\\texttt{false}$。\n\n```Python [sol2-Python3]\nclass Solution:\n    def isOneBitCharacter(self, bits: List[int]) -> bool:\n        n = len(bits)\n        i = n - 2\n        while i >= 0 and bits[i]:\n            i -= 1\n        return (n - i) % 2 == 0\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool isOneBitCharacter(vector<int> &bits) {\n        int n = bits.size(), i = n - 2;\n        while (i >= 0 and bits[i]) {\n            --i;\n        }\n        return (n - i) % 2 == 0;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean isOneBitCharacter(int[] bits) {\n        int n = bits.length, i = n - 2;\n        while (i >= 0 && bits[i] == 1) {\n            --i;\n        }\n        return (n - i) % 2 == 0;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public bool IsOneBitCharacter(int[] bits) {\n        int n = bits.Length, i = n - 2;\n        while (i >= 0 && bits[i] == 1) {\n            --i;\n        }\n        return (n - i) % 2 == 0;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc isOneBitCharacter(bits []int) bool {\n    n := len(bits)\n    i := n - 2\n    for i >= 0 && bits[i] == 1 {\n        i--\n    }\n    return (n-i)%2 == 0\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar isOneBitCharacter = function(bits) {\n    const n = bits.length;\n    let i = n - 2;\n    while (i >= 0 && bits[i]) {\n        i--;\n    }\n    return (n - i) % 2 === 0;\n};\n```\n\n```C [sol2-C]\nbool isOneBitCharacter(int* bits, int bitsSize){\n    int i = bitsSize - 2;\n    while (i >= 0 && bits[i]) {\n        --i;\n    }\n    return (bitsSize - i) % 2 == 0;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{bits}$ 的长度。\n\n- 空间复杂度：$O(1)$。"
}