{
	"titleSlug": "painting-a-grid-with-three-different-colors",
	"slug": "zhuang-tai-ya-suo-dpcdai-ma-by-hankpipi-fnma",
	"url": "https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors/solution/zhuang-tai-ya-suo-dpcdai-ma-by-hankpipi-fnma/",
	"content": "这题最显而易见的方法就是状态压缩，没有去想 $O(n)$ 的做法\r\n\r\n直接将一列的m个点的状态用三进制表示，分别代表三种颜色\r\n设 $f[i][j]$ 表示前 $i$ 列，其中第 $i$ 列状态是 $j$ 的方案数\r\n$f[i][j]$ 从 $f[i-1][k]$ 转移来，其中 $j,k$ 这两列都要求相邻的格子颜色不同(对应代码中check)，且 $j$ 与 $k$ 两列在同一行也不能有相同的颜色(对应代码中check_n)。\r\n\r\n转移时，实际上可以先将合法的 $j,k$ 先筛选出来，然后再枚举，常数会优秀一些，这里没有写出。\r\n\r\n时间复杂度 $O(n*m*3^{2m})$\r\n空间复杂度 $O(n*m*3^{m})$\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    int f[1005][255];\r\n    int mod = 1e9 + 7, M;\r\n    bool check(int S) {\r\n        int last = -1;\r\n        for(int i = 0; i < M; ++i){\r\n            if(S%3==last)return false;\r\n            last = S%3;\r\n            S /= 3;\r\n        }\r\n        return true;\r\n    }\r\n    bool check_n(int x, int y) {\r\n        for(int i = 0; i < M; ++i) {\r\n            if(x%3==y%3)return false;\r\n            x/=3,y/=3;\r\n        }\r\n        return true;\r\n    }\r\n    int colorTheGrid(int m, int n) {\r\n        M = m;\r\n        int tot = 1;\r\n        for(int i = 1; i <= m; ++i)tot*=3;\r\n        for(int i = 0; i < tot; ++i)\r\n            if(check(i))f[1][i] = 1;\r\n        for(int i = 2; i <= n; ++i)\r\n            for(int j = 0; j < tot; ++j)\r\n                if(check(j))\r\n                    for(int k = 0;k < tot; ++k)\r\n                        if(check(k)) {\r\n                            if(!check_n(j,k))continue;\r\n                            f[i][j] = (f[i][j] + f[i - 1][k]) % mod;\r\n                        }\r\n        int ans = 0;\r\n        for(int i = 0; i < tot; ++i)\r\n            ans = (ans + f[n][i]) % mod;\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```"
}