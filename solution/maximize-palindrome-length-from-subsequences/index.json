{
	"titleSlug": "maximize-palindrome-length-from-subsequences",
	"slug": "python-ji-yi-hua-sou-suo-bu-tai-cong-min-hj2z",
	"url": "https://leetcode-cn.com/problems/maximize-palindrome-length-from-subsequences/solution/python-ji-yi-hua-sou-suo-bu-tai-cong-min-hj2z/",
	"content": "将word1和word2拼接为一个大字符串\n利用哈希表数组记录每个下标之前字符出现的最近位置。\n构建深搜，参数分别为字符串区间首尾下标，是否word1和word2的子序列非空。\n当子序列为空且当前区间都为word1或者word2之内，则无法满足题意。\n分别考虑左区间下标字符是否加入回文串，当不加入时直接移动左区间下标。\n当加入时，通过已记录的哈希表数组寻找右区间内字符出现的最近位置。\n当最近位置为左区间下标时则返回1.\n其他情况则考虑两个字符是否分别在word1和word2内，如果在的话则更新标记。\n```\nclass Solution:\n    def longestPalindrome(self, word1: str, word2: str) -> int:\n        @lru_cache(None)\n        def dfs(i, j, t):\n            if j == i:\n                if t == 0:\n                    return 0\n                return float(\"-inf\")\n            if t == 1:\n                if i >= k or j <= k:\n                    return float(\"-inf\")\n            res = dfs(i + 1, j, t)\n            n = word[i]\n            j = dp[j][n] + 1\n            if j - 1 == i:\n                if t == 1:\n                    return res \n                return max(res, 1)\n            if i < k and j - 1 >= k:\n                return max(res, 2 + dfs(i + 1, j - 1, 0))\n            return max(res, 2 + dfs(i + 1, j - 1, t))\n    \n        word = word1 + word2\n        l = len(word)\n        dp = [{}]\n        d = {}\n        for i, n in enumerate(word):\n            d[n] = i\n            dp.append(d.copy())\n        k = len(word1)\n        return max(0, dfs(0, l, 1))\n```\n"
}