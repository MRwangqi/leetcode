{
	"titleSlug": "yong-liang-ge-zhan-shi-xian-dui-lie-lcof",
	"slug": "mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3",
	"url": "https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/",
	"content": "#### 方法一：双栈\n\n**思路**\n\n将一个栈当作输入栈，用于压入 $\\texttt{appendTail}$ 传入的数据；另一个栈当作输出栈，用于 $\\texttt{deleteHead}$ 操作。\n\n每次 $\\texttt{deleteHead}$ 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\n\n**代码**\n\n```C++ [sol1-C++]\nclass CQueue {\nprivate:\n    stack<int> inStack, outStack;\n\n    void in2out() {\n        while (!inStack.empty()) {\n            outStack.push(inStack.top());\n            inStack.pop();\n        }\n    }\n\npublic:\n    CQueue() {}\n\n    void appendTail(int value) {\n        inStack.push(value);\n    }\n\n    int deleteHead() {\n        if (outStack.empty()) {\n            if (inStack.empty()) {\n                return -1;\n            }\n            in2out();\n        }\n        int value = outStack.top();\n        outStack.pop();\n        return value;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass CQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public CQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void appendTail(int value) {\n        inStack.push(value);\n    }\n\n    public int deleteHead() {\n        if (outStack.isEmpty()) {\n            if (inStack.isEmpty()) {\n                return -1;\n            }\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class CQueue {\n    Stack<int> inStack;\n    Stack<int> outStack;\n\n    public CQueue() {\n        inStack = new Stack<int>();\n        outStack = new Stack<int>();\n    }\n\n    public void AppendTail(int value) {\n        inStack.Push(value);\n    }\n\n    public int DeleteHead() {\n        if (outStack.Count == 0) {\n            if (inStack.Count == 0) {\n                return -1;\n            }\n            In2Out();\n        }\n        return outStack.Pop();\n    }\n\n    private void In2Out() {\n        while (inStack.Count > 0) {\n            outStack.Push(inStack.Pop());\n        }\n    }\n}\n```\n\n```go [sol1-Golang]\ntype CQueue struct {\n    inStack, outStack []int\n}\n\nfunc Constructor() CQueue {\n    return CQueue{}\n}\n\nfunc (this *CQueue) AppendTail(value int)  {\n    this.inStack = append(this.inStack, value)\n}\n\nfunc (this *CQueue) DeleteHead() int {\n    if len(this.outStack) == 0 {\n        if len(this.inStack) == 0 {\n            return -1\n        }\n        this.in2out()\n    }\n    value := this.outStack[len(this.outStack)-1]\n    this.outStack = this.outStack[:len(this.outStack)-1]\n    return value\n}\n\nfunc (this *CQueue) in2out() {\n    for len(this.inStack) > 0 {\n        this.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\n        this.inStack = this.inStack[:len(this.inStack)-1]\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar CQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\nCQueue.prototype.appendTail = function(value) {\n    this.inStack.push(value);\n};\n\nCQueue.prototype.deleteHead = function() {\n    if (!this.outStack.length) {\n        if (!this.inStack.length) {\n            return -1;\n        }\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nCQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int* stk;\n    int stkSize;\n    int stkCapacity;\n} Stack;\n\nStack* stackCreate(int cpacity) {\n    Stack* ret = malloc(sizeof(Stack));\n    ret->stk = malloc(sizeof(int) * cpacity);\n    ret->stkSize = 0;\n    ret->stkCapacity = cpacity;\n    return ret;\n}\n\nvoid stackPush(Stack* obj, int value) {\n    obj->stk[obj->stkSize++] = value;\n}\n\nvoid stackPop(Stack* obj) {\n    obj->stkSize--;\n}\n\nint stackTop(Stack* obj) {\n    return obj->stk[obj->stkSize - 1];\n}\n\nbool stackEmpty(Stack* obj) {\n    return obj->stkSize == 0;\n}\n\nvoid stackFree(Stack* obj) {\n    free(obj->stk);\n}\n\ntypedef struct {\n    Stack* inStack;\n    Stack* outStack;\n} CQueue;\n\nCQueue* cQueueCreate() {\n    CQueue* ret = malloc(sizeof(CQueue));\n    ret->inStack = stackCreate(10000);\n    ret->outStack = stackCreate(10000);\n    return ret;\n}\n\nvoid in2out(CQueue* obj) {\n    while (!stackEmpty(obj->inStack)) {\n        stackPush(obj->outStack, stackTop(obj->inStack));\n        stackPop(obj->inStack);\n    }\n}\n\nvoid cQueueAppendTail(CQueue* obj, int value) {\n    stackPush(obj->inStack, value);\n}\n\nint cQueueDeleteHead(CQueue* obj) {\n    if (stackEmpty(obj->outStack)) {\n        if (stackEmpty(obj->inStack)) {\n            return -1;\n        }\n        in2out(obj);\n    }\n    int x = stackTop(obj->outStack);\n    stackPop(obj->outStack);\n    return x;\n}\n\nvoid cQueueFree(CQueue* obj) {\n    stackFree(obj->inStack);\n    stackFree(obj->outStack);\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$\\texttt{appendTail}$ 为 $O(1)$，$\\texttt{deleteHead}$ 为均摊 $O(1)$。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 $O(1)$。\n\n- 空间复杂度：$O(n)$。其中 $n$ 是操作总数。对于有 $n$ 次 $\\texttt{appendTail}$ 操作的情况，队列中会有 $n$ 个元素，故空间复杂度为 $O(n)$。"
}