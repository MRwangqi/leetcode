{
	"titleSlug": "design-circular-deque",
	"slug": "she-ji-xun-huan-shuang-duan-dui-lie-by-l-97v0",
	"url": "https://leetcode-cn.com/problems/design-circular-deque/solution/she-ji-xun-huan-shuang-duan-dui-lie-by-l-97v0/",
	"content": "#### 方法一：数组\n\n可以参考循环队列：「[622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)」，我们利用循环队列实现双端队列。在循环队列中的基础上，我们增加 $\\texttt{insertFront}$ 和 $\\texttt{deleteFront}$ 函数实现即可。根据循环队列的定义，队列判空的条件是 $\\textit{front}=\\textit{rear}$，而队列判满的条件是 $\\textit{front} = (\\textit{rear} + 1) \\bmod \\textit{capacity}$。\n\n对于一个固定大小的数组，只要知道队尾 $\\textit{rear}$ 与队首 $\\textit{front}$，即可计算出队列当前的长度：\n\n$$\n(\\textit{rear} - \\textit{front} + \\textit{capacity}) \\bmod \\textit{capacity}\n$$\n\n循环双端队列与循环队列的属性一致:\n+ $\\texttt{elements}$：一个固定大小的数组，用于保存循环队列的元素。\n+ $\\texttt{capacity}$：循环队列的容量，即队列中最多可以容纳的元素数量。\n+ $\\texttt{front}$：队列首元素对应的数组的索引。\n+ $\\texttt{rear}$：队列尾元素对应的索引的下一个索引。\n\n循环双端队列的接口方法如下：\n+ $\\texttt{MyCircularDeque(int k)}$：初始化队列，同时 $\\textit{base}$ 数组的空间初始化大小为 $k + 1$。$\\textit{front},\\textit{rear}$ 全部初始化为 $0$。\n+ $\\texttt{insertFront(int value)}$：队列未满时，在队首插入一个元素。我们首先将队首 $\\textit{front}$ 移动一个位置，更新队首索引为 $\\textit{front}$ 更新为 $(\\textit{front} - 1 + \\textit{capacity}) \\bmod \\textit{capacity}$。\n+ $\\texttt{insertLast(int value)}$：队列未满时，在队列的尾部插入一个元素，并同时将队尾的索引 $\\textit{rear}$ 更新为 $(\\textit{rear} + 1) \\bmod \\textit{capacity}$。\n+ $\\texttt{deleteFront()}$：队列不为空时，从队首删除一个元素，并同时将队首的索引 $\\textit{front}$ 更新为 $(\\textit{front} + 1) \\bmod \\textit{capacity}$。\n+ $\\texttt{deleteLast()}$：队列不为空时，从队尾删除一个元素。并同时将队尾的索引 $\\textit{rear}$ 更新为 $(rear - 1 + capacity) \\bmod \\textit{capacity}$。\n+ $\\texttt{getFront()}$：返回队首的元素，需要检测队列是否为空。\n+ $\\texttt{getRear()}$：返回队尾的元素，需要检测队列是否为空。\n+ $\\texttt{isEmpty()}$：检测队列是否为空，根据之前的定义只需判断 $\\textit{rear}$ 是否等于 $\\textit{front}$。\n+ $\\texttt{isFull()}$：检测队列是否已满，根据之前的定义只需判断 $\\textit{front}$ 是否等于 $(\\textit{rear} + 1) \\bmod \\textit{capacity}$。\n\n```Python [sol1-Python3]\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.front = self.rear = 0\n        self.elements = [0] * (k + 1)\n\n    def insertFront(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.front = (self.front - 1) % len(self.elements)\n        self.elements[self.front] = value\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.elements[self.rear] = value\n        self.rear = (self.rear + 1) % len(self.elements)\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.front = (self.front + 1) % len(self.elements)\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.rear = (self.rear - 1) % len(self.elements)\n        return True\n\n    def getFront(self) -> int:\n        return -1 if self.isEmpty() else self.elements[self.front]\n\n    def getRear(self) -> int:\n        return -1 if self.isEmpty() else self.elements[(self.rear - 1) % len(self.elements)]\n\n    def isEmpty(self) -> bool:\n        return self.rear == self.front\n\n    def isFull(self) -> bool:\n        return (self.rear + 1) % len(self.elements) == self.front\n```\n\n```C++ [sol1-C++]\nclass MyCircularDeque {\nprivate:\n    vector<int> elements;\n    int rear, front;\n    int capacity;\n\npublic:\n    MyCircularDeque(int k) {\n        capacity = k + 1;\n        rear = front = 0;\n        elements = vector<int>(k + 1);\n    }\n\n    bool insertFront(int value) {\n        if (isFull()) {\n            return false;\n        }\n        front = (front - 1 + capacity) % capacity;\n        elements[front] = value;\n        return true;\n    }\n\n    bool insertLast(int value) {\n        if (isFull()) {\n            return false;\n        }\n        elements[rear] = value;\n        rear = (rear + 1) % capacity;\n        return true;\n    }\n\n    bool deleteFront() {\n        if (isEmpty()) {\n            return false;\n        }\n        front = (front + 1) % capacity;\n        return true;\n    }\n\n    bool deleteLast() {\n        if (isEmpty()) {\n            return false;\n        }\n        rear = (rear - 1 + capacity) % capacity;\n        return true;\n    }\n\n    int getFront() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return elements[front];\n    }\n\n    int getRear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return elements[(rear - 1 + capacity) % capacity];\n    }   \n\n    bool isEmpty() {\n        return rear == front;\n    }\n\n    bool isFull() {\n        return (rear + 1) % capacity == front;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass MyCircularDeque {\n    private int[] elements;\n    private int rear, front;\n    private int capacity;\n\n    public MyCircularDeque(int k) {\n        capacity = k + 1;\n        rear = front = 0;\n        elements = new int[k + 1];\n    }\n\n    public boolean insertFront(int value) {\n        if (isFull()) {\n            return false;\n        }\n        front = (front - 1 + capacity) % capacity;\n        elements[front] = value;\n        return true;\n    }\n\n    public boolean insertLast(int value) {\n        if (isFull()) {\n            return false;\n        }\n        elements[rear] = value;\n        rear = (rear + 1) % capacity;\n        return true;\n    }\n\n    public boolean deleteFront() {\n        if (isEmpty()) {\n            return false;\n        }\n        front = (front + 1) % capacity;\n        return true;\n    }\n\n    public boolean deleteLast() {\n        if (isEmpty()) {\n            return false;\n        }\n        rear = (rear - 1 + capacity) % capacity;\n        return true;\n    }\n\n    public int getFront() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return elements[front];\n    }\n\n    public int getRear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return elements[(rear - 1 + capacity) % capacity];\n    }\n\n    public boolean isEmpty() {\n        return rear == front;\n    }\n\n    public boolean isFull() {\n        return (rear + 1) % capacity == front;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class MyCircularDeque {\n    private int[] elements;\n    private int rear, front;\n    private int capacity;\n\n    public MyCircularDeque(int k) {\n        capacity = k + 1;\n        rear = front = 0;\n        elements = new int[k + 1];\n    }\n\n    public bool InsertFront(int value) {\n        if (IsFull()) {\n            return false;\n        }\n        front = (front - 1 + capacity) % capacity;\n        elements[front] = value;\n        return true;\n    }\n\n    public bool InsertLast(int value) {\n        if (IsFull()) {\n            return false;\n        }\n        elements[rear] = value;\n        rear = (rear + 1) % capacity;\n        return true;\n    }\n\n    public bool DeleteFront() {\n        if (IsEmpty()) {\n            return false;\n        }\n        front = (front + 1) % capacity;\n        return true;\n    }\n\n    public bool DeleteLast() {\n        if (IsEmpty()) {\n            return false;\n        }\n        rear = (rear - 1 + capacity) % capacity;\n        return true;\n    }\n\n    public int GetFront() {\n        if (IsEmpty()) {\n            return -1;\n        }\n        return elements[front];\n    }\n\n    public int GetRear() {\n        if (IsEmpty()) {\n            return -1;\n        }\n        return elements[(rear - 1 + capacity) % capacity];\n    }\n\n    public bool IsEmpty() {\n        return rear == front;\n    }\n\n    public bool IsFull() {\n        return (rear + 1) % capacity == front;\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int *elements;\n    int rear, front;\n    int capacity;\n} MyCircularDeque;\n\nMyCircularDeque* myCircularDequeCreate(int k) {\n    MyCircularDeque *obj = (MyCircularDeque *)malloc(sizeof(MyCircularDeque));\n    obj->capacity = k + 1;\n    obj->rear = obj->front = 0;\n    obj->elements = (int *)malloc(sizeof(int) * obj->capacity);\n    return obj;\n}\n\nbool myCircularDequeInsertFront(MyCircularDeque* obj, int value) {\n    if ((obj->rear + 1) % obj->capacity == obj->front) {\n        return false;\n    }\n    obj->front = (obj->front - 1 + obj->capacity) % obj->capacity;\n    obj->elements[obj->front] = value;\n    return true;\n}\n\nbool myCircularDequeInsertLast(MyCircularDeque* obj, int value) {\n    if ((obj->rear + 1) % obj->capacity == obj->front) {\n        return false;\n    }\n    obj->elements[obj->rear] = value;\n    obj->rear = (obj->rear + 1) % obj->capacity;\n    return true;\n}\n\nbool myCircularDequeDeleteFront(MyCircularDeque* obj) {\n    if (obj->rear == obj->front) {\n        return false;\n    }\n    obj->front = (obj->front + 1) % obj->capacity;\n    return true;\n}\n\nbool myCircularDequeDeleteLast(MyCircularDeque* obj) {\n    if (obj->rear == obj->front) {\n        return false;\n    }\n    obj->rear = (obj->rear - 1 + obj->capacity) % obj->capacity;\n    return true;\n}\n\nint myCircularDequeGetFront(MyCircularDeque* obj) {\n    if (obj->rear == obj->front) {\n        return -1;\n    }\n    return obj->elements[obj->front];\n}\n\nint myCircularDequeGetRear(MyCircularDeque* obj) {\n    if (obj->rear == obj->front) {\n        return -1;\n    }\n    return obj->elements[(obj->rear - 1 + obj->capacity) % obj->capacity];\n}\n\nbool myCircularDequeIsEmpty(MyCircularDeque* obj) {\n    return obj->rear == obj->front;\n}\n\nbool myCircularDequeIsFull(MyCircularDeque* obj) {\n    return (obj->rear + 1) % obj->capacity == obj->front;\n}\n\nvoid myCircularDequeFree(MyCircularDeque* obj) {\n    free(obj->elements);\n    free(obj);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar MyCircularDeque = function(k) {\n    this.capacity = k + 1;\n    this.rear = this.front = 0;\n    this.elements = new Array(k + 1).fill(0);\n};\n\nMyCircularDeque.prototype.insertFront = function(value) {\n    if (this.isFull()) {\n        return false;\n    }\n    this.front = (this.front - 1 + this.capacity) % this.capacity;\n    this.elements[this.front] = value;\n    return true;\n};\n\nMyCircularDeque.prototype.insertLast = function(value) {\n    if (this.isFull()) {\n        return false;\n    }\n    this.elements[this.rear] = value;\n    this.rear = (this.rear + 1) % this.capacity;\n    return true;\n};\n\nMyCircularDeque.prototype.deleteFront = function() {\n    if (this.isEmpty()) {\n        return false;\n    }\n    this.front = (this.front + 1) % this.capacity;\n    return true;\n};\n\nMyCircularDeque.prototype.deleteLast = function() {\n    if (this.isEmpty()) {\n        return false;\n    }\n    this.rear = (this.rear - 1 + this.capacity) % this.capacity;\n    return true;\n};\n\nMyCircularDeque.prototype.getFront = function() {\n    if (this.isEmpty()) {\n        return -1;\n    }\n    return this.elements[this.front];\n};\n\nMyCircularDeque.prototype.getRear = function() {\n    if (this.isEmpty()) {\n        return -1;\n    }\n    return this.elements[(this.rear - 1 + this.capacity) % this.capacity];\n};\n\nMyCircularDeque.prototype.isEmpty = function() {\n    return this.rear == this.front;\n};\n\nMyCircularDeque.prototype.isFull = function() {\n    return (this.rear + 1) % this.capacity == this.front;\n};\n```\n\n```go [sol1-Golang]\ntype MyCircularDeque struct {\n    front, rear int\n    elements    []int\n}\n\nfunc Constructor(k int) MyCircularDeque {\n    return MyCircularDeque{elements: make([]int, k+1)}\n}\n\nfunc (q *MyCircularDeque) InsertFront(value int) bool {\n    if q.IsFull() {\n        return false\n    }\n    q.front = (q.front - 1 + len(q.elements)) % len(q.elements)\n    q.elements[q.front] = value\n    return true\n}\n\nfunc (q *MyCircularDeque) InsertLast(value int) bool {\n    if q.IsFull() {\n        return false\n    }\n    q.elements[q.rear] = value\n    q.rear = (q.rear + 1) % len(q.elements)\n    return true\n}\n\nfunc (q *MyCircularDeque) DeleteFront() bool {\n    if q.IsEmpty() {\n        return false\n    }\n    q.front = (q.front + 1) % len(q.elements)\n    return true\n}\n\nfunc (q *MyCircularDeque) DeleteLast() bool {\n    if q.IsEmpty() {\n        return false\n    }\n    q.rear = (q.rear - 1 + len(q.elements)) % len(q.elements)\n    return true\n}\n\nfunc (q MyCircularDeque) GetFront() int {\n    if q.IsEmpty() {\n        return -1\n    }\n    return q.elements[q.front]\n}\n\nfunc (q MyCircularDeque) GetRear() int {\n    if q.IsEmpty() {\n        return -1\n    }\n    return q.elements[(q.rear-1+len(q.elements))%len(q.elements)]\n}\n\nfunc (q MyCircularDeque) IsEmpty() bool {\n    return q.rear == q.front\n}\n\nfunc (q MyCircularDeque) IsFull() bool {\n    return (q.rear+1)%len(q.elements) == q.front\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化和每项操作的时间复杂度均为 $O(1)$。\n\n- 空间复杂度：$O(k)$，其中 $k$ 为给定的队列元素数目。\n\n#### 方法二：链表\n\n我们同样可以使用双向链表来模拟双端队列，实现双端队列队首与队尾元素的添加、删除。双向链表实现比较简单，双向链表支持 $O(1)$ 时间复杂度内在指定节点的前后插入新的节点或者删除新的节点。\n\n![1](https://assets.leetcode-cn.com/solution-static/641/641_1.png)\n\n循环双端队列的属性如下:\n+ $\\texttt{head}$：队列的头节点；\n+ $\\texttt{tail}$：队列的尾节点\n+ $\\texttt{capacity}$：队列的容量大小。\n+ $\\texttt{size}$：队列当前的元素数量。\n\n循环双端队列的接口方法如下：\n+ $\\texttt{MyCircularDeque(int k)}$：初始化队列，同时初始化队列元素数量 $\\textit{size}$ 为 $0$。$\\textit{head},\\textit{tail}$ 初始化为空。 \n+ $\\texttt{insertFront(int value)}$：队列未满时，在队首头结点 $\\textit{head}$ 之前插入一个新的节点，并更新 $\\textit{head}$，并更新 $\\textit{size}$。\n+ $\\texttt{insertLast(int value)}$：队列未满时，在队w尾节点 $\\textit{tail}$ 之后插入一个新的节点，并更新 $\\textit{tail}$，并更新 $\\textit{size}$。\n+ $\\texttt{deleteFront()}$：队列不为空时，删除头结点 $\\textit{head}$，并更新 $\\textit{head}$ 为 $\\textit{head}$ 的后一个节点，并更新 $\\textit{size}$。\n+ $\\texttt{deleteLast()}$：队列不为空时，删除尾结点 $\\textit{tail}$，并更新 $\\textit{tail}$ 为 $\\textit{tail}$ 的前一个节点，并更新 $\\textit{size}$。\n+ $\\texttt{getFront()}$：返回队首节点指向的值，需要检测队列是否为空。\n+ $\\texttt{getRear()}$：返回队尾节点指向的值，需要检测队列是否为空。\n+ $\\texttt{isEmpty()}$：检测当前 $\\textit{size}$ 是否为 $0$。\n+ $\\texttt{isFull()}$：检测当前 $\\textit{size}$ 是否为 $\\textit{capacity}$。\n\n```Python [sol2-Python3]\nclass Node:\n    __slots__ = 'prev', 'next', 'val'\n\n    def __init__(self, val):\n        self.prev = self.next = None\n        self.val = val\n\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.head = self.tail = None\n        self.capacity = k\n        self.size = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        node = Node(value)\n        if self.isEmpty():\n            self.head = node\n            self.tail = node\n        else:\n            node.next = self.head\n            self.head.prev = node\n            self.head = node\n        self.size += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        node = Node(value)\n        if self.isEmpty():\n            self.head = node\n            self.tail = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n            self.tail = node\n        self.size += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.head = self.head.next\n        if self.head:\n            self.head.prev = None\n        self.size -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.tail = self.tail.prev\n        if self.tail:\n            self.tail.next = None\n        self.size -= 1\n        return True\n\n    def getFront(self) -> int:\n        return -1 if self.isEmpty() else self.head.val\n\n    def getRear(self) -> int:\n        return -1 if self.isEmpty() else self.tail.val\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n    def isFull(self) -> bool:\n        return self.size == self.capacity\n```\n\n```C++ [sol2-C++]\nstruct DLinkListNode {\n    int val;\n    DLinkListNode *prev, *next;\n    DLinkListNode(int _val): val(_val), prev(nullptr), next(nullptr) {\n\n    }\n};\n\nclass MyCircularDeque {\nprivate:\n    DLinkListNode *head, *tail;\n    int capacity;\n    int size;\n\npublic:\n    MyCircularDeque(int k): capacity(k), size(0), head(nullptr), tail(nullptr) {\n        \n    }\n\n    bool insertFront(int value) {\n        if (size == capacity) {\n            return false;\n        }\n        DLinkListNode *node = new DLinkListNode(value);\n        if (size == 0) {\n            head = tail = node;\n        } else {\n            node->next = head;\n            head->prev = node;\n            head = node;\n        }\n        size++;\n        return true;\n    }\n\n    bool insertLast(int value) {\n        if (size == capacity) {\n            return false;\n        }\n        DLinkListNode *node = new DLinkListNode(value);\n        if (size == 0) {\n            head = tail = node;\n        } else {\n            tail->next = node;\n            node->prev = tail;\n            tail = node;\n        }\n        size++;\n        return true;\n    }\n\n    bool deleteFront() {\n        if (size == 0) {\n            return false;\n        }\n        DLinkListNode *node = head;\n        head = head->next;\n        if (head) {\n            head->prev = nullptr;\n        }\n        delete node;\n        size--;\n        return true;\n    }\n\n    bool deleteLast() {\n        if (size == 0) {\n            return false;\n        }\n        DLinkListNode *node = tail;\n        tail = tail->prev;\n        if (tail) {\n            tail->next = nullptr;\n        }\n        delete node;\n        size--;\n        return true;\n    }\n\n    int getFront() {\n        if (size == 0) {\n            return -1;\n        }\n        return head->val;\n    }\n\n    int getRear() {\n        if (size == 0) {\n            return -1;\n        }\n        return tail->val;\n    }\n\n    bool isEmpty() {\n        return size == 0;\n    }\n\n    bool isFull() {\n        return size == capacity;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass MyCircularDeque {\n    private class DLinkListNode {\n        int val;\n        DLinkListNode prev, next;\n\n        DLinkListNode(int val) {\n            this.val = val;\n        }\n    }\n\n    private DLinkListNode head, tail;\n    private int capacity;\n    private int size;\n\n    public MyCircularDeque(int k) {\n        capacity = k;\n        size = 0;\n    }\n\n    public boolean insertFront(int value) {\n        if (size == capacity) {\n            return false;\n        }\n        DLinkListNode node = new DLinkListNode(value);\n        if (size == 0) {\n            head = tail = node;\n        } else {\n            node.next = head;\n            head.prev = node;\n            head = node;\n        }\n        size++;\n        return true;\n    }\n\n    public boolean insertLast(int value) {\n        if (size == capacity) {\n            return false;\n        }\n        DLinkListNode node = new DLinkListNode(value);\n        if (size == 0) {\n            head = tail = node;\n        } else {\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n        }\n        size++;\n        return true;\n    }\n\n    public boolean deleteFront() {\n        if (size == 0) {\n            return false;\n        }\n        head = head.next;\n        if (head != null) {\n            head.prev = null;\n        }\n        size--;\n        return true;\n    }\n\n    public boolean deleteLast() {\n        if (size == 0) {\n            return false;\n        }\n        tail = tail.prev;\n        if (tail != null) {\n            tail.next = null;\n        }\n        size--;\n        return true;\n    }\n\n    public int getFront() {\n        if (size == 0) {\n            return -1;\n        }\n        return head.val;\n    }\n\n    public int getRear() {\n        if (size == 0) {\n            return -1;\n        }\n        return tail.val;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class MyCircularDeque {\n    private class DLinkListNode {\n        public int val;\n        public DLinkListNode prev, next;\n\n        public DLinkListNode(int val) {\n            this.val = val;\n        }\n    }\n\n    private DLinkListNode head, tail;\n    private int capacity;\n    private int size;\n\n    public MyCircularDeque(int k) {\n        capacity = k;\n        size = 0;\n    }\n\n    public bool InsertFront(int value) {\n        if (size == capacity) {\n            return false;\n        }\n        DLinkListNode node = new DLinkListNode(value);\n        if (size == 0) {\n            head = tail = node;\n        } else {\n            node.next = head;\n            head.prev = node;\n            head = node;\n        }\n        size++;\n        return true;\n    }\n\n    public bool InsertLast(int value) {\n        if (size == capacity) {\n            return false;\n        }\n        DLinkListNode node = new DLinkListNode(value);\n        if (size == 0) {\n            head = tail = node;\n        } else {\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n        }\n        size++;\n        return true;\n    }\n\n    public bool DeleteFront() {\n        if (size == 0) {\n            return false;\n        }\n        head = head.next;\n        if (head != null) {\n            head.prev = null;\n        }\n        size--;\n        return true;\n    }\n\n    public bool DeleteLast() {\n        if (size == 0) {\n            return false;\n        }\n        tail = tail.prev;\n        if (tail != null) {\n            tail.next = null;\n        }\n        size--;\n        return true;\n    }\n\n    public int GetFront() {\n        if (size == 0) {\n            return -1;\n        }\n        return head.val;\n    }\n\n    public int GetRear() {\n        if (size == 0) {\n            return -1;\n        }\n        return tail.val;\n    }\n\n    public bool IsEmpty() {\n        return size == 0;\n    }\n\n    public bool IsFull() {\n        return size == capacity;\n    }\n}\n```\n\n```C [sol2-C]\ntypedef struct DLinkListNode {\n    int val;\n    struct DLinkListNode *prev, *next;\n} DLinkListNode;\n\ntypedef struct {\n    DLinkListNode *head, *tail;\n    int capacity;\n    int size;\n} MyCircularDeque;\n\nDLinkListNode * dLinkListNodeCreat(int val) {\n    DLinkListNode *obj = (DLinkListNode *)malloc(sizeof(DLinkListNode));\n    obj->val = val;\n    obj->prev = NULL;\n    obj->next = NULL;\n    return obj;\n} \n\nMyCircularDeque* myCircularDequeCreate(int k) {\n    MyCircularDeque *obj = (MyCircularDeque *)malloc(sizeof(MyCircularDeque));\n    obj->capacity = k;\n    obj->size = 0;\n    obj->head = obj->tail = NULL;\n    return obj;\n}\n\nbool myCircularDequeInsertFront(MyCircularDeque* obj, int value) {\n    if (obj->size == obj->capacity) {\n        return false;\n    }\n    DLinkListNode *node = dLinkListNodeCreat(value);\n    if (obj->size == 0) {\n        obj->head = obj->tail = node;\n    } else {\n        node->next = obj->head;\n        obj->head->prev = node;\n        obj->head = node;\n    }\n    obj->size++;\n    return true;\n}\n\nbool myCircularDequeInsertLast(MyCircularDeque* obj, int value) {\n    if (obj->size == obj->capacity) {\n        return false;\n    }\n    DLinkListNode *node = dLinkListNodeCreat(value);\n    if (obj->size == 0) {\n        obj->head = obj->tail = node;\n    } else {\n        obj->tail->next = node;\n        node->prev = obj->tail;\n        obj->tail = node;\n    }\n    obj->size++;\n    return true;\n}\n\nbool myCircularDequeDeleteFront(MyCircularDeque* obj) {\n    if (obj->size == 0) {\n        return false;\n    }\n    DLinkListNode *node = obj->head;\n    obj->head = obj->head->next;\n    if (obj->head) {\n        obj->head->prev = NULL;\n    }\n    free(node);\n    obj->size--;\n    return true;\n}\n\nbool myCircularDequeDeleteLast(MyCircularDeque* obj) {\n    if (obj->size == 0) {\n        return false;\n    }\n    DLinkListNode *node = obj->tail;\n    obj->tail = obj->tail->prev;\n    if (obj->tail) {\n        obj->tail->next = NULL;\n    }\n    free(node);\n    obj->size--;\n    return true;\n}\n\nint myCircularDequeGetFront(MyCircularDeque* obj) {\n    if (obj->size == 0) {\n        return -1;\n    }\n    return obj->head->val;\n}\n\nint myCircularDequeGetRear(MyCircularDeque* obj) {\n    if (obj->size == 0) {\n        return -1;\n    }\n    return obj->tail->val;\n}\n\nbool myCircularDequeIsEmpty(MyCircularDeque* obj) {\n    return obj->size == 0;\n}\n\nbool myCircularDequeIsFull(MyCircularDeque* obj) {\n    return obj->size == obj->capacity;\n}\n\nvoid myCircularDequeFree(MyCircularDeque* obj) {\n    for (DLinkListNode *curr = obj->head; curr;) {\n        DLinkListNode *node = curr;\n        curr = curr->next;\n        free(node);\n    }\n    free(obj);\n}\n```\n\n```go [sol2-Golang]\ntype node struct {\n    prev, next *node\n    val        int\n}\n\ntype MyCircularDeque struct {\n    head, tail     *node\n    capacity, size int\n}\n\nfunc Constructor(k int) MyCircularDeque {\n    return MyCircularDeque{capacity: k}\n}\n\nfunc (q *MyCircularDeque) InsertFront(value int) bool {\n    if q.IsFull() {\n        return false\n    }\n    node := &node{val: value}\n    if q.IsEmpty() {\n        q.head = node\n        q.tail = node\n    } else {\n        node.next = q.head\n        q.head.prev = node\n        q.head = node\n    }\n    q.size++\n    return true\n}\n\nfunc (q *MyCircularDeque) InsertLast(value int) bool {\n    if q.IsFull() {\n        return false\n    }\n    node := &node{val: value}\n    if q.IsEmpty() {\n        q.head = node\n        q.tail = node\n    } else {\n        q.tail.next = node\n        node.prev = q.tail\n        q.tail = node\n    }\n    q.size++\n    return true\n}\n\nfunc (q *MyCircularDeque) DeleteFront() bool {\n    if q.IsEmpty() {\n        return false\n    }\n    q.head = q.head.next\n    if q.head != nil {\n        q.head.prev = nil\n    }\n    q.size--\n    return true\n}\n\nfunc (q *MyCircularDeque) DeleteLast() bool {\n    if q.IsEmpty() {\n        return false\n    }\n    q.tail = q.tail.prev\n    if q.tail != nil {\n        q.tail.next = nil\n    }\n    q.size--\n    return true\n}\n\nfunc (q MyCircularDeque) GetFront() int {\n    if q.IsEmpty() {\n        return -1\n    }\n    return q.head.val\n}\n\nfunc (q MyCircularDeque) GetRear() int {\n    if q.IsEmpty() {\n        return -1\n    }\n    return q.tail.val\n}\n\nfunc (q MyCircularDeque) IsEmpty() bool {\n    return q.size == 0\n}\n\nfunc (q MyCircularDeque) IsFull() bool {\n    return q.size == q.capacity\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化和每项操作的时间复杂度均为 $O(1)$。\n\n- 空间复杂度：$O(k)$，其中 $k$ 为给定的队列元素数目。"
}