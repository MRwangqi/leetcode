{
	"titleSlug": "stickers-to-spell-word",
	"slug": "tie-zhi-pin-ci-by-leetcode-solution-9g3z",
	"url": "https://leetcode-cn.com/problems/stickers-to-spell-word/solution/tie-zhi-pin-ci-by-leetcode-solution-9g3z/",
	"content": "#### 方法一：记忆化搜索 + 状态压缩\n\n**思路**\n\n记 $\\textit{target}$ 的长度为 $m$，它一共有 $2^m$ 个子序列（包括空子序列和 $\\textit{target}$ 本身，字符相同但组成的下标不同的子序列视为不同的子序列）。根据动态规划的思路，拼出某个子序列 $\\textit{mask}$ 所需要的最小贴纸数又可以由 $\\textit{mask}$ 的子序列来计算，下一段介绍动态规划的思路。\n\n在本题中，定义函数 $\\textit{dp}(\\textit{mask})$ 来求解不同状态的最小贴纸数，输入是某个子序列 $\\textit{mask}$，输出是拼出该子序列的最小贴纸数。计算拼出 $\\textit{mask}$ 所需的最小贴纸数时，需要选取最优的 $\\textit{sticker}$ 让其贡献部分字符，未被 $\\textit{sticker}$ 覆盖的其他字符 $\\textit{left}$ 需要用动态规划继续计算。在选取最优的 $\\textit{sticker}$ 时，需要遍历所有 $\\textit{sticker}$。遍历到某个 $\\textit{sticker}$ 时，计算 $\\textit{mask}$ 和 $\\textit{sticker}$ 字符的最大交集（非空），$\\textit{mask}$ 中这部分交集由 $\\textit{sticker}$ 贡献，剩余部分的最小贴纸数由动态规划继续计算，而 $\\textit{sticker}$ 中不属于最大交集的剩下部分会被舍弃，不会产生任何贡献。遍历完所有 $\\textit{sticker}$ 后，选取出所有贴纸数的最小值作为本次规划的结果，这一遍历 $\\textit{stickers}$ 并根据剩余部分的最小贴纸数来计算当前 $\\textit{mask}$ 的最小贴纸数的步骤完成了状态转移。边界情况是，如果 $\\textit{mask}$ 为空集，则贴纸数为 $0$。\n\n在动态规划时，子序列可以用一个二进制数来表示。从低位到高位，某位为 $0$ 则表示在 $\\textit{target}$ 中这一位不选取，为 $1$ 则表示选取这一位，从而完成状态压缩的过程。代码实现上，本题解选择了记忆化搜索的方式。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def minStickers(self, stickers: List[str], target: str) -> int:\n        m = len(target)\n        @cache\n        def dp(mask: int) -> int:\n            if mask == 0:\n                return 0\n            res = m + 1\n            for sticker in stickers:\n                left = mask\n                cnt = Counter(sticker)\n                for i, c in enumerate(target):\n                    if mask >> i & 1 and cnt[c]:\n                        cnt[c] -= 1\n                        left ^= 1 << i\n                if left < mask:\n                    res = min(res, dp(left) + 1)\n            return res\n        res = dp((1 << m) - 1)\n        return res if res <= m else -1\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minStickers(vector<string>& stickers, string target) {\n        int m = target.size();\n        vector<int> dp(1 << m, -1);\n        dp[0] = 0;\n        function<int(int)> helper = [&](int mask) {\n            if (dp[mask] != -1) {\n                return dp[mask];\n            }\n            dp[mask] = m + 1;\n            for (auto & sticker : stickers) {\n                int left = mask;\n                vector<int> cnt(26);\n                for (char & c : sticker) {\n                    cnt[c - 'a']++;\n                }\n                for (int i = 0; i < m; i++) {\n                    if ((mask >> i & 1) && cnt[target[i] - 'a'] > 0) {\n                        cnt[target[i] - 'a']--;\n                        left ^= 1 << i;\n                    }\n                }\n                if (left < mask) {\n                    dp[mask] = min(dp[mask], helper(left) + 1);\n                }\n            }\n            return dp[mask];\n        };\n        int res = helper((1 << m) - 1);\n        return res > m ? -1 : res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minStickers(String[] stickers, String target) {\n        int m = target.length();\n        int[] memo = new int[1 << m];\n        Arrays.fill(memo, -1);\n        memo[0] = 0;\n        int res = dp(stickers, target, memo, (1 << m) - 1);\n        return res <= m ? res : -1;\n    }\n\n    public int dp(String[] stickers, String target, int[] memo, int mask) {\n        int m = target.length();\n        if (memo[mask] < 0) {\n            int res = m + 1;\n            for (String sticker : stickers) {\n                int left = mask;\n                int[] cnt = new int[26];\n                for (int i = 0; i < sticker.length(); i++) {\n                    cnt[sticker.charAt(i) - 'a']++;\n                }\n                for (int i = 0; i < target.length(); i++) {\n                    char c = target.charAt(i);\n                    if (((mask >> i) & 1) == 1 && cnt[c - 'a'] > 0) {\n                        cnt[c - 'a']--;\n                        left ^= 1 << i;\n                    }\n                }\n                if (left < mask) {\n                    res = Math.min(res, dp(stickers, target, memo, left) + 1);\n                }\n            }\n            memo[mask] = res;\n        }\n        return memo[mask];\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinStickers(string[] stickers, string target) {\n        int m = target.Length;\n        int[] memo = new int[1 << m];\n        Array.Fill(memo, -1);\n        memo[0] = 0;\n        int res = DP(stickers, target, memo, (1 << m) - 1);\n        return res <= m ? res : -1;\n    }\n\n    public int DP(string[] stickers, string target, int[] memo, int mask) {\n        int m = target.Length;\n        if (memo[mask] < 0) {\n            int res = m + 1;\n            foreach (string sticker in stickers) {\n                int left = mask;\n                int[] cnt = new int[26];\n                for (int i = 0; i < sticker.Length; i++) {\n                    cnt[sticker[i] - 'a']++;\n                }\n                for (int i = 0; i < target.Length; i++) {\n                    char c = target[i];\n                    if (((mask >> i) & 1) == 1 && cnt[c - 'a'] > 0) {\n                        cnt[c - 'a']--;\n                        left ^= 1 << i;\n                    }\n                }\n                if (left < mask) {\n                    res = Math.Min(res, DP(stickers, target, memo, left) + 1);\n                }\n            }\n            memo[mask] = res;\n        }\n        return memo[mask];\n    }\n}\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nstatic int helper(int mask, int * dp, char ** stickers, int stickersSize, char * target) {\n    int m = strlen(target);\n    if (dp[mask] != -1) {\n        return dp[mask];\n    }\n    dp[mask] = m + 1;\n    for (int j = 0; j < stickersSize; j++) {\n        int left = mask;\n        int cnt[26];\n        int len = strlen(stickers[j]);\n        memset(cnt, 0, sizeof(cnt));\n        for (int i = 0; i < len; i++) {\n            cnt[stickers[j][i] - 'a']++;\n        }\n        for (int i = 0; i < m; i++) {\n            if ((mask >> i & 1) && cnt[target[i] - 'a'] > 0) {\n                cnt[target[i] - 'a']--;\n                left ^= 1 << i;\n            }\n        }\n        if (left < mask) {\n            dp[mask] = MIN(dp[mask], helper(left, dp, stickers, stickersSize, target) + 1);\n        }\n    }\n    return dp[mask];\n};\n\nint minStickers(char ** stickers, int stickersSize, char * target) {\n    int m = strlen(target);\n    int * dp = (int *)malloc(sizeof(int) * (1 << m));\n    memset(dp, -1, sizeof(int) * (1 << m));\n    dp[0] = 0;\n    int res = helper((1 << m) - 1, dp, stickers, stickersSize, target);\n    free(dp);\n    return res > m ? -1 : res;\n}\n```\n\n```go [sol1-Golang]\nfunc minStickers(stickers []string, target string) int {\n    m := len(target)\n    f := make([]int, 1<<m)\n    for i := range f {\n        f[i] = -1\n    }\n    f[0] = 0\n    var dp func(int) int\n    dp = func(mask int) int {\n        if f[mask] != -1 {\n            return f[mask]\n        }\n        f[mask] = m + 1\n        for _, sticker := range stickers {\n            left := mask\n            cnt := [26]int{}\n            for _, c := range sticker {\n                cnt[c-'a']++\n            }\n            for i, c := range target {\n                if mask>>i&1 == 1 && cnt[c-'a'] > 0 {\n                    cnt[c-'a']--\n                    left ^= 1 << i\n                }\n            }\n            if left < mask {\n                f[mask] = min(f[mask], dp(left)+1)\n            }\n        }\n        return f[mask]\n    }\n    ans := dp(1<<m - 1)\n    if ans <= m {\n        return ans\n    }\n    return -1\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minStickers = function(stickers, target) {\n    const m = target.length;\n    const memo = new Array(1 << m).fill(-1);\n    memo[0] = 0;\n    const res = dp(stickers, target, memo, (1 << m) - 1);\n    return res <= m ? res : -1;\n};\n\nconst dp = (stickers, target, memo, mask) => {\n    const m = target.length;\n    if (memo[mask] < 0) {\n        let res = m + 1;\n        for (const sticker of stickers) {\n            let left = mask;\n            const cnt = new Array(26).fill(0);\n            for (let i = 0; i < sticker.length; i++) {\n                cnt[sticker[i].charCodeAt() - 'a'.charCodeAt()]++;\n            }\n            for (let i = 0; i < target.length; i++) {\n                const c = target[i];\n                if (((mask >> i) & 1) === 1 && cnt[c.charCodeAt() - 'a'.charCodeAt()] > 0) {\n                    cnt[c.charCodeAt() - 'a'.charCodeAt()]--;\n                    left ^= 1 << i;\n                }\n            }\n            if (left < mask) {\n                res = Math.min(res, dp(stickers, target, memo, left) + 1);\n            }\n        }\n        memo[mask] = res;\n    }\n    return memo[mask];\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(2 ^ m \\times n \\times (c + m))$，其中 $m$ 为 $\\textit{target}$ 的长度，$c$ 为每个 $\\textit{sticker}$ 的平均字符数。一共有 $O(2 ^ m)$ 个状态。计算每个状态时，需要遍历 $n$ 个 $\\textit{sticker}$。遍历每个 $\\textit{sticker}$ 时，需要遍历它所有字符和 $\\textit{target}$ 所有字符。\n\n- 空间复杂度：$O(2 ^ m)$，记忆化时需要保存每个状态的贴纸数量。"
}