{
	"titleSlug": "smallest-missing-genetic-value-in-each-subtree",
	"slug": "dui-by-sweet-villanijaz-t2ei",
	"url": "https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/dui-by-sweet-villanijaz-t2ei/",
	"content": "思路来自第2424题\n\n\n\nclass Solution {\n\n&#x20;   public int\\[] smallestMissingValueSubtree(int\\[] parents, int\\[] nums) {\n\n&#x20;       ArrayList\\<Integer>\\[] graph = new ArrayList\\[nums.length];\n\n&#x20;       for (int i = 0; i < nums.length; i++) {\n\n&#x20;           graph\\[i] = new ArrayList<>();\n\n&#x20;       }\n\n&#x20;       for (int i = 0; i < parents.length; i++) {\n\n&#x20;           if (parents\\[i] >= 0) {\n\n&#x20;               graph\\[parents\\[i]].add(i);\n\n&#x20;           }\n\n&#x20;       }\n\n&#x20;       int\\[] res = new int\\[nums.length];\n\n&#x20;       dfs(0, nums, res, graph);\n\n&#x20;       return res;\n\n&#x20;   }\n\n&#x20;  &#x20;\n\n&#x20;   private Prefix dfs(int node, int\\[] nums, int\\[] res, ArrayList\\<Integer>\\[] graph) {\n\n&#x20;       Prefix prefix = new Prefix();\n\n&#x20;       for (int child : graph\\[node]) {\n\n&#x20;           prefix.merge(dfs(child, nums, res, graph));\n\n&#x20;       }\n\n&#x20;       prefix.insert(nums\\[node]);\n\n&#x20;       res\\[node] = prefix.firstMissing;\n\n&#x20;       return prefix;\n\n&#x20;   }\n\n}\n\nclass Heap {\n\n&#x20;   static class HeapNode {\n\n&#x20;       HeapNode sibling;\n\n&#x20;       HeapNode children;\n\n&#x20;       int value;\n\n&#x20;      &#x20;\n\n&#x20;       public HeapNode(int value) {\n\n&#x20;           this.value = value;\n\n&#x20;       }\n\n&#x20;   }\n\n&#x20;  &#x20;\n\n&#x20;   static HeapNode melt(HeapNode a, HeapNode b) {\n\n&#x20;       if (a == null) return b;\n\n&#x20;       if (b == null) return a;\n\n&#x20;       if (a.value <= b.value) {\n\n&#x20;           b.sibling = a.children;\n\n&#x20;           a.children = b;\n\n&#x20;           return a;\n\n&#x20;       } else {\n\n&#x20;           a.sibling = b.children;\n\n&#x20;           b.children = a;\n\n&#x20;           return b;\n\n&#x20;       }\n\n&#x20;      &#x20;\n\n&#x20;   }\n\n&#x20;  &#x20;\n\n&#x20;   static HeapNode merge(HeapNode node) {\n\n&#x20;       if (node == null || node.sibling == null) return node;\n\n&#x20;       HeapNode next = node.sibling;\n\n&#x20;       HeapNode nextNext = next.sibling;\n\n&#x20;      &#x20;\n\n&#x20;       node.sibling = null;\n\n&#x20;       next.sibling = null;\n\n&#x20;      &#x20;\n\n&#x20;       return melt(melt(node, next), merge(nextNext));\n\n&#x20;   }\n\n&#x20;  &#x20;\n\n&#x20;   private HeapNode root = null;\n\n&#x20;  &#x20;\n\n&#x20;   public void offer(int value) {\n\n&#x20;       this.root = melt(this.root, new HeapNode(value));\n\n&#x20;   }\n\n&#x20;  &#x20;\n\n&#x20;   public int peek() {\n\n&#x20;       return this.root.value;\n\n&#x20;   }\n\n&#x20;  &#x20;\n\n&#x20;   public void poll() {\n\n&#x20;       this.root = merge(this.root.children);\n\n&#x20;   }\n\n&#x20;  &#x20;\n\n&#x20;   public void merge(Heap heap) {\n\n&#x20;       this.root = melt(this.root, heap.root);\n\n&#x20;   }\n\n&#x20;  &#x20;\n\n&#x20;   public boolean isEmpty() {\n\n&#x20;       return this.root == null;\n\n&#x20;   }\n\n}\n\nclass Prefix {\n\n&#x20;   int firstMissing = 1;\n\n&#x20;   Heap heap = new Heap();\n\n&#x20;  &#x20;\n\n&#x20;   public void insert(int value) {\n\n&#x20;       heap.offer(value);\n\n&#x20;       while (!heap.isEmpty() && heap.peek() == firstMissing) {\n\n&#x20;           heap.poll();\n\n&#x20;           firstMissing++;\n\n&#x20;       }\n\n&#x20;   }\n\n&#x20;  &#x20;\n\n&#x20;   public void merge(Prefix prefix) {\n\n&#x20;       this.firstMissing = Math.max(this.firstMissing, prefix.firstMissing);\n\n&#x20;       this.heap.merge(prefix.heap);\n\n&#x20;   }\n\n}\n"
}