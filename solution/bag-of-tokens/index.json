{
	"titleSlug": "bag-of-tokens",
	"slug": "ling-pai-fang-zhi-by-leetcode",
	"url": "https://leetcode-cn.com/problems/bag-of-tokens/solution/ling-pai-fang-zhi-by-leetcode/",
	"content": "#### 方法一： 贪心\n\n**思路**\n\n如果让我们来玩令牌放置这个游戏，在让令牌正面朝上的时候，肯定要去找能量最小的令牌。同样的，在让令牌反面朝上的时候，肯定要去找能量最大的令牌。\n\n**算法**\n\n只要还有能量，就一直让令牌正面朝上，直到没有能量的时候，让一个令牌反面朝上从而获得能量继续之前的操作。\n\n一定要小心处理边界条件，不然很有可能会写出错误的答案。这里要牢牢记住，在有能量时候，只能让令牌正面朝上，直到能量不够用了才能让令牌反面朝上。\n\n最终答案一定是在一次让令牌正常朝上操作之后产生的（永远不可能在让令牌反面朝上操作之后产生）\n\n```java [solution1-Java]\nclass Solution {\n    public int bagOfTokensScore(int[] tokens, int P) {\n        Arrays.sort(tokens);\n        int lo = 0, hi = tokens.length - 1;\n        int points = 0, ans = 0;\n        while (lo <= hi && (P >= tokens[lo] || points > 0)) {\n            while (lo <= hi && P >= tokens[lo]) {\n                P -= tokens[lo++];\n                points++;\n            }\n\n            ans = Math.max(ans, points);\n            if (lo <= hi && points > 0) {\n                P += tokens[hi--];\n                points--;\n            }\n        }\n\n        return ans;\n    }\n}\n```\n\n```python [solution1-Python]\nclass Solution(object):\n    def bagOfTokensScore(self, tokens, P):\n        tokens.sort()\n        deque = collections.deque(tokens)\n        ans = bns = 0\n        while deque and (P >= deque[0] or bns):\n            while deque and P >= deque[0]:\n                P -= deque.popleft()\n                bns += 1\n            ans = max(ans, bns)\n\n            if deque and bns:\n                P += deque.pop()\n                bns -= 1\n\n        return ans\n```\n\n**复杂度分析**\n\n* 时间复杂度： $O(N \\log N)$，其中 $N$ 是 `tokens` 的大小。\n\n* 空间复杂度： $O(N)$。"
}