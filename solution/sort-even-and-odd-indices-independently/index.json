{
	"titleSlug": "sort-even-and-odd-indices-independently",
	"slug": "dui-qi-ou-xia-biao-fen-bie-pai-xu-by-lee-31wr",
	"url": "https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/solution/dui-qi-ou-xia-biao-fen-bie-pai-xu-by-lee-31wr/",
	"content": "#### 方法一：按要求操作\n\n**思路与算法**\n\n我们可以用 $\\textit{even}$ 和 $\\textit{odd}$ 两个辅助数组分别存储数组 $\\textit{nums}$ 的奇偶下标元素，随后对两个数组按要求排序：$\\textit{even}$ 升序排序，$\\textit{odd}$ 降序排序。最终，我们将排序后的 $\\textit{even}$ 和 $\\textit{odd}$ 数组的元素交替放回 $\\textit{nums}$ 中，具体地：\n\n- $\\textit{nums}[2i] = \\textit{even}[i]$，\n\n- $\\textit{nums}[2i+1] = \\textit{odd}[i]$\n\n最终，我们返回更新后的 $\\textit{nums}$ 数组作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> sortEvenOdd(vector<int>& nums) {\n        vector<int> even, odd;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (i % 2 == 0) {\n                even.push_back(nums[i]);\n            }\n            else {\n                odd.push_back(nums[i]);\n            }\n        }\n        sort(even.begin(), even.end());\n        sort(odd.begin(), odd.end(), greater<int>());\n        for (int i = 0; i < even.size(); ++i) {\n            nums[2*i] = even[i];\n        }\n        for (int i = 0; i < odd.size(); ++i) {\n            nums[2*i+1] = odd[i];\n        }\n        return nums;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def sortEvenOdd(self, nums: List[int]) -> List[int]:\n        even = sorted(nums[::2])\n        odd = sorted(nums[1::2])[::-1]\n        nums[::2] = even\n        nums[1::2] = odd\n        return nums\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 为 $\\textit{nums}$ 的长度。即为对数组奇偶下标分别排序的时间复杂度。\n\n- 空间复杂度：$O(n)$，即为辅助数组的空间开销。"
}