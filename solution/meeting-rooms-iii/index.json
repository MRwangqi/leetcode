{
	"titleSlug": "meeting-rooms-iii",
	"slug": "shuang-dui-mo-ni-pythonjavacgo-by-endles-ctwc",
	"url": "https://leetcode-cn.com/problems/meeting-rooms-iii/solution/shuang-dui-mo-ni-pythonjavacgo-by-endles-ctwc/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1Dt4y1j7qh) 已出炉，欢迎素质三连，在评论区分享你对这场周赛的看法~\r\n\r\n---\r\n\r\n用两个小顶堆模拟：\r\n\r\n- $\\textit{idle}$ 维护在 $\\textit{start}_i$ 时刻空闲的会议室的编号；\r\n- $\\textit{using}$ 维护在 $\\textit{start}_i$ 时刻使用中的会议室的结束时间和编号。\r\n\r\n这两类会议室是互补关系，伴随着会议的开始和结束，会议室在这两类中来回倒。\r\n\r\n对 $\\textit{meetings}$ 按照开始时间排序，然后遍历 $\\textit{meetings}$，按照题目要求模拟即可，具体模拟方式见代码。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n+m(\\log n + \\log m))$，其中 $m$ 为 $\\textit{meetings}$ 的长度。注意每个会议至多入堆出堆各一次。\r\n- 空间复杂度：$O(n)$。\r\n\r\n#### 相似题目\r\n\r\n- [1606. 找到处理最多请求的服务器](https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/)\r\n- [1882. 使用服务器处理任务](https://leetcode.cn/problems/process-tasks-using-servers/)\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\r\n        cnt = [0] * n\r\n        idle, using = list(range(n)), []\r\n        meetings.sort(key=lambda m: m[0])\r\n        for st, end in meetings:\r\n            while using and using[0][0] <= st:\r\n                heappush(idle, heappop(using)[1])  # 维护在 st 时刻空闲的会议室\r\n            if len(idle) == 0:\r\n                e, i = heappop(using)  # 没有可用的会议室，那么弹出一个最早结束的会议室（若有多个同时结束的，会弹出下标最小的）\r\n                end += e - st  # 更新当前会议的结束时间\r\n            else:\r\n                i = heappop(idle)\r\n            cnt[i] += 1\r\n            heappush(using, (end, i))  # 使用一个会议室\r\n        ans = 0\r\n        for i, c in enumerate(cnt):\r\n            if c > cnt[ans]:\r\n                ans = i\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int mostBooked(int n, int[][] meetings) {\r\n        var cnt = new int[n];\r\n        var idle = new PriorityQueue<Integer>();\r\n        for (var i = 0; i < n; ++i) idle.offer(i);\r\n        var using = new PriorityQueue<Pair<Long, Integer>>((a, b) -> !Objects.equals(a.getKey(), b.getKey()) ? Long.compare(a.getKey(), b.getKey()) : Integer.compare(a.getValue(), b.getValue()));\r\n        Arrays.sort(meetings, (a, b) -> Integer.compare(a[0], b[0]));\r\n        for (var m : meetings) {\r\n            long st = m[0], end = m[1];\r\n            while (!using.isEmpty() && using.peek().getKey() <= st) {\r\n                idle.offer(using.poll().getValue()); // 维护在 st 时刻空闲的会议室\r\n            }\r\n            int id;\r\n            if (idle.isEmpty()) {\r\n                var p = using.poll(); // 没有可用的会议室，那么弹出一个最早结束的会议室（若有多个同时结束的，会弹出下标最小的）\r\n                end += p.getKey() - st; // 更新当前会议的结束时间\r\n                id = p.getValue();\r\n            } else id = idle.poll();\r\n            ++cnt[id];\r\n            using.offer(new Pair<>(end, id)); // 使用一个会议室\r\n        }\r\n        var ans = 0;\r\n        for (var i = 0; i < n; ++i) if (cnt[i] > cnt[ans]) ans = i;\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int mostBooked(int n, vector<vector<int>> &meetings) {\r\n        int cnt[n]; memset(cnt, 0, sizeof(cnt));\r\n        priority_queue<int, vector<int>, greater<>> idle;\r\n        for (int i = 0; i < n; ++i) idle.push(i);\r\n        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<>> using_;\r\n        sort(meetings.begin(), meetings.end(), [](auto &a, auto &b) { return a[0] < b[0]; });\r\n        for (auto &m : meetings) {\r\n            long st = m[0], end = m[1], id;\r\n            while (!using_.empty() && using_.top().first <= st) {\r\n                idle.push(using_.top().second); // 维护在 st 时刻空闲的会议室\r\n                using_.pop();\r\n            }\r\n            if (idle.empty()) {\r\n                auto[e, i] = using_.top(); // 没有可用的会议室，那么弹出一个最早结束的会议室（若有多个同时结束的，会弹出下标最小的）\r\n                using_.pop();\r\n                end += e - st; // 更新当前会议的结束时间\r\n                id = i;\r\n            } else {\r\n                id = idle.top();\r\n                idle.pop();\r\n            }\r\n            ++cnt[id];\r\n            using_.emplace(end, id); // 使用一个会议室\r\n        }\r\n        int ans = 0;\r\n        for (int i = 0; i < n; ++i) if (cnt[i] > cnt[ans]) ans = i;\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc mostBooked(n int, meetings [][]int) (ans int) {\r\n\tcnt := make([]int, n)\r\n\tidle := hp{make([]int, n)}\r\n\tfor i := 0; i < n; i++ {\r\n\t\tidle.IntSlice[i] = i\r\n\t}\r\n\tusing := hp2{}\r\n\tsort.Slice(meetings, func(i, j int) bool { return meetings[i][0] < meetings[j][0] })\r\n\tfor _, m := range meetings {\r\n\t\tst, end := m[0], m[1]\r\n\t\tfor len(using) > 0 && using[0].end <= st {\r\n\t\t\theap.Push(&idle, heap.Pop(&using).(pair).i) // 维护在 st 时刻空闲的会议室\r\n\t\t}\r\n\t\tvar i int\r\n\t\tif idle.Len() == 0 {\r\n\t\t\tp := heap.Pop(&using).(pair) // 没有可用的会议室，那么弹出一个最早结束的会议室（若有多个同时结束的，会弹出下标最小的）\r\n\t\t\tend += p.end - st // 更新当前会议的结束时间\r\n\t\t\ti = p.i\r\n\t\t} else {\r\n\t\t\ti = heap.Pop(&idle).(int)\r\n\t\t}\r\n\t\tcnt[i]++\r\n\t\theap.Push(&using, pair{end, i}) // 使用一个会议室\r\n\t}\r\n\tfor i, c := range cnt {\r\n\t\tif c > cnt[ans] {\r\n\t\t\tans = i\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n\r\ntype hp struct{ sort.IntSlice }\r\nfunc (h *hp) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) }\r\nfunc (h *hp) Pop() interface{}   { a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v }\r\n\r\ntype pair struct{ end, i int }\r\ntype hp2 []pair\r\nfunc (h hp2) Len() int            { return len(h) }\r\nfunc (h hp2) Less(i, j int) bool  { a, b := h[i], h[j]; return a.end < b.end || a.end == b.end && a.i < b.i }\r\nfunc (h hp2) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\r\nfunc (h *hp2) Push(v interface{}) { *h = append(*h, v.(pair)) }\r\nfunc (h *hp2) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }\r\n```\r\n"
}