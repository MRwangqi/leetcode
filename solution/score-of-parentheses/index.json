{
	"titleSlug": "score-of-parentheses",
	"slug": "gua-hao-de-fen-shu-by-leetcode-solution-we6b",
	"url": "https://leetcode-cn.com/problems/score-of-parentheses/solution/gua-hao-de-fen-shu-by-leetcode-solution-we6b/",
	"content": "#### 方法一：分治\n\n根据题意，一个平衡括号字符串 $s$ 可以被分解为 $A+B$ 或 $(A)$ 的形式，因此我们可以对 $s$ 进行分解，分而治之。\n\n如何判断 $s$ 应该分解为 $A+B$ 或 $(A)$ 的哪一种呢？我们将左括号记为 $1$，右括号记为 $-1$，如果 $s$ 的某个非空前缀对应的和 $\\textit{bal} = 0$，那么这个前缀就是一个平衡括号字符串。如果该前缀长度等于 $s$ 的长度，那么 $s$ 可以分解为 $(A)$ 的形式；否则 $s$ 可以分解为 $A + B$ 的形式，其中 $A$ 为该前缀。将 $s$ 分解之后，我们递归地求解子问题，并且 $s$ 的长度为 $2$ 时，分数为 $1$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def scoreOfParentheses(self, s: str) -> int:\n        n = len(s)\n        if n == 2:\n            return 1\n        bal = 0\n        for i, c in enumerate(s):\n            bal += 1 if c == '(' else -1\n            if bal == 0:\n                if i == n - 1:\n                    return 2 * self.scoreOfParentheses(s[1:-1])\n                return self.scoreOfParentheses(s[:i + 1]) + self.scoreOfParentheses(s[i + 1:])\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int scoreOfParentheses(string s) {\n        if (s.size() == 2) {\n            return 1;\n        }\n        int bal = 0, n = s.size(), len;\n        for (int i = 0; i < n; i++) {\n            bal += (s[i] == '(' ? 1 : -1);\n            if (bal == 0) {\n                len = i + 1;\n                break;\n            }\n        }\n        if (len == n) {\n            return 2 * scoreOfParentheses(s.substr(1, n - 2));\n        } else {\n            return scoreOfParentheses(s.substr(0, len)) + scoreOfParentheses(s.substr(len, n - len));\n        }\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int scoreOfParentheses(String s) {\n        if (s.length() == 2) {\n            return 1;\n        }\n        int bal = 0, n = s.length(), len = 0;\n        for (int i = 0; i < n; i++) {\n            bal += (s.charAt(i) == '(' ? 1 : -1);\n            if (bal == 0) {\n                len = i + 1;\n                break;\n            }\n        }\n        if (len == n) {\n            return 2 * scoreOfParentheses(s.substring(1, n - 1));\n        } else {\n            return scoreOfParentheses(s.substring(0, len)) + scoreOfParentheses(s.substring(len));\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int ScoreOfParentheses(string s) {\n        if (s.Length == 2) {\n            return 1;\n        }\n        int bal = 0, n = s.Length, len = 0;\n        for (int i = 0; i < n; i++) {\n            bal += (s[i] == '(' ? 1 : -1);\n            if (bal == 0) {\n                len = i + 1;\n                break;\n            }\n        }\n        if (len == n) {\n            return 2 * ScoreOfParentheses(s.Substring(1, n - 2));\n        } else {\n            return ScoreOfParentheses(s.Substring(0, len)) + ScoreOfParentheses(s.Substring(len));\n        }\n    }\n}\n```\n\n```C [sol1-C]\nint scoreOfParentheses(char * s) {\n    int n = strlen(s);\n    if (n == 2) {\n        return 1;\n    }\n    int bal = 0, len = 0;\n    for (int i = 0; i < n; i++) {\n        bal += (s[i] == '(' ? 1 : -1);\n        if (bal == 0) {\n            len = i + 1;\n            break;\n        }\n    }\n    if (len == n) {\n        char str[n - 1];\n        strncpy(str, s + 1, n - 2);\n        str[n - 2] = '\\0';\n        return 2 * scoreOfParentheses(str);\n    } else {\n        char str1[len + 1], str2[n - len + 1];\n        strncpy(str1, s, len);\n        str1[len] = '\\0';\n        strncpy(str2, s + len, n - len);\n        str2[n - len] = '\\0';\n        return scoreOfParentheses(str1) + scoreOfParentheses(str2);\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc scoreOfParentheses(s string) int {\n    n := len(s)\n    if n == 2 {\n        return 1\n    }\n    for i, bal := 0, 0; ; i++ {\n        if s[i] == '(' {\n            bal++\n        } else {\n            bal--\n            if bal == 0 {\n                if i == n-1 {\n                    return 2 * scoreOfParentheses(s[1:n-1])\n                }\n                return scoreOfParentheses(s[:i+1]) + scoreOfParentheses(s[i+1:])\n            }\n        }\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar scoreOfParentheses = function(s) {\n    if (s.length === 2) {\n        return 1;\n    }\n    let bal = 0, n = s.length, len = 0;\n    for (let i = 0; i < n; i++) {\n        bal += (s[i] === '(' ? 1 : -1);\n        if (bal === 0) {\n            len = i + 1;\n            break;\n        }\n    }\n    if (len === n) {\n        return 2 * scoreOfParentheses(s.slice(1, n - 1));\n    } else {\n        return scoreOfParentheses(s.slice(0, len)) + scoreOfParentheses(s.slice(len));\n    }\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。递归深度为 $O(n)$，每一层的所有函数调用的总时间复杂度都是 $O(n)$，因此总时间复杂度为 $O(n^2)$。\n\n+ 空间复杂度：$O(n^2)$。每一层都需要将字符串复制一遍，因此总空间复杂度为 $O(n^2)$。对于字符串支持切片的语言，空间复杂度为递归栈所需的空间 $O(n)$。\n\n#### 方法二：栈\n\n我们把平衡字符串 $s$ 看作是一个空字符串加上 $s$ 本身，并且定义空字符串的分数为 $0$。使用栈 $\\textit{st}$ 记录平衡字符串的分数，在开始之前要压入分数 $0$，表示空字符串的分数。\n\n在遍历字符串 $s$ 的过程中：\n\n+ 遇到左括号，那么我们需要计算该左括号内部的子平衡括号字符串 $A$ 的分数，我们也要先压入分数 $0$，表示 $A$ 前面的空字符串的分数。\n\n+ 遇到右括号，说明该右括号内部的子平衡括号字符串 $A$ 的分数已经计算出来了，我们将它弹出栈，并保存到变量 $v$ 中。如果 $v = 0$，那么说明子平衡括号字符串 $A$ 是空串，$(A)$ 的分数为 $1$，否则 $(A)$ 的分数为 $2v$，然后将 $(A)$ 的分数加到栈顶元素上。\n\n遍历结束后，栈顶元素保存的就是 $s$ 的分数。\n\n```Python [sol2-Python3]\nclass Solution:\n    def scoreOfParentheses(self, s: str) -> int:\n        st = [0]\n        for c in s:\n            if c == '(':\n                st.append(0)\n            else:\n                v = st.pop()\n                st[-1] += max(2 * v, 1)\n        return st[-1]\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int scoreOfParentheses(string s) {\n        stack<int> st;\n        st.push(0);\n        for (auto c : s) {\n            if (c == '(') {\n                st.push(0);\n            } else {\n                int v = st.top();\n                st.pop();\n                st.top() += max(2 * v, 1);\n            }\n        }\n        return st.top();\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int scoreOfParentheses(String s) {\n        Deque<Integer> st = new ArrayDeque<Integer>();\n        st.push(0);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                st.push(0);\n            } else {\n                int v = st.pop();\n                int top = st.pop() + Math.max(2 * v, 1);\n                st.push(top);\n            }\n        }\n        return st.peek();\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int ScoreOfParentheses(string s) {\n        Stack<int> st = new Stack<int>();\n        st.Push(0);\n        foreach (char c in s) {\n            if (c == '(') {\n                st.Push(0);\n            } else {\n                int v = st.Pop();\n                int top = st.Pop() + Math.Max(2 * v, 1);\n                st.Push(top);\n            }\n        }\n        return st.Peek();\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint scoreOfParentheses(char * s) {\n    int len = strlen(s);\n    int stack[len + 1], top = 0;\n    stack[top++] = 0;\n    for (int i = 0; i < len; i++) {\n        if (s[i] == '(') {\n            stack[top++] = 0;\n        } else {\n            int v = stack[top - 1];\n            top--;\n            stack[top - 1] += MAX(2 * v, 1);\n        }\n    }\n    return stack[top - 1];\n}\n```\n\n```go [sol2-Golang]\nfunc scoreOfParentheses(s string) int {\n    st := []int{0}\n    for _, c := range s {\n        if c == '(' {\n            st = append(st, 0)\n        } else {\n            v := st[len(st)-1]\n            st = st[:len(st)-1]\n            st[len(st)-1] += max(2*v, 1)\n        }\n    }\n    return st[0]\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar scoreOfParentheses = function(s) {\n    const st = [0];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '(') {\n            st.push(0);\n        } else {\n            let v = st.pop();\n            let top = st.pop() + Math.max(2 * v, 1);\n            st.push(top);\n        }\n    }\n    return st[0];\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是字符串的长度。\n\n+ 空间复杂度：$O(n)$。栈需要 $O(n)$ 的空间。\n\n#### 方法三：计算最终分数和\n\n根据题意，$s$ 的分数与 $1$ 分的 $()$ 有关。对于每个 $()$，它的最终分数与它所处的深度有关，如果深度为 $\\textit{bal}$，那么它的最终分数为 $2^\\textit{bal}$。我们统计所有 $()$ 的最终分数和即可。\n\n```Python [sol3-Python3]\nclass Solution:\n    def scoreOfParentheses(self, s: str) -> int:\n        ans = bal = 0\n        for i, c in enumerate(s):\n            bal += 1 if c == '(' else -1\n            if c == ')' and s[i - 1] == '(':\n                ans += 1 << bal\n        return ans\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int scoreOfParentheses(string s) {\n        int bal = 0, n = s.size(), res = 0;\n        for (int i = 0; i < n; i++) {\n            bal += (s[i] == '(' ? 1 : -1);\n            if (s[i] == ')' && s[i - 1] == '(') {\n                res += 1 << bal;\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int scoreOfParentheses(String s) {\n        int bal = 0, n = s.length(), res = 0;\n        for (int i = 0; i < n; i++) {\n            bal += (s.charAt(i) == '(' ? 1 : -1);\n            if (s.charAt(i) == ')' && s.charAt(i - 1) == '(') {\n                res += 1 << bal;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int ScoreOfParentheses(string s) {\n        int bal = 0, n = s.Length, res = 0;\n        for (int i = 0; i < n; i++) {\n            bal += (s[i] == '(' ? 1 : -1);\n            if (s[i] == ')' && s[i - 1] == '(') {\n                res += 1 << bal;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol3-C]\nint scoreOfParentheses(char * s) {\n    int bal = 0, n = strlen(s), res = 0;\n    for (int i = 0; i < n; i++) {\n        bal += (s[i] == '(' ? 1 : -1);\n        if (s[i] == ')' && s[i - 1] == '(') {\n            res += 1 << bal;\n        }\n    }\n    return res;\n}\n```\n\n```go [sol3-Golang]\nfunc scoreOfParentheses(s string) (ans int) {\n    bal := 0\n    for i, c := range s {\n        if c == '(' {\n            bal++\n        } else {\n            bal--\n            if s[i-1] == '(' {\n                ans += 1 << bal\n            }\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar scoreOfParentheses = function(s) {\n    let bal = 0, n = s.length, res = 0;\n    for (let i = 0; i < n; i++) {\n        bal += (s[i] == '(' ? 1 : -1);\n        if (s[i] == ')' && s[i - 1] === '(') {\n            res += 1 << bal;\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是字符串的长度。\n\n+ 空间复杂度：$O(1)$。"
}