{
	"titleSlug": "find-the-town-judge",
	"slug": "zhao-dao-xiao-zhen-de-fa-guan-by-leetcod-0dcg",
	"url": "https://leetcode-cn.com/problems/find-the-town-judge/solution/zhao-dao-xiao-zhen-de-fa-guan-by-leetcod-0dcg/",
	"content": "#### 预备知识\n\n本题需要用到有向图中节点的入度和出度的概念。在有向图中，一个节点的入度是指向该节点的边的数量；而一个节点的出度是从该节点出发的边的数量。\n\n#### 方法一：计算各节点的入度和出度\n\n**思路及解法**\n\n题干描述了一个有向图。每个人是图的节点，$\\textit{trust}$ 的元素 $\\textit{trust}[i]$ 是图的有向边，从 $\\textit{trust}[i][0]$ 指向 $\\textit{trust}[i][1]$。我们可以遍历 $\\textit{trust}$，统计每个节点的入度和出度，存储在 $\\textit{inDegrees}$ 和 $\\textit{outDegrees}$ 中。\n\n根据题意，在法官存在的情况下，法官不相信任何人，每个人（除了法官外）都信任法官，且只有一名法官。因此法官这个节点的入度是 $n-1$, 出度是 $0$。\n\n我们可以遍历每个节点的入度和出度，如果找到一个符合条件的节点，由于题目保证只有一个法官，我们可以直接返回结果；如果不存在符合条件的点，则返回 $-1$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        inDegrees = Counter(y for _, y in trust)\n        outDegrees = Counter(x for x, _ in trust)\n        return next((i for i in range(1, n + 1) if inDegrees[i] == n - 1 and outDegrees[i] == 0), -1)\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] inDegrees = new int[n + 1];\n        int[] outDegrees = new int[n + 1];\n        for (int[] edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindJudge(int n, int[][] trust) {\n        int[] inDegrees = new int[n + 1];\n        int[] outDegrees = new int[n + 1];\n        foreach (int[] edge in trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegrees(n + 1);\n        vector<int> outDegrees(n + 1);\n        for (auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n```C [sol1-C]\nint findJudge(int n, int** trust, int trustSize, int* trustColSize){\n    int* inDegrees = (int *)malloc(sizeof(int)*(n+1));\n    int* outDegrees = (int *)malloc(sizeof(int)*(n+1));\n    memset(inDegrees, 0, sizeof(int)*(n+1));\n    memset(outDegrees, 0, sizeof(int)*(n+1));\n    for (int i = 0; i < trustSize; ++i) {\n        int x = trust[i][0], y = trust[i][1];\n        ++inDegrees[y];\n        ++outDegrees[x];\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findJudge = function(n, trust) {\n    const inDegrees = new Array(n + 1).fill(0);\n    const outDegrees = new Array(n + 1).fill(0);\n    for (const edge of trust) {\n        const x = edge[0], y = edge[1];\n        ++inDegrees[y];\n        ++outDegrees[x];\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (inDegrees[i] === n - 1 && outDegrees[i] === 0) {\n            return i;\n        }\n    }\n    return -1;\n};\n```\n\n```go [sol1-Golang]\nfunc findJudge(n int, trust [][]int) int {\n    inDegrees := make([]int, n+1)\n    outDegrees := make([]int, n+1)\n    for _, t := range trust {\n        inDegrees[t[1]]++\n        outDegrees[t[0]]++\n    }\n    for i := 1; i <= n; i++ {\n        if inDegrees[i] == n-1 && outDegrees[i] == 0 {\n            return i\n        }\n    }\n    return -1\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n+m)$，其中 $m$ 是 $\\textit{trust}$ 的长度。首先需要遍历 $\\textit{trust}$ 计算出 $\\textit{inDegrees}$ 和 $\\textit{outDegrees}$，然后需要遍历 $\\textit{inDegrees}$ 和 $\\textit{outDegrees}$ 来确定法官。\n\n- 空间复杂度：$O(n)$。记录各个节点的入度和出度需要 $O(n)$ 的空间。"
}