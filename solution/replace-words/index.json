{
	"titleSlug": "replace-words",
	"slug": "dan-ci-ti-huan-by-leetcode-solution-pl6v",
	"url": "https://leetcode-cn.com/problems/replace-words/solution/dan-ci-ti-huan-by-leetcode-solution-pl6v/",
	"content": "#### 方法一：哈希集合\n\n**思路**\n\n首先将 $\\textit{dictionary}$ 中所有词根放入哈希集合中，然后对于 $\\textit{sentence}$ 中的每个单词，由短至长遍历它所有的前缀，如果这个前缀出现在哈希集合中，则我们找到了当前单词的最短词根，将这个词根替换原来的单词。最后返回重新拼接的句子。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n        dictionarySet = set(dictionary)\n        words = sentence.split(' ')\n        for i, word in enumerate(words):\n            for j in range(1, len(words) + 1):\n                if word[:j] in dictionarySet:\n                    words[i] = word[:j]\n                    break\n        return ' '.join(words)\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String replaceWords(List<String> dictionary, String sentence) {\n        Set<String> dictionarySet = new HashSet<String>();\n        for (String root : dictionary) {\n            dictionarySet.add(root);\n        }\n        String[] words = sentence.split(\" \");\n        for (int i = 0; i < words.length; i++) {\n            String word = words[i];\n            for (int j = 0; j < word.length(); j++) {\n                if (dictionarySet.contains(word.substring(0, 1 + j))) {\n                    words[i] = word.substring(0, 1 + j);\n                    break;\n                }\n            }\n        }\n        return String.join(\" \", words);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string ReplaceWords(IList<string> dictionary, string sentence) {\n        ISet<string> dictionarySet = new HashSet<string>();\n        foreach (string root in dictionary) {\n            dictionarySet.Add(root);\n        }\n        string[] words = sentence.Split(\" \");\n        for (int i = 0; i < words.Length; i++) {\n            string word = words[i];\n            for (int j = 0; j < word.Length; j++) {\n                if (dictionarySet.Contains(word.Substring(0, 1 + j))) {\n                    words[i] = word.Substring(0, 1 + j);\n                    break;\n                }\n            }\n        }\n        return String.Join(\" \", words);\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string_view> split(string &str, char ch) {\n        int pos = 0;\n        int start = 0;\n        string_view s(str);\n        vector<string_view> ret;\n        while (pos < s.size()) {\n            while (pos < s.size() && s[pos] == ch) {\n                pos++;\n            }\n            start = pos;\n            while (pos < s.size() && s[pos] != ch) {\n                pos++;\n            }\n            if (start < s.size()) {\n                ret.emplace_back(s.substr(start, pos - start));\n            }\n        }\n        return ret;\n    }\n\n    string replaceWords(vector<string>& dictionary, string sentence) {\n        unordered_set<string_view> dictionarySet;\n        for (auto &root : dictionary) {\n            dictionarySet.emplace(root);\n        }\n        vector<string_view> words = split(sentence, ' ');\n        for (auto &word : words) {\n            for (int j = 0; j < word.size(); j++) {\n                if (dictionarySet.count(word.substr(0, 1 + j))) {\n                    word = word.substr(0, 1 + j);\n                    break;\n                }\n            }\n        }\n        string ans;\n        for (int i = 0; i < words.size() - 1; i++) {\n            ans.append(words[i]);\n            ans.append(\" \");\n        }\n        ans.append(words.back());\n        return ans;\n    }\n};\n```\n\n```C [sol1-C]\n#define MAX_STR_LEN 1024\n\ntypedef struct {\n    char *key;\n    UT_hash_handle hh;\n} HashItem;\n\nchar ** split(char *str, char ch, int *returnSize) {\n    int len = strlen(str);\n    char **res = (char **)malloc(sizeof(char *) * len);\n    int i = 0, pos = 0;\n    while (i < len) {\n        while (i < len && str[i] == ch) {\n            i++;\n        }\n        int start = i;\n        while (i < len && str[i] != ch) {\n            i++;\n        }\n        if (start < len) {\n            res[pos] = (char *)malloc(sizeof(char) * (i - start + 1));\n            memcpy(res[pos], str + start, sizeof(char) * (i - start));\n            res[pos][i - start] = '\\0';\n            pos++;\n        }\n    }\n    *returnSize = pos;\n    return res;\n}\n\nchar * replaceWords(char ** dictionary, int dictionarySize, char * sentence){\n    HashItem *dictionarySet = NULL;\n    for (int i = 0; i < dictionarySize; i++) {\n        HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n        pEntry->key = dictionary[i];\n        HASH_ADD_STR(dictionarySet, key, pEntry);\n    }\n    int n = strlen(sentence);\n    int wordsSize = 0;\n    char **words = split(sentence, ' ', &wordsSize);\n    char str[MAX_STR_LEN];\n    for (int i = 0; i < wordsSize; i++) {\n        int len = strlen(words[i]);\n        for (int j = 0; j < len; j++) {\n            snprintf(str, j + 2, \"%s\", words[i]);\n            HashItem *pEntry = NULL;\n            HASH_FIND_STR(dictionarySet, str, pEntry);\n            if (pEntry) {\n                words[i][j + 1] = '\\0';\n                break;\n            }\n        }\n    }\n    char *res = (char *)malloc(sizeof(char) * (n + 1));\n    int pos = 0;\n    for (int i = 0; i < wordsSize - 1; i++) {\n        pos += sprintf(res + pos, \"%s \", words[i]);\n    }\n    pos += sprintf(res + pos, \"%s\", words[wordsSize - 1]);\n    for (int i = 0; i < wordsSize; i++) {\n        free(words[i]);\n    }\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, dictionarySet, curr, tmp) {\n        HASH_DEL(dictionarySet, curr);  \n        free(curr);         \n    }\n    return res;\n}\n```\n\n```go [sol1-Golang]\nfunc replaceWords(dictionary []string, sentence string) string {\n    dictionarySet := map[string]bool{}\n    for _, s := range dictionary {\n        dictionarySet[s] = true\n    }\n    words := strings.Split(sentence, \" \")\n    for i, word := range words {\n        for j := 1; j <= len(word); j++ {\n            if dictionarySet[word[:j]] {\n                words[i] = word[:j]\n                break\n            }\n        }\n    }\n    return strings.Join(words, \" \")\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar replaceWords = function(dictionary, sentence) {\n    const dictionarySet = new Set();\n    for (const root of dictionary) {\n        dictionarySet.add(root);\n    }\n    const words = sentence.split(\" \");\n    for (let i = 0; i < words.length; i++) {\n        const word = words[i];\n        for (let j = 0; j < word.length; j++) {\n            if (dictionarySet.has(word.substring(0, 1 + j))) {\n                words[i] = word.substring(0, 1 + j);\n                break;\n            }\n        }\n    }\n    return words.join(' ');\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(d + \\sum w_i^2)$。其中 $d$ 是 $\\textit{dictionary}$ 的字符数，构建哈希集合消耗 $O(d)$ 时间。$w_i$ 是 $\\textit{sentence}$ 分割后第 $i$ 个单词的字符数，判断单词的前缀子字符串是否位于哈希集合中消耗 $O(w_i^2)$ 时间。\n\n- 空间复杂度：$O(d + s)$，其中 $s$ 是 $\\textit{sentence}$ 的字符数。构建哈希集合消耗 $O(d)$ 空间，分割 $\\textit{sentence}$ 消耗 $O(s)$ 空间。\n\n#### 方法二：字典树\n\n**思路**\n\n与哈希集合不同，我们用 $\\textit{dictionary}$ 中所有词根构建一棵字典树，并用特殊符号标记结尾。在搜索前缀时，只需在字典树上搜索出一条最短的前缀路径即可。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n        trie = {}\n        for word in dictionary:\n            cur = trie\n            for c in word:\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n            cur['#'] = {}\n\n        words = sentence.split(' ')\n        for i, word in enumerate(words):\n            cur = trie\n            for j, c in enumerate(word):\n                if '#' in cur:\n                    words[i] = word[:j]\n                    break\n                if c not in cur:\n                    break\n                cur = cur[c]\n        return ' '.join(words)\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public String replaceWords(List<String> dictionary, String sentence) {\n        Trie trie = new Trie();\n        for (String word : dictionary) {\n            Trie cur = trie;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charAt(i);\n                cur.children.putIfAbsent(c, new Trie());\n                cur = cur.children.get(c);\n            }\n            cur.children.put('#', new Trie());\n        }\n        String[] words = sentence.split(\" \");\n        for (int i = 0; i < words.length; i++) {\n            words[i] = findRoot(words[i], trie);\n        }\n        return String.join(\" \", words);\n    }\n\n    public String findRoot(String word, Trie trie) {\n        StringBuffer root = new StringBuffer();\n        Trie cur = trie;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            if (cur.children.containsKey('#')) {\n                return root.toString();\n            }\n            if (!cur.children.containsKey(c)) {\n                return word;\n            }\n            root.append(c);\n            cur = cur.children.get(c);\n        }\n        return root.toString();\n    }\n}\n\nclass Trie {\n    Map<Character, Trie> children;\n\n    public Trie() {\n        children = new HashMap<Character, Trie>();\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public string ReplaceWords(IList<string> dictionary, string sentence) {\n        Trie trie = new Trie();\n        foreach (string word in dictionary) {\n            Trie cur = trie;\n            for (int i = 0; i < word.Length; i++) {\n                char c = word[i];\n                if (!cur.Children.ContainsKey(c)) {\n                    cur.Children.Add(c, new Trie());\n                }\n                cur = cur.Children[c];\n            }\n            cur.Children.Add('#', new Trie());\n        }\n        string[] words = sentence.Split(\" \");\n        for (int i = 0; i < words.Length; i++) {\n            words[i] = FindRoot(words[i], trie);\n        }\n        return string.Join(\" \", words);\n    }\n\n    public string FindRoot(string word, Trie trie) {\n        StringBuilder root = new StringBuilder();\n        Trie cur = trie;\n        for (int i = 0; i < word.Length; i++) {\n            char c = word[i];\n            if (cur.Children.ContainsKey('#')) {\n                return root.ToString();\n            }\n            if (!cur.Children.ContainsKey(c)) {\n                return word;\n            }\n            root.Append(c);\n            cur = cur.Children[c];\n        }\n        return root.ToString();\n    }\n}\n\npublic class Trie {\n    public Dictionary<char, Trie> Children;\n\n    public Trie() {\n        Children = new Dictionary<char, Trie>();\n    }\n}\n```\n\n```C++ [sol2-C++]\nstruct Trie {\n    unordered_map<char, Trie *> children;\n};\n\nclass Solution {\npublic:\n    string replaceWords(vector<string>& dictionary, string sentence) {\n        Trie *trie = new Trie();\n        for (auto &word : dictionary) {\n            Trie *cur = trie;\n            for (char &c: word) {\n                if (!cur->children.count(c)) {\n                    cur->children[c] = new Trie();\n                }\n                cur = cur->children[c];\n            }\n            cur->children['#'] = new Trie();\n        }\n        vector<string> words = split(sentence, ' ');\n        for (auto &word : words) {\n            word = findRoot(word, trie);\n        }\n        string ans;\n        for (int i = 0; i < words.size() - 1; i++) {\n            ans.append(words[i]);\n            ans.append(\" \");\n        }\n        ans.append(words.back());\n        return ans;\n    }\n\n    vector<string> split(string &str, char ch) {\n        int pos = 0;\n        int start = 0;\n        vector<string> ret;\n        while (pos < str.size()) {\n            while (pos < str.size() && str[pos] == ch) {\n                pos++;\n            }\n            start = pos;\n            while (pos < str.size() && str[pos] != ch) {\n                pos++;\n            }\n            if (start < str.size()) {\n                ret.emplace_back(str.substr(start, pos - start));\n            }\n        }\n        return ret;\n    }\n\n    string findRoot(string &word, Trie *trie) {\n        string root;\n        Trie *cur = trie;\n        for (char &c : word) {\n            if (cur->children.count('#')) {\n                return root;\n            }\n            if (!cur->children.count(c)) {\n                return word;\n            }\n            root.push_back(c);\n            cur = cur->children[c];\n        }\n        return root;\n    }\n};\n```\n\n```C [sol2-C]\n#define MAX_STR_LEN 1024\n\ntypedef struct Trie {\n    bool isEnd;\n    struct Trie *children[26];\n} Trie;\n\nTrie * creatTrie() {\n    Trie *node = (Trie *)malloc(sizeof(Trie));\n    for (int i = 0; i < 26; i++) {\n        node->children[i] = NULL;\n    }\n    node->isEnd = false;\n    return node;\n}\n\nvoid freeTrie(Trie *root) {\n    for (int i = 0; i < 26; i++) {\n        if (root->children[i]) {\n            freeTrie(root->children[i]);\n        }\n    }\n    free(root);\n}\n\nchar *findRoot(const char *word, Trie *trie) {\n    char *root = (char *)malloc(sizeof(char) * MAX_STR_LEN);\n    Trie *cur = trie;\n    int len = strlen(word);\n    int pos = 0;\n    for (int i = 0; i < len; i++) {\n        char c = word[i];\n        if (cur->isEnd) {\n            root[pos] = 0;\n            return root;\n        }\n        if (!cur->children[c - 'a']) {\n            free(root);\n            return word;\n        }\n        root[pos++] = c;\n        cur = cur->children[c - 'a'];\n    }\n    root[pos] = 0;\n    return root;\n}\n\nchar ** split(char *str, char ch, int *returnSize) {\n    int len = strlen(str);\n    char **res = (char **)malloc(sizeof(char *) * len);\n    int i = 0, pos = 0;\n    while (i < len) {\n        while (i < len && str[i] == ch) {\n            i++;\n        }\n        int start = i;\n        while (i < len && str[i] != ch) {\n            i++;\n        }\n        if (start < len) {\n            res[pos] = (char *)malloc(sizeof(char) * (i - start + 1));\n            memcpy(res[pos], str + start, sizeof(char) * (i - start));\n            res[pos][i - start] = '\\0';\n            pos++;\n        }\n    }\n    *returnSize = pos;\n    return res;\n}\n\nchar * replaceWords(char ** dictionary, int dictionarySize, char * sentence){\n    Trie *trie = creatTrie();\n    for (int i = 0; i < dictionarySize; i++) {\n        Trie *cur = trie;\n        int len = strlen(dictionary[i]);\n        for (int j = 0; j < len; j++) {\n            char c = dictionary[i][j];\n            if (!cur->children[c - 'a']) {\n                cur->children[c - 'a'] = creatTrie();\n            }\n            cur = cur->children[c - 'a'];\n        }\n        cur->isEnd = true;\n    }\n    int wordsSize = 0, pos = 0;\n    char **words = split(sentence, ' ', &wordsSize);\n    char *ans = (char *)malloc(sizeof(char) * (strlen(sentence) + 2));\n    for (int i = 0; i < wordsSize; i++) {\n        char * ret = findRoot(words[i], trie);\n        pos += sprintf(ans + pos, \"%s \", ret);\n        free(words[i]);\n        if (ret != words[i]) {\n            free(ret);\n        }\n    }\n    ans[pos - 1] = '\\0';\n    freeTrie(trie);\n    return ans;\n}\n```\n\n```go [sol2-Golang]\nfunc replaceWords(dictionary []string, sentence string) string {\n    type trie map[rune]trie\n    root := trie{}\n    for _, s := range dictionary {\n        cur := root\n        for _, c := range s {\n            if cur[c] == nil {\n                cur[c] = trie{}\n            }\n            cur = cur[c]\n        }\n        cur['#'] = trie{}\n    }\n\n    words := strings.Split(sentence, \" \")\n    for i, word := range words {\n        cur := root\n        for j, c := range word {\n            if cur['#'] != nil {\n                words[i] = word[:j]\n                break\n            }\n            if cur[c] == nil {\n                break\n            }\n            cur = cur[c]\n        }\n    }\n    return strings.Join(words, \" \")\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar replaceWords = function(dictionary, sentence) {\n    const trie = new Trie();\n    for (const word of dictionary) {\n        let cur = trie;\n        for (let i = 0; i < word.length; i++) {\n            const c = word[i];\n            if (!cur.children.has(c)) {\n                cur.children.set(c, new Trie());\n            }\n            cur = cur.children.get(c);\n        }\n        cur.children.set('#', new Trie());\n    }\n    const words = sentence.split(\" \");\n    for (let i = 0; i < words.length; i++) {\n        words[i] = findRoot(words[i], trie);\n    }\n    return words.join(\" \");\n};\n\nconst findRoot = (word, trie) => {\n    let root = '';\n    let cur = trie;\n    for (let i = 0; i < word.length; i++) {\n        const c = word[i];\n        if (cur.children.has('#')) {\n            return root;\n        }\n        if (!cur.children.has(c)) {\n            return word;\n        }\n        root += c;\n        cur = cur.children.get(c);\n    }\n    return root;\n}\n\nclass Trie {\n    constructor() {\n        this.children = new Map();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(d + s)$。其中 $d$ 是 $\\textit{dictionary}$ 的字符数，$s$ 是 $\\textit{sentence}$ 的字符数。构建字典树消耗 $O(d)$ 时间，每个单词搜索前缀均消耗线性时间。\n\n- 空间复杂度：$O(d + s)$，构建哈希集合消耗 $O(d)$ 空间，分割 $\\textit{sentence}$ 消耗 $O(s)$ 空间。"
}