{
	"titleSlug": "n-ary-tree-postorder-traversal",
	"slug": "n-cha-shu-de-hou-xu-bian-li-by-leetcode-txesi",
	"url": "https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/solution/n-cha-shu-de-hou-xu-bian-li-by-leetcode-txesi/",
	"content": "#### 方法一：递归\n\n**思路**\n\n递归思路比较简单，$N$ 叉树的前序遍历与二叉树的后序遍历的思路和方法基本一致，可以参考「[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)」的方法，每次递归时，先递归访问每个孩子节点，然后再访问根节点即可。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> postorder(Node root) {\n        List<Integer> res = new ArrayList<>();\n        helper(root, res);\n        return res;\n    }\n\n    public void helper(Node root, List<Integer> res) {\n        if (root == null) {\n            return;\n        }\n        for (Node ch : root.children) {\n            helper(ch, res);\n        }\n        res.add(root.val);\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    void helper(const Node* root, vector<int> & res) {\n        if (root == nullptr) {\n            return;\n        }\n        for (auto & ch : root->children) {\n            helper(ch, res);\n        }\n        res.emplace_back(root->val);\n    }\n\n    vector<int> postorder(Node* root) {\n        vector<int> res;\n        helper(root, res);\n        return res;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> Postorder(Node root) {\n        IList<int> res = new List<int>();\n        Helper(root, res);\n        return res;\n    }\n\n    public void Helper(Node root, IList<int> res) {\n        if (root == null) {\n            return;\n        }\n        foreach (Node ch in root.children) {\n            Helper(ch, res);\n        }\n        res.Add(root.val);\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX_NODE_SIZE 10000\n\nvoid helper(const struct Node* root, int* res, int* pos) {\n    if (NULL == root) {\n        return;\n    }\n    for (int i = 0; i < root->numChildren; i++) {\n        helper(root->children[i], res, pos);\n    }\n    res[(*pos)++] = root->val;\n}\n\nint* postorder(struct Node* root, int* returnSize) {\n    int * res = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    int pos = 0;\n    helper(root, res, &pos);\n    *returnSize = pos;\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar postorder = function(root) {\n    const res = [];\n        helper(root, res);\n        return res;\n    }\n\nconst helper = (root, res) => {\n    if (root == null) {\n        return;\n    }\n    for (const ch of root.children) {\n        helper(ch, res);\n    }\n    res.push(root.val);\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def postorder(self, root: 'Node') -> List[int]:\n        ans = []\n        def dfs(node: 'Node'):\n            if node is None:\n                return\n            for ch in node.children:\n                dfs(ch)\n            ans.append(node.val)\n        dfs(root)\n        return ans\n```\n\n```go [sol1-Golang]\nfunc postorder(root *Node) (ans []int) {\n    var dfs func(*Node)\n    dfs = func(node *Node) {\n        if node == nil {\n            return\n        }\n        for _, ch := range node.Children {\n            dfs(ch)\n        }\n        ans = append(ans, node.Val)\n    }\n    dfs(root)\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。每个节点恰好被遍历一次。\n\n- 空间复杂度：$O(m)$，递归过程中需要调用栈的开销，平均情况下为 $O(\\log m)$，最坏情况下树的深度为 $m-1$，需要的空间为 $O(m-1)$，因此空间复杂度为 $O(m)$。\n\n#### 方法二：迭代\n\n**思路**\n\n方法一中利用递归来遍历树，实际的递归中隐式利用了栈，在此我们可以直接模拟递归中栈的调用。在后序遍历中从左向右依次先序遍历该每个以子节点为根的子树，然后先遍历节点本身。\n\n在这里的栈模拟中比较难处理的在于从当前节点 $u$ 的子节点 $v_1$ 返回时，此时需要处理节点 $u$ 的下一个节点 $v_2$，此时需要记录当前已经遍历完成哪些子节点，才能找到下一个需要遍历的节点。在二叉树树中因为只有左右两个子节点，因此比较方便处理，在 $N$ 叉树中由于有多个子节点，因此使用哈希表记录当前节点 $u$ 已经访问过哪些子节点。\n\n+ 每次入栈时都将当前节点的 $u$ 的第一个子节点压入栈中，直到当前节点为空节点为止。\n\n+ 每次查看栈顶元素 $p$，如果节点 $p$ 的子节点已经全部访问过，则记录当前节点的值，并将节点 $p$ 的从栈中弹出，并从哈希表中移除，表示该以该节点的子树已经全部遍历过；如果当前节点 $p$ 的子节点还有未遍历的，则将当前节点的 $p$ 的下一个未访问的节点压入到栈中，重复上述的入栈操作。\n\n**代码**\n\n```Java [sol2-Java]\nclass Solution {\n    public List<Integer> postorder(Node root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (root == null) {\n            return res;\n        }\n        Map<Node, Integer> map = new HashMap<Node, Integer>();\n        Deque<Node> stack = new ArrayDeque<Node>();\n        Node node = root;\n        while (!stack.isEmpty() || node != null) {\n            while (node != null) {\n                stack.push(node);\n                List<Node> children = node.children;\n                if (children != null && children.size() > 0) {\n                    map.put(node, 0);\n                    node = children.get(0);\n                } else {\n                    node = null;\n                }\n            }\n            node = stack.peek();\n            int index = map.getOrDefault(node, -1) + 1;\n            List<Node> children = node.children;\n            if (children != null && children.size() > index) {\n                map.put(node, index);\n                node = children.get(index);\n            } else {\n                res.add(node.val);\n                stack.pop();\n                map.remove(node);\n                node = null;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> postorder(Node* root) {\n        vector<int> res;\n        if (root == nullptr) {\n            return res;\n        }\n        \n        unordered_map<Node *, int> cnt;\n        stack<Node *> st;\n        Node * node = root;\n        while (!st.empty() || node != nullptr) {\n            while (node != nullptr) {\n                st.emplace(node);\n                if (node->children.size() > 0) {\n                    cnt[node] = 0;\n                    node = node->children[0];\n                } else {\n                    node = nullptr;\n                }         \n            }\n            node = st.top();\n            int index = cnt.count(node) ? (cnt[node] + 1) : 0;\n            if (index < node->children.size()) {\n                cnt[node] = index;\n                node = node->children[index];\n            } else {\n                res.emplace_back(node->val);\n                st.pop();\n                cnt.erase(node);\n                node = nullptr;\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public IList<int> Postorder(Node root) {\n        IList<int> res = new List<int>();\n        if (root == null) {\n            return res;\n        }\n        Dictionary<Node, int> dictionary = new Dictionary<Node, int>();\n        Stack<Node> stack = new Stack<Node>();\n        Node node = root;\n        while (stack.Count > 0 || node != null) {\n            while (node != null) {\n                stack.Push(node);\n                IList<Node> childrenList = node.children;\n                if (childrenList != null && childrenList.Count > 0) {\n                    dictionary.Add(node, 0);\n                    node = childrenList[0];\n                } else {\n                    node = null;\n                }\n            }\n            node = stack.Peek();\n            int index = (dictionary.ContainsKey(node) ? dictionary[node] : -1) + 1;\n            IList<Node> children = node.children;\n            if (children != null && children.Count > index) {\n                dictionary[node] = index;\n                node = children[index];\n            } else {\n                res.Add(node.val);\n                stack.Pop();\n                dictionary.Remove(node);\n                node = null;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX_NODE_SIZE 10000\n\ntypedef struct {\n    void * key;\n    int val;\n    UT_hash_handle hh; \n} HashItem;\n\nvoid freeHash(HashItem ** obj) {\n    HashItem * curr = NULL, * next = NULL;\n    HASH_ITER(hh, *obj, curr, next) {\n        HASH_DEL(*obj, curr);\n        free(curr);\n    }\n}\n\nint* postorder(struct Node* root, int* returnSize) {\n    if (NULL == root) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int * res = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    struct Node ** stack = (struct Node **)malloc(sizeof(struct Node *) * MAX_NODE_SIZE);\n    int pos = 0, top = 0;  \n\n    struct Node * node = root;\n    HashItem * cnt = NULL;\n    HashItem * pEntry = NULL;\n    while (top != 0 || node != NULL) {\n        while (node != NULL) {\n            stack[top++] = node;\n            if (node->numChildren > 0) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                pEntry->key = node;\n                pEntry->val = 0;\n                HASH_ADD_PTR(cnt, key, pEntry);\n                node = node->children[0];\n            } else {\n                node = NULL;\n            }\n        }\n        node = stack[top - 1];\n        int index = 0;\n        HASH_FIND_PTR(cnt, &node, pEntry);\n        if (pEntry != NULL) {\n            index = pEntry->val + 1;\n        }\n        if (index < node->numChildren) {\n            pEntry->val++;\n            node = node->children[index];\n        } else {\n            top--;\n            res[pos++] = node->val;\n            if (pEntry != NULL) {\n                HASH_DEL(cnt, pEntry);\n            }\n            node = NULL;\n        }\n    }\n    free(stack);\n    freeHash(&cnt);\n    *returnSize = pos;\n    return res;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar postorder = function(root) {\n    const res = [];\n    if (root == null) {\n        return res;\n    }\n    const map = new Map();\n    const stack = [];\n    let node = root;\n    while (stack.length || node) {\n        while (node) {\n            stack.push(node);\n            const children = node.children;\n            if (children && children.length > 0) {\n                map.set(node, 0);\n                node = children[0];\n            } else {\n                node = null;\n            }\n        }\n        node = stack[stack.length - 1];\n        const index = (map.get(node) || 0) + 1;\n        const children = node.children;\n        if (children && children.length > index) {\n            map.set(node, index);\n            node = children[index];\n        } else {\n            res.push(node.val);\n            stack.pop();\n            map.delete(node);\n            node = null;\n        }\n    }\n    return res;\n};\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def postorder(self, root: 'Node') -> List[int]:\n        if root is None:\n            return []\n        ans = []\n        st = []\n        nextIndex = defaultdict(int)\n        node = root\n        while st or node:\n            while node:\n                st.append(node)\n                if not node.children:\n                    break\n                nextIndex[node] = 1\n                node = node.children[0]\n            node = st[-1]\n            i = nextIndex[node]\n            if i < len(node.children):\n                nextIndex[node] = i + 1\n                node = node.children[i]\n            else:\n                ans.append(node.val)\n                st.pop()\n                del nextIndex[node]\n                node = None\n        return ans\n```\n\n```go [sol2-Golang]\nfunc postorder(root *Node) (ans []int) {\n    if root == nil {\n        return\n    }\n    st := []*Node{}\n    nextIndex := map[*Node]int{}\n    node := root\n    for len(st) > 0 || node != nil {\n        for node != nil {\n            st = append(st, node)\n            if len(node.Children) == 0 {\n                break\n            }\n            nextIndex[node] = 1\n            node = node.Children[0]\n        }\n        node = st[len(st)-1]\n        i := nextIndex[node]\n        if i < len(node.Children) {\n            nextIndex[node] = i + 1\n            node = node.Children[i]\n        } else {\n            ans = append(ans, node.Val)\n            st = st[:len(st)-1]\n            delete(nextIndex, node)\n            node = nil\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。每个节点恰好被访问一次。\n\n- 空间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。如果 $N$ 叉树的深度为 $1$ 则此时栈和哈希表的空间为 $O(1)$，如果 $N$ 叉树的深度为 $m-1$ 则此时栈和哈希表的空间为 $O(m-1)$，平均情况下栈和哈希表的空间为 $O(\\log m)$，因此空间复杂度为 $O(m)$。\n\n#### 方法三：迭代优化\n\n**思路**\n\n在后序遍历中，我们会先从左向右依次后序遍历每个子节点为根的子树，再遍历根节点本身。此时利用栈先进后出的原理，依次从右向左将子节点入栈，这样出栈的时候即可保证从左向右依次遍历每个子树。参考方法二的原理，可以提前将后续需要访问的节点压入栈中。\n\n首先把根节点入栈，因为根节点是前序遍历中的第一个节点。随后每次我们找到栈顶节点 $u$，如果当前节点的子节点没有遍历过，则应该先把 $u$ 的所有子节点从右向左逆序压入栈中，这样出栈的节点则是顺序从左向右的，同时对节点 $u$ 进行标记，表示该节点的子节点已经全部入栈；如果当前节点 $u$ 为叶子节点或者当前节点的子节点已经全部遍历过，则从栈中弹出节点 $u$，并记录节点 $u$ 的值。例如 $u$ 的子节点从左到右为 $v_1, v_2, v_3$，那么入栈的顺序应当为 $v_3, v_2, v_1$，这样就保证了下一个遍历到的节点（即 $u$ 的左侧第一个孩子节点 $v_1$）出现在栈顶的位置。此时，访问第一个子节点 $v_1$ 时，仍然按照此方法则会先访问 $v_1$ 的左侧第一个孩子节点。\n\n**代码**\n\n```Java [sol3-Java]\nclass Solution {\n    public List<Integer> postorder(Node root) {\n        List<Integer> res = new ArrayList<>();\n        if (root == null) {\n            return res;\n        }\n\n        Deque<Node> stack = new ArrayDeque<Node>();\n        Set<Node> visited = new HashSet<Node>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.peek();\n            /* 如果当前节点为叶子节点或者当前节点的子节点已经遍历过 */\n            if (node.children.size() == 0 || visited.contains(node)) {\n                stack.pop();\n                res.add(node.val);\n                continue;\n            }\n            for (int i = node.children.size() - 1; i >= 0; --i) {\n                stack.push(node.children.get(i));\n            }\n            visited.add(node);\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    vector<int> postorder(Node* root) {\n        vector<int> res;\n        if (root == nullptr) {\n            return res;\n        }\n\n        stack<Node *> st;\n        unordered_set<Node *> visited;\n        st.emplace(root);\n        while (!st.empty()) {\n            Node * node = st.top();\n            /* 如果当前节点为叶子节点或者当前节点的子节点已经遍历过 */\n            if (node->children.size() == 0 || visited.count(node)) {\n                res.emplace_back(node->val);\n                st.pop();\n                continue;\n            }\n            for (auto it = node->children.rbegin(); it != node->children.rend(); it++) {\n                st.emplace(*it);\n            }\n            visited.emplace(node);\n        }       \n        return res;\n    }\n};\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public IList<int> Postorder(Node root) {\n        IList<int> res = new List<int>();\n        if (root == null) {\n            return res;\n        }\n\n        Stack<Node> stack = new Stack<Node>();\n        ISet<Node> visited = new HashSet<Node>();\n        stack.Push(root);\n        while (stack.Count > 0) {\n            Node node = stack.Peek();\n            /* 如果当前节点为叶子节点或者当前节点的子节点已经遍历过 */\n            if (node.children.Count == 0 || visited.Contains(node)) {\n                stack.Pop();\n                res.Add(node.val);\n                continue;\n            }\n            for (int i = node.children.Count - 1; i >= 0; i--) {\n                stack.Push(node.children[i]);\n            }\n            visited.Add(node);\n        }\n        return res;\n    }\n}\n```\n\n```C [sol3-C]\n#define MAX_NODE_SIZE 10000\n\ntypedef struct {\n    void * key;\n    UT_hash_handle hh; \n} HashItem;\n\nvoid freeHash(HashItem ** obj) {\n    HashItem * curr = NULL, * next = NULL;\n    HASH_ITER(hh, *obj, curr, next) {\n        HASH_DEL(*obj, curr);\n        free(curr);\n    }\n}\n\nint* postorder(struct Node* root, int* returnSize) {\n    if (NULL == root) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int * res = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    struct Node ** stack = (struct Node **)malloc(sizeof(struct Node *) * MAX_NODE_SIZE);\n    int pos = 0, top = 0;  \n\n    stack[top++] = root;\n    HashItem * visited = NULL;\n    HashItem * pEntry = NULL;\n    while (top != 0) {\n        struct Node * node = stack[top - 1];\n        pEntry = NULL;\n        HASH_FIND_PTR(visited, &node, pEntry);\n        /* 如果当前节点为叶子节点或者当前节点的子节点已经遍历过 */\n        if (node->numChildren == 0 || NULL != pEntry) {\n            res[pos++] = node->val;\n            top--;\n            continue;\n        }\n        for (int i = node->numChildren - 1; i >= 0; i--) {\n            stack[top++] = node->children[i];\n        }\n        pEntry = (HashItem *)malloc(sizeof(HashItem));\n        pEntry->key = node;\n        HASH_ADD_PTR(visited, key, pEntry);\n    }\n    free(stack);\n    *returnSize = pos;\n    return res;\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar postorder = function(root) {\n    const res = [];\n    if (root == null) {\n        return res;\n    }\n\n    const stack = [];\n    const visited = new Set();\n    stack.push(root);\n    while (stack.length) {\n        const node = stack[stack.length - 1];\n        /* 如果当前节点为叶子节点或者当前节点的子节点已经遍历过 */\n        if (node.children.length === 0 || visited.has(node)) {\n            stack.pop();\n            res.push(node.val);\n            continue;\n        }\n        for (let i = node.children.length - 1; i >= 0; --i) {\n            stack.push(node.children[i]);\n        }\n        visited.add(node);\n    }\n    return res;\n};\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def postorder(self, root: 'Node') -> List[int]:\n        if root is None:\n            return []\n        ans = []\n        st = [root]\n        vis = set()\n        while st:\n            node = st[-1]\n            # 如果当前节点为叶子节点或者当前节点的子节点已经遍历过\n            if len(node.children) == 0 or node in vis:\n                ans.append(node.val)\n                st.pop()\n                continue\n            st.extend(reversed(node.children))\n            vis.add(node)\n        return ans\n```\n\n```go [sol3-Golang]\nfunc postorder(root *Node) (ans []int) {\n    if root == nil {\n        return\n    }\n    st := []*Node{root}\n    vis := map[*Node]bool{}\n    for len(st) > 0 {\n        node := st[len(st)-1]\n        // 如果当前节点为叶子节点或者当前节点的子节点已经遍历过\n        if len(node.Children) == 0 || vis[node] {\n            ans = append(ans, node.Val)\n            st = st[:len(st)-1]\n            continue\n        }\n        for i := len(node.Children) - 1; i >= 0; i-- {\n            st = append(st, node.Children[i])\n        }\n        vis[node] = true\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。每个节点恰好被访问一次。\n\n- 空间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。哈希表的空间为 $O(m)$，栈的空间与树的深度相同，栈的空间最大为 $O(m-1)$，因此空间复杂度为 $O(m)$。\n\n#### 方法四：利用前序遍历反转\n\n**思路**\n\n在前序遍历中，我们会先遍历节点本身，然后从左向右依次先序遍历该每个以子节点为根的子树，而在后序遍历中，需要先从左到右依次遍历每个以子节点为根的子树，然后再访问根节点。\n\n例如：当前的节点为 $u$，它的从左至右子节点依次为 $v_1, v_2, v_3$ 时，此时我们可以知道它的前序遍历结果为：\n$$\n[u, v_1, \\textit{children}(v_1), v_2, \\textit{children}(v_2), v_3, \\textit{children}(v_3)]\n$$\n后序遍历结果为:\n$$\n[\\textit{children}(v_1), v_1, \\textit{children}(v_2), v_2, \\textit{children}(v_3), v_3, u]\n$$\n\n其中 $\\textit{children}(v_k)$ 表示以 $v_k$ 为根节点的子树的遍历结果（不包括 $v_k$）。仔细观察可以知道，将前序遍历中子树的访问顺序改为从右向左可以得到如下访问顺序：\n$$\n[u, v_3, \\textit{children}(v_3), v_2, \\textit{children}(v_2), v_1, \\textit{children}(v_1)]\n$$\n将上述的结果进行反转，得到:\n$$\n[\\textit{children}(v_1), v_1, \\textit{children}(v_2), v_2, \\textit{children}(v_3), v_3, u]\n$$\n刚好与后续遍历的结果相同。此时我们可以利用前序遍历，只不过前序遍历中对子节点的遍历顺序是从左向右，而这里是从右向左。因此我们可以使用和 $N$ 叉树的前序遍历相同的方法，使用一个栈来得到后序遍历。\n\n我们首先把根节点入栈。当每次我们从栈顶取出一个节点 $u$ 时，就把 $u$ 的所有子节点顺序推入栈中。例如 $u$ 的子节点从左到右为 $v_1, v_2, v_3$，那么推入栈的顺序应当为 $v_1, v_2, v_3$，这样就保证了出栈顺序是从右向左，下一个遍历到的节点（即 $u$ 的右侧第一个子节点 $v_3$）出现在栈顶的位置。在遍历结束之后，我们把遍历结果进行反转，就可以得到后序遍历。\n\n**代码**\n\n```Java [sol4-Java]\nclass Solution {\n    public List<Integer> postorder(Node root) {\n        List<Integer> res = new ArrayList<>();\n        if (root == null) {\n            return res;\n        }\n\n        Deque<Node> stack = new ArrayDeque<Node>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            res.add(node.val);\n            for (Node item : node.children) {\n                stack.push(item);\n            }\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n```C++ [sol4-C++]\nclass Solution {\npublic:\n    vector<int> postorder(Node* root) {\n        vector<int> res;\n        if (root == nullptr) {\n            return res;\n        }\n\n        stack<Node *> st;\n        st.emplace(root);\n        while (!st.empty()) {\n            Node * node = st.top();\n            st.pop();\n            res.emplace_back(node->val);\n            for (auto &item : node->children) {\n                st.emplace(item);\n            }\n        }       \n        reverse(res.begin(), res.end()); \n        return res;\n    }\n};\n```\n\n```C# [sol4-C#]\npublic class Solution {\n    public IList<int> Postorder(Node root) {\n        IList<int> res = new List<int>();\n        if (root == null) {\n            return res;\n        }\n\n        Stack<Node> stack = new Stack<Node>();\n        stack.Push(root);\n        while (stack.Count > 0) {\n            Node node = stack.Pop();\n            res.Add(node.val);\n            foreach (Node item in node.children) {\n                stack.Push(item);\n            }\n        }\n        ((List<int>) res).Reverse();\n        return res;\n    }\n}\n```\n\n```C [sol4-C]\n#define MAX_NODE_SIZE 10000\n\nint* postorder(struct Node* root, int* returnSize) {\n    if (NULL == root) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int * res = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    struct Node ** stack = (struct Node **)malloc(sizeof(struct Node *) * MAX_NODE_SIZE);\n    int pos = 0, top = 0;  \n\n    stack[top++] = root;\n    while (top != 0) {\n        struct Node * node = stack[--top];\n        res[pos++] = node->val;\n        for (int i = 0; i < node->numChildren; i++) {\n            stack[top++] = node->children[i];\n        }\n    }\n    free(stack);\n    for (int l = 0, r = pos - 1; l < r; l++, r--) {\n        int tmp = res[l];\n        res[l] = res[r];\n        res[r] = tmp;\n    }\n    *returnSize = pos;\n    return res;\n}\n```\n\n```JavaScript [sol4-JavaScript]\nvar postorder = function(root) {\n    const res = [];\n    if (root == null) {\n        return res;\n    }\n\n    const stack = [];\n    stack.push(root);\n    while (stack.length) {\n        const node = stack.pop();\n        res.push(node.val);\n        for (const item of node.children) {\n            stack.push(item);\n        }\n    }\n    res.reverse();\n    return res;\n};\n```\n\n```Python [sol4-Python3]\nclass Solution:\n    def postorder(self, root: 'Node') -> List[int]:\n        if root is None:\n            return []\n        ans = []\n        st = [root]\n        while st:\n            node = st.pop()\n            ans.append(node.val)\n            st.extend(node.children)\n        ans.reverse()\n        return ans\n```\n\n```go [sol4-Golang]\nfunc postorder(root *Node) (ans []int) {\n    if root == nil {\n        return\n    }\n    st := []*Node{root}\n    for len(st) > 0 {\n        node := st[len(st)-1]\n        st = st[:len(st)-1]\n        ans = append(ans, node.Val)\n        st = append(st, node.Children...)\n    }\n    for i, n := 0, len(ans); i < n/2; i++ {\n        ans[i], ans[n-1-i] = ans[n-1-i], ans[i]\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。每个节点恰好被访问一次。\n\n- 空间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。如果 $N$ 叉树的深度为 $1$ 则此时栈的空间为 $O(1)$，如果 $N$ 叉树的深度为 $1$ 则此时栈的空间为 $O(m-1)$，平均情况下栈的空间为 $O(\\log m)$，因此空间复杂度为 $O(m)$。"
}