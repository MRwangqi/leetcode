{
	"titleSlug": "count-the-number-of-ideal-arrays",
	"slug": "shu-lun-zu-he-shu-xue-zuo-fa-by-endlessc-iouh",
	"url": "https://leetcode-cn.com/problems/count-the-number-of-ideal-arrays/solution/shu-lun-zu-he-shu-xue-zuo-fa-by-endlessc-iouh/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1aU4y1q7BA?t=7m29s) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n考虑以 $x$ 结尾的理想数组的个数。\r\n\r\n#### 提示 2-1\r\n\r\n理想数组在哪些位置上发生了**变化**（$\\textit{arr}[i-1]<\\textit{arr}[i]$）？这些位置多吗？\r\n\r\n#### 提示 2-2\r\n\r\n这些位置不多，假设每次都扩大一倍，那么至多可以扩大 $O(\\log x$) 次。\r\n\r\n#### 提示 3-1\r\n\r\n每次扩大的倍率 $\\dfrac{\\textit{arr}[i]}{\\textit{arr}[i-1]}$，乘起来等于什么？\r\n\r\n#### 提示 3-2\r\n\r\n恰好等于 $x$。\r\n\r\n#### 提示 3-3\r\n\r\n反过来，这些倍率是 $x$ 的因子。\r\n\r\n我们可以先对 $x$ 分解质因数，在质因数的基础上寻找答案。\r\n\r\n#### 提示 4-1\r\n\r\n把这些质因数（倍率）分配到数组的 $n$ 个位置中的某些位置上，这样就可以直接确定整个理想数组（因为其余位置都和上一个元素相同）。\r\n\r\n以 $x=8$ 为例：\r\n\r\n- $[2,2,4,4,4,8]$ 对应着 $[\\times 2,\\rule{0.45cm}{0.15mm},\\times 2,\\rule{0.45cm}{0.15mm},\\rule{0.45cm}{0.15mm},\\times 2]$；\r\n- $[1,1,4,4,8,8]$ 对应着 $[\\rule{0.45cm}{0.15mm},\\rule{0.45cm}{0.15mm},\\times 4,\\rule{0.45cm}{0.15mm},\\times 2,\\rule{0.45cm}{0.15mm}]$。\r\n\r\n#### 提示 4-2\r\n\r\n对于 $x=8$ 来说，分解出 $k=3$ 个**相同**的 $2$，那么以 $8$ 结尾的理想数组的个数，等价于一个经典的组合问题：\r\n\r\n> 把 $k$ 个无区别的小球放到 $n$ 个有区别的盒子中，允许盒子为空，一个盒子也可以放多个小球，有多少种不同的放法？\r\n\r\n此问题可以采用**隔板法**来解决：把 $n$ 个盒子当做 $n-1$ 个隔板，隔板加上球总共有 $n-1+k$ 个位置，从中选择 $n-1$ 个位置放隔板，$k$ 个位置放球，两个隔板之间的球（球可以有零个，一个，或者多个）放入对应盒子中（最两侧的隔板同理）。\r\n\r\n因此方案数为 $C(n+k-1,n-1)=C(n+k-1,k)$。\r\n\r\n#### 提示 4-3\r\n\r\n对于多个**不同**的质因数，互相之间无影响，可以采用**乘法原理**计算。\r\n\r\n枚举所有 $[1,\\textit{maxValue}]$ 的 $x$，计算对应的组合数，累加即为答案。\r\n\r\n代码实现时，分解出的质因数（只需要每个质因数的个数）和组合数都可以预处理出来。\r\n\r\n#### 复杂度分析\r\n\r\n预处理之后，`idealArrays` 的时间复杂度：$O(m\\log\\log m)$（$m$ 表示 $\\textit{maxValue}$）。见 [Prime omega function](https://en.wikipedia.org/wiki/Prime_omega_function)。\r\n\r\n```py [sol1-Python3]\r\nMOD, MX = 10 ** 9 + 7, 10 ** 4 + 1\r\n\r\nks = [[] for _ in range(MX)]  # ks[x] 为 x 分解质因数后，每个质因数的个数列表\r\nfor i in range(2, MX):\r\n    p, x = 2, i\r\n    while p * p <= x:\r\n        if x % p == 0:\r\n            k = 1\r\n            x //= p\r\n            while x % p == 0:\r\n                k += 1\r\n                x //= p\r\n            ks[i].append(k)\r\n        p += 1\r\n    if x > 1: ks[i].append(1)\r\n\r\nclass Solution:\r\n    def idealArrays(self, n: int, maxValue: int) -> int:\r\n        ans = 0\r\n        for x in range(1, maxValue + 1):\r\n            mul = 1\r\n            for k in ks[x]:\r\n                mul = mul * comb(n + k - 1, k) % MOD\r\n            ans += mul\r\n        return ans % MOD\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    static final int MOD = (int) 1e9 + 7, MX = (int) 1e4 + 1, MX_K = 13; // 至多 13 个质因数\r\n    static List[] ks = new List[MX]; // ks[x] 为 x 分解质因数后，每个质因数的个数列表\r\n    static int[][] c = new int[MX + MX_K][MX_K + 1]; // 组合数\r\n\r\n    static {\r\n        for (var i = 1; i < MX; i++) {\r\n            ks[i] = new ArrayList<Integer>();\r\n            var x = i;\r\n            for (var p = 2; p * p <= x; ++p) {\r\n                if (x % p == 0) {\r\n                    var k = 1;\r\n                    for (x /= p; x % p == 0; x /= p) ++k;\r\n                    ks[i].add(k);\r\n                }\r\n            }\r\n            if (x > 1) ks[i].add(1);\r\n        }\r\n\r\n        c[0][0] = 1;\r\n        for (var i = 1; i < MX + MX_K; ++i) {\r\n            c[i][0] = 1;\r\n            for (var j = 1; j <= Math.min(i, MX_K); ++j)\r\n                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD;\r\n        }\r\n    }\r\n\r\n    public int idealArrays(int n, int maxValue) {\r\n        var ans = 0L;\r\n        for (var x = 1; x <= maxValue; ++x) {\r\n            var mul = 1L;\r\n            for (var k : ks[x]) mul = mul * c[n + (int) k - 1][(int) k] % MOD;\r\n            ans += mul;\r\n        }\r\n        return (int) (ans % MOD);\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nconst int MOD = 1e9 + 7, MX = 1e4 + 1, MX_K = 13; // 至多 13 个质因数\r\nvector<int> ks[MX]; // ks[x] 为 x 分解质因数后，每个质因数的个数列表\r\nint c[MX + MX_K][MX_K + 1]; // 组合数\r\n\r\nint init = []() {\r\n    for (int i = 2; i < MX; ++i) {\r\n        int x = i;\r\n        for (int p = 2; p * p <= x; ++p) {\r\n            if (x % p == 0) {\r\n                int k = 1;\r\n                for (x /= p; x % p == 0; x /= p) ++k;\r\n                ks[i].push_back(k);\r\n            }\r\n        }\r\n        if (x > 1) ks[i].push_back(1);\r\n    }\r\n\r\n    c[0][0] = 1;\r\n    for (int i = 1; i < MX + MX_K; ++i) {\r\n        c[i][0] = 1;\r\n        for (int j = 1; j <= min(i, MX_K); ++j)\r\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD;\r\n    }\r\n    return 0;\r\n}();\r\n\r\nclass Solution {\r\npublic:\r\n    int idealArrays(int n, int maxValue) {\r\n        long ans = 0L;\r\n        for (int x = 1; x <= maxValue; ++x) {\r\n            long mul = 1L;\r\n            for (int k: ks[x]) mul = mul * c[n + k - 1][k] % MOD;\r\n            ans += mul;\r\n        }\r\n        return ans % MOD;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nconst mod, mx, mxK int = 1e9 + 7, 1e4 + 1, 13 // 至多 13 个质因数\r\n\r\nvar ks [mx][]int\r\nvar c [mx + mxK][mxK + 1]int\r\n\r\nfunc init() {\r\n\tfor i := 2; i < mx; i++ {\r\n\t\tx := i\r\n\t\tfor p := 2; p*p <= x; p++ {\r\n\t\t\tif x%p == 0 {\r\n\t\t\t\tk := 1\r\n\t\t\t\tfor x /= p; x%p == 0; x /= p {\r\n\t\t\t\t\tk++\r\n\t\t\t\t}\r\n\t\t\t\tks[i] = append(ks[i], k)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif x > 1 {\r\n\t\t\tks[i] = append(ks[i], 1)\r\n\t\t}\r\n\t}\r\n\r\n\tc[0][0] = 1\r\n\tfor i := 1; i < len(c); i++ {\r\n\t\tc[i][0] = 1\r\n\t\tfor j := 1; j <= mxK && j <= i; j++ {\r\n\t\t\tc[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc idealArrays(n, maxValue int) (ans int) {\r\n\tfor _, ks := range ks[1 : maxValue+1] {\r\n\t\tmul := 1\r\n\t\tfor _, k := range ks {\r\n\t\t\tmul = mul * c[n+k-1][k] % mod\r\n\t\t}\r\n\t\tans = (ans + mul) % mod\r\n\t}\r\n\treturn ans\r\n}\r\n```\r\n\r\n"
}