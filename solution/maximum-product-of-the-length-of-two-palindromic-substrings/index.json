{
	"titleSlug": "maximum-product-of-the-length-of-two-palindromic-substrings",
	"slug": "by-liupengsay-xutz",
	"url": "https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/solution/by-liupengsay-xutz/",
	"content": "### 解题思路\n【儿须成名酒须醉】Python3+马拉车算法+堆（优先队列）+有序集合\n\n### 代码\n- 执行用时：4736 ms, 在所有 Python3 提交中击败了 5.55% 的用户\n- 内存消耗：33.6 MB, 在所有 Python3 提交中击败了 16.67% 的用户\n- 通过测试用例：67 / 67\n\n```python3\nfrom sortedcontainers import SortedList\n\n\ndef manacher(s):\n    # 马拉车算法\n    n = len(s)\n    arm = [0] * n\n    l, r = 0, -1\n    for i in range(0, n):\n        k = 1 if i > r else min(arm[l + r - i], r - i + 1)\n\n        # 持续增加回文串的长度\n        while 0 <= i - k and i + k < n and s[i - k] == s[i + k]:\n            k += 1\n        arm[i] = k\n\n        # 更新右侧最远的回文串边界\n        k -= 1\n        if i + k > r:\n            l = i - k\n            r = i + k\n    # 返回每个位置往右的臂长\n    return arm\n\n\ndef center_arm(s):\n    # 获取区间的回文串信息\n    n = len(s)\n    t = \"#\" + \"#\".join(list(s)) + \"#\"\n    dp = manacher(t)\n    m = len(t)\n    # 以i为中心的回文子串臂长\n    arm = [0] * n\n    i = 0\n    for j in range(m):\n        if t[j] != \"#\":\n            arm[i] = (dp[j] - 1) // 2\n            i += 1\n    return arm\n\n\nclass Solution:\n    def maxProduct(self, s: str) -> int:\n        n = len(s)\n        arm = center_arm(s)\n\n        # 使用优先队列与有序集合动态规划记录当前索引及之前的最长奇数回文子串长度\n        pre = [0] * n\n        cur = 0\n        stack = []\n        lst = SortedList()\n        for i in range(n):\n            heapq.heappush(stack, [i + arm[i], i])\n            lst.add(i)\n            while stack and stack[0][0] < i:\n                lst.discard(heapq.heappop(stack)[1])\n            cur = cur if cur > (i - lst[0]) * 2 + 1 else (i - lst[0]) * 2 + 1\n            pre[i] = cur\n\n        # 同样的方法计算右边的最长长度\n        post = [0] * n\n        cur = 0\n        stack = []\n        lst = SortedList()\n        for i in range(n - 1, -1, -1):\n            heapq.heappush(stack, [-(i - arm[i]), i])\n            lst.add(i)\n            while stack and stack[0][0] < -i:\n                lst.discard(heapq.heappop(stack)[1])\n            cur = cur if cur > (lst[-1] - i) * 2 + 1 else (lst[-1] - i) * 2 + 1\n            post[i] = cur\n\n        # 枚举左右子串的分割点\n        ans = 0\n        for i in range(n - 1):\n            cur = pre[i] * post[i + 1]\n            ans = ans if ans > cur else cur\n        return ans\n```"
}