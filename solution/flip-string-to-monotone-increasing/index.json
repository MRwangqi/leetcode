{
	"titleSlug": "flip-string-to-monotone-increasing",
	"slug": "jiang-zi-fu-chuan-fan-zhuan-dao-dan-diao-stjd",
	"url": "https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/solution/jiang-zi-fu-chuan-fan-zhuan-dao-dan-diao-stjd/",
	"content": "#### 方法一：动态规划\n\n单调递增的字符串满足以下性质：\n\n- 首个字符是 $0$ 或 $1$；\n\n- 其余的每个字符，字符 $0$ 前面的相邻字符一定是 $0$，字符 $1$ 前面的相邻字符可以是 $0$ 或 $1$。\n\n当 $i > 0$ 时，如果字符串 $s$ 的长度为 $i$ 的前缀即 $s[0 .. i - 1]$ 单调递增，且 $s[i]$ 和 $s[i - 1]$ 也满足上述单调递增的顺序，则长度为 $i + 1$ 的前缀 $s[0 .. i]$ 也单调递增。因此可以使用动态规划计算使字符串 $s$ 单调递增的最小翻转次数。\n\n由于字符串 $s$ 的每个位置的字符可以是 $0$ 或 $1$，因此对于每个位置需要分别计算该位置的字符是 $0$ 和该位置的字符是 $1$ 的情况下的最小翻转次数。\n\n假设字符串 $s$ 的长度是 $n$，对于 $0 \\le i < n$，用 $\\textit{dp}[i][0]$ 和 $\\textit{dp}[i][1]$ 分别表示下标 $i$ 处的字符为 $0$ 和 $1$ 的情况下使得 $s[0 .. i]$ 单调递增的最小翻转次数。\n\n当 $i = 0$ 时，对应长度为 $1$ 的前缀，一定满足单调递增，因此 $\\textit{dp}[0][0]$ 和 $\\textit{dp}[0][1]$ 的值取决于字符 $s[i]$。具体而言，$\\textit{dp}[0][0] = \\mathbb{I}(s[0] = \\text{`1'})$，$\\textit{dp}[0][1] = \\mathbb{I}(s[0] = \\text{`0'})$，其中 $\\mathbb{I}$ 为示性函数，当事件成立时示性函数值为 $1$，当事件不成立时示性函数值为 $0$。\n\n当 $1 \\le i < n$ 时，考虑下标 $i$ 处的字符。如果下标 $i$ 处的字符是 $0$，则只有当下标 $i - 1$ 处的字符是 $0$ 时才符合单调递增；如果下标 $i$ 处的字符是 $1$，则下标 $i - 1$ 处的字符是 $0$ 或 $1$ 都符合单调递增，此时为了将翻转次数最小化，应分别考虑下标 $i - 1$ 处的字符是 $0$ 和 $1$ 的情况下需要的翻转次数，取两者的最小值。\n\n在计算 $\\textit{dp}[i][0]$ 和 $\\textit{dp}[i][1]$ 时，还需要根据 $s[i]$ 的值决定下标 $i$ 处的字符是否需要翻转，因此可以得到如下状态转移方程，其中 $\\mathbb{I}$ 为示性函数：\n\n$$\n\\begin{aligned}\n\\textit{dp}[i][0] &= \\textit{dp}[i - 1][0] + \\mathbb{I}(s[i] = \\text{`1'}) \\\\\n\\textit{dp}[i][1] &= \\min(\\textit{dp}[i - 1][0], \\textit{dp}[i - 1][1]) + \\mathbb{I}(s[i] = \\text{`0'})\n\\end{aligned}\n$$\n\n遍历字符串 $s$ 计算每个下标处的状态值，遍历结束之后，$\\textit{dp}[n - 1][0]$ 和 $\\textit{dp}[n - 1][1]$ 中的最小值即为使字符串 $s$ 单调递增的最小翻转次数。\n\n实现方面有以下两点可以优化。\n\n1. 可以将边界情况定义为 $\\textit{dp}[-1][0] = \\textit{dp}[-1][1] = 0$，则可以从下标 $0$ 开始使用状态转移方程计算状态值。\n\n2. 由于 $\\textit{dp}[i]$ 的值只和 $\\textit{dp}[i - 1]$ 有关，因此在计算状态值的过程中只需要维护前一个下标处的状态值，将空间复杂度降低到 $O(1)$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def minFlipsMonoIncr(self, s: str) -> int:\n        dp0 = dp1 = 0\n        for c in s:\n            dp0New, dp1New = dp0, min(dp0, dp1)\n            if c == '1':\n                dp0New += 1\n            else:\n                dp1New += 1\n            dp0, dp1 = dp0New, dp1New\n        return min(dp0, dp1)\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minFlipsMonoIncr(String s) {\n        int n = s.length();\n        int dp0 = 0, dp1 = 0;\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            int dp0New = dp0, dp1New = Math.min(dp0, dp1);\n            if (c == '1') {\n                dp0New++;\n            } else {\n                dp1New++;\n            }\n            dp0 = dp0New;\n            dp1 = dp1New;\n        }\n        return Math.min(dp0, dp1);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinFlipsMonoIncr(string s) {\n        int n = s.Length;\n        int dp0 = 0, dp1 = 0;\n        for (int i = 0; i < n; i++) {\n            char c = s[i];\n            int dp0New = dp0, dp1New = Math.Min(dp0, dp1);\n            if (c == '1') {\n                dp0New++;\n            } else {\n                dp1New++;\n            }\n            dp0 = dp0New;\n            dp1 = dp1New;\n        }\n        return Math.Min(dp0, dp1);\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minFlipsMonoIncr(string &s) {\n        int dp0 = 0, dp1 = 0;\n        for (char c: s) {\n            int dp0New = dp0, dp1New = min(dp0, dp1);\n            if (c == '1') {\n                dp0New++;\n            } else {\n                dp1New++;\n            }\n            dp0 = dp0New;\n            dp1 = dp1New;\n        }\n        return min(dp0, dp1);\n    }\n};\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint minFlipsMonoIncr(char * s){\n    int n = strlen(s);\n    int dp0 = 0, dp1 = 0;\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        int dp0New = dp0, dp1New = MIN(dp0, dp1);\n        if (c == '1') {\n            dp0New++;\n        } else {\n            dp1New++;\n        }\n        dp0 = dp0New;\n        dp1 = dp1New;\n    }\n    return MIN(dp0, dp1);\n}\n```\n\n```go [sol1-Golang]\nfunc minFlipsMonoIncr(s string) int {\n    dp0, dp1 := 0, 0\n    for _, c := range s {\n        dp0New, dp1New := dp0, min(dp0, dp1)\n        if c == '1' {\n            dp0New++\n        } else {\n            dp1New++\n        }\n        dp0, dp1 = dp0New, dp1New\n    }\n    return min(dp0, dp1)\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minFlipsMonoIncr = function(s) {\n    const n = s.length;\n    let dp0 = 0, dp1 = 0;\n    for (let i = 0; i < n; i++) {\n        const c = s[i];\n        let dp0New = dp0, dp1New = Math.min(dp0, dp1);\n        if (c === '1') {\n            dp0New++;\n        } else {\n            dp1New++;\n        }\n        dp0 = dp0New;\n        dp1 = dp1New;\n    }\n    return Math.min(dp0, dp1);\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。需要遍历字符串一次，对于每个字符计算最小翻转次数的时间都是 $O(1)$。\n\n- 空间复杂度：$O(1)$。使用空间优化的方法，空间复杂度是 $O(1)$。"
}