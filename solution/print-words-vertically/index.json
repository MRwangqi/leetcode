{
	"titleSlug": "print-words-vertically",
	"slug": "shu-zhi-da-yin-dan-ci-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/print-words-vertically/solution/shu-zhi-da-yin-dan-ci-by-leetcode-solution/",
	"content": "#### 方法一：模拟\n\n我们只需要顺着题目的要求进行模拟即可：\n\n- 第一步：将字符串 `s` 进行分词。在 `Python` 中可以直接使用 `split()` 函数对字符串进行分词，而在 `C++` 中没有相关的函数，但可以借助 `std::stringstream` 类，将字符串 `s` 作为输入流，从中依次读取单词；\n\n- 第二步：统计最长的单词长度。对于我们返回的字符串列表，它的长度等于最长的单词长度，其中每个元素的长度等于单词的数量；\n\n- 第三步：得到字符串列表中的每个元素。对于字符串列表中的第 `i` 个元素，它由所有单词的第 `i` 个字母组成。我们依次遍历所有的单词，若单词中有第 `i` 个字母，则将该字母加入元素的末尾；若没有第 `i` 个字母，则将空格加入元素的末尾；\n\n- 第四步：去除尾随空格。在 `Python` 中可以直接使用 `rstrip()` 函数去除尾随空格，而在 `C++` 中没有相关的函数，可以使用循环将字符串末尾的空格依次弹出，或使用 `string::find_last_not_of()` 函数找到字符串最右侧的非空格字符，再使用 `string::substr()` 函数得到不包含尾随空格的字符串。\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> printVertically(string s) {\n        stringstream in(s);\n        vector<string> words;\n        string _word;\n        int maxlen = 0;\n        while (in >> _word) {\n            words.push_back(_word);\n            maxlen = max(maxlen, (int)_word.size());\n        }\n        vector<string> ans;\n        for (int i = 0; i < maxlen; ++i) {\n            string concat;\n            for (string& word: words) {\n                concat += (i < word.size() ? word[i] : ' ');\n            }\n            while (concat.back() == ' ') {\n                concat.pop_back();\n            }\n            ans.push_back(move(concat));\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def printVertically(self, s: str) -> List[str]:\n        words = s.split()\n        maxlen = max(len(word) for word in words)\n        ans = list()\n        for i in range(maxlen):\n            concat = \"\".join([word[i] if i < len(word) else \" \" for word in words])\n            ans.append(concat.rstrip())\n        return ans\n\n```\n\n```Python [sol1-Python3-1Line]\nclass Solution:\n    def printVertically(self, s: str) -> List[str]:\n        return [\"\".join(x).rstrip() for x in itertools.zip_longest(*s.split(), fillvalue=\" \")]\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N\\max(|S|))$，其中 $N$ 是字符串 `s` 中的单词个数，$\\max(|S|)$ 是最长的单词长度。\n\n- 空间复杂度：$O(N\\max(|S|))$。"
}