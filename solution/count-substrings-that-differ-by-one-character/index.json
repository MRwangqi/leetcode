{
	"titleSlug": "count-substrings-that-differ-by-one-character",
	"slug": "dong-tai-gui-hua-jian-dan-yi-dong-by-phi-qgto",
	"url": "https://leetcode-cn.com/problems/count-substrings-that-differ-by-one-character/solution/dong-tai-gui-hua-jian-dan-yi-dong-by-phi-qgto/",
	"content": "# 方法一：动态规划\n## 解题思路\n\n首先，我们可能会这样思考：假设已经知道字符串`s[:i]`和`t[:j]`中所有满足条件的子串对数目，考虑`s[:(i+1)]`和`t[:(j+1)]`中所有满足条件的子串对数目。然而这样对于新加入的`s[i]`，仍然需要和`t[:j]`中的所有字符进行比较判断，非常复杂。\n\n因此，我们可以退一步，只用dp数组记录**以`s[i]`和`t[j]`结尾**的恰好只有一个字符不同的子串对数目，这样每对`(i,j)`结尾得到的子串对是互不重叠的，再用一个变量`tot`记录总的满足条件的子串对数目（dp数组中所有元素之和）。这样考虑新的一位`s[i]`和`t[j]`时，能够直接和前面的字符串拼接起来，就可以利用dp数组存储的信息，给出转移方程。\n\n假设已经知道以`s[i-1]`和`t[j-1]`结尾的恰好只有一个字符不同的子串对数目为`cnt[i-1][j-1]`，考虑以`s[i]`和`t[j]`结尾的满足条件的子串对数目。根据`s[i]==t[j]`是否成立分情况讨论：\n1. 如果`s[i]==t[j]`，那么在所有以`s[i-1]`和`t[j-1]`结尾的符合条件的子字符串对后面分别加上这两位，新的子字符串对仍然满足条件，则`cnt[i][j] = cnt[i-1][j-1]`；\n2. 如果`s[i]!=t[j]`，那么该字符串对已经有一个字符不同了，即`s[i]`和`t[j]`本身就是一组符合条件的子串对。如果前面还有相同的字符，则加上这两位仍然是符合条件的子串对，eg. （加粗的是`s[i]`和`t[j]`）\"**a**\"和\"**b**\"是符合条件的子串对，则\"a**a**\"和\"a**b**\"也是符合条件的子串对，\"ca**a**\"和\"ca**b**\"也是符合条件的子串对。因此只要我们知道以`s[i-1]`和`t[j-1]`结尾的字符串对往前连续相同的字符数量，则`dp[i][j]`就等于相同字符数量+1。\n所以我们再用一个数组`same[i][j]`记录以`s[i]`和`t[j]`结尾的连续相同的字符数量。\n\n综上，\n\n$$\ncnt[i][j] = \\begin{cases} cnt[i-1][j-1], \\quad if \\quad s[i]==t[j]  \\\\\nsame[i-1][j-1]+1, \\quad if \\quad s[i]!=t[j]\n\\end{cases} \n$$\n\n$$\nsame[i][j] = \\begin{cases} same[i-1][j-1]+1, \\quad if \\quad s[i]==t[j]  \\\\\n0, \\quad if \\quad s[i]!=t[j]\n\\end{cases} \n$$\n\n可以发现dp数组中的每一位都只和斜上角的一位有关，所以dp数组可以不用存m*n的矩阵，只需要存上一行。我的代码里把`cnt`和`same`数组合并为元组存在了`dp`变量中。\n\n\n## 代码\n\n```python3\nclass Solution:\n    def countSubstrings(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n\n        # 方法一：用dp存储一行\n        dp = [(0, 0)]*(n+1) # 记录 (以s[i]和t[j]结尾的 满足条件的子字符串对数目, 连续相同的位数)\n        tot = 0   # 总的满足条件的子字符串对数目\n        for i in range(m):\n            last = dp[0]\n            for j in range(n):\n                if s[i] == t[j]:\n                    cur = (dp[j][0], dp[j][1] + 1)\n                    tot += dp[j][0]\n                else:\n                    cur = (dp[j][1] + 1, 0)\n                    tot += dp[j][1] + 1\n                dp[j], last = last, cur\n            dp[n] = last\n        return tot\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(mn)，其中m和n分别是字符串`s`和`t`的长度\n- 空间复杂度：O(n)\n\n\n# 方法一的空间优化\n\n可以发现dp数组中的每一位都只和斜上角的一位有关，所以dp数组甚至可以只存斜上角一位的数，这样空间复杂度可以降到O(1)。\n\n```python3\nclass Solution:\n    def countSubstrings(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        \n        # 方法二：只存储斜上方的值\n        # 记录 (以s[i]和t[j]结尾的 满足条件的子字符串对数目, 连续相同的位数)\n        tot = 0\n        # 左下角\n        for i in range(m-1, -1, -1):\n            last = (0, 0)  # 初始\n            for j in range(min(m-i, n)):\n                if s[i+j] == t[j]:\n                    cur = (last[0], last[1] + 1)\n                    tot += last[0]\n                else:\n                    cur = (last[1] + 1, 0)\n                    tot += last[1] + 1\n                last = cur\n        # 补全右上角\n        for j in range(1, n):\n            last = (0, 0)\n            for i in range(min(n-j, m)):\n                if s[i] == t[j+i]:\n                    cur = (last[0], last[1] + 1)\n                    tot += last[0]\n                else:\n                    cur = (last[1] + 1, 0)\n                    tot += last[1] + 1\n                last = cur\n        return tot\n```\n### 复杂度分析\n\n- 时间复杂度：O(mn)，其中m和n分别是字符串`s`和`t`的长度\n- 空间复杂度：O(1)"
}