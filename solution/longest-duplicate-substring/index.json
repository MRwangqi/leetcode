{
	"titleSlug": "longest-duplicate-substring",
	"slug": "zui-chang-zhong-fu-zi-chuan-by-leetcode-0i9rd",
	"url": "https://leetcode-cn.com/problems/longest-duplicate-substring/solution/zui-chang-zhong-fu-zi-chuan-by-leetcode-0i9rd/",
	"content": "#### 方法一：二分查找 + Rabin-Karp 字符串编码\n\n**思路及解法**\n\n记 $s$ 的长度为 $n$。这个问题可以分为两步：从 $n - 1$ 到 $1$ 由大至小遍历选取长度 $L$，判断 $s$ 中是否有长度为 $L$ 的重复子串。从大至小遍历的时候，第一次遇到的符合条件的 $L$，即为最大的符合条件的 $L$，记为 $L_1$，重复的子串为 $s_1$。并且对于任意满足 $L_0 \\leq L_1$ 的 $L_0$ 也均符合条件，因为 $s_1$ 的所有子串也是 $s$ 的重复子串。而对于任意满足 $L_2 \\gt L_1$ 的 $L_2$，则均不符合条件。因此，我们可以用二分查找的方法，来查找 $L_1$。\n\n剩下的任务便是如何高效判断 $s$ 中是否有长度为 $L$ 的重复子串。我们可以使用 Rabin-Karp 算法对固定长度的字符串进行编码。当两个字符串的编码相同时，则这两个字符串也相同。在 $s$ 中 ${n-L+1}$ 个长度为 $L$ 的子串中，有两个子串的编码相同时，则说明存在长度为 $L$ 的重复子串。具体步骤如下：\n1. 首先，我们需要对 $s$ 的每个字符进行编码，得到一个数组 $arr$。因为本题中 $s$ 仅包含小写字母，我们可按照 $\\texttt{arr[i] = (int)s.charAt(i) - (int)`a'}$，将所有字母编码为 $0-25$ 之间的数字。比如字符串 $\\text{``abcde\"}$ 可以编码为数组 $[0, 1, 2, 3, 4]$。\n2. 我们将子串看成一个 $26$ 进制的数，它对应的 $10$ 进制数就是它的编码。假设此时我们需要求长度为 $3$ 的子串的编码。那么第一个子串 $\\text{``abc''}$ 的编码就是 $h_0 = 0 \\times 26^2 + 1 \\times 26^1 + 2 \\times 26^0 = 28$。更一般地，设 $c_i$ 为 $s$ 的第 $i$ 个字符编码后的数字，$a$ $(a\\geq26)$ 为编码的进制，那么有 $h_0 = c_0a^{L-1} + c_1a^{L-2} + ... +c_{L-1}a^1 = \\sum_{i=0}^{L-1} c_ia^{L-1-i}$。\n3. 上一步我们只求了第一个子串 $\\text{``abc''}$ 的编码。当我们要求第二个子串 $\\text{``bcd''}$ 的编码时，也可以按照上一步的方法求：$h_1 = 1 \\times 26^2 + 2 \\times 26^1 + 3 \\times 26^0 = 731$，但是这样时间复杂度是 $O(L)$。我们可以在 $h_0$ 的基础上，更快地求出它的编码：$h_1 = (h_0 - 0 \\times 26^2) \\times 26 + 3 \\times 26^0 = 731$。更一般的表达式是：$h_1 = (h_0 \\times a - c_0 \\times a^L) + c_{L+1}$。这样，我们只需要在常数时间内就可以根据上一个子串的编码求出下一个子串的编码。我们用一个哈希表 $\\textit{seen}$ 来存储子串的编码。在求子串的编码时，如果某个子串的编码出现过，则表示存在长度为 $L$ 的重复子串，否则，我们将当前的编码放入 $\\textit{seen}$ 中。如果所有编码都不重复，则说明不存在长度为 $L$ 的重复子串。\n4. 还有一点需要考虑的是，本题中 $a^L$ 会非常大。一般的做法是需要对编码进行取模来防止溢出，模一般选取编码的信息量的平方的数量级。而取模则会带来哈希碰撞。本题中为了避免碰撞，我们使用双哈希，即用两套进制和模的组合，来对字符串进行编码。只有两种编码都相同时，我们才认为字符串相同。\n5. 本题要求返回最长重复子串而不是最长重复子串长度。因此，当存在长度为 $L$ 的子串时，我们的判断函数可以返回重复子串的起点。而当不存在时，可以返回 $-1$ 用做区分。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def longestDupSubstring(self, s: str) -> str:\n        # 生成两个进制\n        a1, a2 = random.randint(26, 100), random.randint(26, 100)\n        # 生成两个模\n        mod1, mod2 = random.randint(10**9+7, 2**31-1), random.randint(10**9+7, 2**31-1)\n        n = len(s)\n        # 先对所有字符进行编码\n        arr = [ord(c)-ord('a') for c in s]\n        # 二分查找的范围是[1, n-1]\n        l, r = 1, n-1\n        length, start = 0, -1\n        while l <= r:\n            m = l + (r - l + 1) // 2\n            idx = self.check(arr, m, a1, a2, mod1, mod2)\n            # 有重复子串，移动左边界\n            if idx != -1:\n                l = m + 1\n                length = m\n                start = idx\n            # 无重复子串，移动右边界\n            else:\n                r = m - 1\n        return s[start:start+length] if start != -1 else \"\"\n\n    def check(self, arr, m, a1, a2, mod1, mod2):\n        n = len(arr)\n        aL1, aL2 = pow(a1, m, mod1), pow(a2, m, mod2)\n        h1, h2 = 0, 0\n        for i in range(m):\n            h1 = (h1 * a1 + arr[i]) % mod1\n            h2 = (h2 * a2 + arr[i]) % mod2\n        # 存储一个编码组合是否出现过\n        seen = {(h1, h2)}\n        for start in range(1, n - m + 1):\n            h1 = (h1 * a1 - arr[start - 1] * aL1 + arr[start + m - 1]) % mod1\n            h2 = (h2 * a2 - arr[start - 1] * aL2 + arr[start + m - 1]) % mod2\n            # 如果重复，则返回重复串的起点\n            if (h1, h2) in seen:\n                return start\n            seen.add((h1, h2))\n        # 没有重复，则返回-1\n        return -1\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String longestDupSubstring(String s) {\n        Random random = new Random();\n        // 生成两个进制\n        int a1 = random.nextInt(75) + 26;\n        int a2 = random.nextInt(75) + 26;\n        // 生成两个模\n        int mod1 = random.nextInt(Integer.MAX_VALUE - 1000000007 + 1) + 1000000007;\n        int mod2 = random.nextInt(Integer.MAX_VALUE - 1000000007 + 1) + 1000000007;\n        int n = s.length();\n        // 先对所有字符进行编码\n        int[] arr = new int[n];\n        for (int i = 0; i < n; ++i) {\n            arr[i] = s.charAt(i) - 'a';\n        }\n        // 二分查找的范围是[1, n-1]\n        int l = 1, r = n - 1;\n        int length = 0, start = -1;\n        while (l <= r) {\n            int m = l + (r - l + 1) / 2;\n            int idx = check(arr, m, a1, a2, mod1, mod2);\n            if (idx != -1) {\n                // 有重复子串，移动左边界\n                l = m + 1;\n                length = m;\n                start = idx;\n            } else {\n                // 无重复子串，移动右边界\n                r = m - 1;\n            }\n        }\n        return start != -1 ? s.substring(start, start + length) : \"\";\n    }\n\n    public int check(int[] arr, int m, int a1, int a2, int mod1, int mod2) {\n        int n = arr.length;\n        long aL1 = pow(a1, m, mod1);\n        long aL2 = pow(a2, m, mod2);\n        long h1 = 0, h2 = 0;\n        for (int i = 0; i < m; ++i) {\n            h1 = (h1 * a1 % mod1 + arr[i]) % mod1;\n            h2 = (h2 * a2 % mod2 + arr[i]) % mod2;\n            if (h1 < 0) {\n                h1 += mod1;\n            }\n            if (h2 < 0) {\n                h2 += mod2;\n            }\n        }\n        // 存储一个编码组合是否出现过\n        Set<Long> seen = new HashSet<Long>();\n        seen.add(h1 * mod2 + h2);\n        for (int start = 1; start <= n - m; ++start) {\n            h1 = (h1 * a1 % mod1 - arr[start - 1] * aL1 % mod1 + arr[start + m - 1]) % mod1;\n            h2 = (h2 * a2 % mod2 - arr[start - 1] * aL2 % mod2 + arr[start + m - 1]) % mod2;\n            if (h1 < 0) {\n                h1 += mod1;\n            }\n            if (h2 < 0) {\n                h2 += mod2;\n            }\n\n            long num = h1 * mod2 + h2;\n            // 如果重复，则返回重复串的起点\n            if (!seen.add(num)) {\n                return start;\n            }\n        }\n        // 没有重复，则返回-1\n        return -1;\n    }\n\n    public long pow(int a, int m, int mod) {\n        long ans = 1;\n        long contribute = a;\n        while (m > 0) {\n            if (m % 2 == 1) {\n                ans = ans * contribute % mod;\n                if (ans < 0) {\n                    ans += mod;\n                }\n            }\n            contribute = contribute * contribute % mod;\n            if (contribute < 0) {\n                contribute += mod;\n            }\n            m /= 2;\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string LongestDupSubstring(string s) {\n        Random random = new Random();\n        // 生成两个进制\n        int a1 = random.Next(26, 101);\n        int a2 = random.Next(26, 101);\n        // 生成两个模\n        int mod1 = random.Next(1000000006, int.MaxValue) + 1;\n        int mod2 = random.Next(1000000006, int.MaxValue) + 1;\n        int n = s.Length;\n        // 先对所有字符进行编码\n        int[] arr = new int[n];\n        for (int i = 0; i < n; ++i) {\n            arr[i] = s[i] - 'a';\n        }\n        // 二分查找的范围是[1, n-1]\n        int l = 1, r = n - 1;\n        int length = 0, start = -1;\n        while (l <= r) {\n            int m = l + (r - l + 1) / 2;\n            int idx = Check(arr, m, a1, a2, mod1, mod2);\n            if (idx != -1) {\n                // 有重复子串，移动左边界\n                l = m + 1;\n                length = m;\n                start = idx;\n            } else {\n                // 无重复子串，移动右边界\n                r = m - 1;\n            }\n        }\n        return start != -1 ? s.Substring(start, length) : \"\";\n    }\n\n    public int Check(int[] arr, int m, int a1, int a2, int mod1, int mod2) {\n        int n = arr.Length;\n        long aL1 = Pow(a1, m, mod1);\n        long aL2 = Pow(a2, m, mod2);\n        long h1 = 0, h2 = 0;\n        for (int i = 0; i < m; ++i) {\n            h1 = (h1 * a1 % mod1 + arr[i]) % mod1;\n            h2 = (h2 * a2 % mod2 + arr[i]) % mod2;\n            if (h1 < 0) {\n                h1 += mod1;\n            }\n            if (h2 < 0) {\n                h2 += mod2;\n            }\n        }\n        // 存储一个编码组合是否出现过\n        ISet<long> seen = new HashSet<long>();\n        seen.Add(h1 * mod2 + h2);\n        for (int start = 1; start <= n - m; ++start) {\n            h1 = (h1 * a1 % mod1 - arr[start - 1] * aL1 % mod1 + arr[start + m - 1]) % mod1;\n            h2 = (h2 * a2 % mod2 - arr[start - 1] * aL2 % mod2 + arr[start + m - 1]) % mod2;\n            if (h1 < 0) {\n                h1 += mod1;\n            }\n            if (h2 < 0) {\n                h2 += mod2;\n            }\n\n            long num = h1 * mod2 + h2;\n            // 如果重复，则返回重复串的起点\n            if (!seen.Add(num)) {\n                return start;\n            }\n        }\n        // 没有重复，则返回-1\n        return -1;\n    }\n\n    public long Pow(int a, int m, int mod) {\n        long ans = 1;\n        long contribute = a;\n        while (m > 0) {\n            if (m % 2 == 1) {\n                ans = ans * contribute % mod;\n                if (ans < 0) {\n                    ans += mod;\n                }\n            }\n            contribute = contribute * contribute % mod;\n            if (contribute < 0) {\n                contribute += mod;\n            }\n            m /= 2;\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\ntypedef pair<long long, long long> pll;\nclass Solution {\npublic:\n    long long pow(int a, int m, int mod) {\n        long long ans = 1;\n        long long contribute = a;\n        while (m > 0) {\n            if (m % 2 == 1) {\n                ans = ans * contribute % mod;\n                if (ans < 0) {\n                    ans += mod;\n                }\n            }\n            contribute = contribute * contribute % mod;\n            if (contribute < 0) {\n                contribute += mod;\n            }\n            m /= 2;\n        }\n        return ans;\n    }\n\n    int check(const vector<int> & arr, int m, int a1, int a2, int mod1, int mod2) {\n        int n = arr.size();\n        long long aL1 = pow(a1, m, mod1);\n        long long aL2 = pow(a2, m, mod2);\n        long long h1 = 0, h2 = 0;\n        for (int i = 0; i < m; ++i) {\n            h1 = (h1 * a1 % mod1 + arr[i]) % mod1;\n            h2 = (h2 * a2 % mod2 + arr[i]) % mod2;\n            if (h1 < 0) {\n                h1 += mod1;\n            }\n            if (h2 < 0) {\n                h2 += mod2;\n            }\n        }\n        // 存储一个编码组合是否出现过\n        set<pll> seen;\n        seen.emplace(h1, h2);\n        for (int start = 1; start <= n - m; ++start) {\n            h1 = (h1 * a1 % mod1 - arr[start - 1] * aL1 % mod1 + arr[start + m - 1]) % mod1;\n            h2 = (h2 * a2 % mod2 - arr[start - 1] * aL2 % mod2 + arr[start + m - 1]) % mod2;\n            if (h1 < 0) {\n                h1 += mod1;\n            }\n            if (h2 < 0) {\n                h2 += mod2;\n            }\n\n            // 如果重复，则返回重复串的起点\n            if (seen.count(make_pair(h1, h2))) {\n                return start;\n            }\n            seen.emplace(h1, h2);\n        }\n        // 没有重复，则返回-1\n        return -1;\n    }\n\n    string longestDupSubstring(string s) {\n        srand((unsigned)time(NULL));\n        // 生成两个进制\n        int a1 = random()%75 + 26;\n        int a2 = random()%75 + 26;\n\n        // 生成两个模\n        int mod1 = random()%(INT_MAX - 1000000006) + 1000000006;\n        int mod2 = random()%(INT_MAX - 1000000006) + 1000000006;\n        int n = s.size();\n        // 先对所有字符进行编码\n        vector<int> arr(n);\n        for (int i = 0; i < n; ++i) {\n            arr[i] = s[i] - 'a';\n        }\n        // 二分查找的范围是[1, n-1]\n        int l = 1, r = n - 1;\n        int length = 0, start = -1;\n        while (l <= r) {\n            int m = l + (r - l + 1) / 2;\n            int idx = check(arr, m, a1, a2, mod1, mod2);\n            if (idx != -1) {\n                // 有重复子串，移动左边界\n                l = m + 1;\n                length = m;\n                start = idx;\n            } else {\n                // 无重复子串，移动右边界\n                r = m - 1;\n            }\n        }\n        return start != -1 ? s.substr(start, length) : \"\";\n    }\n};\n```\n\n```go [sol1-Golang]\nfunc randInt(a, b int) int {\n    return a + rand.Intn(b-a)\n}\n\nfunc pow(x, n, mod int) int {\n    res := 1\n    for ; n > 0; n >>= 1 {\n        if n&1 > 0 {\n            res = res * x % mod\n        }\n        x = x * x % mod\n    }\n    return res\n}\n\nfunc check(arr []byte, m, a1, a2, mod1, mod2 int) int {\n    aL1, aL2 := pow(a1, m, mod1), pow(a2, m, mod2)\n    h1, h2 := 0, 0\n    for _, c := range arr[:m] {\n        h1 = (h1*a1 + int(c)) % mod1\n        h2 = (h2*a2 + int(c)) % mod2\n    }\n    // 存储一个编码组合是否出现过\n    seen := map[[2]int]bool{{h1, h2}: true}\n    for start := 1; start <= len(arr)-m; start++ {\n        h1 = (h1*a1 - int(arr[start-1])*aL1 + int(arr[start+m-1])) % mod1\n        if h1 < 0 {\n            h1 += mod1\n        }\n        h2 = (h2*a2 - int(arr[start-1])*aL2 + int(arr[start+m-1])) % mod2\n        if h2 < 0 {\n            h2 += mod2\n        }\n        // 如果重复，则返回重复串的起点\n        if seen[[2]int{h1, h2}] {\n            return start\n        }\n        seen[[2]int{h1, h2}] = true\n    }\n    // 没有重复，则返回 -1\n    return -1\n}\n\nfunc longestDupSubstring(s string) string {\n    rand.Seed(time.Now().UnixNano())\n    // 生成两个进制\n    a1, a2 := randInt(26, 100), randInt(26, 100)\n    // 生成两个模\n    mod1, mod2 := randInt(1e9+7, math.MaxInt32), randInt(1e9+7, math.MaxInt32)\n    // 先对所有字符进行编码\n    arr := []byte(s)\n    for i := range arr {\n        arr[i] -= 'a'\n    }\n\n    l, r := 1, len(s)-1\n    length, start := 0, -1\n    for l <= r {\n        m := l + (r-l+1)/2\n        idx := check(arr, m, a1, a2, mod1, mod2)\n        if idx != -1 { // 有重复子串，移动左边界\n            l = m + 1\n            length = m\n            start = idx\n        } else { // 无重复子串，移动右边界\n            r = m - 1\n        }\n    }\n    if start == -1 {\n        return \"\"\n    }\n    return s[start : start+length]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是字符串 $s$ 的长度。二分查找的时间复杂度为 $O(\\log n)$，Rabin-Karp 字符串编码的时间复杂度为 $O(n)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长。$\\textit{arr}$ 和 $\\textit{seen}$ 各消耗 $O(n)$ 的空间。"
}