{
	"titleSlug": "divide-array-in-sets-of-k-consecutive-numbers",
	"slug": "hua-fen-shu-zu-wei-lian-xu-shu-zi-de-ji-he-by-le-2",
	"url": "https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/solution/hua-fen-shu-zu-wei-lian-xu-shu-zi-de-ji-he-by-le-2/",
	"content": "#### 方法一：贪心\n\n题目要求将数组 $\\textit{nums}$ 中的元素分组使得每组的大小是 $k$。假设数组 $\\textit{nums}$ 的长度是 $n$，只有当 $n \\bmod k = 0$ 时才可能完成分组，因此如果 $n \\bmod k \\ne 0$ 则直接返回 $\\text{false}$。\n\n当 $n \\bmod k = 0$ 时，可以将数组 $\\textit{nums}$ 中的元素分组使得每组的大小是 $k$，此时需要判断是否存在一种分组方式使得同一组的元素都是连续的。\n\n由于每个元素都必须被分到某个组，因此可以使用贪心的策略。假设尚未分组的元素中，最小的数字是 $x$，则如果存在符合要求的分组方式，$x$ 一定是某个组中的最小数字（否则 $x$ 不属于任何一个组，不符合每个元素都必须被分到某个组），该组的数字范围是 $[x, x + k - 1]$。在将 $x$ 到 $x + k - 1$ 的 $k$ 个元素分成一个组之后，继续使用贪心的策略对剩下的元素分组，直到所有的元素分组结束或者无法完成分组。如果在分组过程中发现从最小数字开始的连续 $k$ 个数字中有不存在的数字，则无法完成分组。\n\n首先对数组 $\\textit{nums}$ 排序，并使用哈希表记录数组 $\\textit{nums}$ 中每个元素的出现次数，然后遍历数组 $\\textit{nums}$，使用基于上述贪心策略的做法判断是否可以完成分组。贪心策略的具体做法如下：\n\n1. 将当前元素记为 $x$，如果 $x$ 不在哈希表中则跳过，如果 $x$ 在哈希表中，则 $x$ 是某个组中的最小数字（因为数组 $\\textit{nums}$ 有序，当遍历到 $x$ 时，$x$ 一定是所有尚未分组的元素中的最小数字），该组的数字范围是 $[x, x + k - 1]$；\n\n2. 如果可以完成分组，则 $x$ 到 $x + k - 1$ 的每个整数在哈希表中记录的出现次数都至少为 $1$，如果遇到某个整数的出现次数为 $0$ 则无法完成分组，返回 $\\text{false}$；\n\n3. 将 $x$ 到 $x + k - 1$ 的每个整数在哈希表中记录的出现次数减 $1$，如果出现次数减为 $0$ 则从哈希表中移除该整数；\n\n4. 对于其余元素，重复上述操作，直到遍历结束。\n\n遍历结束之后，如果没有出现无法完成分组的情况，返回 $\\text{true}$。\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean isPossibleDivide(int[] nums, int k) {\n        int n = nums.length;\n        if (n % k != 0) {\n            return false;\n        }\n        Arrays.sort(nums);\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        for (int x : nums) {\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n        }\n        for (int x : nums) {\n            if (!cnt.containsKey(x)) {\n                continue;\n            }\n            for (int j = 0; j < k; j++) {\n                int num = x + j;\n                if (!cnt.containsKey(num)) {\n                    return false;\n                }\n                cnt.put(num, cnt.get(num) - 1);\n                if (cnt.get(num) == 0) {\n                    cnt.remove(num);\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool IsPossibleDivide(int[] nums, int k) {\n        int n = nums.Length;\n        if (n % k != 0) {\n            return false;\n        }\n        Array.Sort(nums);\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        foreach (int x in nums) {\n            if (!cnt.ContainsKey(x)) {\n                cnt.Add(x, 0);\n            }\n            cnt[x]++;\n        }\n        foreach (int x in nums) {\n            if (!cnt.ContainsKey(x)) {\n                continue;\n            }\n            for (int j = 0; j < k; j++) {\n                int num = x + j;\n                if (!cnt.ContainsKey(num)) {\n                    return false;\n                }\n                cnt[num]--;\n                if (cnt[num] == 0) {\n                    cnt.Remove(num);\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool isPossibleDivide(vector<int>& nums, int k) {\n        int n = nums.size();\n        if (n % k != 0) {\n            return false;\n        }\n        sort(nums.begin(), nums.end());\n        unordered_map<int, int> cnt;\n        for (auto & num : nums) {\n            cnt[num]++;\n        }\n        for (auto & x : nums) {\n            if (!cnt.count(x)) {\n                continue;\n            }\n            for (int j = 0; j < k; j++) {\n                int num = x + j;\n                if (!cnt.count(num)) {\n                    return false;\n                }\n                cnt[num]--;\n                if (cnt[num] == 0) {\n                    cnt.erase(num);\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n```C [sol1-C]\nstatic int cmp(const void * pa, const void * pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\ntypedef struct Node {\n    int val;\n    int freq;\n} Node;\n\nbool isPossibleDivide(int* nums, int numsSize, int k) {\n    if (numsSize % k != 0) {\n        return false;\n    }\n    qsort(nums, numsSize, sizeof(int), cmp);\n    Node * cnt = (Node *)malloc(sizeof(Node) * numsSize);\n    memset(cnt, 0, sizeof(Node) * numsSize);\n    int cardSize = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        if (i == 0) {\n            cnt[cardSize].val = nums[i];\n            cnt[cardSize].freq = 1;\n        } else {\n            if(nums[i] != cnt[cardSize].val) {\n                cardSize++;\n            } \n            cnt[cardSize].val = nums[i];\n            cnt[cardSize].freq++;\n        }\n    }\n    int pos = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        while (pos < cardSize && cnt[pos].freq == 0) {\n            pos++;\n        }\n        if (cnt[pos].val == nums[i] && cnt[pos].freq > 0) {\n            for (int j = 0; j < k; ++j) {\n                int num = nums[i] + j;\n                if (cnt[pos + j].freq > 0 && cnt[pos + j].val == num) {\n                    cnt[pos + j].freq--;\n                } else {\n                    return false;\n                }\n            }\n        } \n    }\n    free(cnt);\n    return true;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar isPossibleDivide = function(nums, k) {\n    const n = nums.length;\n    if (n % k !== 0) {\n        return false;\n    }\n    nums.sort((a, b) => a - b);\n    const cnt = new Map();\n    for (const x of nums) {\n        cnt.set(x, (cnt.get(x) || 0) + 1);\n    }\n    for (const x of nums) {\n        if (!cnt.has(x)) {\n            continue;\n        }\n        for (let j = 0; j < k; j++) {\n            const num = x + j;\n            if (!cnt.has(num)) {\n                return false;\n            }\n            cnt.set(num, cnt.get(num) - 1);\n            if (cnt.get(num) == 0) {\n                cnt.delete(num);\n            }\n        }\n    }\n    return true;\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k > 0:\n            return False\n        nums.sort()\n        cnt = Counter(nums)\n        for x in nums:\n            if cnt[x] == 0:\n                continue\n            for num in range(x, x + k):\n                if cnt[num] == 0:\n                    return False\n                cnt[num] -= 1\n        return True\n```\n\n```go [sol1-Golang]\nfunc isPossibleDivide(nums []int, k int) bool {\n    if len(nums)%k > 0 {\n        return false\n    }\n    sort.Ints(nums)\n    cnt := map[int]int{}\n    for _, num := range nums {\n        cnt[num]++\n    }\n    for _, x := range nums {\n        if cnt[x] == 0 {\n            continue\n        }\n        for num := x; num < x+k; num++ {\n            if cnt[num] == 0 {\n                return false\n            }\n            cnt[num]--\n        }\n    }\n    return true\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。对数组 $\\textit{nums}$ 排序需要 $O(n \\log n)$ 的时间，排序之后遍历数组 $\\textit{nums}$ 两次，每次遍历过程中，每个元素的处理时间都是 $O(1)$，因此每次遍历的时间复杂度都是 $O(n)$，总时间复杂度是 $O(n \\log n)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。空间复杂度主要取决于哈希表，哈希表中最多存储 $n$ 个元素。"
}