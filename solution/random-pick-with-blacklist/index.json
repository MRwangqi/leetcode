{
	"titleSlug": "random-pick-with-blacklist",
	"slug": "hei-ming-dan-zhong-de-sui-ji-shu-by-leet-cyrx",
	"url": "https://leetcode-cn.com/problems/random-pick-with-blacklist/solution/hei-ming-dan-zhong-de-sui-ji-shu-by-leet-cyrx/",
	"content": "#### 方法一：黑名单映射\n\n设 $\\textit{blacklist}$ 的长度为 $m$。\n\n考察一个特殊的例子：所有黑名单数全部在区间 $[n-m,n)$ 范围内。此时我们可以直接在 $[0,n-m)$ 范围内取随机整数。\n\n这给我们一个启示，对于在 $[0,n-m)$ 范围内的黑名单数，我们可以将其映射到 $[n-m,n)$ 范围内的非黑名单数（白名单数）上。每次 $\\text{pick()}$ 时，仍然可以在 $[0,n-m)$ 范围内取随机整数（设其为 $x$），那么：\n\n- 如果 $x$ 不在黑名单中，则直接返回 $x$；\n- 如果 $x$ 在黑名单中，则返回 $x$ 映射到 $[n-m,n)$ 范围内的白名单数。\n\n我们可以在初始化时，构建一个从 $[0,n-m)$ 范围内的黑名单数到 $[n-m,n)$ 的白名单数的映射：\n\n1. 将 $[n-m,n)$ 范围内的黑名单数存入一个哈希集合 $\\textit{black}$；\n2. 初始化白名单数 $\\textit{w}=n-m$；\n3. 对于每个 $[0,n-m)$ 范围内的黑名单数 $b$，首先不断增加 $\\textit{w}$ 直至其不在黑名单中，然后将 $b$ 映射到 $\\textit{w}$ 上，并将 $\\textit{w}$ 增加一。\n\n```Python [sol1-Python3]\nclass Solution:\n    def __init__(self, n: int, blacklist: List[int]):\n        m = len(blacklist)\n        self.bound = w = n - m\n        black = {b for b in blacklist if b >= self.bound}\n        self.b2w = {}\n        for b in blacklist:\n            if b < self.bound:\n                while w in black:\n                    w += 1\n                self.b2w[b] = w\n                w += 1\n\n    def pick(self) -> int:\n        x = randrange(self.bound)\n        return self.b2w.get(x, x)\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    unordered_map<int, int> b2w;\n    int bound;\n\npublic:\n    Solution(int n, vector<int> &blacklist) {\n        int m = blacklist.size();\n        bound = n - m;\n        unordered_set<int> black;\n        for (int b: blacklist) {\n            if (b >= bound) {\n                black.emplace(b);\n            }\n        }\n\n        int w = bound;\n        for (int b: blacklist) {\n            if (b < bound) {\n                while (black.count(w)) {\n                    ++w;\n                }\n                b2w[b] = w++;\n            }\n        }\n    }\n\n    int pick() {\n        int x = rand() % bound;\n        return b2w.count(x) ? b2w[x] : x;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    Map<Integer, Integer> b2w;\n    Random random;\n    int bound;\n\n    public Solution(int n, int[] blacklist) {\n        b2w = new HashMap<Integer, Integer>();\n        random = new Random();\n        int m = blacklist.length;\n        bound = n - m;\n        Set<Integer> black = new HashSet<Integer>();\n        for (int b : blacklist) {\n            if (b >= bound) {\n                black.add(b);\n            }\n        }\n\n        int w = bound;\n        for (int b : blacklist) {\n            if (b < bound) {\n                while (black.contains(w)) {\n                    ++w;\n                }\n                b2w.put(b, w);\n                ++w;\n            }\n        }\n    }\n\n    public int pick() {\n        int x = random.nextInt(bound);\n        return b2w.getOrDefault(x, x);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    Dictionary<int, int> b2w;\n    Random random;\n    int bound;\n\n    public Solution(int n, int[] blacklist) {\n        b2w = new Dictionary<int, int>();\n        random = new Random();\n        int m = blacklist.Length;\n        bound = n - m;\n        ISet<int> black = new HashSet<int>();\n        foreach (int b in blacklist) {\n            if (b >= bound) {\n                black.Add(b);\n            }\n        }\n\n        int w = bound;\n        foreach (int b in blacklist) {\n            if (b < bound) {\n                while (black.Contains(w)) {\n                    ++w;\n                }\n                b2w.Add(b, w);\n                ++w;\n            }\n        }\n    }\n\n    public int Pick() {\n        int x = random.Next(bound);\n        return b2w.ContainsKey(x) ? b2w[x] : x;\n    }\n}\n```\n\n```go [sol1-Golang]\ntype Solution struct {\n    b2w   map[int]int\n    bound int\n}\n\nfunc Constructor(n int, blacklist []int) Solution {\n    m := len(blacklist)\n    bound := n - m\n    black := map[int]bool{}\n    for _, b := range blacklist {\n        if b >= bound {\n            black[b] = true\n        }\n    }\n\n    b2w := make(map[int]int, m-len(black))\n    w := bound\n    for _, b := range blacklist {\n        if b < bound {\n            for black[w] {\n                w++\n            }\n            b2w[b] = w\n            w++\n        }\n    }\n    return Solution{b2w, bound}\n}\n\nfunc (s *Solution) Pick() int {\n    x := rand.Intn(s.bound)\n    if s.b2w[x] > 0 {\n        return s.b2w[x]\n    }\n    return x\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} HashItem;\n\ntypedef struct {\n    HashItem *b2w;\n    int bound;\n} Solution;\n\nSolution* solutionCreate(int n, int* blacklist, int blacklistSize) {\n    Solution *obj = (Solution *)malloc(sizeof(Solution));\n    obj->b2w = NULL;\n    obj->bound = n - blacklistSize;\n    HashItem *black = NULL;\n    for (int i = 0; i < blacklistSize; i++) {\n        int b = blacklist[i];\n        if (b >= obj->bound) {\n            HashItem *pEntry = NULL;\n            HASH_FIND_INT(black, &b, pEntry);\n            if (NULL == pEntry) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                pEntry->key = b;\n                pEntry->val = 0;\n                HASH_ADD_INT(black, key, pEntry);\n            }\n        }\n    }\n    int w = obj->bound;\n    for (int i = 0; i < blacklistSize; i++) {\n        int b = blacklist[i];\n        if (b < obj->bound) {\n            HashItem *pEntry = NULL;\n            do {\n                pEntry = NULL;\n                HASH_FIND_INT(black, &w, pEntry);\n                if (pEntry) {\n                    ++w;\n                }\n            } while(pEntry);\n            pEntry = NULL;\n            HASH_FIND_INT(obj->b2w, &b, pEntry);\n            if (pEntry == NULL) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                pEntry->key = b;\n                HASH_ADD_INT(obj->b2w, key, pEntry);\n            } \n            pEntry->val = w++;\n        }\n    }\n    HashItem *curr, *tmp;\n    HASH_ITER(hh, black, curr, tmp) {\n        HASH_DEL(black, curr); \n        free(curr);        \n    }\n    return obj;\n}\n\nint solutionPick(Solution* obj) {\n    int x = rand() % obj->bound;\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(obj->b2w, &x, pEntry);\n    return pEntry != NULL ? pEntry->val : x;\n}\n\nvoid solutionFree(Solution* obj) {\n    HashItem *curr, *tmp;\n    HASH_ITER(hh, obj->b2w, curr, tmp) {\n        HASH_DEL(obj->b2w, curr);  \n        free(curr);        \n    }\n    free(obj);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar Solution = function(n, blacklist) {\n    this.b2w = new Map();\n    const m = blacklist.length;\n    this.bound = n - m;\n    const black = new Set();\n    for (const b of blacklist) {\n        if (b >= this.bound) {\n            black.add(b);\n        }\n    }\n\n    let w = this.bound;\n    for (const b of blacklist) {\n        if (b < this.bound) {\n            while (black.has(w)) {\n                ++w;\n            }\n            this.b2w.set(b, w);\n            ++w;\n        }\n    }\n};\n\nSolution.prototype.pick = function() {\n    const x = Math.floor(Math.random() * this.bound);\n    return this.b2w.get(x) || x;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化为 $O(m)$，$\\text{pick()}$ 为 $O(1)$，其中 $m$ 是数组 $\\textit{blacklist}$ 的长度。在初始化结束时，$[n-m,n)$ 内的每个数字要么是黑名单数，要么被一个黑名单数所映射，因此 $\\textit{white}$ 会恰好增加 $m$ 次，因此初始化的时间复杂度为 $O(m)$。\n\n- 空间复杂度：$O(m)$。哈希表需要 $O(m)$ 的空间。"
}