{
	"titleSlug": "fibonacci-number",
	"slug": "fei-bo-na-qi-shu-by-leetcode-solution-o4ze",
	"url": "https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/",
	"content": "#### 方法一：动态规划\n\n斐波那契数的边界条件是 $F(0)=0$ 和 $F(1)=1$。当 $n>1$ 时，每一项的和都等于前两项的和，因此有如下递推关系：\n\n$$F(n)=F(n-1)+F(n-2)$$\n\n由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 $F(0)$ 和 $F(1)$。\n\n根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 $O(n)$ 的实现。由于 $F(n)$ 只和 $F(n-1)$ 与 $F(n-2)$ 有关，因此可以使用「滚动数组思想」把空间复杂度优化成 $O(1)$。**如下的代码中给出的就是这种实现。**\n\n![fig1](https://assets.leetcode-cn.com/solution-static/509/509_fig1.gif)\n\n```Java [sol1-Java]\nclass Solution {\n    public int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        int p = 0, q = 0, r = 1;\n        for (int i = 2; i <= n; ++i) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        int p = 0, q = 0, r = 1;\n        for (int i = 2; i <= n; ++i) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n};\n```\n\n```JavaScript [sol1-JavaScript]\nvar fib = function(n) {\n    if (n < 2) {\n        return n;\n    }\n    let p = 0, q = 0, r = 1;\n    for (let i = 2; i <= n; i++) {\n        p = q;\n        q = r;\n        r = p + q;\n    }\n    return r;\n};\n```\n\n```go [sol1-Golang]\nfunc fib(n int) int {\n    if n < 2 {\n        return n\n    }\n    p, q, r := 0, 0, 1\n    for i := 2; i <= n; i++ {\n        p = q\n        q = r\n        r = p + q\n    }\n    return r\n}\n```\n\n```C [sol1-C]\nint fib(int n) {\n    if (n < 2) {\n        return n;\n    }\n    int p = 0, q = 0, r = 1;\n    for (int i = 2; i <= n; ++i) {\n        p = q;\n        q = r;\n        r = p + q;\n    }\n    return r;\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n < 2:\n            return n\n        \n        p, q, r = 0, 0, 1\n        for i in range(2, n + 1):\n            p, q = q, r\n            r = p + q\n        \n        return r\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：矩阵快速幂\n\n方法一的时间复杂度是 $O(n)$。使用矩阵快速幂的方法可以降低时间复杂度。\n\n首先我们可以构建这样一个递推关系：\n\n$$\n\\left[\n\\begin{matrix}\n    1 & 1 \\\\\n    1 & 0\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n    F(n)\\\\\n    F(n - 1)\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n    F(n) + F(n - 1)\\\\\n    F(n)\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n    F(n + 1)\\\\\n    F(n)\n\\end{matrix}\n\\right]\n$$\n\n因此：\n\n$$\n\\left[\n\\begin{matrix}\n    F(n + 1)\\\\\n    F(n)\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n    1 & 1 \\\\\n    1 & 0\n\\end{matrix}\n\\right] ^n\n\\left[\n\\begin{matrix}\n    F(1)\\\\\n    F(0)\n\\end{matrix}\n\\right]\n$$\n令：\n$$\nM = \\left[\n\\begin{matrix}\n    1 & 1 \\\\\n    1 & 0\n\\end{matrix}\n\\right]\n$$\n\n因此只要我们能快速计算矩阵 $M$ 的 $n$ 次幂，就可以得到 $F(n)$ 的值。如果直接求取 $M^n$，时间复杂度是 $O(n)$，可以定义矩阵乘法，然后用快速幂算法来加速这里 $M^n$ 的求取。\n\n```Java [sol2-Java]\nclass Solution {\n    public int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        int[][] q = {{1, 1}, {1, 0}};\n        int[][] res = pow(q, n - 1);\n        return res[0][0];\n    }\n\n    public int[][] pow(int[][] a, int n) {\n        int[][] ret = {{1, 0}, {0, 1}};\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ret = multiply(ret, a);\n            }\n            n >>= 1;\n            a = multiply(a, a);\n        }\n        return ret;\n    }\n\n    public int[][] multiply(int[][] a, int[][] b) {\n        int[][] c = new int[2][2];\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n            }\n        }\n        return c;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        vector<vector<int>> q{{1, 1}, {1, 0}};\n        vector<vector<int>> res = matrix_pow(q, n - 1);\n        return res[0][0];\n    }\n\n    vector<vector<int>> matrix_pow(vector<vector<int>>& a, int n) {\n        vector<vector<int>> ret{{1, 0}, {0, 1}};\n        while (n > 0) {\n            if (n & 1) {\n                ret = matrix_multiply(ret, a);\n            }\n            n >>= 1;\n            a = matrix_multiply(a, a);\n        }\n        return ret;\n    }\n\n    vector<vector<int>> matrix_multiply(vector<vector<int>>& a, vector<vector<int>>& b) {\n        vector<vector<int>> c{{0, 0}, {0, 0}};\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n            }\n        }\n        return c;\n    }\n};\n```\n\n```JavaScript [sol2-JavaScript]\nvar fib = function(n) {\n    if (n < 2) {\n        return n;\n    }\n    const q = [[1, 1], [1, 0]];\n    const res = pow(q, n - 1);\n    return res[0][0];\n};\n\nconst pow = (a, n) => {\n    let ret = [[1, 0], [0, 1]];\n    while (n > 0) {\n        if ((n & 1) === 1) {\n            ret = multiply(ret, a);\n        }\n        n >>= 1;\n        a = multiply(a, a);\n    }\n    return ret;\n}\n\nconst multiply = (a, b) => {\n    const c = new Array(2).fill(0).map(() => new Array(2).fill(0));\n    for (let i = 0; i < 2; i++) {\n        for (let j = 0; j < 2; j++) {\n            c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n        }\n    }\n    return c;\n}\n```\n\n```go [sol2-Golang]\ntype matrix [2][2]int\n\nfunc multiply(a, b matrix) (c matrix) {\n    for i := 0; i < 2; i++ {\n        for j := 0; j < 2; j++ {\n            c[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j]\n        }\n    }\n    return\n}\n\nfunc pow(a matrix, n int) matrix {\n    ret := matrix{{1, 0}, {0, 1}}\n    for ; n > 0; n >>= 1 {\n        if n&1 == 1 {\n            ret = multiply(ret, a)\n        }\n        a = multiply(a, a)\n    }\n    return ret\n}\n\nfunc fib(n int) int {\n    if n < 2 {\n        return n\n    }\n    res := pow(matrix{{1, 1}, {1, 0}}, n-1)\n    return res[0][0]\n}\n```\n\n```C [sol2-C]\nstruct Matrix {\n    int mat[2][2];\n};\n\nstruct Matrix matrixMultiply(struct Matrix* a, struct Matrix* b) {\n    struct Matrix c;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            c.mat[i][j] = (*a).mat[i][0] * (*b).mat[0][j] + (*a).mat[i][1] * (*b).mat[1][j];\n        }\n    }\n    return c;\n}\n\nstruct Matrix matrixPow(struct Matrix a, int n) {\n    struct Matrix ret;\n    ret.mat[0][0] = ret.mat[1][1] = 1;\n    ret.mat[0][1] = ret.mat[1][0] = 0;\n    while (n > 0) {\n        if (n & 1) {\n            ret = matrixMultiply(&ret, &a);\n        }\n        n >>= 1;\n        a = matrixMultiply(&a, &a);\n    }\n    return ret;\n}\n\nint fib(int n) {\n    if (n < 2) {\n        return n;\n    }\n    struct Matrix q;\n    q.mat[0][0] = q.mat[0][1] = q.mat[1][0] = 1;\n    q.mat[1][1] = 0;\n    struct Matrix res = matrixPow(q, n - 1);\n    return res.mat[0][0];\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n < 2:\n            return n\n        \n        q = [[1, 1], [1, 0]]\n        res = self.matrix_pow(q, n - 1)\n        return res[0][0]\n    \n    def matrix_pow(self, a: List[List[int]], n: int) -> List[List[int]]:\n        ret = [[1, 0], [0, 1]]\n        while n > 0:\n            if n & 1:\n                ret = self.matrix_multiply(ret, a)\n            n >>= 1\n            a = self.matrix_multiply(a, a)\n        return ret\n\n    def matrix_multiply(self, a: List[List[int]], b: List[List[int]]) -> List[List[int]]:\n        c = [[0, 0], [0, 0]]\n        for i in range(2):\n            for j in range(2):\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]\n        return c\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法三：通项公式\n\n斐波那契数 $F(n)$ 是齐次线性递推，根据递推方程 $F(n)=F(n-1)+F(n-2)$，可以写出这样的特征方程：\n\n$$x^2=x+1$$\n\n求得 $x_1 = \\frac{1+\\sqrt{5}}{2}$，$x_2 = \\frac{1-\\sqrt{5}}{2}$。设通解为 $F(n)=c_1x_1^n+c_2x_2^n$，代入初始条件 $F(0)=0$，$F(1)=1$，得 $c_1=\\frac{1}{\\sqrt{5}}$，$c_2=-\\frac{1}{\\sqrt{5}}$。因此斐波那契数的通项公式如下：\n\n$$F(n)=\\frac{1}{\\sqrt{5}}\\left[ \\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n} - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n} \\right]$$\n\n得到通项公式之后，就可以通过公式直接求解第 $n$ 项。\n\n```Java [sol3-Java]\nclass Solution {\n    public int fib(int n) {\n        double sqrt5 = Math.sqrt(5);\n        double fibN = Math.pow((1 + sqrt5) / 2, n) - Math.pow((1 - sqrt5) / 2, n);\n        return (int) Math.round(fibN / sqrt5);\n    }\n}\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int fib(int n) {\n        double sqrt5 = sqrt(5);\n        double fibN = pow((1 + sqrt5) / 2, n) - pow((1 - sqrt5) / 2, n);\n        return round(fibN / sqrt5);\n    }\n};\n```\n\n```JavaScript [sol3-JavaScript]\nvar fib = function(n) {\n    const sqrt5 = Math.sqrt(5);\n    const fibN = Math.pow((1 + sqrt5) / 2, n) - Math.pow((1 - sqrt5) / 2, n);\n    return Math.round(fibN / sqrt5);\n};\n```\n\n```go [sol3-Golang]\nfunc fib(n int) int {\n    sqrt5 := math.Sqrt(5)\n    p1 := math.Pow((1+sqrt5)/2, float64(n))\n    p2 := math.Pow((1-sqrt5)/2, float64(n))\n    return int(math.Round((p1 - p2) / sqrt5))\n}\n```\n\n```C [sol3-C]\nint fib(int n) {\n    double sqrt5 = sqrt(5);\n    double fibN = pow((1 + sqrt5) / 2, n) - pow((1 - sqrt5) / 2, n);\n    return round(fibN / sqrt5);\n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def fib(self, n: int) -> int:\n        sqrt5 = 5**0.5\n        fibN = ((1 + sqrt5) / 2) ** n - ((1 - sqrt5) / 2) ** n\n        return round(fibN / sqrt5)\n```\n\n**复杂度分析**\n\n代码中使用的 $\\texttt{pow}$ 函数的时空复杂度与 CPU 支持的指令集相关，这里不深入分析。"
}