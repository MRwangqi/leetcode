{
	"titleSlug": "convert-to-base-2",
	"slug": "daydayuppp-jian-dan-de-zhi-guan-mo-ni-by-g2y2",
	"url": "https://leetcode-cn.com/problems/convert-to-base-2/solution/daydayuppp-jian-dan-de-zhi-guan-mo-ni-by-g2y2/",
	"content": "> Problem: [1017. 负二进制转换](https://leetcode.cn/problems/convert-to-base-2/description/)\n\n[TOC]\n\n# 思路\n\n对于「负二进制数」很直观的一个发现就是：\n\n- $2 \\times (-2)^i = (-2) ^ {i + 1} + (-2)^{i + 2}$。\n- $2^i = (-2)^{i} + (-2)^{i + 1}$，当 $i$ 为奇数时。\n\n那么我们用 $h[i]$ 表示 $n$ 需要的 $(-2) ^ i$ 的个数，那么对 $n$ 原二进制数进行分析，如果第 $i$ 位为 $1$：\n\n- 如果 $i$ 为偶数：$h[i]=h[i] + 1$。\n- 如果 $i$ 为奇数，那么可以用 $h[i] + h[i + 1] = (-2)^i + (-2)^{i+1} = -(-2)^i = 2^i$ 来表示： $h[i] = h[i] + 1 , h[i + 1] = h[i + 1] + 1$。\n\n```cpp\nfor (int i = 0; i < 31; ++i) {\n    if (n >> i & 1) {\n        ++ h[i];\n        if (i & 1) ++ h[i + 1];\n    }\n}\n```\n\n然后我们从 $0$ 往后去将每一个 $h[i]$ 给减小到 $<2$ 即可，如果 $h[i] \\ge 2$：\n\n- $h[i + 1] > 0$ 那么前者 $2$ 份可以和后者 $1$ 份相互抵消。\n- 否则每两份 $h[i]$ 可以由 $h[i + 1]$ 和 $h[i + 2]$ 构成。\n\n```cpp\nfor (int i = 0; i < 40; ++i) {\n    if (h[i] > 1 && h[i + 1]) {\n        int sub = min(h[i] / 2, h[i + 1]);\n        h[i] -= sub * 2;\n        h[i + 1] -= sub;\n    }\n    if (h[i] / 2) h[i + 1] += h[i] / 2, h[i + 2] += h[i] / 2;\n    h[i] &= 1;\n}\n```\n\n最后将 $h[]$ 用字符串的形式表示出来即可，注意需要去掉前导零。\n\n具体看代码实现即可，有任何疑问欢迎评论区指出 🍬\n\n# 复杂度\n- 时间复杂度: $O(C)$ 和位数总数有关。\n\n- 空间复杂度: $O(C)$ 和位数总数有关，主要用于存储每一位需要的个数。\n\n# Code\n```C++\nclass Solution {\npublic:\n    string baseNeg2(int n) {\n        if (!n) return \"0\";\n        vector<int> h(40, 0);\n        for (int i = 0; i < 31; ++i) {\n            if (n >> i & 1) {\n                ++ h[i];\n                if (i & 1) ++ h[i + 1];\n            }\n        }\n        for (int i = 0; i < 40; ++i) {\n            if (h[i] > 1 && h[i + 1]) {\n                int sub = min(h[i] / 2, h[i + 1]);\n                h[i] -= sub * 2;\n                h[i + 1] -= sub;\n            }\n            if (h[i] / 2) h[i + 1] += h[i] / 2, h[i + 2] += h[i] / 2;\n            h[i] &= 1;\n        }\n        int l = 39;\n        while (!h[l]) -- l; // 去掉前导零\n        string res = \"\";\n        while (l >= 0) {\n            if (h[l]) res += '1';\n            else res += '0';\n            -- l;\n        }\n        return res;\n    }\n};\n```\n"
}