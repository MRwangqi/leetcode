{
	"titleSlug": "number-of-ways-to-arrive-at-destination",
	"slug": "by-masx200-31se",
	"url": "https://leetcode-cn.com/problems/number-of-ways-to-arrive-at-destination/solution/by-masx200-31se/",
	"content": "### 解题思路\n广度优先搜索+优先级队列+动态规划\n实现Dijkstra\nhttps://www.npmjs.com/package/@datastructures-js/heap\n### 代码\n\n```typescript\n\nfunction countPaths(n: number, roads: number[][]): number {\n    const mod = 10 ** 9 + 7;\n    const map: [number, number][][] = Array(n)\n        .fill(0)\n        .map(() => []);\n\n    for (const [u, v, t] of roads) {\n        map[u].push([v, t]);\n        map[v].push([u, t]);\n    }\n    const dis: number[] = new Array(n).fill(Infinity);\n    dis[0] = 0;\n    const count: number[] = new Array(n).fill(0);\n    count[0] = 1;\n    const seen: boolean[] = new Array(n).fill(false);\n    //@ts-ignore\n    const pq = new Heap<[number, number]>((a, b) => a[1] - b[1]);\n    pq.insert([0, 0]);\n    while (pq.size()) {\n        const now = pq.pop()[0];\n        if (seen[now]) continue;\n        seen[now] = true;\n\n        for (const [end, time] of map[now]) {\n            if (dis[now] + time < dis[end]) {\n                dis[end] = dis[now] + time;\n\n                count[end] = count[now];\n                pq.push([end, dis[end]]);\n            } else if (dis[now] + time === dis[end]) {\n                count[end] = (count[end] + count[now]) % mod;\n            }\n        }\n    }\n    return count[n - 1];\n}\n\n //@ts-ignore\nvar t,e,i=Object.create,s=Object.defineProperty,r=Object.getOwnPropertyDescriptor,h=Object.getOwnPropertyNames,o=Object.getPrototypeOf,a=Object.prototype.hasOwnProperty,n=(t=t=>{var e=class{constructor(t,e,i){if(\"function\"!=typeof t)throw new Error(\"Heap constructor expects a compare function\");this._compare=t,this._nodes=Array.isArray(e)?e:[],this._leaf=i||null}_hasLeftChild(t){return 2*t+1<this.size()}_hasRightChild(t){return 2*t+2<this.size()}_compareAt(t,e){return this._compare(this._nodes[t],this._nodes[e])}_swap(t,e){let i=this._nodes[t];this._nodes[t]=this._nodes[e],this._nodes[e]=i}_shouldSwap(t,e){return!(t<0||t>=this.size()||e<0||e>=this.size())&&this._compareAt(t,e)>0}_compareChildrenOf(t){if(!this._hasLeftChild(t)&&!this._hasRightChild(t))return-1;let e=2*t+1,i=2*t+2;return this._hasLeftChild(t)?this._hasRightChild(t)&&this._compareAt(e,i)>0?i:e:i}_compareChildrenBefore(t,e,i){return this._compareAt(i,e)<=0&&i<t?i:e}_heapifyUp(t){let e=t,i=Math.floor((e-1)/2);for(;this._shouldSwap(i,e);)this._swap(i,e),e=i,i=Math.floor((e-1)/2)}_heapifyDown(t){let e=t,i=this._compareChildrenOf(e);for(;this._shouldSwap(e,i);)this._swap(e,i),e=i,i=this._compareChildrenOf(e)}_heapifyDownUntil(t){let e,i=0,s=1,r=2;for(;s<t;)e=this._compareChildrenBefore(t,s,r),this._shouldSwap(i,e)&&this._swap(i,e),i=e,s=2*i+1,r=2*i+2}insert(t){return this._nodes.push(t),this._heapifyUp(this.size()-1),(null===this._leaf||this._compare(t,this._leaf)>0)&&(this._leaf=t),this}push(t){return this.insert(t)}extractRoot(){if(this.isEmpty())return null;let t=this.root();return this._nodes[0]=this._nodes[this.size()-1],this._nodes.pop(),this._heapifyDown(0),t===this._leaf&&(this._leaf=this.root()),t}pop(){return this.extractRoot()}sort(){for(let t=this.size()-1;t>0;t-=1)this._swap(0,t),this._heapifyDownUntil(t);return this._nodes}fix(){for(let t=Math.floor(this.size()/2)-1;t>=0;t-=1)this._heapifyDown(t);return this}isValid(){let t=e=>{let i=!0,s=!0;if(this._hasLeftChild(e)){let s=2*e+1;if(this._compareAt(e,s)>0)return!1;i=t(s)}if(this._hasRightChild(e)){let i=2*e+2;if(this._compareAt(e,i)>0)return!1;s=t(i)}return i&&s};return t(0)}clone(){return new e(this._compare,this._nodes.slice(),this._leaf)}root(){return this.isEmpty()?null:this._nodes[0]}top(){return this.root()}leaf(){return this._leaf}size(){return this._nodes.length}isEmpty(){return 0===this.size()}clear(){this._nodes=[],this._leaf=null}static heapify(t,i){if(!Array.isArray(t))throw new Error(\"Heap.heapify expects an array of values\");if(\"function\"!=typeof i)throw new Error(\"Heap.heapify expects a compare function\");return new e(i,t).fix()}static isHeapified(t,i){return new e(i,t).isValid()}};t.Heap=e},()=>(e||t((e={exports:{}}).exports,e),e.exports)),l=((t,e,n)=>(n=null!=t?i(o(t)):{},((t,e,i,o)=>{if(e&&\"object\"==typeof e||\"function\"==typeof e)for(let n of h(e))!a.call(t,n)&&n!==i&&s(t,n,{get:()=>e[n],enumerable:!(o=r(e,n))||o.enumerable});return t})(!e&&t&&t.__esModule?n:s(n,\"default\",{value:t,enumerable:!0}),t)))(n()),{Heap:p}=l,{default:f,..._}=l; const Heap=p;\n\n```"
}