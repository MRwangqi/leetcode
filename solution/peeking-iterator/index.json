{
	"titleSlug": "peeking-iterator",
	"slug": "ding-duan-die-dai-qi-by-leetcode-solutio-8toa",
	"url": "https://leetcode-cn.com/problems/peeking-iterator/solution/ding-duan-die-dai-qi-by-leetcode-solutio-8toa/",
	"content": "#### 方法一：迭代器\n\n最直观的做法是使用一个列表存储迭代器中的每个元素，然后按顺序遍历列表中的元素模拟迭代器，但是该做法没有利用到迭代器的性质，更好的做法是利用迭代器的性质实现顶端迭代器的操作。\n\n顶端迭代器需要实现以下三种操作：\n\n- $\\texttt{next}$：返回迭代器的下一个元素，并将指针向后移动一位；\n\n- $\\texttt{hasNext}$：判断迭代器中是否还有剩余的元素；\n\n- $\\texttt{peek}$：返回迭代器的下一个元素，不改变指针。\n\n每种编程语言自带的迭代器可能支持上述一种或多种操作，但是不一定支持上述全部操作。如果编程语言自带的迭代器本身就支持上述操作，可以直接使用，否则需要自定义实现。\n\n$\\texttt{Java}$ 的 $\\texttt{Iterator}$ 接口和 $\\texttt{JavaScript}$ 中自定义的 $\\texttt{Iterator}$ 接口支持 $\\texttt{next}$ 和 $\\texttt{hasNext}$ 操作，但是不支持 $\\texttt{peek}$ 操作。为了在顶端迭代器中支持 $\\texttt{peek}$ 操作，需要使用 $\\textit{nextElement}$ 存储迭代器的下一个元素，各项操作的实现如下：\n\n- $\\texttt{next}$：首先用 $\\textit{ret}$ 存储 $\\textit{nextElement}$ 表示返回值，然后将 $\\textit{nextElement}$ 向后移动一位，最后返回 $\\textit{ret}$；\n\n- $\\texttt{hasNext}$：由于 $\\textit{nextElement}$ 为迭代器的下一个元素，因此当 $\\textit{nextElement}$ 不为空时返回 $\\text{true}$，否则返回 $\\text{false}$；\n\n- $\\texttt{peek}$：由于 $\\texttt{peek}$ 操作不改变指针，因此返回 $\\textit{nextElement}$。\n\n$\\texttt{C\\#}$ 的 $\\texttt{IEnumerator}$ 接口包含属性 $\\textit{Current}$ 和方法 $\\textit{MoveNext}$（该方法的返回值类型是 $\\texttt{bool}$，表示是否成功移动到下一个元素），三种操作都需要自定义实现，需要使用 $\\textit{flag}$ 存储迭代器是否还有剩余的元素。\n\n- $\\texttt{next}$：首先用 $\\textit{ret}$ 存储 $\\textit{iterator}.\\textit{Current}$ 表示返回值，然后对 $\\textit{iterator}$ 调用 $\\textit{MoveNext}$ 方法使其向后移动一位并将该方法的结果赋值给 $\\textit{flag}$，最后返回 $\\textit{ret}$；\n\n- $\\texttt{hasNext}$：返回 $\\text{flag}$；\n\n- $\\texttt{peek}$：由于 $\\texttt{peek}$ 操作不改变指针，因此返回 $\\textit{iterator}.\\textit{Current}$。\n\n$\\texttt{C++}$ 中 $\\texttt{PeekingIterator}$ 继承父类 $\\texttt{Iterator}$，$\\texttt{Iterator}$ 已经实现方法 $\\texttt{next}$ 和 $\\texttt{hasNext}$，在此我们在 $\\texttt{PeekingIterator}$ 中主要实现 $\\texttt{peek}$ 方法即可。我们使用 $\\textit{flag}$ 标记迭代器是否还有剩余元素，使用 $\\textit{nextElement}$ 存储迭代器的下一个元素。\n\n- $\\texttt{next}$：首先用 $\\textit{ret}$ 存储 $\\textit{nextElement}$ 表示返回值，$\\textit{flag}$ 保存 $\\texttt{Iterator}$ 调用 $\\texttt{hasNext}$方法的返回结果，然后将 $\\textit{nextElement}$ 向后移动一位，最后返回 $\\textit{ret}$；\n\n- $\\texttt{hasNext}$：返回 $\\text{flag}$；\n\n- $\\texttt{peek}$：由于 $\\texttt{peek}$ 操作不改变指针，因此返回 $\\textit{nextElement}$。\n\n```Java [sol1-Java]\nclass PeekingIterator implements Iterator<Integer> {\n    private Iterator<Integer> iterator;\n    private Integer nextElement;\n\n    public PeekingIterator(Iterator<Integer> iterator) {\n        this.iterator = iterator;\n        nextElement = iterator.next();\n    }\n    \n    public Integer peek() {\n        return nextElement;\n    }\n    \n    @Override\n    public Integer next() {\n        Integer ret = nextElement;\n        nextElement = iterator.hasNext() ? iterator.next() : null;\n        return ret;\n    }\n    \n    @Override\n    public boolean hasNext() {\n        return nextElement != null;\n    }\n}\n```\n\n```C# [sol1-C#]\nclass PeekingIterator {\n    private IEnumerator<int> iterator;\n    private bool flag;\n\n    public PeekingIterator(IEnumerator<int> iterator) {\n        this.iterator = iterator;\n        flag = true;\n    }\n    \n    public int Peek() {\n        return iterator.Current;\n    }\n    \n    public int Next() {\n        int ret = iterator.Current;\n        flag = iterator.MoveNext();\n        return ret;\n    }\n    \n    public bool HasNext() {\n        return flag;\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar PeekingIterator = function(iterator) {\n    this.iterator = iterator;\n    this.nextElement = this.iterator.next();\n};\n\nPeekingIterator.prototype.peek = function() {\n    return this.nextElement;\n    \n};\n\nPeekingIterator.prototype.next = function() {\n    const ret = this.nextElement;\n    this.nextElement = this.iterator.hasNext() ? this.iterator.next() : null;\n    return ret;\n};\n\nPeekingIterator.prototype.hasNext = function() {\n    return this.nextElement != null;\n};\n```\n\n```C++ [sol1-C++]\nclass PeekingIterator : public Iterator {\npublic:\n    PeekingIterator(const vector<int>& nums) : Iterator(nums) {\n        flag = Iterator::hasNext();\n        if (flag) {\n            nextElement = Iterator::next();\n        }\n    }\n    \n    int peek() {\n        return nextElement;\n    }\n    \n    int next() {\n        int ret = nextElement;\n        flag = Iterator::hasNext();\n        if (flag) {\n            nextElement = Iterator::next();\n        }\n        return ret;\n    }\n    \n    bool hasNext() const {\n        return flag;\n    }\nprivate:\n    int nextElement;\n    bool flag;\n};\n```\n\n```go [sol1-Golang]\ntype PeekingIterator struct {\n    iter     *Iterator\n    _hasNext bool\n    _next    int\n}\n\nfunc Constructor(iter *Iterator) *PeekingIterator {\n    return &PeekingIterator{iter, iter.hasNext(), iter.next()}\n}\n\nfunc (it *PeekingIterator) hasNext() bool {\n    return it._hasNext\n}\n\nfunc (it *PeekingIterator) next() int {\n    ret := it._next\n    it._hasNext = it.iter.hasNext()\n    if it._hasNext {\n        it._next = it.iter.next()\n    }\n    return ret\n}\n\nfunc (it *PeekingIterator) peek() int {\n    return it._next\n}\n```\n\n```Python [sol1-Python3]\nclass PeekingIterator:\n    def __init__(self, iterator):\n        self.iterator = iterator\n        self._next = iterator.next()\n        self._hasNext = iterator.hasNext()\n\n    def peek(self):\n        return self._next\n\n    def next(self):\n        ret = self._next\n        self._hasNext = self.iterator.hasNext()\n        self._next = self.iterator.next() if self._hasNext else 0\n        return ret\n\n    def hasNext(self):\n        return self._hasNext\n```\n\n**复杂度分析**\n\n- 时间复杂度：每一项操作的时间复杂度都是 $O(1)$。\n\n- 空间复杂度：$O(1)$。\n\n#### 进阶问题\n\n进阶问题要求拓展顶端迭代器的设计，使其适用于所有类型，不局限于整数。\n\n对于动态类型语言如 $\\texttt{JavaScript}$ 和 $\\texttt{Python}$，不需要拓展上述设计。\n\n对于静态类型语言如 $\\texttt{Java}$、$\\texttt{C\\#}$ 和 $\\texttt{C++}$，可以通过使用泛型的方式拓展设计，在 $\\texttt{PeekingIterator}$ 类中定义泛型，使用时可以用任意类型。\n\n```Java [sol2-Java]\nclass PeekingIterator<E> implements Iterator<E> {\n    private Iterator<E> iterator;\n    private E nextElement;\n\n    public PeekingIterator(Iterator<E> iterator) {\n        this.iterator = iterator;\n        nextElement = iterator.next();\n    }\n    \n    public E peek() {\n        return nextElement;\n    }\n    \n    @Override\n    public E next() {\n        E ret = nextElement;\n        nextElement = iterator.hasNext() ? iterator.next() : null;\n        return ret;\n    }\n    \n    @Override\n    public boolean hasNext() {\n        return nextElement != null;\n    }\n}\n```\n\n```C# [sol2-C#]\nclass PeekingIterator<T> {\n    private IEnumerator<T> iterator;\n    private bool flag;\n\n    public PeekingIterator(IEnumerator<T> iterator) {\n        this.iterator = iterator;\n        flag = true;\n    }\n    \n    public T Peek() {\n        return iterator.Current;\n    }\n    \n    public T Next() {\n        T ret = iterator.Current;\n        flag = iterator.MoveNext();\n        return ret;\n    }\n    \n    public bool HasNext() {\n        return flag;\n    }\n}\n```\n\n```C++ [sol2-C++]\ntemplate <class T>\nclass PeekingIterator : public Iterator<T> {\npublic:\n    PeekingIterator(const vector<T>& nums) : Iterator<T>(nums) {\n        flag = Iterator<T>::hasNext();\n        if (flag) {\n            nextElement = Iterator<T>::next();\n        }\n    }\n    \n    T peek() {\n        return nextElement;\n    }\n\n    T next() {\n        T ret = nextElement;\n        flag = Iterator<T>::hasNext();\n        if (flag) {\n            nextElement = Iterator<T>::next();\n        }\n        return ret;\n    }\n    \n    bool hasNext() const {\n        return flag;\n    }\nprivate:\n    T nextElement;\n    bool flag;\n};\n```"
}