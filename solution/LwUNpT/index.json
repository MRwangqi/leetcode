{
	"titleSlug": "LwUNpT",
	"slug": "er-cha-shu-zui-di-ceng-zui-zuo-bian-de-z-0nlm",
	"url": "https://leetcode-cn.com/problems/LwUNpT/solution/er-cha-shu-zui-di-ceng-zui-zuo-bian-de-z-0nlm/",
	"content": "#### 方法一：深度优先搜索\n\n使用 $\\textit{height}$ 记录遍历到的节点的高度，$\\textit{curVal}$ 记录高度在 $\\textit{curHeight}$ 的最左节点的值。在深度优先搜索时，我们先搜索当前节点的左子节点，再搜索当前节点的右子节点，然后判断当前节点的高度 $\\textit{height}$ 是否大于 $\\textit{curHeight}$，如果是，那么将 $\\textit{curVal}$ 设置为当前结点的值，$\\textit{curHeight}$ 设置为 $\\textit{height}$。\n\n> 因为我们先遍历左子树，然后再遍历右子树，所以对同一高度的所有节点，最左节点肯定是最先被遍历到的。\n\n```Python [sol1-Python3]\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        curVal = curHeight = 0\n        def dfs(node: Optional[TreeNode], height: int) -> None:\n            if node is None:\n                return\n            height += 1\n            dfs(node.left, height)\n            dfs(node.right, height)\n            nonlocal curVal, curHeight\n            if height > curHeight:\n                curHeight = height\n                curVal = node.val\n        dfs(root, 0)\n        return curVal\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    void dfs(TreeNode *root, int height, int &curVal, int &curHeight) {\n        if (root == nullptr) {\n            return;\n        }\n        height++;\n        dfs(root->left, height, curVal, curHeight);\n        dfs(root->right, height, curVal, curHeight);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root->val;\n        }\n    }\n\n    int findBottomLeftValue(TreeNode* root) {\n        int curVal, curHeight = 0;\n        dfs(root, 0, curVal, curHeight);\n        return curVal;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    int curVal = 0;\n    int curHeight = 0;\n\n    public int findBottomLeftValue(TreeNode root) {\n        int curHeight = 0;\n        dfs(root, 0);\n        return curVal;\n    }\n\n    public void dfs(TreeNode root, int height) {\n        if (root == null) {\n            return;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    int curVal = 0;\n    int curHeight = 0;\n\n    public int FindBottomLeftValue(TreeNode root) {\n        int curHeight = 0;\n        DFS(root, 0);\n        return curVal;\n    }\n\n    public void DFS(TreeNode root, int height) {\n        if (root == null) {\n            return;\n        }\n        height++;\n        DFS(root.left, height);\n        DFS(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n}\n```\n\n```C [sol1-C]\nvoid dfs(const struct TreeNode *root, int height, int *curVal, int *curHeight) {\n    if (root == NULL) {\n        return;\n    }\n    height++;\n    dfs(root->left, height, curVal, curHeight);\n    dfs(root->right, height, curVal, curHeight);\n    if (height > *curHeight) {\n        *curHeight = height;\n        *curVal = root->val;\n    }\n}\n\nint findBottomLeftValue(struct TreeNode* root){\n    int curVal, curHeight = 0;\n    dfs(root, 0, &curVal, &curHeight);\n    return curVal;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findBottomLeftValue = function(root) {\n    const dfs = (root, height) => {\n        if (!root) {\n            return;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n\n    let curHeight = 0;\n    dfs(root, 0);\n    return curVal;\n};\n```\n\n```go [sol1-Golang]\nfunc findBottomLeftValue(root *TreeNode) (curVal int) {\n    curHeight := 0\n    var dfs func(*TreeNode, int)\n    dfs = func(node *TreeNode, height int) {\n        if node == nil {\n            return\n        }\n        height++\n        dfs(node.Left, height)\n        dfs(node.Right, height)\n        if height > curHeight {\n            curHeight = height\n            curVal = node.Val\n        }\n    }\n    dfs(root, 0)\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数目。需要遍历 $n$ 个节点。\n\n+ 空间复杂度：$O(n)$。递归栈需要占用 $O(n)$ 的空间。\n\n#### 方法二：广度优先搜索\n\n使用广度优先搜索遍历每一层的节点。在遍历一个节点时，需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点。广度优先搜索所遍历的最后一个节点的值就是最底层最左边节点的值。\n\n```Python [sol2-Python3]\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node.right:\n                q.append(node.right)\n            if node.left:\n                q.append(node.left)\n            ans = node.val\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        int ret;\n        queue<TreeNode *> q;\n        q.push(root);\n        while (!q.empty()) {\n            auto p = q.front();\n            q.pop();\n            if (p->right) {\n                q.push(p->right);\n            }\n            if (p->left) {\n                q.push(p->left);\n            }\n            ret = p->val;\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int ret = 0;\n        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode p = queue.poll();\n            if (p.right != null) {\n                queue.offer(p.right);\n            }\n            if (p.left != null) {\n                queue.offer(p.left);\n            }\n            ret = p.val;\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int FindBottomLeftValue(TreeNode root) {\n        int ret = 0;\n        Queue<TreeNode> queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n        while (queue.Count > 0) {\n            TreeNode p = queue.Dequeue();\n            if (p.right != null) {\n                queue.Enqueue(p.right);\n            }\n            if (p.left != null) {\n                queue.Enqueue(p.left);\n            }\n            ret = p.val;\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX_NODE_SIZE 10000\n\nint findBottomLeftValue(struct TreeNode* root){\n    int ret;\n    struct TreeNode** queue = (struct TreeNode **)malloc(sizeof(struct TreeNode) * MAX_NODE_SIZE);\n    int head = 0;\n    int tail = 0;\n    queue[tail++] = root;\n    while (head != tail) {\n        struct TreeNode *p = queue[head++];\n        if (p->right) {\n            queue[tail++] = p->right;\n        }\n        if (p->left) {\n            queue[tail++] = p->left;\n        }\n        ret = p->val;\n    }\n    free(queue);\n    return ret;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar findBottomLeftValue = function(root) {\n    let ret = 0;\n    const queue = [root];\n    while (queue.length) {\n        const p = queue.shift();\n        if (p.right) {\n            queue.push(p.right);\n        }\n        if (p.left) {\n            queue.push(p.left);\n        }\n        ret = p.val;\n    }\n    return ret;\n};\n```\n\n```go [sol2-Golang]\nfunc findBottomLeftValue(root *TreeNode) (ans int) {\n    q := []*TreeNode{root}\n    for len(q) > 0 {\n        node := q[0]\n        q = q[1:]\n        if node.Right != nil {\n            q = append(q, node.Right)\n        }\n        if node.Left != nil {\n            q = append(q, node.Left)\n        }\n        ans = node.Val\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数目。\n\n+ 空间复杂度：$O(n)$。如果二叉树是满完全二叉树，那么队列 $q$ 最多保存 $\\big \\lceil \\dfrac{n}{2} \\big \\rceil$ 个节点。"
}