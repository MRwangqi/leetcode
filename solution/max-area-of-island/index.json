{
	"titleSlug": "max-area-of-island",
	"slug": "dao-yu-de-zui-da-mian-ji-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/",
	"content": "### ðŸ“º è§†é¢‘é¢˜è§£ \n\n![695. å²›å±¿çš„æœ€å¤§é¢ç§¯.mp4](cdafaf78-fdc6-4a70-85dc-a5e9697910b6)\n\n### ðŸ“– æ–‡å­—é¢˜è§£\n\n#### æ–¹æ³•ä¸€ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢\n\n**ç®—æ³•**\n\n- æˆ‘ä»¬æƒ³çŸ¥é“ç½‘æ ¼ä¸­æ¯ä¸ªè¿žé€šå½¢çŠ¶çš„é¢ç§¯ï¼Œç„¶åŽå–æœ€å¤§å€¼ã€‚\n\n- å¦‚æžœæˆ‘ä»¬åœ¨ä¸€ä¸ªåœŸåœ°ä¸Šï¼Œä»¥ $4$ ä¸ªæ–¹å‘æŽ¢ç´¢ä¸Žä¹‹ç›¸è¿žçš„æ¯ä¸€ä¸ªåœŸåœ°ï¼ˆä»¥åŠä¸Žè¿™äº›åœŸåœ°ç›¸è¿žçš„åœŸåœ°ï¼‰ï¼Œé‚£ä¹ˆæŽ¢ç´¢è¿‡çš„åœŸåœ°æ€»æ•°å°†æ˜¯è¯¥è¿žé€šå½¢çŠ¶çš„é¢ç§¯ã€‚\n\n- ä¸ºäº†ç¡®ä¿æ¯ä¸ªåœŸåœ°è®¿é—®ä¸è¶…è¿‡ä¸€æ¬¡ï¼Œæˆ‘ä»¬æ¯æ¬¡ç»è¿‡ä¸€å—åœŸåœ°æ—¶ï¼Œå°†è¿™å—åœŸåœ°çš„å€¼ç½®ä¸º $0$ã€‚è¿™æ ·æˆ‘ä»¬å°±ä¸ä¼šå¤šæ¬¡è®¿é—®åŒä¸€åœŸåœ°ã€‚\n\n```Python [sol1-Python3]\nclass Solution:\n    def dfs(self, grid, cur_i, cur_j) -> int:\n        if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:\n            return 0\n        grid[cur_i][cur_j] = 0\n        ans = 1\n        for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n            next_i, next_j = cur_i + di, cur_j + dj\n            ans += self.dfs(grid, next_i, next_j)\n        return ans\n\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ans = 0\n        for i, l in enumerate(grid):\n            for j, n in enumerate(l):\n                ans = max(self.dfs(grid, i, j), ans)\n        return ans\n\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    int dfs(vector<vector<int>>& grid, int cur_i, int cur_j) {\n        if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) {\n            return 0;\n        }\n        grid[cur_i][cur_j] = 0;\n        int di[4] = {0, 0, 1, -1};\n        int dj[4] = {1, -1, 0, 0};\n        int ans = 1;\n        for (int index = 0; index != 4; ++index) {\n            int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n            ans += dfs(grid, next_i, next_j);\n        }\n        return ans;\n    }\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.size(); ++i) {\n            for (int j = 0; j != grid[0].size(); ++j) {\n                ans = max(ans, dfs(grid, i, j));\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.length; ++i) {\n            for (int j = 0; j != grid[0].length; ++j) {\n                ans = Math.max(ans, dfs(grid, i, j));\n            }\n        }\n        return ans;\n    }\n\n    public int dfs(int[][] grid, int cur_i, int cur_j) {\n        if (cur_i < 0 || cur_j < 0 || cur_i == grid.length || cur_j == grid[0].length || grid[cur_i][cur_j] != 1) {\n            return 0;\n        }\n        grid[cur_i][cur_j] = 0;\n        int[] di = {0, 0, 1, -1};\n        int[] dj = {1, -1, 0, 0};\n        int ans = 1;\n        for (int index = 0; index != 4; ++index) {\n            int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n            ans += dfs(grid, next_i, next_j);\n        }\n        return ans;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æž**\n\n* æ—¶é—´å¤æ‚åº¦ï¼š$O(m \\times n)$ã€‚å…¶ä¸­ $m$ æ˜¯ç»™å®šç½‘æ ¼ä¸­çš„è¡Œæ•°ï¼Œ$n$ æ˜¯åˆ—æ•°ã€‚æˆ‘ä»¬è®¿é—®æ¯ä¸ªç½‘æ ¼æœ€å¤šä¸€æ¬¡ã€‚\n\n* ç©ºé—´å¤æ‚åº¦ï¼š$O(m \\times n)$ï¼Œé€’å½’çš„æ·±åº¦æœ€å¤§å¯èƒ½æ˜¯æ•´ä¸ªç½‘æ ¼çš„å¤§å°ï¼Œå› æ­¤æœ€å¤§å¯èƒ½ä½¿ç”¨ $O(m \\times n)$ çš„æ ˆç©ºé—´ã€‚\n\n#### æ–¹æ³•äºŒï¼šæ·±åº¦ä¼˜å…ˆæœç´¢ + æ ˆ\n\n**ç®—æ³•**\n\næˆ‘ä»¬å¯ä»¥ç”¨æ ˆæ¥å®žçŽ°æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ã€‚è¿™ç§æ–¹æ³•æœ¬è´¨ä¸Žæ–¹æ³•ä¸€ç›¸åŒï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼š\n  \n- æ–¹æ³•ä¸€é€šè¿‡å‡½æ•°çš„è°ƒç”¨æ¥è¡¨ç¤ºæŽ¥ä¸‹æ¥æƒ³è¦éåŽ†å“ªäº›åœŸåœ°ï¼Œè®©ä¸‹ä¸€å±‚å‡½æ•°æ¥è®¿é—®è¿™äº›åœŸåœ°ã€‚è€Œæ–¹æ³•äºŒæŠŠæŽ¥ä¸‹æ¥æƒ³è¦éåŽ†çš„åœŸåœ°æ”¾åœ¨æ ˆé‡Œï¼Œç„¶åŽåœ¨å–å‡ºè¿™äº›åœŸåœ°çš„æ—¶å€™è®¿é—®å®ƒä»¬ã€‚\n\n- è®¿é—®æ¯ä¸€ç‰‡åœŸåœ°æ—¶ï¼Œæˆ‘ä»¬å°†å¯¹å›´ç»•å®ƒå››ä¸ªæ–¹å‘è¿›è¡ŒæŽ¢ç´¢ï¼Œæ‰¾åˆ°è¿˜æœªè®¿é—®çš„åœŸåœ°ï¼ŒåŠ å…¥åˆ°æ ˆ $\\textit{stack}$ ä¸­ï¼›\n\n- å¦å¤–ï¼Œåªè¦æ ˆ $\\textit{stack}$ ä¸ä¸ºç©ºï¼Œå°±è¯´æ˜Žæˆ‘ä»¬è¿˜æœ‰åœŸåœ°å¾…è®¿é—®ï¼Œé‚£ä¹ˆå°±ä»Žæ ˆä¸­å–å‡ºä¸€ä¸ªå…ƒç´ å¹¶è®¿é—®ã€‚\n\n```Python [sol2-Python3]\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ans = 0\n        for i, l in enumerate(grid):\n            for j, n in enumerate(l):\n                cur = 0\n                stack = [(i, j)]\n                while stack:\n                    cur_i, cur_j = stack.pop()\n                    if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:\n                        continue\n                    cur += 1\n                    grid[cur_i][cur_j] = 0\n                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                        next_i, next_j = cur_i + di, cur_j + dj\n                        stack.append((next_i, next_j))\n                ans = max(ans, cur)\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.size(); ++i) {\n            for (int j = 0; j != grid[0].size(); ++j) {\n                int cur = 0;\n                stack<int> stacki;\n                stack<int> stackj;\n                stacki.push(i);\n                stackj.push(j);\n                while (!stacki.empty()) {\n                    int cur_i = stacki.top(), cur_j = stackj.top();\n                    stacki.pop();\n                    stackj.pop();\n                    if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) {\n                        continue;\n                    }\n                    ++cur;\n                    grid[cur_i][cur_j] = 0;\n                    int di[4] = {0, 0, 1, -1};\n                    int dj[4] = {1, -1, 0, 0};\n                    for (int index = 0; index != 4; ++index) {\n                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n                        stacki.push(next_i);\n                        stackj.push(next_j);\n                    }\n                }\n                ans = max(ans, cur);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.length; ++i) {\n            for (int j = 0; j != grid[0].length; ++j) {\n                int cur = 0;\n                Deque<Integer> stacki = new LinkedList<Integer>();\n                Deque<Integer> stackj = new LinkedList<Integer>();\n                stacki.push(i);\n                stackj.push(j);\n                while (!stacki.isEmpty()) {\n                    int cur_i = stacki.pop(), cur_j = stackj.pop();\n                    if (cur_i < 0 || cur_j < 0 || cur_i == grid.length || cur_j == grid[0].length || grid[cur_i][cur_j] != 1) {\n                        continue;\n                    }\n                    ++cur;\n                    grid[cur_i][cur_j] = 0;\n                    int[] di = {0, 0, 1, -1};\n                    int[] dj = {1, -1, 0, 0};\n                    for (int index = 0; index != 4; ++index) {\n                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n                        stacki.push(next_i);\n                        stackj.push(next_j);\n                    }\n                }\n                ans = Math.max(ans, cur);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æž**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(m \\times n)$ã€‚å…¶ä¸­ $m$ æ˜¯ç»™å®šç½‘æ ¼ä¸­çš„è¡Œæ•°ï¼Œ$n$ æ˜¯åˆ—æ•°ã€‚æˆ‘ä»¬è®¿é—®æ¯ä¸ªç½‘æ ¼æœ€å¤šä¸€æ¬¡ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(m \\times n)$ï¼Œæ ˆä¸­æœ€å¤šä¼šå­˜æ”¾æ‰€æœ‰çš„åœŸåœ°ï¼ŒåœŸåœ°çš„æ•°é‡æœ€å¤šä¸º $m \\times n$ å—ï¼Œå› æ­¤ä½¿ç”¨çš„ç©ºé—´ä¸º $O(m \\times n)$ã€‚\n\n#### æ–¹æ³•ä¸‰ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢\n\n**ç®—æ³•**\n\næˆ‘ä»¬æŠŠæ–¹æ³•äºŒä¸­çš„æ ˆæ”¹ä¸ºé˜Ÿåˆ—ï¼Œæ¯æ¬¡ä»Žé˜Ÿé¦–å–å‡ºåœŸåœ°ï¼Œå¹¶å°†æŽ¥ä¸‹æ¥æƒ³è¦éåŽ†çš„åœŸåœ°æ”¾åœ¨é˜Ÿå°¾ï¼Œå°±å®žçŽ°äº†å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ã€‚\n\n```Python [sol3-Python3]\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ans = 0\n        for i, l in enumerate(grid):\n            for j, n in enumerate(l):\n                cur = 0\n                q = collections.deque([(i, j)])\n                while q:\n                    cur_i, cur_j = q.popleft()\n                    if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:\n                        continue\n                    cur += 1\n                    grid[cur_i][cur_j] = 0\n                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                        next_i, next_j = cur_i + di, cur_j + dj\n                        q.append((next_i, next_j))\n                ans = max(ans, cur)\n        return ans\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.size(); ++i) {\n            for (int j = 0; j != grid[0].size(); ++j) {\n                int cur = 0;\n                queue<int> queuei;\n                queue<int> queuej;\n                queuei.push(i);\n                queuej.push(j);\n                while (!queuei.empty()) {\n                    int cur_i = queuei.front(), cur_j = queuej.front();\n                    queuei.pop();\n                    queuej.pop();\n                    if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) {\n                        continue;\n                    }\n                    ++cur;\n                    grid[cur_i][cur_j] = 0;\n                    int di[4] = {0, 0, 1, -1};\n                    int dj[4] = {1, -1, 0, 0};\n                    for (int index = 0; index != 4; ++index) {\n                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n                        queuei.push(next_i);\n                        queuej.push(next_j);\n                    }\n                }\n                ans = max(ans, cur);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.length; ++i) {\n            for (int j = 0; j != grid[0].length; ++j) {\n                int cur = 0;\n                Queue<Integer> queuei = new LinkedList<Integer>();\n                Queue<Integer> queuej = new LinkedList<Integer>();\n                queuei.offer(i);\n                queuej.offer(j);\n                while (!queuei.isEmpty()) {\n                    int cur_i = queuei.poll(), cur_j = queuej.poll();\n                    if (cur_i < 0 || cur_j < 0 || cur_i == grid.length || cur_j == grid[0].length || grid[cur_i][cur_j] != 1) {\n                        continue;\n                    }\n                    ++cur;\n                    grid[cur_i][cur_j] = 0;\n                    int[] di = {0, 0, 1, -1};\n                    int[] dj = {1, -1, 0, 0};\n                    for (int index = 0; index != 4; ++index) {\n                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n                        queuei.offer(next_i);\n                        queuej.offer(next_j);\n                    }\n                }\n                ans = Math.max(ans, cur);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æž**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(m \\times n)$ã€‚å…¶ä¸­ $m$ æ˜¯ç»™å®šç½‘æ ¼ä¸­çš„è¡Œæ•°ï¼Œ$n$ æ˜¯åˆ—æ•°ã€‚æˆ‘ä»¬è®¿é—®æ¯ä¸ªç½‘æ ¼æœ€å¤šä¸€æ¬¡ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(m \\times n)$ï¼Œé˜Ÿåˆ—ä¸­æœ€å¤šä¼šå­˜æ”¾æ‰€æœ‰çš„åœŸåœ°ï¼ŒåœŸåœ°çš„æ•°é‡æœ€å¤šä¸º $m \\times n$ å—ï¼Œå› æ­¤ä½¿ç”¨çš„ç©ºé—´ä¸º $O(m \\times n)$ã€‚"
}