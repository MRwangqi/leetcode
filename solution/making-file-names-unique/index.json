{
	"titleSlug": "making-file-names-unique",
	"slug": "ru-he-yi-bu-yi-bu-ac-zhe-ge-wen-ti-by-liuyubobobo",
	"url": "https://leetcode-cn.com/problems/making-file-names-unique/solution/ru-he-yi-bu-yi-bu-ac-zhe-ge-wen-ti-by-liuyubobobo/",
	"content": "很多题解都直接给出了这个问题的正确代码。在这里，我想聊一聊，对于这样一个问题，是如何一步一步获得相应的解的。\n\n<br/>\n\n首先，第一步，毫无疑问，对于大多数问题，都应该思考暴力解法。很多时候，暴力解法都能启发我们获得更优的解。哪怕是对于很难的问题都是如此。这里的一个核心在于：暴力解向我们揭示了问题的**解空间**是什么。\n\n对于这个问题来说，暴力解怎么得到？非常简单：对于每一个已经使用的文件名，都扔到哈希表里。对于一个新的文件，从 ``k = 1`` 开始，尝试``文件名(k)``的形式有没有重复。重复了，``k ++``继续试；否则，我们就找到了正确的文件名。\n\n我的参考代码（C++）：\n\n```\nclass Solution {\npublic:\n    vector<string> getFolderNames(vector<string>& names) {\n\n        vector<string> res;\n        unordered_set<string> table;\n        for(const string& name: names){\n            if(table.count(name)){\n                // 如果 name 已经被使用了，则暴力搜索后面小括号中需要添加的数字\n                for(int k = 1; ; k ++){\n                    string new_name = name + \"(\" + to_string(k) + \")\";    \n                    if(!table.count(new_name)){\n                        res.push_back(new_name);\n                        table.insert(new_name);\n                        break;\n                    }\n                }\n            }\n            else{\n                res.push_back(name);\n                table.insert(name);\n            }\n        }\n        return res;\n    }\n};\n```\n\n这个解法会超时。很容易分析出来，超时的关键在于对 ``k`` 的遍历的那一重循环。\n\n在极端情况下，如果 ``names`` 中的所有名字都一样，那么显然，对 ``k`` 的遍历每次都会从 1 重新开始，产生了大量的重复。\n\n<br/>\n\n解决方案显然是要记录下来，对于每一个 ``name``，现在已经使用到了第几个数字？下次，从这个数字 +1 开始继续使用就好了（注意，这个想法这里有 bug，后续介绍）。\n\n为了能够记录每个 ``name`` 当前使用的数字，我们需要把上面的 ``table`` 换成是一个 ``map``。\n\n我的参考代码如下（C++）。注意，注释部分是修改的代码。\n\n```\nclass Solution {\npublic:\n    vector<string> getFolderNames(vector<string>& names) {\n\n        vector<string> res;\n        unordered_map<string, int> table;\n        for(const string& name: names){\n            if(table.count(name)){\n                // 如果 name 已经被使用了，则使用 table[name] + 1\n                string new_name = name + \"(\" + to_string(table[name] + 1) + \")\";\n                res.push_back(new_name);\n                table[name]++; // table[name] 对应的数字 ++\n            }\n            else{\n                res.push_back(name);\n                table[name] = 0; // 对于一个第一次使用的 name，记录 0\n            }\n        }\n        return res;\n    }\n};\n```\n\n这个代码会 WA。\n\n<br/>\n\n大家看一下 WA 的用例，如果输入是 ``[\"gta\",\"gta(1)\",\"gta\"]``：\n\n在处理第一个 ``gta`` 的时候，``table[\"gta\"]``记录了0。\n\n然后来了一个 ``gta(1)``。\n\n之后，再来了一个 ``gta``。此时，因为 ``table[\"gta\"] == 0``，根据上面的逻辑，我们就会直接采用 ``gta(1)`` 这个名字。可之前已经添加了 ``gta(1)``。产生了冲突。\n\n所以，我们现在代码问题的关键是，不应该直接使用 ``gta(1)`` 这个名字，而面对 ``name`` 的冲突，也应该进行搜索。只不过，我们不需要从 ``1`` 开始搜索，从 ``table[name] + 1`` 开始搜索就好了。\n\n我的参考代码如下（C++）。注意，注释部分是修改的代码。\n\n```\nclass Solution {\npublic:\n    vector<string> getFolderNames(vector<string>& names) {\n\n        vector<string> res;\n        unordered_map<string, int> table;\n        for(const string& name: names){\n            if(table.count(name)){\n                // 如果 name 已经被使用了，则从 table[name] + 1 开始\n                // 搜索小括号中需要添加的数字\n                for(int k = table[name] + 1; ; k ++){\n                    string new_name = name + \"(\" + to_string(k) + \")\";\n                    if(!table.count(new_name)){\n                        res.push_back(new_name);\n                        table[name] = k; // name 对应的使用的数字变成了 k\n                        break;\n                    }\n                }\n            }\n            else{\n                res.push_back(name);\n                table[name] = 0;\n            }\n        }\n        return res;\n    }\n};\n```\n\n这个代码依然会 WA。\n\n<br/>\n\n我们可以研究一下 WA 的用例。\n\n如果输入是 ``[\"gta\",\"gta(1)\",\"gta\", \"gta(2)\"]``\n\n这次，处理前三个字符，就已经可以正确获得 ``\"gta\",\"gta(1)\",\"gta(2)\"`` 的结果了。但是，当处理到第四个字符串 ``gta(2)`` 的时候出现了问题。此时，对于我们的逻辑，会认为 ``gta(2)`` 没有被使用过。\n\n为什么？因为我们在处理第三个字符 ``gta`` 的时候，会搜索到 ``gta(2)`` 这个名字。但是，在对 ``table`` 的更新中，我们只更新了 ``table[\"gta\"] = 2``。 这个更新只保证了对于 ``gta`` 这个名字出现重复可以被检测到。但如果出现了 ``gta(2)`` 这个名字的重复，我们的 ``table`` 中并没有 ``gta(2)`` 的记录。\n\n解决方案，非常简单，每次搜索到一个新的没有被使用的名字以后，不仅仅要更新 ``name``，还要更新 ``new_name``。\n\n我的参考代码如下。只需要添加注释处的一个代码就好。\n\n```\nclass Solution {\npublic:\n    vector<string> getFolderNames(vector<string>& names) {\n\n        vector<string> res;\n        unordered_map<string, int> table;\n        for(const string& name: names){\n            if(table.count(name)){\n                for(int k = table[name] + 1; ; k ++){\n                    string new_name = name + \"(\" + to_string(k) + \")\";\n                    if(!table.count(new_name)){\n                        res.push_back(new_name);\n                        table[name] = k; \n                        table[new_name] = 0; // 更新 new_name\n                        break;\n                    }\n                }\n            }\n            else{\n                res.push_back(name);\n                table[name] = 0;\n            }\n        }\n        return res;\n    }\n};\n```\n\n至此，AC：）\n\n---\n\n觉得有帮助请点赞哇！\n"
}