{
	"titleSlug": "maximize-score-after-n-operations",
	"slug": "by-wangzhizhi-oill",
	"url": "https://leetcode-cn.com/problems/maximize-score-after-n-operations/solution/by-wangzhizhi-oill/",
	"content": "![image.png](https://pic.leetcode-cn.com/1659069594-ZaVAsT-image.png)\n### 解题思路\n状态压缩动态规划。每一次操作，都是由上一次操作的基础上多抹去两个位转移而来的，可以用二进制枚举来代表当前`2 * n`个数中已经抹去的数的状态，`1`表示已经抹去，`0`表示还没有抹去。用`dp[mask]`表示操作至状态`mask`时的最大分数。对于枚举的任意一个状态`k`，可以再枚举两个包含在状态`k`中的`1`（假设分别在`i`和`j`为位上），去掉这两个`1`的状态`s = k - (1 << i) - (1 << j)`就应该是状态`k`的一个前态。状态`k`可以从所有这样的状态`s`转移而来，则有转移方程\n$$ dp\\left[k\\right]=\\max_{0<i<j<n\\ll1}\\left(dp\\left[k-(1\\ll i)-(1\\ll j)\\right]+\\frac{bits(k)\\times gcd[i][j]}{2}\\right) $$\n为了加快计算，可以预处理所有可能用到的最大公约数，保存在矩阵中；并且在枚举的过程中保证 $0<i<j<n\\ll1$，减少重复计算。\n\n### 代码实现\n```java []\nclass Solution {\n    private int gcd(int x, int y) {\n        return y == 0 ? x : gcd(y, x % y);\n    }\n\n    public int maxScore(int[] nums) {\n        int m = nums.length;\n        // 预处理所有可能的最大公约数（只处理 i 小于 j 的情况）\n        int[][] gcd = new int[m][m];\n        for (int i = 0; i < m - 1; i++)\n            for (int j = i + 1; j < m; j++)\n                gcd[i][j] = gcd(nums[i], nums[j]);\n        int mask = 1 << m;\n        int[] dp = new int[mask];\n        // 从小到大枚举状态，注意只有 1 的位数是偶数的状态是有效的\n        for (int k = 0; k < mask; k++) {\n            int bits = Integer.bitCount(k);\n            // 如果 1 的位数不是偶数就跳过，当前的操作次数等于 bits / 2\n            if (bits % 2 != 0)\n                continue;\n            // 在当前状态的基础上任意去掉两个位上的 1，则 dp[k] 可以从 dp[k \\ (1 << i) \\ (1 << j)] 转移而来\n            for (int i = 0; i < m - 1; i++) {\n                if ((k & (1 << i)) == 0)\n                    continue;\n                for (int j = i + 1; j < m; j++) {\n                    if ((k & (1 << j)) == 0)\n                        continue;\n                    dp[k] = Math.max(dp[k], dp[k - (1 << i) - (1 << j)] + gcd[i][j] * bits / 2);\n                }\n            }\n        }\n        return dp[mask - 1];\n    }\n}\n```"
}