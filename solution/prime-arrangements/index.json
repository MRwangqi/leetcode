{
	"titleSlug": "prime-arrangements",
	"slug": "zhi-shu-pai-lie-by-leetcode-solution-i6g1",
	"url": "https://leetcode-cn.com/problems/prime-arrangements/solution/zhi-shu-pai-lie-by-leetcode-solution-i6g1/",
	"content": "#### 方法一：质数判断 + 组合数学\n\n**思路**\n\n求符合条件的方案数，使得所有质数都放在质数索引上，所有合数放在合数索引上，质数放置和合数放置是相互独立的，总的方案数即为「所有质数都放在质数索引上的方案数」$\\times$「所有合数都放在合数索引上的方案数」。求「所有质数都放在质数索引上的方案数」，即求质数个数 $\\textit{numPrimes}$ 的阶乘。「所有合数都放在合数索引上的方案数」同理。求质数个数时，可以使用试除法。「[204.计数质数的官方题解](https://leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/)」列举了更多的求质数个数方法，读者可以根据兴趣阅读。最后注意计算过程中需要对 $10^9+7$ 取模。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        numPrimes = sum(self.isPrime(i) for i in range(1, n + 1))\n        return self.factorial(numPrimes) * self.factorial(n - numPrimes) % (10 ** 9 + 7)\n\n    def isPrime(self, n: int) -> int:\n        if n == 1:\n            return 0\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                return 0\n        return 1\n\n    def factorial(self, n: int) -> int:\n        res = 1\n        for i in range(1, n + 1):\n            res *= i\n            res %= (10 ** 9 + 7)\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static final int MOD = 1000000007;\n\n    public int numPrimeArrangements(int n) {\n        int numPrimes = 0;\n        for (int i = 1; i <= n; i++) {\n            if (isPrime(i)) {\n                numPrimes++;\n            }\n        }\n        return (int) (factorial(numPrimes) * factorial(n - numPrimes) % MOD);\n    }\n\n    public boolean isPrime(int n) {\n        if (n == 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public long factorial(int n) {\n        long res = 1;\n        for (int i = 1; i <= n; i++) {\n            res *= i;\n            res %= MOD;\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    const int MOD = 1000000007;\n\n    public int NumPrimeArrangements(int n) {\n        int numPrimes = 0;\n        for (int i = 1; i <= n; i++) {\n            if (IsPrime(i)) {\n                numPrimes++;\n            }\n        }\n        return (int) (Factorial(numPrimes) * Factorial(n - numPrimes) % MOD);\n    }\n\n    public bool IsPrime(int n) {\n        if (n == 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public long Factorial(int n) {\n        long res = 1;\n        for (int i = 1; i <= n; i++) {\n            res *= i;\n            res %= MOD;\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int numPrimeArrangements(int n) {\n        int numPrimes = 0;\n        for (int i = 1; i <= n; i++) {\n            if (isPrime(i)) {\n                numPrimes++;\n            }\n        }\n        return (int) (factorial(numPrimes) * factorial(n - numPrimes) % MOD);\n    }\n\n    bool isPrime(int n) {\n        if (n == 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    long factorial(int n) {\n        long res = 1;\n        for (int i = 1; i <= n; i++) {\n            res *= i;\n            res %= MOD;\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\n#define MOD 1000000007\n\nbool isPrime(int n) {\n    if (n == 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nlong factorial(int n) {\n    long res = 1;\n    for (int i = 1; i <= n; i++) {\n        res *= i;\n        res %= MOD;\n    }\n    return res;\n}\n\nint numPrimeArrangements(int n){\n    int numPrimes = 0;\n    for (int i = 1; i <= n; i++) {\n        if (isPrime(i)) {\n            numPrimes++;\n        }\n    }\n    return (int) (factorial(numPrimes) * factorial(n - numPrimes) % MOD);\n}\n```\n\n```go [sol1-Golang]\nconst mod int = 1e9 + 7\n\nfunc numPrimeArrangements(n int) int {\n    numPrimes := 0\n    for i := 2; i <= n; i++ {\n        if isPrime(i) {\n            numPrimes++\n        }\n    }\n    return factorial(numPrimes) * factorial(n-numPrimes) % mod\n}\n\nfunc isPrime(n int) bool {\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc factorial(n int) int {\n    f := 1\n    for i := 1; i <= n; i++ {\n        f = f * i % mod\n    }\n    return f\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst MOD = 1000000007;\nvar numPrimeArrangements = function(n) {\n    let numPrimes = 0;\n    for (let i = 2 ; i <= n ; i++) {\n        if (isPrime(i)) {\n            numPrimes++;\n        }\n    }\n    let res = 1;\n    let m = n - numPrimes;\n    while (numPrimes > 0) {\n        res = res % MOD;\n        res *= numPrimes;\n        numPrimes--;\n    }\n    while (m > 0) {\n        res = res % MOD;\n        res *= m;\n        m--;\n    }\n    return res;\n};\n\nconst isPrime = (n) => {\n    if (n === 1) {\n        return false;\n    }\n    for (let i = 2; i * i <= n; i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^{3/2})$。求 $n$ 个数中质数个数的时间复杂度为 $O(n^{3/2})$，阶乘的时间复杂度为 $O(n)$，总的时间复杂度为 $O(n^{3/2})$。\n\n- 空间复杂度：$O(1)$，只使用了常数空间。"
}