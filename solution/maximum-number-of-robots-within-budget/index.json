{
	"titleSlug": "maximum-number-of-robots-within-budget",
	"slug": "by-endlesscheng-7ukp",
	"url": "https://leetcode-cn.com/problems/maximum-number-of-robots-within-budget/solution/by-endlesscheng-7ukp/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1na41137jv) 已出炉，**介绍了单调队列的原理**，欢迎点赞三连，在评论区分享你对这场双周赛的看法~\r\n\r\n---\r\n\r\n前置题目：[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)。\r\n\r\n本题的一种做法是二分答案，这样就转换成了 239 题。\r\n\r\n但实际上不用二分，在 239 这题的基础上，把固定大小的滑动窗口改为不固定大小的双指针，具体见代码注释。\r\n\r\n更多有关单调队列的题目见我的算法竞赛模板库中的 [monotone_queue.go](https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/monotone_queue.go)。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{chargeTimes}$ 的长度。\r\n- 空间复杂度：$O(n)$。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\r\n        ans = s = left = 0\r\n        q = deque()\r\n        # 枚举区间右端点 right，计算区间左端点 left 的最小值\r\n        for right, (t, c) in enumerate(zip(chargeTimes, runningCosts)):\r\n            # 及时清除队列中的无用数据，保证队列的单调性\r\n            while q and t >= chargeTimes[q[-1]]:\r\n                q.pop()\r\n            q.append(right)\r\n            s += c\r\n            # 如果左端点 left 不满足要求，就不断右移 left\r\n            while q and chargeTimes[q[0]] + (right - left + 1) * s > budget:\r\n                # 及时清除队列中的无用数据，保证队列的单调性\r\n                if q[0] == left:\r\n                    q.popleft()\r\n                s -= runningCosts[left]\r\n                left += 1\r\n            ans = max(ans, right - left + 1)\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\r\n        var ans = 0;\r\n        var q = new ArrayDeque<Integer>();\r\n        var sum = 0L;\r\n        // 枚举区间右端点 right，计算区间左端点 left 的最小值\r\n        for (int left = 0, right = 0; right < chargeTimes.length; ++right) {\r\n            // 及时清除队列中的无用数据，保证队列的单调性\r\n            while (!q.isEmpty() && chargeTimes[right] >= chargeTimes[q.peekLast()])\r\n                q.pollLast();\r\n            q.addLast(right);\r\n            sum += runningCosts[right];\r\n            // 如果左端点 left 不满足要求，就不断右移 left\r\n            while (!q.isEmpty() && chargeTimes[q.peekFirst()] + (right - left + 1) * sum > budget) {\r\n                // 及时清除队列中的无用数据，保证队列的单调性\r\n                if (q.peekFirst() == left) q.pollFirst();\r\n                sum -= runningCosts[left++];\r\n            }\r\n            ans = Math.max(ans, right - left + 1);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int maximumRobots(vector<int> &chargeTimes, vector<int> &runningCosts, long long budget) {\r\n        int ans = 0;\r\n        deque<int> q;\r\n        long sum = 0L;\r\n        // 枚举区间右端点 right，计算区间左端点 left 的最小值\r\n        for (int left = 0, right = 0; right < chargeTimes.size(); ++right) {\r\n            // 及时清除队列中的无用数据，保证队列的单调性\r\n            while (!q.empty() && chargeTimes[right] >= chargeTimes[q.back()])\r\n                q.pop_back();\r\n            q.push_back(right);\r\n            sum += runningCosts[right];\r\n            // 如果左端点 left 不满足要求，就不断右移 left\r\n            while (!q.empty() && chargeTimes[q.front()] + (right - left + 1) * sum > budget) {\r\n                // 及时清除队列中的无用数据，保证队列的单调性\r\n                if (q.front() == left) q.pop_front();\r\n                sum -= runningCosts[left++];\r\n            }\r\n            ans = max(ans, right - left + 1);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc maximumRobots(chargeTimes, runningCosts []int, budget int64) (ans int) {\r\n\tsum, left, q := int64(0), 0, []int{}\r\n\t// 枚举区间右端点 right，计算区间左端点 left 的最小值\r\n\tfor right, t := range chargeTimes {\r\n\t\t// 及时清除队列中的无用数据，保证队列的单调性\r\n\t\tfor len(q) > 0 && t >= chargeTimes[q[len(q)-1]] {\r\n\t\t\tq = q[:len(q)-1]\r\n\t\t}\r\n\t\tq = append(q, right)\r\n\t\tsum += int64(runningCosts[right])\r\n\t\t// 如果左端点 left 不满足要求，就不断右移 left\r\n\t\tfor len(q) > 0 && int64(chargeTimes[q[0]])+int64(right-left+1)*sum > budget {\r\n\t\t\t// 及时清除队列中的无用数据，保证队列的单调性\r\n\t\t\tif q[0] == left {\r\n\t\t\t\tq = q[1:]\r\n\t\t\t}\r\n\t\t\tsum -= int64(runningCosts[left])\r\n\t\t\tleft++\r\n\t\t}\r\n\t\tans = max(ans, right-left+1)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n#### 思考题\r\n\r\n把「子数组」改成「子序列」要怎么做？\r\n\r\n思路和 [1383. 最大的团队表现值](https://leetcode.cn/problems/maximum-performance-of-a-team/) 是类似的。\r\n\r\n思考题的讲解见 [视频讲解](https://www.bilibili.com/video/BV1na41137jv) 的最后一部分，代码如下：\r\n\r\n```py\r\nclass Solution:\r\n    def maximumRobotsSubseq(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\r\n        ans = sum_cost = 0\r\n        h = []  # 最大堆，堆顶表示当前的最大花费，从而贪心地在不满足要求的情况下，优先去掉最大的花费\r\n        for t, c in sorted(zip(chargeTimes, runningCosts)):  # 按照时间排序，从而保证当前的时间是最大的，在此之前的机器人都是可以选的\r\n            heappush(h, -c)\r\n            sum_cost += c\r\n            while h and t + len(h) * sum_cost > budget:\r\n                sum_cost += heappop(h)  # 弹出一个最大花费，即使弹出的是当前的 c 也没关系，这不会得到更大的 ans\r\n            ans = max(ans, len(h))\r\n        return ans\r\n```"
}