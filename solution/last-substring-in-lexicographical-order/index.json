{
	"titleSlug": "last-substring-in-lexicographical-order",
	"slug": "by-stormsunshine-zsgp",
	"url": "https://leetcode-cn.com/problems/last-substring-in-lexicographical-order/solution/by-stormsunshine-zsgp/",
	"content": "# 解法\r\n\r\n## 思路和算法\r\n\r\n当字符串 $s$ 中的子串开始下标确定时，子串的长度越大，其字典序越大，因此字符串 $s$ 的所有子串中字典序最大的子串一定是字符串 $s$ 的一个后缀。\r\n\r\n为了寻找字符串 $s$ 中字典序最大的子串，需要考虑以字符串 $s$ 中的每个字符作为首个字符的后缀。用 $n$ 表示字符串 $s$ 的长度，如果直接遍历每个后缀并比较，则时间复杂度是 $O(n^2)$，该时间复杂度过高，需要优化。\r\n\r\n为了降低时间复杂度，需要跳过不可能是字典序最大的子串，避免不必要的计算。可以使用双指针的做法降低时间复杂度，用 $\\textit{left}$ 和 $\\textit{right}$ 表示双指针，分别指向待比较的两个子串的开始下标，其中 $\\textit{left} < \\textit{right}$。\r\n\r\n考虑字符串 $s$ 的以下标 $\\textit{left}$ 和 $\\textit{right}$ 作为开始下标的两个子串，初始时 $\\textit{left} = 0$，$\\textit{right} = 1$。比较这两个子串的过程中，用 $\\textit{step}$ 表示距离开始下标的移动次数，初始时 $\\textit{step} = 0$，每次比较 $s[\\textit{left} + \\textit{step}]$ 和 $s[\\textit{right} + \\textit{step}]$，根据比较的结果执行相应的操作。\r\n\r\n- 如果 $s[\\textit{left} + \\textit{step}] = s[\\textit{right} + \\textit{step}]$，则两个子串已经遍历过的字符相同，将 $\\textit{step}$ 加 $1$。\r\n\r\n- 如果 $s[\\textit{left} + \\textit{step}] \\ne s[\\textit{right} + \\textit{step}]$，则其中较小的字符所在的子串一定不是字典序最大的子串，因此将该子串跳过，具体做法如下。\r\n\r\n   - 如果 $s[\\textit{left} + \\textit{step}] < s[\\textit{right} + \\textit{step}]$，则将 $\\textit{left}$ 向右移动 $\\textit{step} + 1$ 位，然后将 $\\textit{step}$ 的值变成 $0$。更新 $\\textit{left}$ 后，如果 $\\textit{left} \\ge \\textit{right}$，则将 $\\textit{right}$ 移动到 $\\textit{left} + 1$。\r\n\r\n   - 如果 $s[\\textit{left} + \\textit{step}] > s[\\textit{right} + \\textit{step}]$，则将 $\\textit{right}$ 向右移动 $\\textit{step} + 1$ 位，然后将 $\\textit{step}$ 的值变成 $0$。\r\n\r\n遍历结束之后，返回字符串 $s$ 的以下标 $\\textit{left}$ 作为开始下标的子串，该子串是字典序最大的子串。\r\n\r\n由于每次更新 $\\textit{left}$ 或 $\\textit{right}$ 时都会跳过该下标已经遍历过的所有字符，因此双指针最多各遍历字符串一次，时间复杂度是 $O(n)$。\r\n\r\n## 证明\r\n\r\n上述做法中，当遇到 $s[\\textit{left} + \\textit{step}] \\ne s[\\textit{right} + \\textit{step}]$ 时，将字典序较小的子串中已经遍历过的所有字符都跳过。需要证明跳过的字符都不可能是字典序最大的子串的开始字符。以下用 $s[\\textit{start} : \\textit{end}]$ 表示字符串 $s$ 的下标范围 $[\\textit{start}, \\textit{end}]$ 的子串。\r\n\r\n- 如果 $s[\\textit{left} + \\textit{step}] < s[\\textit{right} + \\textit{step}]$，则对于任意 $0 \\le \\textit{step}' \\le \\textit{step}$，子串 $s[\\textit{left} + \\textit{step}' : \\textit{left} + \\textit{step}]$ 的字典序一定小于子串 $s[\\textit{right} + \\textit{step}' : \\textit{right} + \\textit{step}]$ 的字典序，因此字符串 $s$ 的以 $\\textit{left} + \\textit{step}'$ 作为开始下标的子串一定不是字典序最大的子串，即范围 $[\\textit{left}, \\textit{left} + \\textit{step}]$ 中的下标都不可能是字典序最大的子串的开始下标。\r\n\r\n- 如果 $s[\\textit{left} + \\textit{step}] > s[\\textit{right} + \\textit{step}]$，则对于任意 $0 \\le \\textit{step}' \\le \\textit{step}$，子串 $s[\\textit{left} + \\textit{step}' : \\textit{left} + \\textit{step}]$ 的字典序一定大于子串 $s[\\textit{right} + \\textit{step}' : \\textit{right} + \\textit{step}]$ 的字典序，因此字符串 $s$ 的以 $\\textit{right} + \\textit{step}'$ 作为开始下标的子串一定不是字典序最大的子串，即范围 $[\\textit{right}, \\textit{right} + \\textit{step}]$ 中的下标都不可能是字典序最大的子串的开始下标。\r\n\r\n由于每次更新 $\\textit{left}$ 或 $\\textit{right}$ 都是将指针向右移动，因此当 $\\textit{left}$ 更新之后可能出现 $\\textit{left} \\ge \\textit{right}$ 的情况。由于字典序最大的子串的开始下标不可能小于更新后的 $\\textit{left}$，因此当 $\\textit{left} \\ge \\textit{right}$ 时可以将 $\\textit{right}$ 移动到 $\\textit{left} + 1$，确保 $\\textit{left} < \\textit{right}$，$\\textit{right}$ 跳过的下标中除了 $\\textit{left}$ 以外都不可能是字典序最大的子串的开始下标。\r\n\r\n根据上述分析可知，每次更新 $\\textit{left}$ 或 $\\textit{right}$ 时跳过的下标都不可能是字典序最大的子串的开始下标。\r\n\r\n遍历结束时，字符串 $s$ 的以 $\\textit{left}$ 作为开始下标的子串的字典序一定不会小于以 $\\textit{right}$ 作为开始下标的子串的字典序。由于 $\\textit{left} < \\textit{right}$，当字典序相同时，长度越大的字符串的字典序越大，因此字符串 $s$ 的以下标 $\\textit{left}$ 作为开始下标的子串是字典序最大的子串。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public String lastSubstring(String s) {\r\n        int length = s.length();\r\n        int left = 0, right = 1, step = 0;\r\n        while (right + step < length) {\r\n            if (s.charAt(left + step) == s.charAt(right + step)) {\r\n                step++;\r\n            } else {\r\n                if (s.charAt(left + step) < s.charAt(right + step)) {\r\n                    left += step + 1;\r\n                } else {\r\n                    right += step + 1;\r\n                }\r\n                step = 0;\r\n                right = Math.max(right, left + 1);\r\n            }\r\n        }\r\n        return s.substring(left);\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public string LastSubstring(string s) {\r\n        int length = s.Length;\r\n        int left = 0, right = 1, step = 0;\r\n        while (right + step < length) {\r\n            if (s[left + step] == s[right + step]) {\r\n                step++;\r\n            } else {\r\n                if (s[left + step] < s[right + step]) {\r\n                    left += step + 1;\r\n                } else {\r\n                    right += step + 1;\r\n                }\r\n                step = 0;\r\n                right = Math.Max(right, left + 1);\r\n            }\r\n        }\r\n        return s.Substring(left);\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。双指针最多各遍历字符串一次。\r\n\r\n- 空间复杂度：$O(1)$。"
}