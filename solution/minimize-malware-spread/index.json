{
	"titleSlug": "minimize-malware-spread",
	"slug": "jin-liang-jian-shao-e-yi-ruan-jian-de-chuan-bo-b-2",
	"url": "https://leetcode-cn.com/problems/minimize-malware-spread/solution/jin-liang-jian-shao-e-yi-ruan-jian-de-chuan-bo-b-2/",
	"content": "#### 方法一： 深度优先搜索\n\n**思路**\n\n首先，把图中所有的连通分量各自标上不同的颜色，这可以用深度优先搜索来实现。\n\n如题所述，如果 `initial` 中的两个节点的颜色相同（即属于同一个连通分量），那移除这种节点是不会减少 `M(initial)` 的，因为恶意软件会感染同一个连通分量中的所有节点。\n\n因此，对于 `initial` 中颜色唯一的节点，从中选择一个移除来最大限度地减少被感染节点数。(如果有多个节点都可以达成最优解，就选择下标最小的节点。另外，如果没有颜色唯一的节点，就直接返回下标最小的节点。)\n\n**算法**\n\n算法包括以下几个部分：\n\n* **给连通分量上色：**  遍历每个节点，如果它还没有颜色，就用深度优先搜索去遍历它所在的连通分量，同时给这个连通分量标上新的颜色。\n\n* **计算每个连通分量的大小：**  数一下每个颜色的节点各有多少个。\n\n* **找到唯一的颜色：** 找到 `initial` 中颜色唯一的节点。\n\n* **选择答案：** 对于 `initial` 中颜色唯一的节点，计算这个颜色节点的个数。从中选出最大节点个数的那个，如果有多个最优解，选择其中节点下标最小的。 \n\n* 如果没有颜色唯一的节点，直接返回 `min(initial)`。\n\n```java [solution1-Java]\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        // 1. Color each component.\n        // colors[node] = the color of this node.\n\n        int N = graph.length;\n        int[] colors = new int[N];\n        Arrays.fill(colors, -1);\n        int C = 0;\n\n        for (int node = 0; node < N; ++node)\n            if (colors[node] == -1)\n                dfs(graph, colors, node, C++);\n\n        // 2. Size of each color.\n        int[] size = new int[C];\n        for (int color: colors)\n            size[color]++;\n\n        // 3. Find unique colors.\n        int[] colorCount = new int[C];\n        for (int node: initial)\n            colorCount[colors[node]]++;\n\n        // 4. Answer\n        int ans = Integer.MAX_VALUE;\n        for (int node: initial) {\n            int c = colors[node];\n            if (colorCount[c] == 1) {\n                if (ans == Integer.MAX_VALUE)\n                    ans = node;\n                else if (size[c] > size[colors[ans]])\n                    ans = node;\n                else if (size[c] == size[colors[ans]] && node < ans)\n                    ans = node;\n            }\n        }\n\n        if (ans == Integer.MAX_VALUE)\n            for (int node: initial)\n                ans = Math.min(ans, node);\n\n        return ans;\n    }\n\n    public void dfs(int[][] graph, int[] colors, int node, int color) {\n        colors[node] = color;\n        for (int nei = 0; nei < graph.length; ++nei)\n            if (graph[node][nei] == 1 && colors[nei] == -1)\n                dfs(graph, colors, nei, color);\n    }\n}\n```\n\n```python [solution1-Python]\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        # 1. Color each component.\n        # colors[node] = the color of this node.\n\n        N = len(graph)\n        colors = {}\n        c = 0\n\n        def dfs(node, color):\n            colors[node] = color\n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, color)\n\n        for node in xrange(N):\n            if node not in colors:\n                dfs(node, c)\n                c += 1\n\n        # 2. Size of each color.\n        # size[color] = number of occurrences of this color.\n        size = collections.Counter(colors.values())\n\n        # 3. Find unique colors.\n        color_count = collections.Counter()\n        for node in initial:\n            color_count[colors[node]] += 1\n\n        # 4. Answer\n        ans = float('inf')\n        for x in initial:\n            c = colors[x]\n            if color_count[c] == 1:\n                if ans == float('inf'):\n                    ans = x\n                elif size[c] > size[colors[ans]]:\n                    ans = x\n                elif size[c] == size[colors[ans]] and x < ans:\n                    ans = x\n\n        return ans if ans < float('inf') else min(initial)    \n```\n\n**复杂度分析**\n\n* 事件复杂度： $O(N^2)$，其中 $N$ 是 `graph` 的大小。\n\n* 空间复杂度： $O(N)$。\n\n#### 方法二： 并查集\n\n**思路和算法**\n\n同 *方法一* 一样，也得找出图中所有的连通分量，不同的是这一步用并查集来做。\n\n在并查集中会额外计算连通分量的大小，当合并两个连通分量的时候，会把它们的大小进行累加。\n\n借助并查集，可以用 *方法一* 中一样的思路处理：对于 `initial` 中每个颜色唯一的节点，都去计算连通分量的大小，从中找到最优解。如果 `initial` 中没有颜色唯一的节点，直接返回 `min(initial)`。\n\n简洁起见，实现的并查集没有根据 `rank` 合并，这会让渐进复杂度变大一点。\n\n```java [solution2-Java]\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        DSU dsu = new DSU(N);\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j)\n                if (graph[i][j] == 1)\n                    dsu.union(i, j);\n\n        int[] count = new int[N];\n        for (int node: initial)\n            count[dsu.find(node)]++;\n\n        int ans = -1, ansSize = -1;\n        for (int node: initial) {\n            int root = dsu.find(node);\n            if (count[root] == 1) {  // unique color\n                int rootSize = dsu.size(root);\n                if (rootSize > ansSize) {\n                    ansSize = rootSize;\n                    ans = node;\n                } else if (rootSize == ansSize && node < ans) {\n                    ansSize = rootSize;\n                    ans = node;\n                }\n            }\n        }\n\n        if (ans == -1) {\n            ans = Integer.MAX_VALUE;\n            for (int node: initial)\n                ans = Math.min(ans, node);\n        }\n        return ans;\n    }\n}\n\n\nclass DSU {\n    int[] p, sz;\n\n    DSU(int N) {\n        p = new int[N];\n        for (int x = 0; x < N; ++x)\n            p[x] = x;\n\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n\n    public int find(int x) {\n        if (p[x] != x)\n            p[x] = find(p[x]);\n        return p[x];\n    }\n\n    public void union(int x, int y) {\n        int xr = find(x);\n        int yr = find(y);\n        p[xr] = yr;\n        sz[yr] += sz[xr];\n    }\n\n    public int size(int x) {\n        return sz[find(x)];\n    }\n}\n```\n\n```python [solutino2-Python]\nclass DSU:\n    def __init__(self, N):\n        self.p = range(N)\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        self.p[xr] = yr\n        self.sz[yr] += self.sz[xr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\n\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        dsu = DSU(len(graph))\n\n        for j, row in enumerate(graph):\n            for i in xrange(j):\n                if row[i]:\n                    dsu.union(i, j)\n\n        count = collections.Counter(dsu.find(u) for u in initial)\n        ans = (-1, min(initial))\n        for node in initial:\n            root = dsu.find(node)\n            if count[root] == 1:  # unique color\n                if dsu.size(root) > ans[0]:\n                    ans = dsu.size(root), node\n                elif dsu.size(root) == ans[0] and node < ans[1]:\n                    ans = dsu.size(root), node\n\n        return ans[1]\n```\n\n**复杂度分析**\n\n* 时间复杂度： $O(N^2)$，其中 $N$ 是 `graph` 的大小。\n\n* 空间复杂度： $O(N)$。"
}