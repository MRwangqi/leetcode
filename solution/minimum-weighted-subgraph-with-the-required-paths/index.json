{
	"titleSlug": "minimum-weighted-subgraph-with-the-required-paths",
	"slug": "de-dao-yao-qiu-lu-jing-de-zui-xiao-dai-q-mj2c",
	"url": "https://leetcode-cn.com/problems/minimum-weighted-subgraph-with-the-required-paths/solution/de-dao-yao-qiu-lu-jing-de-zui-xiao-dai-q-mj2c/",
	"content": "#### 方法一：分析 + 三次最短路\n\n**提示 $1$**\n\n边权和最小的子图呈现「$Y$ 型」。\n\n**提示 $1$ 解释**\n\n首先我们可以知道，在边权和最小的子图中的任意两个点 $u$ 和 $v$，如果 $u$ 可以到达 $v$，那么从 $u$ 到 $v$ 一定只有**唯一**的一条简单路径。这是因为如果存在多条路径，我们也只会走最短的那一条，因此不在最短路径上的那些边都是无意义的，我们可以将它们移除。\n\n这样一来：\n\n- 从 $\\textit{src}_1$ 到 $\\textit{dest}$ 有唯一的一条简单路径，记为 $X$；\n\n- 从 $\\textit{src}_2$ 到 $\\textit{dest}$ 有唯一的一条简单路径，记为 $Y$。\n\n假设 $X$ 上第一个与 $Y$ 共有的节点为 $c$，显然这样的 $c$ 是一定存在的，因为 $\\textit{dest}$ 就是 $X$ 和 $Y$ 的一个共有节点（但可能存在更早的共有节点）。我们可以断定，从 $c$ 开始到 $\\textit{dest}$ 结束的这一部分，在 $X$ 和 $Y$ 中一定是**完全相同的**，这是因为 $c$ 到 $\\textit{dest}$ 一定只有唯一的一条简单路径，因此 $X$ 和 $Y$ 必定共有这条路径。因此，整个子图可以看成是三部分的并集：\n\n- 从 $\\textit{src}_1$ 到 $c$ 的一条简单路径；\n\n- 从 $\\textit{src}_2$ 到 $c$ 的一条简单路径；\n\n- 从 $c$ 到 $\\textit{dest}$ 的一条简单路径。\n\n此时子图的边权和即为这三部分的边权和之和，即子图呈现「$Y$ 型」。如果 $c$ 与 $\\textit{src}_1$，$\\textit{src}_2$ 或者 $\\textit{dest}$ 中的某个节点重合，那么也是满足要求的。\n\n**思路与算法**\n\n我们可以枚举 $c$ 来得到边权和最小的子图。此时，我们就需要计算出「从 $\\textit{src}_1$ 到 $c$」「从 $\\textit{src}_2$ 到 $c$」「从 $c$ 到 $\\textit{dest}$」这三部分的最短路径。\n\n对于「从 $\\textit{src}_1$ 到 $c$」「从 $\\textit{src}_2$ 到 $c$」这两部分而言，我们可以使用两次 $\\text{Dijkstra}$ 算法计算出以 $\\textit{src}_1$ 为出发点和以 $\\textit{src}_2$ 为出发点，到所有节点的最短路径长度。而对于「从 $c$ 到 $\\textit{dest}$」这一部分，我们可以将原图中的所有边反向，这样就变成了「从 $\\textit{dest}$ 到 $c$」。我们就可以使用 $\\text{Dijkstra}$ 算法计算出以 $\\textit{dest}$ 为出发点，到所有节点的最短路径长度。\n\n在得到了所有需要的最短路径的长度之后，我们就可以枚举 $c$ 得出答案了。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\n        vector<vector<pair<int, int>>> g(n), grev(n);\n        for (const auto& edge: edges) {\n            int x = edge[0], y = edge[1], z = edge[2];\n            g[x].emplace_back(y, z);\n            grev[y].emplace_back(x, z);\n        }\n        \n        auto dijkstra = [&n](const vector<vector<pair<int, int>>>& graph, int start) -> vector<long long> {\n            vector<long long> dist(n, -1);\n            dist[start] = 0;\n            vector<int> used(n);\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n            q.emplace(0, start);\n            \n            while (!q.empty()) {\n                int u = q.top().second;\n                q.pop();\n                if (used[u]) {\n                    continue;\n                }\n                used[u] = true;\n                \n                for (const auto& [v, weight]: graph[u]) {\n                    long long target = dist[u] + weight;\n                    if (dist[v] == -1 || target < dist[v]) {\n                        dist[v] = target;\n                        q.emplace(dist[v], v);\n                    }\n                }\n            }\n            \n            return dist;\n        };\n        \n        vector<long long> dist1 = dijkstra(g, src1);\n        vector<long long> dist2 = dijkstra(g, src2);\n        vector<long long> dist3 = dijkstra(grev, dest);\n        \n        long long ans = -1;\n        for (int i = 0; i < n; ++i) {\n            if (dist1[i] != -1 && dist2[i] != -1 && dist3[i] != -1) {\n                long long result = dist1[i] + dist2[i] + dist3[i];\n                if (ans == -1 || result < ans) {\n                    ans = result;\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n        g, grev = defaultdict(list), defaultdict(list)\n        for (x, y, z) in edges:\n            g[x].append((y, z))\n            grev[y].append((x, z))\n        \n        def dijkstra(graph: Dict[int, List[int]], start: int) -> List[int]:\n            dist = [-1] * n\n            dist[start] = 0\n            used = set()\n            q = [(0, start)]\n\n            while q:\n                u = heapq.heappop(q)[1]\n                if u in used:\n                    continue\n                \n                used.add(u)\n                for (v, weight) in graph[u]:\n                    target = dist[u] + weight\n                    if dist[v] == -1 or target < dist[v]:\n                        dist[v] = target\n                        heapq.heappush(q, (dist[v], v))\n            \n            return dist\n        \n        dist1, dist2, dist3 = dijkstra(g, src1), dijkstra(g, src2), dijkstra(grev, dest)\n        \n        ans = -1\n        for i in range(n):\n            if dist1[i] != -1 and dist2[i] != -1 and dist3[i] != -1:\n                result = dist1[i] + dist2[i] + dist3[i]\n                if ans == -1 or result < ans:\n                    ans = result\n        \n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + m \\log m)$，其中 $m$ 是数组 $\\textit{edges}$ 的长度。\n\n- 空间复杂度：$O(m)$，即为存储图和反向图的邻接表需要使用的空间。"
}