{
	"titleSlug": "image-overlap",
	"slug": "tu-xiang-zhong-die-by-leetcode",
	"url": "https://leetcode-cn.com/problems/image-overlap/solution/tu-xiang-zhong-die-by-leetcode/",
	"content": "#### 方法一：枚举偏移量并计数\n\n我们用二元组 `(x, y)` 表示对 `A` 的偏移量 `delta`，其中 `x` 表示向左（负数）或向右（正数），`y` 表示向上（负数）或向下（正数）。在枚举偏移量时，我们可以分别枚举 `A` 和 `B` 中的一个 `1`，此时 `delta` 即为 `A` 中的 `1` 到 `B` 中的 `1` 的偏移量。枚举偏移量的时间复杂度为 $O(N^4)$。随后，我们对于 `A` 中的每个位置，判断它经过偏移后在 `B` 中的位置是否为 `1`。这一步的时间复杂度为 $O(N^2)$。\n\n为了方便维护偏移量 `delta`，我们可以用 `Java` 中的 `java.awt.Point` 或者 `Python` 中的 `complex` 来表示偏移量。在优化方面，我们可以在枚举了 `delta` 之后进行记录，如果下一次枚举到了同样的 `delta`，就可以跳过并减少一次 $O(N^2)$ 的判断计算。这样做可以减少一定的运行时间，但不会降低时间复杂度。\n\n```Java [sol1]\nimport java.awt.Point;\n\nclass Solution {\n    public int largestOverlap(int[][] A, int[][] B) {\n        int N = A.length;\n        List<Point> A2 = new ArrayList(), B2 = new ArrayList();\n        for (int i = 0; i < N*N; ++i) {\n            if (A[i/N][i%N] == 1) A2.add(new Point(i/N, i%N));\n            if (B[i/N][i%N] == 1) B2.add(new Point(i/N, i%N));\n        }\n\n        Set<Point> Bset = new HashSet(B2);\n\n        int ans = 0;\n        Set<Point> seen = new HashSet();\n        for (Point a: A2) for (Point b: B2) {\n            Point delta = new Point(b.x - a.x, b.y - a.y);\n            if (!seen.contains(delta)) {\n                seen.add(delta);\n                int cand = 0;\n                for (Point p: A2)\n                    if (Bset.contains(new Point(p.x + delta.x, p.y + delta.y)))\n                        cand++;\n                ans = Math.max(ans, cand);\n            }\n        }\n\n        return ans;\n    }\n}\n```\n\n```Python [sol1]\nclass Solution(object):\n    def largestOverlap(self, A, B):\n        N = len(A)\n        A2 = [complex(r, c) for r, row in enumerate(A)\n              for c, v in enumerate(row) if v]\n        B2 = [complex(r, c) for r, row in enumerate(B)\n              for c, v in enumerate(row) if v]\n        Bset = set(B2)\n        seen = set()\n        ans = 0\n        for a in A2:\n            for b in B2:\n                d = b-a\n                if d not in seen:\n                    seen.add(d)\n                    ans = max(ans, sum(x+d in Bset for x in A2))\n        return ans\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(N^6)$，其中 $N$ 是数组 `A` 和 `B` 的边长。\n\n* 空间复杂度：$O(N^2)$。\n\n\n#### 方法二：直接对偏移量计数\n\n我们反向思考方法一，就可以得到一种新的方法。我们分别枚举 `A` 和 `B` 中的一个 `1`，计算出偏移量 `delta` 并放入计数器中。对于每一个 `delta`，如果它在计数器中出现了 `k` 次，那么偏移量为 `delta` 时，`A` 和 `B` 重合的 `1` 的数目就为 `k`。\n\n```Java [sol2]\nclass Solution {\n    public int largestOverlap(int[][] A, int[][] B) {\n        int N = A.length;\n        int[][] count = new int[2*N+1][2*N+1];\n        for (int i = 0; i < N; ++i)\n            for (int j = 0; j < N; ++j)\n                if (A[i][j] == 1)\n                    for (int i2 = 0; i2 < N; ++i2)\n                        for (int j2 = 0; j2 < N; ++j2)\n                            if (B[i2][j2] == 1)\n                                count[i-i2 +N][j-j2 +N] += 1;\n\n        int ans = 0;\n        for (int[] row: count)\n            for (int v: row)\n                ans = Math.max(ans, v);\n        return ans;\n    }\n}\n```\n\n```Python [sol2]\nclass Solution(object):\n    def largestOverlap(self, A, B):\n        N = len(A)\n        count = collections.Counter()\n        for i, row in enumerate(A):\n            for j, v in enumerate(row):\n                if v:\n                    for i2, row2 in enumerate(B):\n                        for j2, v2 in enumerate(row2):\n                            if v2:\n                                count[i-i2, j-j2] += 1\n        return max(count.values() or [0])\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(N^4)$，其中 $N$ 是数组 `A` 和 `B` 的边长。\n\n* 空间复杂度：$O(N^2)$。"
}