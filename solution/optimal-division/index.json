{
	"titleSlug": "optimal-division",
	"slug": "zui-you-chu-fa-by-leetcode-solution-lf4c",
	"url": "https://leetcode-cn.com/problems/optimal-division/solution/zui-you-chu-fa-by-leetcode-solution-lf4c/",
	"content": "#### 方法一：动态规划\n\n**思路**\n\n设 $\\textit{dp}[i][j]$ 表示数组 $\\textit{nums}$ 索引区间 $[i,j]$ 通过添加不同的符号从而可以获取的最小值与最大值为 $\\textit{minVal}_{(i,j)},\\textit{maxVal}_{(i,j)}$，以及它们对应的表达式字符串为 $\\textit{minStr}_{(i,j)},\\textit{maxStr}_{(i,j)}$。可以通过枚举不同的索引 $k$ 且满足 $k \\in [i,j]$，从而获取区间 $[i,j]$ 最大值与最小值以及对应的字符串表达式。\n\n+ 通过枚举 $k$ 满足 $k \\in [i,j)$ 将区间 $[i,j]$ 分为 $[i,k],[k+1,j]$ 左右两部分，则区间 $[i,j]$ 的最小值可以通过左边部分的最小值除以右边部分的最大值得到，最大值可以通过左边部分的最大值除以右边部分的最小值得到。\n\n+ 通过以上推论可以知道其中区间 $[i,j]$ 最大值与最小值动态规划的递推公式如下：\n$$\n\\textit{minVal}_{(i,j)} = \\min(\\dfrac{\\textit{minVal}_{(i,k)}}{\\textit{maxVal}_{(k+1,j)}}) \\qquad k \\in [i,j) \\\\\n\\textit{maxVal}_{(i,j)} = \\max(\\dfrac{\\textit{maxVal}_{(i,k)}}{\\textit{minVal}_{(k+1,j)}}) \\qquad k \\in [i,j) \\\\\n$$\n\n+ 枚举不同的 $k$ 时，当找到区间 $[i,j]$ 的最小值与最大值时，还需要同时记录最大值与最小值时对应的表达式字符串 $\\textit{minStr}_{(i,j)},\\textit{maxStr}_{(i,j)}$。由于除法运算是从左到右的，也就是最左边的除法默认先执行，所以不需要给左边部分添加括号，但需要给右边部分添加括号。比方假设左边部分是 $\\texttt{\"2\"}$ ，右边部分是 $\\texttt{\"3/4\"}$，那么结果字符串 $\\texttt{\"2/(3/4)\"}$。如果右边部分只有一个数字，题目要求返回结果不含有冗余括号，此时也不需要添加括号。假如左边部分是 $\\texttt{\"2\"}$ 且右边部分是 $\\texttt{\"3\"}$ （只包含单个数字），那么答案应该是 $\\texttt{\"2/3\"}$ 而不是 $\\texttt{\"2/(3)\"}$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Node:\n    def __init__(self):\n        self.minVal = 1e4\n        self.maxVal = 0\n        self.minStr = \"\"\n        self.maxStr = \"\"\n\nclass Solution:\n    def optimalDivision(self, nums: List[int]) -> str:\n        n = len(nums)\n        dp = [[Node() for _ in range(n)] for _ in range(n)]\n        for i, num in enumerate(nums):\n            dp[i][i].minVal = num\n            dp[i][i].maxVal = num\n            dp[i][i].minStr = str(num)\n            dp[i][i].maxStr = str(num)\n        for i in range(n):\n            for j in range(n - i):\n                for k in range(j, j + i):\n                    if dp[j][j + i].maxVal < dp[j][k].maxVal / dp[k + 1][j + i].minVal:\n                        dp[j][j + i].maxVal = dp[j][k].maxVal / dp[k + 1][j + i].minVal\n                        if k + 1 == j + i:\n                            dp[j][j + i].maxStr = dp[j][k].maxStr + \"/\" + dp[k + 1][j + i].minStr\n                        else:\n                            dp[j][j + i].maxStr = dp[j][k].maxStr + \"/(\" + dp[k + 1][j + i].minStr + \")\"\n                    if dp[j][j + i].minVal > dp[j][k].minVal / dp[k + 1][j + i].maxVal:\n                        dp[j][j + i].minVal = dp[j][k].minVal / dp[k + 1][j + i].maxVal\n                        if k + 1 == j + i:\n                            dp[j][j + i].minStr = dp[j][k].minStr + \"/\" + dp[k + 1][j + i].maxStr\n                        else:\n                            dp[j][j + i].minStr = dp[j][k].minStr + \"/(\" + dp[k + 1][j + i].maxStr + \")\"\n        return dp[0][n - 1].maxStr\n```\n\n```C++ [sol1-C++]\nstruct Node {\n    double maxVal, minVal;\n    string minStr, maxStr;\n    Node() {\n        this->minVal = 10000.0;\n        this->maxVal = 0.0;\n    }\n};\n\nclass Solution {\npublic:\n    string optimalDivision(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<Node>> dp(n, vector<Node>(n));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][i].minVal = nums[i];\n            dp[i][i].maxVal = nums[i];\n            dp[i][i].minStr = to_string(nums[i]);\n            dp[i][i].maxStr = to_string(nums[i]);\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j + i < n; j++) {\n                for (int k = j; k < j + i; k++) {\n                    if (dp[j][j + i].maxVal < dp[j][k].maxVal / dp[k + 1][j + i].minVal) {\n                        dp[j][j + i].maxVal = dp[j][k].maxVal / dp[k + 1][j + i].minVal;\n                        if (k + 1 == j + i) {\n                            dp[j][j + i].maxStr = dp[j][k].maxStr + \"/\" + dp[k + 1][j + i].minStr;\n                        } else {\n                            dp[j][j + i].maxStr = dp[j][k].maxStr + \"/(\" + dp[k + 1][j + i].minStr + \")\";\n                        }\n                    }\n                    if (dp[j][j + i].minVal > dp[j][k].minVal / dp[k + 1][j + i].maxVal) {\n                        dp[j][j + i].minVal = dp[j][k].minVal / dp[k + 1][j + i].maxVal;\n                        if (k + 1 == j + i) {\n                            dp[j][j + i].minStr = dp[j][k].minStr + \"/\" + dp[k + 1][j + i].maxStr; \n                        } else {\n                            dp[j][j + i].minStr = dp[j][k].minStr + \"/(\" + dp[k + 1][j + i].maxStr + \")\"; \n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][n - 1].maxStr;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String optimalDivision(int[] nums) {\n        int n = nums.length;\n        Node[][] dp = new Node[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                dp[i][j] = new Node();\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            dp[i][i].minVal = nums[i];\n            dp[i][i].maxVal = nums[i];\n            dp[i][i].minStr = String.valueOf(nums[i]);\n            dp[i][i].maxStr = String.valueOf(nums[i]);\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j + i < n; j++) {\n                for (int k = j; k < j + i; k++) {\n                    if (dp[j][j + i].maxVal < dp[j][k].maxVal / dp[k + 1][j + i].minVal) {\n                        dp[j][j + i].maxVal = dp[j][k].maxVal / dp[k + 1][j + i].minVal;\n                        if (k + 1 == j + i) {\n                            dp[j][j + i].maxStr = dp[j][k].maxStr + \"/\" + dp[k + 1][j + i].minStr;\n                        } else {\n                            dp[j][j + i].maxStr = dp[j][k].maxStr + \"/(\" + dp[k + 1][j + i].minStr + \")\";\n                        }\n                    }\n                    if (dp[j][j + i].minVal > dp[j][k].minVal / dp[k + 1][j + i].maxVal) {\n                        dp[j][j + i].minVal = dp[j][k].minVal / dp[k + 1][j + i].maxVal;\n                        if (k + 1 == j + i) {\n                            dp[j][j + i].minStr = dp[j][k].minStr + \"/\" + dp[k + 1][j + i].maxStr; \n                        } else {\n                            dp[j][j + i].minStr = dp[j][k].minStr + \"/(\" + dp[k + 1][j + i].maxStr + \")\"; \n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][n - 1].maxStr;\n    }\n}\n\nclass Node {\n    double maxVal, minVal;\n    String minStr, maxStr;\n\n    public Node() {\n        this.minVal = 10000.0;\n        this.maxVal = 0.0;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string OptimalDivision(int[] nums) {\n        int n = nums.Length;\n        Node[,] dp = new Node[n, n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                dp[i, j] = new Node();\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            dp[i, i].MinVal = nums[i];\n            dp[i, i].MaxVal = nums[i];\n            dp[i, i].MinStr = nums[i].ToString();\n            dp[i, i].MaxStr = nums[i].ToString();\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j + i < n; j++) {\n                for (int k = j; k < j + i; k++) {\n                    if (dp[j, j + i].MaxVal < dp[j, k].MaxVal / dp[k + 1, j + i].MinVal) {\n                        dp[j, j + i].MaxVal = dp[j, k].MaxVal / dp[k + 1, j + i].MinVal;\n                        if (k + 1 == j + i) {\n                            dp[j, j + i].MaxStr = dp[j, k].MaxStr + \"/\" + dp[k + 1, j + i].MinStr;\n                        } else {\n                            dp[j, j + i].MaxStr = dp[j, k].MaxStr + \"/(\" + dp[k + 1, j + i].MinStr + \")\";\n                        }\n                    }\n                    if (dp[j, j + i].MinVal > dp[j, k].MinVal / dp[k + 1, j + i].MaxVal) {\n                        dp[j, j + i].MinVal = dp[j, k].MinVal / dp[k + 1, j + i].MaxVal;\n                        if (k + 1 == j + i) {\n                            dp[j, j + i].MinStr = dp[j, k].MinStr + \"/\" + dp[k + 1, j + i].MaxStr; \n                        } else {\n                            dp[j, j + i].MinStr = dp[j, k].MinStr + \"/(\" + dp[k + 1, j + i].MaxStr + \")\"; \n                        }\n                    }\n                }\n            }\n        }\n        return dp[0, n - 1].MaxStr;\n    }\n}\n\nclass Node {\n    public double MaxVal { get; set; }\n    public double MinVal { get; set; }\n    public string MinStr { get; set; }\n    public string MaxStr { get; set; }\n\n    public Node() {\n        this.MinVal = 10000.0;\n        this.MaxVal = 0.0;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX_STR_LEN 64\n\ntypedef struct {\n    double maxVal, minVal;\n    char minStr[MAX_STR_LEN], maxStr[MAX_STR_LEN];\n} Node;\n\nchar * optimalDivision(int* nums, int numsSize){\n    Node ** dp = (Node **)malloc(sizeof(Node *) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        dp[i] = (Node *)malloc(sizeof(Node) * numsSize);\n    }\n    for (int i = 0; i < numsSize; i++) {\n        for (int j = 0; j < numsSize; j++) {\n            dp[i][j].minVal = 10000.0;\n            dp[i][j].maxVal = 0.0;\n        }\n        dp[i][i].minVal = nums[i];\n        dp[i][i].maxVal = nums[i];\n        snprintf(dp[i][i].minStr, MAX_STR_LEN, \"%d\", nums[i]);\n        snprintf(dp[i][i].maxStr, MAX_STR_LEN, \"%d\", nums[i]);\n    }\n    for (int i = 1; i < numsSize; i++) {\n        for (int j = 0; j + i < numsSize; j++) {\n            for (int k = j ; k < j + i; k++) {\n                if (dp[j][j + i].maxVal < dp[j][k].maxVal / dp[k + 1][j + i].minVal) {\n                    dp[j][j + i].maxVal = dp[j][k].maxVal / dp[k + 1][j + i].minVal;\n                    if (k + 1 == j + i) {\n                        snprintf(dp[j][j + i].maxStr, MAX_STR_LEN, \"%s/%s\", dp[j][k].maxStr, dp[k + 1][j + i].minStr);\n                    } else {\n                        snprintf(dp[j][j + i].maxStr, MAX_STR_LEN, \"%s/(%s)\", dp[j][k].maxStr, dp[k + 1][j + i].minStr);\n                    }\n                }\n                if (dp[j][j + i].minVal > dp[j][k].minVal / dp[k + 1][j + i].maxVal) {\n                    dp[j][j + i].minVal = dp[j][k].minVal / dp[k + 1][j + i].maxVal;\n                    if (k + 1 == j + i) {\n                        snprintf(dp[j][j + i].minStr, MAX_STR_LEN, \"%s/%s\", dp[j][k].minStr, dp[k + 1][j + i].maxStr);\n                    } else {\n                        snprintf(dp[j][j + i].minStr, MAX_STR_LEN, \"%s/(%s)\", dp[j][k].minStr, dp[k + 1][j + i].maxStr);\n                    }\n                }\n            }\n        }\n    };\n    char * ans = (char *)malloc(sizeof(char) * (strlen(dp[0][numsSize-1].maxStr) + 1));\n    strcpy(ans, dp[0][numsSize-1].maxStr);\n    for (int i = 0; i < numsSize; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar optimalDivision = function(nums) {\n    const n = nums.length;\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    for (let i = 0; i < n; i++) {\n        for (let j = i; j < n; j++) {\n            dp[i][j] = new Node();\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        dp[i][i].minVal = nums[i];\n        dp[i][i].maxVal = nums[i];\n        dp[i][i].minStr = '' + nums[i];\n        dp[i][i].maxStr = '' + nums[i];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j + i < n; j++) {\n            for (let k = j; k < j + i; k++) {\n                if (dp[j][j + i].maxVal < dp[j][k].maxVal / dp[k + 1][j + i].minVal) {\n                    dp[j][j + i].maxVal = dp[j][k].maxVal / dp[k + 1][j + i].minVal;\n                    if (k + 1 === j + i) {\n                        dp[j][j + i].maxStr = dp[j][k].maxStr + \"/\" + dp[k + 1][j + i].minStr;\n                    } else {\n                        dp[j][j + i].maxStr = dp[j][k].maxStr + \"/(\" + dp[k + 1][j + i].minStr + \")\";\n                    }\n                }\n                if (dp[j][j + i].minVal > dp[j][k].minVal / dp[k + 1][j + i].maxVal) {\n                    dp[j][j + i].minVal = dp[j][k].minVal / dp[k + 1][j + i].maxVal;\n                    if (k + 1 === j + i) {\n                        dp[j][j + i].minStr = dp[j][k].minStr + \"/\" + dp[k + 1][j + i].maxStr; \n                    } else {\n                        dp[j][j + i].minStr = dp[j][k].minStr + \"/(\" + dp[k + 1][j + i].maxStr + \")\"; \n                    }\n                }\n            }\n        }\n    }\n    return dp[0][n - 1].maxStr;\n};\n\nclass Node {\n    constructor() {\n        this.maxStr;\n        this.minStr;\n        this.minVal = 10000.0;\n        this.maxVal = 0.0;\n    }\n}\n```\n\n```go [sol1-Golang]\ntype node struct {\n    minVal, maxVal float64\n    minStr, maxStr string\n}\n\nfunc optimalDivision(nums []int) string {\n    n := len(nums)\n    dp := make([][]node, n)\n    for i := range dp {\n        dp[i] = make([]node, n)\n        for j := range dp[i] {\n            dp[i][j].minVal = 1e4\n        }\n    }\n\n    for i, num := range nums {\n        dp[i][i].minVal = float64(num)\n        dp[i][i].maxVal = float64(num)\n        dp[i][i].minStr = strconv.Itoa(num)\n        dp[i][i].maxStr = strconv.Itoa(num)\n    }\n    for i := 1; i < n; i++ {\n        for j := 0; j+i < n; j++ {\n            for k := j; k < j+i; k++ {\n                if dp[j][j+i].maxVal < dp[j][k].maxVal/dp[k+1][j+i].minVal {\n                    dp[j][j+i].maxVal = dp[j][k].maxVal / dp[k+1][j+i].minVal\n                    if k+1 == j+i {\n                        dp[j][j+i].maxStr = dp[j][k].maxStr + \"/\" + dp[k+1][j+i].minStr\n                    } else {\n                        dp[j][j+i].maxStr = dp[j][k].maxStr + \"/(\" + dp[k+1][j+i].minStr + \")\"\n                    }\n                }\n                if dp[j][j+i].minVal > dp[j][k].minVal/dp[k+1][j+i].maxVal {\n                    dp[j][j+i].minVal = dp[j][k].minVal / dp[k+1][j+i].maxVal\n                    if k+1 == j+i {\n                        dp[j][j+i].minStr = dp[j][k].minStr + \"/\" + dp[k+1][j+i].maxStr\n                    } else {\n                        dp[j][j+i].minStr = dp[j][k].minStr + \"/(\" + dp[k+1][j+i].maxStr + \")\"\n                    }\n                }\n            }\n        }\n    }\n    return dp[0][n-1].maxStr\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^3)$，其中 $n$ 为数组的长度。$\\textit{dp}$ 数组的大小为 $n^2$，计算 $\\textit{dp}$ 中的每一项元素需要 $O(n)$ 的时间复杂度。\n\n- 空间复杂度：$O(n^3)$，其中 $n$ 表示数组的长度。$\\textit{dp}$ 数组的长度为 $n^2$，其中数组中元素的长度最长为 $O(n)$。\n\n#### 方法二：数学\n\n**思路**\n\n使用一些简单的数学技巧，我们可以找到解决这个问题的简单解法。考虑到除法运算用分数 $\\dfrac{x}{y}$ 来表示，其中分子 $x$ 为被除数，分母 $y$ 为除数，为了最大化 $\\dfrac{x}{y}$，应该使分子 $x$ 尽可能的大，分母 $y$ 尽可能的小。\n+ 假设当前的整数序列为 $[\\textit{nums}_0, \\textit{nums}_1, \\cdots , \\textit{nums}_{n-1}]$，相邻元素相除形式为 $[\\textit{nums}_0 \\div \\textit{nums}_1 \\div \\cdots \\div \\textit{nums}_{n-1}]$，最终的结果一定可以表达为分数的形式 $\\dfrac{x}{y}$，不论如何添加括号改变优先级可以知道分子 $x$ 的最大值为 $\\textit{nums}_0$。通过添加括号使得剩余的表达式 $\\textit{nums}_1 \\div \\textit{nums}_2 \\div \\cdots \\div \\textit{nums}_{n-1}$ 构成的分母 $y$ 最小即可。由于数组 $\\textit{nums}$ 中的每个元素都大于 $1$，因此通过直观的观察可以知道 $y = \\textit{nums}_1 \\div \\textit{nums}_2 \\div \\cdots \\div \\textit{nums}_{n-1}$ 时值最小，由上述结论可以知道当满足 $\\dfrac{x}{y} = \\dfrac{\\textit{nums}_0}{\\textit{nums}_1 \\div \\textit{nums}_2 \\div \\cdots \\div \\textit{nums}_{n-1}}$ 时，数组构成的表达式计算结果为最大。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def optimalDivision(self, nums: List[int]) -> str:\n        if len(nums) == 1:\n            return str(nums[0])\n        if len(nums) == 2:\n            return str(nums[0]) + \"/\" + str(nums[1])\n        return str(nums[0]) + \"/(\" + \"/\".join(map(str, nums[1:])) + \")\"\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    string optimalDivision(vector<int>& nums) {\n        int n = nums.size();        \n        if (n == 1) {\n            return to_string(nums[0]);\n        }\n        if (n == 2) {\n            return to_string(nums[0]) + \"/\" + to_string(nums[1]);\n        }\n        string res = to_string(nums[0]) + \"/(\" + to_string(nums[1]);\n        for (int i = 2; i < n; i++) {\n            res.append(\"/\" + to_string(nums[i]));\n        }\n        res.append(\")\");\n        return res;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public String optimalDivision(int[] nums) {\n        int n = nums.length;        \n        if (n == 1) {\n            return String.valueOf(nums[0]);\n        }\n        if (n == 2) {\n            return String.valueOf(nums[0]) + \"/\" + String.valueOf(nums[1]);\n        }\n        StringBuffer res = new StringBuffer();\n        res.append(nums[0]);\n        res.append(\"/(\");\n        res.append(nums[1]);\n        for (int i = 2; i < n; i++) {\n            res.append(\"/\");\n            res.append(nums[i]);\n        }\n        res.append(\")\");\n        return res.toString();\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public string OptimalDivision(int[] nums) {\n        int n = nums.Length;        \n        if (n == 1) {\n            return nums[0].ToString();\n        }\n        if (n == 2) {\n            return nums[0].ToString() + \"/\" + nums[1].ToString();\n        }\n        StringBuilder res = new StringBuilder();\n        res.Append(nums[0]);\n        res.Append(\"/(\");\n        res.Append(nums[1]);\n        for (int i = 2; i < n; i++) {\n            res.Append(\"/\");\n            res.Append(nums[i]);\n        }\n        res.Append(\")\");\n        return res.ToString();\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX_STR_LEN 64\n\nchar * optimalDivision(int* nums, int numsSize) {\n    char * res = (char *)malloc(sizeof(char) * MAX_STR_LEN);\n    if (numsSize == 1) {\n        sprintf(res, \"%d\", nums[0]);\n        return res;\n    }\n    if (numsSize == 2) {\n        sprintf(res, \"%d/%d\", nums[0], nums[1]);\n        return res;\n    }\n    sprintf(res, \"%d/(%d\", nums[0], nums[1]);\n    int pos = strlen(res);\n    char str[5];\n    for (int i = 2; i < numsSize; i++) {\n        sprintf(str, \"%d\", nums[i]);\n        sprintf(res + pos, \"/%s\", str);\n        pos += strlen(str) + 1;\n    }\n    sprintf(res + pos, \"%s\", \")\");\n    return res;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar optimalDivision = function(nums) {\n    const n = nums.length;        \n    if (n === 1) {\n        return '' + nums[0];\n    }\n    if (n === 2) {\n        return '' + nums[0] + \"/\" + '' + nums[1];\n    }\n    const res = [];\n    res.push(nums[0]);\n    res.push(\"/(\");\n    res.push(nums[1]);\n    for (let i = 2; i < n; i++) {\n        res.push(\"/\");\n        res.push(nums[i]);\n    }\n    res.push(\")\");\n    return res.join('');\n};\n```\n\n```go [sol2-Golang]\nfunc optimalDivision(nums []int) string {\n    n := len(nums)\n    if n == 1 {\n        return strconv.Itoa(nums[0])\n    }\n    if n == 2 {\n        return fmt.Sprintf(\"%d/%d\", nums[0], nums[1])\n    }\n    ans := &strings.Builder{}\n    ans.WriteString(fmt.Sprintf(\"%d/(%d\", nums[0], nums[1]))\n    for _, num := range nums[2:] {\n        ans.WriteByte('/')\n        ans.WriteString(strconv.Itoa(num))\n    }\n    ans.WriteByte(')')\n    return ans.String()\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组的长度。只需要遍历一遍数组即可，所以时间复杂度为 $O(n)$。\n\n- 空间复杂度：$O(1)$。除函数返回值以外，不需要额外的存储空间。"
}