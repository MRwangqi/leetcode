{
	"titleSlug": "Za25hA",
	"slug": "by-qin-qi-shu-hua-2-ybb3",
	"url": "https://leetcode-cn.com/problems/Za25hA/solution/by-qin-qi-shu-hua-2-ybb3/",
	"content": "环的边数等于顶点数，链的边数等于顶点数-1，从环上面延伸出去的链的边数等于顶点数（在环上的起始顶点需要去除）。\n所以说图中只有1个环，且环上任意点都可以延伸出去链，这样都可以满足顶点数等于边数。\n由于题意中说所有点全连通，所以不存在两个不相连的环。而两个环相连时， 两个环延伸出去的链需要相连，会多出一条边，所以不存在两个及以上的环。\n通过题目提供的边，使用哈希表记录每个点的其他联通点，并记录每个点的度（当每个点出现在一条边中，度+1）。\n由于链一定存在最外侧的某个顶点度数为1，而其他非链头的链节点或者环节点度数都大于1。\n如果说不存在度数为1的节点，那么整个图就为一个环，如果环的顶点数大于3且两人初始不相邻则无法抓到。\n由于顶点数小于等于3时两人一定相邻，所以可以简化为如果两人相临则可以在第一回合抓到，否则永远都抓不到。\n如果存在度数为1的节点，那么从链头（度数为1）开始bfs，可以将所有的非环链去除。这样就可以找到所有的链节点和环节点。\n通过bfs找到两个人起点位置到每一个节点的最小路径值。\n遍历每个节点，计算两人到达此节点的最小路径值，由于小力先行动，所以小力的路径值比小扣大1时也可以抓到小扣。\n所以小力的路径值 - 1如果小于等于小扣的路径值时，说明小力先到达，小扣到达不了，可以忽略。\n当小力的路径值 - 1 如果大于小扣的路径值时，小扣可以先到达此点且不被抓到。\n此处如果是环且环的大小大于3时，说明小扣先到达环上，小力永远无法抓到。\n而此处如果是链时，小扣可以到达此节点后等待小力过来，所以小力需要耗费的回合数等于小力的路径值。\n记录每个链节点的最大路径值就是小力能抓到小扣的最小回合数。\n```\nclass Solution:\n    def chaseGame(self, edges: List[List[int]], startA: int, startB: int) -> int:\n        def bfs(x):#bfs记录x节点到其他所有节点的最小路径长度\n            deq = collections.deque()\n            deq.append((0, x))\n            visit = [0 for i in range(l)]\n            visit[x] = 1\n            res = [0 for i in range(l)]\n            while deq:\n                c, i = deq.popleft()\n                res[i] = c\n                for j in d[i]:\n                    if visit[j] == 0:\n                        visit[j] = 1\n                        deq.append([c + 1, j])\n            return res\n        startA -= 1#由于题目中的节点为[1, n]， 改为[0, n - 1]更便于计算，所以所有节点值 - 1\n        startB -= 1\n        l = len(edges)#边数等于顶点数\n        d = collections.defaultdict(set)#记录每个节点的其他相连节点\n        degree = [0 for i in range(l)]#每个节点的度数\n        for i, j in edges:\n            i -= 1\n            j -= 1\n            d[i].add(j)\n            d[j].add(i)\n            degree[i] += 1\n            degree[j] += 1\n        if startA in d[startB]:#如果说两点相连，说明第一回合就可以抓到\n            return 1\n        elif degree.count(1) == 0:#没有链节点且环大小超过3，则永远抓不到\n            return -1\n        else:\n            visit = [0 for i in range(l)]#记录每个节点的访问情况\n            deq = collections.deque()#bfs队列从链头开始遍历\n            for i in range(l):\n                if degree[i] == 1:#如果是链头\n                    visit[i] = 1\n                    deq.append(i)#加入队列\n            while deq:\n                i = deq.popleft()\n                for j in d[i]:\n                    if visit[j] == 0:\n                        degree[j] -= 1#度数-1\n                        if degree[j] == 1:#如果度数为1说明链未结束，继续入列\n                            visit[j] = 1\n                            deq.append(j)\n            A = bfs(startA)#小力到达其他点的最小路径值\n            B = bfs(startB)#小扣到达其他点的最小路径值\n            c = degree.count(2)#环节点的数量\n            res = 0#最小回合数\n            for i in range(l):\n                if degree[i] == 1:#如果是链节点\n                    if A[i] - 1 > B[i]:#如果小扣可以先到达且不被抓\n                        res = max(res, A[i])#小力需要A[i]回合才能到达，更新最大值\n                else:#如果是环节点\n                    if c > 3 and A[i] - 1 > B[i]:#如果小扣可以先到达，说明永远无法抓到\n                        return -1\n            return res #返回最大值\n```\n\n"
}