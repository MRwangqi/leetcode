{
	"titleSlug": "encrypt-and-decrypt-strings",
	"slug": "jia-mi-jie-mi-zi-fu-chuan-by-leetcode-so-mqga",
	"url": "https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/solution/jia-mi-jie-mi-zi-fu-chuan-by-leetcode-so-mqga/",
	"content": "#### 方法一：直接加密 + 预处理解密\n\n**思路与算法**\n\n我们首先可以使用 $\\textit{enc}$ 哈希映射存储单个字母的加密关系，即对于 $\\textit{enc}$ 中的每个键值对，键表示单个字母，值表示该字母加密得到的长度为 $2$ 的字符串。这样一来，对于 $\\texttt{encrypt(word)}$ 操作，我们只需要遍历字符串 $\\textit{word}$，对每个字母分别根据哈希映射进行加密，再合并结果得到最终的字符串即可。\n\n而对于 $\\texttt{decrypt(word)}$ 操作，如果我们直接按照题目中的要求进行分组、解密、判断是否在字典中，那么必然会使用深度优先搜索或者更高级的数据结构（例如字典树）。一种更简单的方法是「逆向思考」：我们直接把字典中的所有单词进行加密，如果该单词可以被加密，那么我们就将加密的结果存储在另一个哈希映射 $\\textit{dec\\_count}$ 中，键表示加密的结果，值表示该结果出现的次数（因为多个单词可以被加密成相同的结果）。这样一来，我们只需要返回 $\\textit{word}$ 作为键在哈希映射中对应的值即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Encrypter {\nprivate:\n    unordered_map<char, string> enc;\n    unordered_map<string, int> dec_count;\n    \npublic:\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\n        int n = keys.size();\n        for (int i = 0; i < n; ++i) {\n            enc[keys[i]] = values[i];\n        }\n        \n        for (const string& word: dictionary) {\n            string result = encrypt(word);\n            if (result != \"\") {\n                ++dec_count[result];\n            }\n        }\n    }\n    \n    string encrypt(string word1) {\n        string result;\n        for (char ch: word1) {\n            if (enc.count(ch)) {\n                result += enc[ch];\n            }\n            else {\n                return \"\";\n            }\n        }\n        return result;\n    }\n    \n    int decrypt(string word2) {\n        return dec_count.count(word2) ? dec_count[word2] : 0;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Encrypter:\n\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\n        self.enc = {key: value for key, value in zip(keys, values)}\n        self.dec_count = Counter()\n        for word in dictionary:\n            if (result := self.encrypt(word)) != \"\":\n                self.dec_count[result] += 1 \n\n    def encrypt(self, word1: str) -> str:\n        result = list()\n        for ch in word1:\n            if ch in self.enc:\n                result.append(self.enc[ch])\n            else:\n                return \"\"\n        return \"\".join(result)\n\n    def decrypt(self, word2: str) -> int:\n        return self.dec_count[word2] if word2 in self.dec_count else 0\n```\n\n**复杂度分析**\n\n- 时间复杂度：\n\n    - 初始化的时间复杂度为 $O(k + d \\times l_d)$，其中 $k$ 分别是数组 $\\textit{keys}$ 和 $\\textit{values}$ 的长度，$d$ 是数组 $\\textit{dictionary}$ 的长度，$l_d$ 是数组 $\\textit{dictionary}$ 中单词的平均长度；\n\n    - $\\texttt{encrypt(word)}$ 的时间复杂度为 $O(|\\textit{word}|)$；\n\n    - $\\texttt{decrypt(word)}$ 的时间复杂度为 $O(|\\textit{word}|)$。\n\n- 空间复杂度：$O(k + d \\times l_d)$，即为两个哈希映射需要使用的空间。"
}