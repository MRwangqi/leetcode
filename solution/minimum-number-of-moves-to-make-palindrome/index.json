{
	"titleSlug": "minimum-number-of-moves-to-make-palindrome",
	"slug": "tan-xin-zheng-ming-geng-da-shu-ju-fan-we-h57i",
	"url": "https://leetcode-cn.com/problems/minimum-number-of-moves-to-make-palindrome/solution/tan-xin-zheng-ming-geng-da-shu-ju-fan-we-h57i/",
	"content": "## 解法：贪心\r\n经典的题目。原题参见 https://www.codechef.com/problems/ENCD12\r\n\r\n由于题目保证原串一定可以变成回文串，那么原串中最多只有一种字母出现奇数次。如果有一种字母出现奇数次，那么将该字母中排在最中间的字符移动到字符串中间，剩下的字符可以转化为所有字母均出现偶数次的情况。\r\n\r\n贪心算法是：每次固定字符串最左边的字母 $a$ 不变，找出距离字符串右侧最近的 $a$，把它交换到字符串最右边。这样字符串的头尾字母就相等了。把字符串的头尾去掉，就变成了子问题。把所有子问题的答案加起来就是最少交换次数。\r\n\r\n由于数据范围较小，通过 $\\mathcal{O}(n^2)$ 的模拟即可通过本题。\r\n\r\n### 证明\r\n构造回文串的过程，实际上是每次选择一对字母并把它们交换到字符串头尾的过程。考虑字母 $x$ 和字母 $y$ 哪个先选，分以下情况讨论：\r\n* 字母 $x$ 和 $y$ 的位置满足 $\\underbrace{\\cdots}_{a\\text{ 个字母}}x\\underbrace{\\cdots}_{b\\text{ 个字母}}y\\underbrace{\\cdots}_{c\\text{ 个字母}}y\\underbrace{\\cdots}_{d\\text{ 个字母}}x\\underbrace{\\cdots}_{e\\text{ 个字母}}$。如果先把 $x$ 换到头尾，再把 $y$ 换到头尾，那么需要 $(a + e) + (b + d)$ 次交换；如果先换 $y$ 再换 $x$，那么需要 $(a + b + 1 + d + e + 1) + (a + e)$ 次交换。显然先换 $x$ 更优。\r\n* 字母 $x$ 和 $y$ 的位置满足 $\\underbrace{\\cdots}_{a\\text{ 个字母}}x\\underbrace{\\cdots}_{b\\text{ 个字母}}y\\underbrace{\\cdots}_{c\\text{ 个字母}}x\\underbrace{\\cdots}_{d\\text{ 个字母}}y\\underbrace{\\cdots}_{e\\text{ 个字母}}$。如果先换 $x$ 再换 $y$，那么需要 $(a + d + e + 1) + (a + b + e)$ 次交换；如果先换 $y$ 再换 $x$，那么需要 $(a + b + 1 + e) + (a + d + e)$ 次交换。先换哪个都一样。\r\n* 字母 $x$ 和 $y$ 的位置满足 $\\underbrace{\\cdots}_{a\\text{ 个字母}}x\\underbrace{\\cdots}_{b\\text{ 个字母}}x\\underbrace{\\cdots}_{c\\text{ 个字母}}y\\underbrace{\\cdots}_{d\\text{ 个字母}}y\\underbrace{\\cdots}_{e\\text{ 个字母}}$。如果先换 $x$ 再换 $y$，那么需要 $(a + c + d + e + 2) + (a + b + c + e)$ 次交换；如果先换 $y$ 再换 $x$，那么需要 $(a + b + c + 2 + e) + (a + c + d + e)$ 次交换。先换哪个都一样。\r\n\r\n上述讨论可以得到结论：每次交换最外边出现的字母不劣。因此贪心解法成立。\r\n\r\n## 参考代码（c++）\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int minMovesToMakePalindrome(string s) {\r\n        int n = s.size(), ans = 0;\r\n        for (int i = 0, j = n - 1; i < j; i++) {\r\n            for (int k = j; i != k; k--) if (s[i] == s[k]) {\r\n                // 字母出现偶数次的情况，模拟交换\r\n                for (; k < j; k++) swap(s[k], s[k + 1]), ans++;\r\n                j--;\r\n                goto OK;\r\n            }\r\n            // 字母出现奇数次的情况，计算它距离中间还有多少距离\r\n            ans += n / 2 - i;\r\n            OK: continue;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n## 拓展\r\n如果数据范围拓展为 `s.length <= 100000` 应该如何解决？\r\n\r\n原题参见 https://www.luogu.com.cn/problem/P5041\r\n\r\n### 提示\r\n通过双端队列维护每个字母出现的位置，并用树状数组维护哪些位置的字母已经被交换出去。复杂度 $\\mathcal{O}(n\\log n)$。\r\n"
}