{
	"titleSlug": "longest-subsequence-repeated-k-times",
	"slug": "by-ffreturn-cmbr",
	"url": "https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times/solution/by-ffreturn-cmbr/",
	"content": "![image.png](https://pic.leetcode-cn.com/1656228866-HJpeWN-image.png)\n\n\n### 解题思路\n思路\n- 直白的解法dfs去解决\n- 优化点\n   - 考虑到 n < k * 8,那么最大字符串长度就是8，这里用一个固定的字符数组，减少字符串的性能损耗\n   - 按照计数值遍历可能满足条件的字符：即数量>=k的字符我们才考虑\n   - 遍历先后往前，即前面字典序更大，且只有更大时候才增加字符串，一旦找到结果就可以结束了\n\n### 代码\n\n```cpp\nclass Solution {\nprivate:\n    int char2cnt[26] = {0};\n    int k;\n    string res;\n    string valid; // 即满足数量的字符串的字符, 是按照字母的倒序排列的\n    char c[8]; // 最大字符串的长度\n\n    // 判断是否满足条件, l表示字符长度\n    bool isOk(const string& s, int l)\n    {\n        // 当前的位置，从0开始找\n        int cursor = 0;\n        for (int i = 0; i < k; ++i)\n        {\n            // 遍历所有的字符是否满足条件\n            for (int j = 0; j < l; ++j)\n            {\n                // 不算往后找\n                auto pos = s.find(c[j], cursor);\n                if (pos == string::npos)\n                {\n                    return false;\n                }\n                cursor = pos + 1;\n            }\n        }\n\n        return true;\n    }\n\n    // 递归函数, i表示结果字符的序号，从0开始\n    void dfs(const string& s, int i)\n    {\n        for (char v : valid)\n        {\n            c[i] = v;\n            // 至少满足计数要求才行\n            if (char2cnt[v-'a'] >= k && isOk(s, i+1))\n            {\n                // 典型的递归回溯\n                char2cnt[v-'a'] -= k;\n                // 剪枝，只有更长的情况才会更新res\n                if (i >= res.size())\n                {\n                    res = string(c, c+i+1);\n                    // cout << res << endl;\n                }\n                dfs(s, i+1);\n                char2cnt[v-'a'] += k;\n            }\n        }\n    }    \npublic:\n    string longestSubsequenceRepeatedK(string s, int kk) {\n        k = kk;\n        // 计算计数 和 valid的数字\n        for (char ss : s)\n        {\n            ++char2cnt[ss-'a'];\n        }\n        // 倒序去计算\n        for (int i = 25; i >= 0; --i)\n        {\n            if (char2cnt[i] >= k)\n            {\n                valid.push_back('a' + i);\n            }\n        }\n        dfs(s, 0);\n\n        return res;\n    }\n};\n```"
}