{
	"titleSlug": "total-appeal-of-a-string",
	"slug": "by-endlesscheng-g405",
	"url": "https://leetcode-cn.com/problems/total-appeal-of-a-string/solution/by-endlesscheng-g405/",
	"content": "#### 提示 1-1\r\n\r\n将**所有子串**按照其末尾字符的下标分组。\r\n\r\n#### 提示 1-2\r\n\r\n考虑两组**相邻**的子串：以 $s[i-1]$ 结尾的子串、以 $s[i]$ 结尾的子串。\r\n\r\n#### 提示 1-3\r\n\r\n以 $s[i]$ 结尾的子串，可以看成是以 $s[i-1]$ 结尾的子串，在末尾添加上 $s[i]$ 组成。\r\n\r\n**上面这一串提示是思考子串统计类问题的通用技巧之一。**\r\n\r\n#### 提示 2-1\r\n\r\n从左往右遍历 $s$，考虑将 $s[i]$ 添加到以 $s[i-1]$ 结尾的子串的末尾。添加后，这些以 $s[i-1]$ 结尾的子串的引力值会增加多少？\r\n\r\n#### 提示 2-2\r\n\r\n分类讨论：\r\n\r\n- 如果 $s[i]$ 之前没有遇到过，那么这些子串的引力值都会增加 $1$，这些子串的引力值之和会增加 $i$，再加上 $1$，即 $s[i]$ 单独组成的子串的引力值；\r\n- 如果 $s[i]$ 之前遇到过，设其上次出现的下标为 $j$，那么向子串 $s[0..i-1],\\ s[1..i-1],\\ s[2..i-1],\\cdots,s[j..i-1]$ 的末尾添加 $s[i]$ 后，这些子串的引力值是不会变化的，因为 $s[i]$ 已经在 $s[j]$ 处出现过了；而子串 $s[j+1..i-1],\\ s[j+2..i-1],\\cdots,s[i-1..i-1]$ 由于不包含字符 $s[i]$，这些子串的引力值都会增加 $1$，因此有 $i-j-1$ 个子串的引力值会增加 $1$，这些子串的引力值之和会增加 $i-j-1$，再加上 $1$，即 $s[i]$ 单独组成的子串的引力值。\r\n\r\n#### 提示 2-3\r\n\r\n模拟上述过程，遍历 $s$ 的过程中用一个变量 $\\textit{sumG}$ 维护以 $s[i]$ 结尾的子串的引力值之和，同时用一个数组或哈希表 $\\textit{last}$ 记录每个字符上次出现的下标。\r\n\r\n累加遍历中的 $\\textit{sumG}$ 即为答案（根据提示 1-1）。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def appealSum(self, s: str) -> int:\r\n        ans, sum_g, last = 0, 0, {}\r\n        for i, c in enumerate(s):\r\n            sum_g += i - last.get(c, -1)  # 将提示 2-2 中的两种情况合并成一个公式\r\n            ans += sum_g\r\n            last[c] = i\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public long appealSum(String s) {\r\n        var ans = 0L;\r\n        var last = new int[26];\r\n        Arrays.fill(last, -1); // 初始化成 -1 可以让提示 2-2 中的两种情况合并成一个公式\r\n        for (int i = 0, sumG = 0; i < s.length(); i++) {\r\n            var c = s.charAt(i) - 'a';\r\n            sumG += i - last[c];\r\n            ans += sumG;\r\n            last[c] = i;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    long long appealSum(string &s) {\r\n        long ans = 0L;\r\n        vector<int> last(26, -1); // 初始化成 -1 可以让提示 2-2 中的两种情况合并成一个公式\r\n        for (int i = 0, sum_g = 0; i < s.length(); ++i) {\r\n            char c = s[i] - 'a';\r\n            sum_g += i - last[c];\r\n            ans += sum_g;\r\n            last[c] = i;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc appealSum(s string) (ans int64) {\r\n\tsumG, last := 0, [26]int{}\r\n\tfor i := range last { last[i] = -1 } // 初始化成 -1 可以让提示 2-2 中的两种情况合并成一个公式\r\n\tfor i, c := range s {\r\n\t\tc -= 'a'\r\n\t\tsumG += i - last[c]\r\n\t\tans += int64(sumG)\r\n\t\tlast[c] = i\r\n\t}\r\n\treturn\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为 $s$ 的长度。\r\n- 空间复杂度：$O(|\\Sigma|)$，其中 $|\\Sigma|$ 为字符集合的大小，本题中字符均为小写字母，所以 $|\\Sigma|=26$。\r\n\r\n#### 相似题目\r\n\r\n- [828. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/) | [题解](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/solution/by-endlesscheng-ko4z/)\r\n\r\n#### 最后\r\n\r\n欢迎关注我的B站频道：[灵茶山艾府](https://space.bilibili.com/206214)，定期更新算法讲解视频哦~"
}