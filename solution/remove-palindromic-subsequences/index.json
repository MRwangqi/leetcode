{
	"titleSlug": "remove-palindromic-subsequences",
	"slug": "shan-chu-hui-wen-zi-xu-lie-by-leetcode-s-tqtb",
	"url": "https://leetcode-cn.com/problems/remove-palindromic-subsequences/solution/shan-chu-hui-wen-zi-xu-lie-by-leetcode-s-tqtb/",
	"content": "#### 方法一：直接判断\n\n由于字符串本身只含有字母 $\\texttt{`a'}$ 和 $\\texttt{`b'}$ 两种字符，题目要求每次删除回文子序列（不一定连续）而使得字符串最终为空。题目中只包含两种不同的字符，由于相同的字符组成的子序列一定是回文子序列，因此最多只需要删除 $2$ 次即可删除所有的字符。删除判断如下：\n+ 如果该字符串本身为回文串，此时只需删除 $1$ 次即可，删除次数为 $1$。\n+ 如果该字符串本身不是回文串，此时只需删除 $2$ 次即可，比如可以先删除所有的 $\\texttt{`a'}$，再删除所有的 $\\texttt{`b'}$，删除次数为 $2$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def removePalindromeSub(self, s: str) -> int:\n        return 1 if s == s[::-1] else 2\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int removePalindromeSub(String s) {\n        int n = s.length();\n        for (int i = 0; i < n / 2; ++i) {\n            if (s.charAt(i) != s.charAt(n - 1 - i)) {\n                return 2;\n            }\n        }\n        return 1;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int removePalindromeSub(string s) {\n        int n = s.size();\n        for (int i = 0; i < n / 2; ++i) {\n            if (s[i] != s[n - 1 - i]) {\n                return 2;\n            }\n        }\n        return 1;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int RemovePalindromeSub(string s) {\n        int n = s.Length;\n        for (int i = 0; i < n / 2; ++i) {\n            if (s[i] != s[n - 1 - i]) {\n                return 2;\n            }\n        }\n        return 1;\n    }\n}\n```\n\n```C [sol1-C]\nint removePalindromeSub(char * s) {\n    int n = strlen(s);\n    for (int i = 0; i < n / 2; ++i) {\n        if (s[i] != s[n - 1 - i]) {\n            return 2;\n        }\n    }\n    return 1;\n}\n```\n\n```go [sol1-Golang]\nfunc removePalindromeSub(s string) int {\n    for i, n := 0, len(s); i < n/2; i++ {\n        if s[i] != s[n-1-i] {\n            return 2\n        }\n    }\n    return 1\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar removePalindromeSub = function(s) {\n    const n = s.length;\n    for (let i = 0; i < Math.floor(n / 2); ++i) {\n        if (s[i] !== s[n - 1 - i]) {\n            return 2;\n        }\n    }\n    return 1;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为字符串的长度。\n\n- 空间复杂度：$O(1)$。"
}