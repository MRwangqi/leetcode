{
	"titleSlug": "binary-tree-preorder-traversal",
	"slug": "leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2",
	"url": "https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/",
	"content": "# X.遍历二叉树的方法合集\n1. 94. 二叉树的中序遍历\n2. 144. 二叉树的前序遍历\n3. 145. 二叉树的后序遍历\n\n**文章有一点长，代码居多。会给出比较详细的动画演示以及视频讲解请大家耐心阅读。**\n## 递归解法\n### 前序遍历\n```Java [sol1-Java]\npublic static void preOrderRecur(TreeNode head) {\n    if (head == null) {\n        return;\n    }\n    System.out.print(head.value + \" \");\n    preOrderRecur(head.left);\n    preOrderRecur(head.right);\n}\n```\n### 中序遍历\n```Java [sol1-Java]\npublic static void preOrderRecur(TreeNode head) {\n    if (head == null) {\n        return;\n    }\n    preOrderRecur(head.left);\n    System.out.print(head.value + \" \");\n    preOrderRecur(head.right);\n}\n```\n### 后序遍历\n```Java [sol1-Java]\npublic static void postOrderRecur(TreeNode head) {\n    if (head == null) {\n        return;\n    }\n    postOrderRecur(head.left);\n    postOrderRecur(head.right);\n    System.out.print(head.value + \" \");\n}\n```\n### 代码解释\n这里没有对递归遍历做过多的解释，仅仅给出了简单的动画演示。\n要理解递归的思路并且熟练的使用它，就是要*想清楚你想做什么，什么时候停止*。\n\n**如前序遍历：**\n我想先打印头节点对吧？那我打印完了头节点，我现在想打印左边节点了，我只是告诉计算机我想打印左边结点，之后打印右边结点。\n\n**那么后序遍历呢？** \n这个时候你应该知道了，我就是想操作左边然后右边，最后打印中间的元素。\n\n我们并不需要太过于在意具体的递归过程，而是要想清楚让计算机干什么。\n> 计算机都可能溢出，用人脑去遍历就不现实了。\n---\n## 迭代解法\n本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用```Stack```来模拟系统栈。\n### 前序遍历\n首先我们应该创建一个```Stack```用来存放节点，首先我们想要打印根节点的数据，此时```Stack```里面的内容为空，所以我们优先将头结点加入```Stack```，然后打印。\n\n之后我们应该先打印左子树，然后右子树。所以先加入```Stack```的就是右子树，然后左子树。\n此时你能得到的流程如下:\n\n![中序遍历流程图](https://pic.leetcode-cn.com/6233a9685447d0b4d7b513f739151ca065e5697e24070bcafc1ee5d28f9155a6.png){:width=\"500px\"}{:align=\"center\"} \n\n```Java [sol1-Java]\npublic static void preOrderIteration(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tStack<TreeNode> stack = new Stack<>();\n\tstack.push(head);\n\twhile (!stack.isEmpty()) {\n\t\tTreeNode node = stack.pop();\n\t\tSystem.out.print(node.value + \" \");\n\t\tif (node.right != null) {\n\t\t\tstack.push(node.right);\n\t\t}\n\t\tif (node.left != null) {\n\t\t\tstack.push(node.left);\n\t\t}\n\t}\n}\n```\n\n### 中序遍历\n1. 同理创建一个```Stack```，然后按 左 中 右的顺序输出节点。\n2. 尽可能的将这个节点的左子树压入```Stack```，此时栈顶的元素是最左侧的元素，*其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，并且在寻找的过程中记录了来源，才能返回上层*,同时在返回上层的时候已经处理完毕左子树了。。\n3. 当处理完最小单位的子树时，返回到上层处理了中间节点。（如果把整个左中右的遍历都理解成子树的话，就是处理完 ```左子树->中间(就是一个节点)->右子树```）\n4. 如果有右节点，其也要进行中序遍历。\n![中序遍历](https://pic.leetcode-cn.com/06eddcac9277efdbbd338b5069e836bbb2e8eb4c4fbf145025f3ab1a52263912.png){:width=\"300px\"}{:align=\"left\"} \n当整个左子树退栈的时候这个时候输出了该子树的根节点 2，之后输出中间节点 1。然后处理根节点为3右子树。\n\n```Java [sol1-Java]\npublic static void inOrderIteration(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur = head;\n\tStack<TreeNode> stack = new Stack<>();\n\twhile (!stack.isEmpty() || cur != null) {\n\t\twhile (cur != null) {\n\t\t\tstack.push(cur);\n\t\t\tcur = cur.left;\n\t\t}\n\t\tTreeNode node = stack.pop();\n\t\tSystem.out.print(node.value + \" \");\n\t\tif (node.right != null) {\n\t\t\tcur = node.right;\n\t\t}\n\t}\n}\n```\n\n### 后序遍历\n#### 代码片段 1\n1. 前序遍历的过程 是 中左右。\n2. 将其转化成 中右左。也就是压栈的过程中优先压入左子树，在压入右子树。\n3. 然后将这个结果返回来，这里是利用栈的先进后出倒序打印。\n```Java [sol1-Java]\npublic static void postOrderIteration(TreeNode head) {\n\t\tif (head == null) {\n\t\t\treturn;\n\t\t}\n\t\tStack<TreeNode> stack1 = new Stack<>();\n\t\tStack<TreeNode> stack2 = new Stack<>();\n\t\tstack1.push(head);\n\t\twhile (!stack1.isEmpty()) {\n\t\t\tTreeNode node = stack1.pop();\n\t\t\tstack2.push(node);\n\t\t\tif (node.left != null) {\n\t\t\t\tstack1.push(node.left);\n\t\t\t}\n\t\t\tif (node.right != null) {\n\t\t\t\tstack1.push(node.right);\n\t\t\t}\n\t\t}\n\t\twhile (!stack2.isEmpty()) {\n\t\t\tSystem.out.print(stack2.pop().value + \" \");\n\t\t}\n\t}\n```\n#### 代码片段 2\n1. 用一个指针```cur```标记当前退出的节点是什么。\n2. 后序遍历的过程中在遍历完左子树跟右子树```cur```都会回到根结点。所以当前不管是从左子树还是右子树回到根结点都不应该再操作了，应该退回上层。\n3. 如果是从右边再返回根结点，应该回到上层。\n```Java [sol1-Java]\npublic static void postOrderIteration2(TreeNode head) { 感谢[@ben-ben-niu](/u/ben-ben-niu/)指出错误，代码确实存在问题，已经在原文中修复\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur = head;\n\tStack<TreeNode> stack = new Stack<>();\n\tstack.push(head);\n\twhile (!stack.isEmpty()) {\n\t\tTreeNode peek = stack.peek();\n\t\tif (peek.left != null && peek.left != cur && peek.right != cur) {\n\t\t\tstack.push(peek.left);\n\t\t} else if (peek.right != null && peek.right != cur) {\n\t\t\tstack.push(peek.right);\n\t\t} else {\n\t\t\tSystem.out.print(stack.pop().val + \" \");\n\t\t\tcur = peek;\n\t\t}\n\t}\n}\n```\n---\n## Morris解法\n```Morris```遍历使用二叉树节点中大量指向```null```的指针，由Joseph Morris 于1979年发明。\n时间复杂度：$O(n)$\n额外空间复杂度：$O(1)$\n\n在你阅读以下代码之前，在这边先讲解一下```Morris```的通用解法过程。\n![在这里插入图片描述](https://pic.leetcode-cn.com/143b40666eebb8992b1ed7e6c35d4d5f3b93c6f20ab436e5c9ffa54032c392c0.png)\n\n```Morris```的整体思路就是将 *以某个根结点开始，找到它左子树的最右侧节点之后与这个根结点进行连接*\n我们可以从 **图2** 看到，如果这么连接之后，**cur** 这个指针是可以完整的从一个节点顺着下一个节点遍历，将整棵树遍历完毕，直到 **7** 这个节点右侧没有指向。\n```Java [sol1-Java]\npublic static void preOrderMorris(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur1 = head;//当前开始遍历的节点\n\tTreeNode cur2 = null;//记录当前结点的左子树\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {//找到当前左子树的最右侧节点，且这个节点应该在指向根结点之前，否则整个节点又回到了根结点。\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {//这个时候如果最右侧这个节点的右指针没有指向根结点，创建连接然后往下一个左子树的根结点进行连接操作。\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {//当左子树的最右侧节点有指向根结点，此时说明我们已经回到了根结点并重复了之前的操作，同时在回到根结点的时候我们应该已经处理完 左子树的最右侧节点 了，把路断开。\n\t\t\t\tcur2.right = null;\n\t\t\t}\n\t\t} \n\t\tcur1 = cur1.right;//一直往右边走，参考图\n\t}\n}\n```\n### 前序遍历\n1. 在某个根结点创建连线的时候打印。因为我们是顺着左边的根节点来创建连线，且创建的过程只有一次。\n2. 打印某些自身无法创建连线的节点，也就是叶子节点。\n\n```Java [sol1-Java]\npublic static void preOrderMorris(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur1 = head;\n\tTreeNode cur2 = null;\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tSystem.out.print(cur1.value + \" \");\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcur2.right = null;\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.out.print(cur1.value + \" \");\n\t\t}\n\t\tcur1 = cur1.right;\n\t}\n}\n```\n### 中序遍历\n从最左侧开始顺着右节点打印。也就是在将cu1切换到上层节点的时候。\n\n```Java [sol1-Java]\npublic static void inOrderMorris(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur1 = head;\n\tTreeNode cur2 = null;\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\t//构建连接线\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcur2.right = null;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(cur1.value + \" \");\n\t\tcur1 = cur1.right;\n\t}\n}\n\n```\n### 后序遍历\n后序遍历就比较复杂了哈，先看一下图\n![在这里插入图片描述](https://pic.leetcode-cn.com/4b023cabcbfc58580127db3bd244a6b9d7f1060b899faa510c7366a5a51cce45.png){:width=\"400px\"}{:align=\"center\"} \n\n当我们到达最左侧，也就是左边连线已经创建完毕了。\n打印 4\n打印 5 2\n打印 6\n打印 7 3 1\n我们将一个节点的连续右节点当成一个单链表来看待。\n当我们返回上层之后，也就是将连线断开的时候，打印下层的单链表。\n比如返回到　２，此时打印　４\n比如返回到　１，此时打印　５　２\n比如返回到　３，此时打印　６\n那么我们只需要将这个单链表逆序打印就行了，下文也给出了 **单链表逆序代码**\n*这里不应该打印当前层，而是下一层，否则根结点会先与右边打印。*\n```Java [sol1-Java]\n//后序Morris\npublic static void postOrderMorris(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur1 = head;//遍历树的指针变量\n\tTreeNode cur2 = null;//当前子树的最右节点\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcur2.right = null;\n\t\t\t\tpostMorrisPrint(cur1.left);\n\t\t\t}\n\t\t}\n\t\tcur1 = cur1.right;\n\t}\n\tpostMorrisPrint(head);\n}\n//打印函数\npublic static void postMorrisPrint(TreeNode head) {\n\tTreeNode reverseList = postMorrisReverseList(head);\n\tTreeNode cur = reverseList;\n\twhile (cur != null) {\n\t\tSystem.out.print(cur.value + \" \");\n\t\tcur = cur.right;\n\t}\n\tpostMorrisReverseList(reverseList);\n}\n//翻转单链表\npublic static TreeNode postMorrisReverseList(TreeNode head) {\n\tTreeNode cur = head;\n\tTreeNode pre = null;\n\twhile (cur != null) {\n\t\tTreeNode next = cur.right;\n\t\tcur.right = pre;\n\t\tpre = cur;\n\t\tcur = next;\n\t}\n\treturn pre;\n}\n```\n\n---\n感谢收看\n"
}