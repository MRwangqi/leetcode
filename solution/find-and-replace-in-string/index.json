{
	"titleSlug": "find-and-replace-in-string",
	"slug": "zi-fu-chuan-zhong-de-cha-zhao-yu-ti-huan-by-leetco",
	"url": "https://leetcode-cn.com/problems/find-and-replace-in-string/solution/zi-fu-chuan-zhong-de-cha-zhao-yu-ti-huan-by-leetco/",
	"content": "#### 方法一：模拟\n\n我们介绍两种不同的模拟方法。在这两种方法中，我们都通过最初给定的字符串 `S` 和替换操作，找出其中无效的那些，并保留有效的，以此得到最终的答案 `ans`。\n\n在 `Java` 的代码中，我们根据替换操作得到数组 `match`，其中 `match[ix] = j` 表示字符串 `S` 从第 `ix` 位开始和 `sources[j]` 匹配，并且会被替换成 `target[j]`，也就是说 `sources[j]` 是字符串 `S[ix:]` 的前缀。在得到 `match` 数组后，我们对 `S` 从左到右进行扫描，对于每个位置 `ix`，如果 `match[ix]` 有值 `j`，那么在 `ans` 尾部添加字符串 `targets[j]`，并将 `ix` 增加 `sources[j].length()`；否则在 `ans` 尾部添加字符 `S[ix]`，并将 `ix` 增加 `1`。\n\n在 `Python` 代码中，我们将所有的替换操作根据 `indexes` 值进行降序排序，这样我们依次执行替换操作时，前面的替换操作并不会改变后面替换操作的 `indexes` 值的位置。对于每个替换操作 `i`，我们直接判断 `S` 中对应的子串是否和 `sources[i]` 相等，如果相等，则替换为 `targets[i]`。\n\n```Java [sol1]\nclass Solution {\n    public String findReplaceString(String S, int[] indexes, String[] sources, String[] targets) {\n        int N = S.length();\n        int[] match = new int[N];\n        Arrays.fill(match, -1);\n\n        for (int i = 0; i < indexes.length; ++i) {\n            int ix = indexes[i];\n            if (S.substring(ix, ix + sources[i].length()).equals(sources[i]))\n                match[ix] = i;\n        }\n\n        StringBuilder ans = new StringBuilder();\n        int ix = 0;\n        while (ix < N) {\n            if (match[ix] >= 0) {\n                ans.append(targets[match[ix]]);\n                ix += sources[match[ix]].length();\n            } else {\n                ans.append(S.charAt(ix++));\n            }\n        }\n        return ans.toString();\n    }\n}\n```\n\n```Python [sol1]\nclass Solution(object):\n    def findReplaceString(self, S, indexes, sources, targets):\n        S = list(S)\n        for i, x, y in sorted(zip(indexes, sources, targets), reverse = True):\n            if all(i+k < len(S) and S[i+k] == x[k] for k in xrange(len(x))):\n                S[i:i+len(x)] = list(y)\n\n        return \"\".join(S)\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(NQ)$，其中 $N$ 是字符串 `S` 的长度，$Q$ 是替换操作的数量。\n\n* 空间复杂度：$O(N)$，我们认为 `sources` 和 `targets` 中的字符串长度均为常数。"
}