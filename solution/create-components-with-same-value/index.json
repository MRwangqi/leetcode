{
	"titleSlug": "create-components-with-same-value",
	"slug": "by-endlesscheng-u03q",
	"url": "https://leetcode-cn.com/problems/create-components-with-same-value/solution/by-endlesscheng-u03q/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1cV4y157BY) 已出炉，欢迎点赞三连，在评论区分享你对这场双周赛的看法~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n枚举连通块的个数 $i$，则删除的边数为 $i-1$。\r\n\r\n设 $\\textit{total}$ 为所有 $\\textit{nums}[i]$ 的和，如果 $\\textit{total}$ 能被 $i$ 整除（$i$ 是 $\\textit{total}$ 的因子），那么每个连通块的价值都应等于 $\\dfrac{\\textit{total}}{i}$，记作 $\\textit{target}$。\r\n\r\n如何判定存在这些连通块呢？\r\n\r\n#### 提示 2\r\n\r\n如果一颗子树的价值等于 $\\textit{target}$，那么可以将其作为一个连通块，和其父节点断开，换句话说，它对其祖先节点的价值贡献是 $0$。\r\n\r\nDFS 这棵树，统计子树的价值：\r\n\r\n- 如果价值超过 $\\textit{target}$，那么当前删边方案不合法，返回 $-1$。\r\n- 如果价值等于 $\\textit{target}$，找到了一个连通块，和其父节点断开，返回 $0$。\r\n- 如果价值小于 $\\textit{target}$，尚未找到一个完整的连通块，返回价值。\r\n\r\n如果 DFS 完了没有返回 $-1$，则当前删边方案合法。如果从大到小枚举连通块的个数，则此时可以直接返回答案。\r\n\r\n#### 优化\r\n\r\n代码实现时，由于价值至少为 $\\max(\\textit{nums}[i])$，连通块的个数至多为 $\\left\\lfloor\\dfrac{\\textit{total}}{\\max(\\textit{nums}[i])}\\right\\rfloor$。由于 $\\left\\lfloor\\dfrac{\\textit{total}}{\\max(\\textit{nums}[i])}\\right\\rfloor\\le n$，因此可以从 $\\left\\lfloor\\dfrac{\\textit{total}}{\\max(\\textit{nums}[i])}\\right\\rfloor$ 开始枚举连通块的个数。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\r\n        g = [[] for _ in nums]\r\n        for x, y in edges:\r\n            g[x].append(y)\r\n            g[y].append(x)\r\n\r\n        def dfs(x: int, fa: int) -> int:\r\n            s = nums[x]  # 价值\r\n            for y in g[x]:\r\n                if y != fa:\r\n                    res = dfs(y, x)\r\n                    if res < 0: return -1\r\n                    s += res\r\n            if s > target: return -1\r\n            return s if s < target else 0\r\n\r\n        total = sum(nums)\r\n        for i in range(total // max(nums), 1, -1):\r\n            if total % i == 0:\r\n                target = total // i\r\n                if dfs(0, -1) == 0: return i - 1\r\n        return 0\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    private List<Integer>[] g;\r\n    private int[] nums;\r\n    private int target;\r\n\r\n    public int componentValue(int[] nums, int[][] edges) {\r\n        g = new ArrayList[nums.length];\r\n        Arrays.setAll(g, e -> new ArrayList<>());\r\n        for (var e : edges) {\r\n            int x = e[0], y = e[1];\r\n            g[x].add(y);\r\n            g[y].add(x);\r\n        }\r\n        this.nums = nums;\r\n\r\n        var total = Arrays.stream(nums).sum();\r\n        var max = Arrays.stream(nums).max().orElseThrow();\r\n        for (var i = total / max; ; --i)\r\n            if (total % i == 0) {\r\n                target = total / i;\r\n                if (dfs(0, -1) == 0) return i - 1;\r\n            }\r\n    }\r\n\r\n    private int dfs(int x, int fa) {\r\n        var sum = nums[x]; // 价值\r\n        for (var y : g[x])\r\n            if (y != fa) {\r\n                var res = dfs(y, x);\r\n                if (res < 0) return -1;\r\n                sum += res;\r\n            }\r\n        if (sum > target) return -1;\r\n        return sum < target ? sum : 0;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int componentValue(vector<int> &nums, vector<vector<int>> &edges) {\r\n        vector<vector<int>> g(nums.size());\r\n        for (auto &e : edges) {\r\n            int x = e[0], y = e[1];\r\n            g[x].push_back(y);\r\n            g[y].push_back(x);\r\n        }\r\n\r\n        int target;\r\n        function<int(int, int)> dfs = [&](int x, int fa) {\r\n            int sum = nums[x]; // 价值\r\n            for (int y : g[x])\r\n                if (y != fa) {\r\n                    int res = dfs(y, x);\r\n                    if (res < 0) return -1;\r\n                    sum += res;\r\n                }\r\n            if (sum > target) return -1;\r\n            return sum < target ? sum : 0;\r\n        };\r\n\r\n        int total = accumulate(nums.begin(), nums.end(), 0);\r\n        int mx = *max_element(nums.begin(), nums.end());\r\n        for (int i = total / mx;; --i)\r\n            if (total % i == 0) {\r\n                target = total / i;\r\n                if (dfs(0, -1) == 0) return i - 1;\r\n            }\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc componentValue(nums []int, edges [][]int) int {\r\n\tg := make([][]int, len(nums))\r\n\tfor _, e := range edges {\r\n\t\tx, y := e[0], e[1]\r\n\t\tg[x] = append(g[x], y)\r\n\t\tg[y] = append(g[y], x)\r\n\t}\r\n\r\n\tvar target int\r\n\tvar dfs func(int, int) int\r\n\tdfs = func(x, fa int) int {\r\n\t\tsum := nums[x] // 价值\r\n\t\tfor _, y := range g[x] {\r\n\t\t\tif y != fa {\r\n\t\t\t\tres := dfs(y, x)\r\n\t\t\t\tif res < 0 {\r\n\t\t\t\t\treturn -1\r\n\t\t\t\t}\r\n\t\t\t\tsum += res\r\n\t\t\t}\r\n\t\t}\r\n\t\tif sum > target {\r\n\t\t\treturn -1\r\n\t\t}\r\n\t\tif sum == target {\r\n\t\t\treturn 0\r\n\t\t}\r\n\t\treturn sum\r\n\t}\r\n\r\n\ttotal, mx := 0, 0\r\n\tfor _, x := range nums {\r\n\t\ttotal += x\r\n\t\tmx = max(mx, x)\r\n\t}\r\n\tfor i := total / mx; ; i-- {\r\n\t\tif total%i == 0 {\r\n\t\t\ttarget = total / i\r\n\t\t\tif dfs(0, -1) == 0 {\r\n\t\t\t\treturn i - 1\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc min(a, b int) int { if b < a { return b }; return a }\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\cdot d(s))$，其中 $n$ 为 $\\textit{nums}$ 的长度，$s$ 为所有 $\\textit{nums}[i]$ 的和，$d(s)$ 为 $s$ 的因子个数。根据本题的数据范围，$d(s)\\le 240$，$s=720720$ 时取等号。\r\n- 空间复杂度：$O(n)$。当树是一条链时，递归的深度最大为 $n$，需要的栈空间为 $O(n)$。\r\n"
}