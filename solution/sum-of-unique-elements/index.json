{
	"titleSlug": "sum-of-unique-elements",
	"slug": "wei-yi-yuan-su-de-he-by-leetcode-solutio-tueh",
	"url": "https://leetcode-cn.com/problems/sum-of-unique-elements/solution/wei-yi-yuan-su-de-he-by-leetcode-solutio-tueh/",
	"content": "#### 方法一：记录每个元素的出现次数\n\n根据题意，我们可以用一个哈希表记录每个元素值的出现次数，然后遍历哈希表，累加恰好出现一次的元素值，即为答案。\n\n```Python [sol1-Python3]\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        return sum(num for num, cnt in Counter(nums).items() if cnt == 1)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int sumOfUnique(vector<int> &nums) {\n        unordered_map<int, int> cnt;\n        for (int num : nums) {\n            ++cnt[num];\n        }\n        int ans = 0;\n        for (auto &[num, c] : cnt) {\n            if (c == 1) {\n                ans += num;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int sumOfUnique(int[] nums) {\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            cnt.put(num, cnt.getOrDefault(num, 0) + 1);\n        }\n        int ans = 0;\n        for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n            int num = entry.getKey(), c = entry.getValue();\n            if (c == 1) {\n                ans += num;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int SumOfUnique(int[] nums) {\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        foreach (int num in nums) {\n            if (!cnt.ContainsKey(num)) {\n                cnt.Add(num, 0);\n            }\n            ++cnt[num];\n        }\n        int ans = 0;\n        foreach (KeyValuePair<int, int> pair in cnt) {\n            int num = pair.Key, c = pair.Value;\n            if (c == 1) {\n                ans += num;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc sumOfUnique(nums []int) (ans int) {\n    cnt := map[int]int{}\n    for _, num := range nums {\n        cnt[num]++\n    }\n    for num, c := range cnt {\n        if c == 1 {\n            ans += num\n        }\n    }\n    return\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;                  \n    int val;\n    UT_hash_handle hh;         \n} HashEntry;\n\nint sumOfUnique(int* nums, int numsSize){\n    HashEntry * cnt = NULL; \n    for (int i = 0; i < numsSize; ++i) {\n        HashEntry * pEntry = NULL;\n        HASH_FIND(hh, cnt, &nums[i], sizeof(int), pEntry);\n        if (NULL == pEntry) {\n            pEntry = (HashEntry *)malloc(sizeof(HashEntry));\n            pEntry->key = nums[i];\n            pEntry->val = 1;\n            HASH_ADD(hh, cnt, key, sizeof(int), pEntry);\n        } else {\n            ++pEntry->val;\n        }\n    }\n    int ans = 0;\n    HashEntry *curr, *next;\n    HASH_ITER(hh, cnt, curr, next) {\n        if (curr->val == 1) {\n            ans += curr->key;\n        } \n    }\n    HASH_ITER(hh, cnt, curr, next)\n    {\n        HASH_DEL(cnt, curr);  \n        free(curr);      \n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar sumOfUnique = function(nums) {\n    const cnt = new Map();\n    for (const num of nums) {\n        cnt.set(num, (cnt.get(num) || 0) + 1);\n    }\n    let ans = 0;\n    for (const [num, c] of cnt.entries()) {\n        if (c === 1) {\n            ans += num;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(n)$。哈希表需要 $O(n)$ 的空间。\n\n#### 方法二：记录每个元素的状态 + 一次遍历\n\n方法一需要遍历数组和哈希表各一次，能否做到仅执行一次遍历呢？\n\n我们可以赋给每个元素三个状态：\n\n- $0$：该元素尚未被访问；\n- $1$：该元素被访问过一次；\n- $2$：该元素被访问超过一次。\n\n我们可以在首次访问一个元素时，将该元素加入答案，然后将该元素状态标记为 $1$。在访问到一个标记为 $1$ 的元素时，由于这意味着该元素出现不止一次，因此将其从答案中减去，并将该元素状态标记为 $2$。\n\n```Python [sol2-Python3]\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        ans = 0\n        state = {}\n        for num in nums:\n            if num not in state:\n                ans += num\n                state[num] = 1\n            elif state[num] == 1:\n                ans -= num\n                state[num] = 2\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int sumOfUnique(vector<int> &nums) {\n        int ans = 0;\n        unordered_map<int, int> state;\n        for (int num : nums) {\n            if (state[num] == 0) {\n                ans += num;\n                state[num] = 1;\n            } else if (state[num] == 1) {\n                ans -= num;\n                state[num] = 2;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int sumOfUnique(int[] nums) {\n        int ans = 0;\n        Map<Integer, Integer> state = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            if (!state.containsKey(num)) {\n                ans += num;\n                state.put(num, 1);\n            } else if (state.get(num) == 1) {\n                ans -= num;\n                state.put(num, 2);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int SumOfUnique(int[] nums) {\n        int ans = 0;\n        Dictionary<int, int> state = new Dictionary<int, int>();\n        foreach (int num in nums) {\n            if (!state.ContainsKey(num)) {\n                ans += num;\n                state.Add(num, 1);\n            } else if (state[num] == 1) {\n                ans -= num;\n                state[num] = 2;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc sumOfUnique(nums []int) (ans int) {\n    state := map[int]int{}\n    for _, num := range nums {\n        if state[num] == 0 {\n            ans += num\n            state[num] = 1\n        } else if state[num] == 1 {\n            ans -= num\n            state[num] = 2\n        }\n    }\n    return\n}\n```\n\n```C [sol2-C]\ntypedef struct {\n    int key;                  \n    int val;\n    UT_hash_handle hh;         \n} HashEntry;\n\nint sumOfUnique(int* nums, int numsSize){\n    HashEntry * cnt = NULL; \n    int ans = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        HashEntry * pEntry = NULL;\n        HASH_FIND(hh, cnt, &nums[i], sizeof(int), pEntry);\n        if (NULL == pEntry) {\n            pEntry = (HashEntry *)malloc(sizeof(HashEntry));\n            pEntry->key = nums[i];\n            pEntry->val = 1;\n            ans += nums[i];\n            HASH_ADD(hh, cnt, key, sizeof(int), pEntry);\n        } else if (pEntry->val == 1){\n            ans -= nums[i];\n            pEntry->val = 2;\n        }\n    }\n    HashEntry *curr = NULL, *next = NULL;\n    HASH_ITER(hh, cnt, curr, next)\n    {\n        HASH_DEL(cnt, curr);  \n        free(curr);      \n    }\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar sumOfUnique = function(nums) {\n    let ans = 0;\n    const state = new Map();\n    for (const num of nums) {\n        if (!state.has(num)) {\n            ans += num;\n            state.set(num, 1);\n        } else if (state.get(num) === 1) {\n            ans -= num;\n            state.set(num, 2);\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(n)$。哈希表需要 $O(n)$ 的空间。"
}