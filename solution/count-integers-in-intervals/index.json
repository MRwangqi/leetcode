{
	"titleSlug": "count-integers-in-intervals",
	"slug": "by-endlesscheng-clk2",
	"url": "https://leetcode-cn.com/problems/count-integers-in-intervals/solution/by-endlesscheng-clk2/",
	"content": "思路同 [715. Range 模块](https://leetcode.cn/problems/range-module/)。\r\n\r\n### 方法一：珂朵莉树\r\n\r\n用一颗平衡树维护若干个不相交的区间，每次 `add(left,right)` 时，删除被该区间覆盖到的区间（部分覆盖也算），然后将这些区间与 $[\\textit{left},\\textit{right}]$ 合并成一个新的大区间，插入平衡树中。\r\n\r\n代码实现时，为方便找到第一个被 $[\\textit{left},\\textit{right}]$ 覆盖到的区间，我们可以用平衡树的 $\\textit{key}$ 存区间右端点，$\\textit{value}$ 存区间左端点。我们要找的就是第一个 $\\textit{key}\\ge\\textit{left}$ 的区间。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：每个区间至多被添加删除各一次，因此 `add` 操作是均摊 $O(\\log n)$ 的，这里 $n$ 是 `add` 的次数。\r\n- 空间复杂度：$O(n)$。\r\n\r\n```python [sol2-Python3]\r\nfrom sortedcontainers import SortedDict\r\n\r\nclass CountIntervals:\r\n    def __init__(self):\r\n        self.d = SortedDict()\r\n        self.cnt = 0  # 所有区间长度和\r\n\r\n    def add(self, left: int, right: int) -> None:\r\n        # 遍历所有被 [left,right] 覆盖到的区间（部分覆盖也算）\r\n        i = self.d.bisect_left(left)\r\n        while i < len(self.d) and self.d.values()[i] <= right:\r\n            r, l = self.d.items()[i]\r\n            left = min(left, l)    # 合并后的新区间，其左端点为所有被覆盖的区间的左端点的最小值\r\n            right = max(right, r)  # 合并后的新区间，其右端点为所有被覆盖的区间的右端点的最大值\r\n            self.cnt -= r - l + 1\r\n            self.d.popitem(i)\r\n        self.cnt += right - left + 1\r\n        self.d[right] = left  # 所有被覆盖到的区间与 [left,right] 合并成一个新区间\r\n\r\n    def count(self) -> int:\r\n        return self.cnt\r\n```\r\n\r\n```java [sol2-Java]\r\nclass CountIntervals {\r\n    TreeMap<Integer, Integer> m = new TreeMap<>();\r\n    int cnt; // 所有区间长度和\r\n\r\n    public CountIntervals() {}\r\n\r\n    public void add(int left, int right) {\r\n        // 遍历所有被 [left,right] 覆盖到的区间（部分覆盖也算）\r\n        for (var e = m.ceilingEntry(left); e != null && e.getValue() <= right; e = m.ceilingEntry(left)) {\r\n            int l = e.getValue(), r = e.getKey();\r\n            left = Math.min(left, l);   // 合并后的新区间，其左端点为所有被覆盖的区间的左端点的最小值\r\n            right = Math.max(right, r); // 合并后的新区间，其右端点为所有被覆盖的区间的右端点的最大值\r\n            cnt -= r - l + 1;\r\n            m.remove(r);\r\n        }\r\n        cnt += right - left + 1;\r\n        m.put(right, left); // 所有被覆盖到的区间与 [left,right] 合并成一个新区间\r\n    }\r\n\r\n    public int count() { return cnt; }\r\n}\r\n```\r\n\r\n```C++ [sol2-C++]\r\nclass CountIntervals {\r\n    map<int, int> m;\r\n    int cnt = 0; // 所有区间长度和\r\n\r\npublic:\r\n    CountIntervals() {}\r\n\r\n    void add(int left, int right) {\r\n        // 遍历所有被 [left,right] 覆盖到的区间（部分覆盖也算）\r\n        for (auto it = m.lower_bound(left); it != m.end() && it->second <= right; m.erase(it++)) {\r\n            int l = it->second, r = it->first;\r\n            left = min(left, l);   // 合并后的新区间，其左端点为所有被覆盖的区间的左端点的最小值\r\n            right = max(right, r); // 合并后的新区间，其右端点为所有被覆盖的区间的右端点的最大值\r\n            cnt -= r - l + 1;\r\n        }\r\n        cnt += right - left + 1;\r\n        m[right] = left; // 所有被覆盖到的区间与 [left,right] 合并成一个新区间\r\n    }\r\n\r\n    int count() { return cnt; }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\ntype CountIntervals struct {\r\n\t*redblacktree.Tree\r\n\tcnt int // 所有区间长度和\r\n}\r\n\r\nfunc Constructor() CountIntervals {\r\n\treturn CountIntervals{redblacktree.NewWithIntComparator(), 0}\r\n}\r\n\r\nfunc (t *CountIntervals) Add(left, right int) {\r\n\t// 遍历所有被 [left,right] 覆盖到的区间（部分覆盖也算）\r\n\tfor node, _ := t.Ceiling(left); node != nil && node.Value.(int) <= right; node, _ = t.Ceiling(left) {\r\n\t\tl, r := node.Value.(int), node.Key.(int)\r\n\t\tif l < left { left = l }   // 合并后的新区间，其左端点为所有被覆盖的区间的左端点的最小值\r\n\t\tif r > right { right = r } // 合并后的新区间，其右端点为所有被覆盖的区间的右端点的最大值\r\n\t\tt.cnt -= r - l + 1\r\n\t\tt.Remove(r)\r\n\t}\r\n\tt.cnt += right - left + 1\r\n\tt.Put(right, left) // 所有被覆盖到的区间与 [left,right] 合并成一个新区间\r\n}\r\n\r\nfunc (t *CountIntervals) Count() int { return t.cnt }\r\n```\r\n\r\n### 方法二：动态开点线段树\r\n\r\n原理见 [这篇文章](https://zhuanlan.zhihu.com/p/246255556)。完整的动态开点线段树模板见我的 [算法竞赛模板库](https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/segment_tree.go)。\r\n\r\n对于本题来说，线段树的每个节点可以保存对应范围的左右端点 $l$ 和 $r$，以及范围内 `add` 过的整数个数 $\\textit{cnt}$。\r\n\r\n代码实现时，无需记录 lazy tag，这是因为被覆盖的范围无需再次覆盖，因此若 $\\textit{cnt}$ 等于范围的长度 $r-l+1$，则可直接返回。\r\n\r\n```Python [sol1-Python3]\r\nclass CountIntervals:\r\n    __slots__ = 'left', 'right', 'l', 'r', 'cnt'\r\n\r\n    def __init__(self, l=1, r=10 ** 9):\r\n        self.left = self.right = None\r\n        self.l, self.r, self.cnt = l, r, 0\r\n\r\n    def add(self, l: int, r: int) -> None:\r\n        if self.cnt == self.r - self.l + 1: return  # self 已被完整覆盖，无需执行任何操作\r\n        if l <= self.l and self.r <= r:  # self 已被区间 [l,r] 完整覆盖，不再继续递归\r\n            self.cnt = self.r - self.l + 1\r\n            return\r\n        mid = (self.l + self.r) // 2\r\n        if self.left is None: self.left = CountIntervals(self.l, mid)  # 动态开点\r\n        if self.right is None: self.right = CountIntervals(mid + 1, self.r)  # 动态开点\r\n        if l <= mid: self.left.add(l, r)\r\n        if mid < r: self.right.add(l, r)\r\n        self.cnt = self.left.cnt + self.right.cnt\r\n\r\n    def count(self) -> int:\r\n        return self.cnt\r\n```\r\n\r\n```java [sol1-Java]\r\nclass CountIntervals {\r\n    CountIntervals left, right;\r\n    int l, r, cnt;\r\n\r\n    public CountIntervals() {\r\n        l = 1;\r\n        r = (int) 1e9;\r\n    }\r\n\r\n    CountIntervals(int l, int r) {\r\n        this.l = l;\r\n        this.r = r;\r\n    }\r\n\r\n    public void add(int L, int R) { // 为方便区分变量名，将递归中始终不变的入参改为大写（视作常量）\r\n        if (cnt == r - l + 1) return; // 当前节点已被完整覆盖，无需执行任何操作\r\n        if (L <= l && r <= R) { // 当前节点已被区间 [L,R] 完整覆盖，不再继续递归\r\n            cnt = r - l + 1;\r\n            return;\r\n        }\r\n        int mid = (l + r) / 2;\r\n        if (left == null) left = new CountIntervals(l, mid); // 动态开点\r\n        if (right == null) right = new CountIntervals(mid + 1, r); // 动态开点\r\n        if (L <= mid) left.add(L, R);\r\n        if (mid < R) right.add(L, R);\r\n        cnt = left.cnt + right.cnt;\r\n    }\r\n\r\n    public int count() {\r\n        return cnt;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass CountIntervals {\r\n    CountIntervals *left = nullptr, *right = nullptr;\r\n    int l, r, cnt = 0;\r\n\r\npublic:\r\n    CountIntervals() : l(1), r(1e9) {}\r\n\r\n    CountIntervals(int l, int r) : l(l), r(r) {}\r\n\r\n    void add(int L, int R) { // 为方便区分变量名，将递归中始终不变的入参改为大写（视作常量）\r\n        if (cnt == r - l + 1) return; // 当前节点已被完整覆盖，无需执行任何操作\r\n        if (L <= l && r <= R) { // 当前节点已被区间 [L,R] 完整覆盖，不再继续递归\r\n            cnt = r - l + 1;\r\n            return;\r\n        }\r\n        int mid = (l + r) / 2;\r\n        if (left == nullptr) left = new CountIntervals(l, mid); // 动态开点\r\n        if (right == nullptr) right = new CountIntervals(mid + 1, r); // 动态开点\r\n        if (L <= mid) left->add(L, R);\r\n        if (mid < R) right->add(L, R);\r\n        cnt = left->cnt + right->cnt;\r\n    }\r\n\r\n    int count() { return cnt; }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\ntype CountIntervals struct {\r\n\tleft, right *CountIntervals\r\n\tl, r, cnt   int\r\n}\r\n\r\nfunc Constructor() CountIntervals { return CountIntervals{l: 1, r: 1e9} }\r\n\r\nfunc (o *CountIntervals) Add(l, r int) {\r\n\tif o.cnt == o.r-o.l+1 { return } // o 已被完整覆盖，无需执行任何操作\r\n\tif l <= o.l && o.r <= r { // 当前节点已被区间 [l,r] 完整覆盖，不再继续递归\r\n\t\to.cnt = o.r - o.l + 1\r\n\t\treturn\r\n\t}\r\n\tmid := (o.l + o.r) >> 1\r\n\tif o.left == nil { o.left = &CountIntervals{l: o.l, r: mid} } // 动态开点\r\n\tif o.right == nil { o.right = &CountIntervals{l: mid + 1, r: o.r} } // 动态开点\r\n\tif l <= mid { o.left.Add(l, r)}\r\n\tif mid < r { o.right.Add(l, r) }\r\n\to.cnt = o.left.cnt + o.right.cnt\r\n}\r\n\r\nfunc (o *CountIntervals) Count() int { return o.cnt }\r\n```\r\n"
}