{
	"titleSlug": "lexicographical-numbers",
	"slug": "zi-dian-xu-pai-shu-by-leetcode-solution-98mz",
	"url": "https://leetcode-cn.com/problems/lexicographical-numbers/solution/zi-dian-xu-pai-shu-by-leetcode-solution-98mz/",
	"content": "#### 方法一：深度优先搜索\n\n**思路与算法**\n\n题目要求设计一个时间复杂度为 $O(n)$ 且使用 $O(1)$ 额外空间的算法，因此我们不能使用直接排序的方法。\n\n那么对于一个整数 $\\textit{number}$，它的下一个字典序整数对应下面的规则：\n\n+ 尝试在 $\\textit{number}$ 后面附加一个零，即 $\\textit{number} \\times 10$，如果 $\\textit{number} \\times 10 \\le n$，那么说明 $\\textit{number} \\times 10$ 是下一个字典序整数；\n\n+ 如果 $\\textit{number} \\bmod 10 = 9$ 或 $\\textit{number} + 1 \\gt n$，那么说明末尾的数位已经搜索完成，退回上一位，即 $\\textit{number} = \\Big \\lfloor \\dfrac{\\textit{number}}{10} \\Big \\rfloor$，然后继续判断直到 $\\textit{number} \\bmod 10 \\ne 9$ 且 $\\textit{number} + 1 \\le n$ 为止，那么 $\\textit{number} + 1$ 是下一个字典序整数。\n\n字典序最小的整数为 $\\textit{number} = 1$，我们从它开始，然后依次获取下一个字典序整数，加入结果中，结束条件为已经获取到 $n$ 个整数。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        ans = [0] * n\n        num = 1\n        for i in range(n):\n            ans[i] = num\n            if num * 10 <= n:\n                num *= 10\n            else:\n                while num % 10 == 9 or num + 1 > n:\n                    num //= 10\n                num += 1\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> lexicalOrder(int n) {\n        vector<int> ret(n);\n        int number = 1;\n        for (int i = 0; i < n; i++) {\n            ret[i] = number;\n            if (number * 10 <= n) {\n                number *= 10;\n            } else {\n                while (number % 10 == 9 || number + 1 > n) {\n                    number /= 10;\n                }\n                number++;\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> lexicalOrder(int n) {\n        List<Integer> ret = new ArrayList<Integer>();\n        int number = 1;\n        for (int i = 0; i < n; i++) {\n            ret.add(number);\n            if (number * 10 <= n) {\n                number *= 10;\n            } else {\n                while (number % 10 == 9 || number + 1 > n) {\n                    number /= 10;\n                }\n                number++;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> LexicalOrder(int n) {\n        IList<int> ret = new List<int>();\n        int number = 1;\n        for (int i = 0; i < n; i++) {\n            ret.Add(number);\n            if (number * 10 <= n) {\n                number *= 10;\n            } else {\n                while (number % 10 == 9 || number + 1 > n) {\n                    number /= 10;\n                }\n                number++;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol1-C]\nint* lexicalOrder(int n, int* returnSize){\n    int *ret = (int *)malloc(sizeof(int) * n);\n    int number = 1;\n    for (int i = 0; i < n; i++) {\n        ret[i] = number;\n        if (number * 10 <= n) {\n            number *= 10;\n        } else {\n            while (number % 10 == 9 || number + 1 > n) {\n                number /= 10;\n            }\n            number++;\n        }\n    }\n    *returnSize = n;\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar lexicalOrder = function(n) {\n    const ret = [];\n    let number = 1;\n    for (let i = 0; i < n; i++) {\n        ret.push(number);\n        if (number * 10 <= n) {\n            number *= 10;\n        } else {\n            while (number % 10 === 9 || number + 1 > n) {\n                number = Math.floor(number / 10);\n            }\n            number++;\n        }\n    }\n    return ret;\n};\n```\n\n```go [sol1-Golang]\nfunc lexicalOrder(n int) []int {\n    ans := make([]int, n)\n    num := 1\n    for i := range ans {\n        ans[i] = num\n        if num*10 <= n {\n            num *= 10\n        } else {\n            for num%10 == 9 || num+1 > n {\n                num /= 10\n            }\n            num++\n        }\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 为整数的数目。获取下一个字典序整数的最坏时间复杂度为 $O(\\log n)$，但 $\\texttt{while}$ 循环的迭代次数与 $\\textit{number}$ 的末尾连续的 $9$ 的数目有关，在整数区间 $[1, n]$ 中，末尾连续的 $9$ 的数目为 $k$ 的整数不超过 $\\Big \\lceil \\dfrac{n}{10^k} \\Big \\rceil$ 个，其中 $1 \\le k \\le \\lceil \\log_{10} n \\rceil$，因此总迭代次数不超过 $\\sum_k k \\Big \\lceil \\dfrac{n}{10^k} \\Big \\rceil \\le 2n$，总时间复杂度为 $O(n)$。\n\n+ 空间复杂度：$O(1)$。返回值不计入空间复杂度。"
}