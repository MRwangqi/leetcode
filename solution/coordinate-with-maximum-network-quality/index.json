{
	"titleSlug": "coordinate-with-maximum-network-quality",
	"slug": "bao-li-suan-fa-du-ji-bai-liao-94-he-74-b-tkx6",
	"url": "https://leetcode-cn.com/problems/coordinate-with-maximum-network-quality/solution/bao-li-suan-fa-du-ji-bai-liao-94-he-74-b-tkx6/",
	"content": "![image.png](https://pic.leetcode-cn.com/1641387511-wxIhXW-image.png)\r\n\r\n\r\n----\r\n三层循环暴力计算\r\n\r\n\r\n```\r\nclass Solution {\r\n    public int[] bestCoordinate(int[][] towers, int radius) {\r\n         int[] ans = new int[2];\r\n            int max = 0;\r\n            int radius2 = radius * radius;\r\n\r\n            //获得需要遍历的范围\r\n            int ax = Integer.MAX_VALUE, ay = Integer.MAX_VALUE, bx = 0, by = 0;\r\n            for (int[] tower : towers) {\r\n                ax = Math.min(tower[0], ax);\r\n                bx = Math.max(tower[0], bx);\r\n                ay = Math.min(tower[1], ay);\r\n                by = Math.max(tower[1], by);\r\n\r\n            }\r\n\r\n\r\n            for (int i = ax; i <= bx; i++) {\r\n                for (int j = ay; j <= by; j++) {\r\n                    int signal = 0;\r\n                    for (int[] tower : towers) {\r\n                        int distance2 = \r\n                        (tower[0] - i) * (tower[0] - i) + \r\n                        (tower[1] - j) * (tower[1] - j);\r\n                        //如果距离小于radius，则signal加上此塔的信号\r\n                        if (distance2 <= radius2) {\r\n                            signal += Math.floor(tower[2] / (1 + Math.sqrt(distance2)));\r\n                        }\r\n                    }\r\n                    //取得最大的信号值和坐标点位置\r\n                    if (signal > max) {\r\n                        max = signal;\r\n                        ans[0] = i;\r\n                        ans[1] = j;\r\n                    }\r\n                }\r\n            }\r\n            return ans;\r\n    }\r\n}\r\n```\r\n"
}