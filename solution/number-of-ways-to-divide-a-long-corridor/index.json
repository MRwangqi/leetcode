{
	"titleSlug": "number-of-ways-to-divide-a-long-corridor",
	"slug": "fen-ge-chang-lang-de-fang-an-shu-by-leet-p9wr",
	"url": "https://leetcode-cn.com/problems/number-of-ways-to-divide-a-long-corridor/solution/fen-ge-chang-lang-de-fang-an-shu-by-leet-p9wr/",
	"content": "#### 方法一：乘法原理\n\n**思路与算法**\n\n我们可以按照顺序将座位每两个分成一组。在相邻两组之间，如果有 $x$ 个装饰植物，那么就有 $x + 1$ 种放置屏风的方法。根据乘法原理，总方案数就是所有 $x+1$ 的乘积。\n\n因此，我们只需要对数组 $\\textit{corridor}$ 进行一次遍历就可得到答案。在遍历的过程中，我们维护当前的座位总数 $\\textit{cnt}$ 和上一个座位的位置 $\\textit{prev}$。当遍历到 $\\textit{corridor}[i]$ 时，如果它是座位，并且包括它我们遍历到奇数（并且大于等于 $3$）个座位，那么 $\\textit{corridor}[i]$ 就是一个新的座位组的开始，它和上一个组之间就有 $i - \\textit{prev} - 1$ 个装饰植物，即 $i - \\textit{prev}$ 种放置屏风的方法。\n\n在遍历完成后，我们需要检查 $\\textit{cnt}$ 是否为偶数并且大于等于 $2$。如果不满足，那么需要返回 $0$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    static constexpr int mod = 1000000007;\n    \npublic:\n    int numberOfWays(string corridor) {\n        int n = corridor.size();\n        int prev = -1, cnt = 0, ans = 1;\n        for (int i = 0; i < n; ++i) {\n            if (corridor[i] == 'S') {\n                ++cnt;\n                if (cnt >= 3 && cnt % 2 == 1) {\n                    ans = static_cast<long long>(ans) * (i - prev) % mod;\n                }\n                prev = i;\n            }\n        }\n        if (cnt < 2 || cnt & 1) {\n            ans = 0;\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def numberOfWays(self, corridor: str) -> int:\n        mod = 10**9 + 7\n\n        prev, cnt, ans = -1, 0, 1\n        for i, ch in enumerate(corridor):\n            if ch == \"S\":\n                cnt += 1\n                if cnt >= 3 and cnt % 2 == 1:\n                    ans = ans * (i - prev) % mod\n                prev = i\n        \n        if cnt < 2 or cnt % 2 == 1:\n            ans = 0\n        \n        return ans\n```\n\n```Golang [sol1-Golang]\nfunc numberOfWays(corridor string) int {\n\tconst mod = 1e9 + 7\n\tprev, cnt, ans := -1, 0, 1\n\tfor i, ch := range corridor {\n\t\tif ch == 'S' {\n\t\t\tcnt += 1\n\t\t\tif (cnt >= 3) && (cnt%2 == 1) {\n\t\t\t\tans = ans * (i - prev) % mod\n\t\t\t}\n\t\t\tprev = i\n\t\t}\n\t}\n\tif (cnt < 2) || (cnt%2 == 1) {\n\t\tans = 0\n\t}\n\treturn ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。\n\n- 空间复杂度：$O(1)$。"
}