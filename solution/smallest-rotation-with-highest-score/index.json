{
	"titleSlug": "smallest-rotation-with-highest-score",
	"slug": "de-fen-zui-gao-de-zui-xiao-lun-diao-by-l-hbtd",
	"url": "https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/solution/de-fen-zui-gao-de-zui-xiao-lun-diao-by-l-hbtd/",
	"content": "#### 方法一：差分数组\n\n**思路和算法**\n\n最简单的做法是遍历每个可能的 $k$，计算轮调 $k$ 个位置之后的数组得分。假设数组的长度是 $n$，则有 $n$ 种可能的轮调，对于每种轮调都需要 $O(n)$ 的时间计算得分，总时间复杂度是 $O(n^2)$，对于 $n \\le 10^5$ 的数据范围会超出时间限制，因此需要优化。\n\n对于数组 $\\textit{nums}$ 中的元素 $x$，当 $x$ 所在下标大于或等于 $x$ 时，元素 $x$ 会记 $1$ 分。因此元素 $x$ 记 $1$ 分的下标范围是 $[x, n - 1]$，有 $n - x$ 个下标，元素 $x$ 不计分的下标范围是 $[0, x - 1]$，有 $x$ 个下标。\n\n假设元素 $x$ 的初始下标为 $i$，则当轮调下标为 $k$ 时，元素 $x$ 位于下标 $(i - k + n) \\bmod n$。如果元素 $x$ 记 $1$ 分，则有 $(i - k + n) \\bmod n \\ge x$，等价于 $k \\le (i - x + n) \\bmod n$。由于元素 $x$ 记 $1$ 分的下标有 $n - x$ 个，因此有 $k \\ge (i + 1) \\bmod n$。\n\n将取模运算去掉之后，可以得到 $k$ 的实际取值范围：\n\n- 当 $i < x$ 时，$i + 1 \\le k \\le i - x + n$；\n\n- 当 $i \\ge x$ 时，$k \\ge i + 1$ 或 $k \\le i - x$。\n\n对于数组 $\\textit{nums}$ 中的每个元素，都可以根据元素值与元素所在下标计算该元素记 $1$ 分的轮调下标范围。遍历所有元素之后，即可得到每个轮调下标对应的计 $1$ 分的元素个数，计 $1$ 分的元素个数最多的轮调下标即为得分最高的轮调下标。如果存在多个得分最高的轮调下标，则取其中最小的轮调下标。\n\n创建长度为 $n$ 的数组 $\\textit{points}$，其中 $\\textit{points}[k]$ 表示轮调下标为 $k$ 时的得分。对于数组 $\\textit{nums}$ 中的每个元素，得到该元素记 $1$ 分的轮调下标范围，然后将数组 $\\textit{points}$ 的该下标范围内的所有元素加 $1$。当数组 $\\textit{points}$ 中的元素值确定后，找到最大元素的最小下标。该做法的时间复杂度仍然是 $O(n^2)$，为了降低时间复杂度，需要利用差分数组。\n\n假设元素 $x$ 的初始下标为 $i$。当 $i < x$ 时应将 $\\textit{points}$ 的下标范围 $[i + 1, i - x + n]$ 内的所有元素加 $1$，当 $i \\ge x$ 时应将 $\\textit{points}$ 的下标范围 $[0, i - x]$ 和 $[i + 1, n - 1]$ 内的所有元素加 $1$。由于是将一段或两段连续下标范围内的元素加 $1$，因此可以使用差分数组实现。定义长度为 $n$ 的差分数组 $\\textit{diffs}$，其中 $\\textit{diffs}[k] = \\textit{points}[k] - \\textit{points}[k - 1]$（特别地，$\\textit{points}[-1] = 0$），具体做法是：令 $\\textit{low} = (i + 1) \\bmod n$，$\\textit{high} = (i - x + n + 1) \\bmod n$，将 $\\textit{diffs}[\\textit{low}]$ 的值加 $1$，将 $\\textit{diffs}[\\textit{high}]$ 的值减 $1$，如果 $\\textit{low} \\ge \\textit{high}$ 则将 $\\textit{diffs}[0]$ 的值加 $1$。\n\n遍历数组 $\\textit{nums}$ 的所有元素并更新差分数组之后，遍历数组 $\\textit{diffs}$ 并计算前缀和，则每个下标处的前缀和表示当前轮调下标处的得分。在遍历过程中维护最大得分和最大得分的最小轮调下标，遍历结束之后即可得到结果。\n\n实现方面，不需要显性创建数组 $\\textit{points}$，只需要创建差分数组 $\\textit{diffs}$，遍历数组 $\\textit{diffs}$ 时即可根据前缀和得到数组 $\\textit{points}$ 中的每个元素值。\n\n**证明**\n\n差分数组做法的正确性证明需要考虑 $\\textit{low}$ 和 $\\textit{high}$ 的不同情况。\n\n1. 如果 $\\textit{low} \\le \\textit{high} - 1 < n - 1$，则有 $\\textit{low} < \\textit{high} < n$，更新 $\\textit{diffs}$ 等价于将数组 $\\textit{points}$ 的下标范围 $[\\textit{low}, \\textit{high} - 1]$ 内的所有元素加 $1$。\n\n2. 如果 $\\textit{low} \\le \\textit{high} + n - 1 = n - 1$，则有 $0 = \\textit{high} \\le \\textit{low}$，更新 $\\textit{diffs}$ 等价于将数组 $\\textit{points}$ 的下标范围 $[\\textit{low}, n - 1]$ 内的所有元素加 $1$，$\\textit{diffs}[0]$ 先减 $1$ 后加 $1$ 因此 $\\textit{diffs}[0]$ 没有变化，同第 1 种情况。\n\n3. 如果 $\\textit{low} \\ge \\textit{high} \\ne 0$，则需要将 $\\textit{diffs}[0]$ 加 $1$，更新 $\\textit{diffs}$ 等价于将数组 $\\textit{points}$ 的下标范围 $[\\textit{low}, n - 1]$ 和 $[0, \\textit{high} - 1]$ 内的所有元素加 $1$。\n\n上述三种情况对应的更新数组 $\\textit{points}$ 的效果都符合预期，因此差分数组的做法可以得到正确的结果。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public int bestRotation(int[] nums) {\n        int n = nums.length;\n        int[] diffs = new int[n];\n        for (int i = 0; i < n; i++) {\n            int low = (i + 1) % n;\n            int high = (i - nums[i] + n + 1) % n;\n            diffs[low]++;\n            diffs[high]--;\n            if (low >= high) {\n                diffs[0]++;\n            }\n        }\n        int bestIndex = 0;\n        int maxScore = 0;\n        int score = 0;\n        for (int i = 0; i < n; i++) {\n            score += diffs[i];\n            if (score > maxScore) {\n                bestIndex = i;\n                maxScore = score;\n            }\n        }\n        return bestIndex;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int BestRotation(int[] nums) {\n        int n = nums.Length;\n        int[] diffs = new int[n];\n        for (int i = 0; i < n; i++) {\n            int low = (i + 1) % n;\n            int high = (i - nums[i] + n + 1) % n;\n            diffs[low]++;\n            diffs[high]--;\n            if (low >= high) {\n                diffs[0]++;\n            }\n        }\n        int bestIndex = 0;\n        int maxScore = 0;\n        int score = 0;\n        for (int i = 0; i < n; i++) {\n            score += diffs[i];\n            if (score > maxScore) {\n                bestIndex = i;\n                maxScore = score;\n            }\n        }\n        return bestIndex;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int bestRotation(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> diffs(n);\n        for (int i = 0; i < n; i++) {\n            int low = (i + 1) % n;\n            int high = (i - nums[i] + n + 1) % n;\n            diffs[low]++;\n            diffs[high]--;\n            if (low >= high) {\n                diffs[0]++;\n            }\n        }\n        int bestIndex = 0;\n        int maxScore = 0;\n        int score = 0;\n        for (int i = 0; i < n; i++) {\n            score += diffs[i];\n            if (score > maxScore) {\n                bestIndex = i;\n                maxScore = score;\n            }\n        }\n        return bestIndex;\n    }\n};\n```\n\n```C [sol1-C]\nint bestRotation(int* nums, int numsSize){\n    int * diffs = (int *)malloc(sizeof(int) * numsSize);\n    memset(diffs, 0, sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        int low = (i + 1) % numsSize;\n        int high = (i - nums[i] + numsSize + 1) % numsSize;\n        diffs[low]++;\n        diffs[high]--;\n        if (low >= high) {\n            diffs[0]++;\n        }\n    }\n    int bestIndex = 0;\n    int maxScore = 0;\n    int score = 0;\n    for (int i = 0; i < numsSize; i++) {\n        score += diffs[i];\n        if (score > maxScore) {\n            bestIndex = i;\n            maxScore = score;\n        }\n    }\n    free(diffs);\n    return bestIndex;\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def bestRotation(self, nums: List[int]) -> int:\n        n = len(nums)\n        diffs = [0] * n\n        for i, num in enumerate(nums):\n            low = (i + 1) % n\n            high = (i - num + n + 1) % n\n            diffs[low] += 1\n            diffs[high] -= 1\n            if low >= high:\n                diffs[0] += 1\n        score, maxScore, idx = 0, 0, 0\n        for i, diff in enumerate(diffs):\n            score += diff\n            if score > maxScore:\n                maxScore, idx = score, i\n        return idx\n```\n\n```go [sol1-Golang]\nfunc bestRotation(nums []int) int {\n    n := len(nums)\n    diffs := make([]int, n)\n    for i, num := range nums {\n        low := (i + 1) % n\n        high := (i - num + n + 1) % n\n        diffs[low]++\n        diffs[high]--\n        if low >= high {\n            diffs[0]++\n        }\n    }\n    score, maxScore, idx := 0, 0, 0\n    for i, diff := range diffs {\n        score += diff\n        if score > maxScore {\n            maxScore, idx = score, i\n        }\n    }\n    return idx\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar bestRotation = function(nums) {\n    const n = nums.length;\n    const diffs = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        const low = (i + 1) % n;\n        const high = (i - nums[i] + n + 1) % n;\n        diffs[low]++;\n        diffs[high]--;\n        if (low >= high) {\n            diffs[0]++;\n        }\n    }\n    let bestIndex = 0;\n    let maxScore = 0;\n    let score = 0;\n    for (let i = 0; i < n; i++) {\n        score += diffs[i];\n        if (score > maxScore) {\n            bestIndex = i;\n            maxScore = score;\n        }\n    }\n    return bestIndex;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。需要遍历数组 $\\textit{nums}$ 两次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。需要创建长度为 $n$ 的数组 $\\textit{diffs}$。"
}