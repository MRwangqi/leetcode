{
	"titleSlug": "maximum-score-of-a-node-sequence",
	"slug": "by-endlesscheng-dt8h",
	"url": "https://leetcode-cn.com/problems/maximum-score-of-a-node-sequence/solution/by-endlesscheng-dt8h/",
	"content": "#### 提示 1-1\r\n\r\n试试枚举可不可以。（做题时优先考虑最简单的算法）\r\n\r\n#### 提示 1-2\r\n\r\n枚举谁呢？可以枚举点，也可以枚举边。\r\n\r\n#### 提示 2-1\r\n\r\n**简化问题**可以帮助我们找到思路。\r\n\r\n如果序列长度为 $3$，要如何枚举？\r\n\r\n#### 提示 2-2\r\n\r\n只要 $3$ 个节点的话，我们可以枚举端点，可以枚举中间的节点，还可以枚举边。\r\n\r\n这几种方案都试着想一想，哪一种是最方便的呢？\r\n\r\n#### 提示 2-3\r\n\r\n枚举**中间**的点是最方便的，算出与其相邻的分数最大的两个点即可。\r\n\r\n相比枚举端点，**枚举中间的效率也要更高**。\r\n\r\n顺着这个思路去思考原问题。\r\n\r\n#### 提示 3-1\r\n\r\n设序列为 $a-x-y-b$（$-$ 表示边），枚举 $\\textit{edges}$ 中的每条边，作为序列**正中间**的那条边，即 $x-y$。\r\n\r\n#### 提示 3-2\r\n\r\n我们需要把与 $x$ 相邻的点中，分数最大且不同于 $y$ 和 $b$ 的点作为 $a$；把与 $y$ 相邻的点中，分数最大且不同于 $x$ 和 $a$ 的点作为 $b$。\r\n\r\n#### 提示 3-3\r\n\r\n与 $x$ 相邻的点中，由于只需要与 $y$ 和 $b$ 不一样，我们仅需要保留分数最大的三个点，$a$ 必定在这三个点中。\r\n\r\n#### 提示 3-4\r\n\r\n剩下要做的，就是在枚举 $\\textit{edges}$ 前，预处理出这三个点。\r\n\r\n代码实现时，可以用排序（见 Go 和 Java）、堆（见 Python `nlargest`）、快速选择（见 C++ `nth_element`）或者手动维护求前三大。最优的时间复杂度为 $O(n+m)$。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\r\n        g = [[] for _ in range(len(scores))]\r\n        for x, y in edges:\r\n            g[x].append((scores[y], y))\r\n            g[y].append((scores[x], x))\r\n        for i, vs in enumerate(g):\r\n            if len(vs) > 3: \r\n                g[i] = nlargest(3, vs)\r\n\r\n        # 下面这一段可以简写成一行，为了可读性这里就不写了\r\n        ans = -1\r\n        for x, y in edges:\r\n            for score_a, a in g[x]:\r\n                for score_b, b in g[y]:\r\n                    if y != a != b != x:\r\n                        ans = max(ans, score_a + scores[x] + scores[y] + score_b)\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int maximumScore(int[] scores, int[][] edges) {\r\n        var n = scores.length;\r\n        List<int[]>[] g = new ArrayList[n];\r\n        Arrays.setAll(g, e -> new ArrayList<>());\r\n        for (var e : edges) {\r\n            int x = e[0], y = e[1];\r\n            g[x].add(new int[]{scores[y], y});\r\n            g[y].add(new int[]{scores[x], x});\r\n        }\r\n        for (var i = 0; i < n; i++)\r\n            if (g[i].size() > 3) {\r\n                g[i].sort((a, b) -> (b[0] - a[0]));\r\n                g[i] = new ArrayList<>(g[i].subList(0, 3));\r\n            }\r\n\r\n        var ans = -1;\r\n        for (var e : edges) {\r\n            int x = e[0], y = e[1];\r\n            for (var p : g[x]) {\r\n                var a = p[1];\r\n                for (var q : g[y]) {\r\n                    var b = q[1];\r\n                    if (a != y && b != x && a != b)\r\n                        ans = Math.max(ans, p[0] + scores[x] + scores[y] + q[0]);\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int maximumScore(vector<int> &scores, vector<vector<int>> &edges) {\r\n        int n = scores.size();\r\n        vector<vector<pair<int, int>>> g(n);\r\n        for (auto &e : edges) {\r\n            int x = e[0], y = e[1];\r\n            g[x].emplace_back(-scores[y], y);\r\n            g[y].emplace_back(-scores[x], x);\r\n        }\r\n        for (auto &vs : g)\r\n            if (vs.size() > 3) {\r\n                nth_element(vs.begin(), vs.begin() + 3, vs.end());\r\n                vs.resize(3);\r\n            }\r\n\r\n        int ans = -1;\r\n        for (auto &e : edges) {\r\n            int x = e[0], y = e[1];\r\n            for (auto &[score_a, a] : g[x])\r\n                for (auto &[score_b, b] : g[y])\r\n                    if (a != y && b != x && a != b)\r\n                        ans = max(ans, -score_a + scores[x] + scores[y] - score_b);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc maximumScore(scores []int, edges [][]int) int {\r\n\ttype nb struct{ to, s int }\r\n\tg := make([][]nb, len(scores))\r\n\tfor _, e := range edges {\r\n\t\tx, y := e[0], e[1]\r\n\t\tg[x] = append(g[x], nb{y, scores[y]})\r\n\t\tg[y] = append(g[y], nb{x, scores[x]})\r\n\t}\r\n\tfor i, vs := range g {\r\n\t\tif len(vs) > 3 {\r\n\t\t\tsort.Slice(vs, func(i, j int) bool { return vs[i].s > vs[j].s })\r\n\t\t\tg[i] = vs[:3]\r\n\t\t}\r\n\t}\r\n\r\n\tans := -1\r\n\tfor _, e := range edges {\r\n\t\tx, y := e[0], e[1]\r\n\t\tfor _, p := range g[x] {\r\n\t\t\tfor _, q := range g[y] {\r\n\t\t\t\tif p.to != y && q.to != x && p.to != q.to {\r\n\t\t\t\t\tans = max(ans, p.s+scores[x]+scores[y]+q.s)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n#### 相似题目\r\n\r\n- [Codeforces 666B. World Tour](https://codeforces.com/problemset/problem/666/B)\r\n\r\n#### 最后\r\n\r\n欢迎关注我的B站频道：[灵茶山艾府](https://space.bilibili.com/206214)，定期更新算法讲解视频哦~\r\n"
}