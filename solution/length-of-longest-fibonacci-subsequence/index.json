{
	"titleSlug": "length-of-longest-fibonacci-subsequence",
	"slug": "zui-chang-de-fei-bo-na-qi-zi-xu-lie-de-c-8trz",
	"url": "https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/solution/zui-chang-de-fei-bo-na-qi-zi-xu-lie-de-c-8trz/",
	"content": "#### 方法一：动态规划\n\n如果数组 $\\textit{arr}$ 中存在三个下标 $i$、$j$、$k$ 满足 $\\textit{arr}[i] > \\textit{arr}[j] > \\textit{arr}[k]$ 且 $\\textit{arr}[k] + \\textit{arr}[j] = \\textit{arr}[i]$，则 $\\textit{arr}[k]$、$\\textit{arr}[j]$ 和 $\\textit{arr}[i]$ 三个元素组成一个斐波那契子序列。由于数组 $\\textit{arr}$ 严格递增，因此 $\\textit{arr}[i] > \\textit{arr}[j] > \\textit{arr}[k]$ 等价于 $i > j > k$。\n\n当下标 $i$ 确定时，任何小于下标 $i$ 的下标 $j$ 都可能满足 $\\textit{arr}[j]$ 是某个斐波那契子序列中 $\\textit{arr}[i]$ 前面的一个数字，因此只有当确定斐波那契子序列的最后两个数字时，才能确定整个斐波那契子序列。\n\n定义二维数组 $\\textit{dp}$ 表示以每个下标对的元素作为最后两个数字的斐波那契子序列的最大长度。当 $i > j$ 时，$\\textit{dp}[j][i]$ 表示以 $\\textit{arr}[j]$ 和 $\\textit{arr}[i]$ 作为最后两个数字的斐波那契子序列的最大长度。初始时 $\\textit{dp}$ 中的所有值都是 $0$。\n\n为了计算 $\\textit{dp}[j][i]$ 的值，需要得到该斐波那契序列中位于 $\\textit{arr}[j]$ 前面的数字，该数字是 $\\textit{arr}[i] - \\textit{arr}[j]$。如果 $\\textit{arr}[i] - \\textit{arr}[j]$ 存在于数组 $\\textit{arr}$ 中，且该数字小于 $\\textit{arr}[j]$，则用 $k$ 表示其下标，有 $\\textit{arr}[k] + \\textit{arr}[j] = \\textit{arr}[i]$。因此在以 $\\textit{arr}[k]$ 和 $\\textit{arr}[j]$ 作为最后两个数字的斐波那契子序列的后面添加 $\\textit{arr}[i]$，即可得到以 $\\textit{arr}[j]$ 和 $\\textit{arr}[i]$ 作为最后两个数字的斐波那契子序列。\n\n根据斐波那契子序列的定义可知，斐波那契子序列的长度至少为 $3$。当 $\\textit{dp}[k][j] \\ge 3$ 时，$\\textit{dp}[j][i] = \\textit{dp}[k][j] + 1$。当 $\\textit{dp}[k][j] < 3$ 时，以 $\\textit{arr}[k]$ 和 $\\textit{arr}[j]$ 作为最后两个数字的斐波那契子序列并不存在，但是以 $\\textit{arr}[j]$ 和 $\\textit{arr}[i]$ 作为最后两个数字的斐波那契子序列存在，此时有 $\\textit{dp}[j][i] = 3$。\n\n假设当 $\\textit{arr}[i] - \\textit{arr}[j]$ 不存在于数组中时，$k < 0$，则完整的状态转移方程如下：\n\n$$\n\\textit{dp}[j][i] = \\begin{cases}\n\\max(\\textit{dp}[k][j] + 1, 3), & 0 \\le k < j \\\\\n0, & k < 0 \\text{~or~} k \\ge j\n\\end{cases}\n$$\n\n实现方面可以利用数组 $\\textit{arr}$ 的单调性优化。由于数组 $\\textit{arr}$ 是严格单调递增的，因此在确定下标 $i$ 的情况下可以反向遍历下标 $j$，计算 $\\textit{dp}[j][i]$ 的值，只有当 $\\textit{arr}[j] \\times 2 > \\textit{arr}[i]$ 时才满足 $\\textit{arr}[k] < \\textit{arr}[j]$，当 $\\textit{arr}[j] \\times 2 \\le \\textit{arr}[i]$ 时不需要对当前下标 $i$ 继续遍历更小的下标 $j$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\n        indices = {x: i for i, x in enumerate(arr)}\n        ans, n = 0, len(arr)\n        dp = [[0] * n for _ in range(n)]\n        for i, x in enumerate(arr):\n            for j in range(n - 1, -1, -1):\n                if arr[j] * 2 <= x:\n                    break\n                if x - arr[j] in indices:\n                    k = indices[x - arr[j]]\n                    dp[j][i] = max(dp[k][j] + 1, 3)\n                    ans = max(ans, dp[j][i])\n        return ans\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int lenLongestFibSubseq(int[] arr) {\n        Map<Integer, Integer> indices = new HashMap<Integer, Integer>();\n        int n = arr.length;\n        for (int i = 0; i < n; i++) {\n            indices.put(arr[i], i);\n        }\n        int[][] dp = new int[n][n];\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i - 1; j >= 0 && arr[j] * 2 > arr[i]; j--) {\n                int k = indices.getOrDefault(arr[i] - arr[j], -1);\n                if (k >= 0) {\n                    dp[j][i] = Math.max(dp[k][j] + 1, 3);\n                }\n                ans = Math.max(ans, dp[j][i]);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int LenLongestFibSubseq(int[] arr) {\n        Dictionary<int, int> indices = new Dictionary<int, int>();\n        int n = arr.Length;\n        for (int i = 0; i < n; i++) {\n            indices.Add(arr[i], i);\n        }\n        int[,] dp = new int[n, n];\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i - 1; j >= 0 && arr[j] * 2 > arr[i]; j--) {\n                int k = indices.ContainsKey(arr[i] - arr[j]) ? indices[arr[i] - arr[j]] : -1;\n                if (k >= 0) {\n                    dp[j, i] = Math.Max(dp[k, j] + 1, 3);\n                }\n                ans = Math.Max(ans, dp[j, i]);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& arr) {\n        unordered_map<int, int> indices;\n        int n = arr.size();\n        for (int i = 0; i < n; i++) {\n            indices[arr[i]] = i;\n        }\n        vector<vector<int>> dp(n, vector<int>(n));\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i - 1; j >= 0 && arr[j] * 2 > arr[i]; j--) {\n                int k = -1;\n                if (indices.count(arr[i] - arr[j])) {\n                    k = indices[arr[i] - arr[j]];\n                }\n                if (k >= 0) {\n                    dp[j][i] = max(dp[k][j] + 1, 3);\n                }\n                ans = max(ans, dp[j][i]);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} HashItem;\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint lenLongestFibSubseq(int* arr, int arrSize){\n    HashItem *indices = NULL, *pEntry = NULL;\n    for (int i = 0; i < arrSize; i++) {\n        pEntry = (HashItem *)malloc(sizeof(HashItem));\n        pEntry->key = arr[i];\n        pEntry->val = i;\n        HASH_ADD_INT(indices, key, pEntry);\n    }\n    int **dp = (int **)malloc(sizeof(int *) * arrSize);\n    int ans = 0;\n    for (int i = 0; i < arrSize; i++) {\n        dp[i] = (int *)malloc(sizeof(int) * arrSize);\n        memset(dp[i], 0, sizeof(int) * arrSize);\n    }\n    for (int i = 0; i < arrSize; i++) {\n        for (int j = i - 1; j >= 0 && arr[j] * 2 > arr[i]; j--) {\n            int k = -1;\n            int target = arr[i] - arr[j];\n            pEntry = NULL;\n            HASH_FIND_INT(indices, &target, pEntry);\n            if (pEntry) {\n                k = pEntry->val;\n            }\n            if (k >= 0) {\n                dp[j][i] = MAX(dp[k][j] + 1, 3);\n            }\n            ans = MAX(ans, dp[j][i]);\n        }\n    }\n    for (int i = 0; i < arrSize; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, indices, curr, tmp) {\n        HASH_DEL(indices, curr);  \n        free(curr);         \n    }\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc lenLongestFibSubseq(arr []int) (ans int) {\n    n := len(arr)\n    indices := make(map[int]int, n)\n    for i, x := range arr {\n        indices[x] = i\n    }\n    dp := make([][]int, n)\n    for i := range dp {\n        dp[i] = make([]int, n)\n    }\n    for i, x := range arr {\n        for j := n - 1; j >= 0 && arr[j]*2 > x; j-- {\n            if k, ok := indices[x-arr[j]]; ok {\n                dp[j][i] = max(dp[k][j]+1, 3)\n                ans = max(ans, dp[j][i])\n            }\n        }\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar lenLongestFibSubseq = function(arr) {\n    const indices = new Map();\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        indices.set(arr[i], i);\n    }\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    let ans = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (arr[j] * 2 <= arr[i]) {\n                break;\n            }\n            if (indices.has(arr[i] - arr[j])) {\n                const k = indices.get(arr[i] - arr[j]);\n                dp[j][i] = Math.max(dp[k][j] + 1, 3);\n                ans = Math.max(ans, dp[j][i]);\n            }\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度。动态规划的状态数是 $O(n^2)$，每个状态的计算时间都是 $O(1)$。\n\n- 空间复杂度：$O(n^2)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度。需要创建二维数组 $\\textit{dp}$，空间是 $O(n^2)$。"
}