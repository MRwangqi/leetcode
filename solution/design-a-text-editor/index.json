{
	"titleSlug": "design-a-text-editor",
	"slug": "lian-biao-mo-ni-pythonjavacgo-by-endless-egw4",
	"url": "https://leetcode-cn.com/problems/design-a-text-editor/solution/lian-biao-mo-ni-pythonjavacgo-by-endless-egw4/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1w34y1L7yu/) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n## 方法一：双向链表\r\n\r\n#### 提示 1\r\n\r\n注意添加、删除和移动操作均在光标附近完成，且 $\\textit{text}$ 的长度和 $k$ 都很小。\r\n\r\n#### 提示 2\r\n\r\n用链表模拟所有操作，每个节点存储一个字符。\r\n\r\n光标指向链表中的一个节点（该节点保存着光标左边的字符）。\r\n\r\n#### 提示 3\r\n\r\n用一个哨兵节点表示光标位于文本最左侧的情况，此时光标左侧无字符，即指向哨兵节点。\r\n\r\n#### 复杂度分析\r\n\r\n时空复杂度均与输入量成正比（线性）。\r\n\r\n```Python [sol1-Python3]\r\n# 手写双向链表\r\nclass Node:\r\n    __slots__ = 'prev', 'next', 'ch'\r\n\r\n    def __init__(self, ch=''):\r\n        self.prev = None\r\n        self.next = None\r\n        self.ch = ch\r\n\r\n    # 在 self 后插入 node，并返回该 node\r\n    def insert(self, node: 'Node') -> 'Node':\r\n        node.prev = self\r\n        node.next = self.next\r\n        node.prev.next = node\r\n        node.next.prev = node\r\n        return node\r\n\r\n    # 从链表中移除 self\r\n    def remove(self) -> None:\r\n        self.prev.next = self.next\r\n        self.next.prev = self.prev\r\n\r\nclass TextEditor:\r\n    def __init__(self):\r\n        self.root = self.cur = Node()  # 哨兵节点\r\n        self.root.prev = self.root\r\n        self.root.next = self.root  # 初始化双向链表，下面判断节点的 next 若为 self.root，则表示 next 为空\r\n\r\n    def addText(self, text: str) -> None:\r\n        for ch in text:\r\n            self.cur = self.cur.insert(Node(ch))\r\n\r\n    def deleteText(self, k: int) -> int:\r\n        k0 = k\r\n        while k and self.cur != self.root:\r\n            self.cur = self.cur.prev\r\n            self.cur.next.remove()\r\n            k -= 1\r\n        return k0 - k\r\n\r\n    def text(self) -> str:\r\n        s = []\r\n        k, cur = 10, self.cur\r\n        while k and cur != self.root:\r\n            s.append(cur.ch)\r\n            cur = cur.prev\r\n            k -= 1\r\n        return ''.join(reversed(s))\r\n\r\n    def cursorLeft(self, k: int) -> str:\r\n        while k and self.cur != self.root:\r\n            self.cur = self.cur.prev\r\n            k -= 1\r\n        return self.text()\r\n\r\n    def cursorRight(self, k: int) -> str:\r\n        while k and self.cur.next != self.root:\r\n            self.cur = self.cur.next\r\n            k -= 1\r\n        return self.text()\r\n```\r\n\r\n```java [sol1-Java]\r\nclass TextEditor {\r\n    Node root, cur;\r\n\r\n    public TextEditor() {\r\n        root = cur = new Node(); // 哨兵节点\r\n        root.prev = root;\r\n        root.next = root; // 初始化双向链表，下面判断节点的 next 若为 root，则表示 next 为空\r\n    }\r\n\r\n    public void addText(String text) {\r\n        for (var i = 0; i < text.length(); i++)\r\n            cur = cur.insert(new Node(text.charAt(i)));\r\n    }\r\n\r\n    public int deleteText(int k) {\r\n        var k0 = k;\r\n        for (; k > 0 && cur != root; --k) {\r\n            cur = cur.prev;\r\n            cur.next.remove();\r\n        }\r\n        return k0 - k;\r\n    }\r\n\r\n    String text() {\r\n        var s = new StringBuilder();\r\n        var cur = this.cur;\r\n        for (var k = 10; k > 0 && cur != root; --k) {\r\n            s.append(cur.ch);\r\n            cur = cur.prev;\r\n        }\r\n        return s.reverse().toString();\r\n    }\r\n\r\n    public String cursorLeft(int k) {\r\n        for (; k > 0 && cur != root; --k)\r\n            cur = cur.prev;\r\n        return text();\r\n    }\r\n\r\n    public String cursorRight(int k) {\r\n        for (; k > 0 && cur.next != root; --k)\r\n            cur = cur.next;\r\n        return text();\r\n    }\r\n}\r\n\r\n// 手写双向链表\r\nclass Node {\r\n    Node prev, next;\r\n    char ch;\r\n\r\n    Node() {}\r\n\r\n    Node(char ch) {\r\n        this.ch = ch;\r\n    }\r\n\r\n    // 在 this 后插入 node，并返回该 node\r\n    Node insert(Node node) {\r\n        node.prev = this;\r\n        node.next = this.next;\r\n        node.prev.next = node;\r\n        node.next.prev = node;\r\n        return node;\r\n    }\r\n\r\n    // 从链表中移除 this\r\n    void remove() {\r\n        this.prev.next = this.next;\r\n        this.next.prev = this.prev;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass TextEditor {\r\n    list<char> l;\r\n    list<char>::iterator cur = l.begin();\r\n\r\npublic:\r\n    void addText(string text) {\r\n        for (char ch : text)\r\n            l.insert(cur, ch);\r\n    }\r\n\r\n    int deleteText(int k) {\r\n        int k0 = k;\r\n        for (; k && cur != l.begin(); --k)\r\n            cur = l.erase(prev(cur));\r\n        return k0 - k;\r\n    }\r\n\r\n    string text() {\r\n        string s;\r\n        auto it = cur;\r\n        for (int k = 10; k && it != l.begin(); --k)\r\n            s += *--it;\r\n        reverse(s.begin(), s.end());\r\n        return s;\r\n    }\r\n\r\n    string cursorLeft(int k) {\r\n        for (; k && cur != l.begin(); --k)\r\n            --cur;\r\n        return text();\r\n    }\r\n\r\n    string cursorRight(int k) {\r\n        for (; k && cur != l.end(); --k)\r\n            ++cur;\r\n        return text();\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\ntype TextEditor struct {\r\n\t*list.List\r\n\tcur *list.Element\r\n}\r\n\r\nfunc Constructor() TextEditor {\r\n\tl := list.New()\r\n\treturn TextEditor{l, l.PushBack(nil)} // 哨兵节点\r\n}\r\n\r\nfunc (l *TextEditor) AddText(text string) {\r\n\tfor _, ch := range text {\r\n\t\tl.cur = l.InsertAfter(byte(ch), l.cur)\r\n\t}\r\n}\r\n\r\nfunc (l *TextEditor) DeleteText(k int) int {\r\n\tk0 := k\r\n\tfor ; k > 0 && l.cur.Value != nil; k-- {\r\n\t\tpre := l.cur.Prev()\r\n\t\tl.Remove(l.cur)\r\n\t\tl.cur = pre\r\n\t}\r\n\treturn k0 - k\r\n}\r\n\r\nfunc (l *TextEditor) text() string {\r\n\ts := []byte{}\r\n\tfor k, cur := 10, l.cur; k > 0 && cur.Value != nil; k-- {\r\n\t\ts = append(s, cur.Value.(byte))\r\n\t\tcur = cur.Prev()\r\n\t}\r\n\tfor i, n := 0, len(s); i < n/2; i++ {\r\n\t\ts[i], s[n-1-i] = s[n-1-i], s[i] // reverse s\r\n\t}\r\n\treturn string(s)\r\n}\r\n\r\nfunc (l *TextEditor) CursorLeft(k int) string {\r\n\tfor ; k > 0 && l.cur.Value != nil; k-- {\r\n\t\tl.cur = l.cur.Prev()\r\n\t}\r\n\treturn l.text()\r\n}\r\n\r\nfunc (l *TextEditor) CursorRight(k int) string {\r\n\tfor ; k > 0 && l.cur.Next() != nil; k-- {\r\n\t\tl.cur = l.cur.Next()\r\n\t}\r\n\treturn l.text()\r\n}\r\n```\r\n\r\n\r\n## 方法二：对顶栈\r\n\r\n用两个栈头对头，光标的左右移动就相当于两个栈来回倒；对于插入和删除操作，就相当于在左边那个栈上入栈出栈。\r\n\r\n#### 复杂度分析\r\n\r\n时空复杂度均与输入量成正比（线性）。\r\n\r\n#### 相似题目\r\n\r\n- [HDU4699 Editor](http://acm.hdu.edu.cn/showproblem.php?pid=4699)\r\n\r\n```Python [sol2-Python3]\r\nclass TextEditor:\r\n    def __init__(self):\r\n        self.left, self.right = [], []\r\n\r\n    def addText(self, text: str) -> None:\r\n        self.left.extend(list(text))\r\n\r\n    def deleteText(self, k: int) -> int:\r\n        k0 = k\r\n        while k and self.left:\r\n            self.left.pop()\r\n            k -= 1\r\n        return k0 - k\r\n\r\n    def text(self) -> str:\r\n        return ''.join(self.left[-10:])\r\n\r\n    def cursorLeft(self, k: int) -> str:\r\n        while k and self.left:\r\n            self.right.append(self.left.pop())\r\n            k -= 1\r\n        return self.text()\r\n\r\n    def cursorRight(self, k: int) -> str:\r\n        while k and self.right:\r\n            self.left.append(self.right.pop())\r\n            k -= 1\r\n        return self.text()\r\n```\r\n\r\n```java [sol2-Java]\r\nclass TextEditor {\r\n    StringBuilder left = new StringBuilder(), right = new StringBuilder();\r\n\r\n    public void addText(String text) {\r\n        left.append(text);\r\n    }\r\n\r\n    public int deleteText(int k) {\r\n        k = Math.min(k, left.length());\r\n        left.setLength(left.length() - k);\r\n        return k;\r\n    }\r\n\r\n    String text() {\r\n        return left.substring(Math.max(left.length() - 10, 0));\r\n    }\r\n\r\n    public String cursorLeft(int k) {\r\n        for (; k > 0 && !left.isEmpty(); --k) {\r\n            right.append(left.charAt(left.length() - 1));\r\n            left.deleteCharAt(left.length() - 1);\r\n        }\r\n        return text();\r\n    }\r\n\r\n    public String cursorRight(int k) {\r\n        for (; k > 0 && !right.isEmpty(); --k) {\r\n            left.append(right.charAt(right.length() - 1));\r\n            right.deleteCharAt(right.length() - 1);\r\n        }\r\n        return text();\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol2-C++]\r\nclass TextEditor {\r\n    string left, right;\r\n\r\npublic:\r\n    void addText(string text) {\r\n        left += text;\r\n    }\r\n\r\n    int deleteText(int k) {\r\n        k = min(k, (int) left.length());\r\n        left.resize(left.length() - k);\r\n        return k;\r\n    }\r\n\r\n    string text() {\r\n        return left.substr(max((int) left.size() - 10, 0));\r\n    }\r\n\r\n    string cursorLeft(int k) {\r\n        for (; k && !left.empty(); --k) {\r\n            right += left.back();\r\n            left.pop_back();\r\n        }\r\n        return text();\r\n    }\r\n\r\n    string cursorRight(int k) {\r\n        for (; k && !right.empty(); --k) {\r\n            left += right.back();\r\n            right.pop_back();\r\n        }\r\n        return text();\r\n    }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\ntype TextEditor struct{ l, r []byte }\r\n\r\nfunc Constructor() TextEditor { return TextEditor{} }\r\n\r\nfunc (t *TextEditor) AddText(text string) {\r\n\tt.l = append(t.l, text...)\r\n}\r\n\r\nfunc (t *TextEditor) DeleteText(k int) int {\r\n\tif k < len(t.l) {\r\n\t\tt.l = t.l[:len(t.l)-k]\r\n\t} else {\r\n\t\tk = len(t.l)\r\n\t\tt.l = t.l[:0]\r\n\t}\r\n\treturn k\r\n}\r\n\r\nfunc (t *TextEditor) text() string {\r\n\treturn string(t.l[max(len(t.l)-10, 0):])\r\n}\r\n\r\nfunc (t *TextEditor) CursorLeft(k int) string {\r\n\tfor ; k > 0 && len(t.l) > 0; k-- {\r\n\t\tt.r = append(t.r, t.l[len(t.l)-1])\r\n\t\tt.l = t.l[:len(t.l)-1]\r\n\t}\r\n\treturn t.text()\r\n}\r\n\r\nfunc (t *TextEditor) CursorRight(k int) string {\r\n\tfor ; k > 0 && len(t.r) > 0; k-- {\r\n\t\tt.l = append(t.l, t.r[len(t.r)-1])\r\n\t\tt.r = t.r[:len(t.r)-1]\r\n\t}\r\n\treturn t.text()\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n## 方法三：Splay（超纲）\r\n\r\n本题还可以用 [Splay](https://oi-wiki.org/ds/splay/) 来模拟文本的添加和删除，由于该算法超纲，感兴趣的同学可以查阅相关资料。具体做法在本题的 [视频讲解](https://www.bilibili.com/video/BV1w34y1L7yu/) 中有说明。完整的 Splay 模板见我的 [算法竞赛模板库](https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/splay.go)。\r\n\r\n```go [sol3-Go]\r\ntype node struct {\r\n\tch  [2]*node\r\n\tsz  int\r\n\tkey byte\r\n}\r\n\r\n// 设置如下返回值是为了方便使用 node 中的 ch 数组\r\nfunc (o *node) cmpKth(k int) int {\r\n\td := k - o.ch[0].size() - 1\r\n\tswitch {\r\n\tcase d < 0:\r\n\t\treturn 0 // 左儿子\r\n\tcase d > 0:\r\n\t\treturn 1 // 右儿子\r\n\tdefault:\r\n\t\treturn -1\r\n\t}\r\n}\r\n\r\nfunc (o *node) size() int {\r\n\tif o != nil {\r\n\t\treturn o.sz\r\n\t}\r\n\treturn 0\r\n}\r\n\r\nfunc (o *node) maintain() {\r\n\to.sz = 1 + o.ch[0].size() + o.ch[1].size()\r\n}\r\n\r\n// 构建一颗中序遍历为 [l,r] 的 splay 树\r\n// 比如，给你一个序列和一些修改操作，每次取出一段子区间，cut 掉然后 append 到末尾，输出完成所有操作后的最终序列：\r\n//     我们可以 buildSplay(1,n)，每次操作调用两次 split 来 cut 区间，得到三颗子树 a b c\r\n//     append 之后应该是 a c b，那么我们可以 a.merge(c.merge(b)) 来完成这一操作\r\n//     注意 merge 后可能就不满足搜索树的性质了，但是没有关系，中序遍历的结果仍然是正确的，我们只要保证这一点成立，就能正确得到完成所有操作后的最终序列\r\nfunc buildSplay(s string) *node {\r\n\tif s == \"\" {\r\n\t\treturn nil\r\n\t}\r\n\tm := len(s) / 2\r\n\to := &node{key: s[m]}\r\n\to.ch[0] = buildSplay(s[:m])\r\n\to.ch[1] = buildSplay(s[m+1:])\r\n\to.maintain()\r\n\treturn o\r\n}\r\n\r\n// 旋转，并维护子树大小\r\n// d=0：左旋，返回 o 的右儿子\r\n// d=1：右旋，返回 o 的左儿子\r\nfunc (o *node) rotate(d int) *node {\r\n\tx := o.ch[d^1]\r\n\to.ch[d^1] = x.ch[d]\r\n\tx.ch[d] = o\r\n\to.maintain()\r\n\tx.maintain()\r\n\treturn x\r\n}\r\n\r\n// 将子树 o（中序遍历）的第 k 个节点伸展到 o，并返回该节点\r\n// 1 <= k <= o.size()\r\nfunc (o *node) splay(k int) (kth *node) {\r\n\td := o.cmpKth(k)\r\n\tif d < 0 {\r\n\t\treturn o\r\n\t}\r\n\tk -= d * (o.ch[0].size() + 1)\r\n\tc := o.ch[d]\r\n\tif d2 := c.cmpKth(k); d2 >= 0 {\r\n\t\tc.ch[d2] = c.ch[d2].splay(k - d2*(c.ch[0].size()+1))\r\n\t\tif d2 == d {\r\n\t\t\to = o.rotate(d ^ 1)\r\n\t\t} else {\r\n\t\t\to.ch[d] = c.rotate(d)\r\n\t\t}\r\n\t}\r\n\treturn o.rotate(d ^ 1)\r\n}\r\n\r\n// 分裂子树 o，把 o（中序遍历）的前 k 个节点放在 lo 子树，其余放在 ro 子树\r\n// 返回的 lo 节点为 o（中序遍历）的第 k 个节点\r\n// 1 <= k <= o.size()\r\n// 特别地，k = o.size() 时 ro 为 nil\r\nfunc (o *node) split(k int) (lo, ro *node) {\r\n\tlo = o.splay(k)\r\n\tro = lo.ch[1]\r\n\tlo.ch[1] = nil\r\n\tlo.maintain()\r\n\treturn\r\n}\r\n\r\n// 把子树 ro 合并进子树 o，返回合并前 o（中序遍历）的最后一个节点\r\n// 相当于把 ro 的中序遍历 append 到 o 的中序遍历之后\r\n// ro 可以为 nil，但 o 不能为 nil\r\nfunc (o *node) merge(ro *node) *node {\r\n\t// 把最大节点伸展上来，这样会空出一个右儿子用来合并 ro\r\n\to = o.splay(o.size())\r\n\to.ch[1] = ro\r\n\to.maintain()\r\n\treturn o\r\n}\r\n\r\ntype TextEditor struct {\r\n\troot *node\r\n\tcur  int\r\n}\r\n\r\nfunc Constructor() TextEditor { return TextEditor{} }\r\n\r\nfunc (t *TextEditor) AddText(text string) {\r\n\tif t.cur == 0 {\r\n\t\tt.root = buildSplay(text).merge(t.root)\r\n\t} else {\r\n\t\tlo, ro := t.root.split(t.cur)\r\n\t\tt.root = lo.merge(buildSplay(text)).merge(ro)\r\n\t}\r\n\tt.cur += len(text)\r\n}\r\n\r\nfunc (t *TextEditor) DeleteText(k int) int {\r\n\tif t.cur == 0 {\r\n\t\treturn 0\r\n\t}\r\n\tif t.cur <= k { // 左边全部删除\r\n\t\t_, t.root = t.root.split(t.cur)\r\n\t\tans := t.cur\r\n\t\tt.cur = 0\r\n\t\treturn ans\r\n\t} else {\r\n\t\tlo, ro := t.root.split(t.cur)\r\n\t\tt.cur -= k\r\n\t\tlo, _ = lo.split(t.cur) // 删除中间 k 个\r\n\t\tt.root = lo.merge(ro)\r\n\t\treturn k\r\n\t}\r\n}\r\n\r\nfunc (t *TextEditor) text() string {\r\n\tif t.cur == 0 {\r\n\t\treturn \"\"\r\n\t}\r\n\tk := max(t.cur-10, 0)\r\n\tt.root = t.root.splay(k + 1)\r\n\tans := make([]byte, 1, t.cur-k)\r\n\tans[0] = t.root.key\r\n\tvar inorder func(*node) bool\r\n\tinorder = func(o *node) bool {\r\n\t\tif o == nil {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tif inorder(o.ch[0]) || len(ans) == cap(ans) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tans = append(ans, o.key)\r\n\t\treturn inorder(o.ch[1])\r\n\t}\r\n\tinorder(t.root.ch[1])\r\n\treturn string(ans)\r\n}\r\n\r\nfunc (t *TextEditor) CursorLeft(k int) string {\r\n\tt.cur = max(t.cur-k, 0)\r\n\treturn t.text()\r\n}\r\n\r\nfunc (t *TextEditor) CursorRight(k int) string {\r\n\tt.cur = min(t.cur+k, t.root.size())\r\n\treturn t.text()\r\n}\r\n\r\nfunc min(a, b int) int { if a > b { return b }; return a }\r\nfunc max(a, b int) int { if a < b { return b }; return a }\r\n```\r\n"
}