{
	"titleSlug": "grid-game",
	"slug": "java-by-a-biao-33-qy9g",
	"url": "https://leetcode-cn.com/problems/grid-game/solution/java-by-a-biao-33-qy9g/",
	"content": "**思路**：因为机器人只能够向右或者向下走，当第一个机器人走完后，相当于第二个机器人只能选择两行中剩余元素较大的一行从头走到尾（先拐到第二行走到尾或者先走到位再拐到第二行）。因此可以维护一个`prefix`矩阵，其第一行`prefix[0][i]`表示在下标`i`向下拐右边剩余留给第二个机器人的点数总和，第二行`prefix[1][i]`表示在下标`i`向下拐左边剩余留给第二个机器人的点数总和。最后找出下标`index`使得`Math.max(prefix[0][i], prefix[1][i])`最小即可。\r\n**注意**：首要目的是让第二个机器人点数最小化，而非让第一个机器人点数最大化，因此寻找让第一个机器人点数最大的拐点的做法是错的，无法通过以下这个测试点：\r\n````python\r\n[[20,3,20,17,2,12,15,17,4,15],[20,10,13,14,15,5,2,3,14,3]]\r\n````\r\n**代码实现**：\r\n``` java\r\nclass Solution {\r\n    public long gridGame(int[][] grid) {\r\n        int n = grid[0].length;\r\n        long[][] prefix = new long[2][n];\r\n        // prefix[0][i]表示在下标 i 向下拐右边剩余留给第二个机器人的点数总和\r\n        for (int i = n - 2; i >= 0; i--)\r\n            prefix[0][i] = prefix[0][i + 1] + grid[0][i + 1];\r\n        // prefix[1][i]表示在下标 i 向下拐左边剩余留给第二个机器人的点数总和\r\n        for (int i = 1; i < n; i++)\r\n            prefix[1][i] = prefix[1][i - 1] + grid[1][i - 1];\r\n        long max = Long.MAX_VALUE;\r\n        int index = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            // 第二个机器人选择两行中的最大值\r\n            long sum = Math.max(prefix[0][i], prefix[1][i]);\r\n            // 目的是让这个最大值尽可能小\r\n            if (max > sum) {\r\n                max = sum;\r\n                index = i;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\n```\r\n"
}