{
	"titleSlug": "middle-of-the-linked-list",
	"slug": "kuai-man-zhi-zhen-zhu-yao-zai-yu-diao-shi-by-liwei",
	"url": "https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/kuai-man-zhi-zhen-zhu-yao-zai-yu-diao-shi-by-liwei/",
	"content": "**朴素解法**：这道题最朴素的做法是，先遍历一次，计算链表的长度，进而计算链表中间结点的下标（注意偶数结点的时候，得到的是中间的第二个结点），然后再遍历一次，来到所要求结点的位置。\n\n缺点：\n+ 必须先遍历完整个链表，然后才可以「干正事」，再遍历到一半，找到中间结点；\n+ 在链表的长度很长的时候，**这种方法之前的等待会很久**。\n\n**快慢指针**：比较经典的做法是：\n\n+ 使用两个指针变量，刚开始都位于链表的第 1 个结点，一个永远一次只走 1 步，一个永远一次只走 2 步，一个在前，一个在后，**同时走**。这样当快指针走完的时候，慢指针就来到了链表的中间位置。\n\n思想是：快慢指针的前进方向相同，且它们步伐的「差」是恒定的，根据这种确定性去解决链表中的一些问题。使用这种思想还可以解决链表的以下问题：\n\n+ 「力扣」第 19 题： [倒数第 k 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)，快指针先走几步，不是靠猜的，要在纸上画图模拟一下，就清楚了；\n+ 「力扣」第 141 题：[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)，在环中的时候可以想象，A 同学开始有存款 100 元，每天赚 1 元，B 同学开始有存款 50 元，每天赚 2 元，B 同学一定会在某一天和 A 同学的存款一样；\n+ 「力扣」第 142 题：[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)；\n+ 「力扣」第 161 题：[相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)，起点不同，构造相同长度让它们相遇，同样是利用了同步走这个等量关系。\n\n解决这些问题的共同特点就是使用两个指针变量同步移动。解决链表的问题常见的技巧还有：\n\n+ 1、使用递归函数，避免复杂的更改指针变量指向操作，使得求解问题变得简单。\n    - 「力扣」第 206 题：[反转链表](https://leetcode-cn.com/problems/reverse-linked-list)；\n    - 「力扣」第 24 题：[两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs)；\n    - 「力扣」第 25 题：[K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)；\n    - 「力扣」第 328 题：[奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list)；\n    - 「力扣」第 203 题：[移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)；\n    - 「力扣」第 21 题：[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)。\n+ 2、设置「虚拟头结点」，避免对链表第 1 个结点做单独讨论，这个思想在数组里我们见过，叫「哨兵」；\n    - 「力扣」第 2 题：[两数相加](https://leetcode-cn.com/problems/add-two-numbers)；\n    - 「力扣」第 82 题：[删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)。\n+ 3、使用「快慢指针」，本题就是。确切地说，叫「同步指针」可能更好一些；\n+ 4、为链表编写测试函数，进行调试（在下面的参考代码中有），主要是：\n    - 从数组得到一个链表；\n    - 根据当前结点打印当前结点以及后面的结点。\n这两个方法可以非常方便地帮助我们调试关于链表的程序。\n\n大家还可以在「力扣」的新手场：[「探索」](https://leetcode-cn.com/explore/learn/card/linked-list/) 板块里，学习链表的相关知识和问题。「力扣」上的链表问题，和我们在教科书里学习的链表是有一点点不一样的，「力扣」的链表是以结点类 `ListNode` 为中心进行编程。而一般教科书上则是将 `ListNode` 作为链表的内部类进行编程，差别就是这些。其它处理链表问题的技巧是完全一样的。\n\n**打草稿很重要**：链表问题在「力扣」上是相对较少，**并且题目类型和解题技巧相对固定的问题**，相信通过刷题和总结，我们是可以把链表问题全部掌握的。\n\n并且思考链表问题的第 1 步，和「回溯算法」一样，绝大多数时候在草稿纸上写写画画就能得到解决链表问题的办法，特别是在链表中做一些更改指针变量指向操作的问题。\n\n**注意**：这里要注意一个细节：题目要求：「两个中间结点的时候，返回第二个中间结点」。此时可以在草稿纸上写写画画，就拿自己的左右手的两根指头同步移动，可以得出：快指针可以前进的条件是：**当前快指针和当前快指针的下一个结点都非空**。\n\n在有些问题，例如「力扣」第 148 题：[排序链表](https://leetcode-cn.com/problems/sort-list/)，是需要来到链表的第一个中间结点，然后切断链表，这时代码就得做小的调整。具体是怎么写的，不能靠猜，依然是要在纸上模拟一下这个「快慢指针同步走」的过程，就很清楚了（不过第 148 题的本来意思不是让我们从中间二分递归去做）。\n\n结论：如果题目要求「在两个中间结点的时候，返回第一个中间结点」，此时快指针可以前进的条件是：当前快指针的下一个结点和当前快指针的**下下一个结点**都非空。\n\n注意体会以上二者的不同之处。\n\n![876-1.png](https://pic.leetcode-cn.com/2b7a4130111600cf615b5584b3cc7f863d289a9a7d43b90147c79f51f68a5aa6-876-1.png)\n![876-2.png](https://pic.leetcode-cn.com/5c3f88cc6b312b7193a6e071cef93ec5eb3070005af23cad22a11e10ea0aca3e-876-2.png)\n\n说明：图例中使用了 Python 语言的写法，例如 `while fast` 在 `fast` 变量不是空结点的时候，返回 `True`，写成 `while fast is not None` 是语义更清晰的写法，但由于约定，且这种写法非常常见，我们就简写了。\n\n**参考代码 1**：\n\n\n```Java []\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n        val = x;\n    }\n\n    public ListNode(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            throw new IllegalArgumentException(\"arr can not be empty\");\n        }\n        this.val = nums[0];\n        ListNode curr = this;\n        for (int i = 1; i < nums.length; i++) {\n            curr.next = new ListNode(nums[i]);\n            curr = curr.next;\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        ListNode cur = this;\n        while (cur != null) {\n            s.append(cur.val);\n            s.append(\" -> \");\n            cur = cur.next;\n        }\n        s.append(\"NULL\");\n        return s.toString();\n    }\n}\n\npublic class Solution {\n\n    public ListNode middleNode(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = new int[]{1, 2, 3, 4, 5, 6};\n        // int[] arr = new int[]{1, 2, 3, 4, 5};\n        ListNode head = new ListNode(arr);\n        Solution solution = new Solution();\n        ListNode res = solution.middleNode(head);\n        System.out.println(res);\n    }\n}\n```\n```Python []\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        if head is None:\n            return None\n\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n\ndef create_linked_list(nums):\n    if len(nums) == 0:\n        return None\n    head = ListNode(nums[0])\n    cur = head\n    for i in range(1, len(nums)):\n        cur.next = ListNode(nums[i])\n        cur = cur.next\n    return head\n\n\ndef print_linked_list(list_node):\n    if list_node is None:\n        return\n\n    cur = list_node\n    while cur:\n        print(cur.val, '->', end=' ')\n        cur = cur.next\n    print('null')\n\n\nif __name__ == '__main__':\n    # nums = [1, 2, 3, 4, 5, 6, 7]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    head = create_linked_list(nums)\n    solution = Solution()\n    result = solution.middleNode(head)\n    print('结果：')\n    print_linked_list(result)\n```\n\n**复杂度分析**：\n\n+ 时间复杂度：$O(N)$，$N$ 是链表的长度，快指针变量需要遍历完整个链表，因此最多走 $N$ 步；\n+ 空间复杂度：$O(1)$。"
}