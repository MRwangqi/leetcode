{
	"titleSlug": "maximum-rows-covered-by-columns",
	"slug": "by-endlesscheng-dvxe",
	"url": "https://leetcode-cn.com/problems/maximum-rows-covered-by-columns/solution/by-endlesscheng-dvxe/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1na41137jv) 已出炉，欢迎点赞三连，在评论区分享你对这场双周赛的看法~\r\n\r\n---\r\n\r\n由于数据范围很小，我们可以枚举所有大小为 $\\textit{cols}$ 的列编号的集合，对于每个集合，遍历 $\\textit{mat}$，统计所有 $1$ 被覆盖的行的个数，个数的最大值即为答案。\r\n\r\n代码实现时，我们可以用二进制表示集合，二进制的第 $i$ 位为 $1$ 表示 $i$ 在集合中，为 $0$ 表示 $i$ 不在集合中。这样可以用二进制枚举集合，同时把 $\\textit{mat}$ 的每一行也用二进制表示，从而做到 $O(1)$ 判断行中的所有 $1$ 是否被覆盖。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\r\n        ans = 0\r\n        mask = [sum(v << j for j, v in enumerate(row)) for i, row in enumerate(mat)]\r\n        for set in range(1 << len(mat[0])):\r\n            if set.bit_count() == cols:  # 集合的大小等于 cols，符合题目要求\r\n                ans = max(ans, sum(row & set == row for row in mask))  # row & set = row 表示 row 是 set 的子集，所有 1 都被覆盖\r\n        return ans\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc maximumRows(mat [][]int, cols int) (ans int) {\r\n\tm, n := len(mat), len(mat[0])\r\n\tmask := make([]int, m)\r\n\tfor i, row := range mat {\r\n\t\tfor j, v := range row {\r\n\t\t\tmask[i] |= v << j\r\n\t\t}\r\n\t}\r\n\tfor set := 0; set < 1<<n; set++ {\r\n\t\tif bits.OnesCount(uint(set)) != cols { // 跳过大小不等于 cols 的集合\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tcnt := 0\r\n\t\tfor _, row := range mask {\r\n\t\t\tif row&set == row { // row 是 set 的子集，所有 1 都被覆盖\r\n\t\t\t\tcnt++\r\n\t\t\t}\r\n\t\t}\r\n\t\tans = max(ans, cnt)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n上面的代码有很多无效枚举，即大小不等于 $\\textit{cols}$ 的集合，如何优化呢？\r\n\r\n通过使用 Gosper's Hack，我们可以在 $O(1)$ 的时间内找到下一个大小为 $\\textit{cols}$ 的集合。\r\n\r\n[视频讲解](https://www.bilibili.com/video/BV1na41137jv) 中介绍了这个算法。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(m\\cdot C_{n}^{\\textit{cols}})$。其中 $m$ 为 $\\textit{mat}$ 的行数，$n$ 为 $\\textit{mat}$ 的列数。\r\n- 空间复杂度：$O(m)$。\r\n\r\n```py [sol2-Python3]\r\nclass Solution:\r\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\r\n        ans = 0\r\n        mask = [sum(v << j for j, v in enumerate(row)) for i, row in enumerate(mat)]\r\n        set = (1 << cols) - 1\r\n        while set < 1 << len(mat[0]):\r\n            ans = max(ans, sum(row & set == row for row in mask))  # row & set = row 表示 row 是 set 的子集，所有 1 都被覆盖\r\n            lb = set & -set\r\n            x = set + lb\r\n            set = (set ^ x) // lb >> 2 | x\r\n        return ans\r\n```\r\n\r\n```go [sol2-Go]\r\nfunc maximumRows(mat [][]int, cols int) (ans int) {\r\n\tm, n := len(mat), len(mat[0])\r\n\tmask := make([]int, m)\r\n\tfor i, row := range mat {\r\n\t\tfor j, v := range row {\r\n\t\t\tmask[i] |= v << j\r\n\t\t}\r\n\t}\r\n\tfor set := 1<<cols - 1; set < 1<<n; {\r\n\t\tcnt := 0\r\n\t\tfor _, row := range mask {\r\n\t\t\tif row&set == row { // row 是 set 的子集，所有 1 都被覆盖\r\n\t\t\t\tcnt++\r\n\t\t\t}\r\n\t\t}\r\n\t\tans = max(ans, cnt)\r\n\t\tlb := set & -set\r\n\t\tx := set + lb\r\n\t\t// 下式等价于 set = (set^x)/lb>>2 | x\r\n\t\tset = (set^x)>>bits.TrailingZeros(uint(lb))>>2 | x\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n"
}