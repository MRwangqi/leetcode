{
	"titleSlug": "largest-component-size-by-common-factor",
	"slug": "an-gong-yin-shu-ji-suan-zui-da-zu-jian-d-amdx",
	"url": "https://leetcode-cn.com/problems/largest-component-size-by-common-factor/solution/an-gong-yin-shu-ji-suan-zui-da-zu-jian-d-amdx/",
	"content": "#### 方法一：并查集\n\n为了得到数组 $\\textit{nums}$ 中的每个数和哪些数属于同一个组件，需要得到数组 $\\textit{nums}$ 中的最大值 $m$，对于每个不超过 $m$ 的正整数 $\\textit{num}$ 计算 $\\textit{num}$ 和哪些数属于同一个组件。对于范围 $[2, \\sqrt{\\textit{num}}]$ 内的每个正整数 $i$，如果 $i$ 是 $\\textit{num}$ 的因数，则 $\\textit{num}$ 和 $i$、$\\dfrac{\\textit{num}}{i}$ 都属于同一个组件。\n\n可以使用并查集实现组件的计算。初始时，每个数分别属于不同的组件。如果两个正整数满足其中一个正整数是另一个正整数的因数，则这两个正整数属于同一个组件，将这两个正整数的组件合并。\n\n当所有不超过 $m$ 的正整数都完成合并操作之后。遍历数组 $\\textit{nums}$，对于每个数得到其所在的组件并更新该组件的大小，遍历结束之后即可得到最大组件的大小。\n\n```Python [sol1-Python3]\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def merge(self, x: int, y: int) -> None:\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] > self.rank[y]:\n            self.parent[y] = x\n        elif self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n            self.rank[x] += 1\n\nclass Solution:\n    def largestComponentSize(self, nums: List[int]) -> int:\n        uf = UnionFind(max(nums) + 1)\n        for num in nums:\n            i = 2\n            while i * i <= num:\n                if num % i == 0:\n                    uf.merge(num, i)\n                    uf.merge(num, num // i)\n                i += 1\n        return max(Counter(uf.find(num) for num in nums).values())\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int largestComponentSize(int[] nums) {\n        int m = Arrays.stream(nums).max().getAsInt();\n        UnionFind uf = new UnionFind(m + 1);\n        for (int num : nums) {\n            for (int i = 2; i * i <= num; i++) {\n                if (num % i == 0) {\n                    uf.union(num, i);\n                    uf.union(num, num / i);\n                }\n            }\n        }\n        int[] counts = new int[m + 1];\n        int ans = 0;\n        for (int num : nums) {\n            int root = uf.find(num);\n            counts[root]++;\n            ans = Math.max(ans, counts[root]);\n        }\n        return ans;\n    }\n}\n\nclass UnionFind {\n    int[] parent;\n    int[] rank;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        rank = new int[n];\n    }\n\n    public void union(int x, int y) {\n        int rootx = find(x);\n        int rooty = find(y);\n        if (rootx != rooty) {\n            if (rank[rootx] > rank[rooty]) {\n                parent[rooty] = rootx;\n            } else if (rank[rootx] < rank[rooty]) {\n                parent[rootx] = rooty;\n            } else {\n                parent[rooty] = rootx;\n                rank[rootx]++;\n            }\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int LargestComponentSize(int[] nums) {\n        int m = nums.Max();\n        UnionFind uf = new UnionFind(m + 1);\n        foreach (int num in nums) {\n            for (int i = 2; i * i <= num; i++) {\n                if (num % i == 0) {\n                    uf.Union(num, i);\n                    uf.Union(num, num / i);\n                }\n            }\n        }\n        int[] counts = new int[m + 1];\n        int ans = 0;\n        foreach (int num in nums) {\n            int root = uf.Find(num);\n            counts[root]++;\n            ans = Math.Max(ans, counts[root]);\n        }\n        return ans;\n    }\n}\n\nclass UnionFind {\n    int[] parent;\n    int[] rank;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        rank = new int[n];\n    }\n\n    public void Union(int x, int y) {\n        int rootx = Find(x);\n        int rooty = Find(y);\n        if (rootx != rooty) {\n            if (rank[rootx] > rank[rooty]) {\n                parent[rooty] = rootx;\n            } else if (rank[rootx] < rank[rooty]) {\n                parent[rootx] = rooty;\n            } else {\n                parent[rooty] = rootx;\n                rank[rootx]++;\n            }\n        }\n    }\n\n    public int Find(int x) {\n        if (parent[x] != x) {\n            parent[x] = Find(parent[x]);\n        }\n        return parent[x];\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass UnionFind {\npublic:\n    UnionFind(int n) {\n        parent = vector<int>(n);\n        rank = vector<int>(n);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    void uni(int x, int y) {\n        int rootx = find(x);\n        int rooty = find(y);\n        if (rootx != rooty) {\n            if (rank[rootx] > rank[rooty]) {\n                parent[rooty] = rootx;\n            } else if (rank[rootx] < rank[rooty]) {\n                parent[rootx] = rooty;\n            } else {\n                parent[rooty] = rootx;\n                rank[rootx]++;\n            }\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n};\n\nclass Solution {\npublic:\n    int largestComponentSize(vector<int>& nums) {\n        int m = *max_element(nums.begin(), nums.end());\n        UnionFind uf(m + 1);\n        for (int num : nums) {\n            for (int i = 2; i * i <= num; i++) {\n                if (num % i == 0) {\n                    uf.uni(num, i);\n                    uf.uni(num, num / i);\n                }\n            }\n        }\n        vector<int> counts(m + 1);\n        int ans = 0;\n        for (int num : nums) {\n            int root = uf.find(num);\n            counts[root]++;\n            ans = max(ans, counts[root]);\n        }\n        return ans;\n    }\n};\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\ntypedef struct UnionFind {\n    int *parent;\n    int *rank;\n} UnionFind;\n\nUnionFind* unionFindCreate(int n) {\n    UnionFind *obj = (UnionFind *)malloc(sizeof(UnionFind));\n    obj->parent = (int *)malloc(sizeof(int) * n);\n    obj->rank = (int *)malloc(sizeof(int) * n);\n    memset(obj->rank, 0, sizeof(int) * n);\n    for (int i = 0; i < n; i++) {\n        obj->parent[i] = i;\n    }\n    return obj;\n}\n\nint find(const UnionFind *obj, int x) {\n    if (obj->parent[x] != x) {\n        obj->parent[x] = find(obj, obj->parent[x]);\n    }\n    return obj->parent[x];\n}\n\nvoid uni(UnionFind *obj, int x, int y) {\n    int rootx = find(obj, x);\n    int rooty = find(obj, y);\n    if (rootx != rooty) {\n        if (obj->rank[rootx] > obj->rank[rooty]) {\n            obj->parent[rooty] = rootx;\n        } else if (obj->rank[rootx] < obj->rank[rooty]) {\n            obj->parent[rootx] = rooty;\n        } else {\n            obj->parent[rooty] = rootx;\n            obj->rank[rootx]++;\n        }\n    }\n}\n\nvoid unionFindFree(UnionFind *obj) {\n    free(obj->parent);\n    free(obj->rank);\n    free(obj);\n}\n\nint largestComponentSize(int* nums, int numsSize) {\n    int m = nums[0];\n    for (int i = 0; i < numsSize; i++) {\n        m = MAX(m, nums[i]);\n    }\n    UnionFind *uf = unionFindCreate(m + 1);\n    for (int i = 0; i < numsSize; i++) {\n        int num = nums[i];\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                uni(uf, num, i);\n                uni(uf, num, num / i);\n            }\n        }\n    }\n    int *counts = (int *)malloc(sizeof(int) * (m + 1));\n    memset(counts, 0, sizeof(int) * (m + 1));\n    int ans = 0;\n    for (int i = 0; i < numsSize; i++) {\n        int root = find(uf, nums[i]);\n        counts[root]++;\n        ans = MAX(ans, counts[root]);\n    }\n    free(counts);\n    unionFindFree(uf);\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar largestComponentSize = function(nums) {\n    const m = _.max(nums);;\n    const uf = new UnionFind(m + 1);\n    for (const num of nums) {\n        for (let i = 2; i * i <= num; i++) {\n            if (num % i === 0) {\n                uf.union(num, i);\n                uf.union(num, Math.floor(num / i));\n            }\n        }\n    }\n    const counts = new Array(m + 1).fill(0);\n    let ans = 0;\n    for (let num of nums) {\n        const root = uf.find(num);\n        counts[root]++;\n        ans = Math.max(ans, counts[root]);\n    }\n    return ans;\n};\n\nclass UnionFind {\n    constructor(n) {\n        this.parent = new Array(n).fill(0).map((_, i) => i);\n        this.rank = new Array(n).fill(0);\n    }\n\n    union(x, y) {\n        let rootx = this.find(x);\n        let rooty = this.find(y);\n        if (rootx !== rooty) {\n            if (this.rank[rootx] > this.rank[rooty]) {\n                this.parent[rooty] = rootx;\n            } else if (this.rank[rootx] < this.rank[rooty]) {\n                this.parent[rootx] = rooty;\n            } else {\n                this.parent[rooty] = rootx;\n                this.rank[rootx]++;\n            }\n        }\n    }\n\n    find(x) {\n        if (this.parent[x] !== x) {\n            this.parent[x] = this.find(this.parent[x]);\n        }\n        return this.parent[x];\n    }\n}\n```\n\n```go [sol1-Golang]\ntype unionFind struct {\n    parent, rank []int\n}\n\nfunc newUnionFind(n int) unionFind {\n    parent := make([]int, n)\n    for i := range parent {\n        parent[i] = i\n    }\n    return unionFind{parent, make([]int, n)}\n}\n\nfunc (uf unionFind) find(x int) int {\n    if uf.parent[x] != x {\n        uf.parent[x] = uf.find(uf.parent[x])\n    }\n    return uf.parent[x]\n}\n\nfunc (uf unionFind) merge(x, y int) {\n    x, y = uf.find(x), uf.find(y)\n    if x == y {\n        return\n    }\n    if uf.rank[x] > uf.rank[y] {\n        uf.parent[y] = x\n    } else if uf.rank[x] < uf.rank[y] {\n        uf.parent[x] = y\n    } else {\n        uf.parent[y] = x\n        uf.rank[x]++\n    }\n}\n\nfunc largestComponentSize(nums []int) (ans int) {\n    m := 0\n    for _, num := range nums {\n        m = max(m, num)\n    }\n    uf := newUnionFind(m + 1)\n    for _, num := range nums {\n        for i := 2; i*i <= num; i++ {\n            if num%i == 0 {\n                uf.merge(num, i)\n                uf.merge(num, num/i)\n            }\n        }\n    }\n    cnt := make([]int, m+1)\n    for _, num := range nums {\n        rt := uf.find(num)\n        cnt[rt]++\n        ans = max(ans, cnt[rt])\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times \\alpha(n) \\times \\sqrt{m})$，其中 $n$ 是数组 $\\textit{nums}$ 的长度，$m$ 是数组 $\\textit{nums}$ 中的最大元素，$\\alpha$ 是反阿克曼函数。这里的并查集使用了路径压缩和按秩合并，单次操作的时间复杂度是 $O(\\alpha(n))$，对于每个元素需要遍历 $O(\\sqrt{m})$ 个数字寻找公因数并执行合并操作，总操作次数是 $O(n \\times \\sqrt{m})$，因此整个数组的并查集操作的时间复杂度是 $O(n \\times \\alpha(n) \\times \\sqrt{m})$，并查集操作之后需要 $O(n \\times \\alpha(n))$ 的时间再次遍历数组计算最大组件大小，因此总时间复杂度是 $O(n \\times \\alpha(n) \\times \\sqrt{m})$。\n\n- 空间复杂度：$O(m)$，其中 $m$ 是数组 $\\textit{nums}$ 中的最大元素。并查集和统计组件大小都需要 $O(m)$ 的空间。"
}