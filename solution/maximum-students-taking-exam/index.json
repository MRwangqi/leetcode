{
	"titleSlug": "maximum-students-taking-exam",
	"slug": "can-jia-kao-shi-de-zui-da-xue-sheng-shu-by-leetcod",
	"url": "https://leetcode-cn.com/problems/maximum-students-taking-exam/solution/can-jia-kao-shi-de-zui-da-xue-sheng-shu-by-leetcod/",
	"content": "#### 方法一：记忆化递归 + 状态压缩\n\n##### 递归\n\n以题目中的实例一为例，座位的排布为：\n\n```\n #.##.#\n .####.\n #.##.#\n```\n\n将此排布记为 $A$。建模函数 $f(X)$，$f(X)$ 的参数为座位排布，返回值为此种排布最多可能容纳的学生数量。$f(A)$ 即为题目所求。\n\n从第一排开始考虑。我们用数字 1 表示“学生坐在这里”，用数字 0 表示“学生不坐在这里”。第一排可能的安排方式有三种：`010010`，`000010`或者`010000`\n\n当第一排安排方式为`010010`时，第一排容纳了 2 名学生，此时第二排有些座位不可以再坐人。去掉不可以坐人的位置，后排的座位排布为\n\n```\n ######\n #.##.#\n```\n\n将此排布记为 $A'_1$。则此时可以容纳的学生数量为 $2+f(A'_1)$。\n\n当第一排安排方式为`000010`时，第一排容纳了 1 名学生，此时第二排有些座位不可以再坐人。去掉不可以坐人的位置，后排的座位排布为\n\n```\n .#####\n #.##.#\n```\n\n将此排布记为 $A'_2$。则此时可以容纳的学生数量为 $1+f(A'_2)$。\n\n当第一排安排方式为`010000`时，第一排容纳了 1 名学生，此时第二排有些座位不可以再坐人。去掉不可以坐人的位置，后排的座位排布为\n\n```\n #####.\n #.##.#\n```\n\n将此排布记为 $A'_3$。则此时可以容纳的学生数量为 $1+f(A'_3)$。\n\n综合起来，可得\n$$f(A)=max(2+f(A'_1),1+f(A'_2),1+f(A'_3))$$\n\n同样，$f(A'_1),f(A'_2),f(A'_3)$ 也可以如此递归求解。对于任意一种座位排布 $X$，函数 $f$ 只需遍历第一排的所有可能安排方式，对于每一种可能性递归求解，取其中的最大结果即可。\n\n此递归的终止条件为：当 $X$ 所剩排数为 1 时，$f(X)$ 可直接返回此排可容纳的最大学生数，而不需要再递归到下一排。\n\n此外可以看到，作为 $f$ 的参数的 $X$，$X$ 只有第一排可能与初始座位排布不同。这是由于后排的座位可用情况不会被 $X$ 的第一排之前的座位情况影响。因此 $f$ 的参数不需要记录后排的所有座位情况，只需要有 $X$ 的第一排的座位情况，以及已经被安排的座位排数即可。\n\n##### 记忆化递归\n\n可以想到，在 $f$ 的递归过程中，会有一些重复情况，比如 $f(A'_1)$ 与 $f(A'_2)$ 都有可能选择`100000`的安排方式，此时它们都会递归到如下情况：\n\n```\n ####.#\n```\n\n为了防止对这种递归过程中的重复情况进行多次计算，影响性能，需要采用记忆化递归。即对于任意一个 $X$，在第一次计算 $f(X)$ 时将 $f(X)$ 的值保存在数组中，下次再计算 $f(X)$ 时，直接将数组中保存的值返回，不需要重新计算。采用记忆化递归的方法可以大大降低时间复杂度。\n\n##### 状态压缩\n\n至此，问题只有剩下一个：如何高效地表示 $f$ 的参数 $X$？题目中使用字符串表示座位情况，但字符串处理起来不太方便，代码冗长且效率低下。\n\n观察问题的性质可以发现，对于一个位置，座位情况与可能的学生安排都只有两种：座位情况可能是“可坐”或者“不可坐”，学生安排只可能是“有学生”或者“无学生”。因此，我们可以分别用一个二进制串来表示一排的座位情况，1 表示“可坐”，0 表示“不可坐”，以及这排的可能的学生安排，1 表示“有学生”，0 表示“无学生”。二进制串可以直接用一个整数来存储。这样，就将一排座位的状态由一个字符串压缩成了一个整数。\n\n那么，对于座位情况的判断和操作如何完成呢？记座位情况的数字为 $seats$，学生安排的数字为 $scheme$，我们使用位运算解决：\n\n  * 首先是判断学生安排与本排的座位情况是否冲突，即“不可坐”的座位不可以安排为“有学生”。抽象为二进制运算，即对任意一位， `seats=0,scheme=1` 的情况不合法。因此可以得出结论，`scheme&~seats!=0` 时，座位安排不合法。\n  * 其次是判断学生是否有相邻的情况。即对于 $scheme$ 的二进制表示，不可以出现相邻的 1。对于这种情况，可以计算 `(scheme<<1)&scheme`，不为 0 时说明 $scheme$ 中存在相邻的 1.\n  * 最后是要根据本排的学生安排来决定下一排的座位情况。即如果 $scheme$ 中某一位为 1，那么下一排的 $seats$ 中，相邻的位需要置为 0.这一目的可以使用如下操作达成：\n\n```python\n  seats &= ~(scheme << 1)\n  seats &= ~(scheme >> 1)\n```\n\n至此，问题就解决了。\n\n```python []\nimport functools\nclass Solution:\n    @functools.lru_cache(8 * 2 ** 8)\n    def f(self, X, row_num, width):\n        ans = 0\n        for scheme in range(1 << width):\n            if scheme & ~X or scheme & (scheme << 1):\n                continue\n            curans = 0\n            for j in range(8):\n                if (1 << j) & scheme:\n                    curans += 1\n            if row_num == len(self.seats) - 1:\n                ans = max(ans, curans)\n            else:\n                next_seats = self.seats[row_num + 1]\n                next_seats &= ~(scheme << 1)\n                next_seats &= ~(scheme >> 1)\n                ans = max(ans, curans + self.f(next_seats, row_num + 1, width))\n        return ans\n\n    def compress(self, row):\n        ans = 0\n        for c in row:\n            ans <<= 1\n            if c == '.':\n                ans += 1\n        return ans\n\n    def maxStudents(self, seats: List[List[str]]) -> int:\n        self.seats = [self.compress(row) for row in seats]\n        return self.f(self.seats[0], 0, len(seats[0]))\n```\n\n```C++ []\nclass Solution {\n    int memory[8][1 << 8];\n    vector<int> compressed_seats;\n    int f(int X, int row_num, int width) {\n        if (memory[row_num][X] != -1)\n            return memory[row_num][X];\n        int ans = 0;\n        for (int scheme = 0; scheme != (1 << width); ++scheme) {\n            if (scheme & ~X || scheme & (scheme << 1))\n                continue;\n            int curans = 0;\n            for (int j = 0; j != width; ++j)\n                if ((1 << j) & scheme)\n                    ++curans;\n            if (row_num == compressed_seats.size() - 1)\n                ans = max(ans, curans);\n            else {\n                int next_seats = compressed_seats[row_num + 1];\n                next_seats &= ~(scheme << 1);\n                next_seats &= ~(scheme >> 1);\n                ans = max(ans, curans + f(next_seats, row_num + 1, width));\n            }\n        }\n        memory[row_num][X] = ans;\n        return ans;\n    }\n    \n    int compress(vector<char>& row) {\n        int ans = 0;\n        for (char c : row) {\n            ans <<= 1;\n            if (c == '.')\n                ++ans;\n        }\n        return ans;\n    }\n\npublic:\n    int maxStudents(vector<vector<char>>& seats) {\n        for (int i = 0; i != seats.size(); ++i)\n            for (int j = 0; j != (1 << seats[0].size()); ++j)\n                memory[i][j] = -1;\n        for (auto row: seats)\n            compressed_seats.push_back(compress(row));\n        return f(compressed_seats[0], 0, seats[0].size());\n    }\n};\n```\n\n##### 复杂度分析\n\n  * 时间复杂度：$O(4^nmn)$\n  * 空间复杂度：$O(2^nm)$\n    需要求解的情况最多有 $2^nm$ 种，求解每个情况所需的时间是 $O(2^nn)$，因此时间复杂度为$O(4^nmn)$，空间复杂度为 $O(2^nm)$ 。"
}