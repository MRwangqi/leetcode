{
	"titleSlug": "minimum-obstacle-removal-to-reach-corner",
	"slug": "0-1-bfs-by-endlesscheng-4pjt",
	"url": "https://leetcode-cn.com/problems/minimum-obstacle-removal-to-reach-corner/solution/0-1-bfs-by-endlesscheng-4pjt/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1iF41157dG) 已出炉，包括 **0-1 BFS 的原理**，欢迎三连~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n把障碍物当作可以经过的单元格，经过它的代价为 $1$，空单元格经过的代价为 $0$。\r\n\r\n#### 提示 2\r\n\r\n问题转化成从起点到终点的最短路。\r\n\r\n#### 提示 3\r\n\r\n我们可以用 Dijkstra，但还可以用 0-1 BFS 来将时间复杂度优化至 $O(mn)$。\r\n\r\n具体见 [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/) 官方题解的方法二，本文不再赘述。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(mn)$。\r\n- 空间复杂度：$O(mn)$。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\r\n        m, n = len(grid), len(grid[0])\r\n        dis = [[inf] * n for _ in range(m)]\r\n        dis[0][0] = 0\r\n        q = deque([(0, 0)])\r\n        while q:\r\n            x, y = q.popleft()\r\n            for nx, ny in (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1):\r\n                if 0 <= nx < m and 0 <= ny < n:\r\n                    g = grid[x][y]\r\n                    if dis[x][y] + g < dis[nx][ny]:\r\n                        dis[nx][ny] = dis[x][y] + g\r\n                        if g == 0: q.appendleft((nx, ny))\r\n                        else: q.append((nx, ny))\r\n        return dis[m - 1][n - 1]\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    static final int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n\r\n    public int minimumObstacles(int[][] grid) {\r\n        int m = grid.length, n = grid[0].length;\r\n        var dis = new int[m][n];\r\n        for (var i = 0; i < m; i++) Arrays.fill(dis[i], Integer.MAX_VALUE);\r\n        dis[0][0] = 0;\r\n        var q = new ArrayDeque<int[]>();\r\n        q.addFirst(new int[]{0, 0});\r\n        while (!q.isEmpty()) {\r\n            var p = q.pollFirst();\r\n            int x = p[0], y = p[1];\r\n            for (var d : dirs) {\r\n                int nx = x + d[0], ny = y + d[1];\r\n                if (0 <= nx && nx < m && 0 <= ny && ny < n) {\r\n                    var g = grid[nx][ny];\r\n                    if (dis[x][y] + g < dis[nx][ny]) {\r\n                        dis[nx][ny] = dis[x][y] + g;\r\n                        if (g == 0) q.addFirst(new int[]{nx, ny});\r\n                        else q.addLast(new int[]{nx, ny});\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dis[m - 1][n - 1];\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\n    static constexpr int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\r\n\r\npublic:\r\n    int minimumObstacles(vector<vector<int>> &grid) {\r\n        int m = grid.size(), n = grid[0].size();\r\n        int dis[m][n];\r\n        memset(dis, 0x3f, sizeof(dis));\r\n        dis[0][0] = 0;\r\n        deque<pair<int, int>> q;\r\n        q.emplace_front(0, 0);\r\n        while (!q.empty()) {\r\n            auto [x, y] = q.front();\r\n            q.pop_front();\r\n            for (auto &[dx, dy] : dirs) {\r\n                int nx = x + dx, ny = y + dy;\r\n                if (0 <= nx && nx < m && 0 <= ny && ny < n) {\r\n                    int g = grid[nx][ny];\r\n                    if (dis[x][y] + g < dis[nx][ny]) {\r\n                        dis[nx][ny] = dis[x][y] + g;\r\n                        g == 0 ? q.emplace_front(nx, ny) : q.emplace_back(nx, ny);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dis[m - 1][n - 1];\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\ntype pair struct{ x, y int }\r\nvar dir4 = []struct{ x, y int }{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\r\n\r\nfunc minimumObstacles(grid [][]int) (ans int) {\r\n\tm, n := len(grid), len(grid[0])\r\n\tdis := make([][]int, m)\r\n\tfor i := range dis {\r\n\t\tdis[i] = make([]int, n)\r\n\t\tfor j := range dis[i] {\r\n\t\t\tdis[i][j] = m * n\r\n\t\t}\r\n\t}\r\n\tdis[0][0] = 0\r\n\tq := [2][]pair{{{}}} // 两个 slice 头对头来实现 deque\r\n\tfor len(q[0]) > 0 || len(q[1]) > 0 {\r\n\t\tvar p pair\r\n\t\tif len(q[0]) > 0 {\r\n\t\t\tp, q[0] = q[0][len(q[0])-1], q[0][:len(q[0])-1]\r\n\t\t} else {\r\n\t\t\tp, q[1] = q[1][0], q[1][1:]\r\n\t\t}\r\n\t\tfor _, d := range dir4 {\r\n\t\t\tx, y := p.x+d.x, p.y+d.y\r\n\t\t\tif 0 <= x && x < m && 0 <= y && y < n {\r\n\t\t\t\tg := grid[x][y]\r\n\t\t\t\tif dis[p.x][p.y]+g < dis[x][y] {\r\n\t\t\t\t\tdis[x][y] = dis[p.x][p.y] + g\r\n\t\t\t\t\tq[g] = append(q[g], pair{x, y})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn dis[m-1][n-1]\r\n}\r\n```\r\n\r\n"
}