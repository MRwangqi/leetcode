{
	"titleSlug": "number-of-laser-beams-in-a-bank",
	"slug": "yin-xing-zhong-de-ji-guang-shu-shu-liang-ad02",
	"url": "https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank/solution/yin-xing-zhong-de-ji-guang-shu-shu-liang-ad02/",
	"content": "#### 方法一：直接计数\n\n**思路与算法**\n\n根据题目的要求，对于两个不同的行 $r_1$ 和 $r_2~(r_1 < r_2)$，如果它们恰好是相邻的两行（即 $r_1 + 1 = r_2$），或者它们之间的所有行都全为 $0$，那么第 $r_1$ 行的任意一个安全设备与第 $r_2$ 行的任意一个安全设备之间都有激光束。\n\n因此，我们只需要统计每一行的安全设备个数，记为 $\\textit{cnt}$，以及上一个不全为 $0$ 的行的安全设备个数，记为 $\\textit{last}$。那么 $\\textit{cnt} \\times \\textit{last}$ 即为激光束的个数。我们对所有的行进行遍历，维护 $\\textit{cnt}$ 和 $\\textit{last}$ 并对 $\\textit{cnt} \\times \\textit{last}$ 进行累加，即可得到激光束的总数量。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int numberOfBeams(vector<string>& bank) {\n        int last = 0, ans = 0;\n        for (const string& line: bank) {\n            int cnt = count_if(line.begin(), line.end(), [](char ch) {return ch == '1';});\n            if (cnt != 0) {\n                ans += last * cnt;\n                last = cnt;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def numberOfBeams(self, bank: List[str]) -> int:\n        last = ans = 0\n        for line in bank:\n            cnt = line.count(\"1\")\n            if cnt != 0:\n                ans += last * cnt\n                last = cnt\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn)$。\n\n- 空间复杂度：$O(1)$。"
}