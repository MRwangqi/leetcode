{
	"titleSlug": "number-of-restricted-paths-from-first-to-last-node",
	"slug": "by-canceraaron-5v6m",
	"url": "https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/solution/by-canceraaron-5v6m/",
	"content": "### 解题思路\n受限路径：dist[起点]>...dsit[i]>dist[i+1]>..>dist[n]，dist[i]表示i到n的最短路径\n这道题的起点是1\n因为边数最多是点数的两倍，所以是稀疏图，所以用堆优化的dijkstra求dist数组\n求出来后构建dp数组，dp[i]表示i到n的受限路径数，显然dp[n]为1，然后因为是无向连通图，a->b->n，a的受限路径数是取取决于dp[b]，如果dp[b]为5，那么dp[a]>=5，然后我们再构建一个数组arr，按dist值升序排列，\n我们就从第一个arr元素开始更新dp数组，从离n最近开始更新嘛，应该好理解吧。因为受限路径越靠近n，dist值越小，所以我们每次找的应该是比自己dist值小的点，因为dist值小的点应该在自己的后面，我们相当于从n一直遍历到1，这是不是应该dist值从小到大呀。当遍历到点1，就确定了dp[1],也就是1到n的受限路径数，这个时候就可以退出啦。\n\n### 代码\n\n```java\nclass Solution {\n    public int countRestrictedPaths(int n, int[][] edges) {\n        int N = n + 1;\n        List<int[]>[] graph = new ArrayList[N];\n        boolean[] visited = new boolean[N];\n        int[] dist = new int[N];\n        for (int i = 1; i < N; i++){\n            graph[i] = new ArrayList<>();\n            dist[i] = Integer.MAX_VALUE;\n        }\n        for (int i = 0; i < edges.length; i++){\n            graph[edges[i][0]].add(new int[]{edges[i][1], edges[i][2]});\n            graph[edges[i][1]].add(new int[]{edges[i][0], edges[i][2]});\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<>(new Comparator<int[]>() {\n            public int compare(int[] o1, int[] o2) {\n                return o1[1] - o2[1];\n            }\n        });\n        dist[n] = 0;\n        queue.add(new int[]{n, 0});\n        while (!queue.isEmpty()){\n            int[] t = queue.poll();\n            visited[t[0]] = true;\n            for (int[] g:graph[t[0]]\n            ) {\n                if (visited[g[0]])\n                    continue;\n                if (dist[g[0]] > dist[t[0]] + g[1]){\n                    dist[g[0]] = dist[t[0]] + g[1];\n                    queue.add(new int[]{g[0], dist[g[0]]});\n                }\n            }\n        }\n        int[] dp = new int[N];\n        dp[n] = 1;\n        int[][] arr = new int[n][2];\n        for (int i = 0; i < n; i++){\n            arr[i][0] = i + 1;\n            arr[i][1] = dist[i + 1];\n        }\n        Arrays.sort(arr, new Comparator<int[]>() {\n            public int compare(int[] o1, int[] o2) {\n                return o1[1] - o2[1];\n            }\n        });\n        for (int i = 0; i < n; i++){\n            int node = arr[i][0];\n            for (int[] g:graph[node]\n                 ) {\n                if (dist[g[0]] < dist[node]){\n                    dp[node] += dp[g[0]];\n                    dp[node] %= 1000000007;\n                }\n            }\n            if (node == 1)\n                continue;\n        }\n        return dp[1];\n    }\n}\n```"
}