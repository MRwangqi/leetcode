{
	"titleSlug": "insert-interval",
	"slug": "cha-ru-qu-jian-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/",
	"content": "#### 前言\n\n对于区间 $S_1 = [l_1, r_1]$ 和 $S_2 = [l_2, r_2]$，如果它们之间没有重叠（没有交集），说明要么 $S_1$ 在 $S_2$ 的左侧，此时有 $r_1 < l_2$；要么 $S_1$ 在 $S_2$ 的右侧，此时有 $l_1 > r_2$。\n\n如果 $r_1 < l_2$ 和 $l_1 > r_2$ 二者均不满足，说明 $S_1$ 和 $S_2$ 必定有交集，它们的交集即为\n$$\n[\\max(l_1, l_2), \\min(r_1, r_2)]\n$$\n\n并集即为\n\n$$\n[\\min(l_1, l_2), \\max(r_1, r_2)]\n$$\n\n#### 方法一：模拟\n\n**思路与算法**\n\n在给定的区间集合 $\\mathcal{X}$ **互不重叠**的前提下，当我们需要插入一个新的区间 $S = [\\textit{left}, \\textit{right}]$ 时，我们只需要：\n\n- 找出所有与区间 $S$ 重叠的区间集合 $\\mathcal{X}'$；\n- 将 $\\mathcal{X}'$ 中的所有区间连带上区间 $S$ 合并成一个大区间；\n- 最终的答案即为不与 $\\mathcal{X}'$ 重叠的区间以及合并后的大区间。\n\n![fig1](https://assets.leetcode-cn.com/solution-static/57/1.png)\n\n这样做的正确性在于，给定的区间集合中任意两个区间都是没有交集的，因此所有需要合并的区间，就是所有与区间 $S$ 重叠的区间。 \n\n并且，在给定的区间集合已经**按照左端点排序**的前提下，所有与区间 $S$ 重叠的区间在数组 $\\textit{intervals}$ 中**下标范围是连续的**，因此我们可以对所有的区间进行一次遍历，就可以找到这个连续的下标范围。\n\n当我们遍历到区间 $[l_i, r_i]$ 时：\n\n- 如果 $r_i < \\textit{left}$，说明 $[l_i, r_i]$ 与 $S$ 不重叠并且在其左侧，我们可以直接将 $[l_i, r_i]$ 加入答案；\n\n- 如果 $l_i > \\textit{right}$，说明 $[l_i, r_i]$ 与 $S$ 不重叠并且在其右侧，我们可以直接将 $[l_i, r_i]$ 加入答案；\n\n- 如果上面两种情况均不满足，说明 $[l_i, r_i]$ 与 $S$ 重叠，我们无需将 $[l_i, r_i]$ 加入答案。此时，我们需要将 $S$ 与 $[l_i, r_i]$ 合并，即将 $S$ 更新为其与 $[l_i, r_i]$ 的并集。\n\n那么我们应当在什么时候将区间 $S$ 加入答案呢？由于我们需要保证答案也是按照左端点排序的，因此当我们遇到**第一个** 满足 $l_i > \\textit{right}$ 的区间时，说明以后遍历到的区间不会与 $S$ 重叠，并且它们左端点一定会大于 $S$ 的左端点。此时我们就可以将 $S$ 加入答案。特别地，如果不存在这样的区间，我们需要在遍历结束后，将 $S$ 加入答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        int left = newInterval[0];\n        int right = newInterval[1];\n        bool placed = false;\n        vector<vector<int>> ans;\n        for (const auto& interval: intervals) {\n            if (interval[0] > right) {\n                // 在插入区间的右侧且无交集\n                if (!placed) {\n                    ans.push_back({left, right});\n                    placed = true;                    \n                }\n                ans.push_back(interval);\n            }\n            else if (interval[1] < left) {\n                // 在插入区间的左侧且无交集\n                ans.push_back(interval);\n            }\n            else {\n                // 与插入区间有交集，计算它们的并集\n                left = min(left, interval[0]);\n                right = max(right, interval[1]);\n            }\n        }\n        if (!placed) {\n            ans.push_back({left, right});\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        int left = newInterval[0];\n        int right = newInterval[1];\n        boolean placed = false;\n        List<int[]> ansList = new ArrayList<int[]>();\n        for (int[] interval : intervals) {\n            if (interval[0] > right) {\n                // 在插入区间的右侧且无交集\n                if (!placed) {\n                    ansList.add(new int[]{left, right});\n                    placed = true;                    \n                }\n                ansList.add(interval);\n            } else if (interval[1] < left) {\n                // 在插入区间的左侧且无交集\n                ansList.add(interval);\n            } else {\n                // 与插入区间有交集，计算它们的并集\n                left = Math.min(left, interval[0]);\n                right = Math.max(right, interval[1]);\n            }\n        }\n        if (!placed) {\n            ansList.add(new int[]{left, right});\n        }\n        int[][] ans = new int[ansList.size()][2];\n        for (int i = 0; i < ansList.size(); ++i) {\n            ans[i] = ansList.get(i);\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        left, right = newInterval\n        placed = False\n        ans = list()\n        for li, ri in intervals:\n            if li > right:\n                # 在插入区间的右侧且无交集\n                if not placed:\n                    ans.append([left, right])\n                    placed = True\n                ans.append([li, ri])\n            elif ri < left:\n                # 在插入区间的左侧且无交集\n                ans.append([li, ri])\n            else:\n                # 与插入区间有交集，计算它们的并集\n                left = min(left, li)\n                right = max(right, ri)\n        \n        if not placed:\n            ans.append([left, right])\n        return ans\n```\n\n```Golang [sol1-Golang]\nfunc insert(intervals [][]int, newInterval []int) (ans [][]int) {\n    left, right := newInterval[0], newInterval[1]\n    merged := false\n    for _, interval := range intervals {\n        if interval[0] > right {\n            // 在插入区间的右侧且无交集\n            if !merged {\n                ans = append(ans, []int{left, right})\n                merged = true\n            }\n            ans = append(ans, interval)\n        } else if interval[1] < left {\n            // 在插入区间的左侧且无交集\n            ans = append(ans, interval)\n        } else {\n            // 与插入区间有交集，计算它们的并集\n            left = min(left, interval[0])\n            right = max(right, interval[1])\n        }\n    }\n    if !merged {\n        ans = append(ans, []int{left, right})\n    }\n    return\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n```C [sol1-C]\nint** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0;\n    int left = newInterval[0];\n    int right = newInterval[1];\n    bool placed = false;\n    int** ans = malloc(sizeof(int*) * (intervalsSize + 1));\n    *returnColumnSizes = malloc(sizeof(int*) * (intervalsSize + 1));\n    for (int i = 0; i < intervalsSize; ++i) {\n        int* interval = intervals[i];\n        if (interval[0] > right) {\n            // 在插入区间的右侧且无交集\n            if (!placed) {\n                int* tmp = malloc(sizeof(int) * 2);\n                tmp[0] = left, tmp[1] = right;\n                (*returnColumnSizes)[*returnSize] = 2;\n                ans[(*returnSize)++] = tmp;\n                placed = true;\n            }\n            int* tmp = malloc(sizeof(int) * 2);\n            memcpy(tmp, interval, sizeof(int) * 2);\n            (*returnColumnSizes)[*returnSize] = 2;\n            ans[(*returnSize)++] = tmp;\n        } else if (interval[1] < left) {\n            // 在插入区间的左侧且无交集\n            int* tmp = malloc(sizeof(int) * 2);\n            memcpy(tmp, interval, sizeof(int) * 2);\n            (*returnColumnSizes)[*returnSize] = 2;\n            ans[(*returnSize)++] = tmp;\n        } else {\n            // 与插入区间有交集，计算它们的并集\n            left = fmin(left, interval[0]);\n            right = fmax(right, interval[1]);\n        }\n    }\n    if (!placed) {\n        int* tmp = malloc(sizeof(int) * 2);\n        tmp[0] = left, tmp[1] = right;\n        (*returnColumnSizes)[*returnSize] = 2;\n        ans[(*returnSize)++] = tmp;\n    }\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{intervals}$ 的长度，即给定的区间个数。\n\n- 空间复杂度：$O(1)$。除了存储返回答案的空间以外，我们只需要额外的常数空间即可。"
}