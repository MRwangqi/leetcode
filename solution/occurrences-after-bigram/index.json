{
	"titleSlug": "occurrences-after-bigram",
	"slug": "bigram-fen-ci-by-leetcode-solution-7q3e",
	"url": "https://leetcode-cn.com/problems/occurrences-after-bigram/solution/bigram-fen-ci-by-leetcode-solution-7q3e/",
	"content": "#### 方法一：遍历\n\n**思路与算法**\n\n我们将文本 $\\textit{text}$ 按空格分割成单词数组 $\\textit{words}$，然后遍历 $\\textit{words}$ 数组，如果一个单词的前两个单词分别按顺序等于 $\\textit{first}$ 和 $\\textit{second}$，则该单词符合第三个单词 $\\textit{third}$ 的定义, 将其加入结果中。\n\n**代码**\n\n```C [sol1-C]\nchar ** findOcurrences(char * text, char * first, char * second, int* returnSize){\n    int s = 0, e = 0, len = strlen(text);\n    char **words = (char **)malloc(sizeof(char *) * len);\n    memset(words, 0, sizeof(char *) * len);\n    int nwords = 0;\n    while (true) {\n        while (s < len && text[s] == ' ') {\n            s++;\n        }\n        if (s >= len) {\n            break;\n        }\n        e = s + 1;\n        while (e < len && text[e] != ' ') {\n            e++;\n        }\n        words[nwords++] = strndup(text + s, e - s);\n        s = e + 1;\n    }\n    char **ret = (char **)malloc(sizeof(char *) * (nwords + 1));\n    memset(ret, 0, sizeof(char *) * (nwords + 1));\n    int nret = 0;\n    for (int i = 2; i < nwords; i++) {\n        if (strcmp(words[i - 2], first) == 0 && strcmp(words[i - 1], second) == 0) {\n            ret[nret++] = strdup(words[i]);\n        }\n    }\n    for (int i = 0; i < nwords; i++) {\n        free(words[i]);\n    }\n    free(words);\n    *returnSize = nret;\n    return ret;\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> findOcurrences(string text, string first, string second) {\n        vector<string> words;\n        int s = 0, e = 0, len = text.length();\n        while (true) {\n            while (s < len && text[s] == ' ') {\n                s++;\n            }\n            if (s >= len) {\n                break;\n            }\n            e = s + 1;\n            while (e < len && text[e] != ' ') {\n                e++;\n            }\n            words.push_back(text.substr(s, e - s));\n            s = e + 1;\n        }\n        vector<string> ret;\n        for (int i = 2; i < words.size(); i++) {\n            if (words[i - 2] == first && words[i - 1] == second) {\n                ret.push_back(words[i]);\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String[] findOcurrences(String text, String first, String second) {\n        String[] words = text.split(\" \");\n        List<String> list = new ArrayList<String>();\n        for (int i = 2; i < words.length; i++) {\n            if (words[i - 2].equals(first) && words[i - 1].equals(second)) {\n                list.add(words[i]);\n            }\n        }\n        int size = list.size();\n        String[] ret = new String[size];\n        for (int i = 0; i < size; i++) {\n            ret[i] = list.get(i);\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string[] FindOcurrences(string text, string first, string second) {\n        string[] words = text.Split(\" \");\n        IList<string> list = new List<string>();\n        for (int i = 2; i < words.Length; i++) {\n            if (words[i - 2].Equals(first) && words[i - 1].Equals(second)) {\n                list.Add(words[i]);\n            }\n        }\n        int size = list.Count;\n        string[] ret = new string[size];\n        for (int i = 0; i < size; i++) {\n            ret[i] = list[i];\n        }\n        return ret;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:\n        words = text.split()\n        return [words[i] for i in range(2, len(words)) if words[i - 2] == first and words[i - 1] == second]\n```\n\n```Go [sol1-Golang]\nfunc findOcurrences(text, first, second string) (ans []string) {\n    words := strings.Split(text, \" \")\n    for i := 2; i < len(words); i++ {\n        if words[i-2] == first && words[i-1] == second {\n            ans = append(ans, words[i])\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findOcurrences = function(text, first, second) {\n    const words = text.split(\" \");\n    const list = [];\n    for (let i = 2; i < words.length; i++) {\n        if (words[i - 2] === first && words[i - 1] === second) {\n            list.push(words[i]);\n        }\n    }\n    const size = list.length;\n    const ret = Array(size).fill('');\n    for (let i = 0; i < size; i++) {\n        ret[i] = list[i];\n    }\n    return ret;\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(N)$，其中 $N$ 为 $\\textit{text}$ 的长度。分割 $\\textit{text}$ 需要 $O(N)$，$\\textit{words}$ 每个元素最多访问两次，需要 $O(N)$，所以总的时间复杂度为 $O(N)$。\n\n+ 空间复杂度：$O(N)$。需要 $O(N)$ 的空间来保存 $\\textit{words}$ 数组。"
}