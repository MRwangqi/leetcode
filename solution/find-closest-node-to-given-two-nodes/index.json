{
	"titleSlug": "find-closest-node-to-given-two-nodes",
	"slug": "ji-suan-dao-mei-ge-dian-de-ju-chi-python-gr2u",
	"url": "https://leetcode-cn.com/problems/find-closest-node-to-given-two-nodes/solution/ji-suan-dao-mei-ge-dian-de-ju-chi-python-gr2u/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1Ba411N78j) 已出炉，包含**思考题**的讲解，欢迎点赞三连，在评论区分享你对这场周赛的看法~\r\n\r\n--- \r\n\r\n求出 $\\textit{node}_1$ 到每个点的距离 $d_1$ 和 $\\textit{node}_2$ 到每个点的距离 $d_2$（无法到达时设为一个比较大的数），然后遍历 $d_1$ 和 $d_2$，答案即为 $\\max(d_1[i],d_2[i])$ 的最小值所对应的 $i$。若没有这样的节点，答案为 $-1$。\r\n\r\n这可以用 BFS 来做，但由于题目的输入是内向基环树（森林），每个连通块至多有一个环，利用这一特性，代码实现时可以用一个简单的循环求出距离数组。\r\n\r\n如果读者不了解**内向基环树**，我之前在 [2127. 参加会议的最多员工数](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/) 的题解中作了详细介绍，可以参考。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\r\n        n, min_dis, ans = len(edges), len(edges), -1\r\n        def calc_dis(x: int) -> List[int]:\r\n            dis = [n] * n\r\n            d = 0\r\n            while x >= 0 and dis[x] == n:\r\n                dis[x] = d\r\n                d += 1\r\n                x = edges[x]\r\n            return dis\r\n        for i, d in enumerate(map(max, zip(calc_dis(node1), calc_dis(node2)))):\r\n            if d < min_dis:\r\n                min_dis, ans = d, i\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\r\n        int[] d1 = calcDis(edges, node1), d2 = calcDis(edges, node2);\r\n        int ans = -1, n = edges.length;\r\n        for (int i = 0, minDis = n; i < n; ++i) {\r\n            var d = Math.max(d1[i], d2[i]);\r\n            if (d < minDis) {\r\n                minDis = d;\r\n                ans = i;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    int[] calcDis(int[] edges, int x) {\r\n        var n = edges.length;\r\n        var dis = new int[n];\r\n        Arrays.fill(dis, n);\r\n        for (var d = 0; x >= 0 && dis[x] == n; x = edges[x])\r\n            dis[x] = d++;\r\n        return dis;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int closestMeetingNode(vector<int> &edges, int node1, int node2) {\r\n        int n = edges.size(), min_dis = n, ans = -1;\r\n        auto calc_dis = [&](int x) -> vector<int> {\r\n            vector<int> dis(n, n);\r\n            for (int d = 0; x >= 0 && dis[x] == n; x = edges[x])\r\n                dis[x] = d++;\r\n            return dis;\r\n        };\r\n        auto d1 = calc_dis(node1), d2 = calc_dis(node2);\r\n        for (int i = 0; i < n; ++i) {\r\n            int d = max(d1[i], d2[i]);\r\n            if (d < min_dis) {\r\n                min_dis = d;\r\n                ans = i;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc closestMeetingNode(edges []int, node1, node2 int) int {\r\n\tn := len(edges)\r\n\tcalcDis := func(x int) []int {\r\n\t\tdis := make([]int, n)\r\n\t\tfor i := range dis {\r\n\t\t\tdis[i] = n\r\n\t\t}\r\n\t\tfor d := 0; x >= 0 && dis[x] == n; x = edges[x] {\r\n\t\t\tdis[x] = d\r\n\t\t\td++\r\n\t\t}\r\n\t\treturn dis\r\n\t}\r\n\r\n\td1 := calcDis(node1)\r\n\td2 := calcDis(node2)\r\n\tminDis, ans := n, -1\r\n\tfor i, d := range d1 {\r\n\t\tif d2[i] > d {\r\n\t\t\td = d2[i]\r\n\t\t}\r\n\t\tif d < minDis {\r\n\t\t\tminDis, ans = d, i\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{edges}$ 的长度。\r\n- 空间复杂度：$O(n)$。\r\n\r\n#### 思考题\r\n\r\n1. 如果输入的不止两个节点 $\\textit{node}_1$ 和 $\\textit{node}_2$，而是一个很长的 $\\textit{nodes}$ 列表，要怎么做呢？\r\n2. 如果输入的是 $\\textit{queries}$ 询问数组，每个询问包含两个节点 $\\textit{node}_1$ 和 $\\textit{node}_2$，要你回答 `closestMeetingNode(edges, node1, node2)` 的答案，要怎么做呢？\r\n\r\n解答见 [视频讲解](https://www.bilibili.com/video/BV1Ba411N78j)。\r\n"
}