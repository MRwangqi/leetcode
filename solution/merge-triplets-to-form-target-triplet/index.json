{
	"titleSlug": "merge-triplets-to-form-target-triplet",
	"slug": "he-bing-ruo-gan-san-yuan-zu-yi-xing-chen-8ypf",
	"url": "https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet/solution/he-bing-ruo-gan-san-yuan-zu-yi-xing-chen-8ypf/",
	"content": "#### 方法一：合并尽可能多的三元组\n\n**提示 $1$**\n\n设数组 $\\textit{triplets}$ 的长度为 $n$。\n\n题目等价于让我们选择若干个下标 $i_1, i_2, \\cdots, i_k$，且 $i_1 < i_2 < \\cdots < i_k \\leq n$，使得：\n\n$$\n\\begin{cases}\nx = \\max \\{ a_{i_1}, a_{i_2}, \\cdots, a_{i_k} \\} \\\\\ny = \\max \\{ b_{i_1}, b_{i_2}, \\cdots, b_{i_k} \\} \\\\\nz = \\max \\{ c_{i_1}, c_{i_2}, \\cdots, c_{i_k} \\}\n\\end{cases}\n$$\n\n这里的正确性在于，我们每次执行的操作是选择两个三元组每一个位置中的较大值，因此：\n\n- 同一个下标对应的三元组选择多次是没有意义的，每个三元组会被选择 $0$ 或 $1$ 次；\n\n- 选择三元组的顺序也是可以任意交换的。\n\n**提示 $2$**\n\n对于任意一个三元组 $(a_i, b_i, c_i)$：\n\n- 如果 $a_i > x$ 或者 $b_i > y$ 或者 $c_i > z$，那么选择该三元组是不合理的；\n- 否则，一定有 $a_i \\leq x$ 并且 $b_i \\leq y$ 并且 $c_i \\leq z$。由于所有的操作都是 $\\max$ 操作，因此选择这个三元组并没有什么坏处，它不会让我们原本得到 $(a_i, b_i, c_i)$ 的某种可行选择变得不可行，因为：\n\n    $$\n    \\big( \\max\\{x, a_i\\}, \\max\\{y, b_i\\}, \\max\\{z, c_i\\} \\big) = (x, y, z)\n    $$\n\n    是显然成立的。\n\n**思路与算法**\n\n根据提示 $2$，我们只需要遍历所有的三元组，如果 $a_i \\leq x$ 并且 $b_i \\leq y$ 并且 $c_i \\leq z$，那么我们就选择该三元组。\n\n设 $a, b, c$ 分别是我们选择的所有三元组 $a_i, b_i, c_i$ 中的最大值。在遍历结束后，如果有：\n\n$$\n(a, b, c) = (x, y, z)\n$$\n\n则返回 $\\text{true}$，否则返回 $\\text{false}$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {\n        int x = target[0], y = target[1], z = target[2];\n        int a = 0, b = 0, c = 0;\n\n        for (const auto& triplet: triplets) {\n            int ai = triplet[0], bi = triplet[1], ci = triplet[2];\n            if (ai <= x && bi <= y && ci <= z) {\n                tie(a, b, c) = tuple{max(a, ai), max(b, bi), max(c, ci)};\n            }\n        }\n\n        return tie(a, b, c) == tie(x, y, z);\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        x, y, z = target\n        a, b, c = 0, 0, 0\n        \n        for ai, bi, ci in triplets:\n            if ai <= x and bi <= y and ci <= z:\n                a, b, c = max(a, ai), max(b, bi), max(c, ci)\n        \n        return (a, b, c) == (x, y, z)\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{triples}$ 的长度。\n\n- 空间复杂度：$O(1)$。"
}