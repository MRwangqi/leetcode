{
	"titleSlug": "569nqc",
	"slug": "zui-xiao-shi-jian-chai-by-leetcode-solut-ue5t",
	"url": "https://leetcode-cn.com/problems/569nqc/solution/zui-xiao-shi-jian-chai-by-leetcode-solut-ue5t/",
	"content": "#### 方法一：排序\n\n将 $\\textit{timePoints}$ 排序后，最小时间差必然出现在 $\\textit{timePoints}$ 的两个相邻时间，或者 $\\textit{timePoints}$ 的两个首尾时间中。因此排序后遍历一遍 $\\textit{timePoints}$ 即可得到最小时间差。\n\n```Python [sol1-Python3]\ndef getMinutes(t: str) -> int:\n    return ((ord(t[0]) - ord('0')) * 10 + ord(t[1]) - ord('0')) * 60 + (ord(t[3]) - ord('0')) * 10 + ord(t[4]) - ord('0')\n\nclass Solution:\n    def findMinDifference(self, timePoints: List[str]) -> int:\n        timePoints.sort()\n        ans = float('inf')\n        t0Minutes = getMinutes(timePoints[0])\n        preMinutes = t0Minutes\n        for i in range(1, len(timePoints)):\n            minutes = getMinutes(timePoints[i])\n            ans = min(ans, minutes - preMinutes)  # 相邻时间的时间差\n            preMinutes = minutes\n        ans = min(ans, t0Minutes + 1440 - preMinutes)  # 首尾时间的时间差\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    int getMinutes(string &t) {\n        return (int(t[0] - '0') * 10 + int(t[1] - '0')) * 60 + int(t[3] - '0') * 10 + int(t[4] - '0');\n    }\n\npublic:\n    int findMinDifference(vector<string> &timePoints) {\n        sort(timePoints.begin(), timePoints.end());\n        int ans = INT_MAX;\n        int t0Minutes = getMinutes(timePoints[0]);\n        int preMinutes = t0Minutes;\n        for (int i = 1; i < timePoints.size(); ++i) {\n            int minutes = getMinutes(timePoints[i]);\n            ans = min(ans, minutes - preMinutes); // 相邻时间的时间差\n            preMinutes = minutes;\n        }\n        ans = min(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findMinDifference(List<String> timePoints) {\n        Collections.sort(timePoints);\n        int ans = Integer.MAX_VALUE;\n        int t0Minutes = getMinutes(timePoints.get(0));\n        int preMinutes = t0Minutes;\n        for (int i = 1; i < timePoints.size(); ++i) {\n            int minutes = getMinutes(timePoints.get(i));\n            ans = Math.min(ans, minutes - preMinutes); // 相邻时间的时间差\n            preMinutes = minutes;\n        }\n        ans = Math.min(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差\n        return ans;\n    }\n\n    public int getMinutes(String t) {\n        return ((t.charAt(0) - '0') * 10 + (t.charAt(1) - '0')) * 60 + (t.charAt(3) - '0') * 10 + (t.charAt(4) - '0');\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindMinDifference(IList<string> timePoints) {\n        timePoints = timePoints.OrderBy(x => x).ToList();\n        int ans = int.MaxValue;\n        int t0Minutes = getMinutes(timePoints[0]);\n        int preMinutes = t0Minutes;\n        for (int i = 1; i < timePoints.Count; ++i) {\n            int minutes = getMinutes(timePoints[i]);\n            ans = Math.Min(ans, minutes - preMinutes); // 相邻时间的时间差\n            preMinutes = minutes;\n        }\n        ans = Math.Min(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差\n        return ans;\n    }\n\n    public int getMinutes(string t) {\n        return ((t[0] - '0') * 10 + (t[1] - '0')) * 60 + (t[3] - '0') * 10 + (t[4] - '0');\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc getMinutes(t string) int {\n    return (int(t[0]-'0')*10+int(t[1]-'0'))*60 + int(t[3]-'0')*10 + int(t[4]-'0')\n}\n\nfunc findMinDifference(timePoints []string) int {\n    sort.Strings(timePoints)\n    ans := math.MaxInt32\n    t0Minutes := getMinutes(timePoints[0])\n    preMinutes := t0Minutes\n    for _, t := range timePoints[1:] {\n        minutes := getMinutes(t)\n        ans = min(ans, minutes-preMinutes) // 相邻时间的时间差\n        preMinutes = minutes\n    }\n    ans = min(ans, t0Minutes+1440-preMinutes) // 首尾时间的时间差\n    return ans\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint getMinutes(const char * t) {\n    return ((t[0] - '0') * 10 + (t[1] - '0')) * 60 + (t[3] - '0') * 10 + (t[4] - '0');\n}\n\nint cmp(const void * pa, const void * pb) {\n    return strcmp(*(char **)pa, *(char **)pb);\n}\n\nint findMinDifference(char ** timePoints, int timePointsSize) {\n    qsort(timePoints, timePointsSize, sizeof(char *), cmp);\n    int ans = 1440;\n    int t0Minutes = getMinutes(timePoints[0]);\n    int preMinutes = t0Minutes;\n    for (int i = 1; i < timePointsSize; ++i) {\n        int minutes = getMinutes(timePoints[i]);\n        ans = MIN(ans, minutes - preMinutes); // 相邻时间的时间差\n        preMinutes = minutes;\n    }\n    ans = MIN(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findMinDifference = function(timePoints) {\n    timePoints.sort();\n    let ans = Number.MAX_VALUE;\n    let t0Minutes = getMinutes(timePoints[0]);\n    let preMinutes = t0Minutes;\n    for (let i = 1; i < timePoints.length; ++i) {\n        const minutes = getMinutes(timePoints[i]);\n        ans = Math.min(ans, minutes - preMinutes); // 相邻时间的时间差\n        preMinutes = minutes;\n    }\n    ans = Math.min(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差\n    return ans;\n};\n\nconst getMinutes = (t) => {\n    return ((t[0].charCodeAt() - '0'.charCodeAt()) * 10 + (t[1].charCodeAt() - '0'.charCodeAt())) * 60 + (t[3].charCodeAt() - '0'.charCodeAt()) * 10 + (t[4].charCodeAt() - '0'.charCodeAt());\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n\\log n)$，其中 $n$ 是数组 $\\textit{timePoints}$ 的长度。排序需要 $O(n\\log n)$ 的时间。\n\n- 空间复杂度：$O(n)$ 或 $O(\\log n)$。为排序需要的空间，取决于具体语言的实现。\n\n#### 方法二：鸽巢原理\n\n根据题意，一共有 $24 \\times 60=1440$ 种不同的时间。由鸽巢原理可知，如果 $\\textit{timePoints}$ 的长度超过 $1440$，那么必然会有两个相同的时间，此时可以直接返回 $0$。\n\n```Python [sol2-Python3]\ndef getMinutes(t: str) -> int:\n    return ((ord(t[0]) - ord('0')) * 10 + ord(t[1]) - ord('0')) * 60 + (ord(t[3]) - ord('0')) * 10 + ord(t[4]) - ord('0')\n\nclass Solution:\n    def findMinDifference(self, timePoints: List[str]) -> int:\n        n = len(timePoints)\n        if n > 1440:\n            return 0\n        timePoints.sort()\n        ans = float('inf')\n        t0Minutes = getMinutes(timePoints[0])\n        preMinutes = t0Minutes\n        for i in range(1, n):\n            minutes = getMinutes(timePoints[i])\n            ans = min(ans, minutes - preMinutes)  # 相邻时间的时间差\n            preMinutes = minutes\n        ans = min(ans, t0Minutes + 1440 - preMinutes)  # 首尾时间的时间差\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\n    int getMinutes(string &t) {\n        return (int(t[0] - '0') * 10 + int(t[1] - '0')) * 60 + int(t[3] - '0') * 10 + int(t[4] - '0');\n    }\n\npublic:\n    int findMinDifference(vector<string> &timePoints) {\n        int n = timePoints.size();\n        if (n > 1440) {\n            return 0;\n        }\n        sort(timePoints.begin(), timePoints.end());\n        int ans = INT_MAX;\n        int t0Minutes = getMinutes(timePoints[0]);\n        int preMinutes = t0Minutes;\n        for (int i = 1; i < n; ++i) {\n            int minutes = getMinutes(timePoints[i]);\n            ans = min(ans, minutes - preMinutes); // 相邻时间的时间差\n            preMinutes = minutes;\n        }\n        ans = min(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int findMinDifference(List<String> timePoints) {\n        int n = timePoints.size();\n        if (n > 1440) {\n            return 0;\n        }\n        Collections.sort(timePoints);\n        int ans = Integer.MAX_VALUE;\n        int t0Minutes = getMinutes(timePoints.get(0));\n        int preMinutes = t0Minutes;\n        for (int i = 1; i < n; ++i) {\n            int minutes = getMinutes(timePoints.get(i));\n            ans = Math.min(ans, minutes - preMinutes); // 相邻时间的时间差\n            preMinutes = minutes;\n        }\n        ans = Math.min(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差\n        return ans;\n    }\n\n    public int getMinutes(String t) {\n        return ((t.charAt(0) - '0') * 10 + (t.charAt(1) - '0')) * 60 + (t.charAt(3) - '0') * 10 + (t.charAt(4) - '0');\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int FindMinDifference(IList<string> timePoints) {\n        int n = timePoints.Count;\n        if (n > 1440) {\n            return 0;\n        }\n        timePoints = timePoints.OrderBy(x => x).ToList();\n        int ans = int.MaxValue;\n        int t0Minutes = getMinutes(timePoints[0]);\n        int preMinutes = t0Minutes;\n        for (int i = 1; i < n; ++i) {\n            int minutes = getMinutes(timePoints[i]);\n            ans = Math.Min(ans, minutes - preMinutes); // 相邻时间的时间差\n            preMinutes = minutes;\n        }\n        ans = Math.Min(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差\n        return ans;\n    }\n\n    public int getMinutes(string t) {\n        return ((t[0] - '0') * 10 + (t[1] - '0')) * 60 + (t[3] - '0') * 10 + (t[4] - '0');\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc getMinutes(t string) int {\n    return (int(t[0]-'0')*10+int(t[1]-'0'))*60 + int(t[3]-'0')*10 + int(t[4]-'0')\n}\n\nfunc findMinDifference(timePoints []string) int {\n    if len(timePoints) > 1440 {\n        return 0\n    }\n    sort.Strings(timePoints)\n    ans := math.MaxInt32\n    t0Minutes := getMinutes(timePoints[0])\n    preMinutes := t0Minutes\n    for _, t := range timePoints[1:] {\n        minutes := getMinutes(t)\n        ans = min(ans, minutes-preMinutes) // 相邻时间的时间差\n        preMinutes = minutes\n    }\n    ans = min(ans, t0Minutes+1440-preMinutes) // 首尾时间的时间差\n    return ans\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n```C [sol2-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint getMinutes(const char * t) {\n    return ((t[0] - '0') * 10 + (t[1] - '0')) * 60 + (t[3] - '0') * 10 + (t[4] - '0');\n}\n\nint cmp(const void * pa, const void * pb) {\n    return strcmp(*(char **)pa, *(char **)pb);\n}\n\nint findMinDifference(char ** timePoints, int timePointsSize) {\n    if (timePointsSize > 1440) {\n        return 0;\n    }\n    qsort(timePoints, timePointsSize, sizeof(char *), cmp);\n    int ans = 1440;\n    int t0Minutes = getMinutes(timePoints[0]);\n    int preMinutes = t0Minutes;\n    for (int i = 1; i < timePointsSize; ++i) {\n        int minutes = getMinutes(timePoints[i]);\n        ans = MIN(ans, minutes - preMinutes); // 相邻时间的时间差\n        preMinutes = minutes;\n    }\n    ans = MIN(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar findMinDifference = function(timePoints) {\n    const n = timePoints.length;\n    if (n > 1440) {\n        return 0;\n    }\n    timePoints.sort();\n    let ans = Number.MAX_VALUE;\n    let t0Minutes = getMinutes(timePoints[0]);\n    let preMinutes = t0Minutes;\n    for (let i = 1; i < n; ++i) {\n        const minutes = getMinutes(timePoints[i]);\n        ans = Math.min(ans, minutes - preMinutes); // 相邻时间的时间差\n        preMinutes = minutes;\n    }\n    ans = Math.min(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差\n    return ans;\n};\n\nconst getMinutes = (t) => {\n    return ((t[0].charCodeAt() - '0'.charCodeAt()) * 10 + (t[1].charCodeAt() - '0'.charCodeAt())) * 60 + (t[3].charCodeAt() - '0'.charCodeAt()) * 10 + (t[4].charCodeAt() - '0'.charCodeAt());\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\min(n,C)\\log\\min(n,C))$，其中 $n$ 是数组 $\\textit{timePoints}$ 的长度，$C=24 \\times 60=1440$。由于当 $n>C$ 时直接返回 $0$，排序时的 $n$ 不会超过 $C$，因此排序需要 $O(\\min(n,C)\\log\\min(n,C))$ 的时间。\n\n- 空间复杂度：$O(\\min(n,C))$ 或 $O(\\log\\min(n,C))$。为排序需要的空间，取决于具体语言的实现。"
}