{
	"titleSlug": "mini-parser",
	"slug": "mi-ni-yu-fa-fen-xi-qi-by-leetcode-soluti-l2ma",
	"url": "https://leetcode-cn.com/problems/mini-parser/solution/mi-ni-yu-fa-fen-xi-qi-by-leetcode-soluti-l2ma/",
	"content": "#### 方法一：深度优先搜索\n\n**思路**\n\n根据题意，一个 $\\texttt{NestedInteger}$ 实例只能包含下列两部分之一：1）一个整数；2）一个列表，列表中的每个元素都是一个 $\\texttt{NestedInteger}$ 实例。据此，$\\texttt{NestedInteger}$ 是通过递归定义的，因此也可以用递归的方式来解析。\n\n从左至右遍历 $s$，\n- 如果第一位是 $\\texttt{`['}$ 字符，则表示待解析的是一个列表，从 $\\texttt{`['}$ 后面的字符开始又是一个新的 $\\texttt{NestedInteger}$ 实例，我们仍调用解析函数来解析列表的元素，调用结束后如果遇到的是 $,$ 字符，表示列表仍有其他元素，需要继续调用。如果是 $\\texttt{`]'}$ 字符，表示这个列表已经解析完毕，可以返回 $\\texttt{NestedInteger}$ 实例。\n- 否则，则表示待解析的 $\\texttt{NestedInteger}$ 只包含一个整数。我们可以从左至右解析这个整数，并注意是否是负数，直到遍历完或者遇到非数字字符（$\\texttt{`]'}$ 或 $\\texttt{`,'}$），并返回 $\\texttt{NestedInteger}$ 实例。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        index = 0\n\n        def dfs() -> NestedInteger:\n            nonlocal index\n            if s[index] == '[':\n                index += 1\n                ni = NestedInteger()\n                while s[index] != ']':\n                    ni.add(dfs())\n                    if s[index] == ',':\n                        index += 1\n                index += 1\n                return ni\n            else:\n                negative = False\n                if s[index] == '-':\n                    negative = True\n                    index += 1\n                num = 0\n                while index < len(s) and s[index].isdigit():\n                    num *= 10\n                    num += int(s[index])\n                    index += 1\n                if negative:\n                    num = -num\n                return NestedInteger(num)\n\n        return dfs()\n```\n\n```Java [sol1-Java]\nclass Solution {\n    int index = 0;\n\n    public NestedInteger deserialize(String s) {\n        if (s.charAt(index) == '[') {\n            index++;\n            NestedInteger ni = new NestedInteger();\n            while (s.charAt(index) != ']') {\n                ni.add(deserialize(s));\n                if (s.charAt(index) == ',') {\n                    index++;\n                }\n            }\n            index++;\n            return ni;\n        } else {\n            boolean negative = false;\n            if (s.charAt(index) == '-') {\n                negative = true;\n                index++;\n            }\n            int num = 0;\n            while (index < s.length() && Character.isDigit(s.charAt(index))) {\n                num = num * 10 + s.charAt(index) - '0';\n                index++;\n            }\n            if (negative) {\n                num *= -1;\n            }\n            return new NestedInteger(num);\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    int index = 0;\n\n    public NestedInteger Deserialize(string s) {\n        if (s[index] == '[') {\n            index++;\n            NestedInteger ni = new NestedInteger();\n            while (s[index] != ']') {\n                ni.Add(Deserialize(s));\n                if (s[index] == ',') {\n                    index++;\n                }\n            }\n            index++;\n            return ni;\n        } else {\n            bool negative = false;\n            if (s[index] == '-') {\n                negative = true;\n                index++;\n            }\n            int num = 0;\n            while (index < s.Length && char.IsDigit(s[index])) {\n                num = num * 10 + s[index] - '0';\n                index++;\n            }\n            if (negative) {\n                num *= -1;\n            }\n            return new NestedInteger(num);\n        }\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int index = 0;\n\n    NestedInteger deserialize(string s) {\n        if (s[index] == '[') {\n            index++;\n            NestedInteger ni;\n            while (s[index] != ']') {\n                ni.add(deserialize(s));\n                if (s[index] == ',') {\n                    index++;\n                }\n            }\n            index++;\n            return ni;\n        } else {\n            bool negative = false;\n            if (s[index] == '-') {\n                negative = true;\n                index++;\n            }\n            int num = 0;\n            while (index < s.size() && isdigit(s[index])) {\n                num = num * 10 + s[index] - '0';\n                index++;\n            }\n            if (negative) {\n                num *= -1;\n            }\n            return NestedInteger(num);\n        }\n    }\n};\n```\n\n```C [sol1-C]\nstruct NestedInteger* helper(const char * s, int * index){\n    if (s[*index] == '[') {\n        (*index)++;\n        struct NestedInteger * ni = NestedIntegerInit();\n        while (s[*index] != ']') {\n            NestedIntegerAdd(ni, helper(s, index));\n            if (s[*index] == ',') {\n                (*index)++;\n            }\n        }\n        (*index)++;\n        return ni;\n    } else {\n        bool negative = false;\n        if (s[*index] == '-') {\n            negative = true;\n            (*index)++;\n        }\n        int num = 0;\n        while (s[*index] && isdigit(s[*index])) {\n            num = num * 10 + s[*index] - '0';\n            (*index)++;\n        }\n        if (negative) {\n            num *= -1;\n        }\n        struct NestedInteger * ni = NestedIntegerInit();\n        NestedIntegerSetInteger(ni, num);\n        return ni;\n    }\n}\n\nstruct NestedInteger* deserialize(char * s){\n    int index = 0;\n    return helper(s, &index);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar deserialize = function(s) {\n    let index = 0;\n    const dfs = (s) => {\n        if (s[index] === '[') {\n            index++;\n            const ni = new NestedInteger();\n            while (s[index] !== ']') {\n                ni.add(dfs(s));\n                if (s[index] === ',') {\n                    index++;\n                }\n            }\n            index++;\n            return ni;\n        } else {\n            let negative = false;\n            if (s[index] === '-') {\n                negative = true;\n                index++;\n            }\n            let num = 0;\n            while (index < s.length && isDigit(s[index])) {\n                num = num * 10 + s[index].charCodeAt() - '0'.charCodeAt();\n                index++;\n            }\n            if (negative) {\n                num *= -1;\n            }\n            return new NestedInteger(num);\n        }\n    }\n    return dfs(s);\n};\n\nconst isDigit = (ch) => {\n    return parseFloat(ch).toString() === \"NaN\" ? false : true;\n}\n```\n\n```go [sol1-Golang]\nfunc deserialize(s string) *NestedInteger {\n    index := 0\n    var dfs func() *NestedInteger\n    dfs = func() *NestedInteger {\n        ni := &NestedInteger{}\n        if s[index] == '[' {\n            index++\n            for s[index] != ']' {\n                ni.Add(*dfs())\n                if s[index] == ',' {\n                    index++\n                }\n            }\n            index++\n            return ni\n        }\n\n        negative := s[index] == '-'\n        if negative {\n            index++\n        }\n        num := 0\n        for ; index < len(s) && unicode.IsDigit(rune(s[index])); index++ {\n            num = num*10 + int(s[index]-'0')\n        }\n        if negative {\n            num = -num\n        }\n        ni.SetInteger(num)\n        return ni\n    }\n    return dfs()\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是 $s$ 的长度。我们需要遍历 $s$ 的每一位来解析。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是 $s$ 的长度。深度优先搜索的深度最多为 $O(n)$，需要 $O(n)$ 的栈空间。\n\n#### 方法二：栈\n\n**思路**\n\n上述递归的思路也可以用栈来模拟。从左至右遍历 $s$，如果遇到 $\\texttt{`['}$，则表示是一个新的 $\\texttt{NestedInteger}$ 实例，需要将其入栈。如果遇到 $\\texttt{`]'}$ 或 $\\texttt{`,'}$，则表示是一个数字或者 $\\texttt{NestedInteger}$ 实例的结束，需要将其添加入栈顶的 $\\texttt{NestedInteger}$ 实例。最后需返回栈顶的实例。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        if s[0] != '[':\n            return NestedInteger(int(s))\n        stack, num, negative = [], 0, False\n        for i, c in enumerate(s):\n            if c == '-':\n                negative = True\n            elif c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '[':\n                stack.append(NestedInteger())\n            elif c in ',]':\n                if s[i-1].isdigit():\n                    if negative:\n                        num = -num\n                    stack[-1].add(NestedInteger(num))\n                num, negative = 0, False\n                if c == ']' and len(stack) > 1:\n                    stack[-2].add(stack.pop())\n        return stack.pop()\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public NestedInteger deserialize(String s) {\n        if (s.charAt(0) != '[') {\n            return new NestedInteger(Integer.parseInt(s));\n        }\n        Deque<NestedInteger> stack = new ArrayDeque<NestedInteger>();\n        int num = 0;\n        boolean negative = false;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '-') {\n                negative = true;\n            } else if (Character.isDigit(c)) {\n                num = num * 10 + c - '0';\n            } else if (c == '[') {\n                stack.push(new NestedInteger());\n            } else if (c == ',' || c == ']') {\n                if (Character.isDigit(s.charAt(i - 1))) {\n                    if (negative) {\n                        num *= -1;\n                    }\n                    stack.peek().add(new NestedInteger(num));\n                }\n                num = 0;\n                negative = false;\n                if (c == ']' && stack.size() > 1) {\n                    NestedInteger ni = stack.pop();\n                    stack.peek().add(ni);\n                }\n            }\n        }\n        return stack.pop();\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public NestedInteger Deserialize(string s) {\n        if (s[0] != '[') {\n            return new NestedInteger(int.Parse(s));\n        }\n        Stack<NestedInteger> stack = new Stack<NestedInteger>();\n        int num = 0;\n        bool negative = false;\n        for (int i = 0; i < s.Length; i++) {\n            char c = s[i];\n            if (c == '-') {\n                negative = true;\n            } else if (char.IsDigit(c)) {\n                num = num * 10 + c - '0';\n            } else if (c == '[') {\n                stack.Push(new NestedInteger());\n            } else if (c == ',' || c == ']') {\n                if (char.IsDigit(s[i - 1])) {\n                    if (negative) {\n                        num *= -1;\n                    }\n                    stack.Peek().Add(new NestedInteger(num));\n                }\n                num = 0;\n                negative = false;\n                if (c == ']' && stack.Count > 1) {\n                    NestedInteger ni = stack.Pop();\n                    stack.Peek().Add(ni);\n                }\n            }\n        }\n        return stack.Pop();\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    NestedInteger deserialize(string s) {\n        if (s[0] != '[') {\n            return NestedInteger(stoi(s));\n        }\n        stack<NestedInteger> st;\n        int num = 0;\n        bool negative = false;\n        for (int i = 0; i < s.size(); i++) {\n            char c = s[i];\n            if (c == '-') {\n                negative = true;\n            } else if (isdigit(c)) {\n                num = num * 10 + c - '0';\n            } else if (c == '[') {\n                st.emplace(NestedInteger());\n            } else if (c == ',' || c == ']') {\n                if (isdigit(s[i - 1])) {\n                    if (negative) {\n                        num *= -1;\n                    }\n                    st.top().add(NestedInteger(num));\n                }\n                num = 0;\n                negative = false;\n                if (c == ']' && st.size() > 1) {\n                    NestedInteger ni = st.top();\n                    st.pop();\n                    st.top().add(ni);\n                }\n            }\n        }\n        return st.top();\n    }\n};\n```\n\n```C [sol2-C]\n#define MAX_NEST_LEVEL 50001\n\nstruct NestedInteger* deserialize(char * s){\n    if (s[0] != '[') {\n        struct NestedInteger * ni = NestedIntegerInit();\n        NestedIntegerSetInteger(ni, atoi(s));\n        return ni;\n    }\n    struct NestedInteger **stack = (struct NestedInteger **)malloc(sizeof(struct NestedInteger *) * MAX_NEST_LEVEL);\n    int top = 0;\n    int num = 0;\n    bool negative = false;\n    int n = strlen(s);\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        if (c == '-') {\n            negative = true;\n        } else if (isdigit(c)) {\n            num = num * 10 + c - '0';\n        } else if (c == '[') {\n            struct NestedInteger * ni = NestedIntegerInit();\n            stack[top++] = ni;\n        } else if (c == ',' || c == ']') {\n            if (isdigit(s[i - 1])) {\n                if (negative) {\n                    num *= -1;\n                }\n                struct NestedInteger * ni = NestedIntegerInit();\n                NestedIntegerSetInteger(ni, num);\n                NestedIntegerAdd(stack[top - 1], ni);\n            }\n            num = 0;\n            negative = false;\n            if (c == ']' && top > 1) {\n                struct NestedInteger *ni = stack[top - 1];\n                top--;\n                NestedIntegerAdd(stack[top - 1], ni);\n            }\n        }\n    }\n    struct NestedInteger * res = stack[top - 1];\n    free(stack);\n    return res;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar deserialize = function(s) {\n    if (s[0] !== '[') {\n        return new NestedInteger(parseInt(s));\n    }\n    const stack = [];\n    let num = 0;\n    let negative = false;\n    for (let i = 0; i < s.length; i++) {\n        const c = s[i];\n        if (c === '-') {\n            negative = true;\n        } else if (isDigit(c)) {\n            num = num * 10 + c.charCodeAt() - '0'.charCodeAt();\n        } else if (c === '[') {\n            stack.push(new NestedInteger());\n        } else if (c === ',' || c === ']') {\n            if (isDigit(s[i - 1])) {\n                if (negative) {\n                    num *= -1;\n                }\n                stack[stack.length - 1].add(new NestedInteger(num));\n            }\n            num = 0;\n            negative = false;\n            if (c === ']' && stack.length > 1) {\n                const ni = stack.pop();\n                stack[stack.length - 1].add(ni);\n            }\n        }\n    }\n    return stack.pop();\n};\n\nconst isDigit = (ch) => {\n    return parseFloat(ch).toString() === \"NaN\" ? false : true;\n}\n```\n\n```go [sol2-Golang]\nfunc deserialize(s string) *NestedInteger {\n    if s[0] != '[' {\n        num, _ := strconv.Atoi(s)\n        ni := &NestedInteger{}\n        ni.SetInteger(num)\n        return ni\n    }\n    stack, num, negative := []*NestedInteger{}, 0, false\n    for i, ch := range s {\n        if ch == '-' {\n            negative = true\n        } else if unicode.IsDigit(ch) {\n            num = num*10 + int(ch-'0')\n        } else if ch == '[' {\n            stack = append(stack, &NestedInteger{})\n        } else if ch == ',' || ch == ']' {\n            if unicode.IsDigit(rune(s[i-1])) {\n                if negative {\n                    num = -num\n                }\n                ni := NestedInteger{}\n                ni.SetInteger(num)\n                stack[len(stack)-1].Add(ni)\n            }\n            num, negative = 0, false\n            if ch == ']' && len(stack) > 1 {\n                stack[len(stack)-2].Add(*stack[len(stack)-1])\n                stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    return stack[len(stack)-1]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是 $s$ 的长度。我们需要遍历 $s$ 的每一位来解析。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是 $s$ 的长度。栈的深度最多为 $O(n)$。"
}