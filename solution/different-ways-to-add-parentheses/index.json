{
	"titleSlug": "different-ways-to-add-parentheses",
	"slug": "wei-yun-suan-biao-da-shi-she-ji-you-xian-lyw6",
	"url": "https://leetcode-cn.com/problems/different-ways-to-add-parentheses/solution/wei-yun-suan-biao-da-shi-she-ji-you-xian-lyw6/",
	"content": "#### 方法一：记忆化搜索\n\n**思路与算法**\n\n我们首先对 $\\textit{expression}$ 做一个预处理，把全部的操作数（包括数字和算符）都放到 $\\textit{ops}$ 数组中，因为题目数据满足每一个数字都是 $[0,99]$ 的范围中，且算符总共有 $3$ 个，所以我们分别用 $-1$，$-2$，$-3$ 来表示算符 $+$，$-$，$*$。因为对于表达式中的某一个算符 $\\textit{op}$，我们将其左部可能的计算结果用 $\\textit{left}$ 集合来表示，其右部可能的计算结果用 $\\textit{right}$ 集合来表示。那么以该算符为该表达式的最后一步操作的情况的全部可能结果就是对应集合 $\\textit{left}$ 和集合 $\\textit{right}$ 中元素对应该算符操作的组合数。那么我们枚举表达式中的全部算符来作为 $\\textit{left}$ 和 $\\textit{right}$ 的分隔符来求得对应的集合，那么该表达式最终的可能结果就是这些集合的并集。\n\n为了避免相同区间的重复计算，我们用 $\\textit{dp}[l][r] = \\{v_0,v_1,\\ldots\\}$ 来表示对应表达式 $\\textit{ops}[l:r]$ 在按不同优先级组合数字和运算符的操作下能产生的全部可能结果。这样我们就可以通过记忆化搜索这种「自顶向下」的方式来进行求解原始的表达式的全部可能计算结果。而上面讨论的条件是需要计算的表达式中存在算符的情况，所以还需要讨论搜索结束的条件：当表达式不存在任何算符时，即 $l = r$ 时，对应的结果集合中就只有该一个数字。\n\n$$\\textit{dp}[l][r] = \\{\\textit{ops}[l]\\} , l = r \\And \\textit{ops}[l] \\ge 0$$\n\n**代码**\n\n```Python [sol1-Python3]\nADDITION = -1\nSUBTRACTION = -2\nMULTIPLICATION = -3\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        ops = []\n        i, n = 0, len(expression)\n        while i < n:\n            if expression[i].isdigit():\n                x = 0\n                while i < n and expression[i].isdigit():\n                    x = x * 10 + int(expression[i])\n                    i += 1\n                ops.append(x)\n            else:\n                if expression[i] == '+':\n                    ops.append(ADDITION)\n                elif expression[i] == '-':\n                    ops.append(SUBTRACTION)\n                else:\n                    ops.append(MULTIPLICATION)\n                i += 1\n\n        @cache\n        def dfs(l: int, r: int) -> List[int]:\n            if l == r:\n                return [ops[l]]\n            res = []\n            for i in range(l, r, 2):\n                left = dfs(l, i)\n                right = dfs(i + 2, r)\n                for x in left:\n                    for y in right:\n                        if ops[i + 1] == ADDITION:\n                            res.append(x + y)\n                        elif ops[i + 1] == SUBTRACTION:\n                            res.append(x - y)\n                        else:\n                            res.append(x * y)\n            return res\n        return dfs(0, len(ops) - 1)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    const int ADDITION = -1;\n    const int SUBTRACTION = -2;\n    const int MULTIPLICATION = -3;\n\n    vector<int> dfs(vector<vector<vector<int>>>& dp, int l, int r, const vector<int>& ops) {\n        if (dp[l][r].empty()) {\n            if (l == r) {\n                dp[l][r].push_back(ops[l]);\n            } else {\n                for (int i = l; i < r; i += 2) {\n                    auto left = dfs(dp, l, i, ops);\n                    auto right = dfs(dp, i + 2, r, ops);\n                    for (auto& lv : left) {\n                        for (auto& rv : right) {\n                            if (ops[i + 1] == ADDITION) {\n                                dp[l][r].push_back(lv + rv);\n                            } else if (ops[i + 1] == SUBTRACTION) {\n                                dp[l][r].push_back(lv - rv);\n                            } else {\n                                dp[l][r].push_back(lv * rv);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[l][r];\n    }\n\n    vector<int> diffWaysToCompute(string expression) {\n        vector<int> ops;\n        for (int i = 0; i < expression.size();) {\n            if (!isdigit(expression[i])) {\n                if (expression[i] == '+') {\n                    ops.push_back(ADDITION);\n                } else if (expression[i] == '-') {\n                    ops.push_back(SUBTRACTION);\n                } else {\n                    ops.push_back(MULTIPLICATION);\n                }\n                i++;\n            } else {\n                int t = 0;\n                while (i < expression.size() && isdigit(expression[i])) {\n                    t = t * 10 + expression[i] - '0';\n                    i++;\n                }\n                ops.push_back(t);\n            }\n        }\n        vector<vector<vector<int>>> dp((int) ops.size(), vector<vector<int>>((int) ops.size()));\n        return dfs(dp, 0, ops.size() - 1, ops);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static final int ADDITION = -1;\n    static final int SUBTRACTION = -2;\n    static final int MULTIPLICATION = -3;\n\n    public List<Integer> diffWaysToCompute(String expression) {\n        List<Integer> ops = new ArrayList<Integer>();\n        for (int i = 0; i < expression.length();) {\n            if (!Character.isDigit(expression.charAt(i))) {\n                if (expression.charAt(i) == '+') {\n                    ops.add(ADDITION);\n                } else if (expression.charAt(i) == '-') {\n                    ops.add(SUBTRACTION);\n                } else {\n                    ops.add(MULTIPLICATION);\n                }\n                i++;\n            } else {\n                int t = 0;\n                while (i < expression.length() && Character.isDigit(expression.charAt(i))) {\n                    t = t * 10 + expression.charAt(i) - '0';\n                    i++;\n                }\n                ops.add(t);\n            }\n        }\n        List<Integer>[][] dp = new List[ops.size()][ops.size()];\n        for (int i = 0; i < ops.size(); i++) {\n            for (int j = 0; j < ops.size(); j++) {\n                dp[i][j] = new ArrayList<Integer>();\n            }\n        }\n        return dfs(dp, 0, ops.size() - 1, ops);\n    }\n\n    public List<Integer> dfs(List<Integer>[][] dp, int l, int r, List<Integer> ops) {\n        if (dp[l][r].isEmpty()) {\n            if (l == r) {\n                dp[l][r].add(ops.get(l));\n            } else {\n                for (int i = l; i < r; i += 2) {\n                    List<Integer> left = dfs(dp, l, i, ops);\n                    List<Integer> right = dfs(dp, i + 2, r, ops);\n                    for (int lv : left) {\n                        for (int rv : right) {\n                            if (ops.get(i + 1) == ADDITION) {\n                                dp[l][r].add(lv + rv);\n                            } else if (ops.get(i + 1) == SUBTRACTION) {\n                                dp[l][r].add(lv - rv);\n                            } else {\n                                dp[l][r].add(lv * rv);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[l][r];\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    const int ADDITION = -1;\n    const int SUBTRACTION = -2;\n    const int MULTIPLICATION = -3;\n\n    public IList<int> DiffWaysToCompute(string expression) {\n        IList<int> ops = new List<int>();\n        for (int i = 0; i < expression.Length;) {\n            if (!char.IsDigit(expression[i])) {\n                if (expression[i] == '+') {\n                    ops.Add(ADDITION);\n                } else if (expression[i] == '-') {\n                    ops.Add(SUBTRACTION);\n                } else {\n                    ops.Add(MULTIPLICATION);\n                }\n                i++;\n            } else {\n                int t = 0;\n                while (i < expression.Length && char.IsDigit(expression[i])) {\n                    t = t * 10 + expression[i] - '0';\n                    i++;\n                }\n                ops.Add(t);\n            }\n        }\n        IList<int>[][] dp = new IList<int>[ops.Count][];\n        for (int i = 0; i < ops.Count; i++) {\n            dp[i] = new IList<int>[ops.Count];\n        }\n        for (int i = 0; i < ops.Count; i++) {\n            for (int j = 0; j < ops.Count; j++) {\n                dp[i][j] = new List<int>();\n            }\n        }\n        return DFS(dp, 0, ops.Count - 1, ops);\n    }\n\n    public IList<int> DFS(IList<int>[][] dp, int l, int r, IList<int> ops) {\n        if (dp[l][r].Count == 0) {\n            if (l == r) {\n                dp[l][r].Add(ops[l]);\n            } else {\n                for (int i = l; i < r; i += 2) {\n                    IList<int> left = DFS(dp, l, i, ops);\n                    IList<int> right = DFS(dp, i + 2, r, ops);\n                    foreach (int lv in left) {\n                        foreach (int rv in right) {\n                            if (ops[i + 1] == ADDITION) {\n                                dp[l][r].Add(lv + rv);\n                            } else if (ops[i + 1] == SUBTRACTION) {\n                                dp[l][r].Add(lv - rv);\n                            } else {\n                                dp[l][r].Add(lv * rv);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[l][r];\n    }\n}\n```\n\n```C [sol1-C]\n#define ADDITION -1\n#define SUBTRACTION -2\n#define MULTIPLICATION -3\n\nstruct ListNode * dfs(struct ListNode ***dp, int l, int r, const int *ops) {\n    if (!dp[l][r]) {\n        if (l == r) {\n            struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));\n            node->val = ops[l];\n            node->next = dp[l][r];\n            dp[l][r] = node;\n        } else {\n            for (int i = l; i < r; i += 2) {\n                for (struct ListNode *left = dfs(dp, l, i, ops); left; left = left->next) {\n                    for (struct ListNode *right = dfs(dp, i + 2, r, ops); right; right = right->next) {\n                        struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));\n                        if (ops[i + 1] == ADDITION) {\n                            node->val = left->val + right->val;\n                        } else if (ops[i + 1] == SUBTRACTION) {\n                            node->val = left->val - right->val;\n                        } else {\n                            node->val = left->val * right->val;\n                        }\n                        node->next = dp[l][r];\n                        dp[l][r] = node;\n                    }\n                }\n            }\n        }\n    }\n    return dp[l][r];\n}\n\nint* diffWaysToCompute(char * expression, int* returnSize) {\n    int len = strlen(expression);\n    int *ops = (int *)malloc(sizeof(int) * len);\n    int opsSize = 0;\n    for (int i = 0; i < len;) {\n        if (!isdigit(expression[i])) {\n            if (expression[i] == '+') {\n                ops[opsSize++] = ADDITION;\n            } else if (expression[i] == '-') {\n                ops[opsSize++] = SUBTRACTION;\n            } else {\n                ops[opsSize++] = MULTIPLICATION;\n            }\n            i++;\n        } else {\n            int t = 0;\n            while (i < len && isdigit(expression[i])) {\n                t = t * 10 + expression[i] - '0';\n                i++;\n            }\n            ops[opsSize++] = t;\n        }\n    }\n    struct ListNode ***dp = NULL;\n    dp = (struct ListNode ***)malloc(sizeof(struct ListNode **) * opsSize);\n    for (int i = 0; i < opsSize; i++) {\n        dp[i] = (struct ListNode **)malloc(sizeof(struct ListNode *) * opsSize);\n        for (int j = 0; j < opsSize; j++) {\n            dp[i][j] = NULL;\n        }\n    }\n    int *ans = (int *)malloc(sizeof(int) * (1 << opsSize));\n    int pos = 0;\n    struct ListNode *node = dfs(dp, 0, opsSize - 1, ops);\n    while (node) {\n        ans[pos++] = node->val;\n        node = node->next;\n    }\n    *returnSize = pos;\n    for (int i = 0; i < opsSize; i++) {\n        for (int j = 0; j < opsSize; j++) {\n            struct ListNode *curr, *tmp;\n            curr = dp[i][j];\n            while (curr) {\n                tmp = curr;\n                curr = curr->next;\n                free(tmp);\n            }\n        }\n        free(dp[i]);\n    }\n    free(dp);\n    free(ops);\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nconst addition, subtraction, multiplication = -1, -2, -3\n\nfunc diffWaysToCompute(expression string) []int {\n    ops := []int{}\n    for i, n := 0, len(expression); i < n; {\n        if unicode.IsDigit(rune(expression[i])) {\n            x := 0\n            for ; i < n && unicode.IsDigit(rune(expression[i])); i++ {\n                x = x*10 + int(expression[i]-'0')\n            }\n            ops = append(ops, x)\n        } else {\n            if expression[i] == '+' {\n                ops = append(ops, addition)\n            } else if expression[i] == '-' {\n                ops = append(ops, subtraction)\n            } else {\n                ops = append(ops, multiplication)\n            }\n            i++\n        }\n    }\n\n    n := len(ops)\n    dp := make([][][]int, n)\n    for i := range dp {\n        dp[i] = make([][]int, n)\n    }\n    var dfs func(int, int) []int\n    dfs = func(l, r int) []int {\n        res := dp[l][r]\n        if res != nil {\n            return res\n        }\n        if l == r {\n            dp[l][r] = []int{ops[l]}\n            return dp[l][r]\n        }\n        for i := l; i < r; i += 2 {\n            left := dfs(l, i)\n            right := dfs(i+2, r)\n            for _, x := range left {\n                for _, y := range right {\n                    if ops[i+1] == addition {\n                        dp[l][r] = append(dp[l][r], x+y)\n                    } else if ops[i+1] == subtraction {\n                        dp[l][r] = append(dp[l][r], x-y)\n                    } else {\n                        dp[l][r] = append(dp[l][r], x*y)\n                    }\n                }\n            }\n        }\n        return dp[l][r]\n    }\n    return dfs(0, n-1)\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst ADDITION = -1;\nconst SUBTRACTION = -2;\nconst MULTIPLICATION = -3;\n\nvar diffWaysToCompute = function(expression) {\n    const ops = [];\n    for (let i = 0; i < expression.length;) {\n        if (!isDigit(expression[i])) {\n            if (expression[i] === '+') {\n                ops.push(ADDITION);\n            } else if (expression[i] === '-') {\n                ops.push(SUBTRACTION);\n            } else {\n                ops.push(MULTIPLICATION);\n            }\n            i++;\n        } else {\n            let t = 0;\n            while (i < expression.length && isDigit(expression[i])) {\n                t = t * 10 + expression[i].charCodeAt() - '0'.charCodeAt();\n                i++;\n            }\n            ops.push(t);\n        }\n    }\n    const dp = new Array(ops.length).fill(0).map(() => new Array(ops.length).fill(0));\n    for (let i = 0; i < ops.length; i++) {\n        for (let j = 0; j < ops.length; j++) {\n            dp[i][j] = [];\n        }\n    }\n    return dfs(dp, 0, ops.length - 1, ops);\n};\n\nconst dfs = (dp, l, r, ops) => {\n    if (dp[l][r].length === 0) {\n        if (l == r) {\n            dp[l][r].push(ops[l]);\n        } else {\n            for (let i = l; i < r; i += 2) {\n                const left = dfs(dp, l, i, ops);\n                const right = dfs(dp, i + 2, r, ops);\n                for (const lv of left) {\n                    for (const rv of right) {\n                        if (ops[i + 1] === ADDITION) {\n                            dp[l][r].push(lv + rv);\n                        } else if (ops[i + 1] === SUBTRACTION) {\n                            dp[l][r].push(lv - rv);\n                        } else {\n                            dp[l][r].push(lv * rv);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dp[l][r];\n}\n\nconst isDigit = (ch) => {\n    return parseFloat(ch).toString() === \"NaN\" ? false : true;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(2^n)$，其中 $n$ 为 $\\textit{ops}$ 的大小。可以分析得到 $n$ 一定是奇数，令 $n = 2k+1$，最后的答案集合大小等于 $C_k$，第 $k$ 个[卡特兰数（Catalan Number）](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746)；以及 $\\sum_{k<\\frac{n}{2}}C_k$（计算中间结果所涉及的复杂度）限制在 $O(2^n)$。这里不具体证明，感兴趣的读者可以自行研究。\n\n- 空间复杂度：$O(2^n)$，其中 $n$ 为 $\\textit{ops}$ 的大小。\n\n#### 方法二：动态规划\n\n**思路与算法**\n\n我们同样可以用「动态规划」这种「自底向上」的方法来求解原始的表达式的全部可能计算结果。同样我们用 $\\textit{dp}[l][r] = \\{v_0,v_1,\\ldots\\}$ 来表示对应表达式 $\\textit{ops}[l:r]$ 在按不同优先级组合数字和运算符的操作下能产生的全部可能结果。此时边界情况就是当表达式不存在任何算符时，即 $l = r$ 时，对应的结果集合中就只有一个数字。\n\n$$\\textit{dp}[l][r] = \\{\\textit{ops}[l]\\} , l = r \\And \\textit{ops}[l] \\ge 0$$\n\n**代码**\n\n```Python [sol2-Python3]\nADDITION = -1\nSUBTRACTION = -2\nMULTIPLICATION = -3\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        ops = []\n        i, n = 0, len(expression)\n        while i < n:\n            if expression[i].isdigit():\n                x = 0\n                while i < n and expression[i].isdigit():\n                    x = x * 10 + int(expression[i])\n                    i += 1\n                ops.append(x)\n            else:\n                if expression[i] == '+':\n                    ops.append(ADDITION)\n                elif expression[i] == '-':\n                    ops.append(SUBTRACTION)\n                else:\n                    ops.append(MULTIPLICATION)\n                i += 1\n\n        n = len(ops)\n        dp = [[[] for _ in range(n)] for _ in range(n)]\n        for i, x in enumerate(ops):\n            dp[i][i] = [x]\n        for sz in range(3, n + 1):\n            for r in range(sz - 1, n, 2):\n                l = r - sz + 1\n                for k in range(l + 1, r, 2):\n                    for x in dp[l][k - 1]:\n                        for y in dp[k + 1][r]:\n                            if ops[k] == ADDITION:\n                                dp[l][r].append(x + y)\n                            elif ops[k] == SUBTRACTION:\n                                dp[l][r].append(x - y)\n                            else:\n                                dp[l][r].append(x * y)\n        return dp[0][-1]\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    const int ADDITION = -1;\n    const int SUBTRACTION = -2;\n    const int MULTIPLICATION = -3;\n\n    vector<int> diffWaysToCompute(string expression) {\n        vector<int> ops;\n        for (int i = 0; i < expression.size();) {\n            if (!isdigit(expression[i])) {\n                if (expression[i] == '+') {\n                    ops.push_back(ADDITION);\n                } else if (expression[i] == '-') {\n                    ops.push_back(SUBTRACTION);\n                } else {\n                    ops.push_back(MULTIPLICATION);\n                }\n                i++;\n            } else {\n                int t = 0;\n                while (i < expression.size() && isdigit(expression[i])) {\n                    t = t * 10 + expression[i] - '0';\n                    i++;\n                }\n                ops.push_back(t);\n            }\n        }\n        vector<vector<vector<int>>> dp((int) ops.size(), vector<vector<int>>((int) ops.size()));\n        for (int i = 0; i < ops.size(); i += 2) {\n            dp[i][i] = {ops[i]};\n        }\n        for (int i = 3; i <= ops.size(); i++) {\n            for (int j = 0; j + i <= ops.size(); j += 2) {\n                int l = j;\n                int r = j + i - 1;\n                for (int k = j + 1; k < r; k += 2) {\n                    auto& left = dp[l][k - 1];\n                    auto& right = dp[k + 1][r];\n                    for (auto& num1 : left) {\n                        for (auto& num2 : right) {\n                            if (ops[k] == ADDITION) {\n                                dp[l][r].push_back(num1 + num2);\n                            }\n                            else if (ops[k] == SUBTRACTION) {\n                                dp[l][r].push_back(num1 - num2);\n                            }\n                            else if (ops[k] == MULTIPLICATION) {\n                                dp[l][r].push_back(num1 * num2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][(int) ops.size() - 1];\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    static final int ADDITION = -1;\n    static final int SUBTRACTION = -2;\n    static final int MULTIPLICATION = -3;\n\n    public List<Integer> diffWaysToCompute(String expression) {\n        List<Integer> ops = new ArrayList<Integer>();\n        for (int i = 0; i < expression.length();) {\n            if (!Character.isDigit(expression.charAt(i))) {\n                if (expression.charAt(i) == '+') {\n                    ops.add(ADDITION);\n                } else if (expression.charAt(i) == '-') {\n                    ops.add(SUBTRACTION);\n                } else {\n                    ops.add(MULTIPLICATION);\n                }\n                i++;\n            } else {\n                int t = 0;\n                while (i < expression.length() && Character.isDigit(expression.charAt(i))) {\n                    t = t * 10 + expression.charAt(i) - '0';\n                    i++;\n                }\n                ops.add(t);\n            }\n        }\n        List<Integer>[][] dp = new List[ops.size()][ops.size()];\n        for (int i = 0; i < ops.size(); i++) {\n            for (int j = 0; j < ops.size(); j++) {\n                dp[i][j] = new ArrayList<Integer>();\n            }\n        }\n        for (int i = 0; i < ops.size(); i += 2) {\n            dp[i][i].add(ops.get(i));\n        }\n        for (int i = 3; i <= ops.size(); i++) {\n            for (int j = 0; j + i <= ops.size(); j += 2) {\n                int l = j;\n                int r = j + i - 1;\n                for (int k = j + 1; k < r; k += 2) {\n                    List<Integer> left = dp[l][k - 1];\n                    List<Integer> right = dp[k + 1][r];\n                    for (int num1 : left) {\n                        for (int num2 : right) {\n                            if (ops.get(k) == ADDITION) {\n                                dp[l][r].add(num1 + num2);\n                            } else if (ops.get(k) == SUBTRACTION) {\n                                dp[l][r].add(num1 - num2);\n                            } else if (ops.get(k) == MULTIPLICATION) {\n                                dp[l][r].add(num1 * num2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][ops.size() - 1];\n    }\n};\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    const int ADDITION = -1;\n    const int SUBTRACTION = -2;\n    const int MULTIPLICATION = -3;\n\n    public IList<int> DiffWaysToCompute(string expression) {\n        IList<int> ops = new List<int>();\n        for (int i = 0; i < expression.Length;) {\n            if (!char.IsDigit(expression[i])) {\n                if (expression[i] == '+') {\n                    ops.Add(ADDITION);\n                } else if (expression[i] == '-') {\n                    ops.Add(SUBTRACTION);\n                } else {\n                    ops.Add(MULTIPLICATION);\n                }\n                i++;\n            } else {\n                int t = 0;\n                while (i < expression.Length && char.IsDigit(expression[i])) {\n                    t = t * 10 + expression[i] - '0';\n                    i++;\n                }\n                ops.Add(t);\n            }\n        }\n        IList<int>[][] dp = new IList<int>[ops.Count][];\n        for (int i = 0; i < ops.Count; i++) {\n            dp[i] = new IList<int>[ops.Count];\n        }\n        for (int i = 0; i < ops.Count; i++) {\n            for (int j = 0; j < ops.Count; j++) {\n                dp[i][j] = new List<int>();\n            }\n        }\n        for (int i = 0; i < ops.Count; i += 2) {\n            dp[i][i].Add(ops[i]);\n        }\n        for (int i = 3; i <= ops.Count; i++) {\n            for (int j = 0; j + i <= ops.Count; j += 2) {\n                int l = j;\n                int r = j + i - 1;\n                for (int k = j + 1; k < r; k += 2) {\n                    IList<int> left = dp[l][k - 1];\n                    IList<int> right = dp[k + 1][r];\n                    foreach (int num1 in left) {\n                        foreach (int num2 in right) {\n                            if (ops[k] == ADDITION) {\n                                dp[l][r].Add(num1 + num2);\n                            } else if (ops[k] == SUBTRACTION) {\n                                dp[l][r].Add(num1 - num2);\n                            } else if (ops[k] == MULTIPLICATION) {\n                                dp[l][r].Add(num1 * num2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][ops.Count - 1];\n    }\n}\n```\n\n```C [sol2-C]\n#define ADDITION -1\n#define SUBTRACTION -2\n#define MULTIPLICATION -3\n\nint* diffWaysToCompute(char * expression, int* returnSize) {\n    int len = strlen(expression);\n    int *ops = (int *)malloc(sizeof(int) * len);\n    int opsSize = 0;\n    for (int i = 0; i < len;) {\n        if (!isdigit(expression[i])) {\n            if (expression[i] == '+') {\n                ops[opsSize++] = ADDITION;\n            } else if (expression[i] == '-') {\n                ops[opsSize++] = SUBTRACTION;\n            } else {\n                ops[opsSize++] = MULTIPLICATION;\n            }\n            i++;\n        } else {\n            int t = 0;\n            while (i < len && isdigit(expression[i])) {\n                t = t * 10 + expression[i] - '0';\n                i++;\n            }\n            ops[opsSize++] = t;\n        }\n    }\n    struct ListNode ***dp = NULL;\n    dp = (struct ListNode ***)malloc(sizeof(struct ListNode **) * opsSize);\n    for (int i = 0; i < opsSize; i++) {\n        dp[i] = (struct ListNode **)malloc(sizeof(struct ListNode *) * opsSize);\n        for (int j = 0; j < opsSize; j++) {\n            dp[i][j] = NULL;\n        }\n    }\n    for (int i = 0; i < opsSize; i += 2) {\n        struct ListNode *node = (struct ListNode*)malloc(sizeof(struct ListNode));\n        node->val = ops[i];\n        node->next = NULL;\n        dp[i][i] = node;\n    }\n    for (int i = 3; i <= opsSize; i++) {\n        for (int j = 0; j + i <= opsSize; j += 2) {\n            int l = j;\n            int r = j + i - 1;\n            for (int k = j + 1; k < r; k += 2) {\n                struct ListNode *left = dp[l][k - 1];\n                struct ListNode *right = dp[k + 1][r];\n                for (struct ListNode *left = dp[l][k - 1]; left; left = left->next) {\n                    for (struct ListNode *right = dp[k + 1][r]; right; right = right->next) {\n                        struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));\n                        if (ops[k] == ADDITION) {\n                            node->val = left->val + right->val;\n                        }\n                        else if (ops[k] == SUBTRACTION) {\n                            node->val = left->val - right->val;\n                        }\n                        else if (ops[k] == MULTIPLICATION) {\n                            node->val = left->val * right->val;\n                        }\n                        node->next = dp[l][r];\n                        dp[l][r] = node;\n                    }\n                }\n            }\n        }\n    }\n    int *ans = (int *)malloc(sizeof(int) * (1 << opsSize));\n    int pos = 0;\n    for (struct ListNode *node = dp[0][opsSize - 1]; node; node = node->next) {\n        ans[pos++] = node->val;\n    }\n    *returnSize = pos;\n    for (int i = 0; i < opsSize; i++) {\n        for (int j = 0; j < opsSize; j++) {\n            struct ListNode *curr, *tmp;\n            curr = dp[i][j];\n            while (curr) {\n                tmp = curr;\n                curr = curr->next;\n                free(tmp);\n            }\n        }\n        free(dp[i]);\n    }\n    free(dp);\n    free(ops);\n    return ans;\n}\n```\n\n```go [sol2-Golang]\nconst addition, subtraction, multiplication = -1, -2, -3\n\nfunc diffWaysToCompute(expression string) []int {\n    ops := []int{}\n    for i, n := 0, len(expression); i < n; {\n        if unicode.IsDigit(rune(expression[i])) {\n            x := 0\n            for ; i < n && unicode.IsDigit(rune(expression[i])); i++ {\n                x = x*10 + int(expression[i]-'0')\n            }\n            ops = append(ops, x)\n        } else {\n            if expression[i] == '+' {\n                ops = append(ops, addition)\n            } else if expression[i] == '-' {\n                ops = append(ops, subtraction)\n            } else {\n                ops = append(ops, multiplication)\n            }\n            i++\n        }\n    }\n\n    n := len(ops)\n    dp := make([][][]int, n)\n    for i, x := range ops {\n        dp[i] = make([][]int, n)\n        dp[i][i] = []int{x}\n    }\n    for sz := 3; sz <= n; sz++ {\n        for l, r := 0, sz-1; r < n; l += 2 {\n            for k := l + 1; k < r; k += 2 {\n                for _, x := range dp[l][k-1] {\n                    for _, y := range dp[k+1][r] {\n                        if ops[k] == addition {\n                            dp[l][r] = append(dp[l][r], x+y)\n                        } else if ops[k] == subtraction {\n                            dp[l][r] = append(dp[l][r], x-y)\n                        } else {\n                            dp[l][r] = append(dp[l][r], x*y)\n                        }\n                    }\n                }\n            }\n            r += 2\n        }\n    }\n    return dp[0][n-1]\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar diffWaysToCompute = function(expression) {\n    const ADDITION = -1;\n    const SUBTRACTION = -2;\n    const MULTIPLICATION = -3;\n    const ops = [];\n    for (let i = 0; i < expression.length;) {\n        if (!isDigit(expression[i])) {\n            if (expression[i] === '+') {\n                ops.push(ADDITION);\n            } else if (expression[i] === '-') {\n                ops.push(SUBTRACTION);\n            } else {\n                ops.push(MULTIPLICATION);\n            }\n            i++;\n        } else {\n            let t = 0;\n            while (i < expression.length && isDigit(expression[i])) {\n                t = t * 10 + expression[i].charCodeAt() - '0'.charCodeAt();\n                i++;\n            }\n            ops.push(t);\n        }\n    }\n    const dp = new Array(ops.length).fill(0).map(() => new Array(ops.length).fill(0));\n    for (let i = 0; i < ops.length; i++) {\n        for (let j = 0; j < ops.length; j++) {\n            dp[i][j] = [];\n        }\n    }\n    for (let i = 0; i < ops.length; i += 2) {\n        dp[i][i].push(ops[i]);\n    }\n    for (let i = 3; i <= ops.length; i++) {\n        for (let j = 0; j + i <= ops.length; j += 2) {\n            let l = j;\n            let r = j + i - 1;\n            for (let k = j + 1; k < r; k += 2) {\n                const left = dp[l][k - 1];\n                const right = dp[k + 1][r];\n                for (const num1 of left) {\n                    for (const num2 of right) {\n                        if (ops[k] === ADDITION) {\n                            dp[l][r].push(num1 + num2);\n                        } else if (ops[k] === SUBTRACTION) {\n                            dp[l][r].push(num1 - num2);\n                        } else if (ops[k] === MULTIPLICATION) {\n                            dp[l][r].push(num1 * num2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dp[0][ops.length - 1];\n};\n\nconst isDigit = (ch) => {\n    return parseFloat(ch).toString() === \"NaN\" ? false : true;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(2^n)$，其中 $n$ 为 $\\textit{ops}$ 的大小。分析同方法一的「记忆化搜索」。\n\n- 空间复杂度：$O(2^n)$，其中 $n$ 为 $\\textit{ops}$ 的大小。"
}