{
	"titleSlug": "minimum-height-tree-lcci",
	"slug": "zui-xiao-gao-du-shu-by-leetcode-solution-t8d1",
	"url": "https://leetcode-cn.com/problems/minimum-height-tree-lcci/solution/zui-xiao-gao-du-shu-by-leetcode-solution-t8d1/",
	"content": "#### 前言\n\n二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。\n\n给定二叉搜索树的中序遍历，是否可以唯一地确定二叉搜索树？答案是否定的。如果没有要求二叉搜索树的高度最小，则任何一个数字都可以作为二叉搜索树的根节点，因此可能的二叉搜索树有多个。\n\n![fig1](https://assets.leetcode-cn.com/solution-static/jindian_04.02/04.02_fig1.png){:width=\"85%\"}\n\n如果增加一个限制条件，即要求二叉搜索树的高度最小，是否可以唯一地确定二叉搜索树？答案仍然是否定的。\n\n![fig2](https://assets.leetcode-cn.com/solution-static/jindian_04.02/04.02_fig2.png){:width=\"85%\"}\n\n如果二叉搜索树中有 $n$ 个节点，则二叉搜索树的最小高度是 $\\lfloor \\log n \\rfloor$，最大高度是 $n - 1$。为了使二叉搜索树的高度最小，左右子树的节点数应尽可能接近，因此我们选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 $1$，可以使得二叉搜索树的高度最小。如果数组长度是奇数，则根节点的选择是唯一的，如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点，选择不同的数字作为根节点则创建的最小高度二叉搜索树也是不同的。\n\n![fig3](https://assets.leetcode-cn.com/solution-static/jindian_04.02/04.02_fig3.png){:width=\"60%\"}\n\n确定最小高度二叉搜索树的根节点之后，其余的数字分别位于最小高度二叉搜索树的左子树和右子树中，左子树和右子树分别也是最小高度二叉搜索树，因此可以通过递归的方式创建最小高度二叉搜索树。\n\n递归的基准情形是最小高度二叉搜索树不包含任何数字，此时最小高度二叉搜索树为空。\n\n在给定中序遍历序列数组的情况下，每一个子树中的数字在数组中一定是连续的，因此可以通过数组下标范围确定子树包含的数字，下标范围记为 $[\\textit{left}, \\textit{right}]$。对于整个中序遍历序列，下标范围从 $\\textit{left}=0$ 到 $\\textit{right}=\\textit{nums}.\\text{length}-1$。当 $\\textit{left}>\\textit{right}$ 时，最小高度二叉搜索树为空。\n\n以下三种方法中，方法一总是选择中间位置左边的数字作为根节点，方法二总是选择中间位置右边的数字作为根节点，方法三是方法一和方法二的结合，选择任意一个中间位置数字作为根节点。\n\n#### 方法一：中序遍历，总是选择中间位置左边的数字作为根节点\n\n选择中间位置左边的数字作为根节点，则根节点的下标为 $\\textit{mid}=(\\textit{left}+\\textit{right})/2$，此处的除法为整数除法。\n\n![fig4](https://assets.leetcode-cn.com/solution-static/jindian_04.02/04.02_fig4.png){:width=\"60%\"}\n\n```Java [sol1-Java]\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return helper(nums, 0, nums.length - 1);\n    }\n\n    public TreeNode helper(int[] nums, int left, int right) {\n        if (left > right) {\n            return null;\n        }\n\n        // 总是选择中间位置左边的数字作为根节点\n        int mid = (left + right) / 2;\n\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = helper(nums, left, mid - 1);\n        root.right = helper(nums, mid + 1, right);\n        return root;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\n        def helper(left, right):\n            if left > right:\n                return None\n\n            # 总是选择中间位置左边的数字作为根节点\n            mid = (left + right) // 2\n\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n\n        return helper(0, len(nums) - 1)\n```\n\n```csharp [sol1-C#]\npublic class Solution \n{\n    public TreeNode SortedArrayToBST(int[] nums) \n    {\n        return Helper(nums, 0, nums.Length - 1);\n    }\n\n    public TreeNode Helper(int[] nums, int left, int right) \n    {\n        if (left > right)\n        {\n            return null;\n        }\n\n        // 总是选择中间位置左边的数字作为根节点\n        int mid = (left + right) / 2;\n\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = Helper(nums, left, mid - 1);\n        root.right = Helper(nums, mid + 1, right);\n        return root;\n    }\n}\n```\n\n```cpp [sol1-C++]\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        return helper(nums, 0, nums.size() - 1);\n    }\n\n    TreeNode* helper(vector<int>& nums, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n\n        // 总是选择中间位置左边的数字作为根节点\n        int mid = (left + right) / 2;\n\n        TreeNode* root = new TreeNode(nums[mid]);\n        root->left = helper(nums, left, mid - 1);\n        root->right = helper(nums, mid + 1, right);\n        return root;\n    }\n};\n```\n\n```C [sol1-C]\nstruct TreeNode* helper(int* nums, int left, int right) {\n    if (left > right) {\n        return NULL;\n    }\n\n    // 总是选择中间位置左边的数字作为根节点\n    int mid = (left + right) / 2;\n\n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = nums[mid];\n    root->left = helper(nums, left, mid - 1);\n    root->right = helper(nums, mid + 1, right);\n    return root;\n}\n\nstruct TreeNode* sortedArrayToBST(int* nums, int numsSize) {\n    return helper(nums, 0, numsSize - 1);\n}\n```\n\n```golang [sol1-Golang]\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    return helper(nums, 0, len(nums) - 1)\n}\n\nfunc helper(nums []int, left, right int) *TreeNode {\n    if left > right {\n        return nil\n    }\n    mid := (left + right) / 2\n    root := &TreeNode{Val: nums[mid]}\n    root.Left = helper(nums, left, mid - 1)\n    root.Right = helper(nums, mid + 1, right)\n    return root\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(n)$，其中 $n$ 是数组的长度。每个数字只访问一次。\n\n* 空间复杂度：$O(\\log n)$，其中 $n$ 是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 $O(\\log n)$。\n\n#### 方法二：中序遍历，总是选择中间位置右边的数字作为根节点\n\n选择中间位置右边的数字作为根节点，则根节点的下标为 $\\textit{mid}=(\\textit{left}+\\textit{right}+1)/2$，此处的除法为整数除法。\n\n![fig5](https://assets.leetcode-cn.com/solution-static/jindian_04.02/04.02_fig5.png){:width=\"60%\"}\n\n```Java [sol2-Java]\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return helper(nums, 0, nums.length - 1);\n    }\n\n    public TreeNode helper(int[] nums, int left, int right) {\n        if (left > right) {\n            return null;\n        }\n\n        // 总是选择中间位置右边的数字作为根节点\n        int mid = (left + right + 1) / 2;\n\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = helper(nums, left, mid - 1);\n        root.right = helper(nums, mid + 1, right);\n        return root;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\n        def helper(left, right):\n            if left > right:\n                return None\n\n            # 总是选择中间位置右边的数字作为根节点\n            mid = (left + right + 1) // 2\n\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n\n        return helper(0, len(nums) - 1)\n```\n\n```csharp [sol2-C#]\npublic class Solution \n{\n    public TreeNode SortedArrayToBST(int[] nums) \n    {\n        return Helper(nums, 0, nums.Length - 1);\n    }\n\n    public TreeNode Helper(int[] nums, int left, int right) \n    {\n        if (left > right)\n        {\n            return null;\n        }\n\n        // 总是选择中间位置右边的数字作为根节点\n        int mid = (left + right + 1) / 2;\n\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = Helper(nums, left, mid - 1);\n        root.right = Helper(nums, mid + 1, right);\n        return root;\n    }\n}\n```\n\n```cpp [sol2-C++]\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        return helper(nums, 0, nums.size() - 1);\n    }\n\n    TreeNode* helper(vector<int>& nums, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n\n        // 总是选择中间位置右边的数字作为根节点\n        int mid = (left + right + 1) / 2;\n\n        TreeNode* root = new TreeNode(nums[mid]);\n        root->left = helper(nums, left, mid - 1);\n        root->right = helper(nums, mid + 1, right);\n        return root;\n    }\n};\n```\n\n```C [sol2-C]\nstruct TreeNode* helper(int* nums, int left, int right) {\n    if (left > right) {\n        return NULL;\n    }\n\n    // 总是选择中间位置右边的数字作为根节点\n    int mid = (left + right + 1) / 2;\n\n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = nums[mid];\n    root->left = helper(nums, left, mid - 1);\n    root->right = helper(nums, mid + 1, right);\n    return root;\n}\n\nstruct TreeNode* sortedArrayToBST(int* nums, int numsSize) {\n    return helper(nums, 0, numsSize - 1);\n}\n```\n\n```golang [sol2-Golang]\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    return helper(nums, 0, len(nums) - 1)\n}\n\nfunc helper(nums []int, left, right int) *TreeNode {\n    if left > right {\n        return nil\n    }\n\n    // 总是选择中间位置右边的数字作为根节点\n    mid := (left + right + 1) / 2\n    root := &TreeNode{Val: nums[mid]}\n    root.Left = helper(nums, left, mid - 1)\n    root.Right = helper(nums, mid + 1, right)\n    return root\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(n)$，其中 $n$ 是数组的长度。每个数字只访问一次。\n\n* 空间复杂度：$O(\\log n)$，其中 $n$ 是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 $O(\\log n)$。\n\n#### 方法三：中序遍历，选择任意一个中间位置数字作为根节点\n\n选择任意一个中间位置数字作为根节点，则根节点的下标为 $\\textit{mid}=(\\textit{left}+\\textit{right})/2$ 和 $\\textit{mid}=(\\textit{left}+\\textit{right}+1)/2$ 两者中随机选择一个，此处的除法为整数除法。\n\n![fig6](https://assets.leetcode-cn.com/solution-static/jindian_04.02/04.02_fig6.png){:width=\"85%\"}\n\n```Java [sol3-Java]\nclass Solution {\n    Random rand = new Random();\n\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return helper(nums, 0, nums.length - 1);\n    }\n\n    public TreeNode helper(int[] nums, int left, int right) {\n        if (left > right) {\n            return null;\n        }\n\n        // 选择任意一个中间位置数字作为根节点\n        int mid = (left + right + rand.nextInt(2)) / 2;\n\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = helper(nums, left, mid - 1);\n        root.right = helper(nums, mid + 1, right);\n        return root;\n    }\n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\n        def helper(left, right):\n            if left > right:\n                return None\n\n            # 选择任意一个中间位置数字作为根节点\n            mid = (left + right + randint(0, 1)) // 2\n\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n\n        return helper(0, len(nums) - 1)\n```\n\n```csharp [sol3-C#]\npublic class Solution \n{\n    public TreeNode SortedArrayToBST(int[] nums) \n    {\n        return Helper(nums, 0, nums.Length - 1);\n    }\n\n    public TreeNode Helper(int[] nums, int left, int right) \n    {\n        if (left > right)\n        {\n            return null;\n        }\n\n        // 选择任意一个中间位置数字作为根节点\n        int mid = (left + right + new Random().Next(2)) / 2;\n\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = Helper(nums, left, mid - 1);\n        root.right = Helper(nums, mid + 1, right);\n        return root;\n    }\n}\n```\n\n```cpp [sol3-C++]\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        return helper(nums, 0, nums.size() - 1);\n    }\n\n    TreeNode* helper(vector<int>& nums, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n\n        // 选择任意一个中间位置数字作为根节点\n        int mid = (left + right + rand() % 2) / 2;\n\n        TreeNode* root = new TreeNode(nums[mid]);\n        root->left = helper(nums, left, mid - 1);\n        root->right = helper(nums, mid + 1, right);\n        return root;\n    }\n};\n```\n\n```C [sol3-C]\nstruct TreeNode* helper(int* nums, int left, int right) {\n    if (left > right) {\n        return NULL;\n    }\n\n    // 选择任意一个中间位置数字作为根节点\n    int mid = (left + right + rand() % 2) / 2;\n\n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = nums[mid];\n    root->left = helper(nums, left, mid - 1);\n    root->right = helper(nums, mid + 1, right);\n    return root;\n}\n\nstruct TreeNode* sortedArrayToBST(int* nums, int numsSize) {\n    return helper(nums, 0, numsSize - 1);\n}\n```\n\n```golang [sol3-Golang]\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    rand.Seed(time.Now().UnixNano())\n    return helper(nums, 0, len(nums) - 1)\n}\n\nfunc helper(nums []int, left, right int) *TreeNode {\n    if left > right {\n        return nil\n    }\n\n    // 选择任意一个中间位置数字作为根节点\n    mid := (left + right + rand.Intn(2)) / 2\n    root := &TreeNode{Val: nums[mid]}\n    root.Left = helper(nums, left, mid - 1)\n    root.Right = helper(nums, mid + 1, right)\n    return root\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(n)$，其中 $n$ 是数组的长度。每个数字只访问一次。\n\n* 空间复杂度：$O(\\log n)$，其中 $n$ 是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 $O(\\log n)$。"
}