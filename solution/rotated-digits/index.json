{
	"titleSlug": "rotated-digits",
	"slug": "xuan-zhuan-shu-zi-by-leetcode-solution-q9bh",
	"url": "https://leetcode-cn.com/problems/rotated-digits/solution/xuan-zhuan-shu-zi-by-leetcode-solution-q9bh/",
	"content": "#### 方法一：枚举每一个数\n\n**思路与算法**\n\n根据题目的要求，一个数是好数，当且仅当：\n\n- 数中没有出现 $3, 4, 7$；\n\n- 数中至少出现一次 $2$ 或 $5$ 或 $6$ 或 $9$；\n\n- 对于 $0, 1, 8$ 则没有要求。\n\n因此，我们可以枚举 $[1, n]$ 的每一个正整数，并以此判断它们是否满足上述要求即可。在下面的代码中，我们用 $\\textit{valid}$ 记录数是否满足第一条要求，$\\textit{diff}$ 记录数是否满足第二条要求。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int rotatedDigits(int n) {\n        int ans = 0;\n        for (int i = 1; i <= n; ++i) {\n            string num = to_string(i);\n            bool valid = true, diff = false;\n            for (char ch: num) {\n                if (check[ch - '0'] == -1) {\n                    valid = false;\n                }\n                else if (check[ch - '0'] == 1) {\n                    diff = true;\n                }\n            }\n            if (valid && diff) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    static constexpr int check[10] = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static int[] check = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\n\n    public int rotatedDigits(int n) {\n        int ans = 0;\n        for (int i = 1; i <= n; ++i) {\n            String num = String.valueOf(i);\n            boolean valid = true, diff = false;\n            for (int j = 0; j < num.length(); ++j) {\n                char ch = num.charAt(j);\n                if (check[ch - '0'] == -1) {\n                    valid = false;\n                } else if (check[ch - '0'] == 1) {\n                    diff = true;\n                }\n            }\n            if (valid && diff) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    static int[] check = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\n\n    public int RotatedDigits(int n) {\n        int ans = 0;\n        for (int i = 1; i <= n; ++i) {\n            string num = i.ToString();\n            bool valid = true, diff = false;\n            foreach (char ch in num) {\n                if (check[ch - '0'] == -1) {\n                    valid = false;\n                } else if (check[ch - '0'] == 1) {\n                    diff = true;\n                }\n            }\n            if (valid && diff) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def rotatedDigits(self, n: int) -> int:\n        check = [0, 0, 1, -1, -1, 1, 1, -1, 0, 1]\n\n        ans = 0\n        for i in range(1, n + 1):\n            num = [int(digit) for digit in str(i)]\n            valid, diff = True, False\n            for digit in num:\n                if check[digit] == -1:\n                    valid = False\n                elif check[digit] == 1:\n                    diff = True\n            if valid and diff:\n                ans += 1\n        \n        return ans\n```\n\n```C [sol1-C]\nconst int check[10] = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\n\nint rotatedDigits(int n){\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        char num[8];\n        sprintf(num, \"%d\", i);\n        bool valid = true, diff = false;\n        for (int j = 0; num[j]; j++) {\n            if (check[num[j] - '0'] == -1) {\n                valid = false;\n            }\n            else if (check[num[j] - '0'] == 1) {\n                diff = true;\n            }\n        }\n        if (valid && diff) {\n            ++ans;\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst check = [0, 0, 1, -1, -1, 1, 1, -1, 0, 1];\nvar rotatedDigits = function(n) {\n    let ans = 0;\n    for (let i = 1; i <= n; ++i) {\n        const num = '' + i;\n        let valid = true, diff = false;\n        for (let j = 0; j < num.length; ++j) {\n            const ch = num[j];\n            if (check[ch.charCodeAt() - '0'.charCodeAt()] === -1) {\n                valid = false;\n            } else if (check[ch.charCodeAt() - '0'.charCodeAt()] === 1) {\n                diff = true;\n            }\n        }\n        if (valid && diff) {\n            ++ans;\n        }\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nvar check = [10]int{0, 0, 1, -1, -1, 1, 1, -1, 0, 1}\n\nfunc rotatedDigits(n int) (ans int) {\n    for i := 1; i <= n; i++ {\n        valid, diff := true, false\n        for _, c := range strconv.Itoa(i) {\n            if check[c-'0'] == -1 {\n                valid = false\n            } else if check[c-'0'] == 1 {\n                diff = true\n            }\n        }\n        if valid && diff {\n            ans++\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$。数 $n$ 的数位有 $\\lceil \\log_{10} n \\rceil + 1 = O(\\log n)$ 个，其中 $\\lceil \\cdot \\rceil$ 表示向上取整。因此总时间复杂度为 $O(n \\log n)$。\n\n- 空间复杂度：$O(\\log n)$。使用的空间分为两部分，第一部分为代码中记录每一个数位类型的数组 $\\textit{check}$ 需要使用的 $O(10)=O(1)$ 的空间，第二部分为将数 $i$ 转化为字符串需要使用的临时空间，大小为 $O(\\log n)$。这一部分的空间也可以优化至 $O(1)$，只需要每次将 $i$ 对 $10$ 进行取模，从低位到高位获取 $i$ 的每一个数位即可。\n\n#### 方法二：数位动态规划\n\n**思路与算法**\n\n我们也可以用数位动态规划的思路解决本题。由于在一个数之前填加前导零不会改变数本身的好坏，因此我们只需要考虑所有位数与 $n$ 相同并且小于等于 $n$ 的数（可以有前导零）即可。\n\n记 $f(\\textit{pos}, \\textit{bound}, \\textit{diff})$ 为满足如下要求的好数的个数：\n\n- 只从第 $\\textit{pos}$ 位开始考虑。这里数的最高位为第 $0$ 位，最低位为第 $\\textit{len}-1$ 位，其中 $\\textit{len}$ 是数 $n$ 的长度。在计算 $f(\\textit{pos}, \\textit{bound}, \\textit{diff})$ 时，会假设第 $0$ 位到第 $\\textit{pos}-1$ 位已经固定，并且会用 $\\textit{bound}$ 和 $\\textit{diff}$ 两个布尔变量表示这些数位的「状态」；\n\n- 从第 $0$ 位到第 $\\textit{pos}-1$ 位的数是否「贴着」$n$，记为 $\\textit{bound}$。例如当 $n=12345$，$\\textit{pos}=3$ 时，如果前面的数位是 $123$，那就表示贴着 $n$，如果是 $122, 121, \\cdots$，那就表示没有贴着 $n$。区分是否「贴着」$n$ 的作用是，如果 $\\textit{bound}$ 为真，第 $\\textit{pos}$ 位只能在 $0$ 到 $n$ 的第 $\\textit{pos}$ 位进行选择，否则构造出的数就超过 $n$ 了；如果 $\\textit{bound}$ 为假，那么第 $\\textit{pos}$ 位可以在 $0$ 到 $9$ 之间任意选择；\n\n- 从第 $0$ 位到第 $\\textit{pos}-1$ 位的数中是否至少出现了一次 $2$ 或 $5$ 或 $6$ 或 $9$，记为 $\\textit{diff}$。在进行状态转移时，我们只会枚举（第 $\\textit{pos}$ 位的数）$0/1/2/5/6/8/9$ 而不枚举 $3/4/7$，这样可以保证数一定是可以旋转的，只需要额外的状态 $\\textit{diff}$ 就能表示其是否为好数。\n\n根据上述的定义，我们需要求出的答案即为 $f(0, \\text{True}, \\text{False})$。\n\n在进行状态转移时，我们只需要枚举第 $\\textit{pos}$ 位选择的数，其可以选择的范围根据 $\\textit{bound}$ 的不同而不同（上述定义中已经详细阐述过）。我们可以写出如下的状态转移方程：\n\n$$\nf(\\textit{pos}, \\textit{bound}, \\textit{diff}) = \\sum f(\\textit{pos}+1, \\textit{bound'}, \\textit{diff'})\n$$\n\n那么如何根据选择的数，确定 $\\textit{bound'}$ 和 $\\textit{diff'}$ 呢？我们可以发现：\n\n- $\\textit{bound'}$ 为真，当且仅当 $\\textit{bound}$ 为真，并且选择的数恰好与 $n$ 的第 $\\textit{pos}$ 个数位相同；\n\n- $\\textit{diff'}$ 为真，当且仅当 $\\textit{diff}$ 为真，或者选择的数在 $2/5/6/9$ 中。\n\n动态规划的边界情况为出现在 $\\textit{pos}$ 等于 $n$ 的长度时，此时所有数位已经确定，那么我们通过 $\\textit{diff}$ 就可以知道其是否为好数：如果 $\\textit{diff}$ 为真，那么 $f(\\textit{pos}, \\textit{bound}, \\textit{diff})$ 的值为 $1$，否则为 $0$。\n\n该方法使用记忆化搜索编写代码更为方便。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int rotatedDigits(int n) {\n        vector<int> digits;\n        while (n) {\n            digits.push_back(n % 10);\n            n /= 10;\n        }\n        reverse(digits.begin(), digits.end());\n        \n        memset(memo, -1, sizeof(memo));\n        function<int(int, bool, bool)> dfs = [&](int pos, bool bound, bool diff) -> int {\n            if (pos == digits.size()) {\n                return diff;\n            }\n            if (memo[pos][bound][diff] != -1) {\n                return memo[pos][bound][diff];\n            }\n\n            int ret = 0;\n            for (int i = 0; i <= (bound ? digits[pos] : 9); ++i) {\n                if (check[i] != -1) {\n                    ret += dfs(\n                        pos + 1,\n                        bound && (i == digits[pos]),\n                        diff || (check[i] == 1)\n                    );\n                }\n            }\n            return memo[pos][bound][diff] = ret;\n        };\n        \n        int ans = dfs(0, true, false);\n        return ans;\n    }\n\nprivate:\n    static constexpr int check[10] = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\n    int memo[5][2][2];\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    static int[] check = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\n    int[][][] memo = new int[5][2][2];\n    List<Integer> digits = new ArrayList<Integer>();\n\n    public int rotatedDigits(int n) {\n        while (n != 0) {\n            digits.add(n % 10);\n            n /= 10;\n        }\n        Collections.reverse(digits);\n\n        for (int i = 0; i < 5; ++i) {\n            for (int j = 0; j < 2; ++j) {\n                Arrays.fill(memo[i][j], -1);\n            }\n        }\n\n        int ans = dfs(0, 1, 0);\n        return ans;\n    }\n\n    public int dfs(int pos, int bound, int diff) {\n        if (pos == digits.size()) {\n            return diff;\n        }\n        if (memo[pos][bound][diff] != -1) {\n            return memo[pos][bound][diff];\n        }\n\n        int ret = 0;\n        for (int i = 0; i <= (bound != 0 ? digits.get(pos) : 9); ++i) {\n            if (check[i] != -1) {\n                ret += dfs(\n                    pos + 1,\n                    bound != 0 && i == digits.get(pos) ? 1 : 0,\n                    diff != 0 || check[i] == 1 ? 1 : 0\n                );\n            }\n        }\n        return memo[pos][bound][diff] = ret;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    static int[] check = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\n    int[,,] memo = new int[5, 2, 2];\n    IList<int> digits = new List<int>();\n\n    public int RotatedDigits(int n) {\n        while (n != 0) {\n            digits.Add(n % 10);\n            n /= 10;\n        }\n        for (int i = 0, j = digits.Count - 1; i < j; ++i, --j) {\n            int temp = digits[i];\n            digits[i] = digits[j];\n            digits[j] = temp;\n        }\n\n        for (int i = 0; i < 5; ++i) {\n            for (int j = 0; j < 2; ++j) {\n                for (int k = 0; k < 2; ++k) {\n                    memo[i, j, k] = -1;\n                }\n            }\n        }\n\n        int ans = DFS(0, 1, 0);\n        return ans;\n    }\n\n    public int DFS(int pos, int bound, int diff) {\n        if (pos == digits.Count) {\n            return diff;\n        }\n        if (memo[pos, bound, diff] != -1) {\n            return memo[pos, bound, diff];\n        }\n\n        int ret = 0;\n        for (int i = 0; i <= (bound != 0 ? digits[pos] : 9); ++i) {\n            if (check[i] != -1) {\n                ret += DFS(\n                    pos + 1,\n                    bound != 0 && i == digits[pos] ? 1 : 0,\n                    diff != 0 || check[i] == 1 ? 1 : 0\n                );\n            }\n        }\n        return memo[pos, bound, diff] = ret;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def rotatedDigits(self, n: int) -> int:\n        check = [0, 0, 1, -1, -1, 1, 1, -1, 0, 1]\n        digits = [int(digit) for digit in str(n)]\n\n        @cache\n        def dfs(pos: int, bound: bool, diff: bool) -> int:\n            if pos == len(digits):\n                return int(diff)\n            \n            ret = 0\n            for i in range(0, (digits[pos] if bound else 9) + 1):\n                if check[i] != -1:\n                    ret += dfs(\n                        pos + 1,\n                        bound and i == digits[pos],\n                        diff or check[i] == 1\n                    )\n            \n            return ret\n            \n        \n        ans = dfs(0, True, False)\n        dfs.cache_clear()\n        return ans\n```\n\n```C [sol2-C]\nstatic const int check[10] = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\nint memo[5][2][2];\n\nvoid reverse(int *arr, int l, int r) {\n    while (l < r) {\n        int element = arr[l];\n        arr[l] = arr[r];\n        arr[r] = element;\n        l++, r--;\n    }\n}\n\nint dfs(int pos, bool bound, bool diff, int *digits, int digitsSize) {\n    if (pos == digitsSize) {\n        return diff;\n    }\n    if (memo[pos][bound][diff] != -1) {\n        return memo[pos][bound][diff];\n    }\n\n    int ret = 0;\n    for (int i = 0; i <= (bound ? digits[pos] : 9); ++i) {\n        if (check[i] != -1) {\n            ret += dfs(pos + 1, bound && (i == digits[pos]), diff || (check[i] == 1), digits, digitsSize);\n        }\n    }\n    return memo[pos][bound][diff] = ret;\n};\n\nint rotatedDigits(int n) {\n    int digits[8];\n    int pos = 0;\n    while (n) {\n        digits[pos++] = n % 10;\n        n /= 10;\n    }\n    reverse(digits, 0, pos - 1);    \n    memset(memo, -1, sizeof(memo));\n    return dfs(0, true, false, digits, pos);\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar rotatedDigits = function(n) {\n    const check = [0, 0, 1, -1, -1, 1, 1, -1, 0, 1];\n    const memo = new Array(5).fill(0).map(() => new Array(2).fill(0).map(() => new Array(2).fill(-1)));\n    let digits = [];\n\n    const dfs = (pos, bound, diff) => {\n        if (pos === digits.length) {\n            return diff;\n        }\n        if (memo[pos][bound][diff] !== -1) {\n            return memo[pos][bound][diff];\n        }\n\n        let ret = 0;\n        for (let i = 0; i <= (bound !== 0 ? digits[pos] : 9); ++i) {\n            if (check[i] != -1) {\n                ret += dfs(\n                    pos + 1,\n                    bound !== 0 && i === digits[pos] ? 1 : 0,\n                    diff !== 0 || check[i] === 1 ? 1 : 0\n                );\n            }\n        }\n        return memo[pos][bound][diff] = ret;\n    }\n\n    while (n !== 0) {\n        digits.push(n % 10);\n        n = Math.floor(n / 10);\n    }\n    digits = _.reverse(digits);\n\n    const ans = dfs(0, 1, 0);\n    return ans;\n};\n```\n\n```go [sol2-Golang]\nvar check = [10]int{0, 0, 1, -1, -1, 1, 1, -1, 0, 1}\n\nfunc rotatedDigits(n int) int {\n    digits := strconv.Itoa(n)\n    memo := [5][2][2]int{}\n    for i := 0; i < 5; i++ {\n        memo[i] = [2][2]int{{-1, -1}, {-1, -1}}\n    }\n    var dfs func(int, bool, bool) int\n    dfs = func(pos int, bound, diff bool) (res int) {\n        if pos == len(digits) {\n            return bool2int(diff)\n        }\n        ptr := &memo[pos][bool2int(bound)][bool2int(diff)]\n        if *ptr != -1 {\n            return *ptr\n        }\n        lim := 9\n        if bound {\n            lim = int(digits[pos] - '0')\n        }\n        for i := 0; i <= lim; i++ {\n            if check[i] != -1 {\n                res += dfs(pos+1, bound && i == int(digits[pos]-'0'), diff || check[i] == 1)\n            }\n        }\n        *ptr = res\n        return\n    }\n    return dfs(0, true, false)\n}\n\nfunc bool2int(b bool) int {\n    if b {\n        return 1\n    }\n    return 0\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$。数 $n$ 的数位有 $\\lceil \\log_{10} n \\rceil + 1 = O(\\log n)$ 个，那么动态规划的状态有 $O(\\log n \\times 2 \\times 2) = O(\\log n)$ 个，每个状态需要 $O(10) = O(1)$ 的时间进行转移，因此总时间复杂度为 $O(\\log n)$。\n\n- 空间复杂度：$O(\\log n)$，即为动态规划中存储状态需要使用的空间。"
}