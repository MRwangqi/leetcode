{
	"titleSlug": "find-players-with-zero-or-one-losses",
	"slug": "zhao-chu-shu-diao-ling-chang-huo-yi-chan-fpsj",
	"url": "https://leetcode-cn.com/problems/find-players-with-zero-or-one-losses/solution/zhao-chu-shu-diao-ling-chang-huo-yi-chan-fpsj/",
	"content": "#### 方法一：哈希表\n\n**思路与算法**\n\n我们可以用一个哈希映射记录每一名玩家输掉比赛的次数。对于哈希映射中的每一个键值对，键表示一名玩家，值表示该玩家输掉比赛的次数。\n\n这样一来，我们只需要遍历数组 $\\textit{matches}$。当我们遍历到第 $i$ 项 $(\\textit{winner}_i, \\textit{loser}_i)$ 时，如果 $\\textit{winner}_i$ 或 $\\textit{loser}_i$ 没有在哈希映射中作为键出现过，那么我们需要把他们加入哈希映射中，并且对应的值为 $0$。随后，我们需要将 $\\textit{loser}_i$ 在哈希映射中对应的值增加 $1$，表示玩家 $\\textit{loser}_i$ 输掉了一场比赛。\n\n在这之后，我们只需要再对哈希表进行一次遍历，「没有输掉任何比赛的玩家」即为所有值为 $0$ 的键，「恰好输掉一场比赛的玩家」即为所有值为 $1$ 的键。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> findWinners(vector<vector<int>>& matches) {\n        unordered_map<int, int> freq;\n        for (const auto& match: matches) {\n            int winner = match[0], loser = match[1];\n            if (!freq.count(winner)) {\n                freq[winner] = 0;\n            }\n            ++freq[loser];\n        }\n\n        vector<vector<int>> ans(2);\n        for (const auto& [key, value]: freq) {\n            if (value < 2) {\n                ans[value].push_back(key);\n            }\n        }\n\n        sort(ans[0].begin(), ans[0].end());\n        sort(ans[1].begin(), ans[1].end());\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n        freq = Counter()\n        for winner, loser in matches:\n            if winner not in freq:\n                freq[winner] = 0\n            freq[loser] += 1\n        \n        ans = [[], []]\n        for key, value in freq.items():\n            if value < 2:\n                ans[value].append(key)\n        \n        ans[0].sort()\n        ans[1].sort()\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{matches}$ 的长度。\n\n- 空间复杂度：$O(n)$，即为哈希映射需要使用的空间。"
}