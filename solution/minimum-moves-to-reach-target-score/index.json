{
	"titleSlug": "minimum-moves-to-reach-target-score",
	"slug": "de-dao-mu-biao-zhi-de-zui-shao-xing-dong-39rh",
	"url": "https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/solution/de-dao-mu-biao-zhi-de-zui-shao-xing-dong-39rh/",
	"content": "#### 方法一：反向操作 + 贪心\n\n**思路与算法**\n\n我们可以反过来考虑这个游戏：\n\n- 目标是将给定的整数 $\\textit{target}$ 变为 $1$；\n\n- 可以进行**递减**操作，将当前整数的值减 $1$；\n\n- 可以进行**折半**操作，将当前整数的值除以 $2$，前提是当前整数为偶数。\n\n上述游戏和题目描述中的游戏是等价的。但不同的是，题目描述中的游戏在每一次行动中，我们并不能知道是进行**递增**还是**加倍**操作。而在上述游戏中，如果当前整数为奇数，那么我们必须只能执行**递减**操作；如果当前整数为偶数，那么可以执行任意操作。\n\n由于我们的目标是将整数变为 $1$，因此在当前整数为偶数时，我们应当贪心地执行**折半**操作。这也是可以证明的：\n\n> 如果我们选择执行**递减**操作，那么有两种情况：\n> - 我们不断执行**递减**操作直到整数变为 $1$；\n> - 我们执行了 $k$ 次**递减**操作，随后再执行**折半**操作。\n>\n> 对于第一种情况。我们可以先执行一次**折半**操作，这样后续的**递减**操作至少会减少一次；对于第二种情况，我们可以先执行一次**折半**操作，再执行 $k/2$ 次**递减**操作，可以得到相同的结果，但操作次数减少了 $k/2$ 次。\n\n因此如果当前整数为偶数，并且还有剩余的**折半**操作次数，我们就执行**折半**操作，否则执行**递减**操作。\n\n**优化**\n\n在最坏的情况下，如果初始的**折半**操作次数为 $0$，那么我们会执行 $\\textit{target} - 1$ 次递减操作，时间复杂度为 $O(\\textit{target})$，会超出时间限制。一种可行的优化方法是，任意时刻当**折半**操作次数为 $0$ 时，剩余的操作只能为**递减操作**，我们直接返回之前使用的操作次数加上当前 $\\textit{target}$ 的值减去 $1$ 即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minMoves(int target, int maxDoubles) {\n        int ans = 0;\n        while (maxDoubles && target != 1) {\n            ++ans;\n            if (target % 2 == 1) {\n                --target;\n            }\n            else {\n                --maxDoubles;\n                target /= 2;\n            }\n        }\n        ans += (target - 1);\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minMoves(self, target: int, maxDoubles: int) -> int:\n        ans = 0\n        while maxDoubles and target != 1:\n            ans += 1\n            if target % 2 == 1:\n                target -= 1\n            else:\n                maxDoubles -= 1\n                target //= 2\n        ans += (target - 1)\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\min(\\log \\textit{target}, \\textit{maxDoubles}))$。在上述代码的循环中，每两次循环就至少会有一次**折半**操作，而 $\\textit{target}$ 最多可以被**折半** $O(\\log \\textit{target})$ 次。并且**折半**操作有次数限制，不能超过 $\\textit{maxDoubles}$，因此时间复杂度为 $O(\\min(\\log \\textit{target}, \\textit{maxDoubles}))$。\n\n- 空间复杂度：$O(1)$。"
}