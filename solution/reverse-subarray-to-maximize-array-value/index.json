{
	"titleSlug": "reverse-subarray-to-maximize-array-value",
	"slug": "chun-cui-by-bai-mu-ying-li-dra-eniac-rd49",
	"url": "https://leetcode-cn.com/problems/reverse-subarray-to-maximize-array-value/solution/chun-cui-by-bai-mu-ying-li-dra-eniac-rd49/",
	"content": "翻转子数组得到的最大的数组值\r\n\r\n本题的题意是不难理解的，首先给出了数组值的概念，就是数组中相邻两项的差值的绝对值的和，现在给一次可以翻转子数组的机会，要求得在这样的情况下能得到的最大数组值，那么这样的题目其实是很容易让我们往贪心的思路上去思考的，因为暴力二重循环枚举肯定超时，那我们就考虑能不能利用贪心的算法思路或者数学推理结论去优化复杂度，那么这个题目确实是这样优化的，那么废话少说，接下来就进入优美且纯粹的数学演绎环节。\r\n\r\n首先我们先考虑翻转的子数组在中间的情况，也就是翻转的子数组两边都有数值，这是一般的情况，结论更加普遍且直接。\r\n\r\n我们不妨记 $n$ 为原数组的长度，将数组中的元素依次记为:\r\n$$a_0,a_1,a_2,a_3,\\cdots\\cdots,a_i-_1,a_i,\\cdots\\cdots,a_j,a_j+_1,\\cdots\\cdots,a_n-_1\\\\$$\r\n其中， $a_i$ 与 $a_j$ 表示我们将选择从 $a_i$ 到 $a_j$ 这段子数组进行我们的翻转操作,很容易就能够看出来，如果我们记翻转子数组前的数组值为 $curVal$ ,用 $A、B、C、D$ 分别表示 $a_i-_1、a_i、a_j、a_j+_1$ 所对应的数组值，记翻转子数组后的数组值为 $nextVal$ ,那么根据定义，我们可以得到:\r\n$$nextVal=curVal+|D-B|+|C-A|-|D-C|-|B-A| \\tag{1}$$\r\n$(1)$ 式其实是很容易理解的，翻转子数组之后子数组中间的值并不会对最终的结果产生影响，只有边界上的四个数会产生影响，那么本题其实就是求得 $(1)$ 的最大值，我们记 $target$ 表示 $|D-B|+|C-A|-|D-C|-|B-A|$ 的值，也就是找到 $target$ 的最大值。\r\n接下来我们对 $target$进行变换研究。显而易见得，着手的关键就是去绝对值。那么我们分类讨论:\r\n$1^。：D-B>0 并且 C-A<0,target可以表示为$\r\n$$D-B-C+A-|D-C|-|B-A|\\\\$$\r\n$整理可得，$\r\n$$(D-C)-(B-A)-|D-C|-|B-A|\\tag{2}$$\r\n$观察(2)式，如果D-C>0,B-A>0,那么这个式子的值为-(B-A)-|B-A|,而B-A>0,所以导致了这个式子的结果一定是比0小的，这肯定不会作为答案的组成，因此直接排除这种情况;$\r\n$同样地，如果D-C>0,B-A<0,那么这个式子的值为0，同样不会对最优的答案产生影响；$\r\n$自然可以很轻松地得到当D-C<0,B-A>0以及D-C<0,B-A<0的情况，都会使target的值<=0，这些情况都可以直接排除。$\r\n\r\n$2^。：D-B<0 并且 C-A>0,target可以表示为$\r\n$$B-D+C-A-|D-C|-|B-A|\\\\$$\r\n$整理可得，$\r\n$$(B-A)-(D-C)-|D-C|-|B-A|\\tag{3}$$\r\n$其实和第一种情况一样的，我们简单得讨论一下，很快可以发现这种情况下的target值也是始终<=0的，可以直接排除，不可能作为最终的答案的组成。$\r\n\r\n$3^。：D-B>0 并且 C-A>0,target可以表示为$\r\n$$D-B+C-A-|D-C|-|B-A|\\\\$$\r\n$整理可得，$\r\n$$(D+C)-(B+A)-|D-C|-|B-A|\\tag{4}$$\r\n$同样地，和前面的讨论思路一样，我们讨论去掉绝对值的情况:$\r\n$若D-C>0,B-A>0,那么(4)式可整理为，$\r\n$$2C-2B\\tag{5}$$\r\n$若D-C>0,B-A<0,那么(4)式可整理为，$\r\n$$2C-2A\\tag{6}$$\r\n$若D-C<0,B-A>0,那么(4)式可整理为，$\r\n$$2D-2B\\tag{7}$$\r\n$若D-C<0,B-A<0,那么(4)式可整理为，$\r\n$$2D-2A\\tag{8}$$\r\n\r\n$4^。：D-B<0 并且 C-A<0,target可以表示为$\r\n$$B-D+A-C-|D-C|-|B-A|\\\\$$\r\n$整理可得，$\r\n$$(B+A)-(D+C)-|D-C|-|B-A|\\tag{9}$$\r\n$同样地，我们讨论去掉绝对值的情况:$\r\n$若D-C>0,B-A>0,那么(9)式可整理为，$\r\n$$2A-2D\\tag{10}$$\r\n$若D-C>0,B-A<0,那么(9)式可整理为，$\r\n$$2B-2D\\tag{11}$$\r\n$若D-C<0,B-A>0,那么(9)式可整理为，$\r\n$$2A-2C\\tag{12}$$\r\n$若D-C<0,B-A<0,那么(9)式可整理为，$\r\n$$2B-2C\\tag{13}$$\r\n\r\n至此，所有情况我们都已经讨论完毕，观察上面 $(5)(6)(7)(8)$ 和 $(10)(11)(12)(13)$ 式以及 $ABCD$ 在数组中所对应的值情况，我们可以发现，$target$ 均可以表示为:\r\n**在数组中相邻两项的较小者-相邻两项的较大者的2倍。**\r\n\r\n那么到此我们的优美的数学逻辑推理可以说算是结束了，我们要求的最大的数组值，其实就是一次遍历数组，然后得到最大化的相邻两项的较小者与相邻两项的较大者，最后乘以2加到 $curVal$上即可。但是还有一个，上述讨论是基于子数组在中间的情况，那么如果翻转的子数组有一端落在左右边界上的情况怎么办呢?很简单，特殊处理就可以了，两次一维遍历即可。最终我们通过严密的数学逻辑推理，清晰地证明了我们使用的贪心逻辑，代码自然是水到渠成、清晰明了。\r\n\r\n代码如下：（码字排版公式不易，希望你能彻底理解！😋）\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxValueAfterReverse(vector<int>& nums) {\r\n        int n=nums.size();\r\n        if(n==1)return 0;\r\n        int curVal=0;\r\n        for(int i=0;i<n-1;i++){\r\n            curVal+=abs(nums[i]-nums[i+1]);\r\n        }\r\n        int res=curVal;\r\n        //边界1:i=0\r\n        for(int j=1;j<n-1;j++){\r\n            res=max(res,curVal+abs(nums[j+1]-nums[0])-abs(nums[j+1]-nums[j]));\r\n        }\r\n        //边界2:j=n-1\r\n        for(int i=1;i<n-1;i++){\r\n            res=max(res,curVal+abs(nums[i-1]-nums[n-1])-abs(nums[i]-nums[i-1]));\r\n        }\r\n        int a=min(nums[0],nums[1]);\r\n        int b=max(nums[0],nums[1]);\r\n        for(int i=0;i<n-1;i++){\r\n            a=max(a,min(nums[i],nums[i+1]));\r\n            b=min(b,max(nums[i],nums[i+1]));\r\n        }\r\n        res=max(res,curVal+2*(a-b));\r\n        return res;\r\n    }\r\n};\r\n```\r\n"
}