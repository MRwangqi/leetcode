{
	"titleSlug": "minimum-operations-to-make-the-array-k-increasing",
	"slug": "shi-shu-zu-k-di-zeng-de-zui-shao-cao-zuo-3e62",
	"url": "https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/solution/shi-shu-zu-k-di-zeng-de-zui-shao-cao-zuo-3e62/",
	"content": "#### 方法一：动态规划\n\n**提示 $1$**\n\n题目的要求本质上是对于每一个 $i~(0 \\leq i < k)$，数组 $\\textit{arr}$ 的子序列：\n\n$$\n\\textit{arr}[i], \\textit{arr}[i + k], \\textit{arr}[i + 2k], \\cdots\n$$\n\n是单调递增的。\n\n**提示 $1$ 解释**\n\n由于 $\\textit{arr}[i - k] \\leq \\textit{arr}[i]$，它也可以写成 $\\textit{arr}[i] \\leq \\textit{arr}[i + k]$。如果我们对于 $\\textit{arr}[i + k]$ 也套用这个不等式，就可以得到 $\\textit{arr}[i + k] \\leq \\textit{arr}[i + 2k]$。以此类推，我们就可以得到：\n\n$$\n\\textit{arr}[i] \\leq \\textit{arr}[i + k] \\leq \\textit{arr}[i + 2k] \\leq \\cdots\n$$\n\n也就是说，我们将数组 $\\textit{arr}$ 中的每个元素根据其下标对 $k$ 取模的值，分成了 $k$ 个子序列（即下标对 $k$ 取模的值分别为 $0, 1, \\cdots, k-1$）。这 $k-1$ 个子序列分别都是单调递增的。\n\n**提示 $2$**\n\n对于给定的一个序列，如果我们希望通过修改最少的元素，使得它单调递增，那么最少需要修改的元素个数，就是「序列的长度」减去「序列的最长递增子序列」的长度。\n\n**提示 $2$ 解释**\n\n我们可以这样想：对于序列中那些需要被修改的元素，由于我们可以把它们修改成任意元素，因此它们修改之前的值并不重要，我们可以忽略它们。\n\n而对于序列中那些没有被修改的元素，由于最终的序列是单调递增的，因此这些没有被修改的元素组成的子序列也一定是单调递增的。要想修改的元素越少，这个子序列就要越长。因此我们的目标就是求出序列的最长递增的子序列。\n\n**思路与算法**\n\n我们对于每一个满足 $0 \\leq i < k$ 的 $i$，抽取出数组 $\\textit{arr}$ 的子序列：\n\n$$\n\\textit{arr}[i], \\textit{arr}[i + k], \\textit{arr}[i + 2k], \\cdots\n$$\n\n设其长度为 $\\textit{length}$，最长递增的子序列的长度为 $f$，那么最少需要修改的元素个数即为 $\\textit{length} - f$。\n\n最终的答案即为所有的 $\\textit{length} - f$ 之和。\n\n**细节**\n\n求解最长递增子序列可以参考[「300. 最长递增子序列」的官方题解](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)的方法二，这里不再赘述。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int kIncreasing(vector<int>& arr, int k) {\n        int n = arr.size();\n        int ans = 0;\n        for (int i = 0; i < k; ++i) {\n            vector<int> f;\n            int length = 0;\n            for (int j = i; j < n; j += k) {\n                ++length;\n                auto it = upper_bound(f.begin(), f.end(), arr[j]);\n                if (it == f.end()) {\n                    f.push_back(arr[j]);\n                }\n                else {\n                    *it = arr[j];\n                }\n            }\n            ans += length - f.size();\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def kIncreasing(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        ans = 0\n        for i in range(k):\n            f = list()\n            j, length = i, 0\n            while j < n:\n                length += 1\n                it = bisect_right(f, arr[j])\n                if it == len(f):\n                    f.append(arr[j])\n                else:\n                    f[it] = arr[j]\n                j += k\n            ans += length - len(f)\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log \\dfrac{n}{k})$。每个序列的长度为 $O(\\dfrac{n}{k})$，寻找其最长递增子序列需要的时间为 $O(\\dfrac{n}{k} \\log \\dfrac{n}{k})$，而一共有 $k$ 个序列，因此总时间复杂度为 $O(n \\log \\dfrac{n}{k})$。\n\n- 空间复杂度：$O(\\dfrac{n}{k})$，即为寻找单个序列的最长递增子序列时，数组 $f$ 需要的空间。"
}