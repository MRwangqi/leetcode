{
	"titleSlug": "permutation-ii-lcci",
	"slug": "mian-shi-ti-by-exciting-tesladmw-1w4m",
	"url": "https://leetcode-cn.com/problems/permutation-ii-lcci/solution/mian-shi-ti-by-exciting-tesladmw-1w4m/",
	"content": "# 重复字符串的排列组合\r\n\r\n**方法1：DFS+哈希表：**\r\n\r\n1. 用哈希表统计词频；\r\n2. 每次往string str里尾插一个字符，然后再次调用dfs（此时词频应该-1），直到str的长度达到原字符串的长度，将可行解添加到答案中；\r\n3. 恢复调用dfs之前删减词频的状态，即原先的词频+1，str尾删；\r\n4. 从空字符串开始调用dfs，返回记录可行解的成员vector即可。\r\n\r\n\r\n踩了的坑：\r\n1. 递归baseCase忘记恢复原状态了，即忘记pop_back()了\r\n2. 是大小写字母！！！不是小写字母\r\n\r\n**方法2：偷懒next_permutation()**\r\n\r\n对原始字符串排序后循环使用next_permutation()方法。\r\n\r\n```C++ []\r\nclass Solution {\r\npublic:\r\n    vector<string> ans;\r\n    vector<string> permutation(string S) {\r\n        map<char, int> m;\r\n        for (char ch : S) m[ch]++;\r\n        string str = \"\";\r\n        dfs(m, S.size() -1, str);\r\n        return ans;\r\n    }\r\n    \r\n    // dfs递归函数的返回值不要定义为vector，直接用一个成员vector统一存储，到达终点时添加一次\r\n    // 需要注意的是，每次调用完自身后记得把状态恢复到变更前！！！\r\n    void dfs(map<char, int> &m, int n, string& s) {\r\n        if (s.length() == n) {\r\n            for (auto [k,v] : m) {\r\n                if (v != 0) {\r\n                    s.push_back(k);\r\n                    ans.emplace_back(s);\r\n                    s.pop_back(); // 恢复\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        for (auto [k,v] : m) {\r\n            if (v > 0) {\r\n                s.push_back(k);\r\n                m[k]--;\r\n                dfs(m, n, s);\r\n                // 恢复\r\n                m[k]++;\r\n                s.pop_back();\r\n            }            \r\n        }\r\n    }\r\n};\r\n```\r\n```C++ []\r\nclass Solution {\r\npublic:\r\n    vector<string> permutation(string S) {\r\n        vector<string> ans;\r\n        sort(S.begin(), S.end());\r\n        ans.emplace_back(S);\r\n        while(next_permutation(S.begin(), S.end())) {\r\n            ans.emplace_back(S);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n菜鸡题解，仅供个人记录\r\n\r\n"
}