{
	"titleSlug": "construct-the-lexicographically-largest-valid-sequence",
	"slug": "c-hui-su-suan-fa-by-liu-xiang-3-x3fw",
	"url": "https://leetcode-cn.com/problems/construct-the-lexicographically-largest-valid-sequence/solution/c-hui-su-suan-fa-by-liu-xiang-3-x3fw/",
	"content": "### 思路\r\n1. 回溯算法, 从大数往小数递归判断;\r\n2. `1`需要特殊处理一下, `[2,9]`填入时, 将两个位置同时填入;\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> constructDistancedSequence(int n) {\r\n        vector<int> ans(2 * n - 1);\r\n        vector<bool> vis(n + 1);\r\n\r\n        function<bool(int)> dfs = [&](int idx) -> bool {\r\n            if (idx == 2 * n - 1) { /* 可以填完, 返回true */\r\n                return true;\r\n            }\r\n            if (ans[idx] != 0) {  /* 当前位置已填过, 处理下个位置 */\r\n                return dfs(idx + 1);\r\n            }\r\n            for (int j = n; j >= 1; j--) { /* 从大数开始遍历 */\r\n                if (vis[j]) {\r\n                    continue;\r\n                }\r\n                if (j == 1) { /* 当前为1, 只需填1次 */\r\n                    ans[idx] = j;\r\n                    vis[j] = true;\r\n                    if (dfs(idx + 1)) {\r\n                        return true;\r\n                    }\r\n                    ans[idx] = 0;  /* 状态回置 */\r\n                    vis[j] = false;\r\n                } else {  /* [2,9]需要同时填2个位置 */\r\n                    if (idx + j < 2 * n - 1 && ans[idx + j] == 0) {\r\n                        ans[idx] = ans[idx + j] = j;\r\n                        vis[j] = true;\r\n                        if (dfs(idx + 1)) {\r\n                            return true;\r\n                        }\r\n                        ans[idx] = ans[idx + j] = 0; /* 状态回置 */\r\n                        vis[j] = false;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        dfs(0);\r\n        return ans;\r\n    }\r\n};\r\n```\r\n"
}