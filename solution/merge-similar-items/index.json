{
	"titleSlug": "merge-similar-items",
	"slug": "mo-ni-by-endlesscheng-tz4z",
	"url": "https://leetcode-cn.com/problems/merge-similar-items/solution/mo-ni-by-endlesscheng-tz4z/",
	"content": "[视频讲解](https://www.bilibili.com/video/bv1gB4y1k7Jz) 已出炉，欢迎点赞三连，在评论区分享你对这场双周赛的看法~\r\n\r\n--- \r\n \r\n一行写法，由于每个元素都是一个长为 $2$ 的列表，所以可以直接作为键值对传入 `dict`，然后通过 `Counter` 把值加起来：\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\r\n        return sorted((Counter(dict(items1)) + Counter(dict(items2))).items())\r\n```\r\n\r\n普通写法：\r\n\r\n```go [sol2-Go]\r\nfunc mergeSimilarItems(item1 [][]int, item2 [][]int) [][]int {\r\n\tm := map[int]int{}\r\n\tfor _, p := range item1 {\r\n\t\tm[p[0]] += p[1]\r\n\t}\r\n\tfor _, p := range item2 {\r\n\t\tm[p[0]] += p[1]\r\n\t}\r\n\tans := make([][]int, 0, len(m)) // 预先申请好空间\r\n\tfor v, w := range m {\r\n\t\tans = append(ans, []int{v, w})\r\n\t}\r\n\tsort.Slice(ans, func(i, j int) bool { return ans[i][0] < ans[j][0] })\r\n\treturn ans\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O((n+m)\\log(n+m))$，其中 $n$ 为 $\\textit{items}_1$ 的长度，$m$ 为 $\\textit{items}_2$ 的长度。最坏情况下两个列表没有重复的 $\\textit{value}$，我们会对一个长为 $n+m$ 的列表排序，因此时间复杂度为 $O((n+m)\\log(n+m))$。\r\n- 空间复杂度：$O(n+m)$。\r\n"
}