{
	"titleSlug": "rotate-string",
	"slug": "xuan-zhuan-zi-fu-chuan-by-leetcode-solut-4hlp",
	"url": "https://leetcode-cn.com/problems/rotate-string/solution/xuan-zhuan-zi-fu-chuan-by-leetcode-solut-4hlp/",
	"content": "#### 方法一：模拟\n\n**思路**\n\n首先，如果 $s$ 和 $\\textit{goal}$ 的长度不一样，那么无论怎么旋转，$s$ 都不能得到 $\\textit{goal}$，返回 $\\text{false}$。在长度一样（都为 $n$）的前提下，假设 $s$ 旋转 $i$ 位，则与 $\\textit{goal}$ 中的某一位字符 $\\textit{goal}[j]$ 对应的原 $s$ 中的字符应该为 $s[(i+j) \\bmod n]$。在固定 $i$ 的情况下，遍历所有 $j$，若对应字符都相同，则返回 $\\text{true}$。否则，继续遍历其他候选的 $i$。若所有的 $i$ 都不能使 $s$ 变成 $\\textit{goal}$，则返回 $\\text{false}$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n        m, n = len(s), len(goal)\n        if m != n:\n            return False\n        for i in range(n):\n            for j in range(n):\n                if s[(i + j) % n] != goal[j]:\n                    break\n            else:\n                return True\n        return False\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean rotateString(String s, String goal) {\n        int m = s.length(), n = goal.length();\n        if (m != n) {\n            return false;\n        }\n        for (int i = 0; i < n; i++) {\n            boolean flag = true;\n            for (int j = 0; j < n; j++) {\n                if (s.charAt((i + j) % n) != goal.charAt(j)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool RotateString(string s, string goal) {\n        int m = s.Length, n = goal.Length;\n        if (m != n) {\n            return false;\n        }\n        for (int i = 0; i < n; i++) {\n            bool flag = true;\n            for (int j = 0; j < n; j++) {\n                if (s[(i + j) % n] != goal[j]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool rotateString(string s, string goal) {\n        int m = s.size(), n = goal.size();\n        if (m != n) {\n            return false;\n        }\n        for (int i = 0; i < n; i++) {\n            bool flag = true;\n            for (int j = 0; j < n; j++) {\n                if (s[(i + j) % n] != goal[j]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n```C [sol1-C]\nbool rotateString(char * s, char * goal){\n    int m = strlen(s), n = strlen(goal);\n    if (m != n) {\n        return false;\n    }\n    for (int i = 0; i < n; i++) {\n        bool flag = true;\n        for (int j = 0; j < n; j++) {\n            if (s[(i + j) % n] != goal[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar rotateString = function(s, goal) {\n    const m = s.length, n = goal.length;\n    if (m !== n) {\n        return false;\n    }\n    for (let i = 0; i < n; i++) {\n        let flag = true;\n        for (let j = 0; j < n; j++) {\n            if (s[(i + j) % n] !== goal[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            return true;\n        }\n    }\n    return false;\n};\n```\n\n```go [sol1-Golang]\nfunc rotateString(s, goal string) bool {\n    n := len(s)\n    if n != len(goal) {\n        return false\n    }\nnext:\n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            if s[(i+j)%n] != goal[j] {\n                continue next\n            }\n        }\n        return true\n    }\n    return false\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 是字符串 $s$ 的长度。我们需要双重循环来判断。\n\n- 空间复杂度：$O(1)$。仅使用常数空间。\n\n#### 方法二：搜索子字符串\n\n**思路**\n\n首先，如果 $s$ 和 $\\textit{goal}$ 的长度不一样，那么无论怎么旋转，$s$ 都不能得到 $\\textit{goal}$，返回 $\\text{false}$。字符串 $s + s$ 包含了所有 $s$ 可以通过旋转操作得到的字符串，只需要检查 $\\textit{goal}$ 是否为 $s + s$ 的子字符串即可。具体可以参考「[28. 实现 strStr() 的官方题解](https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode-solution-ds6y/)」的实现代码，本题解中采用直接调用库函数的方法。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n        return len(s) == len(goal) and goal in s + s\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean rotateString(String s, String goal) {\n        return s.length() == goal.length() && (s + s).contains(goal);\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public bool RotateString(string s, string goal) {\n        return s.Length == goal.Length && (s + s).Contains(goal);\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool rotateString(string s, string goal) {\n        return s.size() == goal.size() && (s + s).find(goal) != string::npos;\n    }\n};\n```\n\n```C [sol2-C]\nbool rotateString(char * s, char * goal){\n    int m = strlen(s), n = strlen(goal);\n    if (m != n) {\n        return false;\n    }\n    char * str = (char *)malloc(sizeof(char) * (m + n + 1));\n    sprintf(str, \"%s%s\", goal, goal);\n    return strstr(str, s) != NULL;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar rotateString = function(s, goal) {\n    return s.length === goal.length && (s + s).indexOf(goal) !== -1;\n};\n```\n\n```go [sol2-Golang]\nfunc rotateString(s, goal string) bool {\n    return len(s) == len(goal) && strings.Contains(s+s, goal)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。$\\text{KMP}$ 算法搜索子字符串的时间复杂度为 $O(n)$，其他搜索子字符串的方法会略有差异。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。$\\text{KMP}$ 算法搜索子字符串的空间复杂度为 $O(n)$，其他搜索子字符串的方法会略有差异。"
}