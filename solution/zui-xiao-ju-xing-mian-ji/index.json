{
	"titleSlug": "zui-xiao-ju-xing-mian-ji",
	"slug": "xiang-lin-liang-lie-jue-dui-bu-hui-shu-d-s95z",
	"url": "https://leetcode-cn.com/problems/zui-xiao-ju-xing-mian-ji/solution/xiang-lin-liang-lie-jue-dui-bu-hui-shu-d-s95z/",
	"content": "# 解题思路\n\n~~翻了翻比赛的时候大家的代码，感觉都好长。我虽然写了好几行废话，但感觉还是挺短的！~~\n\n首先，我们可以把问题看成是求所有交点 $x$ 和 $y$ 的最大最小值。那第一反应就是联立方程求交点，得到：$x = -\\frac{b_i - b_j}{k_i - k_j}$。但其实正负不重要，反正我们需要的是最大值和最小值的差。同理，$y$ 只需要把 $k_i$ 换成 $\\frac{1}{k_i}$ 就可以了，下面我们都以 $x$ 为例讨论。\n\n这样，问题变成了在 $k-b$ 平面上有 $n$ 个点，我们要求斜率最大和最小的一条线段。当然，正无穷的斜率是不合法的，因为平行线并不会相交。\n\n然后，通过我们仔细的观察，只有下图红线所示的这类线段才可能成为最终的答案。即按照 $k$ 分类排序后，只有**相邻两列**的**最上、最下两个顶点**之间的连线才有可能构成答案。这个可以分下面两步来证明：\n![image.png](https://pic.leetcode-cn.com/1618058771-OkrLxN-image.png)\n\n1. 答案一定出现在相邻两列中。这个可以反证，如果答案出现在不相同的两列中，例如下图中的 A 和 C 两个点。对于中间某一列上的任意一个点 B，显然 AB 和 BC 的斜率一定是一个大于等于 AC, 一个小于等于 AC，且仅在 ABC 三点共线时等号成立。所以 AC 一定不可能构成答案。\n![image.png](https://pic.leetcode-cn.com/1618059195-uaHvbC-image.png)\n\n2. 相邻两列中一定是上下两端的节点构成答案，这个很显然。\n\n综上，我们得到了一个做法，只需要按照 $(k, b)$ 将所有点排序，维护三个 pointer 表示相邻两段，就可以快速得到答案。整体的复杂度是 $O(nlogn)$。\n\n\n# 代码\n\n```cpp\nclass Solution {\npublic:\n    double minRecSize(vector<vector<int>>& f) {\n        int n = f.size();\n        vector<int> k(n, 0), b(n, 0);\n        sort(f.begin(), f.end());\n        for (int i = 0; i < n; i++) {\n            k[i] = f[i][0]; b[i] = f[i][1];\n        }\n        int p = 0, q = 0;\n        while (q < n && k[q] == k[p]) q++;\n        if (q >= n) return 0.;\n        double x_min = 1e100, x_max = -1e100;\n        double y_min = 1e100, y_max = -1e100;\n        for (; q < n;) {\n            int r = q;\n            while (r + 1 < n && k[r + 1] == k[q]) r++;\n            // [p, q - 1], [q, r]\n            double cx1 = 1.0 * (b[r] - b[p]) / (k[r] - k[p]);\n            double cx2 = 1.0 * (b[q] - b[q - 1]) / (k[q] - k[q - 1]);\n            x_min = min(x_min, min(cx1, cx2));\n            x_max = max(x_max, max(cx1, cx2));\n            double cy1 = 1.0 * (b[r] * k[p] - b[p] * k[r]) / (k[r] - k[p]);\n            double cy2 = 1.0 * (b[q] * k[q - 1] - b[q - 1] * k[q]) / (k[q] - k[q - 1]);\n            y_min = min(y_min, min(cy1, cy2));\n            y_max = max(y_max, max(cy1, cy2));\n            p = q;\n            while (q < n && k[q] == k[p]) q++;\n        }\n        return (x_max - x_min) * (y_max - y_min);\n    }\n};\n```\n"
}