{
	"titleSlug": "goat-latin",
	"slug": "shan-yang-la-ding-wen-by-leetcode-soluti-1l55",
	"url": "https://leetcode-cn.com/problems/goat-latin/solution/shan-yang-la-ding-wen-by-leetcode-soluti-1l55/",
	"content": "#### 方法一：找到每一个单词 + 模拟\n\n**思路与算法**\n\n我们可以对给定的字符串 $\\textit{sentence}$ 进行一次遍历，找出其中的每一个单词，并根据题目的要求进行操作。\n\n在寻找单词时，我们可以使用语言自带的 $\\texttt{split()}$ 函数，将空格作为分割字符，得到所有的单词。为了节省空间，我们也可以直接进行遍历：每当我们遍历到一个空格或者到达 $\\textit{sentence}$ 的末尾时，我们就找到了一个单词。\n\n当我们得到一个单词 $w$ 后，我们首先需要判断 $w$ 的首字母是否为元音字母。我们可以使用一个哈希集合 $\\textit{vowels}$ 存储所有的元音字母 $\\text{aeiouAEIOU}$，这样只需要判断 $w$ 的首字母是否在 $\\textit{vowels}$ 中。如果是元音字母，那么单词本身保持不变；如果是辅音字母，那么需要首字母移到末尾，这里使用语言自带的字符串切片函数即可。在这之后，我们需要在末尾添加 $\\text{m}$ 以及若干个 $\\text{a}$，因此可以使用一个变量 $\\textit{cnt}$ 记录需要添加的 $\\text{a}$ 的个数，它的初始值为 $1$，每当我们得到一个单词，就将它的值增加 $1$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string toGoatLatin(string sentence) {\n        unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n\n        int n = sentence.size();\n        int i = 0, cnt = 1;\n        string ans;\n\n        while (i < n) {\n            int j = i;\n            while (j < n && sentence[j] != ' ') {\n                ++j;\n            }\n\n            ++cnt;\n            if (cnt != 2) {\n                ans += ' ';\n            }\n            if (vowels.count(sentence[i])) {\n                ans += sentence.substr(i, j - i) + 'm' + string(cnt, 'a');\n            }\n            else {\n                ans += sentence.substr(i + 1, j - i - 1) + sentence[i] + 'm' + string(cnt, 'a');\n            }\n\n            i = j + 1;\n        }\n\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        Set<Character> vowels = new HashSet<Character>() {{\n            add('a');\n            add('e');\n            add('i');\n            add('o');\n            add('u');\n            add('A');\n            add('E');\n            add('I');\n            add('O');\n            add('U');\n        }};\n\n        int n = sentence.length();\n        int i = 0, cnt = 1;\n        StringBuffer ans = new StringBuffer();\n\n        while (i < n) {\n            int j = i;\n            while (j < n && sentence.charAt(j) != ' ') {\n                ++j;\n            }\n\n            ++cnt;\n            if (cnt != 2) {\n                ans.append(' ');\n            }\n            if (vowels.contains(sentence.charAt(i))) {\n                ans.append(sentence.substring(i, j));\n            } else {\n                ans.append(sentence.substring(i + 1, j));\n                ans.append(sentence.charAt(i));\n            }\n            ans.append('m');\n            for (int k = 0; k < cnt; ++k) {\n                ans.append('a');\n            }\n\n            i = j + 1;\n        }\n\n        return ans.toString();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string ToGoatLatin(string sentence) {\n        ISet<char> vowels = new HashSet<char>();\n        vowels.Add('a');\n        vowels.Add('e');\n        vowels.Add('i');\n        vowels.Add('o');\n        vowels.Add('u');\n        vowels.Add('A');\n        vowels.Add('E');\n        vowels.Add('I');\n        vowels.Add('O');\n        vowels.Add('U');\n\n        int n = sentence.Length;\n        int i = 0, cnt = 1;\n        StringBuilder ans = new StringBuilder();\n\n        while (i < n) {\n            int j = i;\n            while (j < n && sentence[j] != ' ') {\n                ++j;\n            }\n\n            ++cnt;\n            if (cnt != 2) {\n                ans.Append(' ');\n            }\n            if (vowels.Contains(sentence[i])) {\n                ans.Append(sentence.Substring(i, j - i));\n            } else {\n                ans.Append(sentence.Substring(i + 1, j - i - 1));\n                ans.Append(sentence[i]);\n            }\n            ans.Append('m');\n            for (int k = 0; k < cnt; ++k) {\n                ans.Append('a');\n            }\n\n            i = j + 1;\n        }\n\n        return ans.ToString();\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def toGoatLatin(self, sentence: str) -> str:\n        vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n\n        n = len(sentence)\n        i, cnt = 0, 1\n        words = list()\n\n        while i < n:\n            j = i\n            while j < n and sentence[j] != \" \":\n                j += 1\n            \n            cnt += 1\n            if sentence[i] in vowels:\n                words.append(sentence[i:j] + \"m\" + \"a\" * cnt)\n            else:\n                words.append(sentence[i+1:j] + sentence[i] + \"m\" + \"a\" * cnt)\n            \n            i = j + 1\n        \n        return \" \".join(words)\n\n```\n\n```JavaScript [sol1-JavaScript]\nvar toGoatLatin = function(sentence) {\n    const vowels = new Set();\n    vowels.add('a');\n    vowels.add('e');\n    vowels.add('i');\n    vowels.add('o');\n    vowels.add('u');\n    vowels.add('A');\n    vowels.add('E');\n    vowels.add('I');\n    vowels.add('O');\n    vowels.add('U');\n\n    const n = sentence.length;\n    let i = 0, cnt = 1;\n    ans = '';\n\n    while (i < n) {\n        let j = i;\n        while (j < n && sentence[j] !== ' ') {\n            ++j;\n        }\n\n        ++cnt;\n        if (cnt !== 2) {\n            ans += ' ';\n        }\n        if (vowels.has(sentence[i])) {\n            ans += sentence.substring(i, j);\n        } else {\n            ans += sentence.slice(i + 1, j);\n            ans += sentence[i];\n        }\n        ans += 'm';\n        for (let k = 0; k < cnt; ++k) {\n            ans += 'a';\n        }\n\n        i = j + 1;\n    }\n\n    return ans;\n};\n```\n\n```C [sol1-C]\n#define MAX_LATIN_LEN 2048\n\nchar * toGoatLatin(char * sentence){\n    int vowels[256];\n    memset(vowels, 0, sizeof(vowels));\n    vowels['a'] = 1;\n    vowels['e'] = 1;\n    vowels['i'] = 1;\n    vowels['o'] = 1;\n    vowels['u'] = 1;\n    vowels['A'] = 1;\n    vowels['E'] = 1;\n    vowels['I'] = 1;\n    vowels['O'] = 1;\n    vowels['U'] = 1;\n\n    int n = strlen(sentence);\n    int i = 0, cnt = 1;\n    char * ans = (char *)malloc(sizeof(char) * MAX_LATIN_LEN);\n    int pos = 0;\n\n    while (i < n) {\n        int j = i;\n        while (j < n && sentence[j] != ' ') {\n            ++j;\n        }\n\n        ++cnt;\n        if (cnt != 2) {\n            ans[pos++] = ' ';\n        }\n        if (vowels[sentence[i]]) {\n            memcpy(ans + pos, sentence + i, sizeof(char) * (j - i));\n            pos += j - i;\n            ans[pos++] = 'm';\n            memset(ans + pos, 'a', cnt);\n            pos += cnt;\n        } else {\n            memcpy(ans + pos, sentence + i + 1, sizeof(char) * (j - i - 1));\n            pos += j - i - 1;\n            ans[pos++] = sentence[i];\n            ans[pos++] = 'm';\n            memset(ans + pos, 'a', cnt);\n            pos += cnt;\n        }\n        i = j + 1;\n    }\n    ans[pos] = 0;\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nvar vowels = map[byte]struct{}{'a': {}, 'e': {}, 'i': {}, 'o': {}, 'u': {}, 'A': {}, 'E': {}, 'I': {}, 'O': {}, 'U': {}}\n\nfunc toGoatLatin(sentence string) string {\n    ans := &strings.Builder{}\n    for i, cnt, n := 0, 1, len(sentence); i < n; i++ {\n        if cnt > 1 {\n            ans.WriteByte(' ')\n        }\n        start := i\n        for i++; i < n && sentence[i] != ' '; i++ {}\n        cnt++\n        if _, ok := vowels[sentence[start]]; ok {\n            ans.WriteString(sentence[start:i])\n        } else {\n            ans.WriteString(sentence[start+1 : i])\n            ans.WriteByte(sentence[start])\n        }\n        ans.WriteByte('m')\n        ans.WriteString(strings.Repeat(\"a\", cnt))\n    }\n    return ans.String()\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 是字符串 $\\textit{sentence}$ 的长度。虽然我们对字符串只进行了常数次遍历，但是返回的字符串长度的数量级是 $O(n^2)$ 的。考虑最坏的情况，字符串 $\\textit{sentence}$ 包含 $75$ 个单词 $\\text{a}$，此时返回的字符串的长度为：\n\n    $$\n    75 + 75 + \\sum_{i=2}^{76} i + 74\n    $$\n\n    这四部分分别为：单词 $\\text{a}$ 的长度，添加的 $\\text{m}$ 的长度，添加的 $\\text{a}$ 的长度，空格的长度。\n\n- 空间复杂度：$O(n^2)$ 或 $O(n)$，取决于使用的语言的字符串是否可修改。如果可以修改，我们只需要 $O(n)$ 的空间临时存储字符串切片；如果不可以修改，我们需要 $O(n^2)$ 的空间临时存储所有单词修改后的结果。注意这里不计入返回字符串使用的空间。"
}