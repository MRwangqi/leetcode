{
	"titleSlug": "3aqs1c",
	"slug": "by-endlesscheng-fu9b",
	"url": "https://leetcode-cn.com/problems/3aqs1c/solution/by-endlesscheng-fu9b/",
	"content": "个人赛五道题目的 [视频讲解](https://www.bilibili.com/video/BV1zN4y1K762) 已出炉，欢迎点赞三连，在评论区分享你对这场比赛的看法~\r\n\r\n---\r\n\r\n数形结合更好理解，推荐先看视频哦，下面整理了视频中讲的重点。\r\n\r\n1. 画折线图，问题转换成最小化折线图中最大值与最小值的差。\r\n2. 定义 $f[i][j]$ 表示考虑 $\\textit{operate}$ 的前 $i$ 个数，其中某些数字变成负数后，折线图最右端点到折线图最下端点的纵坐标距离为 $j$ 时，折线图中最大值与最小值的差的最小值（请注意：状态定义中的 $j$ 不是坐标，是到下界的相对距离）。\r\n3. 设 $x=\\textit{operate}[i]$，分类讨论（**下面的等号表示左值和右值取 $\\min$ 后赋给左值**）：\r\n   - 取正号，折线图往上走：$f[i][j+x] = \\max(f[i-1][j],j+x)$；\r\n   - 取负号，折线图往下走，且纵坐标没有小于最下端点的纵坐标：$f[i][j-x] = f[i-1][j]$；\r\n   - 取负号，折线图往下走，且纵坐标小于最下端点的纵坐标，那么产生了一个新的最下端点，按照定义：$f[i][0] = f[i-1][j]-j+x$。\r\n4. 初始值 $f[0][0] = 0$，其余为 $+\\infty$。\r\n5. 答案为 $\\min(f[n-1])$。\r\n6. 代码实现时，用滚动数组优化空间。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def unSuitability(self, operate: List[int]) -> int:\r\n        mx = max(operate) * 2\r\n        pre = [0] + [inf] * mx\r\n        for x in operate:\r\n            f = [inf] * (mx + 1)\r\n            for j, dis in enumerate(pre):\r\n                if dis == inf: continue  # 无效的长度（无法组成）\r\n                if j + x <= mx: f[j + x] = min(f[j + x], max(dis, j + x))\r\n                if j >= x: f[j - x] = min(f[j - x], dis)\r\n                else: f[0] = min(f[0], dis - j + x)\r\n            pre = f\r\n        return min(pre)\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int unSuitability(int[] operate) {\r\n        var mx = Arrays.stream(operate).max().orElseThrow() * 2 + 1;\r\n        int[] pre = new int[mx], f = new int[mx];\r\n        Arrays.fill(pre, Integer.MAX_VALUE);\r\n        pre[0] = 0;\r\n        for (var x : operate) {\r\n            Arrays.fill(f, Integer.MAX_VALUE);\r\n            for (var j = 0; j < mx; ++j) {\r\n                var dis = pre[j];\r\n                if (dis == Integer.MAX_VALUE) continue; // 无效的长度（无法组成）\r\n                if (j + x < mx) f[j + x] = Math.min(f[j + x], Math.max(dis, j + x));\r\n                if (j >= x) f[j - x] = Math.min(f[j - x], dis);\r\n                else f[0] = Math.min(f[0], dis - j + x);\r\n            }\r\n            var tmp = pre;\r\n            pre = f;\r\n            f = tmp;\r\n        }\r\n        return Arrays.stream(pre).min().orElseThrow();\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int unSuitability(vector<int> &operate) {\r\n        int mx = *max_element(operate.begin(), operate.end()) * 2 + 1;\r\n        int pre[mx], f[mx];\r\n        memset(pre, 0x3f, sizeof(pre));\r\n        pre[0] = 0;\r\n        for (int x : operate) {\r\n            memset(f, 0x3f, sizeof(f));\r\n            for (int j = 0; j < mx; ++j) {\r\n                int dis = pre[j];\r\n                if (dis == 0x3f3f3f3f) continue; // 无效的长度（无法组成）\r\n                if (j + x < mx) f[j + x] = min(f[j + x], max(dis, j + x));\r\n                if (j >= x) f[j - x] = min(f[j - x], dis);\r\n                else f[0] = min(f[0], dis - j + x);\r\n            }\r\n            memcpy(pre, f, sizeof(f));\r\n        }\r\n        return *min_element(pre, pre + mx);\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc unSuitability(operate []int) int {\r\n\tconst inf = math.MaxInt32\r\n\tmx := 0\r\n\tfor _, x := range operate {\r\n\t\tmx = max(mx, x)\r\n\t}\r\n\tmx *= 2\r\n\tpre := make([]int, mx+1)\r\n\tfor i := range pre {\r\n\t\tpre[i] = inf\r\n\t}\r\n\tpre[0] = 0\r\n\tf := make([]int, mx+1)\r\n\tfor _, x := range operate {\r\n\t\tfor i := range f {\r\n\t\t\tf[i] = inf\r\n\t\t}\r\n\t\tfor j, dis := range pre {\r\n\t\t\tif pre[j] == inf { // 无效的长度（无法组成）\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif j+x <= mx {\r\n\t\t\t\tf[j+x] = min(f[j+x], max(dis, j+x))\r\n\t\t\t}\r\n\t\t\tif j >= x {\r\n\t\t\t\tf[j-x] = min(f[j-x], dis)\r\n\t\t\t} else {\r\n\t\t\t\tf[0] = min(f[0], dis-j+x)\r\n\t\t\t}\r\n\t\t}\r\n\t\tpre, f = f, pre\r\n\t}\r\n\tans := inf\r\n\tfor _, x := range pre {\r\n\t\tans = min(ans, x)\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc min(a, b int) int { if b < a { return b }; return a }\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(nU)$，其中 $n$ 为 $\\textit{operate}$ 的长度，$U=max(\\textit{operate})$。\r\n- 空间复杂度：$O(U)$。\r\n"
}