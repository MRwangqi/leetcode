{
	"titleSlug": "swap-adjacent-in-lr-string",
	"slug": "zai-lrzi-fu-chuan-zhong-jiao-huan-xiang-rjaw8",
	"url": "https://leetcode-cn.com/problems/swap-adjacent-in-lr-string/solution/zai-lrzi-fu-chuan-zhong-jiao-huan-xiang-rjaw8/",
	"content": "#### 方法一：双指针\n\n每次移动操作将 $\\text{``XL\"}$ 替换成 $\\text{``LX\"}$，或将 $\\text{``RX\"}$ 替换成 $\\text{``XR\"}$，等价于如下操作：\n\n- 如果一个字符 $\\text{`L'}$ 左侧的相邻字符是 $\\text{`X'}$，则将字符 $\\text{`L'}$ 向左移动一位，将其左侧的 $\\text{`X'}$ 向右移动一位；\n\n- 如果一个字符 $\\text{`R'}$ 右侧的相邻字符是 $\\text{`X'}$，则将字符 $\\text{`R'}$ 向右移动一位，将其右侧的 $\\text{`X'}$ 向左移动一位。\n\n由于每次移动操作只是交换两个相邻字符，不会增加或删除字符，因此如果可以经过一系列移动操作将 $\\textit{start}$ 转换成 $\\textit{end}$，则 $\\textit{start}$ 和 $\\textit{end}$ 满足每一种字符的数量分别相同，字符 $\\text{`L'}$ 和 $\\text{`R'}$ 的相对顺序相同，且每个 $\\text{`L'}$ 在 $\\textit{end}$ 中的下标小于等于对应的 $\\text{`L'}$ 在 $\\textit{start}$ 中的下标，以及每个 $\\text{`R'}$ 在 $\\textit{end}$ 中的下标大于等于对应的 $\\text{`R'}$ 在 $\\textit{start}$ 中的下标。\n\n因此，可以通过判断 $\\textit{start}$ 和 $\\textit{end}$ 中的所有 $\\text{`L'}$ 和 $\\text{`R'}$ 是否符合替换后的规则，判断是否可以经过一系列移动操作将 $\\textit{start}$ 转换成 $\\textit{end}$。\n\n用 $n$ 表示 $\\textit{start}$ 和 $\\textit{end}$ 的长度，用 $i$ 和 $j$ 分别表示 $\\textit{start}$ 和 $\\textit{end}$ 中的下标，从左到右遍历 $\\textit{start}$ 和 $\\textit{end}$，跳过所有的 $\\text{`X'}$，当 $i$ 和 $j$ 都小于 $n$ 时，比较非 $\\text{`X'}$ 的字符：\n\n- 如果 $\\textit{start}[i] \\ne \\textit{end}[j]$，则 $\\textit{start}$ 和 $\\textit{end}$ 中的当前字符不匹配，返回 $\\text{false}$；\n\n- 如果 $\\textit{start}[i] = \\textit{end}[j]$，则当前字符是 $\\text{`L'}$ 时应有 $i \\ge j$，当前字符是 $\\text{`R'}$ 时应有 $i \\le j$，如果当前字符与两个下标的关系不符合该规则，返回 $\\text{false}$。\n\n如果 $i$ 和 $j$ 中有一个下标大于等于 $n$，则有一个字符串已经遍历到末尾，继续遍历另一个字符串中的其余字符，如果其余字符中出现非 $\\text{`X'}$ 的字符，则该字符不能与任意字符匹配，返回 $\\text{false}$。\n\n如果 $\\textit{start}$ 和 $\\textit{end}$ 遍历结束之后没有出现不符合移动操作的情况，则可以经过一系列移动操作将 $\\textit{start}$ 转换成 $\\textit{end}$，返回 $\\text{true}$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def canTransform(self, start: str, end: str) -> bool:\n        n = len(start)\n        i = j = 0\n        while i < n and j < n:\n            while i < n and start[i] == 'X':\n                i += 1\n            while j < n and end[j] == 'X':\n                j += 1\n            if i < n and j < n:\n                if start[i] != end[j]:\n                    return False\n                c = start[i]\n                if c == 'L' and i < j or c == 'R' and i > j:\n                    return False\n                i += 1\n                j += 1\n        while i < n:\n            if start[i] != 'X':\n                return False\n            i += 1\n        while j < n:\n            if end[j] != 'X':\n                return False\n            j += 1\n        return True\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean canTransform(String start, String end) {\n        int n = start.length();\n        int i = 0, j = 0;\n        while (i < n && j < n) {\n            while (i < n && start.charAt(i) == 'X') {\n                i++;\n            }\n            while (j < n && end.charAt(j) == 'X') {\n                j++;\n            }\n            if (i < n && j < n) {\n                if (start.charAt(i) != end.charAt(j)) {\n                    return false;\n                }\n                char c = start.charAt(i);\n                if ((c == 'L' && i < j) || (c == 'R' && i > j)) {\n                    return false;\n                }\n                i++;\n                j++;\n            }\n        }\n        while (i < n) {\n            if (start.charAt(i) != 'X') {\n                return false;\n            }\n            i++;\n        }\n        while (j < n) {\n            if (end.charAt(j) != 'X') {\n                return false;\n            }\n            j++;\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool CanTransform(string start, string end) {\n        int n = start.Length;\n        int i = 0, j = 0;\n        while (i < n && j < n) {\n            while (i < n && start[i] == 'X') {\n                i++;\n            }\n            while (j < n && end[j] == 'X') {\n                j++;\n            }\n            if (i < n && j < n) {\n                if (start[i] != end[j]) {\n                    return false;\n                }\n                char c = start[i];\n                if ((c == 'L' && i < j) || (c == 'R' && i > j)) {\n                    return false;\n                }\n                i++;\n                j++;\n            }\n        }\n        while (i < n) {\n            if (start[i] != 'X') {\n                return false;\n            }\n            i++;\n        }\n        while (j < n) {\n            if (end[j] != 'X') {\n                return false;\n            }\n            j++;\n        }\n        return true;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool canTransform(string start, string end) {\n        int n = start.length();\n        int i = 0, j = 0;\n        while (i < n && j < n) {\n            while (i < n && start[i] == 'X') {\n                i++;\n            }\n            while (j < n && end[j] == 'X') {\n                j++;\n            }\n            if (i < n && j < n) {\n                if (start[i] != end[j]) {\n                    return false;\n                }\n                char c = start[i];\n                if ((c == 'L' && i < j) || (c == 'R' && i > j)) {\n                    return false;\n                }\n                i++;\n                j++;\n            }\n        }\n        while (i < n) {\n            if (start[i] != 'X') {\n                return false;\n            }\n            i++;\n        }\n        while (j < n) {\n            if (end[j] != 'X') {\n                return false;\n            }\n            j++;\n        }\n        return true;\n    }\n};\n```\n\n```C [sol1-C]\nbool canTransform(char * start, char * end) {\n    int n = strlen(start);\n    int i = 0, j = 0;\n    while (i < n && j < n) {\n        while (i < n && start[i] == 'X') {\n            i++;\n        }\n        while (j < n && end[j] == 'X') {\n            j++;\n        }\n        if (i < n && j < n) {\n            if (start[i] != end[j]) {\n                return false;\n            }\n            char c = start[i];\n            if ((c == 'L' && i < j) || (c == 'R' && i > j)) {\n                return false;\n            }\n            i++;\n            j++;\n        }\n    }\n    while (i < n) {\n        if (start[i] != 'X') {\n            return false;\n        }\n        i++;\n    }\n    while (j < n) {\n        if (end[j] != 'X') {\n            return false;\n        }\n        j++;\n    }\n    return true;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar canTransform = function(start, end) {\n    const n = start.length;\n    let i = 0, j = 0;\n    while (i < n && j < n) {\n        while (i < n && start[i] === 'X') {\n            i++;\n        }\n        while (j < n && end[j] === 'X') {\n            j++;\n        }\n        if (i < n && j < n) {\n            if (start[i] !== end[j]) {\n                return false;\n            }\n            const c = start[i];\n            if ((c === 'L' && i < j) || (c === 'R' && i > j)) {\n                return false;\n            }\n            i++;\n            j++;\n        }\n    }\n    while (i < n) {\n        if (start[i] !== 'X') {\n            return false;\n        }\n        i++;\n    }\n    while (j < n) {\n        if (end[j] !== 'X') {\n            return false;\n        }\n        j++;\n    }\n    return true;\n};\n```\n\n```go [sol1-Golang]\nfunc canTransform(start, end string) bool {\n    i, j, n := 0, 0, len(start)\n    for i < n && j < n {\n        for i < n && start[i] == 'X' {\n            i++\n        }\n        for j < n && end[j] == 'X' {\n            j++\n        }\n        if i < n && j < n {\n            if start[i] != end[j] {\n                return false\n            }\n            c := start[i]\n            if c == 'L' && i < j || c == 'R' && i > j {\n                return false\n            }\n            i++\n            j++\n        }\n    }\n    for i < n {\n        if start[i] != 'X' {\n            return false\n        }\n        i++\n    }\n    for j < n {\n        if end[j] != 'X' {\n            return false\n        }\n        j++\n    }\n    return true\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $\\textit{start}$ 和 $\\textit{end}$ 的长度。需要遍历两个字符串各一次。\n\n- 空间复杂度：$O(1)$。只需要使用常量的额外空间。"
}