{
	"titleSlug": "symmetric-tree",
	"slug": "dong-hua-yan-shi-101-dui-cheng-er-cha-shu-by-user7",
	"url": "https://leetcode-cn.com/problems/symmetric-tree/solution/dong-hua-yan-shi-101-dui-cheng-er-cha-shu-by-user7/",
	"content": "#### 递归实现\r\n乍一看无从下手，但用递归其实很好解决。   \r\n根据题目的描述，镜像对称，就是左右两边相等，也就是左子树和右子树是相当的。   \r\n注意这句话，左子树和右子相等，也就是说要递归的比较左子树和右子树。   \r\n我们将根节点的左子树记做 `left`，右子树记做 `right`。比较 `left` 是否等于 `right`，不等的话直接返回就可以了。   \r\n如果相当，比较 `left` 的左节点和 `right` 的右节点，再比较 `left` 的右节点和 `right` 的左节点   \r\n比如看下面这两个子树(他们分别是根节点的左子树和右子树)，能观察到这么一个规律：   \r\n左子树 $2$ 的左孩子 == 右子树 $2$ 的右孩子   \r\n左子树 $2$ 的右孩子 == 右子树 $2$ 的左孩子   \r\n```\r\n    2         2\r\n   / \\       / \\\r\n  3   4     4   3\r\n / \\ / \\   / \\ / \\\r\n8  7 6  5 5  6 7  8\r\n```\r\n根据上面信息可以总结出递归函数的两个条件：   \r\n终止条件：   \r\n1. `left` 和 `right` 不等，或者 `left` 和 `right` 都为空\r\n2. 递归的比较 `left`，`left` 和 `right.right`，递归比较 `left`，`right` 和 `right.left`   \r\n   \r\n动态图如下：   \r\n![2.gif](https://pic.leetcode-cn.com/2449af8862537df2cbbc45a07764415c1a10769677c822fa271ea7447c8fa128-2.gif)\r\n   \r\n算法的时间复杂度是 $O(n)$，因为要遍历 $n$ 个节点   \r\n空间复杂度是 $O(n)$，空间复杂度是递归的深度，也就是跟树高度有关，最坏情况下树变成一个链表结构，高度是$n$。   \r\n代码实现：\r\n```Java []\r\nclass Solution {\r\n\tpublic boolean isSymmetric(TreeNode root) {\r\n\t\tif(root==null) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t//调用递归函数，比较左节点，右节点\r\n\t\treturn dfs(root.left,root.right);\r\n\t}\r\n\t\r\n\tboolean dfs(TreeNode left, TreeNode right) {\r\n\t\t//递归的终止条件是两个节点都为空\r\n\t\t//或者两个节点中有一个为空\r\n\t\t//或者两个节点的值不相等\r\n\t\tif(left==null && right==null) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif(left==null || right==null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(left.val!=right.val) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t//再递归的比较 左节点的左孩子 和 右节点的右孩子\r\n\t\t//以及比较  左节点的右孩子 和 右节点的左孩子\r\n\t\treturn dfs(left.left,right.right) && dfs(left.right,right.left);\r\n\t}\r\n}\r\n```\r\n```Python []\r\nclass Solution(object):\r\n\tdef isSymmetric(self, root):\r\n\t\t\"\"\"\r\n\t\t:type root: TreeNode\r\n\t\t:rtype: bool\r\n\t\t\"\"\"\r\n\t\tif not root:\r\n\t\t\treturn True\r\n\t\tdef dfs(left,right):\r\n\t\t\t# 递归的终止条件是两个节点都为空\r\n\t\t\t# 或者两个节点中有一个为空\r\n\t\t\t# 或者两个节点的值不相等\r\n\t\t\tif not (left or right):\r\n\t\t\t\treturn True\r\n\t\t\tif not (left and right):\r\n\t\t\t\treturn False\r\n\t\t\tif left.val!=right.val:\r\n\t\t\t\treturn False\r\n\t\t\treturn dfs(left.left,right.right) and dfs(left.right,right.left)\r\n\t\t# 用递归函数，比较左节点，右节点\r\n\t\treturn dfs(root.left,root.right)\r\n```\r\n   \r\n   \r\n   \r\n#### 队列实现\r\n回想下递归的实现：   \r\n当两个子树的根节点相等时，就比较:   \r\n左子树的 `left` 和 右子树的 `right`，这个比较是用递归实现的。   \r\n现在我们改用队列来实现，思路如下：   \r\n首先从队列中拿出两个节点(`left` 和 `right`)比较\r\n将 `left` 的 `left` 节点和 `right` 的 `right` 节点放入队列   \r\n将 `left` 的 `right` 节点和 `right` 的 `left` 节点放入队列   \r\n时间复杂度是 $O(n)$，空间复杂度是 $O(n)$ \r\n动画演示如下：   \r\n![1.gif](https://pic.leetcode-cn.com/45a663b08efaa14193d63ef63ae3d1d130807467d13707f584906ad3af4adc36-1.gif)\r\n\r\n\r\n代码实现：\r\n```Java []\r\nclass Solution {\r\n\tpublic boolean isSymmetric(TreeNode root) {\r\n\t\tif(root==null || (root.left==null && root.right==null)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t//用队列保存节点\r\n\t\tLinkedList<TreeNode> queue = new LinkedList<TreeNode>();\r\n\t\t//将根节点的左右孩子放到队列中\r\n\t\tqueue.add(root.left);\r\n\t\tqueue.add(root.right);\r\n\t\twhile(queue.size()>0) {\r\n\t\t\t//从队列中取出两个节点，再比较这两个节点\r\n\t\t\tTreeNode left = queue.removeFirst();\r\n\t\t\tTreeNode right = queue.removeFirst();\r\n\t\t\t//如果两个节点都为空就继续循环，两者有一个为空就返回false\r\n\t\t\tif(left==null && right==null) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif(left==null || right==null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif(left.val!=right.val) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t//将左节点的左孩子， 右节点的右孩子放入队列\r\n\t\t\tqueue.add(left.left);\r\n\t\t\tqueue.add(right.right);\r\n\t\t\t//将左节点的右孩子，右节点的左孩子放入队列\r\n\t\t\tqueue.add(left.right);\r\n\t\t\tqueue.add(right.left);\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n```\r\n```Python []\r\nclass Solution(object):\r\n\tdef isSymmetric(self, root):\r\n\t\t\"\"\"\r\n\t\t:type root: TreeNode\r\n\t\t:rtype: bool\r\n\t\t\"\"\"\r\n\t\tif not root or not (root.left or root.right):\r\n\t\t\treturn True\r\n\t\t# 用队列保存节点\t\r\n\t\tqueue = [root.left,root.right]\r\n\t\twhile queue:\r\n\t\t\t# 从队列中取出两个节点，再比较这两个节点\r\n\t\t\tleft = queue.pop(0)\r\n\t\t\tright = queue.pop(0)\r\n\t\t\t# 如果两个节点都为空就继续循环，两者有一个为空就返回false\r\n\t\t\tif not (left or right):\r\n\t\t\t\tcontinue\r\n\t\t\tif not (left and right):\r\n\t\t\t\treturn False\r\n\t\t\tif left.val!=right.val:\r\n\t\t\t\treturn False\r\n\t\t\t# 将左节点的左孩子， 右节点的右孩子放入队列\r\n\t\t\tqueue.append(left.left)\r\n\t\t\tqueue.append(right.right)\r\n\t\t\t# 将左节点的右孩子，右节点的左孩子放入队列\r\n\t\t\tqueue.append(left.right)\r\n\t\t\tqueue.append(right.left)\r\n\t\treturn True\r\n```\r\n"
}