{
	"titleSlug": "kskhHQ",
	"slug": "jiantu-by-endlesscheng-rkra",
	"url": "https://leetcode-cn.com/problems/kskhHQ/solution/jiantu-by-endlesscheng-rkra/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1rT411P7NA) 已出炉，欢迎点赞三连，在评论区分享你对这场力扣杯的看法~\r\n\r\n记录关键思路，详细的说明见视频讲解。\r\n\r\n1. 判断能否容纳水：第 $i$ 行的水，在不走到第 $i-1$ 行的前提下，无法触及左、右、下边界。\r\n2. 转换成连通性问题，用并查集处理。\r\n3. 为了方便判断是否触及边界，还需要在左、右、下各加一条格子。\r\n4. 根据 1，我们可以从最后一行往上计算。\r\n5. 用并查集合并当前行各个区域，以及边界。\r\n6. 如果合并完了，枚举当前行的各个区域，如果不和边界相连，那么该区域能容纳水。\r\n7. 边界、最上面一层和超级汇点 $0$ 相连。\r\n8. 最后判断的时候，如果该区域能容纳水，且和超级汇点相连，那么不是闭合区域，就真的有水。\r\n9. 统计真的有水的格子，即为答案。\r\n10. 代码实现时，把每个格子划分四个区域，相对两个区域，代码写起来要容易一些。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def reservoir(self, shape: List[str]) -> int:\r\n        n, m = len(shape), len(shape[0])\r\n        # 每个格子分成四个区域（上下左右），标上序号，方便用并查集连通\r\n        # 假设左右下还有一圈格子，直接连到超级汇点 0\r\n        u = [[0] * (m + 2) for _ in range(n + 1)]\r\n        d = [[0] * (m + 2) for _ in range(n + 1)]\r\n        l = [[0] * (m + 2) for _ in range(n + 1)]\r\n        r = [[0] * (m + 2) for _ in range(n + 1)]\r\n        c = 1\r\n        for i in range(n):\r\n            for j in range(1, m + 1):  # 假设格子的列号从 1 开始，这样方便表示左右边界\r\n                u[i][j] = c; c += 1\r\n                d[i][j] = c; c += 1\r\n                l[i][j] = c; c += 1\r\n                r[i][j] = c; c += 1\r\n\r\n        # 并查集模板\r\n        fa = list(range(c))\r\n        def find(x: int) -> int:\r\n            if fa[x] != x:\r\n                fa[x] = find(fa[x])\r\n            return fa[x]\r\n        def merge(x: int, y: int):\r\n            fa[find(x)] = find(y)\r\n\r\n        ok = [False] * c  # 能否容纳水\r\n        # 倒着判断每一行，寻找可能有水的区域\r\n        for i in range(n - 1, -1, -1):\r\n            for j in range(m + 1):\r\n                merge(r[i][j], l[i][j + 1])  # 连通左右\r\n            for j, type in enumerate(shape[i], 1):\r\n                merge(d[i][j], u[i + 1][j])  # 连通下\r\n                # 根据格子的类型连接格子内部四个区域\r\n                if type == '.':\r\n                    merge(l[i][j], u[i][j])\r\n                    merge(l[i][j], d[i][j])\r\n                    merge(l[i][j], r[i][j])\r\n                elif type == 'l':\r\n                    merge(l[i][j], d[i][j])\r\n                    merge(r[i][j], u[i][j])\r\n                else:\r\n                    merge(l[i][j], u[i][j])\r\n                    merge(r[i][j], d[i][j])\r\n            for j in range(1, m + 1):\r\n                # 在没有连接第 i-1 行的情况下，无法到达左右下边界 => 能容纳水\r\n                ok[l[i][j]] = find(l[i][j]) != find(0)\r\n                ok[r[i][j]] = find(r[i][j]) != find(0)\r\n                ok[u[i][j]] = find(u[i][j]) != find(0)\r\n                ok[d[i][j]] = find(d[i][j]) != find(0)\r\n\r\n        # 第一行连上超级汇点，方便后面统一判断是否在闭合区域里面\r\n        for j in range(1, m + 1):\r\n            merge(u[0][j], 0)\r\n\r\n        ans = 0\r\n        for i, b in enumerate(ok):\r\n            if b and find(i) == find(0):  # 能容纳水，且不在闭合区域里面\r\n                ans += 1\r\n        return ans // 2\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    private int[] fa;\r\n\r\n    public int reservoir(String[] shape) {\r\n        int n = shape.length, m = shape[0].length(), c = 1;\r\n        // 每个格子分成四个区域（上下左右），标上序号，方便用并查集连通\r\n        // 假设左右下还有一圈格子，直接连到超级汇点 0\r\n        int[][] u = new int[n + 1][m + 2], d = new int[n + 1][m + 2], l = new int[n + 1][m + 2], r = new int[n + 1][m + 2];\r\n        for (var i = 0; i < n; ++i)\r\n            for (var j = 1; j <= m; ++j) {  // 假设格子的列号从 1 开始，这样方便表示左右边界\r\n                u[i][j] = c++;\r\n                d[i][j] = c++;\r\n                l[i][j] = c++;\r\n                r[i][j] = c++;\r\n            }\r\n\r\n        fa = new int[c];\r\n        for (var i = 0; i < c; i++) fa[i] = i;\r\n\r\n        var ok = new boolean[c]; // 能否容纳水\r\n        // 倒着判断每一行，寻找可能有水的区域\r\n        for (var i = n - 1; i >= 0; --i) {\r\n            for (var j = 0; j <= m; j++)\r\n                merge(r[i][j], l[i][j + 1]); // 连通左右\r\n            for (var j = 1; j <= m; j++) {\r\n                merge(d[i][j], u[i + 1][j]); // 连通下\r\n                // 根据格子的类型连接格子内部四个区域\r\n                var type = shape[i].charAt(j - 1);\r\n                if (type == '.') {\r\n                    merge(l[i][j], u[i][j]);\r\n                    merge(l[i][j], d[i][j]);\r\n                    merge(l[i][j], r[i][j]);\r\n                } else if (type == 'l') {\r\n                    merge(l[i][j], d[i][j]);\r\n                    merge(r[i][j], u[i][j]);\r\n                } else {\r\n                    merge(l[i][j], u[i][j]);\r\n                    merge(r[i][j], d[i][j]);\r\n                }\r\n            }\r\n            for (var j = 1; j <= m; j++) {\r\n                // 在没有连接第 i-1 行的情况下，无法到达左右下边界 => 能容纳水\r\n                ok[l[i][j]] = find(l[i][j]) != find(0);\r\n                ok[r[i][j]] = find(r[i][j]) != find(0);\r\n                ok[u[i][j]] = find(u[i][j]) != find(0);\r\n                ok[d[i][j]] = find(d[i][j]) != find(0);\r\n            }\r\n        }\r\n\r\n        // 第一行连上超级汇点，方便后面统一判断是否在闭合区域里面\r\n        for (var j = 1; j <= m; j++)\r\n            merge(u[0][j], 0);\r\n\r\n        var ans = 0;\r\n        for (var i = 0; i < c; i++)\r\n            if (ok[i] && find(i) == find(0))\r\n                ++ans; // 能容纳水，且不在闭合区域里面\r\n        return ans / 2;\r\n    }\r\n\r\n    private int find(int x) {\r\n        if (fa[x] != x) fa[x] = find(fa[x]);\r\n        return fa[x];\r\n    }\r\n\r\n    private void merge(int x, int y) {\r\n        fa[find(x)] = find(y);\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int reservoir(vector<string> &shape) {\r\n        int n = shape.size(), m = shape[0].size(), c = 1;\r\n        // 每个格子分成四个区域（上下左右），标上序号，方便用并查集连通\r\n        // 假设左右下还有一圈格子，直接连到超级汇点 0\r\n        int u[n + 1][m + 2], d[n + 1][m + 2], l[n + 1][m + 2], r[n + 1][m + 2];\r\n        memset(u, 0, sizeof(u)); memset(d, 0, sizeof(d)); memset(l, 0, sizeof(l)); memset(r, 0, sizeof(r));\r\n        for (int i = 0; i < n; ++i)\r\n            for (int j = 1; j <= m; ++j) // 假设格子的列号从 1 开始，这样方便表示左右边界\r\n                u[i][j] = c++, d[i][j] = c++, l[i][j] = c++, r[i][j] = c++;\r\n\r\n        // 并查集模板\r\n        int fa[c];\r\n        iota(fa, fa + c, 0);\r\n        function<int(int)> find = [&](int x) -> int { return fa[x] == x ? x : fa[x] = find(fa[x]); };\r\n        auto merge = [&](int x, int y) { fa[find(x)] = find(y); };\r\n\r\n        bool ok[c]; // 能否容纳水\r\n        memset(ok, 0, sizeof(ok));\r\n        // 倒着判断每一行，寻找可能有水的区域\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            for (int j = 0; j <= m; j++) merge(r[i][j], l[i][j + 1]); // 连通左右\r\n            for (int j = 1; j <= m; j++) {\r\n                merge(d[i][j], u[i + 1][j]); // 连通下\r\n                // 根据格子的类型连接格子内部四个区域\r\n                if (shape[i][j - 1] == '.') merge(l[i][j], u[i][j]), merge(l[i][j], d[i][j]), merge(l[i][j], r[i][j]);\r\n                else if (shape[i][j - 1] == 'l') merge(l[i][j], d[i][j]), merge(r[i][j], u[i][j]);\r\n                else merge(l[i][j], u[i][j]), merge(r[i][j], d[i][j]);\r\n            }\r\n            for (int j = 1; j <= m; j++) {\r\n                // 在没有连接第 i-1 行的情况下，无法到达左右下边界 => 能容纳水\r\n                ok[l[i][j]] = find(l[i][j]) != find(0);\r\n                ok[r[i][j]] = find(r[i][j]) != find(0);\r\n                ok[u[i][j]] = find(u[i][j]) != find(0);\r\n                ok[d[i][j]] = find(d[i][j]) != find(0);\r\n            }\r\n        }\r\n\r\n        // 第一行连上超级汇点，方便后面统一判断是否在闭合区域里面\r\n        for (int j = 1; j <= m; j++) merge(u[0][j], 0);\r\n\r\n        int ans = 0;\r\n        for (int i = 0; i < c; i++)\r\n            ans += ok[i] && find(i) == find(0); // 能容纳水，且不在闭合区域里面\r\n        return ans / 2;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc reservoir(shape []string) int {\r\n\tn, m := len(shape), len(shape[0])\r\n\t// 每个格子分成四个区域（上下左右），标上序号，方便用并查集连通\r\n\t// 假设左右下还有一圈格子，直接连到超级汇点 0\r\n\tu := make([][]int, n+1)\r\n\td := make([][]int, n+1)\r\n\tl := make([][]int, n+1)\r\n\tr := make([][]int, n+1)\r\n\tfor i := range u {\r\n\t\tu[i] = make([]int, m+2)\r\n\t\td[i] = make([]int, m+2)\r\n\t\tl[i] = make([]int, m+2)\r\n\t\tr[i] = make([]int, m+2)\r\n\t}\r\n\tc := 1\r\n\tfor i := 0; i < n; i++ {\r\n\t\tfor j := 1; j <= m; j++ { // 假设格子的列号从 1 开始，这样方便表示左右边界\r\n\t\t\tu[i][j] = c; c++\r\n\t\t\td[i][j] = c; c++\r\n\t\t\tl[i][j] = c; c++\r\n\t\t\tr[i][j] = c; c++\r\n\t\t}\r\n\t}\r\n\r\n\t// 并查集模板\r\n\tfa := make([]int, c)\r\n\tfor i := range fa {\r\n\t\tfa[i] = i\r\n\t}\r\n\tvar find func(int) int\r\n\tfind = func(x int) int {\r\n\t\tif fa[x] != x {\r\n\t\t\tfa[x] = find(fa[x])\r\n\t\t}\r\n\t\treturn fa[x]\r\n\t}\r\n\tmerge := func(x, y int) { fa[find(x)] = find(y) }\r\n\r\n\tok := make([]bool, c) // 能否容纳水\r\n\t// 倒着判断每一行，寻找可能有水的区域\r\n\tfor i := n - 1; i >= 0; i-- {\r\n\t\tfor j := 0; j <= m; j++ {\r\n\t\t\tmerge(r[i][j], l[i][j+1]) // 连通左右\r\n\t\t}\r\n\t\tfor j := 1; j <= m; j++ {\r\n\t\t\tmerge(d[i][j], u[i+1][j]) // 连通下\r\n\t\t\t// 根据格子的类型连接格子内部四个区域\r\n\t\t\tswitch shape[i][j-1] {\r\n\t\t\tcase '.':\r\n\t\t\t\tmerge(l[i][j], u[i][j])\r\n\t\t\t\tmerge(l[i][j], d[i][j])\r\n\t\t\t\tmerge(l[i][j], r[i][j])\r\n\t\t\tcase 'l':\r\n\t\t\t\tmerge(l[i][j], d[i][j])\r\n\t\t\t\tmerge(r[i][j], u[i][j])\r\n\t\t\tdefault:\r\n\t\t\t\tmerge(l[i][j], u[i][j])\r\n\t\t\t\tmerge(r[i][j], d[i][j])\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor j := 1; j <= m; j++ {\r\n\t\t\t// 在没有连接第 i-1 行的情况下，无法到达左右下边界 => 能容纳水\r\n\t\t\tok[l[i][j]] = find(l[i][j]) != find(0)\r\n\t\t\tok[r[i][j]] = find(r[i][j]) != find(0)\r\n\t\t\tok[u[i][j]] = find(u[i][j]) != find(0)\r\n\t\t\tok[d[i][j]] = find(d[i][j]) != find(0)\r\n\t\t}\r\n\t}\r\n\r\n\t// 第一行连上超级汇点，方便后面统一判断是否在闭合区域里面\r\n\tfor j := 1; j <= m; j++ {\r\n\t\tmerge(u[0][j], 0)\r\n\t}\r\n\r\n\tans := 0\r\n\tfor i, b := range ok {\r\n\t\tif b && find(i) == find(0) { // 能容纳水，且不在闭合区域里面\r\n\t\t\tans++\r\n\t\t}\r\n\t}\r\n\treturn ans / 2\r\n}\r\n```\r\n"
}