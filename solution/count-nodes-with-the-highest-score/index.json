{
	"titleSlug": "count-nodes-with-the-highest-score",
	"slug": "tong-ji-zui-gao-fen-de-jie-dian-shu-mu-b-n810",
	"url": "https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/solution/tong-ji-zui-gao-fen-de-jie-dian-shu-mu-b-n810/",
	"content": "#### 方法一：深度优先搜索\n\n**思路**\n\n在一棵树中，当把一个节点和与它相连的所有边删除，剩余部分最多为三棵非空子树，即原节点的左子树（如果有），右子树（如果有），以及把以这个节点为根结点的子树移除所形成的子树（除根结点外均有）。而这个节点的分数为这些子树的节点个数的乘积。我们可以先用 $\\textit{parents}$ 数组统计出每个节点的子节点，然后使用深度优先搜索来计算以每个节点为根结点的子树的大小，同时计算每个节点的大小，作为深度优先搜索的返回值，最后统计最大分数出现的次数。在实现上，统计最大分数出现的次数可以放到深度优先搜索中完成，从而节省一部分空间。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\n        n = len(parents)\n        children = [[] for _ in range(n)]\n        for node, p in enumerate(parents):\n            if p != -1:\n                children[p].append(node)\n\n        maxScore, cnt = 0, 0\n        def dfs(node: int) -> int:\n            score = 1\n            size = n - 1\n            for ch in children[node]:\n                sz = dfs(ch)\n                score *= sz\n                size -= sz\n            if node != 0:\n                score *= size\n            nonlocal maxScore, cnt\n            if score == maxScore:\n                cnt += 1\n            elif score > maxScore:\n                maxScore, cnt = score, 1\n            return n - size\n        dfs(0)\n        return cnt\n```\n\n```Java [sol1-Java]\nclass Solution {\n    long maxScore = 0;\n    int cnt = 0;\n    int n;\n    List<Integer>[] children;\n\n    public int countHighestScoreNodes(int[] parents) {\n        n = parents.length;\n        children = new List[n];\n        for (int i = 0; i < n; i++) {\n            children[i] = new ArrayList<Integer>();\n        }\n        for (int i = 0; i < n; i++) {\n            int p = parents[i];\n            if (p != -1) {\n                children[p].add(i);\n            }\n        }\n        dfs(0);\n        return cnt;\n    }\n\n    public int dfs(int node) {\n        long score = 1;\n        int size = n - 1;\n        for (int c : children[node]) {\n            int t = dfs(c);\n            score *= t;\n            size -= t;\n        }\n        if (node != 0) {\n            score *= size;\n        }\n        if (score == maxScore) {\n            cnt++;\n        } else if (score > maxScore) {\n            maxScore = score;\n            cnt = 1;\n        }\n        return n - size;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    long maxScore = 0;\n    int cnt = 0;\n    int n;\n    IList<int>[] children;\n\n    public int CountHighestScoreNodes(int[] parents) {\n        n = parents.Length;\n        children = new IList<int>[n];\n        for (int i = 0; i < n; i++) {\n            children[i] = new List<int>();\n        }\n        for (int i = 0; i < n; i++) {\n            int p = parents[i];\n            if (p != -1) {\n                children[p].Add(i);\n            }\n        }\n        DFS(0);\n        return cnt;\n    }\n\n    public int DFS(int node) {\n        long score = 1;\n        int size = n - 1;\n        foreach (int c in children[node]) {\n            int t = DFS(c);\n            score *= t;\n            size -= t;\n        }\n        if (node != 0) {\n            score *= size;\n        }\n        if (score == maxScore) {\n            cnt++;\n        } else if (score > maxScore) {\n            maxScore = score;\n            cnt = 1;\n        }\n        return n - size;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    long maxScore = 0;\n    int cnt = 0;\n    int n;\n    vector<vector<int>> children;\n\n    int dfs(int node) {\n        long score = 1;\n        int size = n - 1;\n        for (int c : children[node]) {\n            int t = dfs(c);\n            score *= t;\n            size -= t;\n        }\n        if (node != 0) {\n            score *= size;\n        }\n        if (score == maxScore) {\n            cnt++;\n        } else if (score > maxScore) {\n            maxScore = score;\n            cnt = 1;\n        }\n        return n - size;\n    }\n\n    int countHighestScoreNodes(vector<int>& parents) {\n        this->n = parents.size();\n        this->children = vector<vector<int>>(n);\n        for (int i = 0; i < n; i++) {\n            int p = parents[i];\n            if (p != -1) {\n                children[p].emplace_back(i);\n            }\n        }\n        dfs(0);\n        return cnt;\n    }\n};\n```\n\n```C [sol1-C]\nint dfs(int node, long * maxScore, int * cnt, int n, const struct ListNode ** children) {\n    long score = 1;\n    int size = n - 1;\n    for (struct ListNode * curr = children[node]; curr; curr = curr->next) {\n        int t = dfs(curr->val, maxScore, cnt, n, children);\n        score *= t;\n        size -= t;\n    }\n    if (node != 0) {\n        score *= size;\n    }\n    if (score == *maxScore) {\n        (*cnt)++;\n    } else if (score > *maxScore) {\n        *maxScore = score;\n        *cnt = 1;\n    }\n    return n - size;\n}\n\nint countHighestScoreNodes(int* parents, int parentsSize){\n    int n = parentsSize;\n    int cnt = 0;\n    long maxScore = 0;\n    struct ListNode ** children = (struct ListNode **)malloc(sizeof(struct ListNode *) * n);\n    for (int i = 0; i < n; i++) {\n        children[i] = NULL;\n    }\n    for (int i = 0; i < n; i++) {\n        int p = parents[i];\n        if (p != -1) {\n            struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode));\n            node->val = i;\n            node->next = children[p];\n            children[p] = node;\n        }\n    }\n    dfs(0, &maxScore, &cnt, n, children);\n    for (int i = 0; i < n; i++) {\n        for (struct ListNode * curr = children[i]; curr; ) {\n            struct ListNode * next = curr->next;\n            free(curr);\n            curr = next;\n        }\n    }\n    free(children);\n    return cnt;\n}\n```\n\n```go [sol1-Golang]\nfunc countHighestScoreNodes(parents []int) (ans int) {\n    n := len(parents)\n    children := make([][]int, n)\n    for node := 1; node < n; node++ {\n        p := parents[node]\n        children[p] = append(children[p], node)\n    }\n\n    maxScore := 0\n    var dfs func(int) int\n    dfs = func(node int) int {\n        score, size := 1, n-1\n        for _, ch := range children[node] {\n            sz := dfs(ch)\n            score *= sz\n            size -= sz\n        }\n        if node > 0 {\n            score *= size\n        }\n        if score == maxScore {\n            ans++\n        } else if score > maxScore {\n            maxScore = score\n            ans = 1\n        }\n        return n - size\n    }\n    dfs(0)\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar countHighestScoreNodes = function(parents) {\n    const n = parents.length;\n    const children = new Array(n).fill(0);\n    let maxScore = 0;\n    let cnt = 0;\n    for (let i = 0; i < n; i++) {\n        children[i] = [];\n    }\n    for (let i = 0; i < n; i++) {\n        const p = parents[i];\n        if (p !== -1) {\n            children[p].push(i);\n        }\n    }\n\n    const dfs = (node) => {\n        let score = 1;\n        let size = n - 1;\n        for (const c of children[node]) {\n            let t = dfs(c);\n            score *= t;\n            size -= t;\n        }\n        if (node !== 0) {\n            score *= size;\n        }\n        if (score === maxScore) {\n            cnt++;\n        } else if (score > maxScore) {\n            maxScore = score;\n            cnt = 1;\n        }\n        return n - size;\n    }\n\n    dfs(0);\n    return cnt;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是树的节点数。预处理，深度优先搜索均消耗 $O(n)$ 时间。\n\n- 空间复杂度：$O(n)$。统计每个节点的子节点消耗 $O(n)$ 空间，深度优先搜索的深度最多为 $O(n)$ 空间。"
}