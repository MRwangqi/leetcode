{
	"titleSlug": "where-will-the-ball-fall",
	"slug": "qiu-hui-luo-he-chu-by-leetcode-solution-xqop",
	"url": "https://leetcode-cn.com/problems/where-will-the-ball-fall/solution/qiu-hui-luo-he-chu-by-leetcode-solution-xqop/",
	"content": "#### 方法一：模拟\n\n**思路**\n\n我们依次判断每个球的最终位置。对于每个球，从上至下判断球位置的移动方向。在对应的位置，如果挡板向右偏，则球会往右移动；如果挡板往左偏，则球会往左移动。若移动过程中碰到侧边或者 $\\text{V}$ 型，则球会停止移动，卡在箱子里。如果可以完成本层的移动，则继续判断下一层的移动方向，直到落出箱子或者卡住。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findBall(self, grid: List[List[int]]) -> List[int]:\n        n = len(grid[0])\n        ans = [-1] * n\n        for j in range(n):\n            col = j  # 球的初始列\n            for row in grid:\n                dir = row[col]\n                col += dir  # 移动球\n                if col < 0 or col == n or row[col] != dir:  # 到达侧边或 V 形\n                    break\n            else:  # 成功到达底部\n                ans[j] = col\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> findBall(vector<vector<int>> &grid) {\n        int n = grid[0].size();\n        vector<int> ans(n);\n        for (int j = 0; j < n; ++j) {\n            int col = j; // 球的初始列\n            for (auto &row : grid) {\n                int dir = row[col];\n                col += dir; // 移动球\n                if (col < 0 || col == n || row[col] != dir) { // 到达侧边或 V 形\n                    col = -1;\n                    break;\n                }\n            }\n            ans[j] = col; // col >= 0 为成功到达底部\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] findBall(int[][] grid) {\n        int n = grid[0].length;\n        int[] ans = new int[n];\n        for (int j = 0; j < n; j++) {\n            int col = j;  // 球的初始列\n            for (int[] row : grid) {\n                int dir = row[col];\n                col += dir;  // 移动球\n                if (col < 0 || col == n || row[col] != dir) {  // 到达侧边或 V 形\n                    col = -1;\n                    break;\n                }\n            }\n            ans[j] = col;  // col >= 0 为成功到达底部\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] FindBall(int[][] grid) {\n        int n = grid[0].Length;\n        int[] ans = new int[n];\n        for (int j = 0; j < n; j++) {\n            int col = j;  // 球的初始列\n            foreach (int[] row in grid) {\n                int dir = row[col];\n                col += dir;  // 移动球\n                if (col < 0 || col == n || row[col] != dir) {  // 到达侧边或 V 形\n                    col = -1;\n                    break;\n                }\n            }\n            ans[j] = col;  // col >= 0 为成功到达底部\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc findBall(grid [][]int) []int {\n    n := len(grid[0])\n    ans := make([]int, n)\n    for j := range ans {\n        col := j // 球的初始列\n        for _, row := range grid {\n            dir := row[col]\n            col += dir // 移动球\n            if col < 0 || col == n || row[col] != dir { // 到达侧边或 V 形\n                col = -1\n                break\n            }\n        }\n        ans[j] = col // col >= 0 为成功到达底部\n    }\n    return ans\n}\n```\n\n```C [sol1-C]\nint* findBall(int** grid, int gridSize, int* gridColSize, int* returnSize) {\n    int n = gridColSize[0];\n    int * ans = (int *)malloc(sizeof(int) * n);\n    for (int j = 0; j < n; ++j) {\n        int col = j; // 球的初始列\n        for (int i = 0; i < gridSize; i++) {\n            int dir = grid[i][col];\n            col += dir; // 移动球\n            if (col < 0 || col == n || grid[i][col] != dir) { // 到达侧边或 V 形\n                col = -1;\n                break;\n            }\n        }\n        ans[j] = col; // col >= 0 为成功到达底部\n    }\n    *returnSize = n; \n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findBall = function(grid) {\n    const n = grid[0].length;\n    const ans = new Array(n);\n    for (let j = 0; j < n; j++) {\n        let col = j; // 球的初始列\n        for (const row of grid) {\n            const dir = row[col];\n            col += dir; // 移动球\n            if (col < 0 || col === n || row[col] !== dir) { // 到达侧边或 V 形\n                col = -1;\n                break;\n            }\n        }\n        ans[j] = col;  // col >= 0 为成功到达底部\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m \\times n)$，其中 $m$ 和 $n$ 是网格的行数和列数。外循环消耗 $O(n)$，内循环消耗 $O(m)$。\n\n- 空间复杂度：$O(1)$。返回值不计入空间。"
}