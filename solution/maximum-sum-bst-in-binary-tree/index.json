{
	"titleSlug": "maximum-sum-bst-in-binary-tree",
	"slug": "by-wrt_-e163",
	"url": "https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/solution/by-wrt_-e163/",
	"content": "![image.png](https://pic.leetcode-cn.com/1662781020-IFzPqt-image.png)\n\n### 解题思路\nTalk is cheap, show you the code.🐶\n\n### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int ans = 0;\n    const int INF = -1e9;\n    int maxSumBST(TreeNode* root) {\n        dfs(root);\n        return ans;\n    }\n\n    // 是二叉搜索树返回非负数，即其键值和，否则返回 INF\n    int dfs(TreeNode* root) {\n        if (!root) return 0;\n\n        int l = dfs(root->left), r = dfs(root->right);\n        if (l == INF || r == INF) return INF;  // 左右子树存在非二叉树，自身一定是非二叉树\n\n        TreeNode *front = root->left;  // 中序遍历中 root 的前驱节点\n        while (front && front->right) front = front->right;\n        TreeNode *behind = root->right;  // 后继节点\n        while (behind && behind->left) behind = behind->left;\n        if (front && front->val >= root->val) return INF;  // 左子树为二叉树，但是其键值大于本节点值\n        if (behind && behind->val <= root->val) return INF;\n\n        ans = max(ans, l + r + root->val);\n        return l + r + root->val;\n    }\n};\n```"
}