{
	"titleSlug": "maximum-sum-bst-in-binary-tree",
	"slug": "by-wrt_-e163",
	"url": "https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/solution/by-wrt_-e163/",
	"content": "![image.png](https://pic.leetcode-cn.com/1662781020-IFzPqt-image.png)\n\n### è§£é¢˜æ€è·¯\nTalk is cheap, show you the code.ðŸ¶\n\n### ä»£ç \n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int ans = 0;\n    const int INF = -1e9;\n    int maxSumBST(TreeNode* root) {\n        dfs(root);\n        return ans;\n    }\n\n    // æ˜¯äºŒå‰æœç´¢æ ‘è¿”å›žéžè´Ÿæ•°ï¼Œå³å…¶é”®å€¼å’Œï¼Œå¦åˆ™è¿”å›ž INF\n    int dfs(TreeNode* root) {\n        if (!root) return 0;\n\n        int l = dfs(root->left), r = dfs(root->right);\n        if (l == INF || r == INF) return INF;  // å·¦å³å­æ ‘å­˜åœ¨éžäºŒå‰æ ‘ï¼Œè‡ªèº«ä¸€å®šæ˜¯éžäºŒå‰æ ‘\n\n        TreeNode *front = root->left;  // ä¸­åºéåŽ†ä¸­ root çš„å‰é©±èŠ‚ç‚¹\n        while (front && front->right) front = front->right;\n        TreeNode *behind = root->right;  // åŽç»§èŠ‚ç‚¹\n        while (behind && behind->left) behind = behind->left;\n        if (front && front->val >= root->val) return INF;  // å·¦å­æ ‘ä¸ºäºŒå‰æ ‘ï¼Œä½†æ˜¯å…¶é”®å€¼å¤§äºŽæœ¬èŠ‚ç‚¹å€¼\n        if (behind && behind->val <= root->val) return INF;\n\n        ans = max(ans, l + r + root->val);\n        return l + r + root->val;\n    }\n};\n```"
}