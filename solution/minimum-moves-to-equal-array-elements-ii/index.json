{
	"titleSlug": "minimum-moves-to-equal-array-elements-ii",
	"slug": "zui-shao-yi-dong-ci-shu-shi-shu-zu-yuan-xt3r2",
	"url": "https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/solution/zui-shao-yi-dong-ci-shu-shi-shu-zu-yuan-xt3r2/",
	"content": "#### 方法一：排序\n\n假设数组元素都变成 $x$ 时，所需的移动数最少，那么 $x$ 需要满足什么性质呢？\n\n为了简化讨论，我们先假定数组长度 $n$ 是偶数。我们将数组 $\\textit{nums}$ 从小到大进行排序，然后将数组进行首尾配对，从而划分为多个数对，并将这些数对组成区间：\n$$[\\textit{nums}_0, \\textit{nums}_{n-1}], [\\textit{nums}_1, \\textit{nums}_{n-2}], ...,[\\textit{nums}_{\\frac{n}{2} - 1}, \\textit{nums}_{\\frac{n}{2}}]$$\n\n当 $x$ 同时位于以上区间内时，所需的移动数最少，总移动数为 $\\sum_{i=0}^{\\frac{n}{2} - 1} (\\textit{nums}_{n-1-i} - \\textit{nums}_i)$。\n\n> 证明：对于某一个区间 $[\\textit{nums}_i, \\textit{nums}_{n - 1 -i}]$，该区间对应的数对所需要的移动数为 $|\\textit{nums}_{n - 1 - i} - x| + |\\textit{nums}_i - x| \\ge |\\textit{nums}_{n - 1 - i} - x - (\\textit{nums}_i - x)| = \\textit{nums}_{n - 1 - i} - \\textit{nums}_i$，当且仅当 $x \\in [\\textit{nums}_i, \\textit{nums}_{n - 1 -i}]$ 时，等号成立。\n\n在上述区间中，后一个区间是前一个区间的子集，因此只要 $x \\in [\\textit{nums}_{\\frac{n}{2} - 1}, \\textit{nums}_{\\frac{n}{2}}]$，就满足要求。当 $n$ 为奇数时，我们将排序后的数组中间的元素 $\\textit{nums}_{\\lfloor \\frac{n}{2} \\rfloor}$ 当成区间 $[\\textit{nums}_{\\lfloor \\frac{n}{2} \\rfloor}, \\textit{nums}_{\\lfloor \\frac{n}{2} \\rfloor}]$ 看待，则 $x \\in [\\textit{nums}_{\\lfloor \\frac{n}{2} \\rfloor}, \\textit{nums}_{\\lfloor \\frac{n}{2} \\rfloor}]$ 即 $x = \\textit{nums}_{\\lfloor \\frac{n}{2} \\rfloor}$时，所需的移动数最少。\n\n综上所述，所有元素都变成 $\\textit{nums}_{\\lfloor \\frac{n}{2} \\rfloor}$ 时，所需的移动数最少。\n\n```Python [sol1-Python3]\nclass Solution:\n    def minMoves2(self, nums: List[int]) -> int:\n        nums.sort()\n        return sum(abs(num - nums[len(nums) // 2]) for num in nums)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minMoves2(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), ret = 0, x = nums[n / 2];\n        for (int i = 0; i < n; i++) {\n            ret += abs(nums[i] - x);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minMoves2(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length, ret = 0, x = nums[n / 2];\n        for (int i = 0; i < n; i++) {\n            ret += Math.abs(nums[i] - x);\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinMoves2(int[] nums) {\n        Array.Sort(nums);\n        int n = nums.Length, ret = 0, x = nums[n / 2];\n        for (int i = 0; i < n; i++) {\n            ret += Math.Abs(nums[i] - x);\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol1-C]\nint cmp(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint minMoves2(int* nums, int numsSize){\n    qsort(nums, numsSize, sizeof(int), cmp);\n    int ret = 0, x = nums[numsSize / 2];\n    for (int i = 0; i < numsSize; i++) {\n        ret += abs(nums[i] - x);\n    }\n    return ret;\n}\n```\n\n```go [sol1-Golang]\nfunc minMoves2(nums []int) (ans int) {\n    sort.Ints(nums)\n    x := nums[len(nums)/2]\n    for _, num := range nums {\n        ans += abs(num - x)\n    }\n    return\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minMoves2 = function(nums) {\n    nums.sort((a, b) => a - b);\n    let n = nums.length, ret = 0, x = nums[Math.floor(n / 2)];\n    for (let i = 0; i < n; i++) {\n        ret += Math.abs(nums[i] - x);\n    }\n    return ret;\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。排序需要 $O(n \\log n)$ 的时间。\n\n+ 空间复杂度：$O(\\log n)$。排序需要 $O(\\log n)$ 的递归栈空间。\n\n#### 方法二：快速选择\n\n根据方法一的推导，$x$ 取数组 $\\textit{nums}$ 第 $\\lfloor \\frac{n}{2} \\rfloor$ 小元素（从 $0$ 开始计数）时，所需要的移动数最少。\n\n求解数组第 $k$ 小元素可以使用快速选择算法，具体算法推导可以参考「[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/)」。\n\n```Python [sol2-Python3]\nclass Helper:\n    @staticmethod\n    def partition(nums: List[int], l: int, r: int) -> int:\n        pivot = nums[r]\n        i = l - 1\n        for j in range(l, r):\n            if nums[j] <= pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1], nums[r] = nums[r], nums[i + 1]\n        return i + 1\n\n    @staticmethod\n    def randomPartition(nums: List[int], l: int, r: int) -> int:\n        i = randint(l, r)\n        nums[r], nums[i] = nums[i], nums[r]\n        return Helper.partition(nums, l, r)\n\n    @staticmethod\n    def quickSelected(nums: List[int], l: int, r: int, k: int) -> int:\n        index = Helper.randomPartition(nums, l, r)\n        if k == index:\n            return nums[k]\n        if k < index:\n            return Helper.quickSelected(nums, l, index - 1, k)\n        return Helper.quickSelected(nums, index + 1, r, k)\n\nclass Solution:\n    def minMoves2(self, nums: List[int]) -> int:\n        seed(time())\n        x = Helper.quickSelected(nums, 0, len(nums) - 1, len(nums) // 2)\n        return sum(abs(num - x) for num in nums)\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int quickSelect(vector<int>& nums, int left, int right, int index) {\n        int q = randomPartition(nums, left, right);\n        if (q == index) {\n            return nums[q];\n        } else {\n            return q < index ? quickSelect(nums, q + 1, right, index) : quickSelect(nums, left, q - 1, index);\n        }\n    }\n\n    inline int randomPartition(vector<int>& nums, int left, int right) {\n        int i = rand() % (right - left + 1) + left;\n        swap(nums[i], nums[right]);\n        return partition(nums, left, right);\n    }\n\n    inline int partition(vector<int>& nums, int left, int right) {\n        int x = nums[right], i = left - 1;\n        for (int j = left; j < right; ++j) {\n            if (nums[j] <= x) {\n                swap(nums[++i], nums[j]);\n            }\n        }\n        swap(nums[i + 1], nums[right]);\n        return i + 1;\n    }\n\n    int minMoves2(vector<int>& nums) {\n        srand(time(0));\n        int n = nums.size(), x = quickSelect(nums, 0, n - 1, n / 2), ret = 0;\n        for (int i = 0; i < n; ++i) {\n            ret += abs(nums[i] - x);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    Random random = new Random();\n\n    public int minMoves2(int[] nums) {\n        int n = nums.length, x = quickSelect(nums, 0, n - 1, n / 2), ret = 0;\n        for (int i = 0; i < n; ++i) {\n            ret += Math.abs(nums[i] - x);\n        }\n        return ret;\n    }\n\n    public int quickSelect(int[] nums, int left, int right, int index) {\n        int q = randomPartition(nums, left, right);\n        if (q == index) {\n            return nums[q];\n        } else {\n            return q < index ? quickSelect(nums, q + 1, right, index) : quickSelect(nums, left, q - 1, index);\n        }\n    }\n\n    public int randomPartition(int[] nums, int left, int right) {\n        int i = random.nextInt(right - left + 1) + left;\n        swap(nums, i, right);\n        return partition(nums, left, right);\n    }\n\n    public int partition(int[] nums, int left, int right) {\n        int x = nums[right], i = left - 1;\n        for (int j = left; j < right; ++j) {\n            if (nums[j] <= x) {\n                ++i;\n                swap(nums, i, j);\n            }\n        }\n        swap(nums, i + 1, right);\n        return i + 1;\n    }\n\n    public void swap(int[] nums, int index1, int index2) {\n        int temp = nums[index1];\n        nums[index1] = nums[index2];\n        nums[index2] = temp;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    Random random = new Random();\n\n    public int MinMoves2(int[] nums) {\n        int n = nums.Length, x = QuickSelect(nums, 0, n - 1, n / 2), ret = 0;\n        for (int i = 0; i < n; ++i) {\n            ret += Math.Abs(nums[i] - x);\n        }\n        return ret;\n    }\n\n    public int QuickSelect(int[] nums, int left, int right, int index) {\n        int q = RandomPartition(nums, left, right);\n        if (q == index) {\n            return nums[q];\n        } else {\n            return q < index ? QuickSelect(nums, q + 1, right, index) : QuickSelect(nums, left, q - 1, index);\n        }\n    }\n\n    public int RandomPartition(int[] nums, int left, int right) {\n        int i = random.Next(right - left + 1) + left;\n        Swap(nums, i, right);\n        return partition(nums, left, right);\n    }\n\n    public int partition(int[] nums, int left, int right) {\n        int x = nums[right], i = left - 1;\n        for (int j = left; j < right; ++j) {\n            if (nums[j] <= x) {\n                ++i;\n                Swap(nums, i, j);\n            }\n        }\n        Swap(nums, i + 1, right);\n        return i + 1;\n    }\n\n    public void Swap(int[] nums, int index1, int index2) {\n        int temp = nums[index1];\n        nums[index1] = nums[index2];\n        nums[index2] = temp;\n    }\n}\n```\n\n```C [sol2-C]\nstatic inline void swap(int *a, int *b) {\n    int c = *a;\n    *a = *b;\n    *b = c;\n}\n\nstatic inline int partition(int *nums, int left, int right) {\n    int x = nums[right], i = left - 1;\n    for (int j = left; j < right; ++j) {\n        if (nums[j] <= x) {\n            swap(&nums[++i], &nums[j]);\n        }\n    }\n    swap(&nums[i + 1], &nums[right]);\n    return i + 1;\n}\n\nstatic inline int randomPartition(int *nums, int left, int right) {\n    int i = rand() % (right - left + 1) + left;\n    swap(&nums[i], &nums[right]);\n    return partition(nums, left, right);\n}\n\nstatic int quickSelect(int *nums, int left, int right, int index) {\n    int q = randomPartition(nums, left, right);\n    if (q == index) {\n        return nums[q];\n    } else {\n        return q < index ? quickSelect(nums, q + 1, right, index) : quickSelect(nums, left, q - 1, index);\n    }\n}\n\nint minMoves2(int* nums, int numsSize){\n    srand(time(0));\n    int n = numsSize, x = quickSelect(nums, 0, n - 1, n / 2), ret = 0;\n    for (int i = 0; i < n; ++i) {\n        ret += abs(nums[i] - x);\n    }\n    return ret;\n}\n```\n\n```go [sol2-Golang]\nfunc partition(a []int, l, r int) int {\n    x := a[r]\n    i := l - 1\n    for j := l; j < r; j++ {\n        if a[j] <= x {\n            i++\n            a[i], a[j] = a[j], a[i]\n        }\n    }\n    a[i+1], a[r] = a[r], a[i+1]\n    return i + 1\n}\n\nfunc randomPartition(a []int, l, r int) int {\n    i := rand.Intn(r-l+1) + l\n    a[i], a[r] = a[r], a[i]\n    return partition(a, l, r)\n}\n\nfunc quickSelect(a []int, l, r, index int) int {\n    q := randomPartition(a, l, r)\n    if q == index {\n        return a[q]\n    }\n    if q < index {\n        return quickSelect(a, q+1, r, index)\n    }\n    return quickSelect(a, l, q-1, index)\n}\n\nfunc minMoves2(nums []int) (ans int) {\n    rand.Seed(time.Now().UnixNano())\n    x := quickSelect(nums, 0, len(nums)-1, len(nums)/2)\n    for _, num := range nums {\n        ans += abs(num - x)\n    }\n    return\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar minMoves2 = function(nums) {\n    let n = nums.length, x = quickSelect(nums, 0, n - 1, Math.floor(n / 2)), ret = 0;\n    for (let i = 0; i < n; ++i) {\n        ret += Math.abs(nums[i] - x);\n    }\n    return ret;\n}\n\nconst quickSelect = (nums, left, right, index) => {\n    const q = randomPartition(nums, left, right);\n    if (q === index) {\n        return nums[q];\n    } else {\n        return q < index ? quickSelect(nums, q + 1, right, index) : quickSelect(nums, left, q - 1, index);\n    }\n}\n\nconst randomPartition = (nums, left, right) => {\n    const i = Math.floor(Math.random() * (right - left + 1)) + left;\n    swap(nums, i, right);\n    return partition(nums, left, right);\n}\n\nconst partition = (nums, left, right) => {\n    let x = nums[right], i = left - 1;\n    for (let j = left; j < right; ++j) {\n        if (nums[j] <= x) {\n            ++i;\n            swap(nums, i, j);\n        }\n    }\n    swap(nums, i + 1, right);\n    return i + 1;\n}\n\nconst swap = (nums, index1, index2) => {\n    const temp = nums[index1];\n    nums[index1] = nums[index2];\n    nums[index2] = temp;\n}\n```\n\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。快速选择算法的平均时间复杂度为 $O(n)$。\n\n+ 空间复杂度：$O(\\log n)$。递归栈的平均占用空间为 $O(\\log n)$。"
}