{
	"titleSlug": "number-of-submatrices-that-sum-to-target",
	"slug": "yuan-su-he-wei-mu-biao-zhi-de-zi-ju-zhen-8ym2",
	"url": "https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/solution/yuan-su-he-wei-mu-biao-zhi-de-zi-ju-zhen-8ym2/",
	"content": "#### æ–¹æ³•ä¸€ï¼šå‰ç¼€å’Œ + å“ˆå¸Œè¡¨\n\næˆ‘ä»¬æšä¸¾å­çŸ©é˜µçš„ä¸Šä¸‹è¾¹ç•Œï¼Œå¹¶è®¡ç®—å‡ºè¯¥è¾¹ç•Œå†…æ¯åˆ—çš„å…ƒç´ å’Œï¼Œåˆ™åŸé—®é¢˜è½¬æ¢æˆäº†å¦‚ä¸‹ä¸€ç»´é—®é¢˜ï¼š\n\n> ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œä¸€ä¸ªæ•´æ•° $\\textit{target}$ï¼Œè®¡ç®—è¯¥æ•°ç»„ä¸­å­æ•°ç»„å’Œç­‰äº $\\textit{target}$ çš„å­æ•°ç»„ä¸ªæ•°ã€‚\n\nåŠ›æ‰£ä¸Šå·²æœ‰è¯¥é—®é¢˜ï¼š[560. å’Œä¸ºKçš„å­æ•°ç»„](https://leetcode-cn.com/problems/subarray-sum-equals-k/)ï¼Œè¯»è€…å¯ä»¥å‚è€ƒå…¶[å®˜æ–¹é¢˜è§£](https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/)ï¼Œå¹¶æŒæ¡ä½¿ç”¨å‰ç¼€å’Œ+å“ˆå¸Œè¡¨çš„çº¿æ€§åšæ³•ã€‚\n\nå¯¹äºæ¯åˆ—çš„å…ƒç´ å’Œ $\\textit{sum}$ çš„è®¡ç®—ï¼Œæˆ‘ä»¬åœ¨æšä¸¾å­çŸ©é˜µä¸Šè¾¹ç•Œ $i$ æ—¶ï¼Œåˆå§‹ä¸‹è¾¹ç•Œ $j$ ä¸º $i$ï¼Œæ­¤æ—¶ $\\textit{sum}$ å°±æ˜¯çŸ©é˜µç¬¬ $i$ è¡Œçš„å…ƒç´ ã€‚æ¯æ¬¡å‘ä¸‹å»¶é•¿ä¸‹è¾¹ç•Œ $j$ æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†çŸ©é˜µç¬¬ $j$ è¡Œçš„å…ƒç´ ç´¯åŠ åˆ° $\\textit{sum}$ ä¸­ã€‚\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    int subarraySum(vector<int> &nums, int k) {\n        unordered_map<int, int> mp;\n        mp[0] = 1;\n        int count = 0, pre = 0;\n        for (auto &x:nums) {\n            pre += x;\n            if (mp.find(pre - k) != mp.end()) {\n                count += mp[pre - k];\n            }\n            mp[pre]++;\n        }\n        return count;\n    }\n\npublic:\n    int numSubmatrixSumTarget(vector<vector<int>> &matrix, int target) {\n        int ans = 0;\n        int m = matrix.size(), n = matrix[0].size();\n        for (int i = 0; i < m; ++i) { // æšä¸¾ä¸Šè¾¹ç•Œ\n            vector<int> sum(n);\n            for (int j = i; j < m; ++j) { // æšä¸¾ä¸‹è¾¹ç•Œ\n                for (int c = 0; c < n; ++c) {\n                    sum[c] += matrix[j][c]; // æ›´æ–°æ¯åˆ—çš„å…ƒç´ å’Œ\n                }\n                ans += subarraySum(sum, target);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\n        int ans = 0;\n        int m = matrix.length, n = matrix[0].length;\n        for (int i = 0; i < m; ++i) { // æšä¸¾ä¸Šè¾¹ç•Œ\n            int[] sum = new int[n];\n            for (int j = i; j < m; ++j) { // æšä¸¾ä¸‹è¾¹ç•Œ\n                for (int c = 0; c < n; ++c) {\n                    sum[c] += matrix[j][c]; // æ›´æ–°æ¯åˆ—çš„å…ƒç´ å’Œ\n                }\n                ans += subarraySum(sum, target);\n            }\n        }\n        return ans;\n    }\n\n    public int subarraySum(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        map.put(0, 1);\n        int count = 0, pre = 0;\n        for (int x : nums) {\n            pre += x;\n            if (map.containsKey(pre - k)) {\n                count += map.get(pre - k);\n            }\n            map.put(pre, map.getOrDefault(pre, 0) + 1);\n        }\n        return count;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\n\n        int ans = 0;\n        int m = matrix.Length, n = matrix[0].Length;\n        for (int i = 0; i < m; ++i) { // æšä¸¾ä¸Šè¾¹ç•Œ\n            int[] sum = new int[n];\n            for (int j = i; j < m; ++j) { // æšä¸¾ä¸‹è¾¹ç•Œ\n                for (int c = 0; c < n; ++c) {\n                    sum[c] += matrix[j][c]; // æ›´æ–°æ¯åˆ—çš„å…ƒç´ å’Œ\n                }\n                ans += SubarraySum(sum, target);\n            }\n        }\n        return ans;\n    }\n\n    public int SubarraySum(int[] nums, int k) {\n        Dictionary<int, int> dictionary = new Dictionary<int, int>();\n        dictionary.Add(0, 1);\n        int count = 0, pre = 0;\n        foreach (int x in nums) {\n            pre += x;\n            if (dictionary.ContainsKey(pre - k)) {\n                count += dictionary[pre - k];\n            }\n            if (!dictionary.ContainsKey(pre)) {\n                dictionary.Add(pre, 1);\n            } else {\n                ++dictionary[pre];\n            }\n        }\n        return count;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc subarraySum(nums []int, k int) (ans int) {\n    mp := map[int]int{0: 1}\n    for i, pre := 0, 0; i < len(nums); i++ {\n        pre += nums[i]\n        if _, ok := mp[pre-k]; ok {\n            ans += mp[pre-k]\n        }\n        mp[pre]++\n    }\n    return\n}\n\nfunc numSubmatrixSumTarget(matrix [][]int, target int) (ans int) {\n    for i := range matrix { // æšä¸¾ä¸Šè¾¹ç•Œ\n        sum := make([]int, len(matrix[0]))\n        for _, row := range matrix[i:] { // æšä¸¾ä¸‹è¾¹ç•Œ\n            for c, v := range row {\n                sum[c] += v // æ›´æ–°æ¯åˆ—çš„å…ƒç´ å’Œ\n            }\n            ans += subarraySum(sum, target)\n        }\n    }\n    return\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\n        def subarraySum(nums: List[int], k: int) -> int:\n            mp = Counter([0])\n            count = pre = 0\n            for x in nums:\n                pre += x\n                if pre - k in mp:\n                    count += mp[pre - k]\n                mp[pre] += 1\n            return count\n        \n        m, n = len(matrix), len(matrix[0])\n        ans = 0\n        # æšä¸¾ä¸Šè¾¹ç•Œ\n        for i in range(m):\n            total = [0] * n\n            # æšä¸¾ä¸‹è¾¹ç•Œ\n            for j in range(i, m):\n                for c in range(n):\n                    # æ›´æ–°æ¯åˆ—çš„å…ƒç´ å’Œ\n                    total[c] += matrix[j][c]\n                ans += subarraySum(total, target)\n        \n        return ans\n```\n\n```C [sol1-C]\nstruct HashTable {\n    int key, val;\n    UT_hash_handle hh;\n};\n\nint subarraySum(int* nums, int numsSize, int k) {\n    struct HashTable* hashTable = NULL;\n    struct HashTable* tmp = malloc(sizeof(struct HashTable));\n    tmp->key = 0, tmp->val = 1;\n    HASH_ADD_INT(hashTable, key, tmp);\n    int count = 0, pre = 0;\n    for (int i = 0; i < numsSize; i++) {\n        pre += nums[i];\n        int x = pre - k;\n        HASH_FIND_INT(hashTable, &x, tmp);\n        if (tmp != NULL) {\n            count += tmp->val;\n        }\n        HASH_FIND_INT(hashTable, &pre, tmp);\n        if (tmp != NULL) {\n            tmp->val++;\n        } else {\n            tmp = malloc(sizeof(struct HashTable));\n            tmp->key = pre, tmp->val = 1;\n            HASH_ADD_INT(hashTable, key, tmp);\n        }\n    }\n    return count;\n}\n\nint numSubmatrixSumTarget(int** matrix, int matrixSize, int* matrixColSize, int target) {\n    int ans = 0;\n    int m = matrixSize, n = matrixColSize[0];\n    for (int i = 0; i < m; ++i) {  // æšä¸¾ä¸Šè¾¹ç•Œ\n        int sum[n];\n        memset(sum, 0, sizeof(sum));\n        for (int j = i; j < m; ++j) {  // æšä¸¾ä¸‹è¾¹ç•Œ\n            for (int c = 0; c < n; ++c) {\n                sum[c] += matrix[j][c];  // æ›´æ–°æ¯åˆ—çš„å…ƒç´ å’Œ\n            }\n            ans += subarraySum(sum, n, target);\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar numSubmatrixSumTarget = function(matrix, target) {\n    let ans = 0;\n    const m = matrix.length, n = matrix[0].length;\n    for (let i = 0; i < m; ++i) { // æšä¸¾ä¸Šè¾¹ç•Œ\n        const sum = new Array(n).fill(0);\n        for (let j = i; j < m; ++j) { // æšä¸¾ä¸‹è¾¹ç•Œ\n            for (let c = 0; c < n; ++c) {\n                sum[c] += matrix[j][c]; // æ›´æ–°æ¯åˆ—çš„å…ƒç´ å’Œ\n            }\n            ans += subarraySum(sum, target);\n        }\n    }\n    return ans;\n}\n\nconst subarraySum = (nums, k) => {\n    const map = new Map();\n    map.set(0, 1);\n    let count = 0, pre = 0;\n    for (const x of nums) {\n        pre += x;\n        if (map.has(pre - k)) {\n            count += map.get(pre - k);\n        }\n        map.set(pre, (map.get(pre) || 0) + 1);\n    }\n    return count;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(m^2\\cdot n)$ã€‚å…¶ä¸­ $m$ å’Œ $n$ åˆ†åˆ«æ˜¯çŸ©é˜µ $\\textit{matrix}$ çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ã€‚\n\n**ä¼˜åŒ–**\n\nè‹¥è¡Œæ•°å¤§äºåˆ—æ•°ï¼Œæšä¸¾çŸ©å½¢çš„å·¦å³è¾¹ç•Œæ›´ä¼˜ï¼Œå¯¹åº”çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2\\cdot m)$ã€‚\n\næ€»ä¹‹ï¼Œæ ¹æ® $m$ å’Œ $n$ çš„å¤§å°æ¥ç»†åŒ–æšä¸¾ç­–ç•¥ï¼Œæˆ‘ä»¬å¯ä»¥åšåˆ° $O(\\min(m,n)^2\\cdot\\max(m,n))$ çš„æ—¶é—´å¤æ‚åº¦ã€‚\n\n---\n## âœ¨æ‰£å‹å¸®å¸®å›¢ - äº’åŠ¨ç­”ç–‘\n\n[![è®¨è®º.jpg](https://pic.leetcode-cn.com/1621178600-MKHFrl-%E8%AE%A8%E8%AE%BA.jpg){:width=260px}](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)\n\n\nå³æ—¥èµ· - 5 æœˆ 30 æ—¥ï¼Œç‚¹å‡»Â [è¿™é‡Œ](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)Â å‰å¾€ã€Œ[æ‰£å‹å¸®å¸®å›¢](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)ã€æ´»åŠ¨é¡µï¼ŒæŠŠä½ é‡åˆ°çš„é—®é¢˜å¤§èƒ†åœ°æå‡ºæ¥ï¼Œè®©æ‰£å‹ä¸ºä½ è§£ç­”ï½\n\n### ğŸ å¥–åŠ±è§„åˆ™\nè¢«é‡‡çº³æ•°é‡æ’å 1ï½3 åï¼šã€ŒåŠ›æ‰£æå®¢å¥—è£…ã€ *1 å¹¶å°†è·å¾—ã€ŒåŠ›æ‰£ç¥ç§˜åº”æ´å›¢ã€å†…æµ‹èµ„æ ¼\nè¢«é‡‡çº³æ•°é‡æ’å 4ï½10 åï¼šã€ŒåŠ›æ‰£é¼ æ ‡å«ã€ *1 å¹¶å°†è·å¾—ã€ŒåŠ›æ‰£ç¥ç§˜åº”æ´å›¢ã€å†…æµ‹èµ„æ ¼\nã€Œè¯²äººä¸å€¦ã€ï¼šæ´»åŠ¨æœŸé—´ã€Œè§£æƒ‘è€…ã€åªè¦æœ‰ 1 ä¸ªå›ç­”è¢«é‡‡çº³ï¼Œå³å¯è·å¾— 20 LeetCoins å¥–åŠ±ï¼\nã€Œæ±‚çŸ¥è‹¥æ¸´ã€ï¼šæ´»åŠ¨æœŸé—´ã€Œæ±‚çŸ¥è€…ã€åœ¨æ´»åŠ¨é¡µå‘èµ·ä¸€æ¬¡ç¬¦åˆè¦æ±‚çš„ç–‘é—®å¸–å¹¶è‡³å°‘é‡‡çº³ä¸€æ¬¡ã€Œè§£æƒ‘è€…ã€çš„å›ç­”ï¼Œå³å¯è·å¾— 20 LeetCoins å¥–åŠ±ï¼\n\næ´»åŠ¨è¯¦æƒ…çŒ›æˆ³é“¾æ¥äº†è§£æ›´å¤šï¼š[ğŸ ä½ æœ‰ BUG æˆ‘æ¥å¸® - åŠ›æ‰£äº’åŠ¨ç­”ç–‘å­£](https://leetcode-cn.com/circle/discuss/xtliW6/)"
}