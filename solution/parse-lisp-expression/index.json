{
	"titleSlug": "parse-lisp-expression",
	"slug": "lisp-yu-fa-jie-xi-by-leetcode-solution-zycb",
	"url": "https://leetcode-cn.com/problems/parse-lisp-expression/solution/lisp-yu-fa-jie-xi-by-leetcode-solution-zycb/",
	"content": "#### 方法一：递归解析\n\n对于一个表达式 $\\textit{expression}$，如果它的首字符不等于左括号 $\\text{`('}$，那么它只能是一个整数或者变量；否则它是 $\\text{let}$，$\\text{add}$ 和 $\\text{mult}$ 三种表达式之一。\n\n定义函数 $\\text{parseVar}$ 用来解析变量以及函数 $\\text{parseInt}$ 用来解析整数。使用 $\\textit{scope}$ 来记录作用域，每个变量都依次记录下它从外到内的所有值，查找时只需要查找最后一个数值。我们递归地解析表达式 $\\textit{expression}$。\n\n+ $\\textit{expression}$ 的下一个字符不等于左括号 $\\text{`('}$。\n\n    + $\\textit{expression}$ 的下一个字符是小写字母，那么表达式是一个变量，使用函数 $\\text{parseVar}$ 解析变量，然后在 $\\textit{scope}$ 中查找变量的最后一个数值即最内层作用域的值并返回结果。\n\n    + $\\textit{expression}$ 的下一个字符不是小写字母，那么表达式是一个整数，使用函数 $\\textit{parseInt}$ 解析并返回结果。\n\n+ 去掉左括号后，$\\textit{expression}$ 的下一个字符是 $\\text{`l'}$，那么表达式是 $\\text{let}$ 表达式。对于 $\\text{let}$ 表达式，需要判断是否已经解析到最后一个 $\\textit{expr}$ 表达式。\n\n    + 如果下一个字符不是小写字母，或者解析变量后下一个字符是右括号 $\\text{`)'}$，说明是最后一个 $\\textit{expr}$ 表达式，计算它的值并返回结果。并且我们需要在 $\\textit{scope}$ 中清除 $\\text{let}$ 表达式对应的作用域变量。\n\n    + 否则说明是交替的变量 $v_i$ 和表达式 $e_i$，在 $\\textit{scope}$ 将变量 $v_i$ 的数值列表增加表达式 $e_i$ 的数值。\n\n+ 去掉左括号后，$\\textit{expression}$ 的下一个字符是 $\\text{`a'}$，那么表达式是 $\\text{add}$ 表达式。计算 $\\text{add}$ 表达式对应的两个表达式 $e_1$ 和 $e_2$ 的值，返回两者之和。\n\n+ 去掉左括号后，$\\textit{expression}$ 的下一个字符是 $\\text{`m'}$，那么表达式是 $\\text{mult}$ 表达式。计算 $\\text{mult}$ 表达式对应的两个表达式 $e_1$ 和 $e_2$ 的值，返回两者之积。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        i, n = 0, len(expression)\n\n        def parseVar() -> str:\n            nonlocal i\n            i0 = i\n            while i < n and expression[i] != ' ' and expression[i] != ')':\n                i += 1\n            return expression[i0:i]\n\n        def parseInt() -> int:\n            nonlocal i\n            sign, x = 1, 0\n            if expression[i] == '-':\n                sign = -1\n                i += 1\n            while i < n and expression[i].isdigit():\n                x = x * 10 + int(expression[i])\n                i += 1\n            return sign * x\n\n        scope = defaultdict(list)\n\n        def innerEvaluate() -> int:\n            nonlocal i\n            if expression[i] != '(':  # 非表达式，可能为：整数或变量\n                if expression[i].islower():  # 变量\n                    return scope[parseVar()][-1]\n                return parseInt()  # 整数\n            i += 1  # 移除左括号\n            if expression[i] == 'l':  # \"let\" 表达式\n                i += 4  # 移除 \"let \"\n                vars = []\n                while True:\n                    if not expression[i].islower():\n                        ret = innerEvaluate()  # let 表达式的最后一个 expr 表达式的值\n                        break\n                    var = parseVar()\n                    if expression[i] == ')':\n                        ret = scope[var][-1]  # let 表达式的最后一个 expr 表达式的值\n                        break\n                    vars.append(var)\n                    i += 1  # 移除空格\n                    scope[var].append(innerEvaluate())\n                    i += 1  # 移除空格\n                for var in vars:\n                    scope[var].pop()  # 清除当前作用域的变量\n            elif expression[i] == 'a':  # \"add\" 表达式\n                i += 4  # 移除 \"add \"\n                e1 = innerEvaluate()\n                i += 1  # 移除空格\n                e2 = innerEvaluate()\n                ret = e1 + e2\n            else:  # \"mult\" 表达式\n                i += 5  # 移除 \"mult \"\n                e1 = innerEvaluate()\n                i += 1  # 移除空格\n                e2 = innerEvaluate()\n                ret = e1 * e2\n            i += 1  # 移除右括号\n            return ret\n\n        return innerEvaluate()\n```\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    unordered_map<string, vector<int>> scope;\n\npublic:\n    int evaluate(string expression) {\n        int start = 0;\n        return innerEvaluate(expression, start);\n    }\n\n    int innerEvaluate(const string &expression, int &start) {\n        if (expression[start] != '(') { // 非表达式，可能为：整数或变量\n            if (islower(expression[start])) {\n                string var = parseVar(expression, start); // 变量\n                return scope[var].back();\n            } else { // 整数\n                return parseInt(expression, start);\n            }\n        }\n        int ret;\n        start++; // 移除左括号\n        if (expression[start] == 'l') { // \"let\" 表达式\n            start += 4; // 移除 \"let \"\n            vector<string> vars;\n            while (true) {\n                if (!islower(expression[start])) {\n                    ret = innerEvaluate(expression, start); // let 表达式的最后一个 expr 表达式的值\n                    break;\n                }\n                string var = parseVar(expression, start);\n                if (expression[start] == ')') {\n                    ret = scope[var].back(); // let 表达式的最后一个 expr 表达式的值\n                    break;\n                }\n                vars.push_back(var);\n                start++; // 移除空格\n                int e = innerEvaluate(expression, start);\n                scope[var].push_back(e);\n                start++; // 移除空格\n            }\n            for (auto var : vars) {\n                scope[var].pop_back(); // 清除当前作用域的变量\n            }\n        } else if (expression[start] == 'a') { // \"add\" 表达式\n            start += 4; // 移除 \"add \"\n            int e1 = innerEvaluate(expression, start);\n            start++; // 移除空格\n            int e2 = innerEvaluate(expression, start);\n            ret = e1 + e2;\n        } else { // \"mult\" 表达式\n            start += 5; // 移除 \"mult \"\n            int e1 = innerEvaluate(expression, start);\n            start++; // 移除空格\n            int e2 = innerEvaluate(expression, start);\n            ret = e1 * e2;\n        }\n        start++; // 移除右括号\n        return ret;\n    }\n\n    int parseInt(const string &expression, int &start) { // 解析整数\n        int n = expression.size();\n        int ret = 0, sign = 1;\n        if (expression[start] == '-') {\n            sign = -1;\n            start++;\n        }\n        while (start < n && isdigit(expression[start])) {\n            ret = ret * 10 + (expression[start] - '0');\n            start++;\n        }\n        return sign * ret;\n    }\n\n    string parseVar(const string &expression, int &start) { // 解析变量\n        int n = expression.size();\n        string ret;\n        while (start < n && expression[start] != ' ' && expression[start] != ')') {\n            ret.push_back(expression[start]);\n            start++;\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    Map<String, Deque<Integer>> scope = new HashMap<String, Deque<Integer>>();\n    int start = 0;\n\n    public int evaluate(String expression) {\n        return innerEvaluate(expression);\n    }\n\n    public int innerEvaluate(String expression) {\n        if (expression.charAt(start) != '(') { // 非表达式，可能为：整数或变量\n            if (Character.isLowerCase(expression.charAt(start))) {\n                String var = parseVar(expression); // 变量\n                return scope.get(var).peek();\n            } else { // 整数\n                return parseInt(expression);\n            }\n        }\n        int ret;\n        start++; // 移除左括号\n        if (expression.charAt(start) == 'l') { // \"let\" 表达式\n            start += 4; // 移除 \"let \"\n            List<String> vars = new ArrayList<String>();\n            while (true) {\n                if (!Character.isLowerCase(expression.charAt(start))) {\n                    ret = innerEvaluate(expression); // let 表达式的最后一个 expr 表达式的值\n                    break;\n                }\n                String var = parseVar(expression);\n                if (expression.charAt(start) == ')') {\n                    ret = scope.get(var).peek(); // let 表达式的最后一个 expr 表达式的值\n                    break;\n                }\n                vars.add(var);\n                start++; // 移除空格\n                int e = innerEvaluate(expression);\n                scope.putIfAbsent(var, new ArrayDeque<Integer>());\n                scope.get(var).push(e);\n                start++; // 移除空格\n            }\n            for (String var : vars) {\n                scope.get(var).pop(); // 清除当前作用域的变量\n            }\n        } else if (expression.charAt(start) == 'a') { // \"add\" 表达式\n            start += 4; // 移除 \"add \"\n            int e1 = innerEvaluate(expression);\n            start++; // 移除空格\n            int e2 = innerEvaluate(expression);\n            ret = e1 + e2;\n        } else { // \"mult\" 表达式\n            start += 5; // 移除 \"mult \"\n            int e1 = innerEvaluate(expression);\n            start++; // 移除空格\n            int e2 = innerEvaluate(expression);\n            ret = e1 * e2;\n        }\n        start++; // 移除右括号\n        return ret;\n    }\n\n    public int parseInt(String expression) { // 解析整数\n        int n = expression.length();\n        int ret = 0, sign = 1;\n        if (expression.charAt(start) == '-') {\n            sign = -1;\n            start++;\n        }\n        while (start < n && Character.isDigit(expression.charAt(start))) {\n            ret = ret * 10 + (expression.charAt(start) - '0');\n            start++;\n        }\n        return sign * ret;\n    }\n\n    public String parseVar(String expression) { // 解析变量\n        int n = expression.length();\n        StringBuffer ret = new StringBuffer();\n        while (start < n && expression.charAt(start) != ' ' && expression.charAt(start) != ')') {\n            ret.append(expression.charAt(start));\n            start++;\n        }\n        return ret.toString();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    Dictionary<string, Stack<int>> scope = new Dictionary<string, Stack<int>>();\n    int start = 0;\n\n    public int Evaluate(string expression) {\n        return InnerEvaluate(expression);\n    }\n\n    public int InnerEvaluate(string expression) {\n        if (expression[start] != '(') { // 非表达式，可能为：整数或变量\n            if (char.IsLower(expression[start])) {\n                string var = ParseVar(expression); // 变量\n                return scope[var].Peek();\n            } else { // 整数\n                return ParseInt(expression);\n            }\n        }\n        int ret;\n        start++; // 移除左括号\n        if (expression[start] == 'l') { // \"let\" 表达式\n            start += 4; // 移除 \"let \"\n            IList<string> vars = new List<string>();\n            while (true) {\n                if (!char.IsLower(expression[start])) {\n                    ret = InnerEvaluate(expression); // let 表达式的最后一个 expr 表达式的值\n                    break;\n                }\n                string var = ParseVar(expression);\n                if (expression[start] == ')') {\n                    ret = scope[var].Peek(); // let 表达式的最后一个 expr 表达式的值\n                    break;\n                }\n                vars.Add(var);\n                start++; // 移除空格\n                int e = InnerEvaluate(expression);\n                if (!scope.ContainsKey(var)) {\n                    scope.Add(var, new Stack<int>());\n                }\n                scope[var].Push(e);\n                start++; // 移除空格\n            }\n            foreach (string var in vars) {\n                scope[var].Pop(); // 清除当前作用域的变量\n            }\n        } else if (expression[start] == 'a') { // \"add\" 表达式\n            start += 4; // 移除 \"add \"\n            int e1 = InnerEvaluate(expression);\n            start++; // 移除空格\n            int e2 = InnerEvaluate(expression);\n            ret = e1 + e2;\n        } else { // \"mult\" 表达式\n            start += 5; // 移除 \"mult \"\n            int e1 = InnerEvaluate(expression);\n            start++; // 移除空格\n            int e2 = InnerEvaluate(expression);\n            ret = e1 * e2;\n        }\n        start++; // 移除右括号\n        return ret;\n    }\n\n    public int ParseInt(string expression) { // 解析整数\n        int n = expression.Length;\n        int ret = 0, sign = 1;\n        if (expression[start] == '-') {\n            sign = -1;\n            start++;\n        }\n        while (start < n && char.IsDigit(expression[start])) {\n            ret = ret * 10 + (expression[start] - '0');\n            start++;\n        }\n        return sign * ret;\n    }\n\n    public string ParseVar(string expression) { // 解析变量\n        int n = expression.Length;\n        StringBuilder ret = new StringBuilder();\n        while (start < n && expression[start] != ' ' && expression[start] != ')') {\n            ret.Append(expression[start]);\n            start++;\n        }\n        return ret.ToString();\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    char *key;\n    struct ListNode *lst;\n    UT_hash_handle hh;\n} HashItem;\n\ntypedef struct Node {\n    char *var;\n    struct Node *next;\n} Node;\n\nHashItem *scope = NULL;\n\nint parseInt(const char *expression, int *start) { // 解析整数\n    int n = strlen(expression);\n    int ret = 0, sign = 1;\n    if (expression[*start] == '-') {\n        sign = -1;\n        (*start)++;\n    }\n    while ((*start) < n && isdigit(expression[*start])) {\n        ret = ret * 10 + (expression[*start] - '0');\n        (*start)++;\n    }\n    return sign * ret;\n}\n\nchar *parseVar(const char *expression, int *start) { // 解析变量\n    int n = strlen(expression);\n    char *ret = (char *)malloc(sizeof(char) * (n - (*start) + 1));\n    int pos = 0;\n    while ((*start) < n && expression[*start] != ' ' && expression[*start] != ')') {\n        ret[pos++] = expression[(*start)++];\n    }\n    ret[pos] = '\\0';\n    return ret;\n}\n\nint innerEvaluate(const char *expression, int *start) {\n    if (expression[*start] != '(') { // 非表达式，可能为：整数或变量\n        if (islower(expression[*start])) {\n            char *var = parseVar(expression, start); // 变量\n            HashItem *pEntry = NULL;\n            HASH_FIND_STR(scope, var, pEntry);\n            free(var);\n            return pEntry->lst->val;\n        } else { // 整数\n            return parseInt(expression, start);\n        }\n    }\n    int ret;\n    (*start)++; // 移除左括号\n    if (expression[*start] == 'l') { // \"let\" 表达式\n        (*start) += 4; // 移除 \"let \"\n        Node *vars = NULL;\n        while (true) {\n            if (isdigit(expression[*start]) || expression[*start] == '(') {\n                ret = innerEvaluate(expression, start); // let 表达式的最后一个 expr 表达式的值\n                break;\n            }\n            char *var = parseVar(expression, start);\n            if (expression[*start] == ')') {\n                int start1 = 0;\n                ret = innerEvaluate(var, &start1); // let 表达式的最后一个 expr 表达式的值\n                break;\n            }\n            Node *node = (Node *)malloc(sizeof(Node));\n            node->var = var;\n            node->next = vars;\n            vars = node;\n            (*start)++; // 移除空格\n            int e = innerEvaluate(expression, start);\n            HashItem *pEntry = NULL;\n            HASH_FIND_STR(scope, var, pEntry);\n            if (NULL == pEntry) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                pEntry->key = var;\n                pEntry->lst = NULL;\n                HASH_ADD_STR(scope, key, pEntry);\n            }\n            struct ListNode *pNode = (struct ListNode *)malloc(sizeof(struct ListNode));\n            pNode->val = e;\n            pNode->next = pEntry->lst;\n            pEntry->lst = pNode; \n            (*start)++; // 移除空格\n        }\n        for (Node *node = vars; node; node = node->next) {\n            HashItem *pEntry = NULL;\n            HASH_FIND_STR(scope, node->var, pEntry);\n            if (pEntry) {\n                struct ListNode *pNode = pEntry->lst; // 清除当前作用域的变量\n                pEntry->lst = pEntry->lst->next;\n                free(pNode);\n            }\n        }\n    } else if (expression[*start] == 'a') { // \"add\" 表达式\n        (*start) += 4; // 移除 \"add \"\n        int e1 = innerEvaluate(expression, start);\n        (*start)++; // 移除空格\n        int e2 = innerEvaluate(expression, start);\n        ret = e1 + e2;\n    } else { // \"mult\" 表达式\n        (*start) += 5; // 移除 \"mult \"\n        int e1 = innerEvaluate(expression, start);\n        (*start)++; // 移除空格\n        int e2 = innerEvaluate(expression, start);\n        ret = e1 * e2;\n    }\n    (*start)++; // 移除右括号\n    return ret;\n}\n\nvoid freeScope() {\n    HashItem *curr, *tmp;\n    HASH_ITER(hh, scope, curr, tmp) {\n      HASH_DEL(scope, curr);\n      free(curr->key);\n      for (struct ListNode *node = curr->lst; node; ) {\n          struct ListNode *pNode = node;\n          node = node->next;\n          free(pNode);\n      }\n      free(curr);\n    }\n}\n\nint evaluate(char * expression){\n    int start = 0;    \n    int ret = innerEvaluate(expression, &start);\n    freeScope();\n    return ret;\n}\n```\n\n```go [sol1-Golang]\nfunc evaluate(expression string) int {\n    i, n := 0, len(expression)\n    parseVar := func() string {\n        i0 := i\n        for i < n && expression[i] != ' ' && expression[i] != ')' {\n            i++\n        }\n        return expression[i0:i]\n    }\n    parseInt := func() int {\n        sign, x := 1, 0\n        if expression[i] == '-' {\n            sign = -1\n            i++\n        }\n        for i < n && unicode.IsDigit(rune(expression[i])) {\n            x = x*10 + int(expression[i]-'0')\n            i++\n        }\n        return sign * x\n    }\n\n    scope := map[string][]int{}\n    var innerEvaluate func() int\n    innerEvaluate = func() (ret int) {\n        if expression[i] != '(' { // 非表达式，可能为：整数或变量\n            if unicode.IsLower(rune(expression[i])) { // 变量\n                vals := scope[parseVar()]\n                return vals[len(vals)-1]\n            }\n            return parseInt() // 整数\n        }\n        i++ // 移除左括号\n        if expression[i] == 'l' { // \"let\" 表达式\n            i += 4 // 移除 \"let \"\n            vars := []string{}\n            for {\n                if !unicode.IsLower(rune(expression[i])) {\n                    ret = innerEvaluate() // let 表达式的最后一个 expr 表达式的值\n                    break\n                }\n                vr := parseVar()\n                if expression[i] == ')' {\n                    vals := scope[vr]\n                    ret = vals[len(vals)-1] // let 表达式的最后一个 expr 表达式的值\n                    break\n                }\n                vars = append(vars, vr)\n                i++ // 移除空格\n                scope[vr] = append(scope[vr], innerEvaluate())\n                i++ // 移除空格\n            }\n            for _, vr := range vars {\n                scope[vr] = scope[vr][:len(scope[vr])-1] // 清除当前作用域的变量\n            }\n        } else if expression[i] == 'a' { // \"add\" 表达式\n            i += 4 // 移除 \"add \"\n            e1 := innerEvaluate()\n            i++ // 移除空格\n            e2 := innerEvaluate()\n            ret = e1 + e2\n        } else { // \"mult\" 表达式\n            i += 5 // 移除 \"mult \"\n            e1 := innerEvaluate()\n            i++ // 移除空格\n            e2 := innerEvaluate()\n            ret = e1 * e2\n        }\n        i++ // 移除右括号\n        return\n    }\n    return innerEvaluate()\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar evaluate = function(expression) {\n    const scope = new Map();\n    let start = 0;\n\n    const innerEvaluate = (expression) => {\n        if (expression[start] !== '(') { // 非表达式，可能为：整数或变量\n            if (isLowerCase(expression[start])) {\n                const v = parseVar(expression); // 变量\n                const n = scope.get(v).length;\n                return scope.get(v)[n - 1];\n            } else { // 整数\n                return parseInt(expression);\n            }\n        }\n        let ret;\n        start++; // 移除左括号\n        if (expression[start] === 'l') { // \"let\" 表达式\n            start += 4; // 移除 \"let \"\n            const vars = [];\n            while (true) {\n                if (!isLowerCase(expression[start])) {\n                    ret = innerEvaluate(expression); // let 表达式的最后一个 expr 表达式的值\n                    break;\n                }\n                const v = parseVar(expression);\n                if (expression[start] === ')') {\n                    const n = scope.get(v).length;\n                    ret = scope.get(v)[n - 1]; // let 表达式的最后一个 expr 表达式的值\n                    break;\n                }\n                vars.push(v);\n                start++; // 移除空格\n                const e = innerEvaluate(expression);\n                if (!scope.has(v)) {\n                    scope.set(v, []);\n                }\n                scope.get(v).push(e);\n                start++; // 移除空格\n            }\n            for (const v of vars) {\n                scope.get(v).pop(); // 清除当前作用域的变量\n            }\n        } else if (expression[start] === 'a') { // \"add\" 表达式\n            start += 4; // 移除 \"add \"\n            const e1 = innerEvaluate(expression);\n            start++; // 移除空格\n            const e2 = innerEvaluate(expression);\n            ret = e1 + e2;\n        } else { // \"mult\" 表达式\n            start += 5; // 移除 \"mult \"\n            const e1 = innerEvaluate(expression);\n            start++; // 移除空格\n            const e2 = innerEvaluate(expression);\n            ret = e1 * e2;\n        }\n        start++; // 移除右括号\n        return ret;\n    }\n\n    const parseInt = (expression) => { // 解析整数\n        const n = expression.length;\n        let ret = 0, sign = 1;\n        if (expression[start] === '-') {\n            sign = -1;\n            start++;\n        }\n        while (start < n && isDigit(expression[start])) {\n            ret = ret * 10 + (expression.charAt(start) - '0');\n            start++;\n        }\n        return sign * ret;\n    }\n\n    const parseVar = (expression) => { // 解析变量\n        const n = expression.length;\n        let ret = '';\n        while (start < n && expression[start] !== ' ' && expression[start] !== ')') {\n            ret += expression[start];\n            start++;\n        }\n        return ret;\n    }\n\n    return innerEvaluate(expression, start);\n};\n\nconst isDigit = (ch) => {\n    return parseFloat(ch).toString() === \"NaN\" ? false : true;\n}\n\nconst isLowerCase = (ch) => {\n    return ch >= 'a' && ch <= 'z';\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是字符串 $\\textit{expression}$ 的长度。递归调用函数 $\\text{innerEvaluate}$ 在某一层调用的时间复杂度为 $O(k)$，其中 $k$ 为指针 $\\textit{start}$ 在该层调用的移动次数。在整个递归调用过程中，指针 $\\textit{start}$ 会遍历整个字符串，因此解析 $\\textit{expression}$ 需要 $O(n)$。\n\n+ 空间复杂度：$O(n)$。保存 $\\textit{scope}$ 以及递归调用栈需要 $O(n)$ 的空间。\n\n#### 方法二：状态机\n\n定义状态 $\\text{ExprStatus}$，状态机的初始状态 $\\textit{cur}$ 为 $\\text{VALUE}$。\n\n当我们解析到一个左括号时，我们需要将当前状态 $\\textit{cur}$ 压入栈中，然后将当前状态 $\\textit{cur}$ 设为状态 $\\text{NONE}$，表示对一个未知表达式的解析。当我们解析到一个右括号时，我们需要根据括号对应的表达式的类型来计算最终值，并且将它转换成一个 $\\textit{token}$ 传回上层状态，将上层状态出栈并设为当前状态 $\\textit{cur}$，对于 $\\text{let}$ 表达式，我们还需要清除它的作用域。\n\n以下的每次状态的转换都会伴随一个 $\\textit{token}$，其中 $\\textit{token}$ 表示被空格和括号分隔开的词块，并且 $\\text{let}$，$\\text{add}$ 和 $\\text{mult}$ 三种表达式都可以转换成一个整数 $\\textit{token}$。状态转换如下：\n\n+ 状态 $\\text{VALUE}$：\n\n    + 将 $\\textit{token}$ 直接解析成整数保存到 $\\textit{value}$ 中，并将状态设为 $\\text{DONE}$，标志解析完成。\n\n+ 状态 $\\text{NONE}$：\n\n    + $\\textit{token} = \\text{``let\"}$：将当前状态 $\\textit{cur}$ 设为 $\\text{LET}$。\n\n    + $\\textit{token} = \\text{``add\"}$：将当前状态 $\\textit{cur}$ 设为 $\\text{ADD}$。\n\n    + $\\textit{token} = \\text{``mult\"}$：将当前状态 $\\textit{cur}$ 设为 $\\text{MULT}$。\n\n+ 状态 $\\text{LET}$：\n\n    + 下一个字符是右括号，说明已经到达 $\\text{let}$ 表达式的最后一个 $\\text{expr}$ 表达式，计算 $\\textit{token}$ 的值并保存到 $\\textit{value}$，并且将当前状态 $\\textit{cur}$ 设为 $\\text{LET2}$，标志着 $\\text{let}$ 表达式的解析完成。\n\n    + 下一个字符不是右括号，将 $\\textit{token}$ 记录到 $\\textit{var}$ 中，并且将当前状态 $\\textit{cur}$ 设为 $\\text{LET1}$。\n\n+ 状态 $\\text{LET1}$：\n\n    + 计算 $\\textit{token}$ 的值，在 $\\textit{scope}$ 中将变量 $var$ 的数值列表增加该数值，并且将当前状态 $\\textit{cur}$ 设为 $\\text{LET}$。\n\n+ 状态 $\\text{ADD}$：\n\n    + 计算 $\\textit{token}$ 的值，为 $e_1$ 赋值，并且将当前状态 $\\textit{cur}$ 设为 $\\text{ADD1}$。\n\n+ 状态 $\\text{ADD1}$：\n\n    + 计算 $\\textit{token}$ 的值，为 $e_2$ 赋值，并且将当前状态 $\\textit{cur}$ 设为 $\\text{ADD2}$，标志着 $\\text{add}$ 表达式的解析完成。\n\n+ 状态 $\\text{MULT}$：\n\n    + 计算 $\\textit{token}$ 的值，为 $e_1$ 赋值，并且将当前状态 $\\textit{cur}$ 设为 $\\text{MULT1}$。\n\n+ 状态 $\\text{MULT1}$：\n\n    + 计算 $\\textit{token}$ 的值，为 $e_2$ 赋值，并且将当前状态 $\\textit{cur}$ 设为 $\\text{MULT2}$，标志着 $\\text{mult}$ 表达式的解析完成。\n\n状态机有两种转换路线，第一种是从 $\\text{VALUE}$ 到 $\\text{DONE}$ 的转换路线，第二种是从 $\\text{NONE}$ 到 $\\text{LET2}$，$\\text{ADD2}$ 或 $\\text{MULT2}$ 的转换路线。\n\n![状态机转换图](https://assets.leetcode-cn.com/solution-static/736/1.jpg)\n\n**代码**\n\n```Python [sol2-Python3]\nfrom enum import Enum, auto\n\nclass ExprStatus(Enum):\n    VALUE = auto()  # 初始状态\n    NONE  = auto()  # 表达式类型未知\n    LET   = auto()  # let 表达式\n    LET1  = auto()  # let 表达式已经解析了 vi 变量\n    LET2  = auto()  # let 表达式已经解析了最后一个表达式 expr\n    ADD   = auto()  # add 表达式\n    ADD1  = auto()  # add 表达式已经解析了 e1 表达式\n    ADD2  = auto()  # add 表达式已经解析了 e2 表达式\n    MULT  = auto()  # mult 表达式\n    MULT1 = auto()  # mult 表达式已经解析了 e1 表达式\n    MULT2 = auto()  # mult 表达式已经解析了 e2 表达式\n    DONE  = auto()  # 解析完成\n\nclass Expr:\n    __slots__ = 'status', 'var', 'value', 'e1', 'e2'\n\n    def __init__(self, status):\n        self.status = status\n        self.var = ''  # let 的变量 vi\n        self.value = 0  # VALUE 状态的数值，或者 LET2 状态最后一个表达式的数值\n        self.e1 = self.e2 = 0  # add 或 mult 表达式的两个表达式 e1 和 e2 的数值\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        scope = defaultdict(list)\n\n        def calculateToken(token: str) -> int:\n            return scope[token][-1] if token[0].islower() else int(token)\n\n        vars = []\n        s = []\n        cur = Expr(ExprStatus.VALUE)\n        i, n = 0, len(expression)\n        while i < n:\n            if expression[i] == ' ':\n                i += 1  # 去掉空格\n                continue\n            if expression[i] == '(':\n                i += 1  # 去掉左括号\n                s.append(cur)\n                cur = Expr(ExprStatus.NONE)\n                continue\n            if expression[i] == ')':  # 本质上是把表达式转成一个 token\n                i += 1  # 去掉右括号\n                if cur.status is ExprStatus.LET2:\n                    token = str(cur.value)\n                    for var in vars[-1]:\n                        scope[var].pop()  # 清除作用域\n                    vars.pop()\n                elif cur.status is ExprStatus.ADD2:\n                    token = str(cur.e1 + cur.e2)\n                else:\n                    token = str(cur.e1 * cur.e2)\n                cur = s.pop()  # 获取上层状态\n            else:\n                i0 = i\n                while i < n and expression[i] != ' ' and expression[i] != ')':\n                    i += 1\n                token = expression[i0:i]\n\n            if cur.status is ExprStatus.VALUE:\n                cur.value = int(token)\n                cur.status = ExprStatus.DONE\n            elif cur.status is ExprStatus.NONE:\n                if token == \"let\":\n                    cur.status = ExprStatus.LET\n                    vars.append([])  # 记录该层作用域的所有变量, 方便后续的清除\n                elif token == \"add\":\n                    cur.status = ExprStatus.ADD\n                elif token == \"mult\":\n                    cur.status = ExprStatus.MULT\n            elif cur.status is ExprStatus.LET:\n                if expression[i] == ')':  # let 表达式的最后一个 expr 表达式\n                    cur.value = calculateToken(token)\n                    cur.status = ExprStatus.LET2\n                else:\n                    cur.var = token\n                    vars[-1].append(token)  # 记录该层作用域的所有变量, 方便后续的清除\n                    cur.status = ExprStatus.LET1\n            elif cur.status is ExprStatus.LET1:\n                scope[cur.var].append(calculateToken(token))\n                cur.status = ExprStatus.LET\n            elif cur.status is ExprStatus.ADD:\n                cur.e1 = calculateToken(token)\n                cur.status = ExprStatus.ADD1\n            elif cur.status is ExprStatus.ADD1:\n                cur.e2 = calculateToken(token)\n                cur.status = ExprStatus.ADD2\n            elif cur.status is ExprStatus.MULT:\n                cur.e1 = calculateToken(token)\n                cur.status = ExprStatus.MULT1\n            elif cur.status is ExprStatus.MULT1:\n                cur.e2 = calculateToken(token)\n                cur.status = ExprStatus.MULT2\n        return cur.value\n```\n\n```C++ [sol2-C++]\nenum ExprStatus {\n    VALUE = 0, // 初始状态\n    NONE,      // 表达式类型未知\n    LET,       // let 表达式\n    LET1,      // let 表达式已经解析了 vi 变量\n    LET2,      // let 表达式已经解析了最后一个表达式 expr\n    ADD,       // add 表达式\n    ADD1,      // add 表达式已经解析了 e1 表达式\n    ADD2,      // add 表达式已经解析了 e2 表达式\n    MULT,      // mult 表达式\n    MULT1,     // mult 表达式已经解析了 e1 表达式\n    MULT2,     // mult 表达式已经解析了 e2 表达式\n    DONE       // 解析完成\n};\n\nstruct Expr {\n    ExprStatus status;\n    string var; // let 的变量 vi\n    int value; // VALUE 状态的数值，或者 LET2 状态最后一个表达式的数值\n    int e1, e2; // add 或 mult 表达式的两个表达式 e1 和 e2 的数值\n\n    Expr(ExprStatus s) {\n        status = s;\n    }\n};\n\nclass Solution {\nprivate:\n    unordered_map<string, vector<int>> scope;\n\npublic:\n    int evaluate(string expression) {\n        vector<vector<string>> vars;\n        int start = 0, n = expression.size();\n        stack<Expr> s;\n        Expr cur(VALUE);\n        while (start < n) {\n            if (expression[start] == ' ') {\n                start++; // 去掉空格\n                continue;\n            }\n            if (expression[start] == '(') {\n                start++; // 去掉左括号\n                s.push(cur);\n                cur = Expr(NONE);\n                continue;\n            }\n            string token;\n            if (expression[start] == ')') { // 本质上是把表达式转成一个 token\n                start++; // 去掉右括号\n                if (cur.status == LET2) {\n                    token = to_string(cur.value);\n                    for (auto var : vars.back()) { // 清除作用域\n                        scope[var].pop_back();\n                    }\n                    vars.pop_back();\n                } else if (cur.status == ADD2) {\n                    token = to_string(cur.e1 + cur.e2);\n                } else {\n                    token = to_string(cur.e1 * cur.e2);\n                }\n                cur = s.top(); // 获取上层状态\n                s.pop();\n            } else {\n                while (start < n && expression[start] != ' ' && expression[start] != ')') {\n                    token.push_back(expression[start]);\n                    start++;\n                }\n            }\n            switch (cur.status) {\n                case VALUE:\n                    cur.value = stoi(token);\n                    cur.status = DONE;\n                    break;\n                case NONE:\n                    if (token == \"let\") {\n                        cur.status = LET;\n                        vars.emplace_back(); // 记录该层作用域的所有变量, 方便后续的清除\n                    } else if (token == \"add\") {\n                        cur.status = ADD;\n                    } else if (token == \"mult\") {\n                        cur.status = MULT;\n                    }\n                    break;\n                case LET:\n                    if (expression[start] == ')') { // let 表达式的最后一个 expr 表达式\n                        cur.value = calculateToken(token);\n                        cur.status = LET2;\n                    } else {\n                        cur.var = token;\n                        vars.back().push_back(token); // 记录该层作用域的所有变量, 方便后续的清除\n                        cur.status = LET1;\n                    }\n                    break;\n                case LET1:\n                    scope[cur.var].push_back(calculateToken(token));\n                    cur.status = LET;\n                    break;\n                case ADD:\n                    cur.e1 = calculateToken(token);\n                    cur.status = ADD1;\n                    break;\n                case ADD1:\n                    cur.e2 = calculateToken(token);\n                    cur.status = ADD2;\n                    break;\n                case MULT:\n                    cur.e1 = calculateToken(token);\n                    cur.status = MULT1;\n                    break;\n                case MULT1:\n                    cur.e2 = calculateToken(token);\n                    cur.status = MULT2;\n                    break;\n            }\n        }\n        return cur.value;\n    }\n\n    int calculateToken(const string &token) {\n        if (islower(token[0])) {\n            return scope[token].back();\n        } else {\n            return stoi(token);\n        }\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    Map<String, Deque<Integer>> scope = new HashMap<String, Deque<Integer>>();\n\n    public int evaluate(String expression) {\n        Deque<Deque<String>> vars = new ArrayDeque<Deque<String>>();\n        int start = 0, n = expression.length();\n        Deque<Expr> stack = new ArrayDeque<Expr>();\n        Expr cur = new Expr(ExprStatus.VALUE);\n        while (start < n) {\n            if (expression.charAt(start) == ' ') {\n                start++; // 去掉空格\n                continue;\n            }\n            if (expression.charAt(start) == '(') {\n                start++; // 去掉左括号\n                stack.push(cur);\n                cur = new Expr(ExprStatus.NONE);\n                continue;\n            }\n            StringBuffer sb = new StringBuffer();\n            if (expression.charAt(start) == ')') { // 本质上是把表达式转成一个 token\n                start++; // 去掉右括号\n                if (cur.status == ExprStatus.LET2) {\n                    sb = new StringBuffer(Integer.toString(cur.value));\n                    for (String var : vars.peek()) { // 清除作用域\n                        scope.get(var).pop();\n                    }\n                    vars.pop();\n                } else if (cur.status == ExprStatus.ADD2) {\n                    sb = new StringBuffer(Integer.toString(cur.e1 + cur.e2));\n                } else {\n                    sb = new StringBuffer(Integer.toString(cur.e1 * cur.e2));\n                }\n                cur = stack.pop(); // 获取上层状态\n            } else {\n                while (start < n && expression.charAt(start) != ' ' && expression.charAt(start) != ')') {\n                    sb.append(expression.charAt(start));\n                    start++;\n                }\n            }\n            String token = sb.toString();\n            switch (cur.status.toString()) {\n            case \"VALUE\":\n                cur.value = Integer.parseInt(token);\n                cur.status = ExprStatus.DONE;\n                break;\n            case \"NONE\":\n                if (\"let\".equals(token)) {\n                    cur.status = ExprStatus.LET;\n                    vars.push(new ArrayDeque<String>()); // 记录该层作用域的所有变量, 方便后续的清除\n                } else if (\"add\".equals(token)) {\n                    cur.status = ExprStatus.ADD;\n                } else if (\"mult\".equals(token)) {\n                    cur.status = ExprStatus.MULT;\n                }\n                break;\n            case \"LET\":\n                if (expression.charAt(start) == ')') { // let 表达式的最后一个 expr 表达式\n                    cur.value = calculateToken(token);\n                    cur.status = ExprStatus.LET2;\n                } else {\n                    cur.var = token;\n                    vars.peek().push(token); // 记录该层作用域的所有变量, 方便后续的清除\n                    cur.status = ExprStatus.LET1;\n                }\n                break;\n            case \"LET1\":\n                scope.putIfAbsent(cur.var, new ArrayDeque<Integer>());\n                scope.get(cur.var).push(calculateToken(token));\n                cur.status = ExprStatus.LET;\n                break;\n            case \"ADD\":\n                cur.e1 = calculateToken(token);\n                cur.status = ExprStatus.ADD1;\n                break;\n            case \"ADD1\":\n                cur.e2 = calculateToken(token);\n                cur.status = ExprStatus.ADD2;\n                break;\n            case \"MULT\":\n                cur.e1 = calculateToken(token);\n                cur.status = ExprStatus.MULT1;\n                break;\n            case \"MULT1\":\n                cur.e2 = calculateToken(token);\n                cur.status = ExprStatus.MULT2;\n                break;\n            }\n        }\n        return cur.value;\n    }\n\n    public int calculateToken(String token) {\n        if (Character.isLowerCase(token.charAt(0))) {\n            return scope.get(token).peek();\n        } else {\n            return Integer.parseInt(token);\n        }\n    }\n}\n\nenum ExprStatus {\n    VALUE,     // 初始状态\n    NONE,      // 表达式类型未知\n    LET,       // let 表达式\n    LET1,      // let 表达式已经解析了 vi 变量\n    LET2,      // let 表达式已经解析了最后一个表达式 expr\n    ADD,       // add 表达式\n    ADD1,      // add 表达式已经解析了 e1 表达式\n    ADD2,      // add 表达式已经解析了 e2 表达式\n    MULT,      // mult 表达式\n    MULT1,     // mult 表达式已经解析了 e1 表达式\n    MULT2,     // mult 表达式已经解析了 e2 表达式\n    DONE       // 解析完成\n}\n\nclass Expr {\n    ExprStatus status;\n    String var; // let 的变量 vi\n    int value; // VALUE 状态的数值，或者 LET2 状态最后一个表达式的数值\n    int e1, e2; // add 或 mult 表达式的两个表达式 e1 和 e2 的数值\n\n    public Expr(ExprStatus s) {\n        status = s;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    Dictionary<string, Stack<int>> scope = new Dictionary<string, Stack<int>>();\n\n    public int Evaluate(string expression) {\n        Stack<Stack<string>> vars = new Stack<Stack<string>>();\n        int start = 0, n = expression.Length;\n        Stack<Expr> stack = new Stack<Expr>();\n        Expr cur = new Expr(ExprStatus.VALUE);\n        while (start < n) {\n            if (expression[start] == ' ') {\n                start++; // 去掉空格\n                continue;\n            }\n            if (expression[start] == '(') {\n                start++; // 去掉左括号\n                stack.Push(cur);\n                cur = new Expr(ExprStatus.NONE);\n                continue;\n            }\n            StringBuilder sb = new StringBuilder();\n            if (expression[start] == ')') { // 本质上是把表达式转成一个 token\n                start++; // 去掉右括号\n                if (cur.status == ExprStatus.LET2) {\n                    sb = new StringBuilder(cur.value.ToString());\n                    foreach (string var in vars.Peek()) { // 清除作用域\n                        scope[var].Pop();\n                    }\n                    vars.Pop();\n                } else if (cur.status == ExprStatus.ADD2) {\n                    sb = new StringBuilder((cur.e1 + cur.e2).ToString());\n                } else {\n                    sb = new StringBuilder((cur.e1 * cur.e2).ToString());\n                }\n                cur = stack.Pop(); // 获取上层状态\n            } else {\n                while (start < n && expression[start] != ' ' && expression[start] != ')') {\n                    sb.Append(expression[start]);\n                    start++;\n                }\n            }\n            string token = sb.ToString();\n            switch (cur.status.ToString()) {\n            case \"VALUE\":\n                cur.value = int.Parse(token);\n                cur.status = ExprStatus.DONE;\n                break;\n            case \"NONE\":\n                if (\"let\".Equals(token)) {\n                    cur.status = ExprStatus.LET;\n                    vars.Push(new Stack<string>()); // 记录该层作用域的所有变量, 方便后续的清除\n                } else if (\"add\".Equals(token)) {\n                    cur.status = ExprStatus.ADD;\n                } else if (\"mult\".Equals(token)) {\n                    cur.status = ExprStatus.MULT;\n                }\n                break;\n            case \"LET\":\n                if (expression[start] == ')') { // let 表达式的最后一个 expr 表达式\n                    cur.value = CalculateToken(token);\n                    cur.status = ExprStatus.LET2;\n                } else {\n                    cur.var = token;\n                    vars.Peek().Push(token); // 记录该层作用域的所有变量, 方便后续的清除\n                    cur.status = ExprStatus.LET1;\n                }\n                break;\n            case \"LET1\":\n                if (!scope.ContainsKey(cur.var)) {\n                    scope.Add(cur.var, new Stack<int>());\n                }\n                scope[cur.var].Push(CalculateToken(token));\n                cur.status = ExprStatus.LET;\n                break;\n            case \"ADD\":\n                cur.e1 = CalculateToken(token);\n                cur.status = ExprStatus.ADD1;\n                break;\n            case \"ADD1\":\n                cur.e2 = CalculateToken(token);\n                cur.status = ExprStatus.ADD2;\n                break;\n            case \"MULT\":\n                cur.e1 = CalculateToken(token);\n                cur.status = ExprStatus.MULT1;\n                break;\n            case \"MULT1\":\n                cur.e2 = CalculateToken(token);\n                cur.status = ExprStatus.MULT2;\n                break;\n            }\n        }\n        return cur.value;\n    }\n\n    public int CalculateToken(string token) {\n        if (char.IsLower(token[0])) {\n            return scope[token].Peek();\n        } else {\n            return int.Parse(token);\n        }\n    }\n}\n\npublic enum ExprStatus {\n    VALUE,     // 初始状态\n    NONE,      // 表达式类型未知\n    LET,       // let 表达式\n    LET1,      // let 表达式已经解析了 vi 变量\n    LET2,      // let 表达式已经解析了最后一个表达式 expr\n    ADD,       // add 表达式\n    ADD1,      // add 表达式已经解析了 e1 表达式\n    ADD2,      // add 表达式已经解析了 e2 表达式\n    MULT,      // mult 表达式\n    MULT1,     // mult 表达式已经解析了 e1 表达式\n    MULT2,     // mult 表达式已经解析了 e2 表达式\n    DONE       // 解析完成\n}\n\npublic class Expr {\n    public ExprStatus status;\n    public string var; // let 的变量 vi\n    public int value; // VALUE 状态的数值，或者 LET2 状态最后一个表达式的数值\n    public int e1, e2; // add 或 mult 表达式的两个表达式 e1 和 e2 的数值\n\n    public Expr(ExprStatus s) {\n        status = s;\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX_VAR_LEN 64\n#define MAX_VAR_SIZE 1024\n\ntypedef struct {\n    char key[MAX_VAR_LEN];\n    struct ListNode *lst;\n    UT_hash_handle hh;\n} HashItem;\n\ntypedef struct VarNode {\n    char *var[MAX_VAR_SIZE];\n    int varSize;\n    struct VarNode *next;\n} VarNode;\n\nHashItem *scope = NULL;\n\ntypedef enum ExprStatus {\n    VALUE = 0, // 初始状态\n    NONE,      // 表达式类型未知\n    LET,       // let 表达式\n    LET1,      // let 表达式已经解析了 vi 变量\n    LET2,      // let 表达式已经解析了最后一个表达式 expr\n    ADD,       // add 表达式\n    ADD1,      // add 表达式已经解析了 e1 表达式\n    ADD2,      // add 表达式已经解析了 e2 表达式\n    MULT,      // mult 表达式\n    MULT1,     // mult 表达式已经解析了 e1 表达式\n    MULT2,     // mult 表达式已经解析了 e2 表达式\n    DONE       // 解析完成\n} ExprStatus;\n\ntypedef struct Expr {\n    ExprStatus status;\n    char var[MAX_VAR_LEN]; // let 的变量 vi\n    int value; // VALUE 状态的数值，或者 LET2 状态最后一个表达式的数值\n    int e1, e2; // add 或 mult 表达式的两个表达式 e1 和 e2 的数值\n} Expr;\n\nExpr *creatExpr(ExprStatus s) {\n    Expr *e = (Expr *)malloc(sizeof(Expr));\n    e->status = s;\n    e->value = 0;\n    return e;\n}\n\nVarNode *creatVarNode() {\n    VarNode *node = (VarNode *)malloc(sizeof(VarNode));\n    node->varSize = 0;\n    node->next = NULL;\n    return node;\n}\n\nint calculateToken(const char *token) {\n    if (islower(token[0])) {\n        HashItem *pEntry = NULL;\n        HASH_FIND_STR(scope, token, pEntry);\n        return pEntry->lst->val;\n    } else {\n        return atoi(token);\n    }\n}\n\nvoid freeScope() {\n    HashItem *curr, *tmp;\n    HASH_ITER(hh, scope, curr, tmp) {\n      HASH_DEL(scope, curr);\n      for (struct ListNode *node = curr->lst; node; ) {\n          struct ListNode *pNode = node;\n          node = node->next;\n          free(pNode);\n      }\n      free(curr);\n    }\n}\n\nint evaluate(char * expression){\n    VarNode *vars = NULL;\n    int start = 0, n = strlen(expression);\n    Expr **st = (Expr **)malloc(sizeof(Expr *) * n);\n    int top = 0;\n    Expr *cur = creatExpr(VALUE);\n    HashItem *pEntry = NULL;\n    while (start < n) {\n        if (expression[start] == ' ') {\n            start++; // 去掉空格\n            continue;\n        }\n        if (expression[start] == '(') {\n            start++; // 去掉左括号\n            st[top++] = cur;\n            cur = creatExpr(NONE);\n            continue;\n        }\n        char token[MAX_VAR_LEN];\n        int pos = 0;\n        if (expression[start] == ')') { // 本质上是把表达式转成一个 token\n            start++; // 去掉右括号\n            if (cur->status == LET2) {\n                pos = sprintf(token, \"%d\", cur->value);\n                for (int i = 0; i < vars->varSize; i++) {\n                    pEntry = NULL;\n                    HASH_FIND_STR(scope, vars->var[i], pEntry);\n                    if (pEntry) {\n                        struct ListNode *pNode = pEntry->lst; // 清除当前作用域的变量\n                        if (pEntry->lst) {\n                            pEntry->lst = pEntry->lst->next;\n                            free(pNode);\n                        }\n                    }\n                    free(vars->var[i]);\n                }\n                VarNode *prev = vars;\n                vars = vars->next;    \n                free(prev);        \n            } else if (cur->status == ADD2) {\n                pos = sprintf(token, \"%d\", cur->e1 + cur->e2);\n            } else {\n                pos = sprintf(token, \"%d\", cur->e1 * cur->e2);\n            }\n            free(cur);\n            cur = st[top - 1]; // 获取上层状态\n            top--;\n        } else {\n            while (start < n && expression[start] != ' ' && expression[start] != ')') {\n                token[pos++] = expression[start];\n                token[pos] = '\\0';\n                start++;\n            }\n        }\n        switch (cur->status) {\n            case VALUE:\n                cur->value = atoi(token);\n                cur->status = DONE;\n                break;\n            case NONE:\n                if (!strcmp(token, \"let\")) {\n                    cur->status = LET;\n                    VarNode *pNode = creatVarNode();\n                    pNode->next = vars;\n                    vars = pNode; // 记录该层作用域的所有变量, 方便后续的清除\n                } else if (!strcmp(token, \"add\")) {\n                    cur->status = ADD;\n                } else if (!strcmp(token, \"mult\")) {\n                    cur->status = MULT;\n                }\n                break;\n            case LET:\n                if (expression[start] == ')') { // let 表达式的最后一个 expr 表达式\n                    cur->value = calculateToken(token);\n                    cur->status = LET2;\n                } else {\n                    strcpy(cur->var, token);\n                    vars->var[vars->varSize] = (char *)malloc(sizeof(char) * (strlen(token) + 1));\n                    strcpy(vars->var[vars->varSize++], token); // 记录该层作用域的所有变量, 方便后续的清除      \n                    cur->status = LET1;         \n                }\n                break;\n            case LET1:\n                pEntry = NULL;\n                HASH_FIND_STR(scope, cur->var, pEntry);\n                if (NULL == pEntry) {\n                    pEntry = (HashItem *)malloc(sizeof(HashItem));\n                    strcpy(pEntry->key, cur->var);\n                    pEntry->lst = NULL;\n                    HASH_ADD_STR(scope, key, pEntry);\n                }\n                struct ListNode *pNode = (struct ListNode *)malloc(sizeof(struct ListNode));\n                pNode->val = calculateToken(token);\n                pNode->next = pEntry->lst;\n                pEntry->lst = pNode; \n                cur->status = LET;\n                break;\n            case ADD:\n                cur->e1 = calculateToken(token);\n                cur->status = ADD1;\n                break;\n            case ADD1:\n                cur->e2 = calculateToken(token);\n                cur->status = ADD2;\n                break;\n            case MULT:\n                cur->e1 = calculateToken(token);\n                cur->status = MULT1;\n                break;\n            case MULT1:\n                cur->e2 = calculateToken(token);\n                cur->status = MULT2;\n                break;\n        }\n    }\n    freeScope();\n    return cur->value;\n}\n```\n\n```go [sol2-Golang]\nconst (\n    VALUE = iota // 初始状态\n    NONE         // 表达式类型未知\n    LET          // let 表达式\n    LET1         // let 表达式已经解析了 vi 变量\n    LET2         // let 表达式已经解析了最后一个表达式 expr\n    ADD          // add 表达式\n    ADD1         // add 表达式已经解析了 e1 表达式\n    ADD2         // add 表达式已经解析了 e2 表达式\n    MULT         // mult 表达式\n    MULT1        // mult 表达式已经解析了 e1 表达式\n    MULT2        // mult 表达式已经解析了 e2 表达式\n    DONE         // 解析完成\n)\n\ntype expr struct {\n    status int\n    vr     string // let 的变量 vi\n    value  int    // VALUE 状态的数值，或者 LET2 状态最后一个表达式的数值\n    e1, e2 int    // add 或 mult 表达式的两个表达式 e1 和 e2 的数值\n}\n\nfunc evaluate(expression string) int {\n    scope := map[string][]int{}\n    calculateToken := func(token string) int {\n        if unicode.IsLower(rune(token[0])) {\n            vals := scope[token]\n            return vals[len(vals)-1]\n        }\n        val, _ := strconv.Atoi(token)\n        return val\n    }\n\n    vars := [][]string{}\n    s := []expr{}\n    cur := expr{status: VALUE}\n    for i, n := 0, len(expression); i < n; {\n        if expression[i] == ' ' {\n            i++ // 去掉空格\n            continue\n        }\n        if expression[i] == '(' {\n            i++ // 去掉左括号\n            s = append(s, cur)\n            cur.status = NONE\n            continue\n        }\n        var token string\n        if expression[i] == ')' { // 本质上是把表达式转成一个 token\n            i++ // 去掉右括号\n            if cur.status == LET2 {\n                token = strconv.Itoa(cur.value)\n                for _, vr := range vars[len(vars)-1] { // 清除作用域\n                    scope[vr] = scope[vr][:len(scope[vr])-1]\n                }\n                vars = vars[:len(vars)-1]\n            } else if cur.status == ADD2 {\n                token = strconv.Itoa(cur.e1 + cur.e2)\n            } else {\n                token = strconv.Itoa(cur.e1 * cur.e2)\n            }\n            cur, s = s[len(s)-1], s[:len(s)-1] // 获取上层状态\n        } else {\n            i0 := i\n            for i < n && expression[i] != ' ' && expression[i] != ')' {\n                i++\n            }\n            token = expression[i0:i]\n        }\n\n        switch cur.status {\n        case VALUE:\n            cur.value, _ = strconv.Atoi(token)\n            cur.status = DONE\n        case NONE:\n            if token == \"let\" {\n                cur.status = LET\n                vars = append(vars, nil) // 记录该层作用域的所有变量, 方便后续的清除\n            } else if token == \"add\" {\n                cur.status = ADD\n            } else if token == \"mult\" {\n                cur.status = MULT\n            }\n        case LET:\n            if expression[i] == ')' { // let 表达式的最后一个 expr 表达式\n                cur.value = calculateToken(token)\n                cur.status = LET2\n            } else {\n                cur.vr = token\n                vars[len(vars)-1] = append(vars[len(vars)-1], token) // 记录该层作用域的所有变量, 方便后续的清除\n                cur.status = LET1\n            }\n        case LET1:\n            scope[cur.vr] = append(scope[cur.vr], calculateToken(token))\n            cur.status = LET\n        case ADD:\n            cur.e1 = calculateToken(token)\n            cur.status = ADD1\n        case ADD1:\n            cur.e2 = calculateToken(token)\n            cur.status = ADD2\n        case MULT:\n            cur.e1 = calculateToken(token)\n            cur.status = MULT1\n        case MULT1:\n            cur.e2 = calculateToken(token)\n            cur.status = MULT2\n        }\n    }\n    return cur.value\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar evaluate = function(expression) {\n    const scope = new Map();\n    let vars = [];\n    let start = 0, n = expression.length;\n    const stack = [];\n    let cur = new Expr(ExprStatus.VALUE);\n\n    while (start < n) {\n        if (expression[start] === ' ') {\n            start++; // 去掉空格\n            continue;\n        }\n        if (expression[start] === '(') {\n            start++; // 去掉左括号\n            stack.push(cur);\n            cur = new Expr(ExprStatus.NONE);\n            continue;\n        }\n        let sb = '';\n        if (expression[start] === ')') { // 本质上是把表达式转成一个 token\n            start++; // 去掉右括号\n            if (cur.status == ExprStatus.LET2) {\n                sb = cur.value;\n                for (const v of vars[vars.length - 1]) { // 清除作用域\n                    scope.get(v).pop();\n                }\n                vars.pop();\n            } else if (cur.status === ExprStatus.ADD2) {\n                sb = cur.e1 + cur.e2;\n            } else {\n                sb = cur.e1 * cur.e2;\n            }\n            cur = stack.pop(); // 获取上层状态\n        } else {\n            while (start < n && expression[start] !== ' ' && expression[start] !== ')') {\n                sb += expression[start];\n                start++;\n            }\n        }\n        let token = sb;\n        switch (cur.status) {\n        case \"VALUE\":\n            cur.value = parseInt(token);\n            cur.status = ExprStatus.DONE;\n            break;\n        case \"NONE\":\n            if (\"let\" === token) {\n                cur.status = ExprStatus.LET;\n                vars.push([]); // 记录该层作用域的所有变量, 方便后续的清除\n            } else if (\"add\" === token) {\n                cur.status = ExprStatus.ADD;\n            } else if (\"mult\" === token) {\n                cur.status = ExprStatus.MULT;\n            }\n            break;\n        case \"LET\":\n            if (expression[start] === ')') { // let 表达式的最后一个 expr 表达式\n                cur.value = calculateToken(scope, token);\n                cur.status = ExprStatus.LET2;\n            } else {\n                cur.v = token;\n                vars[vars.length - 1].push(token); // 记录该层作用域的所有变量, 方便后续的清除\n                cur.status = ExprStatus.LET1;\n            }\n            break;\n        case \"LET1\":\n            if (!scope.has(cur.v)) {\n                scope.set(cur.v, []);\n            }\n            scope.get(cur.v).push(calculateToken(scope, token));\n            cur.status = ExprStatus.LET;\n            break;\n        case \"ADD\":\n            cur.e1 = calculateToken(scope, token);\n            cur.status = ExprStatus.ADD1;\n            break;\n        case \"ADD1\":\n            cur.e2 = calculateToken(scope, token);\n            cur.status = ExprStatus.ADD2;\n            break;\n        case \"MULT\":\n            cur.e1 = calculateToken(scope, token);\n            cur.status = ExprStatus.MULT1;\n            break;\n        case \"MULT1\":\n            cur.e2 = calculateToken(scope, token);\n            cur.status = ExprStatus.MULT2;\n            break;\n        }\n    }\n    return cur.value;\n}\n\nconst calculateToken = (scope, token) => {\n    if (token[0] >= 'a' && token[0] <= 'z') {\n        const n = scope.get(token).length;\n        return scope.get(token)[n - 1];\n    } else {\n        return parseInt(token);\n    }\n};\n\nvar ExprStatus = {\n    VALUE: 'VALUE',     // 初始状态\n    NONE: 'NONE',      // 表达式类型未知\n    LET: 'LET',       // let 表达式\n    LET1: 'LET1',      // let 表达式已经解析了 vi 变量\n    LET2: 'LET2',      // let 表达式已经解析了最后一个表达式 expr\n    ADD: 'ADD',       // add 表达式\n    ADD1: 'ADD1',      // add 表达式已经解析了 e1 表达式\n    ADD2: 'ADD2',      // add 表达式已经解析了 e2 表达式\n    MULT: 'MULT',      // mult 表达式\n    MULT1: 'MULT1',     // mult 表达式已经解析了 e1 表达式\n    MULT2: 'MULT2',     // mult 表达式已经解析了 e2 表达式\n    DONE: 'DONE'       // 解析完成\n}\n\nclass Expr {\n    constructor(s) {\n        this.status = s;\n        this.v = ''; // let 的变量 vi\n        this.value = 0; // VALUE 状态的数值，或者 LET2 状态最后一个表达式的数值\n        this.e1 = 0; // add 或 mult 表达式的两个表达式 e1 和 e2 的数值\n        this.e2 = 0;\n    }\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是字符串 $\\textit{expression}$ 的长度。状态机解析会遍历整个字符串，因此需要 $O(n)$ 的时间。\n\n+ 空间复杂度：$O(n)$。保存状态的栈以及作用域变量都需要 $O(n)$ 的空间。"
}