{
	"titleSlug": "sum-lists-lcci",
	"slug": "lian-biao-qiu-he-by-leetcode-solution-vcyz",
	"url": "https://leetcode-cn.com/problems/sum-lists-lcci/solution/lian-biao-qiu-he-by-leetcode-solution-vcyz/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n由于输入的两个链表都是**反向**存放数字的位数的，因此两个链表中同一位置的数字可以直接相加。\n\n我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 $n_1,n_2$，进位值为 $\\textit{carry}$，则它们的和为 $n_1+n_2+\\textit{carry}$；其中，答案链表处相应位置的数字为 $(n_1+n_2+\\textit{carry}) \\bmod 10$，而新的进位值为 $\\Big\\lfloor\\dfrac{n_1+n_2+\\textit{carry}}{10}\\Big\\rfloor$。\n\n如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 $0$ 。\n\n此外，如果链表遍历结束后，有 $\\textit{carry} > 0$，还需要在答案链表的后面附加一个节点，节点的值为 $\\textit{carry}$。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head = null, tail = null;\n        int carry = 0;\n        while (l1 != null || l2 != null) {\n            int n1 = l1 != null ? l1.val : 0;\n            int n2 = l2 != null ? l2.val : 0;\n            int sum = n1 + n2 + carry;\n            if (head == null) {\n                head = tail = new ListNode(sum % 10);\n            } else {\n                tail.next = new ListNode(sum % 10);\n                tail = tail.next;\n            }\n            carry = sum / 10;\n            if (l1 != null) {\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                l2 = l2.next;\n            }\n        }\n        if (carry > 0) {\n            tail.next = new ListNode(carry);\n        }\n        return head;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head = null, tail = null;\n        int carry = 0;\n        while (l1 != null || l2 != null) {\n            int n1 = l1 != null ? l1.val : 0;\n            int n2 = l2 != null ? l2.val : 0;\n            int sum = n1 + n2 + carry;\n            if (head == null) {\n                head = tail = new ListNode(sum % 10);\n            } else {\n                tail.next = new ListNode(sum % 10);\n                tail = tail.next;\n            }\n            carry = sum / 10;\n            if (l1 != null) {\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                l2 = l2.next;\n            }\n        }\n        if (carry > 0) {\n            tail.next = new ListNode(carry);\n        }\n        return head;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode *head = nullptr, *tail = nullptr;\n        int carry = 0;\n        while (l1 || l2) {\n            int n1 = l1 ? l1->val: 0;\n            int n2 = l2 ? l2->val: 0;\n            int sum = n1 + n2 + carry;\n            if (!head) {\n                head = tail = new ListNode(sum % 10);\n            } else {\n                tail->next = new ListNode(sum % 10);\n                tail = tail->next;\n            }\n            carry = sum / 10;\n            if (l1) {\n                l1 = l1->next;\n            }\n            if (l2) {\n                l2 = l2->next;\n            }\n        }\n        if (carry > 0) {\n            tail->next = new ListNode(carry);\n        }\n        return head;\n    }\n};\n```\n\n```JavaScript [sol1-JavaScript]\nvar addTwoNumbers = function(l1, l2) {\n    let head = null, tail = null;\n    let carry = 0;\n    while (l1 || l2) {\n        const n1 = l1 ? l1.val : 0;\n        const n2 = l2 ? l2.val : 0;\n        const sum = n1 + n2 + carry;\n        if (!head) {\n            head = tail = new ListNode(sum % 10);\n        } else {\n            tail.next = new ListNode(sum % 10);\n            tail = tail.next;\n        }\n        carry = Math.floor(sum / 10);\n        if (l1) {\n            l1 = l1.next;\n        }\n        if (l2) {\n            l2 = l2.next;\n        }\n    }\n    if (carry > 0) {\n        tail.next = new ListNode(carry);\n    }\n    return head;\n};\n```\n\n```Golang [sol1-Golang]\nfunc addTwoNumbers(l1, l2 *ListNode) (head *ListNode) {\n    var tail *ListNode\n    carry := 0\n    for l1 != nil || l2 != nil {\n        n1, n2 := 0, 0\n        if l1 != nil {\n            n1 = l1.Val\n            l1 = l1.Next\n        }\n        if l2 != nil {\n            n2 = l2.Val\n            l2 = l2.Next\n        }\n        sum := n1 + n2 + carry\n        sum, carry = sum%10, sum/10\n        if head == nil {\n            head = &ListNode{Val: sum}\n            tail = head\n        } else {\n            tail.Next = &ListNode{Val: sum}\n            tail = tail.Next\n        }\n    }\n    if carry > 0 {\n        tail.Next = &ListNode{Val: carry}\n    }\n    return\n}\n```\n\n```C [sol1-C]\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    struct ListNode *head = NULL, *tail = NULL;\n    int carry = 0;\n    while (l1 || l2) {\n        int n1 = l1 ? l1->val : 0;\n        int n2 = l2 ? l2->val : 0;\n        int sum = n1 + n2 + carry;\n        if (!head) {\n            head = tail = malloc(sizeof(struct ListNode));\n            tail->val = sum % 10;\n            tail->next = NULL;\n        } else {\n            tail->next = malloc(sizeof(struct ListNode));\n            tail->next->val = sum % 10;\n            tail = tail->next;\n            tail->next = NULL;\n        }\n        carry = sum / 10;\n        if (l1) {\n            l1 = l1->next;\n        }\n        if (l2) {\n            l2 = l2->next;\n        }\n    }\n    if (carry > 0) {\n        tail->next = malloc(sizeof(struct ListNode));\n        tail->next->val = carry;\n        tail->next->next = NULL;\n    }\n    return head;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\max(m,n))$，其中 $m$ 和 $n$ 分别为两个链表的长度。我们需要遍历两个链表的全部位置，而处理每个位置只需要 $O(1)$ 的时间。\n\n- 空间复杂度：$O(1)$。注意返回值不计入空间复杂度。\n\n#### 进阶问题\n\n**思路与算法**\n\n进阶问题中，输入的两个链表都是**正向**存放数字的位数的，因此链表中数位的顺序与我们做加法的顺序是相反的。\n\n为了反向处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。\n\n**代码**\n\n```Java [sol2-Java]\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        Deque<Integer> stack1 = new ArrayDeque<Integer>();\n        Deque<Integer> stack2 = new ArrayDeque<Integer>();\n        while (l1 != null) {\n            stack1.push(l1.val);\n            l1 = l1.next;\n        }\n        while (l2 != null) {\n            stack2.push(l2.val);\n            l2 = l2.next;\n        }\n        int carry = 0;\n        ListNode ans = null;\n        while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0) {\n            int a = stack1.isEmpty() ? 0 : stack1.pop();\n            int b = stack2.isEmpty() ? 0 : stack2.pop();\n            int cur = a + b + carry;\n            carry = cur / 10;\n            cur %= 10;\n            ListNode curnode = new ListNode(cur);\n            curnode.next = ans;\n            ans = curnode;\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        Stack<int> stack1 = new Stack<int>();\n        Stack<int> stack2 = new Stack<int>();\n        while (l1 != null) {\n            stack1.Push(l1.val);\n            l1 = l1.next;\n        }\n        while (l2 != null) {\n            stack2.Push(l2.val);\n            l2 = l2.next;\n        }\n        int carry = 0;\n        ListNode ans = null;\n        while (stack1.Count > 0 || stack2.Count > 0 || carry != 0) {\n            int a = stack1.Count == 0 ? 0 : stack1.Pop();\n            int b = stack2.Count == 0 ? 0 : stack2.Pop();\n            int cur = a + b + carry;\n            carry = cur / 10;\n            cur %= 10;\n            ListNode curnode = new ListNode(cur);\n            curnode.next = ans;\n            ans = curnode;\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        stack<int> s1, s2;\n        while (l1) {\n            s1.push(l1 -> val);\n            l1 = l1 -> next;\n        }\n        while (l2) {\n            s2.push(l2 -> val);\n            l2 = l2 -> next;\n        }\n        int carry = 0;\n        ListNode* ans = nullptr;\n        while (!s1.empty() or !s2.empty() or carry != 0) {\n            int a = s1.empty() ? 0 : s1.top();\n            int b = s2.empty() ? 0 : s2.top();\n            if (!s1.empty()) s1.pop();\n            if (!s2.empty()) s2.pop();\n            int cur = a + b + carry;\n            carry = cur / 10;\n            cur %= 10;\n            auto curnode = new ListNode(cur);\n            curnode -> next = ans;\n            ans = curnode;\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        s1, s2 = [], []\n        while l1:\n            s1.append(l1.val)\n            l1 = l1.next\n        while l2:\n            s2.append(l2.val)\n            l2 = l2.next\n        ans = None\n        carry = 0\n        while s1 or s2 or carry != 0:\n            a = 0 if not s1 else s1.pop()\n            b = 0 if not s2 else s2.pop()\n            cur = a + b + carry\n            carry = cur // 10\n            cur %= 10\n            curnode = ListNode(cur)\n            curnode.next = ans\n            ans = curnode\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\max(m,n))$，其中 $m$ 和 $n$ 分别为两个链表的长度。我们需要遍历两个链表的全部位置，而处理每个位置只需要 $O(1)$ 的时间。\n\n- 空间复杂度：$O(m + n)$，其中 $m$ 和 $n$ 分别为两个链表的长度。空间复杂度主要取决于我们把链表内容放入栈中所用的空间。"
}