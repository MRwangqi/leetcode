{
	"titleSlug": "longest-binary-subsequence-less-than-or-equal-to-k",
	"slug": "by-miller-r-3phz",
	"url": "https://leetcode-cn.com/problems/longest-binary-subsequence-less-than-or-equal-to-k/solution/by-miller-r-3phz/",
	"content": "\n# 这个题目做题可谓一波三折\n## 第一波 比较直观的解法，但是很容易超时。卡在这个用例上：\"001010101011010100010101101010010\"   93951055\n### show me code\n```javascript\n/**\n * @param {string} s\n * @param {number} k\n * @return {number} \n */\nvar longestSubsequence = function(s, k) {\n  let res = 0;\n  let len = s.length;\n  let dfs = (ix, path = []) => {\n    if (ix >= len) {\n      let n = path.join('');\n      let val = parseInt(n, 2);\n      if (val <= k) {\n        res = Math.max(res, n.length);\n      }\n      return;\n    };\n    path.push(s[ix]);\n    dfs(ix + 1, path); // 选\n    path.pop();\n    dfs(ix + 1, path); // 不选\n  }\n  dfs(0);\n  return res;\n};\n```\n## 第二波 开始动用记忆化、剪枝，为何不行呢？还是超时，大牛们帮忙分析分析！！！！\n```javascript\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar longestSubsequence = function(s, k) {\n  let res = 0;\n  let len = s.length;\n  let map = new Map();\n  let dfs = (ix, pstr) => {\n    let val = parseInt(pstr, 2);\n    if (val > k) return\n    if (map.get(pstr) > k) {\n     return;\n    }\n    let tmp = pstr\n    if (ix >= len) {\n      let val = parseInt(pstr, 2);\n      map.set(pstr, val)\n      if (val <= k) {\n        res = Math.max(res, `${pstr}`.length);\n      }\n      return;\n    };\n    if (s[ix] === '0') { // 等于0直接选\n      tmp += s[ix]\n      dfs(ix + 1, tmp);\n      tmp -= s[ix]\n      dfs(ix + 1, pstr)\n    } else { // else等于1要使得最终值小于k才选\n      let str = tmp + s[ix]\n      let val = parseInt(str, 2)\n      if (val <= k) {\n        tmp += s[ix]\n        dfs(ix + 1, tmp)\n        tmp -= s[ix]\n        dfs(ix + 1, pstr) \n      }\n    }\n  }\n  dfs(0, '');\n  return res;\n};\n```\n### 第三波 同样的思路，改动一下下就过了，不知道如何分析，请教大牛\n```javascript\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar longestSubsequence = function(s, k) {\n  let res = 0;\n  let len = s.length;\n  let map = new Map();\n  let dfs = (ix /*index*/, \n             now /*当前达到的值大小*/, \n             slen/*当前符合要求的子序列长度*/\n  ) => {\n    if (now > k) return\n    if (map.get(ix) <= now) {\n     return;\n    }\n    map.set(ix, now)\n    if (ix == -1) {\n      if (slen > res) {\n        res = slen\n      }\n      return;\n    };\n    if (s[ix] === '0') { // 等于0直接选\n      dfs(ix - 1, now, slen + 1);\n    } else if(now + Math.pow(2, slen) <= k){ // else等于1要使得最终值小于k才选\n      dfs(ix - 1, now + Math.pow(2, slen), slen + 1)\n    }\n    dfs(ix - 1, now, slen) // 都不选 跳过\n  }\n  dfs(len - 1, 0, 0);\n  return res;\n};\n```\n\n"
}