{
	"titleSlug": "7rLGCR",
	"slug": "typescript-by-981377660lmt-i4fr",
	"url": "https://leetcode-cn.com/problems/7rLGCR/solution/typescript-by-981377660lmt-i4fr/",
	"content": "![image.png](https://pic.leetcode-cn.com/1659527248-aCIFcU-image.png)\n\n### 解题思路\n建图思路：\n\n0. 因为是要割点而不是割边，所以要把每个点拆成入点和出点两个部分\n1. 虚拟源点连接所有恶魔的出生点\n2. 城堡连接虚拟汇点\n3. 用一个虚拟点连通所有传送门\n4. 所有出点连通周围的入点\n\n### 代码\n\n```typescript\nconst DIR2 = [\n  [0, 1],\n  [1, 0]\n]\nconst INF = 2e15\n\nfunction guardCastle(grid: string[]): number {\n  const [ROW, COL] = [grid.length, grid[0].length]\n  const OFFSET = ROW * COL\n  const [START, END, TELEPORT] = [2 * OFFSET + 5, 2 * OFFSET + 6, 2 * OFFSET + 7]\n  const maxFlow = useDinic(2 * OFFSET + 10, START, END)\n\n  for (let r = 0; r < ROW; r++) {\n    for (let c = 0; c < COL; c++) {\n      if (grid[r][c] === '#') continue\n\n      const cur = r * COL + c\n\n      // 0. 所有点拆成 入点 和 出点 两个点\n      maxFlow.addEdgeIfAbsent(cur, cur + OFFSET, grid[r][c] === '.' ? 1 : INF)\n\n      // 1. 源点连接恶魔出生点\n      if (grid[r][c] === 'S') {\n        maxFlow.addEdgeIfAbsent(START, cur, INF)\n      }\n\n      // 2. 城堡连接汇点\n      if (grid[r][c] === 'C') {\n        maxFlow.addEdgeIfAbsent(cur, END, INF)\n      }\n\n      // 3. 虚拟点连通所有传送门\n      if (grid[r][c] === 'P') {\n        maxFlow.addEdgeIfAbsent(cur + OFFSET, TELEPORT, INF)\n        maxFlow.addEdgeIfAbsent(TELEPORT, cur, INF)\n      }\n\n      // 4. 所有出点连通周围的入点\n      for (const next of genNext(cur)) {\n        maxFlow.addEdgeIfAbsent(cur + OFFSET, next, INF)\n        maxFlow.addEdgeIfAbsent(next + OFFSET, cur, INF)\n      }\n    }\n  }\n\n  const minCut = maxFlow.calMaxFlow()\n  return minCut < INF ? minCut : -1\n\n  function* genNext(cur: number): Generator<number> {\n    const [curRow, curCol] = [Math.floor(cur / COL), cur % COL]\n    for (const [dr, dc] of DIR2) {\n      const [nextRow, nextCol] = [curRow + dr, curCol + dc]\n      if (\n        0 <= nextRow &&\n        nextRow < ROW &&\n        0 <= nextCol &&\n        nextCol < COL &&\n        grid[nextRow][nextCol] !== '#'\n      ) {\n        yield nextRow * COL + nextCol\n      }\n    }\n  }\n}\n\n\n\n/**\n * Dinic算法求最大流\n *\n * 时间复杂度: `O(V^2*E)`\n *\n * @param n 图的顶点个数\n * @param start (虚拟)源点\n * @param end (虚拟)汇点\n */\nfunction useDinic(n: number, start: number, end: number) {\n  if (start < 0 || start >= n || end < 0 || end >= n) {\n    throw new RangeError(`start: ${start}, end: ${end} out of range [0, ${n - 1}]`)\n  }\n\n  const graph = Array.from<unknown, number[]>({ length: n }, () => [])\n  const edges: [next: number, capacity: number][] = []\n  const visitedEdge = new Set<number>()\n\n  /**\n   * 添加边 {@link from} -> {@link to}, 容量为 {@link capacity}\n   * 注意这种方式会添加重边\n   */\n  function addEdge(from: number, to: number, capacity: number): void {\n    const hash = from * n + to\n    visitedEdge.add(hash)\n    graph[from].push(edges.length)\n    edges.push([to, capacity])\n    graph[to].push(edges.length)\n    edges.push([from, 0])\n  }\n\n  /**\n   * 如果没有添加过这条边，\n   * 则添加边 {@link from} -> {@link to}, 容量为 {@link capacity}\n   */\n  function addEdgeIfAbsent(from: number, to: number, capacity: number): void {\n    const hash = from * n + to\n    if (visitedEdge.has(hash)) return\n    visitedEdge.add(hash)\n    graph[from].push(edges.length)\n    edges.push([to, capacity])\n    graph[to].push(edges.length)\n    edges.push([from, 0])\n  }\n\n  function calMaxFlow(): number {\n    const levels = new Int32Array(n)\n    const curEdges = new Int32Array(n) // 当前弧优化\n\n    let res = 0\n    while (bfs(start, end)) {\n      curEdges.fill(0)\n      res += dfs(start, end, INF)\n    }\n    return res\n\n    /**\n     * 建立分层图\n     */\n    function bfs(start: number, end: number): boolean {\n      let queue = [start]\n      levels.fill(-1)\n      levels[start] = 0\n\n      while (queue.length) {\n        const nextQueue: number[] = []\n        const step = queue.length\n\n        for (let _ = 0; _ < step; _++) {\n          const cur = queue.pop()!\n\n          for (let i = 0; i < graph[cur].length; i++) {\n            const ei = graph[cur][i]\n            const next = edges[ei][0]\n            const capacity = edges[ei][1]\n            if (capacity > 0 && levels[next] === -1) {\n              levels[next] = levels[cur] + 1\n              if (next === end) return true\n              nextQueue.push(next)\n            }\n          }\n        }\n\n        queue = nextQueue\n      }\n\n      return false\n    }\n\n    /**\n     * 寻找增广路\n     */\n    function dfs(cur: number, end: number, flow: number): number {\n      if (cur === end) {\n        return flow\n      }\n\n      let res = flow\n      // 当前弧优化\n      for (let ei = curEdges[cur]; ei < graph[cur].length; ei = ++curEdges[cur]) {\n        const ej = graph[cur][ei]\n        const next = edges[ej][0]\n        const remain = edges[ej][1]\n        if (remain > 0 && levels[next] === levels[cur] + 1) {\n          const delta = dfs(next, end, Math.min(res, remain))\n          edges[ej][1] -= delta\n          edges[ej ^ 1][1] += delta\n          res -= delta\n          if (res === 0) return flow\n        }\n      }\n\n      return flow - res\n    }\n  }\n\n  /**\n   * @returns 边的残量(剩余的容量)\n   * @example\n   * ```typescript\n   * const maxFlow = useDinic(n, start, end)\n   * const query = maxFlow.useQueryRemainOfEdge()\n   * console.log(query(0, 1))\n   * ```\n   */\n  function useQueryRemainOfEdge(): (v1: number, v2: number) => number {\n    const adjList = Array.from<number, Map<number, number>>({ length: n }, () => new Map())\n    for (let cur = 0; cur < graph.length; cur++) {\n      const eis = graph[cur]\n      const innerMap = adjList[cur]\n\n      for (let i = 0; i < eis.length; i++) {\n        const ei = eis[i]\n        const edge = edges[ei]\n        const next = edge[0]\n        const remain = edge[1]\n\n        innerMap.set(next, (innerMap.get(next) || 0) + remain)\n      }\n    }\n\n    return queryApi\n\n    function queryApi(v1: number, v2: number): number {\n      const innerMap = adjList[v1]\n      return innerMap.get(v2) || 0\n    }\n  }\n\n  /**\n   * @returns 最大流经过的点\n   */\n  function getPath(): Set<number> {\n    const visited = new Set<number>()\n    const queue = [start]\n    while (queue.length) {\n      const cur = queue.pop()!\n      visited.add(cur)\n      for (let i = 0; i < graph[cur].length; i++) {\n        const ei = graph[cur][i]\n        const edge = edges[ei]\n        const next = edge[0]\n        const remain = edge[1]\n        if (remain > 0 && !visited.has(next)) {\n          visited.add(next)\n          queue.push(next)\n        }\n      }\n    }\n\n    return visited\n  }\n\n  return {\n    addEdge,\n    addEdgeIfAbsent,\n    calMaxFlow,\n    useQueryRemainOfEdge,\n    getPath\n  }\n}\n```"
}