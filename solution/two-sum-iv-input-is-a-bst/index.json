{
	"titleSlug": "two-sum-iv-input-is-a-bst",
	"slug": "liang-shu-zhi-he-iv-shu-ru-bst-by-leetco-b4nl",
	"url": "https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/liang-shu-zhi-he-iv-shu-ru-bst-by-leetco-b4nl/",
	"content": "#### 方法一：深度优先搜索 + 哈希表\n\n**思路和算法**\n\n我们可以使用深度优先搜索的方式遍历整棵树，用哈希表记录遍历过的节点的值。\n\n对于一个值为 $x$ 的节点，我们检查哈希表中是否存在 $k - x$ 即可。如果存在对应的元素，那么我们就可以在该树上找到两个节点的和为 $k$；否则，我们将 $x$ 放入到哈希表中。\n\n如果遍历完整棵树都不存在对应的元素，那么该树上不存在两个和为 $k$ 的节点。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def __init__(self):\n        self.s = set()\n\n    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\n        if root is None:\n            return False\n        if k - root.val in self.s:\n            return True\n        self.s.add(root.val)\n        return self.findTarget(root.left, k) or self.findTarget(root.right, k)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    unordered_set<int> hashTable;\n\n    bool findTarget(TreeNode *root, int k) {\n        if (root == nullptr) {\n            return false;\n        }\n        if (hashTable.count(k - root->val)) {\n            return true;\n        }\n        hashTable.insert(root->val);\n        return findTarget(root->left, k) || findTarget(root->right, k);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    Set<Integer> set = new HashSet<Integer>();\n\n    public boolean findTarget(TreeNode root, int k) {\n        if (root == null) {\n            return false;\n        }\n        if (set.contains(k - root.val)) {\n            return true;\n        }\n        set.add(root.val);\n        return findTarget(root.left, k) || findTarget(root.right, k);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    ISet<int> set = new HashSet<int>();\n\n    public bool FindTarget(TreeNode root, int k) {\n        if (root == null) {\n            return false;\n        }\n        if (set.Contains(k - root.val)) {\n            return true;\n        }\n        set.Add(root.val);\n        return FindTarget(root.left, k) || FindTarget(root.right, k);\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    UT_hash_handle hh;\n} HashItem;\n\nbool helper(const struct TreeNode* root, int k, HashItem ** hashTable) {\n    if (root == NULL) {\n        return false;\n    }\n    int key = k - root->val;\n    HashItem * pEntry = NULL;\n    HASH_FIND_INT(*hashTable, &key, pEntry);\n    if (pEntry != NULL) {\n        return true;\n    }\n    pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = root->val;\n    HASH_ADD_INT(*hashTable, key, pEntry);\n    return helper(root->left, k, hashTable) || helper(root->right, k, hashTable);\n}\n\nbool findTarget(struct TreeNode* root, int k){\n    HashItem * hashTable = NULL;\n    return helper(root, k, &hashTable);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findTarget = function(root, k) {\n    const set = new Set();\n    const helper = (root, k) => {\n        if (!root) {\n            return false;\n        }\n        if (set.has(k - root.val)) {\n            return true;\n        }\n        set.add(root.val);\n        return helper(root.left, k) || helper(root.right, k);\n    }\n    return helper(root, k);\n};\n```\n\n```go [sol1-Golang]\nfunc findTarget(root *TreeNode, k int) bool {\n    set := map[int]struct{}{}\n    var dfs func(*TreeNode) bool\n    dfs = func(node *TreeNode) bool {\n        if node == nil {\n            return false\n        }\n        if _, ok := set[k-node.Val]; ok {\n            return true\n        }\n        set[node.Val] = struct{}{}\n        return dfs(node.Left) || dfs(node.Right)\n    }\n    return dfs(root)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的大小。我们需要遍历整棵树一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的大小。主要为哈希表的开销，最坏情况下我们需要将每个节点加入哈希表一次。\n\n#### 方法二：广度优先搜索 + 哈希表\n\n**思路和算法**\n\n我们可以使用广度优先搜索的方式遍历整棵树，用哈希表记录遍历过的节点的值。\n\n具体地，我们首先创建一个哈希表和一个队列，将根节点加入队列中，然后执行以下步骤：\n\n1. 从队列中取出队头，假设其值为 $x$；\n2. 检查哈希表中是否存在 $k - x$，如果存在，返回 $\\text{True}$；\n3. 否则，将该节点的左右的非空子节点加入队尾；\n4. 重复以上步骤，直到队列为空；\n5. 如果队列为空，说明树上不存在两个和为 $k$ 的节点，返回 $\\text{False}$。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\n        s = set()\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if k - node.val in s:\n                return True\n            s.add(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        return False\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool findTarget(TreeNode *root, int k) {\n        unordered_set<int> hashTable;\n        queue<TreeNode *> que;\n        que.push(root);\n        while (!que.empty()) {\n            TreeNode *node = que.front();\n            que.pop();\n            if (hashTable.count(k - node->val)) {\n                return true;\n            }\n            hashTable.insert(node->val);\n            if (node->left != nullptr) {\n                que.push(node->left);\n            }\n            if (node->right != nullptr) {\n                que.push(node->right);\n            }\n        }\n        return false;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean findTarget(TreeNode root, int k) {\n        Set<Integer> set = new HashSet<Integer>();\n        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (set.contains(k - node.val)) {\n                return true;\n            }\n            set.add(node.val);\n            if (node.left != null) {\n                queue.offer(node.left);\n            }\n            if (node.right != null) {\n                queue.offer(node.right);\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public bool FindTarget(TreeNode root, int k) {\n        ISet<int> set = new HashSet<int>();\n        Queue<TreeNode> queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n        while (queue.Count > 0) {\n            TreeNode node = queue.Dequeue();\n            if (set.Contains(k - node.val)) {\n                return true;\n            }\n            set.Add(node.val);\n            if (node.left != null) {\n                queue.Enqueue(node.left);\n            }\n            if (node.right != null) {\n                queue.Enqueue(node.right);\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX_NODE_SIZE 1e4\n\ntypedef struct {\n    int key;\n    UT_hash_handle hh;\n} HashItem;\n\nbool findTarget(struct TreeNode* root, int k){\n    HashItem * hashTable = NULL;\n    struct TreeNode ** que = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * MAX_NODE_SIZE);\n    int head = 0, tail = 0;\n    que[tail++] = root;\n    while (head != tail) {\n        struct TreeNode *node = que[head++];\n        int key = k - node->val;\n        HashItem * pEntry = NULL;\n        HASH_FIND_INT(hashTable, &key, pEntry);\n        if (pEntry != NULL) {\n            return true;\n        }\n        pEntry = (HashItem *)malloc(sizeof(HashItem));\n        pEntry->key = node->val;\n        HASH_ADD_INT(hashTable, key, pEntry);\n        if (node->left != NULL) {\n            que[tail++] = node->left;\n        }\n        if (node->right != NULL) {\n            que[tail++] = node->right;\n        }\n    }\n    HashItem * curr = NULL, * next = NULL;\n    HASH_ITER(hh, hashTable, curr, next) {\n        HASH_DEL(hashTable, curr); \n        free(curr);           \n    }\n    return false;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar findTarget = function(root, k) {\n    const set = new Set();\n    const queue = [];\n    queue.push(root);\n    while (queue.length) {\n        const node = queue.shift();\n        if (set.has(k - node.val)) {\n            return true;\n        }\n        set.add(node.val);\n        if (node.left) {\n            queue.push(node.left);\n        }\n        if (node.right) {\n            queue.push(node.right);\n        }\n    }\n    return false;\n};\n```\n\n```go [sol2-Golang]\nfunc findTarget(root *TreeNode, k int) bool {\n    set := map[int]struct{}{}\n    q := []*TreeNode{root}\n    for len(q) > 0 {\n        node := q[0]\n        q = q[1:]\n        if _, ok := set[k-node.Val]; ok {\n            return true\n        }\n        set[node.Val] = struct{}{}\n        if node.Left != nil {\n            q = append(q, node.Left)\n        }\n        if node.Right != nil {\n            q = append(q, node.Right)\n        }\n    }\n    return false\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的大小。我们需要遍历整棵树一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的大小。主要为哈希表和队列的开销，最坏情况下我们需要将每个节点加入哈希表和队列各一次。\n\n#### 方法三：深度优先搜索 + 中序遍历 + 双指针\n\n**思路和算法**\n\n注意到二叉搜索树的中序遍历是升序排列的，我们可以将该二叉搜索树的中序遍历的结果记录下来，得到一个升序数组。\n\n这样该问题即转化为「[167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)」。我们可以使用双指针解决它。\n\n具体地，我们使用两个指针分别指向数组的头尾，当两个指针指向的元素之和小于 $k$ 时，让左指针右移；当两个指针指向的元素之和大于 $k$ 时，让右指针左移；当两个指针指向的元素之和等于 $k$ 时，返回 $\\text{True}$。\n\n最终，当左指针和右指针重合时，树上不存在两个和为 $k$ 的节点，返回 $\\text{False}$。\n\n**代码**\n\n```Python [sol3-Python3]\nclass Solution:\n    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\n        arr = []\n        def inorderTraversal(node: Optional[TreeNode]) -> None:\n            if node:\n                inorderTraversal(node.left)\n                arr.append(node.val)\n                inorderTraversal(node.right)\n        inorderTraversal(root)\n\n        left, right = 0, len(arr) - 1\n        while left < right:\n            sum = arr[left] + arr[right]\n            if sum == k:\n                return True\n            if sum < k:\n                left += 1\n            else:\n                right -= 1\n        return False\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    vector<int> vec;\n\n    void inorderTraversal(TreeNode *node) {\n        if (node == nullptr) {\n            return;\n        }\n        inorderTraversal(node->left);\n        vec.push_back(node->val);\n        inorderTraversal(node->right);\n    }\n\n    bool findTarget(TreeNode *root, int k) {\n        inorderTraversal(root);\n        int left = 0, right = vec.size() - 1;\n        while (left < right) {\n            if (vec[left] + vec[right] == k) {\n                return true;\n            }\n            if (vec[left] + vec[right] < k) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return false;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    List<Integer> list = new ArrayList<Integer>();\n\n    public boolean findTarget(TreeNode root, int k) {\n        inorderTraversal(root);\n        int left = 0, right = list.size() - 1;\n        while (left < right) {\n            if (list.get(left) + list.get(right) == k) {\n                return true;\n            }\n            if (list.get(left) + list.get(right) < k) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return false;\n    }\n\n    public void inorderTraversal(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        inorderTraversal(node.left);\n        list.add(node.val);\n        inorderTraversal(node.right);\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    IList<int> list = new List<int>();\n\n    public bool FindTarget(TreeNode root, int k) {\n        InorderTraversal(root);\n        int left = 0, right = list.Count - 1;\n        while (left < right) {\n            if (list[left] + list[right] == k) {\n                return true;\n            }\n            if (list[left] + list[right] < k) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return false;\n    }\n\n    public void InorderTraversal(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        InorderTraversal(node.left);\n        list.Add(node.val);\n        InorderTraversal(node.right);\n    }\n}\n```\n\n```C [sol3-C]\n#define MAX_NODE_SIZE 1e4\n\nvoid inorderTraversal(const struct TreeNode* node, int* vec, int* pos) {\n    if (node == NULL) {\n        return;\n    }\n    inorderTraversal(node->left, vec, pos);\n    vec[(*pos)++] = node->val;\n    inorderTraversal(node->right, vec, pos);\n}\n\nbool findTarget(struct TreeNode* root, int k) {\n    int * vec = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    int pos = 0;\n    inorderTraversal(root, vec, &pos);\n    int left = 0, right = pos - 1;\n    while (left < right) {\n        if (vec[left] + vec[right] == k) {\n            return true;\n        }\n        if (vec[left] + vec[right] < k) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    free(vec);\n    return false;\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar findTarget = function(root, k) {\n    const list = [];\n    const inorderTraversal = (node) => {\n        if (!node) {\n            return;\n        }\n        inorderTraversal(node.left);\n        list.push(node.val);\n        inorderTraversal(node.right);\n    }\n    inorderTraversal(root);\n    let left = 0, right = list.length - 1;\n    while (left < right) {\n        if (list[left] + list[right] === k) {\n            return true;\n        }\n        if (list[left] + list[right] < k) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return false;\n};\n```\n\n```go [sol3-Golang]\nfunc findTarget(root *TreeNode, k int) bool {\n    arr := []int{}\n    var inorderTraversal func(*TreeNode)\n    inorderTraversal = func(node *TreeNode) {\n        if node != nil {\n            inorderTraversal(node.Left)\n            arr = append(arr, node.Val)\n            inorderTraversal(node.Right)\n        }\n    }\n    inorderTraversal(root)\n\n    left, right := 0, len(arr)-1\n    for left < right {\n        sum := arr[left] + arr[right]\n        if sum == k {\n            return true\n        }\n        if sum < k {\n            left++\n        } else {\n            right--\n        }\n    }\n    return false\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的大小。我们需要遍历整棵树一次，并对得到的升序数组使用双指针遍历。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的大小。主要为升序数组的开销。\n\n#### 方法四：迭代 + 中序遍历 + 双指针\n\n**思路和算法**\n\n在方法三中，我们是在中序遍历得到的数组上进行双指针，这样需要消耗 $O(n)$ 的空间，实际上我们可以将双指针的移动理解为在树上的遍历过程的一次移动。因为递归方法较难控制移动过程，因此我们使用迭代的方式进行遍历。\n\n具体地，我们对于每个指针新建一个栈。初始，我们让左指针移动到树的最左端点，并将路径保存在栈中，接下来我们可以依据栈来 $O(1)$ 地计算出左指针的下一个位置。右指针也是同理。\n\n计算下一个位置时，我们首先将位于栈顶的当前节点从栈中弹出，此时首先判断当前节点是否存在右子节点，如果存在，那么我们将右子节点的最左子树加入到栈中；否则我们就完成了当前层的遍历，无需进一步修改栈的内容，直接回溯到上一层即可。\n\n**代码**\n\n```Python [sol4-Python3]\nclass Solution:\n    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\n        left, right = root, root\n        leftStk, rightStk = [left], [right]\n        while left.left:\n            left = left.left\n            leftStk.append(left)\n        while right.right:\n            right = right.right\n            rightStk.append(right)\n        while left != right:\n            sum = left.val + right.val\n            if sum == k:\n                return True\n            if sum < k:\n                left = leftStk.pop()\n                node = left.right\n                while node:\n                    leftStk.append(node)\n                    node = node.left\n            else:\n                right = rightStk.pop()\n                node = right.left\n                while node:\n                    rightStk.append(node)\n                    node = node.right\n        return False\n```\n\n```C++ [sol4-C++]\nclass Solution {\npublic:\n    TreeNode *getLeft(stack<TreeNode *> &stk) {\n        TreeNode *root = stk.top();\n        stk.pop();\n        TreeNode *node = root->right;\n        while (node != nullptr) {\n            stk.push(node);\n            node = node->left;\n        }\n        return root;\n    }\n\n    TreeNode *getRight(stack<TreeNode *> &stk) {\n        TreeNode *root = stk.top();\n        stk.pop();\n        TreeNode *node = root->left;\n        while (node != nullptr) {\n            stk.push(node);\n            node = node->right;\n        }\n        return root;\n    }\n\n    bool findTarget(TreeNode *root, int k) {\n        TreeNode *left = root, *right = root;\n        stack<TreeNode *> leftStack, rightStack;\n        leftStack.push(left);\n        while (left->left != nullptr) {\n            leftStack.push(left->left);\n            left = left->left;\n        }\n        rightStack.push(right);\n        while (right->right != nullptr) {\n            rightStack.push(right->right);\n            right = right->right;\n        }\n        while (left != right) {\n            if (left->val + right->val == k) {\n                return true;\n            }\n            if (left->val + right->val < k) {\n                left = getLeft(leftStack);\n            } else {\n                right = getRight(rightStack);\n            }\n        }\n        return false;\n    }\n};\n```\n\n```Java [sol4-Java]\nclass Solution {\n    public boolean findTarget(TreeNode root, int k) {\n        TreeNode left = root, right = root;\n        Deque<TreeNode> leftStack = new ArrayDeque<TreeNode>();\n        Deque<TreeNode> rightStack = new ArrayDeque<TreeNode>();\n        leftStack.push(left);\n        while (left.left != null) {\n            leftStack.push(left.left);\n            left = left.left;\n        }\n        rightStack.push(right);\n        while (right.right != null) {\n            rightStack.push(right.right);\n            right = right.right;\n        }\n        while (left != right) {\n            if (left.val + right.val == k) {\n                return true;\n            }\n            if (left.val + right.val < k) {\n                left = getLeft(leftStack);\n            } else {\n                right = getRight(rightStack);\n            }\n        }\n        return false;\n    }\n\n    public TreeNode getLeft(Deque<TreeNode> stack) {\n        TreeNode root = stack.pop();\n        TreeNode node = root.right;\n        while (node != null) {\n            stack.push(node);\n            node = node.left;\n        }\n        return root;\n    }\n\n    public TreeNode getRight(Deque<TreeNode> stack) {\n        TreeNode root = stack.pop();\n        TreeNode node = root.left;\n        while (node != null) {\n            stack.push(node);\n            node = node.right;\n        }\n        return root;\n    }\n}\n```\n\n```C# [sol4-C#]\npublic class Solution {\n    public bool FindTarget(TreeNode root, int k) {\n        TreeNode left = root, right = root;\n        Stack<TreeNode> leftStack = new Stack<TreeNode>();\n        Stack<TreeNode> rightStack = new Stack<TreeNode>();\n        leftStack.Push(left);\n        while (left.left != null) {\n            leftStack.Push(left.left);\n            left = left.left;\n        }\n        rightStack.Push(right);\n        while (right.right != null) {\n            rightStack.Push(right.right);\n            right = right.right;\n        }\n        while (left != right) {\n            if (left.val + right.val == k) {\n                return true;\n            }\n            if (left.val + right.val < k) {\n                left = GetLeft(leftStack);\n            } else {\n                right = GetRight(rightStack);\n            }\n        }\n        return false;\n    }\n\n    public TreeNode GetLeft(Stack<TreeNode> stack) {\n        TreeNode root = stack.Pop();\n        TreeNode node = root.right;\n        while (node != null) {\n            stack.Push(node);\n            node = node.left;\n        }\n        return root;\n    }\n\n    public TreeNode GetRight(Stack<TreeNode> stack) {\n        TreeNode root = stack.Pop();\n        TreeNode node = root.left;\n        while (node != null) {\n            stack.Push(node);\n            node = node.right;\n        }\n        return root;\n    }\n}\n```\n\n```C [sol4-C]\n#define MAX_NODE_SIZE 1e4 \n\ntypedef struct {\n    struct TreeNode ** stBuf;\n    int stTop;\n    int stSize;\n} Stack;\n\nvoid init(Stack* obj, int stSize) {\n    obj->stBuf = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * stSize);\n    obj->stTop = 0;\n    obj->stSize = stSize;\n}\n\nbool isEmpty(const Stack* obj) {\n    return obj->stTop == 0;\n}\n\nstruct TreeNode * top(const Stack* obj) {\n    return obj->stBuf[obj->stTop - 1];\n}\n\nbool push(Stack * obj, struct TreeNode* val) {\n    if(obj->stTop == obj->stSize) {\n        return false;\n    }\n    obj->stBuf[obj->stTop++] = val;\n    return true;\n}\n\nvoid freeStack(Stack * obj) {\n    free(obj->stBuf);\n}\n\nstruct TreeNode * pop(Stack* obj) {\n    if(obj->stTop == 0) {\n        return NULL;\n    }\n    struct TreeNode *res = obj->stBuf[obj->stTop - 1];\n    obj->stTop--;\n    return res;\n}\n\nstruct TreeNode *getLeft(Stack* stk) {\n    struct TreeNode *root = pop(stk);\n    struct TreeNode *node = root->right;\n    while (node != NULL) {\n        push(stk, node);\n        node = node->left;\n    }\n    return root;\n}\n\nstruct TreeNode *getRight(Stack* stk) {\n    struct TreeNode *root = pop(stk);\n    struct TreeNode *node = root->left;\n    while (node != NULL) {\n        push(stk, node);\n        node = node->right;\n    }\n    return root;\n}\n\nbool findTarget(struct TreeNode* root, int k){\n    struct TreeNode *left = root, *right = root;\n    Stack leftStack, rightStack;\n    init(&leftStack, MAX_NODE_SIZE);\n    init(&rightStack, MAX_NODE_SIZE);\n    push(&leftStack, left);\n    while (left->left != NULL) {\n        push(&leftStack, left->left);\n        left = left->left;\n    }\n    push(&rightStack, right);\n    while (right->right != NULL) {\n        push(&rightStack, right->right);\n        right = right->right;\n    }\n    while (left != right) {\n        if (left->val + right->val == k) {\n            freeStack(&leftStack);\n            freeStack(&rightStack);\n            return true;\n        }\n        if (left->val + right->val < k) {\n            left = getLeft(&leftStack);\n        } else {\n            right = getRight(&rightStack);\n        }\n    }\n    freeStack(&leftStack);\n    freeStack(&rightStack);\n    return false;\n}\n```\n\n```JavaScript [sol4-JavaScript]\nvar findTarget = function(root, k) {\n    const getLeft = (stack) => {\n        const root = stack.pop();\n        let node = root.right;\n        while (node) {\n            stack.push(node);\n            node = node.left;\n        }\n        return root;\n    }\n\n    const getRight = (stack) => {\n        const root = stack.pop();\n        let node = root.left;\n        while (node) {\n            stack.push(node);\n            node = node.right;\n        }\n        return root;\n    };\n\n    let left = root, right = root;\n    const leftStack = [];\n    const rightStack = [];\n    leftStack.push(left);\n    while (left.left) {\n        leftStack.push(left.left);\n        left = left.left;\n    }\n    rightStack.push(right);\n    while (right.right) {\n        rightStack.push(right.right);\n        right = right.right;\n    }\n    while (left !== right) {\n        if (left.val + right.val === k) {\n            return true;\n        }\n        if (left.val + right.val < k) {\n            left = getLeft(leftStack);\n        } else {\n            right = getRight(rightStack);\n        }\n    }\n    return false;\n}\n```\n\n```go [sol4-Golang]\nfunc findTarget(root *TreeNode, k int) bool {\n    left, right := root, root\n    leftStk := []*TreeNode{left}\n    for left.Left != nil {\n        leftStk = append(leftStk, left.Left)\n        left = left.Left\n    }\n    rightStk := []*TreeNode{right}\n    for right.Right != nil {\n        rightStk = append(rightStk, right.Right)\n        right = right.Right\n    }\n    for left != right {\n        sum := left.Val + right.Val\n        if sum == k {\n            return true\n        }\n        if sum < k {\n            left = leftStk[len(leftStk)-1]\n            leftStk = leftStk[:len(leftStk)-1]\n            for node := left.Right; node != nil; node = node.Left {\n                leftStk = append(leftStk, node)\n            }\n        } else {\n            right = rightStk[len(rightStk)-1]\n            rightStk = rightStk[:len(rightStk)-1]\n            for node := right.Left; node != nil; node = node.Right {\n                rightStk = append(rightStk, node)\n            }\n        }\n    }\n    return false\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的大小。在双指针的过程中，我们实际上遍历了整棵树一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的大小。主要为栈的开销，最坏情况下二叉搜索树为一条链，需要 $O(n)$ 的栈空间。"
}