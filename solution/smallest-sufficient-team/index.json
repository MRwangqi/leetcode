{
	"titleSlug": "smallest-sufficient-team",
	"slug": "1125-zui-xiao-de-bi-yao-tuan-dui-by-wang-cwxc",
	"url": "https://leetcode-cn.com/problems/smallest-sufficient-team/solution/1125-zui-xiao-de-bi-yao-tuan-dui-by-wang-cwxc/",
	"content": "### 解题思路\n状态压缩动态规划，思路来源于「[状态压缩动态规划的入门题](https://leetcode.cn/problems/smallest-sufficient-team/solution/zhuang-tai-ya-suo-dong-tai-gui-hua-de-ru-men-ti-by/)」，学习的过程中写了个C#版本。\n\n### 代码实现\n```C# []\npublic class Solution {\n    public int[] SmallestSufficientTeam(string[] req_skills, IList<IList<string>> people) {\n        // 首先用字典为每个技能进行数字编码\n        int n = req_skills.Length;\n        var map = new Dictionary<string, int>();\n        for (int i = 0; i < n; i++)\n            map.Add(req_skills[i], i);\n        // 将每个人的技能也编码成技能组合的形式\n        int m = people.Count;\n        int[] skill = new int[m];\n        for (int i = 0; i < m; i++)\n            foreach (string x in people[i])\n                skill[i] |= 1 << map[x];\n        int mask = 1 << n;\n        // dp[i] 表示在技能需求编码为 i 的情况下的最优安排\n        List<int>[] dp = new List<int>[mask];\n        dp[0] = new List<int>();\n        // 这里用 maxSize 进行剪枝，之后枚举之前的状态时没必要每次都遍历到 mask，只需要遍历到当前已经更新过的最大技能编码即可\n        int maxSize = 0;\n        // 枚举每一个成员，将成员添加到相应的技能需求编码下\n        for (int i = 0; i < m; i++) {\n            // 如果当前成员没有任何技能，直接跳过\n            if (skill[i] == 0)\n                continue;\n            for (int j = 0; j <= maxSize; j++) {\n                // 如果当前成员可以为技能编码 j 增加新的技能（前提是编码 j 更新过）\n                if (dp[j] != null && (j | skill[i]) != j) {\n                    int k = j | skill[i];\n                    // 如果新的技能组合编码 k 还没有更新过或者从编码 j 转移而来的新的员工数（dp[j].Count + 1）小于先前的员工数 dp[k].Count，就更新 dp[k]（添加 i）\n                    if (dp[k] == null || dp[j].Count + 1 < dp[k].Count) {\n                        dp[k] = new List<int>(dp[j]);\n                        dp[k].Add(i);\n                    }  \n                }\n            }\n            // 更新当前已经达到的技能编码最大值\n            maxSize |= skill[i];\n        }\n        return dp[mask - 1].ToArray();\n    }\n}\n```"
}