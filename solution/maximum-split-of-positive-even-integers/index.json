{
	"titleSlug": "maximum-split-of-positive-even-integers",
	"slug": "chai-fen-cheng-zui-duo-shu-mu-de-ou-zhen-dntf",
	"url": "https://leetcode-cn.com/problems/maximum-split-of-positive-even-integers/solution/chai-fen-cheng-zui-duo-shu-mu-de-ou-zhen-dntf/",
	"content": "#### 方法一：贪心\n\n**提示 $1$**\n\n首先，如果一个数 $\\textit{finalSum}$ 是奇数，那么它一定无法被拆分成若干个偶整数（**要求为正数，下同**）。因此我们只需要考虑偶数。\n\n我们可以按照如下的方式对 $\\textit{finalSum}$ 拆分，拆分出来的偶整数数量一定是最多的：\n\n> 从**最小的偶整数**（$2$）开始依次尝试拆分，直到剩余的数值**小于等于**当前被拆分的**最大偶整数**为止。如果此时拆分后的 $\\textit{finalSum}$ 非零，则将这个数值加到最大的偶整数上。\n\n**提示 $1$ 解释**\n\n我们不妨假设 $\\textit{finalSum}$ 按照上文的方法被拆分成了 $k$ 个互不相同的偶整数，那么我们可以计算出 $\\textit{finalSum}$ 的上下界：\n\n$$\n\\textit{finalSum} \\ge \\sum_{i=1}^k 2 \\times i = k(k + 1),\n$$\n\n与\n\n$$\n\\textit{finalSum} \\le \\sum_{i=1}^{k} 2 \\times i + 2 \\times k = k(k + 3).\n$$\n\n在这里我们使用反证法，假设 $\\textit{finalSum}$ 被拆分成了 $k + 1$ 个互不相同的偶整数（拆分成更多的所需数值更大，故只考虑最小的个数），那么必定有：\n\n$$\n\\textit{finalSum} \\ge \\sum_{i=1}^{k+1} 2 \\times i = (k + 1)(k + 2).\n$$\n\n而 $(k + 1)(k + 2) = k^2 + 3k + 2 > k^2 + 3k = k (k + 3)$，高于前文计算出 $\\textit{finalSum}$ 的上界，这就产生了矛盾。因此，上文的拆分方法对应拆分出的互不相同偶整数数量一定是最多的。\n\n**思路与算法**\n\n根据 **提示 $1$**，我们可以模拟拆分的过程。首先，如果 $\\textit{finalSum}$ 为奇数，那么显然无法拆分，我们返回空数组即可。\n\n我们用 $\\textit{res}$ 数组来表示拆分后的偶整数。那么 $\\textit{res}$ 中必定有一个元素为 $2$，因此我们将 $2$ 添加进 $\\textit{res}$ ，并将 $\\textit{finalSum}$ 对应地减去 $2$。\n\n随后，只要当 $\\textit{finalSum}$ 大于 $\\textit{res}$ 数组末尾的元素时，我们就将该元素加上 $2$ 得到的值添加进数组，并将 $\\textit{finalSum}$ 减去对应的数值。最终，我们将 $\\textit{finalSum}$ 剩余的数值加在**当前的** 数组末尾的元素上，并返回 $\\textit{res}$ 数组作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<long long> maximumEvenSplit(long long finalSum) {\n        if (finalSum % 2) {\n            return {};\n        }\n        vector<long long> res = {2};\n        finalSum -= 2;\n        while (res.back() < finalSum) {\n            finalSum -= res.back() + 2;\n            res.push_back(res.back() + 2);\n        }\n        res.back() += finalSum;\n        return res;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\n        if finalSum % 2 != 0:\n            return []\n        res = [2]\n        finalSum -= 2\n        while res[-1] < finalSum:\n            finalSum -= res[-1] + 2\n            res.append(res[-1] + 2)\n        res[-1] += finalSum\n        return res\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\sqrt{n})$，其中 $n = \\textit{finalSum}$。即为拆分后的整数个数。\n\n   具体而言，若一个数想拆成 $k$ 个互不相同的偶数，则该数必定大于等于 $\\sum_{i = 1}^k 2 \\times i = k\\times(k + 1)$，因此对于整数 $n$，可以拆分成的互不相同偶数个数最多为 $O(\\sqrt{n})$ 个。\n\n- 空间复杂度：$O(1)$，输出数组不计入空间复杂度。"
}