{
	"titleSlug": "longest-nice-substring",
	"slug": "zui-chang-de-mei-hao-zi-zi-fu-chuan-by-l-4l1t",
	"url": "https://leetcode-cn.com/problems/longest-nice-substring/solution/zui-chang-de-mei-hao-zi-zi-fu-chuan-by-l-4l1t/",
	"content": "#### 方法一：枚举\n\n**思路**\n\n题目要求找到最长的美好子字符串，题目中给定的字符串 $s$ 的长度 $\\textit{length}$ 范围为 $1 \\le \\textit{length} \\le 100$。由于字符串的长度比较小，因此可以枚举所有可能的子字符串，然后检测该字符串是否为美好的字符串，并得到长度最长的美好字符串。\n\n+ 题目关于美好字符串的定义为: 字符串中的每个字母的大写和小写形式同时出现在该字符串中。检测时，由于英文字母 $\\texttt{`a'}-\\texttt{`z'}$ 最多只有 $26$ 个, 因此可以利用二进制位来进行标记，$\\textit{lower}$ 标记字符中出现过小写英文字母，$\\textit{upper}$ 标记字符中出现过大写英文字母。如果满足 $\\textit{lower} = \\textit{upper}$ ，我们则认为字符串中所有的字符都满足大小写形式同时出现，则认定该字符串为美好字符串。\n\n+ 题目要求如果有多个答案，返回在字符串中最早出现的那个。此时，只需要首先检测从以字符串索引 $0$ 为起始的子字符串。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public String longestNiceSubstring(String s) {\n        int n = s.length();\n        int maxPos = 0;\n        int maxLen = 0;\n        for (int i = 0; i < n; ++i) {\n            int lower = 0;\n            int upper = 0;\n            for (int j = i; j < n; ++j) {\n                if (Character.isLowerCase(s.charAt(j))) {\n                    lower |= 1 << (s.charAt(j) - 'a');\n                } else {\n                    upper |= 1 << (s.charAt(j) - 'A');\n                }\n                if (lower == upper && j - i + 1 > maxLen) {\n                    maxPos = i;\n                    maxLen = j - i + 1;\n                }\n            }\n        }\n        return s.substring(maxPos, maxPos + maxLen);\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string longestNiceSubstring(string s) {\n        int n = s.size();\n        int maxPos = 0;\n        int maxLen = 0;\n        for (int i = 0; i < n; ++i) {\n            int lower = 0;\n            int upper = 0;\n            for (int j = i; j < n; ++j) {\n                if (islower(s[j])) {\n                    lower |= 1 << (s[j] - 'a');\n                } else {\n                    upper |= 1 << (s[j] - 'A');\n                }\n                if (lower == upper && j - i + 1 > maxLen) {\n                    maxPos = i;\n                    maxLen = j - i + 1;\n                }\n            }\n        }\n        return s.substr(maxPos, maxLen);\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string LongestNiceSubstring(string s) {\n        int n = s.Length;\n        int maxPos = 0;\n        int maxLen = 0;\n        for (int i = 0; i < n; ++i) {\n            int lower = 0;\n            int upper = 0;\n            for (int j = i; j < n; ++j) {\n                if (char.IsLower(s[j])) {\n                    lower |= 1 << (s[j] - 'a');\n                } else {\n                    upper |= 1 << (s[j] - 'A');\n                }\n                if (lower == upper && j - i + 1 > maxLen) {\n                    maxPos = i;\n                    maxLen = j - i + 1;\n                }\n            }\n        }\n        return s.Substring(maxPos, maxLen);\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def longestNiceSubstring(self, s: str) -> str:\n        n = len(s)\n        maxPos, maxLen = 0, 0\n        for i in range(n):\n            lower, upper = 0, 0\n            for j in range(i, n):\n                if s[j].islower():\n                    lower |= 1 << (ord(s[j]) - ord('a'))\n                else:\n                    upper |= 1 << (ord(s[j]) - ord('A'))\n                if lower == upper and j - i + 1 > maxLen:\n                    maxPos = i\n                    maxLen = j - i + 1\n        return s[maxPos: maxPos + maxLen]\n```\n\n```C [sol1-C]\nchar * longestNiceSubstring(char * s){\n    int n = strlen(s);\n    int maxPos = 0;\n    int maxLen = 0;\n    for (int i = 0; i < n; ++i) {\n        int lower = 0;\n        int upper = 0;\n        for (int j = i; j < n; ++j) {\n            if (islower(s[j])) {\n                lower |= 1 << (s[j] - 'a');\n            } else {\n                upper |= 1 << (s[j] - 'A');\n            }\n            if (lower == upper && j - i + 1 > maxLen) {\n                maxPos = i;\n                maxLen = j - i + 1;\n            }\n        }\n    }\n    char * ans = (char *)malloc(sizeof(char) * (maxLen + 1));\n    strncpy(ans, s + maxPos, maxLen);\n    ans[maxLen] = '\\0';\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar longestNiceSubstring = function(s) {\n    const n = s.length;\n    let maxPos = 0;\n    let maxLen = 0;\n    for (let i = 0; i < n; ++i) {\n        let lower = 0;\n        let upper = 0;\n        for (let j = i; j < n; ++j) {\n            if ('a' <= s[j] && s[j] <= 'z') {\n                lower |= 1 << (s[j].charCodeAt() - 'a'.charCodeAt());\n            } else {\n                upper |= 1 << (s[j].charCodeAt() - 'A'.charCodeAt());\n            }\n            if (lower === upper && j - i + 1 > maxLen) {\n                maxPos = i;\n                maxLen = j - i + 1;\n            }\n        }\n    }\n    return s.slice(maxPos, maxPos + maxLen);\n};\n```\n\n```go [sol1-Golang]\nfunc longestNiceSubstring(s string) (ans string) {\n    for i := range s {\n        lower, upper := 0, 0\n        for j := i; j < len(s); j++ {\n            if unicode.IsLower(rune(s[j])) {\n                lower |= 1 << (s[j] - 'a')\n            } else {\n                upper |= 1 << (s[j] - 'A')\n            }\n            if lower == upper && j-i+1 > len(ans) {\n                ans = s[i : j+1]\n            }\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 为字符串的长度。需要枚举所有可能的子字符串，因此需要双重循环遍历字符串，总共可能有 $n^2$ 个连续的子字符串。\n\n- 空间复杂度：$O(1)$。由于返回值不需要计算空间复杂度，除了需要两个整数变量用来标记以外不需要额外的空间。\n\n#### 方法二：分治\n\n**思路**\n\n分治思想来源于「[395. 至少有K个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)」，详细的解法与其相似。题目要求找到最长的美好子字符串，如果字符串本身即合法的美好字符串，此时最长的完美字符串即为字符串本身。由于字符串中含有部分字符 $\\textit{ch}$ 只出现大写或者小写形式，如果字符串包含这些字符 $\\textit{ch}$ 时，可以判定该字符串肯定不为完美字符串。一个字符串为美好字符串的必要条件是不包含这些非法字符。因此我们可以利用分治的思想，将字符串从这些非法的字符处切分成若干段，则满足要求的最长子串一定出现在某个被切分的段内，而不能跨越一个或多个段。\n\n+ 递归时，$\\textit{maxPos}$ 用来记录最长完美字符串的起始索引，$\\textit{maxLen}$ 用来记录最长完美字符串的长度。\n\n+ 每次检查区间 $[\\textit{start}, \\textit{end}]$ 中的子字符串是否为完美字符串，如果当前的字符串为合法的完美字符串，则将当前区间的字符串的长度与 $\\textit{maxLen}$ 进行比较和替换；否则我们依次对当前字符串进行切分，然后递归检测切分后的字符串。\n\n**代码**\n\n```Java [sol2-Java]\nclass Solution {\n    private int maxPos;\n    private int maxLen;\n\n    public String longestNiceSubstring(String s) {\n        this.maxPos = 0;\n        this.maxLen = 0;\n        dfs(s, 0, s.length() - 1);\n        return s.substring(maxPos, maxPos + maxLen);\n    }\n\n    public void dfs(String s, int start, int end) {\n        if (start >= end) {\n            return;\n        }\n        int lower = 0, upper = 0;\n        for (int i = start; i <= end; ++i) {\n            if (Character.isLowerCase(s.charAt(i))) {\n                lower |= 1 << (s.charAt(i) - 'a');\n            } else {\n                upper |= 1 << (s.charAt(i) - 'A');\n            }\n        }\n        if (lower == upper) {\n            if (end - start + 1 > maxLen) {\n                maxPos = start;\n                maxLen = end - start + 1;\n            }\n            return;\n        } \n        int valid = lower & upper;\n        int pos = start;\n        while (pos <= end) {\n            start = pos;\n            while (pos <= end && (valid & (1 << Character.toLowerCase(s.charAt(pos)) - 'a')) != 0) {\n                ++pos;\n            }\n            dfs(s, start, pos - 1);\n            ++pos;\n        }\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    void dfs(const string & s, int start, int end, int & maxPos, int & maxLen) {\n        if (start >= end) {\n            return;\n        }\n        int lower = 0, upper = 0;\n        for (int i = start; i <= end; ++i) {\n            if (islower(s[i])) {\n                lower |= 1 << (s[i] - 'a');\n            } else {\n                upper |= 1 << (s[i] - 'A');\n            }\n        }\n        if (lower == upper) {\n            if (end - start + 1 > maxLen) {\n                maxPos = start;\n                maxLen = end - start + 1;\n            }\n            return;\n        } \n        int valid = lower & upper;\n        int pos = start;\n        while (pos <= end) {\n            start = pos;\n            while (pos <= end && valid & (1 << (tolower(s[pos]) - 'a'))) {\n                ++pos;\n            }\n            dfs(s, start, pos - 1, maxPos, maxLen);\n            ++pos;\n        }\n    }\n\n    string longestNiceSubstring(string s) {\n        int maxPos = 0, maxLen = 0;\n        dfs(s, 0, s.size() - 1, maxPos, maxLen);\n        return s.substr(maxPos, maxLen);\n    }\n};\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    private int maxPos;\n    private int maxLen;\n\n    public string LongestNiceSubstring(string s) {\n        this.maxPos = 0;\n        this.maxLen = 0;\n        DFS(s, 0, s.Length - 1);\n        return s.Substring(maxPos, maxLen);\n    }\n\n    public void DFS(String s, int start, int end) {\n        if (start >= end) {\n            return;\n        }\n        int lower = 0, upper = 0;\n        for (int i = start; i <= end; ++i) {\n            if (char.IsLower(s[i])) {\n                lower |= 1 << (s[i] - 'a');\n            } else {\n                upper |= 1 << (s[i] - 'A');\n            }\n        }\n        if (lower == upper) {\n            if (end - start + 1 > maxLen) {\n                maxPos = start;\n                maxLen = end - start + 1;\n            }\n            return;\n        } \n        int valid = lower & upper;\n        int pos = start;\n        while (pos <= end) {\n            start = pos;\n            while (pos <= end && (valid & (1 << char.ToLower(s[pos]) - 'a')) != 0) {\n                ++pos;\n            }\n            DFS(s, start, pos - 1);\n            ++pos;\n        }\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def longestNiceSubstring(self, s: str) -> str:\n        maxPos, maxLen = 0, 0\n        def dfs(start, end):\n            nonlocal maxPos, maxLen\n            if start >= end:\n                return\n            lower, upper = 0, 0\n            for i in range(start, end + 1):\n                if s[i].islower():\n                    lower|= 1 << (ord(s[i]) - ord('a'))\n                else:\n                    upper|= 1 << (ord(s[i]) - ord('A'))\n            if lower == upper:\n                if end - start + 1 > maxLen:\n                    maxPos, maxLen = start, end - start + 1\n                return\n            pos, valid = start, lower & upper\n            while pos <= end:\n                start = pos\n                while pos <= end and valid & (1 << (ord(s[pos].lower()) - ord('a'))):\n                    pos += 1\n                dfs(start, pos - 1)\n                pos += 1\n        dfs(0, len(s) - 1)\n        return s[maxPos : maxPos + maxLen]\n```\n\n```C [sol2-C]\nvoid dfs(const char * s, int start, int end, int * maxPos, int * maxLen) {\n    if (start >= end) {\n        return;\n    }\n    int lower = 0, upper = 0;\n    for (int i = start; i <= end; ++i) {\n        if (islower(s[i])) {\n            lower |= 1 << (s[i] - 'a');\n        } else {\n            upper |= 1 << (s[i] - 'A');\n        }\n    }\n    if (lower == upper) {\n        if (end - start + 1 > *maxLen ) {\n            *maxPos = start;\n            *maxLen = end - start + 1;\n        }\n        return;\n    } \n    int valid = lower & upper;\n    int pos = start;\n    while (pos <= end) {\n        start = pos;\n        while (pos <= end && valid & (1 << (tolower(s[pos]) - 'a'))) {\n            ++pos;\n        }\n        dfs(s, start, pos - 1, maxPos, maxLen);\n        ++pos;\n    }\n}\n\nchar * longestNiceSubstring(char * s){\n    int maxPos = 0, maxLen = 0;\n    dfs(s, 0, strlen(s) - 1, &maxPos, &maxLen);\n    s[maxPos + maxLen] = '\\0';\n    return s + maxPos;\n}\n```\n\n```go [sol2-Golang]\nfunc longestNiceSubstring(s string) (ans string) {\n    if s == \"\" {\n        return\n    }\n    lower, upper := 0, 0\n    for _, ch := range s {\n        if unicode.IsLower(ch) {\n            lower |= 1 << (ch - 'a')\n        } else {\n            upper |= 1 << (ch - 'A')\n        }\n    }\n    if lower == upper {\n        return s\n    }\n    valid := lower & upper\n    for i := 0; i < len(s); i++ {\n        start := i\n        for i < len(s) && valid>>(unicode.ToLower(rune(s[i]))-'a')&1 == 1 {\n            i++\n        }\n        if t := longestNiceSubstring(s[start:i]); len(t) > len(ans) {\n            ans = t\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\cdot |\\Sigma|)$，其中 $n$ 为字符串的长度，$|\\Sigma|$ 为字符集的大小，本题中字符串仅包含英文大小写字母，因此 $|\\Sigma| = 52$。本题使用了递归，由于字符集最多只有 $\\dfrac{|\\Sigma|}{2}$ 个不同的英文字母，每次递归都会去掉一个英文字母的所有大小写形式，因此递归深度最多为 $\\dfrac{|\\Sigma|}{2}$。\n\n- 空间复杂度：$O(|\\Sigma|)$。由于递归深度最多为 $|\\Sigma|$，因此需要使用 $O(|\\Sigma|)$ 的递归栈空间。\n\n#### 方法三：滑动窗口\n\n**思路**\n\n滑动窗口的解法同样参考「[395. 至少有K个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)」。\n我们枚举最长子串中的字符种类数目，它最小为 $1$，最大为 $\\dfrac{|\\Sigma|}{2}$，其中同一个字符的大小写形式视为同一种字符。\n\n对于给定的字符种类数量 $\\textit{typeNum}$，我们维护滑动窗口的左右边界 $l,r$、滑动窗口内部大小字符出现的次数 $\\textit{upperCnt}, \\textit{lowerCnt}$，以及滑动窗口内的字符种类数目 $\\textit{total}$。当 $\\textit{total} > \\textit{typeNum}$ 时，我们不断地右移左边界 $l$，并对应地更新 $\\textit{upperCnt}, \\textit{lowerCnt}$ 以及 $\\textit{total}$，直到 $\\textit{total} \\le \\textit{typeNum}$ 为止。这样，对于任何一个右边界 $r$，我们都能找到最小的 $l$（记为 $l_{min}$，使得 $s[l_{min}...r]$ 之间的字符种类数目不多于 $\\textit{typeNum}$。\n\n完美字符串定义为所有的字符同时出现大写和小写形式，最长的完美字符串一定出现在某个窗口中。对于任何一组 $l_{min}, r$ 而言，我们需要判断当前 $s[l_{min}...r]$ 是否为完美字符串，检测方法如下：\n\n+ 当前字符串中的字符种类数量为 $\\textit{typeNum}$，当前字符串中同时出现大小写的字符的种类数量为 $\\textit{cnt}$，只有满足 $\\textit{cnt}$ 等于 $\\textit{typeNum}$ 时，我们可以判定字符串为完美字符串。\n\n+ 遍历 $\\textit{upperCnt}, \\textit{lowerCnt}$ 两个数组，第 $i$ 个字符同时满足 $\\textit{upperCnt}[i] > 0, \\textit{lowerCnt}[i] > 0$ 时，则认为第 $i$ 个字符的大小写形式同时出现。\n\n根据上面的结论，当限定字符种类数目为 $\\textit{typeNum}$ 时，满足题意的最长子串，就一定出自某个 $s[l_{min}...r]$。因此，在滑动窗口的维护过程中，就可以直接得到最长子串的大小。\n\n最后，还剩下一个细节：如何在滑动窗口的同时高效地维护 $\\textit{total}$ 和 $\\textit{cnt}$。\n\n+ 右移右边界 $r$ 时，假设 $s[r]$ 对应的字符的索引为 $\\textit{idx}$，当满足 $\\textit{upperCnt}[r] + \\textit{lowerCnt}[r] = 1$ 时，则我们认为此时新增了一种字符，将 $\\textit{total}$ 加 $1$。\n\n+ 右移右边界 $r$ 时，假设 $s[r]$ 对应的字符的索引为 $\\textit{idx}$，如果 $s[r]$ 为小写字母，右移右边界后，当满足 $\\textit{lowerCnt}[idx] = 1$ 且 $\\textit{upperCnt}[idx] > 0$ 时，则我们认为此时新增了一种大小写同时存在的字符，将 $\\textit{cnt}$ 加 $1$；如果 $s[r]$ 为大写字母，右移右边界后，当满足 $\\textit{upperCnt}[idx] = 1$ 且 $\\textit{lowerCnt}[idx] > 0$ 时，则我们认为此时新增了一种大小写同时存在的字符，将 $\\textit{cnt}$ 加 $1$。\n\n+ 右移左边界 $l$ 时，假设 $s[l]$ 对应的字符的索引为 $\\textit{idx}$，当满足 $\\textit{upperCnt}[idx] + \\textit{lowerCnt}[idx] = 1$ 时，右移左边界后则我们认为此时将减少一种字符，将 $\\textit{total}$ 减 $1$。\n\n+ 右移左边界 $l$ 时，假设 $s[l]$ 对应的字符的索引为 $\\textit{idx}$，如果 $s[l]$ 为小写字母，右移左边界后，当满足 $\\textit{lowerCnt}[idx] = 0$ 且 $\\textit{upperCnt}[idx] > 0$ 时，则我们认为此时减少了一种大小写同时存在的字符，将 $\\textit{cnt}$ 减 $1$；如果 $s[l]$ 为大写字母，右移左边界后，当满足 $\\textit{upperCnt}[idx] = 0$ 且 $\\textit{lowerCnt}[idx] > 0$ 时，则我们认为此时减少了一种大小写同时存在的字符，将 $\\textit{cnt}$ 减 $1$。\n\n\n**代码**\n\n```Java [sol3-Java]\nclass Solution {\n    private int maxPos;\n    private int maxLen;\n\n    public String longestNiceSubstring(String s) {\n        this.maxPos = 0;\n        this.maxLen = 0;\n        \n        int types = 0;\n        for (int i = 0; i < s.length(); ++i) {\n            types |= 1 << (Character.toLowerCase(s.charAt(i)) - 'a');\n        }\n        types = Integer.bitCount(types);\n        for (int i = 1; i <= types; ++i) {\n            check(s, i);\n        }\n        return s.substring(maxPos, maxPos + maxLen);\n    }\n\n    public void check(String s, int typeNum) {\n        int[] lowerCnt = new int[26];\n        int[] upperCnt = new int[26]; \n        int cnt = 0;\n        for (int l = 0, r = 0, total = 0; r < s.length(); ++r) {\n            int idx = Character.toLowerCase(s.charAt(r)) - 'a';\n            if (Character.isLowerCase(s.charAt(r))) {\n                ++lowerCnt[idx];\n                if (lowerCnt[idx] == 1 && upperCnt[idx] > 0) {\n                    ++cnt;\n                }\n            } else {\n                ++upperCnt[idx];\n                if (upperCnt[idx] == 1 && lowerCnt[idx] > 0) {\n                    ++cnt;\n                }\n            }\n            total += (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0;\n            while (total > typeNum) {\n                idx = Character.toLowerCase(s.charAt(l)) - 'a';\n                total -= (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0;\n                if (Character.isLowerCase(s.charAt(l))) {\n                    --lowerCnt[idx];\n                    if (lowerCnt[idx] == 0 && upperCnt[idx] > 0) {\n                        --cnt;\n                    }\n                } else {\n                    --upperCnt[idx];\n                    if (upperCnt[idx] == 0 && lowerCnt[idx] > 0) {\n                        --cnt;\n                    }\n                }\n                ++l;\n            }\n            if (cnt == typeNum && r - l + 1 > maxLen) {\n                maxPos = l;\n                maxLen = r - l + 1;\n            }\n        }\n    }\n}\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    string longestNiceSubstring(string s) {\n        int maxPos = 0, maxLen = 0;\n        auto check = [&](int typeNum) {\n            vector<int> lowerCnt(26);\n            vector<int> upperCnt(26);\n            int cnt = 0;\n            for (int l = 0, r = 0, total = 0; r < s.size(); ++r) {\n                int idx = tolower(s[r]) - 'a';\n                if (islower(s[r])) {\n                    ++lowerCnt[idx];\n                    if (lowerCnt[idx] == 1 && upperCnt[idx] > 0) {\n                        ++cnt;\n                    }\n                } else {\n                    ++upperCnt[idx];\n                    if (upperCnt[idx] == 1 && lowerCnt[idx] > 0) {\n                        ++cnt;\n                    }\n                }\n                total += (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0;\n\n                while (total > typeNum) {\n                    idx = tolower(s[l]) - 'a';\n                    total -= (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0;\n                    if (islower(s[l])) {\n                        --lowerCnt[idx];\n                        if (lowerCnt[idx] == 0 && upperCnt[idx] > 0) {\n                            --cnt;\n                        }\n                    } else {\n                        --upperCnt[idx];\n                        if (upperCnt[idx] == 0 && lowerCnt[idx] > 0) {\n                            --cnt;\n                        }\n                    }\n                    ++l;\n                }\n                if (cnt == typeNum && r - l + 1 > maxLen) {\n                    maxPos = l;\n                    maxLen = r - l + 1;\n                }\n            }\n        };\n\n        int mask = 0;\n        for (char & ch : s) {\n            mask |= 1 << (tolower(ch) - 'a');\n        }\n        int types = __builtin_popcount(mask);\n        for (int i = 1; i <= types; ++i) {\n            check(i);\n        }\n        return s.substr(maxPos, maxLen);\n    }\n};\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    private int maxPos;\n    private int maxLen;\n\n    public string LongestNiceSubstring(string s) {\n        this.maxPos = 0;\n        this.maxLen = 0;\n        \n        int types = 0;\n        for (int i = 0; i < s.Length; ++i) {\n            types |= 1 << (char.ToLower(s[i]) - 'a');\n        }\n        types = Count((uint) types);\n        for (int i = 1; i <= types; ++i) {\n            Check(s, i);\n        }\n        return s.Substring(maxPos, maxLen);\n    }\n\n    public void Check(string s, int typeNum) {\n        int[] lowerCnt = new int[26];\n        int[] upperCnt = new int[26];\n        int cnt = 0;\n        for (int l = 0, r = 0, total = 0; r < s.Length; ++r) {\n            int idx = char.ToLower(s[r]) - 'a';\n            if (char.IsLower(s[r])) {\n                ++lowerCnt[idx];\n                if (lowerCnt[idx] == 1 && upperCnt[idx] > 0) {\n                    ++cnt;\n                }\n            } else {\n                ++upperCnt[idx];\n                if (upperCnt[idx] == 1 && lowerCnt[idx] > 0) {\n                    ++cnt;\n                }\n            }\n            total += (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0;\n\n            while (total > typeNum) {\n                idx = char.ToLower(s[l]) - 'a';\n                total -= (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0;\n                if (char.IsLower(s[l])) {\n                    --lowerCnt[idx];\n                    if (lowerCnt[idx] == 0 && upperCnt[idx] > 0) {\n                        --cnt;\n                    }\n                } else {\n                    --upperCnt[idx];\n                    if (upperCnt[idx] == 0 && lowerCnt[idx] > 0) {\n                        --cnt;\n                    }\n                }\n                ++l;\n            }\n            if (cnt == typeNum && r - l + 1 > maxLen) {\n                maxPos = l;\n                maxLen = r - l + 1;\n            }\n        }\n    }\n\n    public static int Count(uint x) {\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0f0f0f0f;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        return (int) x & 0x3f;\n    }\n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def longestNiceSubstring(self, s: str) -> str:\n        def check(typeNum):\n            nonlocal maxPos, maxLen\n            lowerCnt = [0] * 26\n            upperCnt = [0] * 26\n            l, r, total, cnt = 0, 0, 0, 0\n            while r < len(s):\n                idx = ord(s[r].lower()) - ord('a')\n                if s[r].islower():\n                    lowerCnt[idx] += 1\n                    if lowerCnt[idx] == 1 and upperCnt[idx] > 0:\n                        cnt += 1\n                else:\n                    upperCnt[idx] += 1\n                    if upperCnt[idx] == 1 and lowerCnt[idx] > 0:\n                        cnt += 1\n                if lowerCnt[idx] + upperCnt[idx] == 1:\n                    total += 1\n\n                while total > typeNum :\n                    idx = ord(s[l].lower()) - ord('a')\n                    if lowerCnt[idx] + upperCnt[idx] == 1:\n                        total -= 1\n                    if s[l].islower():\n                        lowerCnt[idx] -= 1\n                        if lowerCnt[idx] == 0 and upperCnt[idx] > 0:\n                            cnt -= 1\n                    else:\n                        upperCnt[idx] -= 1\n                        if upperCnt[idx] == 0 and lowerCnt[idx] > 0:\n                            cnt -= 1\n                    l += 1\n                if cnt == typeNum and r - l + 1 > maxLen:\n                    maxPos, maxLen = l, r - l + 1\n                r += 1\n        \n        maxPos, maxLen = 0, 0\n        types = len(set(s.lower()))\n        for i in range(1, types + 1):\n            check(i)\n        return s[maxPos: maxPos + maxLen]\n```\n\n```C [sol3-C]\nvoid check(const char * s, int typeNum, int * maxPos, int * maxLen) {\n    int lowerCnt[26], upperCnt[26];\n    memset(lowerCnt, 0, sizeof(lowerCnt));\n    memset(upperCnt, 0, sizeof(upperCnt));\n    int n = strlen(s);\n    int cnt = 0;\n    for (int l = 0, r = 0, total = 0; r < n; ++r) {\n        int idx = tolower(s[r]) - 'a';\n        if (islower(s[r])) {\n            ++lowerCnt[idx];\n            if (lowerCnt[idx] == 1 && upperCnt[idx] > 0) {\n                ++cnt;\n            }\n        } else {\n            ++upperCnt[idx];\n            if (upperCnt[idx] == 1 && lowerCnt[idx] > 0) {\n                ++cnt;\n            }\n        }\n        total += (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0;\n        \n        while (total > typeNum) {\n            int idx = tolower(s[l]) - 'a';\n            total -= (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0;\n            if (islower(s[l])) {\n                --lowerCnt[idx];\n                if (lowerCnt[idx] == 0 && upperCnt[idx] > 0) {\n                    --cnt;\n                }\n            } else {\n                --upperCnt[idx];\n                if (upperCnt[idx] == 0 && lowerCnt[idx] > 0) {\n                    --cnt;\n                }\n            }\n            ++l;\n        }\n        if (cnt == typeNum && r - l + 1 > *maxLen) {\n            *maxPos = l;\n            *maxLen = r - l + 1;\n        }\n    }\n}\n\nchar * longestNiceSubstring(char * s){\n    int maxPos = 0, maxLen = 0;\n    int mask = 0;\n    int n = strlen(s);\n    for (int i = 0; i < n; ++i) {\n        mask |= 1 << (tolower(s[i]) - 'a');\n    }\n    int types = __builtin_popcount(mask);\n    for (int i = 1; i <= types; ++i) {\n        check(s, i, &maxPos, &maxLen);\n    }\n    s[maxPos + maxLen] = '\\0';\n    return s + maxPos;\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar longestNiceSubstring = function(s) {\n    this.maxPos = 0;\n    this.maxLen = 0;\n    \n    let types = 0;\n    for (let i = 0; i < s.length; ++i) {\n        types |= 1 << (s[i].toLowerCase().charCodeAt() - 'a'.charCodeAt());\n    }\n    types = bitCount(types);\n    for (let i = 1; i <= types; ++i) {\n        check(s, i);\n    }\n    return s.slice(maxPos, maxPos + maxLen);\n};\n\nconst check = (s, typeNum) => {\n    const lowerCnt = new Array(26).fill(0);\n    const upperCnt = new Array(26).fill(0);\n    let cnt = 0;\n    for (let l = 0, r = 0, total = 0; r < s.length; ++r) {\n        let idx = s[r].toLowerCase().charCodeAt() - 'a'.charCodeAt();\n        if ('a' <= s[r] && s[r] <= 'z') {\n            ++lowerCnt[idx];\n            if (lowerCnt[idx] === 1 && upperCnt[idx] > 0) {\n                ++cnt;\n            }\n        } else {\n            ++upperCnt[idx];\n            if (upperCnt[idx] === 1 && lowerCnt[idx] > 0) {\n                ++cnt;\n            }\n        }\n        total += (lowerCnt[idx] + upperCnt[idx]) === 1 ? 1 : 0;\n        while (total > typeNum) {\n            idx = s[l].toLowerCase().charCodeAt() - 'a'.charCodeAt();\n            total -= (lowerCnt[idx] + upperCnt[idx]) === 1 ? 1 : 0;\n            if ('a' <= s[l] && s[l] <= 'z') {\n                --lowerCnt[idx];\n                if (lowerCnt[idx] === 0 && upperCnt[idx] > 0) {\n                    --cnt;\n                }\n            } else {\n                --upperCnt[idx];\n                if (upperCnt[idx] === 0 && lowerCnt[idx] > 0) {\n                    --cnt;\n                }\n            }\n            ++l;\n        }\n        if (cnt === typeNum && r - l + 1 > maxLen) {\n            maxPos = l;\n            maxLen = r - l + 1;\n        }\n    }\n}\n\nvar bitCount = function(n) {\n    let ret = 0;\n    while (n) {\n        n &= n - 1;\n        ret++;\n    }\n    return ret;\n};\n```\n\n```go [sol3-Golang]\nfunc longestNiceSubstring(s string) (ans string) {\n    mask := uint(0)\n    for _, ch := range s {\n        mask |= 1 << (unicode.ToLower(ch) - 'a')\n    }\n    maxTypeNum := bits.OnesCount(mask)\n\n    for typeNum := 1; typeNum <= maxTypeNum; typeNum++ {\n        var lowerCnt, upperCnt [26]int\n        var total, cnt, l int\n        for r, ch := range s {\n            idx := unicode.ToLower(ch) - 'a'\n            if unicode.IsLower(ch) {\n                lowerCnt[idx]++\n                if lowerCnt[idx] == 1 && upperCnt[idx] > 0 {\n                    cnt++\n                }\n            } else {\n                upperCnt[idx]++\n                if upperCnt[idx] == 1 && lowerCnt[idx] > 0 {\n                    cnt++\n                }\n            }\n            if lowerCnt[idx]+upperCnt[idx] == 1 {\n                total++\n            }\n\n            for total > typeNum {\n                idx := unicode.ToLower(rune(s[l])) - 'a'\n                if lowerCnt[idx]+upperCnt[idx] == 1 {\n                    total--\n                }\n                if unicode.IsLower(rune(s[l])) {\n                    lowerCnt[idx]--\n                    if lowerCnt[idx] == 0 && upperCnt[idx] > 0 {\n                        cnt--\n                    }\n                } else {\n                    upperCnt[idx]--\n                    if upperCnt[idx] == 0 && lowerCnt[idx] > 0 {\n                        cnt--\n                    }\n                }\n                l++\n            }\n\n            if cnt == typeNum && r-l+1 > len(ans) {\n                ans = s[l : r+1]\n            }\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N \\cdot |\\Sigma|)$，其中 $N$ 为字符串的长度，$|\\Sigma|$ 为字符集的大小，本题中字符集限定为大小写英文字母，$|\\Sigma| = 52$。我们需要遍历所有可能的字符种类数量，共 $\\dfrac{|\\Sigma|}{2}$ 种可能性，内层循环中滑动窗口的复杂度为 $O(2N)$，因此总的时间复杂度为 $O(N \\cdot |\\Sigma|)$ 。\n\n- 空间复杂度：$O(|\\Sigma|)$。需要 $O(|\\Sigma|)$ 存储所有大小写字母的计数。"
}