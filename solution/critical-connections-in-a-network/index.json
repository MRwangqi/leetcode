{
	"titleSlug": "critical-connections-in-a-network",
	"slug": "by-stormsunshine-nw8o",
	"url": "https://leetcode-cn.com/problems/critical-connections-in-a-network/solution/by-stormsunshine-nw8o/",
	"content": "# 解法\r\n\r\n## 思路和算法\r\n\r\n首先考虑关键连接的性质。考虑一条连接 $[a, b]$ 是关键连接和不是关键连接的情况。\r\n\r\n- 如果 $[a, b]$ 是关键连接，则去掉该连接之后，$a$ 和 $b$ 之间不可访问，因此 $[a, b]$ 不在环内。\r\n\r\n- 如果 $[a, b]$ 不是关键连接，则去掉该连接之后，$a$ 和 $b$ 之间仍可通过其他连接访问，因此 $[a, b]$ 在环内。\r\n\r\n根据关键连接的性质可知，一条连接是关键连接等价于这条连接不在环内，因此查找集群内的所有的关键连接等价于查找集群内的所有不在环内的连接。\r\n\r\n可以使用深度优先搜索判断集群内的每条连接是否在环内。由于给定的集群是连通图，因此只需要从服务器 $0$ 开始搜索即可。\r\n\r\n由于题目中的集群的表示方式是边数组，为了方便处理，需要首先将边数组转换成邻接列表的形式，转换后可以在 $O(1)$ 时间得到一个服务器的全部相邻服务器，然后使用深度优先搜索遍历集群。\r\n\r\n为了判断一条连接是否在环内，需要记录每台服务器的首次访问时间，规定起点服务器 $0$ 的首次访问时间是 $0$。如果一条连接不在环内，则每次访问的服务器的访问时间是上一次访问的服务器的访问时间加 $1$。如果一条连接在环内，则沿着环依次访问每条连接，将会回到环的入口，环的入口处的服务器的访问时间小于环内其他服务器的访问时间，由此可以发现环。\r\n\r\n由于只有当环存在时才会出现下一次访问的服务器的访问时间小于当前服务器的访问时间的情况，因此可以记录每台服务器及其下一次访问的服务器的首次访问时间，根据访问时间判断每条链接是否在环内。\r\n\r\n用数组 $\\textit{visitTimes}$ 记录每台服务器及其下一次访问的服务器的首次访问时间，初始时数组 $\\textit{visitTimes}$ 中的元素初始化为 $-1$，表示未访问。用 $\\textit{prev}$ 表示上一次访问的服务器，用 $\\textit{curr}$ 表示当前访问的服务器，当 $\\textit{visitTimes}[\\textit{curr}] < 0$ 时，执行如下操作。\r\n\r\n1. 将访问时间加 $1$，用 $\\textit{currTime}$ 表示当前访问时间，将 $\\textit{visitTimes}[\\textit{curr}]$ 更新为 $\\textit{currTime}$。\r\n\r\n2. 对于每个与 $\\textit{curr}$ 相邻的服务器 $\\textit{next}$，当 $\\textit{next} \\ne \\textit{prev}$ 时，$\\textit{next}$ 是下一次访问的服务器，对 $\\textit{next}$ 递归调用深度优先搜索得到访问时间 $\\textit{nextTime}$，如果 $\\textit{nextTime} < \\textit{visitTimes}[\\textit{curr}]$ 则用 $\\textit{nextTime}$ 更新 $\\textit{visitTimes}[\\textit{curr}]$ 的值。\r\n\r\n3. 对于每个 $\\textit{next}$，如果 $\\textit{nextTime} > \\textit{currTime}$，则连接 $[\\textit{curr}, \\textit{next}]$ 不在环内，因此是关键连接，将该连接添加到答案中。\r\n\r\n遍历结束之后，即可得到集群内的所有的关键连接。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    List<List<Integer>> critical = new ArrayList<List<Integer>>();\r\n    List<Integer>[] adjacentArr;\r\n    int[] visitTimes;\r\n    int time = -1;\r\n\r\n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\r\n        adjacentArr = new List[n];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new ArrayList<Integer>();\r\n        }\r\n        for (List<Integer> connection : connections) {\r\n            adjacentArr[connection.get(0)].add(connection.get(1));\r\n            adjacentArr[connection.get(1)].add(connection.get(0));\r\n        }\r\n        visitTimes = new int[n];\r\n        Arrays.fill(visitTimes, -1);\r\n        dfs(0, -1);\r\n        return critical;\r\n    }\r\n\r\n    public int dfs(int curr, int prev) {\r\n        if (visitTimes[curr] < 0) {\r\n            time++;\r\n            int currTime = time;\r\n            visitTimes[curr] = currTime;\r\n            List<Integer> adjacent = adjacentArr[curr];\r\n            for (int next : adjacent) {\r\n                if (next == prev) {\r\n                    continue;\r\n                }\r\n                int nextTime = dfs(next, curr);\r\n                visitTimes[curr] = Math.min(visitTimes[curr], nextTime);\r\n                if (nextTime > currTime) {\r\n                    List<Integer> connection = new ArrayList<Integer>();\r\n                    connection.add(curr);\r\n                    connection.add(next);\r\n                    critical.add(connection);\r\n                }\r\n            }\r\n        }\r\n        return visitTimes[curr];\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    IList<IList<int>> critical = new List<IList<int>>();\r\n    IList<int>[] adjacentArr;\r\n    int[] visitTimes;\r\n    int time = -1;\r\n\r\n    public IList<IList<int>> CriticalConnections(int n, IList<IList<int>> connections) {\r\n        adjacentArr = new IList<int>[n];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new List<int>();\r\n        }\r\n        foreach (IList<int> connection in connections) {\r\n            adjacentArr[connection[0]].Add(connection[1]);\r\n            adjacentArr[connection[1]].Add(connection[0]);\r\n        }\r\n        visitTimes = new int[n];\r\n        Array.Fill(visitTimes, -1);\r\n        DFS(0, -1);\r\n        return critical;\r\n    }\r\n\r\n    public int DFS(int curr, int prev) {\r\n        if (visitTimes[curr] < 0) {\r\n            time++;\r\n            int currTime = time;\r\n            visitTimes[curr] = currTime;\r\n            IList<int> adjacent = adjacentArr[curr];\r\n            foreach (int next in adjacent) {\r\n                if (next == prev) {\r\n                    continue;\r\n                }\r\n                int nextTime = DFS(next, curr);\r\n                visitTimes[curr] = Math.Min(visitTimes[curr], nextTime);\r\n                if (nextTime > currTime) {\r\n                    IList<int> connection = new List<int>();\r\n                    connection.Add(curr);\r\n                    connection.Add(next);\r\n                    critical.Add(connection);\r\n                }\r\n            }\r\n        }\r\n        return visitTimes[curr];\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n + m)$，其中 $n$ 是服务器数，$m$ 是连接数。将边数组转换成邻接列表需要 $O(n + m)$ 的时间，深度优先搜索需要 $O(n + m)$ 的时间。\r\n\r\n- 空间复杂度：$O(n + m)$，其中 $n$ 是服务器数，$m$ 是连接数。邻接链表需要 $O(n + m)$ 的空间，记录访问时间的数组和递归调用栈需要 $O(n)$ 的空间。"
}