{
	"titleSlug": "reverse-only-letters",
	"slug": "jin-jin-fan-zhuan-zi-mu-by-leetcode-solu-db20",
	"url": "https://leetcode-cn.com/problems/reverse-only-letters/solution/jin-jin-fan-zhuan-zi-mu-by-leetcode-solu-db20/",
	"content": "#### 方法一：双指针\n\n**思路与算法**\n\n我们使用 $\\textit{left}$ 指针从左边开始扫描字符串 $s$，$\\textit{right}$ 指针从右边开始扫描字符串 $s$。如果两个指针都扫描到字母，且 $\\textit{left} < \\textit{right}$，那么交换 $s[\\textit{left}]$ 和 $s[\\textit{right}]$，然后继续进行扫描；否则表明反转过程结束，返回处理后的字符串。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def reverseOnlyLetters(self, s: str) -> str:\n        ans = list(s)\n        left, right = 0, len(ans) - 1\n        while True:\n            while left < right and not ans[left].isalpha():  # 判断左边是否扫描到字母\n                left += 1\n            while right > left and not ans[right].isalpha():  # 判断右边是否扫描到字母\n                right -= 1\n            if left >= right:\n                break\n            ans[left], ans[right] = ans[right], ans[left]\n            left += 1\n            right -= 1\n        return ''.join(ans)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string reverseOnlyLetters(string s) {\n        int n = s.size();\n        int left = 0, right = n - 1;\n        while (true) {\n            while (left < right && !isalpha(s[left])) { // 判断左边是否扫描到字母\n                left++;\n            }\n            while (right > left && !isalpha(s[right])) { // 判断右边是否扫描到字母\n                right--;\n            }\n            if (left >= right) {\n                break;\n            }\n            swap(s[left], s[right]);\n            left++;\n            right--;\n        }\n        return s;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String reverseOnlyLetters(String s) {\n        int n = s.length();\n        char[] arr = s.toCharArray();\n        int left = 0, right = n - 1;\n        while (true) {\n            while (left < right && !Character.isLetter(s.charAt(left))) { // 判断左边是否扫描到字母\n                left++;\n            }\n            while (right > left && !Character.isLetter(s.charAt(right))) { // 判断右边是否扫描到字母\n                right--;\n            }\n            if (left >= right) {\n                break;\n            }\n            swap(arr, left, right);\n            left++;\n            right--;\n        }\n        return new String(arr);\n    }\n\n    public void swap(char[] arr, int left, int right) {\n        char temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string ReverseOnlyLetters(string s) {\n        int n = s.Length;\n        char[] arr = s.ToCharArray();\n        int left = 0, right = n - 1;\n        while (true) {\n            while (left < right && !char.IsLetter(s[left])) { // 判断左边是否扫描到字母\n                left++;\n            }\n            while (right > left && !char.IsLetter(s[right])) { // 判断右边是否扫描到字母\n                right--;\n            }\n            if (left >= right) {\n                break;\n            }\n            Swap(arr, left, right);\n            left++;\n            right--;\n        }\n        return new String(arr);\n    }\n\n    public void Swap(char[] arr, int left, int right) {\n        char temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n    }\n}\n```\n\n```C [sol1-C]\nstatic inline void swap(char *c1, char *c2) {\n    char tmp = *c1;\n    *c1 = *c2;\n    *c2 = tmp;\n}\n\nchar *reverseOnlyLetters(char *s){\n    int n = strlen(s);\n    int left = 0, right = n - 1;\n    while (true) {\n        while (left < right && !isalpha(s[left])) { // 判断左边是否扫描到字母\n            left++;\n        }\n        while (right > left && !isalpha(s[right])) { // 判断右边是否扫描到字母\n            right--;\n        }\n        if (left >= right) {\n            break;\n        }\n        swap(s + left, s + right);\n        left++;\n        right--;\n    }\n    return s;\n}\n```\n\n```go [sol1-Golang]\nfunc reverseOnlyLetters(s string) string {\n    ans := []byte(s)\n    left, right := 0, len(s)-1\n    for {\n        for left < right && !unicode.IsLetter(rune(s[left])) { // 判断左边是否扫描到字母\n            left++\n        }\n        for right > left && !unicode.IsLetter(rune(s[right])) { // 判断右边是否扫描到字母\n            right--\n        }\n        if left >= right {\n            break\n        }\n        ans[left], ans[right] = ans[right], ans[left]\n        left++\n        right--\n    }\n    return string(ans)\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar reverseOnlyLetters = function(s) {\n    const n = s.length;\n    const arr = [...s];\n    let left = 0, right = n - 1;\n    while (true) {\n        while (left < right && !(/^[a-zA-Z]+$/.test(s[left]))) { // 判断左边是否扫描到字母\n            left++;\n        }\n        while (right > left && !(/^[a-zA-Z]+$/.test(s[right]))) { // 判断右边是否扫描到字母\n            right--;\n        }\n        if (left >= right) {\n            break;\n        }\n        swap(arr, left, right);\n        left++;\n        right--;\n    }\n    return arr.join('');\n};\n\nconst swap = (arr, left, right) => {\n    const temp = arr[left];\n    arr[left] = arr[right];\n    arr[right] = temp;\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。反转过程需要 $O(n)$，C 语言计算字符串长度需要 $O(n)$。\n\n+ 空间复杂度：$O(1)$ 或 $O(n)$。某些语言字符串不可变，需要 $O(n)$ 的额外空间。"
}