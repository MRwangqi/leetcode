{
	"titleSlug": "merge-nodes-in-between-zeros",
	"slug": "he-bing-ling-zhi-jian-de-jie-dian-by-lee-zo9b",
	"url": "https://leetcode-cn.com/problems/merge-nodes-in-between-zeros/solution/he-bing-ling-zhi-jian-de-jie-dian-by-lee-zo9b/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n我们从链表头节点 $\\textit{head}$ 的下一个节点开始遍历，并使用一个变量 $\\textit{total}$ 维护当前遍历到的节点的元素之和。\n\n如果当前节点的值为 $0$，那么我们就新建一个值为 $\\textit{total}$ 的节点，放在答案链表的尾部，并将 $\\textit{total}$ 置零，否则我们将值累加进 $\\textit{total}$ 中。\n\n**细节**\n\n为了方便维护答案，我们可以在遍历前新建一个伪头节点 $\\textit{dummy}$，并在遍历完成之后返回 $\\textit{dummy}$ 的下一个节点作为答案。\n\n**代码**\n\n下面给出的 $\\texttt{C++}$ 代码中没有释放 $\\textit{dummy}$ 节点的空间。如果在面试中遇到本题，需要和面试官进行沟通。\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    ListNode* mergeNodes(ListNode* head) {\n        ListNode* dummy = new ListNode();\n        ListNode* tail = dummy;\n        \n        int total = 0;\n        for (ListNode* cur = head->next; cur; cur = cur->next) {\n            if (cur->val == 0) {\n                ListNode* node = new ListNode(total);\n                tail->next = node;\n                tail = tail->next;\n                total = 0;\n            }\n            else {\n                total += cur->val;\n            }\n        }\n        \n        return dummy->next;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = tail = ListNode()\n        total = 0\n        cur = head.next\n\n        while cur:\n            if cur.val == 0:\n                node = ListNode(total)\n                tail.next = node\n                tail = tail.next\n                total = 0\n            else:\n                total += cur.val\n            \n            cur = cur.next\n        \n        return dummy.next\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是给定链表的长度。\n\n- 空间复杂度：$O(1)$。"
}