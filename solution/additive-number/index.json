{
	"titleSlug": "additive-number",
	"slug": "lei-jia-shu-by-leetcode-solution-cadc",
	"url": "https://leetcode-cn.com/problems/additive-number/solution/lei-jia-shu-by-leetcode-solution-cadc/",
	"content": "#### 方法一：穷举累加序列第一个数字和第二个数字的所有可能性\n\n**思路及解法**\n\n一个累加序列，当它的第一个数字和第二个数字以及总长度确定后，这整个累加序列也就确定了。根据这个性质，我们可以穷举累加序列的第一个数字和第二个数字的所有可能性，对每个可能性，进行一次合法性的判断。当出现一次合法的累加序列后，即可返回 $\\texttt{true}$。当所有可能性都遍历完仍无法找到一个合法的累加序列时，返回 $\\texttt{false}$。\n\n记字符串 $\\textit{num}$ 的长度为 $n$，序列最新确定的两个数中，位于前面的数字为 $\\textit{first}$，$\\textit{first}$ 的最高位在 $\\textit{num}$ 中的下标为 $\\textit{firstStart}$，$\\textit{first}$ 的最低位在 $\\textit{num}$ 中的下标为 $\\textit{firstEnd}$。记序列最新确定的两个数中，位于后面的数字为 $\\textit{second}$，$\\textit{second}$ 的最高位在 $\\textit{num}$ 中的下标为 $\\textit{secondStart}$，$\\textit{second}$ 的最低位在 $\\textit{num}$ 中的下标为 $\\textit{secondEnd}$。在穷举第一个数字和第二个数字的过程中，容易得到以下两个结论：$\\textit{firstStart} = 0$，$\\textit{firstEnd} + 1 = \\textit{secondStart}$。因此，我们只需要用两个循环来遍历 $\\textit{secondStart}$ 和 $\\textit{secondEnd}$ 所有可能性的组合即可。\n\n在判断累加序列的合法性时，用字符串的加法来算出 $\\textit{first}$ 与 $\\textit{second}$ 之和 $\\textit{third}$。将 $\\textit{third}$ 与 $\\textit{num}$ 接下来紧邻的相同长度的字符串进行比较。当 $\\textit{third}$ 过长或者与接下来的字符串不相同时，则说明这不是一个合法的累加序列。当相同时，则我们为这个序列新确定了一个数字。如果 $\\textit{third}$ 刚好抵达 $\\textit{num}$ 的末尾时，则说明这是一个合法的序列。当 $\\textit{num}$ 还有多余的字符时，则需要更新 $\\textit{firstStart}$，$\\textit{firstEnd}$，$\\textit{secondStart}$，$\\textit{secondEnd}$， 继续进行合法性的判断。\n\n当输入规模较小时，这题可以直接使用整形或者长整型的数字的相加。而我们这里使用了字符串的加法，因此也能处理溢出的过大的整数输入。\n\n仍需要注意的是，当某个数字长度大于等于 $2$ 时，这个数字不能以 $0$ 开头，这部分的判断可以在两层循环体的开头完成。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        n = len(num)\n        for secondStart in range(1, n-1):\n            if num[0] == '0' and secondStart != 1:\n                break\n            for secondEnd in range(secondStart, n-1):\n                if num[secondStart] == '0' and secondStart != secondEnd:\n                    break\n                if self.valid(secondStart, secondEnd, num):\n                    return True\n        return False\n    \n    def valid(self, secondStart: int, secondEnd: int, num: str) -> bool:\n        n = len(num)\n        firstStart, firstEnd = 0, secondStart - 1\n        while secondEnd <= n - 1:\n            third = self.stringAdd(num, firstStart, firstEnd, secondStart, secondEnd)\n            thirdStart = secondEnd + 1\n            thirdEnd = secondEnd + len(third)\n            if thirdEnd >= n or num[thirdStart:thirdEnd+1] != third:\n                break\n            if thirdEnd == n-1:\n                return True\n            firstStart, firstEnd = secondStart, secondEnd\n            secondStart, secondEnd = thirdStart, thirdEnd\n        return False\n    \n    def stringAdd(self, s: str, firstStart: int, firstEnd: int, secondStart: int, secondEnd: int) -> str:\n        third = []\n        carry, cur = 0, 0\n        while firstEnd >= firstStart or secondEnd >= secondStart or carry != 0:\n            cur = carry\n            if firstEnd >= firstStart:\n                cur += ord(s[firstEnd]) - ord('0')\n                firstEnd -= 1\n            if secondEnd >= secondStart:\n                cur += ord(s[secondEnd]) - ord('0')\n                secondEnd -= 1\n            carry = cur // 10\n            cur %= 10\n            third.append(chr(cur + ord('0')))\n        return ''.join(third[::-1])\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean isAdditiveNumber(String num) {\n        int n = num.length();\n        for (int secondStart = 1; secondStart < n - 1; ++secondStart) {\n            if (num.charAt(0) == '0' && secondStart != 1) {\n                break;\n            }\n            for (int secondEnd = secondStart; secondEnd < n - 1; ++secondEnd) {\n                if (num.charAt(secondStart) == '0' && secondStart != secondEnd) {\n                    break;\n                }\n                if (valid(secondStart, secondEnd, num)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean valid(int secondStart, int secondEnd, String num) {\n        int n = num.length();\n        int firstStart = 0, firstEnd = secondStart - 1;\n        while (secondEnd <= n - 1) {\n            String third = stringAdd(num, firstStart, firstEnd, secondStart, secondEnd);\n            int thirdStart = secondEnd + 1;\n            int thirdEnd = secondEnd + third.length();\n            if (thirdEnd >= n || !num.substring(thirdStart, thirdEnd + 1).equals(third)) {\n                break;\n            }\n            if (thirdEnd == n - 1) {\n                return true;\n            }\n            firstStart = secondStart;\n            firstEnd = secondEnd;\n            secondStart = thirdStart;\n            secondEnd = thirdEnd;\n        }\n        return false;\n    }\n\n    public String stringAdd(String s, int firstStart, int firstEnd, int secondStart, int secondEnd) {\n        StringBuffer third = new StringBuffer();\n        int carry = 0, cur = 0;\n        while (firstEnd >= firstStart || secondEnd >= secondStart || carry != 0) {\n            cur = carry;\n            if (firstEnd >= firstStart) {\n                cur += s.charAt(firstEnd) - '0';\n                --firstEnd;\n            }\n            if (secondEnd >= secondStart) {\n                cur += s.charAt(secondEnd) - '0';\n                --secondEnd;\n            }\n            carry = cur / 10;\n            cur %= 10;\n            third.append((char) (cur + '0'));\n        }\n        third.reverse();\n        return third.toString();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool IsAdditiveNumber(string num) {\n        int n = num.Length;\n        for (int secondStart = 1; secondStart < n - 1; ++secondStart) {\n            if (num[0] == '0' && secondStart != 1) {\n                break;\n            }\n            for (int secondEnd = secondStart; secondEnd < n - 1; ++secondEnd) {\n                if (num[secondStart] == '0' && secondStart != secondEnd) {\n                    break;\n                }\n                if (Valid(secondStart, secondEnd, num)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public bool Valid(int secondStart, int secondEnd, string num) {\n        int n = num.Length;\n        int firstStart = 0, firstEnd = secondStart - 1;\n        while (secondEnd <= n - 1) {\n            string third = StringAdd(num, firstStart, firstEnd, secondStart, secondEnd);\n            int thirdStart = secondEnd + 1;\n            int thirdEnd = secondEnd + third.Length;\n            if (thirdEnd >= n || !num.Substring(thirdStart, thirdEnd - thirdStart + 1).Equals(third)) {\n                break;\n            }\n            if (thirdEnd == n - 1) {\n                return true;\n            }\n            firstStart = secondStart;\n            firstEnd = secondEnd;\n            secondStart = thirdStart;\n            secondEnd = thirdEnd;\n        }\n        return false;\n    }\n\n    public string StringAdd(string s, int firstStart, int firstEnd, int secondStart, int secondEnd) {\n        StringBuilder third = new StringBuilder();\n        int carry = 0, cur = 0;\n        while (firstEnd >= firstStart || secondEnd >= secondStart || carry != 0) {\n            cur = carry;\n            if (firstEnd >= firstStart) {\n                cur += s[firstEnd] - '0';\n                --firstEnd;\n            }\n            if (secondEnd >= secondStart) {\n                cur += s[secondEnd] - '0';\n                --secondEnd;\n            }\n            carry = cur / 10;\n            cur %= 10;\n            third.Append((char) (cur + '0'));\n        }\n        char[] arr = third.ToString().ToCharArray();\n        Array.Reverse(arr);\n        third.Length = 0;\n        foreach (char c in arr) {\n            third.Append(c);\n        }\n        return third.ToString();\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool isAdditiveNumber(string num) {\n        int n = num.size();\n        for (int secondStart = 1; secondStart < n - 1; ++secondStart) {\n            if (num[0] == '0' && secondStart != 1) {\n                break;\n            }\n            for (int secondEnd = secondStart; secondEnd < n - 1; ++secondEnd) {\n                if (num[secondStart] == '0' && secondStart != secondEnd) {\n                    break;\n                }\n                if (valid(secondStart, secondEnd, num)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    bool valid(int secondStart, int secondEnd, string num) {\n        int n = num.size();\n        int firstStart = 0, firstEnd = secondStart - 1;\n        while (secondEnd <= n - 1) {\n            string third = stringAdd(num, firstStart, firstEnd, secondStart, secondEnd);\n            int thirdStart = secondEnd + 1;\n            int thirdEnd = secondEnd + third.size();\n            if (thirdEnd >= n || !(num.substr(thirdStart, thirdEnd - thirdStart + 1) == third)) {\n                break;\n            }\n            if (thirdEnd == n - 1) {\n                return true;\n            }\n            firstStart = secondStart;\n            firstEnd = secondEnd;\n            secondStart = thirdStart;\n            secondEnd = thirdEnd;\n        }\n        return false;\n    }\n\n    string stringAdd(string s, int firstStart, int firstEnd, int secondStart, int secondEnd) {\n        string third;\n        int carry = 0, cur = 0;\n        while (firstEnd >= firstStart || secondEnd >= secondStart || carry != 0) {\n            cur = carry;\n            if (firstEnd >= firstStart) {\n                cur += s[firstEnd] - '0';\n                --firstEnd;\n            }\n            if (secondEnd >= secondStart) {\n                cur += s[secondEnd] - '0';\n                --secondEnd;\n            }\n            carry = cur / 10;\n            cur %= 10;\n            third.push_back(cur + '0');\n        }\n        reverse(third.begin(), third.end());\n        return third;\n    }\n};\n```\n\n```C [sol1-C]\nchar * stringAdd(const char * s, int firstStart, int firstEnd, int secondStart, int secondEnd) {\n    char * third = (char *)malloc(sizeof(char) * (strlen(s) + 1));\n    int thirdSize = 0;\n    int carry = 0, cur = 0;\n    \n    while (firstEnd >= firstStart || secondEnd >= secondStart || carry != 0) {\n        cur = carry;\n        if (firstEnd >= firstStart) {\n            cur += s[firstEnd] - '0';\n            --firstEnd;\n        }\n        if (secondEnd >= secondStart) {\n            cur += s[secondEnd] - '0';\n            --secondEnd;\n        }\n        carry = cur / 10;\n        cur %= 10;\n        third[thirdSize] = cur + '0';\n        thirdSize++;\n    }\n\n    int left = 0;\n    int right = thirdSize - 1;\n    while (left < right) {\n        char c = third[left];\n        third[left] = third[right];\n        third[right] = c;\n        ++left;\n        --right;\n    }\n    third[thirdSize] = '\\0';\n    return third;\n}\n\nbool valid(int secondStart, int secondEnd, const char * num) {\n    int n = strlen(num);\n    int firstStart = 0, firstEnd = secondStart - 1;\n    while (secondEnd <= n - 1) {\n        char * third = stringAdd(num, firstStart, firstEnd, secondStart, secondEnd);\n        int thirdStart = secondEnd + 1;\n        int thirdEnd = secondEnd + strlen(third);\n        if (thirdEnd >= n || strncmp(num + thirdStart, third, thirdEnd - thirdStart + 1)) {\n            free(third);\n            break;\n        }\n        free(third);\n        if (thirdEnd == n - 1) {\n            return true;\n        }\n        firstStart = secondStart;\n        firstEnd = secondEnd;\n        secondStart = thirdStart;\n        secondEnd = thirdEnd;\n    }\n    return false;\n}\n\n\nbool isAdditiveNumber(char * num){\n    int n = strlen(num);\n    for (int secondStart = 1; secondStart < n - 1; ++secondStart) {\n        if (num[0] == '0' && secondStart != 1) {\n            break;\n        }\n        for (int secondEnd = secondStart; secondEnd < n - 1; ++secondEnd) {\n            if (num[secondStart] == '0' && secondStart != secondEnd) {\n                break;\n            }\n            if (valid(secondStart, secondEnd, num)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar isAdditiveNumber = function(num) {\n    const n = num.length;\n    for (let secondStart = 1; secondStart < n - 1; ++secondStart) {\n        if (num[0] === '0' && secondStart !== 1) {\n            break;\n        }\n        for (let secondEnd = secondStart; secondEnd < n - 1; ++secondEnd) {\n            if (num[secondStart] === '0' && secondStart !== secondEnd) {\n                break;\n            }\n            if (valid(secondStart, secondEnd, num)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\nconst valid = (secondStart, secondEnd, num) => {\n    const n = num.length;\n    let firstStart = 0, firstEnd = secondStart - 1;\n    while (secondEnd <= n - 1) {\n        const third = stringAdd(num, firstStart, firstEnd, secondStart, secondEnd);\n        const thirdStart = secondEnd + 1;\n        const thirdEnd = secondEnd + third.length;\n        if (thirdEnd >= n || num.slice(thirdStart, thirdEnd + 1) !== third) {\n            break;\n        }\n        if (thirdEnd === n - 1) {\n            return true;\n        }\n        firstStart = secondStart;\n        firstEnd = secondEnd;\n        secondStart = thirdStart;\n        secondEnd = thirdEnd;\n    }\n    return false;\n}\n\nconst stringAdd = (s, firstStart, firstEnd, secondStart, secondEnd) => {\n    const third = [];\n    let carry = 0, cur = 0;\n    while (firstEnd >= firstStart || secondEnd >= secondStart || carry !== 0) {\n        cur = carry;\n        if (firstEnd >= firstStart) {\n            cur += s[firstEnd].charCodeAt() - '0'.charCodeAt();\n            --firstEnd;\n        }\n        if (secondEnd >= secondStart) {\n            cur += s[secondEnd].charCodeAt() - '0'.charCodeAt();\n            --secondEnd;\n        }\n        carry = Math.floor(cur / 10);\n        cur %= 10;\n        third.push(String.fromCharCode(cur + '0'.charCodeAt()));\n    }\n    third.reverse();\n    return third.join('');\n}\n```\n\n```go [sol1-Golang]\nfunc stringAdd(x, y string) string {\n    res := []byte{}\n    carry, cur := 0, 0\n    for x != \"\" || y != \"\" || carry != 0 {\n        cur = carry\n        if x != \"\" {\n            cur += int(x[len(x)-1] - '0')\n            x = x[:len(x)-1]\n        }\n        if y != \"\" {\n            cur += int(y[len(y)-1] - '0')\n            y = y[:len(y)-1]\n        }\n        carry = cur / 10\n        cur %= 10\n        res = append(res, byte(cur)+'0')\n    }\n    for i, n := 0, len(res); i < n/2; i++ {\n        res[i], res[n-1-i] = res[n-1-i], res[i]\n    }\n    return string(res)\n}\n\nfunc valid(num string, secondStart, secondEnd int) bool {\n    n := len(num)\n    firstStart, firstEnd := 0, secondStart-1\n    for secondEnd <= n-1 {\n        third := stringAdd(num[firstStart:firstEnd+1], num[secondStart:secondEnd+1])\n        thirdStart := secondEnd + 1\n        thirdEnd := secondEnd + len(third)\n        if thirdEnd >= n || num[thirdStart:thirdEnd+1] != third {\n            break\n        }\n        if thirdEnd == n-1 {\n            return true\n        }\n        firstStart, firstEnd = secondStart, secondEnd\n        secondStart, secondEnd = thirdStart, thirdEnd\n    }\n    return false\n}\n\nfunc isAdditiveNumber(num string) bool {\n    n := len(num)\n    for secondStart := 1; secondStart < n-1; secondStart++ {\n        if num[0] == '0' && secondStart != 1 {\n            break\n        }\n        for secondEnd := secondStart; secondEnd < n-1; secondEnd++ {\n            if num[secondStart] == '0' && secondStart != secondEnd {\n                break\n            }\n            if valid(num, secondStart, secondEnd) {\n                return true\n            }\n        }\n    }\n    return false\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^3)$，其中 $n$ 为字符串 $\\textit{num}$ 的长度。需要两层循环来遍历第二个数字的起始位置和结束位置，每个这样的组合又需要 $O(n)$ 来验证合法性。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为字符串 $\\textit{num}$ 的长度。在做字符串加法的时候需要 $O(n)$ 的空间来保存结果。"
}