{
	"titleSlug": "number-of-rectangles-that-can-form-the-largest-square",
	"slug": "ke-yi-xing-cheng-zui-da-zheng-fang-xing-n6pvm",
	"url": "https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/solution/ke-yi-xing-cheng-zui-da-zheng-fang-xing-n6pvm/",
	"content": "#### 方法一：一次遍历\n\n**思路**\n\n记 $l$ 和 $w$ 为某个矩形的长度和宽度，设 $k$ 为可以从这个矩形中切出的最大正方形的边长，则有 $k = \\min(l, w)$。我们遍历输入数组，维护两个变量，$\\textit{maxLen}$ 表示遍历到当前矩形时的所有可以切出的最大正方形的边长的最大值，$\\textit{res}$ 表示可以切出边长为 $\\textit{maxLen}$ 的正方形的个数。计算当前的 $k$，当 $k = \\textit{maxLen}$ 时，对 $\\textit{res}$ 进行加 $1$ 操作；当 $k > \\textit{maxLen}$ 时，则更新 $\\textit{maxLen}$ 为 $k$，并把 $\\textit{res}$ 重置为 $1$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:\n        res, maxLen = 0, 0\n        for l, w in rectangles:\n            k = min(l, w)\n            if k == maxLen:\n                res += 1\n            elif k > maxLen:\n                res = 1\n                maxLen = k\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int countGoodRectangles(int[][] rectangles) {\n        int res = 0, maxLen = 0;\n        for (int[] rectangle : rectangles) {\n            int l = rectangle[0], w = rectangle[1];\n            int k = Math.min(l, w);\n            if (k == maxLen) {\n                ++res;\n            } else if (k > maxLen) {\n                res = 1;\n                maxLen = k;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int CountGoodRectangles(int[][] rectangles) {\n        int res = 0, maxLen = 0;\n        foreach (int[] rectangle in rectangles) {\n            int l = rectangle[0], w = rectangle[1];\n            int k = Math.Min(l, w);\n            if (k == maxLen) {\n                ++res;\n            } else if (k > maxLen) {\n                res = 1;\n                maxLen = k;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int countGoodRectangles(vector<vector<int>>& rectangles) {\n        int res = 0, maxLen = 0;\n        for (auto & rectangle : rectangles) {\n            int l = rectangle[0], w = rectangle[1];\n            int k = min(l, w);\n            if (k == maxLen) {\n                ++res;\n            } else if (k > maxLen) {\n                res = 1;\n                maxLen = k;\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint countGoodRectangles(int** rectangles, int rectanglesSize, int* rectanglesColSize){\n    int res = 0, maxLen = 0;\n    for (int i = 0; i < rectanglesSize; ++i) {\n        int l = rectangles[i][0], w = rectangles[i][1];\n        int k = MIN(l, w);\n        if (k == maxLen) {\n            ++res;\n        } else if (k > maxLen) {\n            res = 1;\n            maxLen = k;\n        }\n    }\n    return res;\n}\n```\n\n```go [sol1-Golang]\nfunc countGoodRectangles(rectangles [][]int) (ans int) {\n    maxLen := 0\n    for _, rect := range rectangles {\n        k := min(rect[0], rect[1])\n        if k == maxLen {\n            ans++\n        } else if k > maxLen {\n            maxLen, ans = k, 1\n        }\n    }\n    return\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar countGoodRectangles = function(rectangles) {\n    let res = 0, maxLen = 0;\n    for (const rectangle of rectangles) {\n        const l = rectangle[0], w = rectangle[1];\n        const k = Math.min(l, w);\n        if (k === maxLen) {\n            ++res;\n        } else if (k > maxLen) {\n            res = 1;\n            maxLen = k;\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为输入数组 $\\textit{rectangles}$ 的长度。我们仅需一次遍历即可得到答案。\n\n- 空间复杂度：$O(1)$。我们仅需要常数空间来存储变量。"
}