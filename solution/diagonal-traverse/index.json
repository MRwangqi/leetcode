{
	"titleSlug": "diagonal-traverse",
	"slug": "dui-jiao-xian-bian-li-by-leetcode-soluti-plz7",
	"url": "https://leetcode-cn.com/problems/diagonal-traverse/solution/dui-jiao-xian-bian-li-by-leetcode-soluti-plz7/",
	"content": "#### 方法一：直接模拟\n\n**思路与算法**\n\n根据题目要求，矩阵按照对角线进行遍历。设矩阵的行数为 $m$, 矩阵的列数为 $n$, 我们仔细观察对角线遍历的规律可以得到如下信息:\n\n+ 一共有 $m + n - 1$ 条对角线，相邻的对角线的遍历方向不同，当前遍历方向为从左下到右上，则紧挨着的下一条对角线遍历方向为从右上到左下；\n\n+ 设对角线从上到下的编号为 $i \\in [0, m + n - 2]$：\n    - 当 $i$ 为偶数时，则第 $i$ 条对角线的走向是从下往上遍历；\n    - 当 $i$ 为奇数时，则第 $i$ 条对角线的走向是从上往下遍历；\n\n+ 当第 $i$ 条对角线从下往上遍历时，每次行索引减 $1$，列索引加 $1$，直到矩阵的边缘为止：\n    - 当 $i < m$ 时，则此时对角线遍历的起点位置为 $(i,0)$；\n    - 当 $i \\ge m$ 时，则此时对角线遍历的起点位置为 $(m - 1, i - m + 1)$；\n\n+ 当第 $i$ 条对角线从上往下遍历时，每次行索引加 $1$，列索引减 $1$，直到矩阵的边缘为止： \n    - 当 $i < n$ 时，则此时对角线遍历的起点位置为 $(0, i)$；\n    - 当 $i \\ge n$ 时，则此时对角线遍历的起点位置为 $(i - n + 1, n - 1)$；\n\n根据以上观察得出的结论，我们直接模拟遍历所有的对角线即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\n        ans = []\n        m, n = len(mat), len(mat[0])\n        for i in range(m + n - 1):\n            if i % 2:\n                x = 0 if i < n else i - n + 1\n                y = i if i < n else n - 1\n                while x < m and y >= 0:\n                    ans.append(mat[x][y])\n                    x += 1\n                    y -= 1\n            else:\n                x = i if i < m else m - 1\n                y = 0 if i < m else i - m + 1\n                while x >= 0 and y < n:\n                    ans.append(mat[x][y])\n                    x -= 1\n                    y += 1\n        return ans\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] findDiagonalOrder(int[][] mat) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int[] res = new int[m * n];\n        int pos = 0;\n        for (int i = 0; i < m + n - 1; i++) {\n            if (i % 2 == 1) {\n                int x = i < n ? 0 : i - n + 1;\n                int y = i < n ? i : n - 1;\n                while (x < m && y >= 0) {\n                    res[pos] = mat[x][y];\n                    pos++;\n                    x++;\n                    y--;\n                }\n            } else {\n                int x = i < m ? i : m - 1;\n                int y = i < m ? 0 : i - m + 1;\n                while (x >= 0 && y < n) {\n                    res[pos] = mat[x][y];\n                    pos++;\n                    x--;\n                    y++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\n        int m = mat.size();\n        int n = mat[0].size();\n        vector<int> res;\n        for (int i = 0; i < m + n - 1; i++) {\n            if (i % 2) {\n                int x = i < n ? 0 : i - n + 1;\n                int y = i < n ? i : n - 1;\n                while (x < m && y >= 0) {\n                    res.emplace_back(mat[x][y]);\n                    x++;\n                    y--;\n                }\n            } else {\n                int x = i < m ? i : m - 1;\n                int y = i < m ? 0 : i - m + 1;\n                while (x >= 0 && y < n) {\n                    res.emplace_back(mat[x][y]);\n                    x--;\n                    y++;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] FindDiagonalOrder(int[][] mat) {\n        int m = mat.Length;\n        int n = mat[0].Length;\n        int[] res = new int[m * n];\n        int pos = 0;\n        for (int i = 0; i < m + n - 1; i++) {\n            if (i % 2 == 1) {\n                int x = i < n ? 0 : i - n + 1;\n                int y = i < n ? i : n - 1;\n                while (x < m && y >= 0) {\n                    res[pos] = mat[x][y];\n                    pos++;\n                    x++;\n                    y--;\n                }\n            } else {\n                int x = i < m ? i : m - 1;\n                int y = i < m ? 0 : i - m + 1;\n                while (x >= 0 && y < n) {\n                    res[pos] = mat[x][y];\n                    pos++;\n                    x--;\n                    y++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol1-C]\nint* findDiagonalOrder(int** mat, int matSize, int* matnSize, int* returnSize) {\n    int m = matSize;\n    int n = matnSize[0];\n    int *res = (int *)malloc(sizeof(int) * m * n);\n    int pos = 0;\n    for (int i = 0; i < m + n - 1; i++) {\n        if (i % 2) {\n            int x = i < n ? 0 : i - n + 1;\n            int y = i < n ? i : n - 1;\n            while (x < m && y >= 0) {\n                res[pos] = mat[x][y];\n                pos++;\n                x++;\n                y--;\n            }\n        } else {\n            int x = i < m ? i : m - 1;\n            int y = i < m ? 0 : i - m + 1;\n            while (x >= 0 && y < n) {\n                res[pos] = mat[x][y];\n                pos++;\n                x--;\n                y++;\n            }\n        }\n    }\n    *returnSize = m * n;\n    return res;\n}\n```\n\n```go [sol1-Golang]\nfunc findDiagonalOrder(mat [][]int) []int {\n    m, n := len(mat), len(mat[0])\n    ans := make([]int, 0, m*n)\n    for i := 0; i < m+n-1; i++ {\n        if i%2 == 1 {\n            x := max(i-n+1, 0)\n            y := min(i, n-1)\n            for x < m && y >= 0 {\n                ans = append(ans, mat[x][y])\n                x++\n                y--\n            }\n        } else {\n            x := min(i, m-1)\n            y := max(i-m+1, 0)\n            for x >= 0 && y < n {\n                ans = append(ans, mat[x][y])\n                x--\n                y++\n            }\n        }\n    }\n    return ans\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findDiagonalOrder = function(mat) {\n    const m = mat.length;\n    const n = mat[0].length;\n    const res = new Array(m * n).fill(0);\n    let pos = 0;\n    for (let i = 0; i < m + n - 1; i++) {\n        if (i % 2 === 1) {\n            let x = i < n ? 0 : i - n + 1;\n            let y = i < n ? i : n - 1;\n            while (x < m && y >= 0) {\n                res[pos] = mat[x][y];\n                pos++;\n                x++;\n                y--;\n            }\n        } else {\n            let x = i < m ? i : m - 1;\n            let y = i < m ? 0 : i - m + 1;\n            while (x >= 0 && y < n) {\n                res[pos] = mat[x][y];\n                pos++;\n                x--;\n                y++;\n            }\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(m \\times n)$，其中 $m$ 为矩阵行的数量，$n$ 为矩阵列的数量。需要遍历一遍矩阵中的所有元素，需要的时间复杂度为 $O(m \\times n)$。\n\n+ 空间复杂度：$O(1)$。除返回值外不需要额外的空间。"
}