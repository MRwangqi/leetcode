{
	"titleSlug": "knight-probability-in-chessboard",
	"slug": "qi-shi-zai-qi-pan-shang-de-gai-lu-by-lee-2qhk",
	"url": "https://leetcode-cn.com/problems/knight-probability-in-chessboard/solution/qi-shi-zai-qi-pan-shang-de-gai-lu-by-lee-2qhk/",
	"content": "#### 方法一：动态规划\n\n**思路**\n\n一个骑士有 $8$ 种可能的走法，骑士会从中以等概率随机选择一种。部分走法可能会让骑士离开棋盘，另外的走法则会让骑士移动到棋盘的其他位置，并且剩余的移动次数会减少 $1$。\n\n定义 $\\textit{dp}[\\textit{step}][i][j]$ 表示骑士从棋盘上的点 $(i, j)$ 出发，走了 $\\textit{step}$ 步时仍然留在棋盘上的概率。特别地，当点 $(i, j)$ 不在棋盘上时，$\\textit{dp}[\\textit{step}][i][j] = 0$；当点 $(i, j)$ 在棋盘上且 $\\textit{step} = 0$ 时，$\\textit{dp}[\\textit{step}][i][j] = 1$。对于其他情况，$\\textit{dp}[\\textit{step}][i][j] = \\dfrac{1}{8} \\times \\sum\\limits_{\\textit{di}, \\textit{dj}} \\textit{dp}[\\textit{step}-1][i+\\textit{di}][j+\\textit{dj}]$。其中 $(\\textit{di}, \\textit{dj})$ 表示走法对坐标的偏移量，具体为 $(-2, -1),(-2,1),(2,-1),(2,1),(-1,-2),(-1,2),(1,-2),(1,2)$ 共 $8$ 种。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        dp = [[[0] * n for _ in range(n)] for _ in range(k + 1)]\n        for step in range(k + 1):\n            for i in range(n):\n                for j in range(n):\n                    if step == 0:\n                        dp[step][i][j] = 1\n                    else:\n                        for di, dj in ((-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)):\n                            ni, nj = i + di, j + dj\n                            if 0 <= ni < n and 0 <= nj < n:\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8\n        return dp[k][row][column]\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static int[][] dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n\n    public double knightProbability(int n, int k, int row, int column) {\n        double[][][] dp = new double[k + 1][n][n];\n        for (int step = 0; step <= k; step++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (step == 0) {\n                        dp[step][i][j] = 1;\n                    } else {\n                        for (int[] dir : dirs) {\n                            int ni = i + dir[0], nj = j + dir[1];\n                            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][row][column];\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    static int[][] dirs = {new int[]{-2, -1}, new int[]{-2, 1}, new int[]{2, -1}, new int[]{2, 1}, new int[]{-1, -2}, new int[]{-1, 2}, new int[]{1, -2}, new int[]{1, 2}};\n\n    public double KnightProbability(int n, int k, int row, int column) {\n        double[,,] dp = new double[k + 1, n, n];\n        for (int step = 0; step <= k; step++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (step == 0) {\n                        dp[step, i, j] = 1;\n                    } else {\n                        foreach (int[] dir in dirs) {\n                            int ni = i + dir[0], nj = j + dir[1];\n                            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                                dp[step, i, j] += dp[step - 1, ni, nj] / 8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k, row, column];\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n\n    double knightProbability(int n, int k, int row, int column) {\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n)));\n        for (int step = 0; step <= k; step++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (step == 0) {\n                        dp[step][i][j] = 1;\n                    } else {\n                        for (auto & dir : dirs) {\n                            int ni = i + dir[0], nj = j + dir[1];\n                            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][row][column];\n    }\n};\n```\n\n```C [sol1-C]\nstatic int dirs[8][2]  = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n\ndouble knightProbability(int n, int k, int row, int column){\n    double dp[200][30][30];\n    memset(dp, 0, sizeof(dp));\n    for (int step = 0; step <= k; step++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (step == 0) {\n                    dp[step][i][j] = 1.0;\n                } else {\n                    for (int k = 0; k < 8; k++) {\n                        int ni = i + dirs[k][0], nj = j + dirs[k][1];\n                        if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                            dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dp[k][row][column];\n}\n```\n\n```go [sol1-Golang]\nvar dirs = []struct{ i, j int }{{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}}\n\nfunc knightProbability(n, k, row, column int) float64 {\n    dp := make([][][]float64, k+1)\n    for step := range dp {\n        dp[step] = make([][]float64, n)\n        for i := 0; i < n; i++ {\n            dp[step][i] = make([]float64, n)\n            for j := 0; j < n; j++ {\n                if step == 0 {\n                    dp[step][i][j] = 1\n                } else {\n                    for _, d := range dirs {\n                        if x, y := i+d.i, j+d.j; 0 <= x && x < n && 0 <= y && y < n {\n                            dp[step][i][j] += dp[step-1][x][y] / 8\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dp[k][row][column]\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst dirs = [[-2, -1], [-2, 1], [2, -1], [2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2]];\nvar knightProbability = function(n, k, row, column) {\n    const dp = new Array(k + 1).fill(0).map(() => new Array(n).fill(0).map(() => new Array(n).fill(0)));\n    for (let step = 0; step <= k; step++) {\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (step === 0) {\n                    dp[step][i][j] = 1;\n                } else {\n                    for (const dir of dirs) {\n                        const ni = i + dir[0], nj = j + dir[1];\n                        if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                            dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dp[k][row][column];\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(k \\times n ^ 2)$。状态数一共有 $O(k \\times n ^ 2)$，每次转移需要考虑 $8$ 种可能的走法，消耗 $O(1)$ 的时间复杂度，总体的时间复杂度是 $O(k \\times n ^ 2)$。\n\n- 空间复杂度：$O(k \\times n ^ 2)$。状态数一共有 $O(k \\times n ^ 2)$，用一个数组来保存。注意到每一步的状态只由前一步决定，空间复杂度可以优化到 $O(n ^ 2)$。"
}