{
	"titleSlug": "minimum-subsequence-in-non-increasing-order",
	"slug": "fei-di-zeng-shun-xu-de-zui-xiao-zi-xu-li-v7kr",
	"url": "https://leetcode-cn.com/problems/minimum-subsequence-in-non-increasing-order/solution/fei-di-zeng-shun-xu-de-zui-xiao-zi-xu-li-v7kr/",
	"content": "#### 方法一：贪心\n\n题目要求从原数组中取出部分元素，且满足取出的元素之和严格大于剩余的元素之和，且满足要求取出的元素数量尽可能的少的前提下，取出的元素之和尽可能的大。根据以上分析，我们可以利用贪心法。我们应尽量保证取出的元素尽可能的大，才能满足取出的元素尽可能的少且元素之和尽可能的大，因此我们按照从大到小的顺序依次从原始数组中取出数据，直到取出的数据之和 $\\textit{curr}$ 大于数组中剩余的元素之和为止。\n\n```Python [sol1-Python3]\nclass Solution:\n    def minSubsequence(self, nums: List[int]) -> List[int]:\n        nums.sort(reverse=True)\n        tot, s = sum(nums), 0\n        for i, num in enumerate(nums):\n            s += num\n            if s > tot - s:\n                return nums[:i + 1]\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> minSubsequence(vector<int>& nums) {\n        int total = accumulate(nums.begin(), nums.end(), 0);\n        sort(nums.begin(), nums.end());\n        vector<int> ans;\n        int curr = 0;\n        for (int i = nums.size() - 1; i >= 0; --i) {\n            curr += nums[i];\n            ans.emplace_back(nums[i]);\n            if (total - curr < curr) {\n                break;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> minSubsequence(int[] nums) {\n        int total = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        List<Integer> ans = new ArrayList<Integer>();\n        int curr = 0;\n        for (int i = nums.length - 1; i >= 0; --i) {\n            curr += nums[i];\n            ans.add(nums[i]);\n            if (total - curr < curr) {\n                break;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> MinSubsequence(int[] nums) {\n        int total = nums.Sum();\n        Array.Sort(nums);\n        IList<int> ans = new List<int>();\n        int curr = 0;\n        for (int i = nums.Length - 1; i >= 0; --i) {\n            curr += nums[i];\n            ans.Add(nums[i]);\n            if (total - curr < curr) {\n                break;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\nstatic inline cmp(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint* minSubsequence(int* nums, int numsSize, int* returnSize){\n    int total = 0;\n    for (int i = 0; i < numsSize; i++) {\n        total += nums[i];\n    }\n    qsort(nums, numsSize, sizeof(int), cmp);\n    int *ans = (int *)malloc(sizeof(int) * numsSize);\n    int curr = 0, pos = 0;\n    for (int i = numsSize - 1; i >= 0; --i) {\n        curr += nums[i];\n        ans[pos++] = nums[i];\n        if (total - curr < curr) {\n            break;\n        }\n    }\n    *returnSize = pos;\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc minSubsequence(nums []int) []int {\n    sort.Sort(sort.Reverse(sort.IntSlice(nums)))\n    tot := 0\n    for _, num := range nums {\n        tot += num\n    }\n    for i, sum := 0, 0; ; i++ {\n        sum += nums[i]\n        if sum > tot-sum {\n            return nums[:i+1]\n        }\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minSubsequence = function(nums) {\n    const total = _.sum(nums);\n    nums.sort((a, b) => a - b);\n    const ans = [];\n    let curr = 0;\n    for (let i = nums.length - 1; i >= 0; --i) {\n        curr += nums[i];\n        ans.push(nums[i]);\n        if (total - curr < curr) {\n            break;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n\\log n)$，其中 $n$ 为 数组的长度。需要对数组进行排序，因此时间复杂度为 $O(n\\log n)$。\n\n- 空间复杂度：$O(\\log n)$，其中 $n$ 为 数组的长度。排序需要的栈空间为 $O(\\log n)$。"
}