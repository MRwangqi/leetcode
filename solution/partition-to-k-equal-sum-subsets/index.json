{
	"titleSlug": "partition-to-k-equal-sum-subsets",
	"slug": "hua-fen-wei-kge-xiang-deng-de-zi-ji-by-l-v66o",
	"url": "https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/solution/hua-fen-wei-kge-xiang-deng-de-zi-ji-by-l-v66o/",
	"content": "#### 方法一：状态压缩 + 记忆化搜索\n\n**思路与算法**\n\n题目给定长度为 $n$ 的数组 $\\textit{nums}$，和整数 $k$，我们需要判断是否能将数组分成 $k$ 个总和相等的非空子集。首先计算数组的和 $\\textit{all}$，如果 $\\textit{all}$ 不是 $k$ 的倍数，那么不可能能有合法方案，此时直接返回 $\\text{False}$。否则我们需要得到 $k$ 个和为 $\\textit{per} = \\frac{\\textit{all}}{k}$ 的集合，那么我们每次尝试选择一个还在数组中的数，若选择后当前已选数字和等于 $\\textit{per}$ 则说明得到了一个集合，而已选数字和大于 $\\textit{per}$ 时，不可能形成一个集合从而停止继续往下选择新的数字。又因为 $n$ 满足 $1 \\le n \\le 16$，所以我们可以用一个整数 $S$ 来表示当前可用的数字集合：从低位到高位，第 $i$ 位为 $1$ 则表示数字 $\\textit{nums}[i]$ 可以使用，否则表示 $\\textit{nums}[i]$ 已被使用。为了避免相同状态的重复计算，我们用 $\\textit{dp}[S]$ 来表示在可用的数字状态为 $S$ 的情况下是否可行，初始全部状态为记录为可行状态 $\\text{True}$。这样我们就可以通过记忆化搜索这种「自顶向下」的方式来进行求解原始状态的可行性，而当状态集合中不存在任何数字时，即 $S = 0$ 时，表示原始数组可以按照题目要求来进行分配，此时返回 $\\text{True}$ 即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        all = sum(nums)\n        if all % k:\n            return False\n        per = all // k\n        nums.sort()  # 方便下面剪枝\n        if nums[-1] > per:\n            return False\n        n = len(nums)\n\n        @cache\n        def dfs(s, p):\n            if s == 0:\n                return True\n            for i in range(n):\n                if nums[i] + p > per:\n                    break\n                if s >> i & 1 and dfs(s ^ (1 << i), (p + nums[i]) % per):  # p + nums[i] 等于 per 时置为 0\n                    return True\n            return False\n        return dfs((1 << n) - 1, 0)\n```\n\n```Java [sol1-Java]\nclass Solution {\n    int[] nums;\n    int per, n;\n    boolean[] dp;\n\n    public boolean canPartitionKSubsets(int[] nums, int k) {\n        this.nums = nums;\n        int all = Arrays.stream(nums).sum();\n        if (all % k != 0) {\n            return false;\n        }\n        per = all / k;\n        Arrays.sort(nums);\n        n = nums.length;\n        if (nums[n - 1] > per) {\n            return false;\n        }\n        dp = new boolean[1 << n];\n        Arrays.fill(dp, true);\n        return dfs((1 << n) - 1, 0);\n    }\n\n    public boolean dfs(int s, int p) {\n        if (s == 0) {\n            return true;\n        }\n        if (!dp[s]) {\n            return dp[s];\n        }\n        dp[s] = false;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] + p > per) {\n                break;\n            }\n            if (((s >> i) & 1) != 0) {\n                if (dfs(s ^ (1 << i), (p + nums[i]) % per)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    int[] nums;\n    int per, n;\n    bool[] dp;\n\n    public bool CanPartitionKSubsets(int[] nums, int k) {\n        this.nums = nums;\n        int all = nums.Sum();\n        if (all % k != 0) {\n            return false;\n        }\n        per = all / k;\n        Array.Sort(nums);\n        n = nums.Length;\n        if (nums[n - 1] > per) {\n            return false;\n        }\n        dp = new bool[1 << n];\n        Array.Fill(dp, true);\n        return DFS((1 << n) - 1, 0);\n    }\n\n    public bool DFS(int s, int p) {\n        if (s == 0) {\n            return true;\n        }\n        if (!dp[s]) {\n            return dp[s];\n        }\n        dp[s] = false;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] + p > per) {\n                break;\n            }\n            if (((s >> i) & 1) != 0) {\n                if (DFS(s ^ (1 << i), (p + nums[i]) % per)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        int all = accumulate(nums.begin(), nums.end(), 0);\n        if (all % k > 0) {\n            return false;\n        }\n        int per = all / k; \n        sort(nums.begin(), nums.end());\n        if (nums.back() > per) {\n            return false;\n        }\n        int n = nums.size();\n        vector<bool> dp(1 << n, true);\n        function<bool(int,int)> dfs = [&](int s, int p)->bool {\n            if (s == 0) {\n                return true;\n            }\n            if (!dp[s]) {\n                return dp[s];\n            }\n            dp[s] = false;\n            for (int i = 0; i < n; i++) {\n                if (nums[i] + p > per) {\n                    break;\n                }\n                if ((s >> i) & 1) {\n                    if (dfs(s ^ (1 << i), (p + nums[i]) % per)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        return dfs((1 << n) - 1, 0);\n    }\n};\n```\n\n```C [sol1-C]\nstatic inline int cmp(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nstatic bool dfs(int s, int p, int per, int* nums, int numsSize, bool* dp) {\n    if (s == 0) {\n        return true;\n    }\n    if (!dp[s]) {\n        return dp[s];\n    }\n    dp[s] = false;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] + p > per) {\n            break;\n        }\n        if ((s >> i) & 1) {\n            if (dfs(s ^ (1 << i), (p + nums[i]) % per, per, nums, numsSize, dp)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool canPartitionKSubsets(int* nums, int numsSize, int k) {\n    int all = 0;\n    for (int i = 0; i < numsSize; i++) {\n        all += nums[i];\n    }\n    if (all % k > 0) {\n        return false;\n    }\n    int per = all / k; \n    qsort(nums, numsSize, sizeof(int), cmp);\n    if (nums[numsSize - 1] > per) {\n        return false;\n    }\n    bool *dp = (bool *)malloc(sizeof(bool) * (1 << numsSize));\n    memset(dp, true, sizeof(bool) * (1 << numsSize));\n    return dfs((1 << numsSize) - 1, 0, per, nums, numsSize, dp);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar canPartitionKSubsets = function(nums, k) {\n    const dfs = (s, p) => {\n        if (s === 0) {\n            return true;\n        }\n        if (!dp[s]) {\n            return dp[s];\n        }\n        dp[s] = false;\n        for (let i = 0; i < n; i++) {\n            if (nums[i] + p > per) {\n                break;\n            }\n            if (((s >> i) & 1) != 0) {\n                if (dfs(s ^ (1 << i), (p + nums[i]) % per)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    const all = _.sum(nums);\n    if (all % k !== 0) {\n        return false;\n    }\n    per = all / k;\n    nums.sort((a, b) => a - b);\n    n = nums.length;\n    if (nums[n - 1] > per) {\n        return false;\n    }\n    dp = new Array(1 << n).fill(true);\n    return dfs((1 << n) - 1, 0);\n}\n```\n\n```go [sol1-Golang]\nfunc canPartitionKSubsets(nums []int, k int) bool {\n    all := 0\n    for _, v := range nums {\n        all += v\n    }\n    if all%k > 0 {\n        return false\n    }\n    per := all / k\n    sort.Ints(nums)\n    n := len(nums)\n    if nums[n-1] > per {\n        return false\n    }\n\n    dp := make([]bool, 1<<n)\n    for i := range dp {\n        dp[i] = true\n    }\n    var dfs func(int, int) bool\n    dfs = func(s, p int) bool {\n        if s == 0 {\n            return true\n        }\n        if !dp[s] {\n            return dp[s]\n        }\n        dp[s] = false\n        for i, num := range nums {\n            if num+p > per {\n                break\n            }\n            if s>>i&1 > 0 && dfs(s^1<<i, (p+nums[i])%per) {\n                return true\n            }\n        }\n        return false\n    }\n    return dfs(1<<n-1, 0)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times 2^n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度，共有 $2^n$ 个状态，每一个状态进行了 $n$ 次尝试。\n- 空间复杂度：$O(2^n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度，主要为状态数组的空间开销。\n\n#### 方法二：状态压缩 + 动态规划\n\n**思路与算法**\n\n我们同样可以用「动态规划」这种「自底向上」的方法来求解是否存在可行方案：同样我们用一个整数 $S$ 来表示当前可用的数字集合：从低位到高位，第 $i$ 位为 $0$ 则表示数字 $\\textit{nums}[i]$ 可以使用，否则表示 $\\textit{nums}[i]$ 已被使用。然后我们用 $\\textit{dp}[S]$ 来表示在可用的数字状态为 $S$ 的情况下是否可能可行，初始全部状态为记录为不可行状态 $\\text{False}$，只记 $\\textit{dp}[0] = \\text{True}$ 为可行状态。同样我们每次对于当前状态下从可用的数字中选择一个数字，若此时选择全部数字取模后小于等于 $\\textit{per}$。则说明选择该数字后的状态再继续往下添加数字是可能能满足题意的，并且此时标记状为可能可行状态，否则就一定不能达到满足。最终 $\\textit{dp}[U]$ 即可，其中 $U$ 表示全部数字使用的集合状态。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        all = sum(nums)\n        if all % k:\n            return False\n        per = all // k\n        nums.sort()\n        if nums[-1] > per:\n            return False\n        n = len(nums)\n        dp = [False] * (1 << n)\n        dp[0] = True\n        cursum = [0] * (1 << n)\n        for i in range(0, 1 << n):\n            if not dp[i]:\n                continue\n            for j in range(n):\n                if cursum[i] + nums[j] > per:\n                    break\n                if (i >> j & 1) == 0:\n                    next = i | (1 << j)\n                    if not dp[next]:\n                        cursum[next] = (cursum[i] + nums[j]) % per\n                        dp[next] = True\n        return dp[(1 << n) - 1]\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean canPartitionKSubsets(int[] nums, int k) {\n        int all = Arrays.stream(nums).sum();\n        if (all % k != 0) {\n            return false;\n        }\n        int per = all / k;\n        Arrays.sort(nums);\n        int n = nums.length;\n        if (nums[n - 1] > per) {\n            return false;\n        }\n        boolean[] dp = new boolean[1 << n];\n        int[] curSum = new int[1 << n];\n        dp[0] = true;\n        for (int i = 0; i < 1 << n; i++) {\n            if (!dp[i]) {\n                continue;\n            }\n            for (int j = 0; j < n; j++) {\n                if (curSum[i] + nums[j] > per) {\n                    break;\n                }\n                if (((i >> j) & 1) == 0) {\n                    int next = i | (1 << j);\n                    if (!dp[next]) {\n                        curSum[next] = (curSum[i] + nums[j]) % per;\n                        dp[next] = true;\n                    }\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public bool CanPartitionKSubsets(int[] nums, int k) {\n        int all = nums.Sum();\n        if (all % k != 0) {\n            return false;\n        }\n        int per = all / k;\n        Array.Sort(nums);\n        int n = nums.Length;\n        if (nums[n - 1] > per) {\n            return false;\n        }\n        bool[] dp = new bool[1 << n];\n        int[] curSum = new int[1 << n];\n        dp[0] = true;\n        for (int i = 0; i < 1 << n; i++) {\n            if (!dp[i]) {\n                continue;\n            }\n            for (int j = 0; j < n; j++) {\n                if (curSum[i] + nums[j] > per) {\n                    break;\n                }\n                if (((i >> j) & 1) == 0) {\n                    int next = i | (1 << j);\n                    if (!dp[next]) {\n                        curSum[next] = (curSum[i] + nums[j]) % per;\n                        dp[next] = true;\n                    }\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        int all = accumulate(nums.begin(), nums.end(), 0);\n        if (all % k > 0) {\n            return false;\n        }\n        int per = all / k; \n        sort(nums.begin(), nums.end());\n        if (nums.back() > per) {\n            return false;\n        }\n        int n = nums.size();\n        vector<bool> dp(1 << n, false);\n        vector<int> curSum(1 << n, 0);\n        dp[0] = true;\n        for (int i = 0; i < 1 << n; i++) {\n            if (!dp[i]) {\n                continue;\n            }\n            for (int j = 0; j < n; j++) {\n                if (curSum[i] + nums[j] > per) {\n                    break;\n                }\n                if (((i >> j) & 1) == 0) {\n                    int next = i | (1 << j);\n                    if (!dp[next]) {\n                        curSum[next] = (curSum[i] + nums[j]) % per;\n                        dp[next] = true;\n                    }\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n};\n```\n\n```C [sol2-C]\nstatic inline int cmp(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nbool canPartitionKSubsets(int* nums, int numsSize, int k) {\n    int all = 0;\n    for (int i = 0; i < numsSize; i++) {\n        all += nums[i];\n    }\n    if (all % k > 0) {\n        return false;\n    }\n    int per = all / k; \n    qsort(nums, numsSize, sizeof(int), cmp);\n    if (nums[numsSize - 1] > per) {\n        return false;\n    }\n    bool *dp = (bool *)malloc(sizeof(bool) * (1 << numsSize));\n    int *curSum = (int *)malloc(sizeof(int) * (1 << numsSize));\n    memset(dp, false, sizeof(bool) * (1 << numsSize));\n    memset(curSum, 0, sizeof(int) * (1 << numsSize));\n    dp[0] = true;\n    for (int i = 0; i < 1 << numsSize; i++) {\n        if (!dp[i]) {\n            continue;\n        }\n        for (int j = 0; j < numsSize; j++) {\n            if (curSum[i] + nums[j] > per) {\n                break;\n            }\n            if (((i >> j) & 1) == 0) {\n                int next = i | (1 << j);\n                if (!dp[next]) {\n                    curSum[next] = (curSum[i] + nums[j]) % per;\n                    dp[next] = true;\n                }\n            }\n        }\n    }\n    bool res = dp[(1 << numsSize) - 1];\n    free(dp);\n    free(curSum);\n    return res;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar canPartitionKSubsets = function(nums, k) {\n    const all = _.sum(nums);\n    if (all % k !== 0) {\n        return false;\n    }\n    let per = all / k;\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    if (nums[n - 1] > per) {\n        return false;\n    }\n    const dp = new Array(1 << n).fill(false);\n    const curSum = new Array(1 << n).fill(0);\n    dp[0] = true;\n    for (let i = 0; i < 1 << n; i++) {\n        if (!dp[i]) {\n            continue;\n        }\n        for (let j = 0; j < n; j++) {\n            if (curSum[i] + nums[j] > per) {\n                break;\n            }\n            if (((i >> j) & 1) == 0) {\n                let next = i | (1 << j);\n                if (!dp[next]) {\n                    curSum[next] = (curSum[i] + nums[j]) % per;\n                    dp[next] = true;\n                }\n            }\n        }\n    }\n    return dp[(1 << n) - 1];\n}\n```\n\n```go [sol2-Golang]\nfunc canPartitionKSubsets(nums []int, k int) bool {\n    all := 0\n    for _, v := range nums {\n        all += v\n    }\n    if all%k > 0 {\n        return false\n    }\n    per := all / k\n    sort.Ints(nums)\n    n := len(nums)\n    if nums[n-1] > per {\n        return false\n    }\n\n    dp := make([]bool, 1<<n)\n    dp[0] = true\n    curSum := make([]int, 1<<n)\n    for i, v := range dp {\n        if !v {\n            continue\n        }\n        for j, num := range nums {\n            if curSum[i]+num > per {\n                break\n            }\n            if i>>j&1 == 0 {\n                next := i | 1<<j\n                if !dp[next] {\n                    curSum[next] = (curSum[i] + nums[j]) % per\n                    dp[next] = true\n\n                }\n            }\n        }\n    }\n    return dp[1<<n-1]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times 2^n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度，共有 $2^n$ 个状态，每一个状态进行了 $n$ 次尝试。\n- 空间复杂度：$O(2^n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度，主要为状态数组的空间开销。"
}