{
	"titleSlug": "divide-two-integers",
	"slug": "liang-shu-xiang-chu-by-leetcode-solution-5hic",
	"url": "https://leetcode-cn.com/problems/divide-two-integers/solution/liang-shu-xiang-chu-by-leetcode-solution-5hic/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![29.ä¸¤æ•°ç›¸é™¤-æ²ˆè€å¸ˆçš„å‰¯æœ¬.mp4](121a473d-cf86-44b3-9536-d5d17c003be8)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### å‰è¨€\n\nç”±äºé¢˜ç›®è§„å®šäº†ã€Œåªèƒ½å­˜å‚¨ $32$ ä½æ•´æ•°ã€ï¼Œæœ¬é¢˜è§£çš„æ­£æ–‡éƒ¨åˆ†å’Œä»£ç ä¸­éƒ½ä¸ä¼šä½¿ç”¨ä»»ä½• $64$ ä½æ•´æ•°ã€‚**è¯šç„¶ï¼Œä½¿ç”¨ $64$ ä½æ•´æ•°å¯ä»¥æå¤§åœ°æ–¹ä¾¿æˆ‘ä»¬çš„ç¼–ç ï¼Œä½†è¿™æ˜¯è¿åé¢˜ç›®è§„åˆ™çš„ã€‚**\n\nå¦‚æœé™¤æ³•ç»“æœæº¢å‡ºï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦è¿”å› $2^{31} - 1$ ä½œä¸ºç­”æ¡ˆã€‚å› æ­¤åœ¨ç¼–ç ä¹‹å‰ï¼Œæˆ‘ä»¬å¯ä»¥é¦–å…ˆå¯¹äºæº¢å‡ºæˆ–è€…å®¹æ˜“å‡ºé”™çš„è¾¹ç•Œæƒ…å†µè¿›è¡Œè®¨è®ºï¼š\n\n- å½“è¢«é™¤æ•°ä¸º $32$ ä½æœ‰ç¬¦å·æ•´æ•°çš„æœ€å°å€¼ $-2^{31}$ æ—¶ï¼š\n\n    - å¦‚æœé™¤æ•°ä¸º $1$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›ç­”æ¡ˆ $-2^{31}$ï¼›\n    - å¦‚æœé™¤æ•°ä¸º $-1$ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º $2^{31}$ï¼Œäº§ç”Ÿäº†æº¢å‡ºã€‚æ­¤æ—¶æˆ‘ä»¬éœ€è¦è¿”å› $2^{31} - 1$ã€‚\n\n- å½“é™¤æ•°ä¸º $32$ ä½æœ‰ç¬¦å·æ•´æ•°çš„æœ€å°å€¼ $-2^{31}$ æ—¶ï¼š\n\n    - å¦‚æœè¢«é™¤æ•°åŒæ ·ä¸º $-2^{31}$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›ç­”æ¡ˆ $1$ï¼›\n    - å¯¹äºå…¶ä½™çš„æƒ…å†µï¼Œæˆ‘ä»¬è¿”å›ç­”æ¡ˆ $0$ã€‚\n\n- å½“è¢«é™¤æ•°ä¸º $0$ æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›ç­”æ¡ˆ $0$ã€‚\n\nå¯¹äºä¸€èˆ¬çš„æƒ…å†µï¼Œæ ¹æ®é™¤æ•°å’Œè¢«é™¤æ•°çš„ç¬¦å·ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘ $4$ ç§ä¸åŒçš„å¯èƒ½æ€§ã€‚å› æ­¤ï¼Œä¸ºäº†æ–¹ä¾¿ç¼–ç ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¢«é™¤æ•°æˆ–è€…é™¤æ•°å–ç›¸åæ•°ï¼Œä½¿å¾—å®ƒä»¬ç¬¦å·ç›¸åŒã€‚\n\nå¦‚æœæˆ‘ä»¬å°†è¢«é™¤æ•°å’Œé™¤æ•°éƒ½å˜ä¸ºæ­£æ•°ï¼Œé‚£ä¹ˆå¯èƒ½ä¼šå¯¼è‡´æº¢å‡ºã€‚ä¾‹å¦‚å½“è¢«é™¤æ•°ä¸º $-2^{31}$ æ—¶ï¼Œå®ƒçš„ç›¸åæ•° $2^{31}$ äº§ç”Ÿäº†æº¢å‡ºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†è¢«é™¤æ•°å’Œé™¤æ•°éƒ½å˜ä¸ºè´Ÿæ•°ï¼Œè¿™æ ·å°±ä¸ä¼šæœ‰æº¢å‡ºçš„é—®é¢˜ï¼Œåœ¨ç¼–ç æ—¶åªéœ€è¦è€ƒè™‘ $1$ ç§æƒ…å†µäº†ã€‚\n\nå¦‚æœæˆ‘ä»¬å°†è¢«é™¤æ•°å’Œé™¤æ•°çš„å…¶ä¸­ï¼ˆæ°å¥½ï¼‰ä¸€ä¸ªå˜ä¸ºäº†æ­£æ•°ï¼Œé‚£ä¹ˆåœ¨è¿”å›ç­”æ¡ˆä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ç­”æ¡ˆä¹Ÿå–ç›¸åæ•°ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šäºŒåˆ†æŸ¥æ‰¾\n\n**æ€è·¯ä¸ç®—æ³•**\n\næ ¹æ®ã€Œå‰è¨€ã€éƒ¨åˆ†çš„è®¨è®ºï¼Œæˆ‘ä»¬è®°è¢«é™¤æ•°ä¸º $X$ï¼Œé™¤æ•°ä¸º $Y$ï¼Œå¹¶ä¸” $X$ å’Œ $Y$ éƒ½æ˜¯è´Ÿæ•°ã€‚æˆ‘ä»¬éœ€è¦æ‰¾å‡º $X/Y$ çš„ç»“æœ $Z$ã€‚$Z$ ä¸€å®šæ˜¯æ­£æ•°æˆ– $0$ã€‚\n\næ ¹æ®é™¤æ³•ä»¥åŠä½™æ•°çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æ”¹æˆä¹˜æ³•çš„ç­‰ä»·å½¢å¼ï¼Œå³ï¼š\n\n$$\nZ \\times Y \\geq X > (Z+1) \\times Y\n$$\n\nå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•å¾—åˆ° $Z$ï¼Œå³æ‰¾å‡º**æœ€å¤§**çš„ $Z$ ä½¿å¾— $Z \\times Y \\geq X$ æˆç«‹ã€‚\n\nç”±äºæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ä¹˜æ³•è¿ç®—ç¬¦ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä½¿ç”¨ã€Œå¿«é€Ÿä¹˜ã€ç®—æ³•å¾—åˆ° $Z \\times Y$ çš„å€¼ã€‚ã€Œå¿«é€Ÿä¹˜ã€ç®—æ³•ä¸ã€Œå¿«é€Ÿå¹‚ã€ç±»ä¼¼ï¼Œå‰è€…é€šè¿‡åŠ æ³•å®ç°ä¹˜æ³•ï¼Œåè€…é€šè¿‡ä¹˜æ³•å®ç°å¹‚è¿ç®—ã€‚ã€Œå¿«é€Ÿå¹‚ã€ç®—æ³•å¯ä»¥å‚è€ƒ[ã€Œ50. Pow(x, n)ã€çš„å®˜æ–¹é¢˜è§£](https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/)ï¼Œã€Œå¿«é€Ÿä¹˜ã€ç®—æ³•åªéœ€è¦åœ¨ã€Œå¿«é€Ÿå¹‚ã€ç®—æ³•çš„åŸºç¡€ä¸Šï¼Œå°†ä¹˜æ³•è¿ç®—æ”¹æˆåŠ æ³•è¿ç®—å³å¯ã€‚\n\n**ç»†èŠ‚**\n\nç”±äºæˆ‘ä»¬åªèƒ½ä½¿ç”¨ $32$ ä½æ•´æ•°ï¼Œå› æ­¤äºŒåˆ†æŸ¥æ‰¾ä¸­ä¼šæœ‰å¾ˆå¤šç»†èŠ‚ã€‚\n\né¦–å…ˆï¼ŒäºŒåˆ†æŸ¥æ‰¾çš„ä¸‹ç•Œä¸º $1$ï¼Œä¸Šç•Œä¸º $2^{31} - 1$ã€‚å”¯ä¸€å¯èƒ½å‡ºç°çš„ç­”æ¡ˆä¸º $2^{31}$ çš„æƒ…å†µå·²ç»è¢«æˆ‘ä»¬åœ¨ã€Œå‰è¨€ã€éƒ¨åˆ†è¿›è¡Œäº†ç‰¹æ®Šå¤„ç†ï¼Œå› æ­¤ç­”æ¡ˆçš„æœ€å¤§å€¼ä¸º $2^{31} - 1$ã€‚å¦‚æœäºŒåˆ†æŸ¥æ‰¾å¤±è´¥ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸€å®šä¸º $0$ã€‚\n\nåœ¨å®ç°ã€Œå¿«é€Ÿä¹˜ã€æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨åŠ æ³•è¿ç®—ï¼Œç„¶è€Œè¾ƒå¤§çš„ $Z$ ä¹Ÿä¼šå¯¼è‡´åŠ æ³•è¿ç®—æº¢å‡ºã€‚ä¾‹å¦‚æˆ‘ä»¬è¦åˆ¤æ–­ $A + B$ æ˜¯å¦å°äº $C$ æ—¶ï¼ˆå…¶ä¸­ $A, B, C$ å‡ä¸ºè´Ÿæ•°ï¼‰ï¼Œ$A + B$ å¯èƒ½ä¼šäº§ç”Ÿæº¢å‡ºï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»å°†åˆ¤æ–­æ”¹ä¸º $A < C - B$ æ˜¯å¦æˆç«‹ã€‚ç”±äºä»»æ„ä¸¤ä¸ªè´Ÿæ•°çš„å·®ä¸€å®šåœ¨ $[-2^{31} + 1, 2^{31} - 1]$ èŒƒå›´å†…ï¼Œè¿™æ ·å°±ä¸ä¼šäº§ç”Ÿæº¢å‡ºã€‚\n\nè¯»è€…å¯ä»¥é˜…è¯»ä¸‹é¢çš„ä»£ç å’Œæ³¨é‡Šï¼Œç†è§£å¦‚ä½•é¿å…ä½¿ç”¨ä¹˜æ³•å’Œé™¤æ³•ï¼Œä»¥åŠæ­£ç¡®å¤„ç†æº¢å‡ºé—®é¢˜ã€‚\n\n**ä»£ç **\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (dividend == INT_MIN) {\n            if (divisor == 1) {\n                return INT_MIN;\n            }\n            if (divisor == -1) {\n                return INT_MAX;\n            }\n        }\n        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (divisor == INT_MIN) {\n            return dividend == INT_MIN ? 1 : 0;\n        }\n        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n        if (dividend == 0) {\n            return 0;\n        }\n        \n        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾\n        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n        bool rev = false;\n        if (dividend > 0) {\n            dividend = -dividend;\n            rev = !rev;\n        }\n        if (divisor > 0) {\n            divisor = -divisor;\n            rev = !rev;\n        }\n\n        // å¿«é€Ÿä¹˜\n        auto quickAdd = [](int y, int z, int x) {\n            // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°\n            // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹\n            int result = 0, add = y;\n            while (z) {\n                if (z & 1) {\n                    // éœ€è¦ä¿è¯ result + add >= x\n                    if (result < x - add) {\n                        return false;\n                    }\n                    result += add;\n                }\n                if (z != 1) {\n                    // éœ€è¦ä¿è¯ add + add >= x\n                    if (add < x - add) {\n                        return false;\n                    }\n                    add += add;\n                }\n                // ä¸èƒ½ä½¿ç”¨é™¤æ³•\n                z >>= 1;\n            }\n            return true;\n        };\n        \n        int left = 1, right = INT_MAX, ans = 0;\n        while (left <= right) {\n            // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•\n            int mid = left + ((right - left) >> 1);\n            bool check = quickAdd(divisor, mid, dividend);\n            if (check) {\n                ans = mid;\n                // æ³¨æ„æº¢å‡º\n                if (mid == INT_MAX) {\n                    break;\n                }\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n\n        return rev ? -ans : ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int divide(int dividend, int divisor) {\n        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (dividend == Integer.MIN_VALUE) {\n            if (divisor == 1) {\n                return Integer.MIN_VALUE;\n            }\n            if (divisor == -1) {\n                return Integer.MAX_VALUE;\n            }\n        }\n        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (divisor == Integer.MIN_VALUE) {\n            return dividend == Integer.MIN_VALUE ? 1 : 0;\n        }\n        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n        if (dividend == 0) {\n            return 0;\n        }\n        \n        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾\n        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n        boolean rev = false;\n        if (dividend > 0) {\n            dividend = -dividend;\n            rev = !rev;\n        }\n        if (divisor > 0) {\n            divisor = -divisor;\n            rev = !rev;\n        }\n        \n        int left = 1, right = Integer.MAX_VALUE, ans = 0;\n        while (left <= right) {\n            // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•\n            int mid = left + ((right - left) >> 1);\n            boolean check = quickAdd(divisor, mid, dividend);\n            if (check) {\n                ans = mid;\n                // æ³¨æ„æº¢å‡º\n                if (mid == Integer.MAX_VALUE) {\n                    break;\n                }\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return rev ? -ans : ans;\n    }\n\n    // å¿«é€Ÿä¹˜\n    public boolean quickAdd(int y, int z, int x) {\n        // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°\n        // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹\n        int result = 0, add = y;\n        while (z != 0) {\n            if ((z & 1) != 0) {\n                // éœ€è¦ä¿è¯ result + add >= x\n                if (result < x - add) {\n                    return false;\n                }\n                result += add;\n            }\n            if (z != 1) {\n                // éœ€è¦ä¿è¯ add + add >= x\n                if (add < x - add) {\n                    return false;\n                }\n                add += add;\n            }\n            // ä¸èƒ½ä½¿ç”¨é™¤æ³•\n            z >>= 1;\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int Divide(int dividend, int divisor) {\n        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (dividend == int.MinValue) {\n            if (divisor == 1) {\n                return int.MinValue;\n            }\n            if (divisor == -1) {\n                return int.MaxValue;\n            }\n        }\n        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (divisor == int.MinValue) {\n            return dividend == int.MinValue ? 1 : 0;\n        }\n        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n        if (dividend == 0) {\n            return 0;\n        }\n        \n        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾\n        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n        bool rev = false;\n        if (dividend > 0) {\n            dividend = -dividend;\n            rev = !rev;\n        }\n        if (divisor > 0) {\n            divisor = -divisor;\n            rev = !rev;\n        }\n        \n        int left = 1, right = int.MaxValue, ans = 0;\n        while (left <= right) {\n            // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•\n            int mid = left + ((right - left) >> 1);\n            bool check = quickAdd(divisor, mid, dividend);\n            if (check) {\n                ans = mid;\n                // æ³¨æ„æº¢å‡º\n                if (mid == int.MaxValue) {\n                    break;\n                }\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return rev ? -ans : ans;\n    }\n\n    // å¿«é€Ÿä¹˜\n    public bool quickAdd(int y, int z, int x) {\n        // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°\n        // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹\n        int result = 0, add = y;\n        while (z != 0) {\n            if ((z & 1) != 0) {\n                // éœ€è¦ä¿è¯ result + add >= x\n                if (result < x - add) {\n                    return false;\n                }\n                result += add;\n            }\n            if (z != 1) {\n                // éœ€è¦ä¿è¯ add + add >= x\n                if (add < x - add) {\n                    return false;\n                }\n                add += add;\n            }\n            // ä¸èƒ½ä½¿ç”¨é™¤æ³•\n            z >>= 1;\n        }\n        return true;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n\n        # è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if dividend == INT_MIN:\n            if divisor == 1:\n                return INT_MIN\n            if divisor == -1:\n                return INT_MAX\n        \n        # è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if divisor == INT_MIN:\n            return 1 if dividend == INT_MIN else 0\n        # è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n        if dividend == 0:\n            return 0\n        \n        # ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾\n        # å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n        rev = False\n        if dividend > 0:\n            dividend = -dividend\n            rev = not rev\n        if divisor > 0:\n            divisor = -divisor\n            rev = not rev\n\n        # å¿«é€Ÿä¹˜\n        def quickAdd(y: int, z: int, x: int) -> bool:\n            # x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°\n            # éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹\n            result, add = 0, y\n            while z > 0:\n                if (z & 1) == 1:\n                    # éœ€è¦ä¿è¯ result + add >= x\n                    if result < x - add:\n                        return False\n                    result += add\n                if z != 1:\n                    # éœ€è¦ä¿è¯ add + add >= x\n                    if add < x - add:\n                        return False\n                    add += add\n                # ä¸èƒ½ä½¿ç”¨é™¤æ³•\n                z >>= 1\n            return True\n        \n        left, right, ans = 1, INT_MAX, 0\n        while left <= right:\n            # æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•\n            mid = left + ((right - left) >> 1)\n            check = quickAdd(divisor, mid, dividend)\n            if check:\n                ans = mid\n                # æ³¨æ„æº¢å‡º\n                if mid == INT_MAX:\n                    break\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -ans if rev else ans\n```\n\n```go [sol1-Golang]\n// å¿«é€Ÿä¹˜\n// x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°\n// åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹\nfunc quickAdd(y, z, x int) bool {\n    for result, add := 0, y; z > 0; z >>= 1 { // ä¸èƒ½ä½¿ç”¨é™¤æ³•\n        if z&1 > 0 {\n            // éœ€è¦ä¿è¯ result + add >= x\n            if result < x-add {\n                return false\n            }\n            result += add\n        }\n        if z != 1 {\n            // éœ€è¦ä¿è¯ add + add >= x\n            if add < x-add {\n                return false\n            }\n            add += add\n        }\n    }\n    return true\n}\n\nfunc divide(dividend, divisor int) int {\n    if dividend == math.MinInt32 { // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if divisor == 1 {\n            return math.MinInt32\n        }\n        if divisor == -1 {\n            return math.MaxInt32\n        }\n    }\n    if divisor == math.MinInt32 { // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if dividend == math.MinInt32 {\n            return 1\n        }\n        return 0\n    }\n    if dividend == 0 { // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n        return 0\n    }\n\n    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾\n    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n    rev := false\n    if dividend > 0 {\n        dividend = -dividend\n        rev = !rev\n    }\n    if divisor > 0 {\n        divisor = -divisor\n        rev = !rev\n    }\n\n    ans := 0\n    left, right := 1, math.MaxInt32\n    for left <= right {\n        mid := left + (right-left)>>1 // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•\n        if quickAdd(divisor, mid, dividend) {\n            ans = mid\n            if mid == math.MaxInt32 { // æ³¨æ„æº¢å‡º\n                break\n            }\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    if rev {\n        return -ans\n    }\n    return ans\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar divide = function(dividend, divisor) {\n    const MAX_VALUE = 2 ** 31 - 1, MIN_VALUE = -(2 ** 31);\n    // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n    if (dividend === MIN_VALUE) {\n        if (divisor === 1) {\n            return MIN_VALUE;\n        }\n        if (divisor === -1) {\n            return MAX_VALUE;\n        }\n    }\n    // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n    if (divisor === MIN_VALUE) {\n        return dividend === MIN_VALUE ? 1 : 0;\n    }\n    // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n    if (dividend === 0) {\n        return 0;\n    }\n    \n    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾\n    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n    let rev = false;\n    if (dividend > 0) {\n        dividend = -dividend;\n        rev = !rev;\n    }\n    if (divisor > 0) {\n        divisor = -divisor;\n        rev = !rev;\n    }\n    \n    let left = 1, right = MAX_VALUE, ans = 0;\n    while (left <= right) {\n        // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•\n        const mid = left + ((right - left) >> 1);\n        const check = quickAdd(divisor, mid, dividend);\n        if (check) {\n            ans = mid;\n            // æ³¨æ„æº¢å‡º\n            if (mid === MAX_VALUE) {\n                break;\n            }\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return rev ? -ans : ans;\n}\n\n// å¿«é€Ÿä¹˜\nconst quickAdd = (y, z, x) => {\n    // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°\n    // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹\n    let result = 0, add = y;\n    while (z !== 0) {\n        if ((z & 1) !== 0) {\n            // éœ€è¦ä¿è¯ result + add >= x\n            if (result < x - add) {\n                return false;\n            }\n            result += add;\n        }\n        if (z !== 1) {\n            // éœ€è¦ä¿è¯ add + add >= x\n            if (add < x - add) {\n                return false;\n            }\n            add += add;\n        }\n        // ä¸èƒ½ä½¿ç”¨é™¤æ³•\n        z >>= 1;\n    }\n    return true;\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(\\log^2 C)$ï¼Œå…¶ä¸­ $C$ è¡¨ç¤º $32$ ä½æ•´æ•°çš„èŒƒå›´ã€‚äºŒåˆ†æŸ¥æ‰¾çš„æ¬¡æ•°ä¸º $O(\\log C)$ï¼Œå…¶ä¸­çš„æ¯ä¸€æ­¥æˆ‘ä»¬éƒ½éœ€è¦ $O(\\log C)$ ä½¿ç”¨ã€Œå¿«é€Ÿä¹˜ã€ç®—æ³•åˆ¤æ–­ $Z \\times Y \\geq X$ æ˜¯å¦æˆç«‹ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(\\log^2 C)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚\n\n#### æ–¹æ³•äºŒï¼šç±»äºŒåˆ†æŸ¥æ‰¾\n\n**å‰è¨€**\n\nå¸¸è§„æ„ä¹‰ä¸‹çš„äºŒåˆ†æŸ¥æ‰¾ä¸ºï¼šç»™å®šåŒºé—´ $[l, r]$ï¼Œå–è¯¥åŒºé—´çš„ä¸­ç‚¹ $\\textit{mid} = \\lfloor \\dfrac{l+r}{2} \\rfloor$ï¼Œæ ¹æ® $\\textit{mid}$ å¤„æ˜¯å¦æ»¡è¶³æŸä¸€æ¡ä»¶ï¼Œæ¥å†³å®šç§»åŠ¨å·¦è¾¹ç•Œ $l$ è¿˜æ˜¯å³è¾¹ç•Œ $r$ã€‚\n\næˆ‘ä»¬ä¹Ÿå¯ä»¥è€ƒè™‘å¦ä¸€ç§äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•ï¼š\n\n- è®° $k$ ä¸ºæ»¡è¶³ $2^k \\leq r-l < 2^{k+1}$ çš„ $k$ å€¼ã€‚\n\n- äºŒåˆ†æŸ¥æ‰¾ä¼šè¿›è¡Œ $k+1$ æ¬¡ã€‚åœ¨ç¬¬ $i ~ (1 \\leq i \\leq k+1)$ æ¬¡äºŒåˆ†æŸ¥æ‰¾æ—¶ï¼Œè®¾åŒºé—´ä¸º $[l_i, r_i]$ï¼Œæˆ‘ä»¬å– $\\textit{mid} = l_i + 2^{k+1-i}$ï¼š\n\n- å¦‚æœ $\\textit{mid}$ ä¸åœ¨ $[l_i, r_i]$ çš„èŒƒå›´å†…ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æ¥å¿½ç•¥è¿™æ¬¡äºŒåˆ†æŸ¥æ‰¾ï¼›\n\n- å¦‚æœ $\\textit{mid}$ åœ¨ $[l_i, r_i]$ çš„èŒƒå›´å†…ï¼Œå¹¶ä¸” $\\textit{mid}$ å¤„æ»¡è¶³æŸä¸€æ¡ä»¶ï¼Œæˆ‘ä»¬å°±å°† $l_i$ æ›´æ–°ä¸º $\\textit{mid}$ï¼Œå¦åˆ™åŒæ ·å¿½ç•¥è¿™æ¬¡äºŒåˆ†æŸ¥æ‰¾ã€‚\n\næœ€ç»ˆ $l_i$ å³ä¸ºäºŒåˆ†æŸ¥æ‰¾çš„ç»“æœã€‚è¿™æ ·åšçš„æ­£ç¡®æ€§åœ¨äºï¼š\n\n> è®¾åœ¨å¸¸è§„æ„ä¹‰ä¸‹çš„äºŒåˆ†æŸ¥æ‰¾çš„ç­”æ¡ˆä¸º $\\textit{ans}$ï¼Œè®° $\\delta$ ä¸º $\\textit{ans}$ ä¸å·¦è¾¹ç•Œçš„å·®å€¼ $\\textit{ans} - l$ã€‚$\\delta$ ä¸ä¼šå¤§äº $r-l$ï¼Œå¹¶ä¸” $\\delta$ ä¸€å®šå¯ä»¥ç”¨ $2^k, 2^{k-1}, 2^{k-2}, \\cdots, 2^1, 2^0$ ä¸­çš„è‹¥å¹²ä¸ªå…ƒç´ ä¹‹å’Œè¡¨ç¤ºï¼ˆè€ƒè™‘ $\\delta$ çš„äºŒè¿›åˆ¶è¡¨ç¤ºçš„æ„ä¹‰å³å¯ï¼‰ã€‚å› æ­¤ä¸Šè¿°äºŒåˆ†æŸ¥æ‰¾æ˜¯æ­£ç¡®çš„ã€‚\n\n**æ€è·¯ä¸ç®—æ³•**\n\nåŸºäºä¸Šè¿°çš„äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥è®¾è®¡å‡ºå¦‚ä¸‹çš„ç®—æ³•ï¼š\n\n- æˆ‘ä»¬é¦–å…ˆä¸æ–­åœ°å°† $Y$ ä¹˜ä»¥ $2$ï¼ˆé€šè¿‡åŠ æ³•è¿ç®—å®ç°ï¼‰ï¼Œå¹¶å°†è¿™äº›ç»“æœæ”¾å…¥æ•°ç»„ä¸­ï¼Œå…¶ä¸­æ•°ç»„çš„ç¬¬ $i$ é¡¹å°±ç­‰äº $Y \\times 2^i$ã€‚è¿™ä¸€è¿‡ç¨‹ç›´åˆ° $Y$ çš„ä¸¤å€ä¸¥æ ¼å°äº $X$ ä¸ºæ­¢ã€‚\n\n- æˆ‘ä»¬å¯¹æ•°ç»„è¿›è¡Œé€†åºéå†ã€‚å½“éå†åˆ°ç¬¬ $i$ é¡¹æ—¶ï¼Œå¦‚æœå…¶å¤§äºç­‰äº $X$ï¼Œæˆ‘ä»¬å°±å°†ç­”æ¡ˆå¢åŠ  $2^i$ï¼Œå¹¶ä¸”å°† $X$ ä¸­å‡å»è¿™ä¸€é¡¹çš„å€¼ã€‚\n\næœ¬è´¨ä¸Šï¼Œä¸Šè¿°çš„é€†åºéå†å°±æ¨¡æ‹Ÿäº†äºŒåˆ†æŸ¥æ‰¾çš„è¿‡ç¨‹ã€‚\n\n**ä»£ç **\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (dividend == INT_MIN) {\n            if (divisor == 1) {\n                return INT_MIN;\n            }\n            if (divisor == -1) {\n                return INT_MAX;\n            }\n        }\n        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (divisor == INT_MIN) {\n            return dividend == INT_MIN ? 1 : 0;\n        }\n        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n        if (dividend == 0) {\n            return 0;\n        }\n        \n        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾\n        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n        bool rev = false;\n        if (dividend > 0) {\n            dividend = -dividend;\n            rev = !rev;\n        }\n        if (divisor > 0) {\n            divisor = -divisor;\n            rev = !rev;\n        }\n\n        vector<int> candidates = {divisor};\n        // æ³¨æ„æº¢å‡º\n        while (candidates.back() >= dividend - candidates.back()) {\n            candidates.push_back(candidates.back() + candidates.back());\n        }\n        int ans = 0;\n        for (int i = candidates.size() - 1; i >= 0; --i) {\n            if (candidates[i] >= dividend) {\n                ans += (1 << i);\n                dividend -= candidates[i];\n            }\n        }\n\n        return rev ? -ans : ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int divide(int dividend, int divisor) {\n        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (dividend == Integer.MIN_VALUE) {\n            if (divisor == 1) {\n                return Integer.MIN_VALUE;\n            }\n            if (divisor == -1) {\n                return Integer.MAX_VALUE;\n            }\n        }\n        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (divisor == Integer.MIN_VALUE) {\n            return dividend == Integer.MIN_VALUE ? 1 : 0;\n        }\n        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n        if (dividend == 0) {\n            return 0;\n        }\n        \n        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾\n        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n        boolean rev = false;\n        if (dividend > 0) {\n            dividend = -dividend;\n            rev = !rev;\n        }\n        if (divisor > 0) {\n            divisor = -divisor;\n            rev = !rev;\n        }\n\n        List<Integer> candidates = new ArrayList<Integer>();\n        candidates.add(divisor);\n        int index = 0;\n        // æ³¨æ„æº¢å‡º\n        while (candidates.get(index) >= dividend - candidates.get(index)) {\n            candidates.add(candidates.get(index) + candidates.get(index));\n            ++index;\n        }\n        int ans = 0;\n        for (int i = candidates.size() - 1; i >= 0; --i) {\n            if (candidates.get(i) >= dividend) {\n                ans += 1 << i;\n                dividend -= candidates.get(i);\n            }\n        }\n\n        return rev ? -ans : ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int Divide(int dividend, int divisor) {\n        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (dividend == int.MinValue) {\n            if (divisor == 1) {\n                return int.MinValue;\n            }\n            if (divisor == -1) {\n                return int.MaxValue;\n            }\n        }\n        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if (divisor == int.MinValue) {\n            return dividend == int.MinValue ? 1 : 0;\n        }\n        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n        if (dividend == 0) {\n            return 0;\n        }\n        \n        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾\n        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n        bool rev = false;\n        if (dividend > 0) {\n            dividend = -dividend;\n            rev = !rev;\n        }\n        if (divisor > 0) {\n            divisor = -divisor;\n            rev = !rev;\n        }\n\n        IList<int> candidates = new List<int>();\n        candidates.Add(divisor);\n        int index = 0;\n        // æ³¨æ„æº¢å‡º\n        while (candidates[index] >= dividend - candidates[index]) {\n            candidates.Add(candidates[index] + candidates[index]);\n            ++index;\n        }\n        int ans = 0;\n        for (int i = candidates.Count - 1; i >= 0; --i) {\n            if (candidates[i] >= dividend) {\n                ans += 1 << i;\n                dividend -= candidates[i];\n            }\n        }\n\n        return rev ? -ans : ans;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n\n        # è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if dividend == INT_MIN:\n            if divisor == 1:\n                return INT_MIN\n            if divisor == -1:\n                return INT_MAX\n        \n        # è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if divisor == INT_MIN:\n            return 1 if dividend == INT_MIN else 0\n        # è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n        if dividend == 0:\n            return 0\n        \n        # ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾\n        # å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n        rev = False\n        if dividend > 0:\n            dividend = -dividend\n            rev = not rev\n        if divisor > 0:\n            divisor = -divisor\n            rev = not rev\n        \n        candidates = [divisor]\n        # æ³¨æ„æº¢å‡º\n        while candidates[-1] >= dividend - candidates[-1]:\n            candidates.append(candidates[-1] + candidates[-1])\n        \n        ans = 0\n        for i in range(len(candidates) - 1, -1, -1):\n            if candidates[i] >= dividend:\n                ans += (1 << i)\n                dividend -= candidates[i]\n\n        return -ans if rev else ans\n```\n\n```go [sol2-Golang]\nfunc divide(dividend, divisor int) int {\n    if dividend == math.MinInt32 { // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if divisor == 1 {\n            return math.MinInt32\n        }\n        if divisor == -1 {\n            return math.MaxInt32\n        }\n    }\n    if divisor == math.MinInt32 { // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n        if dividend == math.MinInt32 {\n            return 1\n        }\n        return 0\n    }\n    if dividend == 0 { // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n        return 0\n    }\n\n    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾\n    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n    rev := false\n    if dividend > 0 {\n        dividend = -dividend\n        rev = !rev\n    }\n    if divisor > 0 {\n        divisor = -divisor\n        rev = !rev\n    }\n\n    candidates := []int{divisor}\n    for y := divisor; y >= dividend-y; { // æ³¨æ„æº¢å‡º\n        y += y\n        candidates = append(candidates, y)\n    }\n\n    ans := 0\n    for i := len(candidates) - 1; i >= 0; i-- {\n        if candidates[i] >= dividend {\n            ans |= 1 << i\n            dividend -= candidates[i]\n        }\n    }\n    if rev {\n        return -ans\n    }\n    return ans\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar divide = function(dividend, divisor) {\n    const MAX_VALUE = 2 ** 31 - 1, MIN_VALUE = -(2 ** 31);\n    // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n    if (dividend === MIN_VALUE) {\n        if (divisor === 1) {\n            return MIN_VALUE;\n        }\n        if (divisor === -1) {\n            return MAX_VALUE;\n        }\n    }\n    // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ\n    if (divisor === MIN_VALUE) {\n        return dividend === MIN_VALUE ? 1 : 0;\n    }\n    // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ\n    if (dividend === 0) {\n        return 0;\n    }\n    \n    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾\n    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ\n    let rev = false;\n    if (dividend > 0) {\n        dividend = -dividend;\n        rev = !rev;\n    }\n    if (divisor > 0) {\n        divisor = -divisor;\n        rev = !rev;\n    }\n\n    const candidates = [divisor];\n    let index = 0;\n    // æ³¨æ„æº¢å‡º\n    while (candidates[index] >= dividend - candidates[index]) {\n        candidates.push(candidates[index] + candidates[index]);\n        ++index;\n    }\n    let ans = 0;\n    for (let i = candidates.length - 1; i >= 0; --i) {\n        if (candidates[i] >= dividend) {\n            ans += 1 << i;\n            dividend -= candidates[i];\n        }\n    }\n\n    return rev ? -ans : ans;\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(\\log C)$ï¼Œå³ä¸ºäºŒåˆ†æŸ¥æ‰¾éœ€è¦çš„æ—¶é—´ã€‚æ–¹æ³•äºŒæ—¶é—´å¤æ‚åº¦ä¼˜äºæ–¹æ³•ä¸€çš„åŸå› æ˜¯ï¼šæ–¹æ³•ä¸€çš„æ¯ä¸€æ­¥äºŒåˆ†æŸ¥æ‰¾éƒ½éœ€è¦é‡æ–°è®¡ç®— $Z \\times Y$ çš„å€¼ï¼Œéœ€è¦ $O(\\log C)$ çš„æ—¶é—´å¤æ‚åº¦ï¼›è€Œæ–¹æ³•äºŒçš„æ¯ä¸€æ­¥çš„æƒé‡éƒ½æ˜¯ $2$ çš„å¹‚ï¼Œåœ¨äºŒåˆ†æŸ¥æ‰¾å¼€å§‹å‰å°±éƒ½æ˜¯å·²çŸ¥çš„å€¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨ $O(\\log C)$ çš„æ—¶é—´å†…ï¼Œä¸€æ¬¡æ€§å°†å®ƒä»¬å…¨éƒ¨é¢„å¤„ç†å‡ºæ¥ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(\\log C)$ï¼Œå³ä¸ºéœ€è¦å­˜å‚¨çš„ $Y \\times 2^i$ çš„æ•°é‡ã€‚"
}