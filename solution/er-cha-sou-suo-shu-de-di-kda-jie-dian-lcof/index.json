{
	"titleSlug": "er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof",
	"slug": "mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d",
	"url": "https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/",
	"content": "#### 解题思路：\r\n\r\n> 本文解法基于此性质：二叉搜索树的中序遍历为 **递增序列** 。\r\n\r\n- 根据以上性质，易得二叉搜索树的 **中序遍历倒序** 为 **递减序列** 。\r\n- 因此，求 “二叉搜索树第 $k$ 大的节点” 可转化为求 “此树的中序遍历倒序的第 $k$ 个节点”。\r\n\r\n![Picture1.png](https://pic.leetcode-cn.com/4ebcaefd4ecec0d76bfab98474dfed323fb86bfcd685d1a5bf610200fdca4405-Picture1.png){:width=450}\r\n\r\n> **中序遍历** 为 “左、根、右” 顺序，递归法代码如下：\r\n\r\n```Python []\r\n# 打印中序遍历\r\ndef dfs(root):\r\n    if not root: return\r\n    dfs(root.left)  # 左\r\n    print(root.val) # 根\r\n    dfs(root.right) # 右\r\n```\r\n\r\n```Java []\r\n// 打印中序遍历\r\nvoid dfs(TreeNode root) {\r\n    if(root == null) return;\r\n    dfs(root.left); // 左\r\n    System.out.println(root.val); // 根\r\n    dfs(root.right); // 右\r\n}\r\n```\r\n\r\n> **中序遍历的倒序** 为 “右、根、左” 顺序，递归法代码如下：\r\n\r\n```Python []\r\n# 打印中序遍历倒序\r\ndef dfs(root):\r\n    if not root: return\r\n    dfs(root.right) # 右\r\n    print(root.val) # 根\r\n    dfs(root.left)  # 左\r\n```\r\n\r\n```Java []\r\n// 打印中序遍历倒序\r\nvoid dfs(TreeNode root) {\r\n    if(root == null) return;\r\n    dfs(root.right); // 右\r\n    System.out.println(root.val); // 根\r\n    dfs(root.left); // 左\r\n}\r\n```\r\n\r\n- 为求第 $k$ 个节点，需要实现以下 **三项工作** ：\r\n  1. 递归遍历时计数，统计当前节点的序号；\r\n  2. 递归到第 $k$ 个节点时，应记录结果 $res$ ；\r\n  3. 记录结果后，后续的遍历即失去意义，应提前终止（即返回）。\r\n\r\n##### 递归解析：\r\n\r\n1. **终止条件：** 当节点 $root$ 为空（越过叶节点），则直接返回；\r\n2. **递归右子树：** 即 $dfs(root.right)$ ；\r\n3. **三项工作：**\r\n   1. 提前返回： 若 $k = 0$ ，代表已找到目标节点，无需继续遍历，因此直接返回；\r\n   2. 统计序号： 执行 $k = k - 1$ （即从 $k$ 减至 $0$ ）；\r\n   3. 记录结果： 若 $k = 0$ ，代表当前节点为第 $k$ 大的节点，因此记录 $res = root.val$ ；\r\n4. **递归左子树：** 即 $dfs(root.left)$ ；\r\n\r\n<![Picture1.png](https://pic.leetcode-cn.com/e34ef69025595a78434979a4be06a58b2add26ec11c56c764e73f37026e23282-Picture1.png),![Picture2.png](https://pic.leetcode-cn.com/696765554befabcd7dd53531b92bb174df131b0b691665d072a8164ab73516cd-Picture2.png),![Picture3.png](https://pic.leetcode-cn.com/1b64db28be8a3e70bce2838a82a182fce8913add1edbc44affca492a2dbda597-Picture3.png),![Picture4.png](https://pic.leetcode-cn.com/e1726df25ed3542175bc113d1324a80da314f75f876c2189c7d6b3a0562cb9cc-Picture4.png),![Picture5.png](https://pic.leetcode-cn.com/0cc14ed09ec40612bb852b20580442b3d7794adfa8772203834ec678c31c12c5-Picture5.png),![Picture6.png](https://pic.leetcode-cn.com/0d73c98b73e942c5609e64b73d05571e113cf546fd219a14374367c460db2574-Picture6.png),![Picture7.png](https://pic.leetcode-cn.com/29c51f6f83eb47498a05a5aa0c56a41cead769881ecde18d53b76b6e7147177d-Picture7.png)>\r\n\r\n##### 复杂度分析：\r\n\r\n- **时间复杂度 $O(N)$ ：** 当树退化为链表时（全部为右子节点），无论 $k$ 的值大小，递归深度都为 $N$ ，占用 $O(N)$ 时间。\r\n- **空间复杂度 $O(N)$ ：**  当树退化为链表时（全部为右子节点），系统使用 $O(N)$ 大小的栈空间。\r\n\r\n#### 代码：\r\n\r\n> 题目指出：$1 \\leq k \\leq N$ （二叉搜索树节点个数）；因此无需考虑 $k > N$ 的情况。\r\n> 若考虑，可以在中序遍历完成后判断 $k > 0$ 是否成立，若成立则说明 $k > N$ 。\r\n\r\n```Python []\r\nclass Solution:\r\n    def kthLargest(self, root: TreeNode, k: int) -> int:\r\n        def dfs(root):\r\n            if not root: return\r\n            dfs(root.right)\r\n            if self.k == 0: return\r\n            self.k -= 1\r\n            if self.k == 0: self.res = root.val\r\n            dfs(root.left)\r\n\r\n        self.k = k\r\n        dfs(root)\r\n        return self.res\r\n```\r\n\r\n```Java []\r\nclass Solution {\r\n    int res, k;\r\n    public int kthLargest(TreeNode root, int k) {\r\n        this.k = k;\r\n        dfs(root);\r\n        return res;\r\n    }\r\n    void dfs(TreeNode root) {\r\n        if(root == null) return;\r\n        dfs(root.right);\r\n        if(k == 0) return;\r\n        if(--k == 0) res = root.val;\r\n        dfs(root.left);\r\n    }\r\n}\r\n```"
}