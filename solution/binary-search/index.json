{
	"titleSlug": "binary-search",
	"slug": "er-fen-cha-zhao-by-leetcode-solution-f0xw",
	"url": "https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/",
	"content": "#### 方法一：二分查找\n\n在升序数组 $\\textit{nums}$ 中寻找目标值 $\\textit{target}$，对于特定下标 $i$，比较 $\\textit{nums}[i]$ 和 $\\textit{target}$ 的大小：\n\n- 如果 $\\textit{nums}[i] = \\textit{target}$，则下标 $i$ 即为要寻找的下标；\n\n- 如果 $\\textit{nums}[i] > \\textit{target}$，则 $\\textit{target}$ 只可能在下标 $i$ 的左侧；\n\n- 如果 $\\textit{nums}[i] < \\textit{target}$，则 $\\textit{target}$ 只可能在下标 $i$ 的右侧。\n\n基于上述事实，可以在有序数组中使用二分查找寻找目标值。\n\n二分查找的做法是，定义查找的范围 $[\\textit{left}, \\textit{right}]$，初始查找范围是整个数组。每次取查找范围的中点 $\\textit{mid}$，比较 $\\textit{nums}[\\textit{mid}]$ 和 $\\textit{target}$ 的大小，如果相等则 $\\textit{mid}$ 即为要寻找的下标，如果不相等则根据 $\\textit{nums}[\\textit{mid}]$ 和 $\\textit{target}$ 的大小关系将查找范围缩小一半。\n\n由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 $O(\\log n)$，其中 $n$ 是数组的长度。\n\n二分查找的条件是查找范围不为空，即 $\\textit{left} \\le \\textit{right}$。如果 $\\textit{target}$ 在数组中，二分查找可以保证找到 $\\textit{target}$，返回 $\\textit{target}$ 在数组中的下标。如果 $\\textit{target}$ 不在数组中，则当 $\\textit{left} > \\textit{right}$ 时结束查找，返回 $-1$。\n\n```Java [sol1-Java]\nclass Solution {\n    public int search(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = (right - left) / 2 + left;\n            int num = nums[mid];\n            if (num == target) {\n                return mid;\n            } else if (num > target) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int Search(int[] nums, int target) {\n        int left = 0, right = nums.Length - 1;\n        while (left <= right) {\n            int mid = (right - left) / 2 + left;\n            int num = nums[mid];\n            if (num == target) {\n                return mid;\n            } else if (num > target) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        while(left <= right){\n            int mid = (right - left) / 2 + left;\n            int num = nums[mid];\n            if (num == target) {\n                return mid;\n            } else if (num > target) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n```JavaScript [sol1-JavaScript]\nvar search = function(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        const mid = Math.floor((right - left) / 2) + left;\n        const num = nums[mid];\n        if (num === target) {\n            return mid;\n        } else if (num > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return -1;\n};\n```\n\n```go [sol1-Golang]\nfunc search(nums []int, target int) int {\n    left, right := 0, len(nums)-1\n    for left <= right {\n        mid := (right-left)/2 + left\n        num := nums[mid]\n        if num == target {\n            return mid\n        } else if num > target {\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return -1\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (right - left) // 2 + left\n            num = nums[mid]\n            if num == target:\n                return mid\n            elif num > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$，其中 $n$ 是数组的长度。\n\n- 空间复杂度：$O(1)$。"
}