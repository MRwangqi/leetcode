{
	"titleSlug": "best-line-lcci",
	"slug": "ha-xi-biao-by-reigo-xxrw",
	"url": "https://leetcode-cn.com/problems/best-line-lcci/solution/ha-xi-biao-by-reigo-xxrw/",
	"content": "![QQ截图20220919172258.png](https://pic.leetcode-cn.com/1663579394-MOGLNJ-QQ%E6%88%AA%E5%9B%BE20220919172258.png)\r\n\r\n# 解题思路\r\n- 当固定一个点i时，只需计算其他点与固定点i的斜率，用哈希表记录下来。当斜率相同时，证明这些点都在一条直线上。\r\n- 已经计算过的点不必再次计算，因为如果先计算别的点，同一直线上的点数也不会发生变化。\r\n\r\n![QQ截图20220919175133.png](https://pic.leetcode-cn.com/1663581123-Coeqgq-QQ%E6%88%AA%E5%9B%BE20220919175133.png)\r\n\r\n\r\n# 注意事项\r\n- 当斜率为无穷时，在哈希表中需要单独记录\r\n\r\n# 复杂度\r\n- 时间复杂度：O(n2)\r\n- 空间复杂度：O(n)\r\n\r\n# 代码\r\n```\r\nclass Solution:\r\n    def bestLine(self, points: List[List[int]]) -> List[int]:\r\n        ansnum=0\r\n        ans=[]\r\n        for i in range(len(points)):\r\n            x,y=points[i]\r\n            dict=defaultdict(list)\r\n            for j in range(i+1,len(points)):\r\n                tx,ty=points[j]\r\n                if tx-x==0:\r\n                    dict[\"inf\"].append(j)\r\n                else:\r\n                    k=(ty-y)/(tx-x)\r\n                    dict[k].append(j)\r\n            for k in dict:\r\n                if len(dict[k])+1>ansnum:\r\n                    ans=[i]+dict[k]\r\n                    ansnum=len(dict[k])+1\r\n        return ans[0:2]\r\n```\r\n# 代码详解\r\n1. 双重循环计算j点和i点的斜率k\r\n2. 以i点为固定点，将j点和i点的斜率k加入哈希表\r\n3. 找到以i点为固定点时，哈希表中斜率相同的点数最多的为答案\r\n4. 返回答案中的前两个点\r\n"
}