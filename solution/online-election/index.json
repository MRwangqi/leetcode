{
	"titleSlug": "online-election",
	"slug": "zai-xian-xuan-ju-by-leetcode-solution-4835",
	"url": "https://leetcode-cn.com/problems/online-election/solution/zai-xian-xuan-ju-by-leetcode-solution-4835/",
	"content": "#### 方法一：预计算 + 二分查找\n\n**思路及解法**\n\n记 $\\textit{persons}$ 的长度为 $N$。我们对输入进行预计算，用一个长度为 $N$ 的数组 $\\textit{tops}$ 记录各时间段得票领先的候选人。具体来说，$\\textit{tops}[i]$ 表示\n\n$$\n\\begin{cases} \n\\textit{times}[i] \\leq t < \\textit{times}[i+1], &0 \\leq i < N-1\\\\\nt \\ge \\textit{times}[i], &i = N-1\n\\end{cases}\n$$\n\n的时间段中领先的候选人。这样的预计算可以通过对 $\\textit{persons}$ 在 $\\textit{times}$ 上的计数完成。具体实现方法是，我们用一个哈希表 $\\textit{voteCounts}$ 记录不同候选人的得票数，用一个变量 $\\textit{top}$ 表示当前领先的候选人。按时间从小到大遍历 $\\textit{persons}$ 和 $\\textit{times}$，并更新 $\\textit{voteCounts}$ 和 $\\textit{top}$，把 $\\textit{top}$ 放入 $\\textit{tops}$。遍历结束后，我们可以得到一个长度为 $N$ 的 $\\textit{tops}$，表示各个时间段得票领先的候选人。\n\n每次查询时，我们在 $\\textit{times}$ 中找出不大于 $t$ 且离 $t$ 最近的元素的下标，这步操作可以通过二分查找完成。到 $\\textit{tops}$ 索引相同的下标即可返回结果。\n\n**代码**\n\n```Python [sol1-Python3]\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        tops = []\n        voteCounts = defaultdict(int)\n        voteCounts[-1] = -1\n        top = -1\n        for p in persons:\n            voteCounts[p] += 1\n            if voteCounts[p] >= voteCounts[top]:\n                top = p\n            tops.append(top)\n        self.tops = tops\n        self.times = times\n        \n    def q(self, t: int) -> int:\n        l, r = 0, len(self.times) - 1\n        # 找到满足 times[l] <= t 的最大的 l\n        while l < r:\n            m = l + (r - l + 1) // 2\n            if self.times[m] <= t:\n                l = m\n            else:\n                r = m - 1\n        # 也可以使用内置的二分查找的包来确定 l\n        # l = bisect.bisect(self.times, t) - 1\n        return self.tops[l]\n```\n\n```Java [sol1-Java]\nclass TopVotedCandidate {\n    List<Integer> tops;\n    Map<Integer, Integer> voteCounts;\n    int[] times;\n\n    public TopVotedCandidate(int[] persons, int[] times) {\n        tops = new ArrayList<Integer>();\n        voteCounts = new HashMap<Integer, Integer>();\n        voteCounts.put(-1, -1);\n        int top = -1;\n        for (int i = 0; i < persons.length; ++i) {\n            int p = persons[i];\n            voteCounts.put(p, voteCounts.getOrDefault(p, 0) + 1);\n            if (voteCounts.get(p) >= voteCounts.get(top)) {\n                top = p;\n            }\n            tops.add(top);\n        }\n        this.times = times;\n    }\n    \n    public int q(int t) {\n        int l = 0, r = times.length - 1;\n        // 找到满足 times[l] <= t 的最大的 l\n        while (l < r) {\n            int m = l + (r - l + 1) / 2;\n            if (times[m] <= t) {\n                l = m;\n            } else {\n                r = m - 1;\n            }\n        }\n        return tops.get(l);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class TopVotedCandidate {\n    IList<int> tops;\n    Dictionary<int, int> voteCounts;\n    int[] times;\n\n    public TopVotedCandidate(int[] persons, int[] times) {\n        tops = new List<int>();\n        voteCounts = new Dictionary<int, int>();\n        voteCounts.Add(-1, -1);\n        int top = -1;\n        for (int i = 0; i < persons.Length; ++i) {\n            int p = persons[i];\n            if (!voteCounts.ContainsKey(p)) {\n                voteCounts.Add(p, 0);\n            } else {\n                ++voteCounts[p];\n            }\n            if (voteCounts[p] >= voteCounts[top]) {\n                top = p;\n            }\n            tops.Add(top);\n        }\n        this.times = times;\n    }\n    \n    public int Q(int t) {\n        int l = 0, r = times.Length - 1;\n        // 找到满足 times[l] <= t 的最大的 l\n        while (l < r) {\n            int m = l + (r - l + 1) / 2;\n            if (times[m] <= t) {\n                l = m;\n            } else {\n                r = m - 1;\n            }\n        }\n        return tops[l];\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass TopVotedCandidate {\npublic:\n    vector<int> tops;\n    vector<int> times;\n\n    TopVotedCandidate(vector<int>& persons, vector<int>& times) {\n        unordered_map<int, int> voteCounts;\n        voteCounts[-1] = -1;\n        int top = -1;\n        for (auto & p : persons) {\n            voteCounts[p]++;\n            if (voteCounts[p] >= voteCounts[top]) {\n                top = p;\n            }\n            tops.emplace_back(top);\n        }\n        this->times = times;\n    }\n    \n    int q(int t) {\n        int pos = upper_bound(times.begin(), times.end(), t) - times.begin() - 1;\n        return tops[pos];\n    }\n};\n```\n\n```go [sol1-Golang]\ntype TopVotedCandidate struct {\n    tops, times []int\n}\n\nfunc Constructor(persons, times []int) TopVotedCandidate {\n    tops := []int{}\n    top := -1\n    voteCounts := map[int]int{-1: -1}\n    for _, p := range persons {\n        voteCounts[p]++\n        if voteCounts[p] >= voteCounts[top] {\n            top = p\n        }\n        tops = append(tops, top)\n    }\n    return TopVotedCandidate{tops, times}\n}\n\nfunc (c *TopVotedCandidate) Q(t int) int {\n    return c.tops[sort.SearchInts(c.times, t+1)-1]\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar TopVotedCandidate = function(persons, times) {\n    this.tops = [];\n    this.voteCounts = new Map();\n    this.voteCounts.set(-1, -1);\n    this.times = times;\n    let top = -1;\n    for (let i = 0; i < persons.length; ++i) {\n        const p = persons[i];\n        if (!this.voteCounts.has(p)) {\n            this.voteCounts.set(p, 0);\n        } else {\n            this.voteCounts.set(p, this.voteCounts.get(p) + 1);\n        }\n        if (this.voteCounts.get(p) >= this.voteCounts.get(top)) {\n            top = p;\n        }\n        this.tops.push(top);\n    }\n};\n\nTopVotedCandidate.prototype.q = function(t) {\n    let l = 0, r = this.times.length - 1;\n    // 找到满足 times[l] <= t 的最大的 l\n    while (l < r) {\n        const m = l + Math.floor((r - l + 1) / 2);\n        if (this.times[m] <= t) {\n            l = m;\n        } else {\n            r = m - 1;\n        }\n    }\n\n    return this.tops[l];\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int * tops;\n    int * times;\n    int timesSize;\n} TopVotedCandidate;\n\n\nTopVotedCandidate* topVotedCandidateCreate(int* persons, int personsSize, int* times, int timesSize) {\n    if (NULL == persons || NULL == times || persons <= 0 || timesSize <= 0) {\n        return NULL;\n    }\n\n    TopVotedCandidate * obj = (TopVotedCandidate *)malloc(sizeof(TopVotedCandidate));\n    int * voteCounts = (int *)malloc(sizeof(int) * personsSize); \n    memset(voteCounts, 0 ,sizeof(int) * personsSize);\n    obj->timesSize = timesSize;\n    obj->tops = (int *)malloc(sizeof(int) * personsSize);\n    obj->times = (int *)malloc(sizeof(int) * timesSize);\n    int top = -1;\n    for (int i = 0; i < personsSize; ++i) {\n        voteCounts[persons[i]]++;\n        if (top < 0 || voteCounts[persons[i]] >= voteCounts[top]) {\n            top = persons[i];\n        }\n        obj->tops[i] = top;\n    }\n    for (int i = 0; i < timesSize; ++i) {\n        obj->times[i] = times[i];\n    }\n    free(voteCounts);\n    return obj;\n}\n\nint topVotedCandidateQ(TopVotedCandidate* obj, int t) {\n    if (NULL == obj) {\n        return -1;\n    }\n    int l = 0, r = obj->timesSize - 1;\n    while (l < r) {\n        int m = l + (r - l + 1) / 2;\n        if (obj->times[m] <= t) {\n            l = m;\n        } else {\n            r = m - 1;\n        }\n    }\n    return obj->tops[l];\n}\n\nvoid topVotedCandidateFree(TopVotedCandidate* obj) {\n    if (NULL == obj) {\n        return;\n    }\n    free(obj->tops);\n    free(obj->times);\n    free(obj);\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：预处理的时间复杂度为 $O(N)$，其中 $N$ 为 $\\textit{persons}$ 的长度。单次查询的时间复杂度为 $O(\\log N)$。\n\n- 空间复杂度：$O(N)$。"
}