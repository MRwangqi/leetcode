{
	"titleSlug": "make-array-strictly-increasing",
	"slug": "yi-wei-dp-si-lu-xiang-jie-cpy3-by-newhar",
	"url": "https://leetcode-cn.com/problems/make-array-strictly-increasing/solution/yi-wei-dp-si-lu-xiang-jie-cpy3-by-newhar/",
	"content": "### 解题思路\r\n#### 状态定义\r\n定义 $f(i)$ 为使数组 $\\texttt{arr1}$ 的前 $i+1$ 项（下标 $0\\sim i$）递增，且 **保留** $\\texttt{arr1[i]}$   的情况下的最小替换次数。\r\n> 为什么要不替换 $\\texttt{arr1[i]}$ 呢？因为如果替换，那么到底替换成哪个数，就得另加一个状态维护。可如果 $\\texttt{arr1}$ 的最后一项也要替换呢？我们可以在数组最后增加一个非常大的数，而这个数不替换即可。\r\n\r\n#### 状态转移\r\n首先将 $\\texttt{arr2}$ 从小到大排序，去重。\r\n考虑 $f(i)$，由于我们不能替换 $\\texttt{arr1[i]}$，那么我们考虑是否替换 $\\texttt{arr1[i-1]}$（如果有）。\r\n#### 1° 如果 替换 $\\texttt{arr1[i-1]}$：\r\n$\\texttt{arr1[i-1]}$ 应当越大越好，但是不能等于或超过 $\\texttt{arr1[i]}$。我们可以二分查找出 $\\texttt{arr2}$ 中第一个等于或超过 $\\texttt{arr1[i]}$ 的数 $\\texttt{arr2[j]}$，然后将 $\\texttt{arr1[i-1]}$ 替换为 $\\texttt{arr2[j-1]}$。\r\n\r\n我们可以继续考虑 $\\texttt{arr1[i-2]}$ （如果有），如果仍然想替换它，那么显然 $\\texttt{arr2[j-1]}$ 是不能再用了，应当选择更小一点的 $\\texttt{arr2[j-2]}$ （如果有）。以此类推，我们还可以继续把 $\\texttt{arr1[i-3]}$ 替换成 $\\texttt{arr2[j-3]}$，等等等等，直到我们不想再替换。\r\n\r\n设已经替换了 $k$ 个数而我们不想再替换了，那就意味着需要保留 $\\texttt{arr1[i-k-1]}$，但这是有条件的，由于 $\\texttt{arr1[i-k]}$ 被替换成了 $\\texttt{arr2[j-k]}$，故只有当 $\\texttt{arr1[i-k-1] < arr2[j-k]}$ 才可以保证序列递增。若我们保留 $\\texttt{arr1[i-k-1]}$，问题就可以被转化为 $f(i-k-1)+k$。\r\n\r\n我们可以枚举 $k$ 进行状态转移。显然 $k$ 不能超过 $j$，也就是最多可供替换的 $\\texttt{arr2}$ 的数字个数；另外 $k$ 也不能超过 $i$，也就是最多能被替换的 $\\texttt{arr1}$ 的数字个数。\r\n>但是有个问题，如果 $k=i$，那么 $\\texttt{arr1[i-k-1] = arr1[-1]}$ 是不存在的。解决方案是在 $\\texttt{arr1}$ 之前添加一个非常小的数（如 $-1$），然后令 $k$ 不超过 $i-1$ 即可。此时的 $\\texttt{arr1[0]}$ 充当了前面的 $\\texttt{arr1[-1]}$ 的作用。\r\n\r\n#### 2° 如果 保留 $\\texttt{arr1[i-1]}$，则需要满足 $\\texttt{arr1[i-1] < arr1[i]}$，此时 $f(i) = \\min(f(i),f(i-1))$\r\n\r\n综上所述，我们在 $\\texttt{arr1}$ 的两侧加上哨兵： $\\texttt{arr1 = [-1] + arr1 + [inf]}$，然后按如下的转移方程执行即可：\r\n$$ \\begin{aligned}f(0) =& \\ 0 \\\\f(i) =& \\min\\left(f(i-k-1) + k\\right), i \\geq 1 \\\\ &\\mathbf{where}\\  1\\leq k \\leq \\min(i-1,j), \\ \\  \\text{arr1}[i-k-1] < \\text{arr2}[j-k] \\\\  f(i) =& \\min(f(i),f(i-1))\\ \\mathbf{if}\\ \\text{arr1}[i] < \\text{arr1}[i-1], i\\geq 1\\end{aligned}$$\r\n\r\n### 代码\r\n```c++ [1]\r\nclass Solution {\r\npublic:\r\n    int maxv = 1e9;\r\n    int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) {\r\n        // 预处理：排序，去重，加哨兵\r\n        sort(arr2.begin(), arr2.end());\r\n        arr2.erase(unique(arr2.begin(), arr2.end()), arr2.end());\r\n        arr1.push_back(maxv + 5); // 右侧哨兵 inf\r\n        arr1.insert(arr1.begin(), -1); // 左侧哨兵 -1\r\n\r\n        vector<int> dp(arr1.size(), maxv);\r\n        dp[0] = 0;\r\n        for(int i = 1; i < arr1.size(); ++i) {\r\n            int j = lower_bound(arr2.begin(),arr2.end(), arr1[i]) - arr2.begin();\r\n            for(int k = 1; k <= min(i-1,j); ++k){ // 1. 枚举替换的个数 k = 1 to min(i-1,j)\r\n                if(arr1[i-k-1] < arr2[j-k]) {\r\n                    dp[i] = min(dp[i], dp[i-k-1] + k);\r\n                }\r\n            }\r\n            if(arr1[i-1] < arr1[i]) { // 2. 不替换 arr1[i-1]\r\n                dp[i] = min(dp[i], dp[i-1]);\r\n            }\r\n        }\r\n\r\n        int res = dp[arr1.size()-1];\r\n        return (res >= maxv)? -1 : res;\r\n    }\r\n};\r\n```\r\n```python3 [1]\r\nclass Solution:\r\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\r\n        # 预处理：排序，去重，加哨兵\r\n        maxv = 1000000000\r\n        arr1 = [-1] + arr1 + [maxv + 5]\r\n        arr2 = sorted(list(set(arr2)))\r\n        n = len(arr1)\r\n\r\n        dp = [0] + [maxv]*(n-1)\r\n        for i in range(1,n):\r\n            j = bisect_left(arr2, arr1[i])\r\n            for k in range(1, min(i-1, j) + 1):  # 1. 枚举替换的个数 k = 1 to min(i-1,j)\r\n                if arr1[i-k-1] < arr2[j-k]:\r\n                    dp[i] = min(dp[i], dp[i-k-1] + k)\r\n            if arr1[i-1] < arr1[i]:          # 2. 不替换 arr1[i-1]\r\n                dp[i] = min(dp[i], dp[i-1])\r\n\r\n        return dp[-1] if dp[-1] < maxv else -1\r\n```"
}