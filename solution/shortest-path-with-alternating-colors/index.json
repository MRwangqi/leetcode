{
	"titleSlug": "shortest-path-with-alternating-colors",
	"slug": "by-stormsunshine-0h68",
	"url": "https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/solution/by-stormsunshine-0h68/",
	"content": "# 解法\r\n\r\n## 思路和算法\r\n\r\n计算最短路径，可以使用广度优先搜索实现。\r\n\r\n由于题目中的图的表示方式是边数组，为了方便处理，需要首先将边数组转换成邻接结点列表的形式，转换后可以在 $O(1)$ 时间获得一个结点的全部相邻结点，然后使用广度优先搜索遍历图。\r\n\r\n由于这道题要求不同颜色边的颜色交替，因此需要分别得到红边和蓝边的邻接结点列表，广度优先搜索的状态包括结点和上次访问的边的颜色，需要记录每个结点分别以两种颜色的边作为结尾的路径长度。\r\n\r\n初始时，结点 $0$ 对应的红边路径和蓝边路径的长度都是 $0$。对于每个状态，其后续状态的结点为从当前结点出发经过一条颜色不同的路径到达的结点，其后续状态的颜色为与当前状态不同的颜色。\r\n\r\n遍历结束后，每个结点的最短路径长度为该结点的红边路径长度和蓝边路径长度中的最小值。如果一个结点使用两种颜色的路径都不能到达，则该结点的最短路径长度为 $-1$。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {\r\n        final int RED = 0, BLUE = 1;\r\n        List<Integer>[][] adjacentArr = new List[n][2];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i][RED] = new ArrayList<Integer>();\r\n            adjacentArr[i][BLUE] = new ArrayList<Integer>();\r\n        }\r\n        for (int[] redEdge : redEdges) {\r\n            adjacentArr[redEdge[0]][RED].add(redEdge[1]);\r\n        }\r\n        for (int[] blueEdge : blueEdges) {\r\n            adjacentArr[blueEdge[0]][BLUE].add(blueEdge[1]);\r\n        }\r\n        int[][] distances = new int[n][2];\r\n        for (int i = 1; i < n; i++) {\r\n            Arrays.fill(distances[i], Integer.MAX_VALUE);\r\n        }\r\n        Queue<int[]> queue = new ArrayDeque<int[]>();\r\n        queue.offer(new int[]{0, RED});\r\n        queue.offer(new int[]{0, BLUE});\r\n        while (!queue.isEmpty()) {\r\n            int[] nodeColor = queue.poll();\r\n            int node = nodeColor[0], color = nodeColor[1];\r\n            int distance = distances[node][color];\r\n            int nextColor = color ^ 1;\r\n            int nextDistance = distance + 1;\r\n            List<Integer> adjacent = adjacentArr[node][nextColor];\r\n            for (int next : adjacent) {\r\n                if (nextDistance < distances[next][nextColor]) {\r\n                    distances[next][nextColor] = nextDistance;\r\n                    queue.offer(new int[]{next, nextColor});\r\n                }\r\n            }\r\n        }\r\n        int[] answer = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            int distance = Math.min(distances[i][RED], distances[i][BLUE]);\r\n            answer[i] = distance != Integer.MAX_VALUE ? distance : -1;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public int[] ShortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {\r\n        const int RED = 0, BLUE = 1;\r\n        IList<int>[][] adjacentArr = new IList<int>[n][];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new IList<int>[2];\r\n            adjacentArr[i][RED] = new List<int>();\r\n            adjacentArr[i][BLUE] = new List<int>();\r\n        }\r\n        foreach (int[] redEdge in redEdges) {\r\n            adjacentArr[redEdge[0]][RED].Add(redEdge[1]);\r\n        }\r\n        foreach (int[] blueEdge in blueEdges) {\r\n            adjacentArr[blueEdge[0]][BLUE].Add(blueEdge[1]);\r\n        }\r\n        int[][] distances = new int[n][];\r\n        for (int i = 0; i < n; i++) {\r\n            distances[i] = new int[2];\r\n        }\r\n        for (int i = 1; i < n; i++) {\r\n            Array.Fill(distances[i], int.MaxValue);\r\n        }\r\n        Queue<Tuple<int, int>> queue = new Queue<Tuple<int, int>>();\r\n        queue.Enqueue(new Tuple<int, int>(0, RED));\r\n        queue.Enqueue(new Tuple<int, int>(0, BLUE));\r\n        while (queue.Count > 0) {\r\n            Tuple<int, int> nodeColor = queue.Dequeue();\r\n            int node = nodeColor.Item1, color = nodeColor.Item2;\r\n            int distance = distances[node][color];\r\n            int nextColor = color ^ 1;\r\n            int nextDistance = distance + 1;\r\n            IList<int> adjacent = adjacentArr[node][nextColor];\r\n            foreach (int next in adjacent) {\r\n                if (nextDistance < distances[next][nextColor]) {\r\n                    distances[next][nextColor] = nextDistance;\r\n                    queue.Enqueue(new Tuple<int, int>(next, nextColor));\r\n                }\r\n            }\r\n        }\r\n        int[] answer = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            int distance = Math.Min(distances[i][RED], distances[i][BLUE]);\r\n            answer[i] = distance != int.MaxValue ? distance : -1;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n + m)$，其中 $n$ 是图中的结点数，$m$ 是图中的边数。广度优先搜索的时间复杂度由结点数和边数决定。\r\n\r\n- 空间复杂度：$O(n + m)$，其中 $n$ 是图中的结点数，$m$ 是图中的边数。空间复杂度主要取决于邻接结点列表和队列，邻接结点列表需要 $O(n + m)$ 的空间，队列需要 $O(n)$ 的空间。"
}