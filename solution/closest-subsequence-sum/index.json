{
	"titleSlug": "closest-subsequence-sum",
	"slug": "by-mountain-ocean-1s0v",
	"url": "https://leetcode-cn.com/problems/closest-subsequence-sum/solution/by-mountain-ocean-1s0v/",
	"content": "这里整理一下 **[** **在数组中选取子集，达到某一目标** **]** 这类问题的通用解法。\r\n- **类型1** : **目标值明确**，可以把目标值看出**背包容量**，数组值看做物品，转成背包问题\r\n- **类型2** : **目标值不明确**，容量不知道，不能用背包，只能枚举子集的和\r\n\r\n**本题**\r\n[1755.最接近目标值的子序列和](https://leetcode-cn.com/problems/closest-subsequence-sum/) \r\n题意:目标值```t```, 子序列和```sum```, 求```min = abs(sum - target)```的最小值。\r\n**目标值不明确**，背包容量不确定，不能转为背包问题，只能二分拆数组，来降低复杂度，然后枚举子数组的子集的和，最后用双指针指向两个子集和的元素，不断逼近目标值。\r\n有人看到这里可能觉得是不是写错了，这题题目已经给出了目标值，**为什么还说是目标值不明确的呢**？\r\n原因在于，**题目给的target不是我们最后要组合的目标值，题目要我们求的是```min```的最小值，这里的最小值我们在解题之前是不知道的**。\r\n```\r\nclass Solution {\r\npublic:\r\n    int minAbsDifference(vector<int>& nums, int goal) {\r\n        int n = nums.size();\r\n        int half = n / 2;\r\n        int ls = half, rs = n - half;\r\n        \r\n        vector<int> lsum(1 << ls, 0);\r\n        for (int i = 1; i < (1 << ls); i++) {\r\n            for (int j = 0; j < ls; j++) {\r\n                if ((i & (1 << j)) == 0) continue;\r\n                lsum[i] = lsum[i-(1<<j)] + nums[j];\r\n                break;\r\n            }\r\n        }\r\n        vector<int> rsum(1 << rs, 0);\r\n        for (int i = 1; i < (1 << rs); i++) {\r\n            for (int j = 0; j < rs; j++) {\r\n                if ((i & (1 << j)) == 0) continue;\r\n                rsum[i] = rsum[i-(1<<j)] + nums[ls+j];\r\n                break;\r\n            }\r\n        }\r\n        sort(lsum.begin(), lsum.end());\r\n        sort(rsum.begin(), rsum.end());\r\n        \r\n        int ret = INT_MAX;\r\n        for (int x: lsum) {\r\n            ret = min(ret, abs(goal - x));\r\n        }\r\n        for (int x: rsum) {\r\n            ret = min(ret, abs(goal - x));\r\n        }\r\n        \r\n        int i = 0, j = rsum.size() - 1;\r\n        while (i < lsum.size() && j >= 0) {\r\n            int s = lsum[i] + rsum[j];\r\n            ret = min(ret, abs(goal - s));\r\n            if (s > goal) {\r\n                j--;\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```\r\n[2035.将数组分成两个数组并最小化数组和的差](https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/)\r\n和1755思路一样\r\n```\r\nclass Solution {\r\npublic:\r\n    int minimumDifference(vector<int>& nums) {\r\n        int n = nums.size();\r\n        int totalSum = 0;\r\n        for (auto item : nums) {\r\n            totalSum += item;\r\n        }\r\n        int half = n >> 1;\r\n        vector<int> nums1(nums.begin(), nums.begin() + half);\r\n        vector<int> nums2(nums.begin() + half, nums.end());\r\n        int totalState = 1 << half;\r\n        vector<int> sumA(totalState, 0);\r\n        vector<int> sumB(totalState, 0);\r\n        map<int, vector<int>> sumMap1, sumMap2;\r\n        sumMap1[0].push_back(0);\r\n        sumMap2[0].push_back(0);\r\n        for (int s = 1; s < totalState; ++s) {\r\n            int lowBit = s & (-s);\r\n            int low = ffs(s) - 1;\r\n            int left = s - lowBit;\r\n            sumA[s] = sumA[left] + nums1[low];\r\n            int bitNum = bitset<32>(s).count();\r\n            sumMap1[bitNum].push_back(sumA[s]);\r\n        }\r\n        for (int s = 1; s < totalState; ++s) {\r\n            int lowBit = s & (-s);\r\n            int low = ffs(s) - 1;\r\n            int left = s - lowBit;\r\n            sumB[s] = sumB[left] + nums2[low];\r\n            int bitNum = bitset<32>(s).count();\r\n            sumMap2[bitNum].push_back(sumB[s]);\r\n        }\r\n        for (auto& pair : sumMap2) {\r\n            auto& vec = pair.second;\r\n            std::sort(vec.begin(), vec.end());\r\n        }\r\n        int ans = INT_MAX;\r\n        for (int i = 0; i <= half; ++i) {\r\n            auto& vec1 = sumMap1[i];\r\n            auto& vec2 = sumMap2[half - i];\r\n            for (auto x : vec1) {\r\n                int id = lower_bound(vec2.begin(), vec2.end(), totalSum / 2 - x) - vec2.begin();\r\n                int y = -1;\r\n                if (id < vec2.size()) {\r\n                    y = vec2[id];\r\n                    ans = std::min(ans, abs(totalSum - (x + y) - (x + y)));\r\n                }\r\n                if (id > 0) {\r\n                    y = vec2[id - 1];\r\n                    ans = std::min(ans, abs(totalSum - (x + y) - (x + y)));\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n[805.数组的均值分割](https://leetcode-cn.com/problems/split-array-with-same-average/)\r\n同1755\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<double> make(vector<double> nums){ // 枚举子序列的和\r\n        int n = nums.size();\r\n        int totalState = 1 << n;\r\n        vector<double> sum(totalState, 0);\r\n        for (int i = 1; i < totalState; ++i) {\r\n            int lowBit = i & (-i);\r\n            int bit = ffs(i);\r\n            int left = i - lowBit;\r\n            sum[i] = sum[left] + nums[bit - 1];\r\n        }\r\n        return sum;\r\n    }\r\n    bool splitArraySameAverage(vector<int>& nums) {\r\n        int n = nums.size(), sum = 0;\r\n        if(n == 1) return false;\r\n        for(int& ev: nums) sum += ev;\r\n        vector<double> dnums(n);\r\n        for(int i = 0; i < n; ++i){\r\n            dnums[i] = nums[i] - (double)sum / n;\r\n        }\r\n        // 获取所有子序列的和\r\n        vector<double> left = make({dnums.begin(), dnums.begin() + n / 2});\r\n        vector<double> right = make({dnums.begin() + n / 2, dnums.end()});\r\n        // 先判断是否能独自构成答案，注意不能从0开始枚举，0表示不贡献任何元素\r\n        for(int i = 1; i < left.size(); ++i){\r\n            if(fabs(left[i]) < 1e-5) return true;\r\n        }\r\n        left.erase(left.begin()); left.pop_back(); // 删除全贡献和全不贡献的情况\r\n        for(int i = 1; i < right.size(); ++i){\r\n            if(fabs(right[i]) < 1e-5) return true;\r\n        }\r\n        right.erase(right.begin()); right.pop_back();\r\n        sort(left.rbegin(), left.rend());\r\n        sort(right.begin(), right.end());\r\n        int l = 0, r = 0; // 双指针\r\n        while(l < left.size() && r < right.size()){\r\n            double ev = left[l] + right[r];\r\n            if(fabs(ev) < 1e-5) return true;\r\n            else if(ev > 0) l++;\r\n            else r++;\r\n        }\r\n        return false;\r\n    }\r\n};\r\n```\r\n\r\n[416.分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\r\n题意:把数组分为两个部分，使每个部分的和相同。\r\n**目标值明确**，```目标值 = sum / 2```，可以把```sum / 2```看做背包容量，转化为**背包容量为sum / 2，数组中的元素是否能*恰好*装满背包**的问题，也就是常说的```01背包```问题。\r\n注：为什么要强调是否恰好呢？\r\n因为和恰好装满和不恰好装满，数组的初始化是有区别的。\r\n恰好装满的初始化:```dp[0] = 0 | true，dp[1.....Tar]``` = ```无效值 | false```(正无穷或负无穷);\r\n不要求完全装满```dp[0......Tar] = 0 | true```;\r\n背包九讲大概是这么讲的：如果要求背包恰好装满，那么此时只有容量为```0```的背包可能被价值为```0```的```nothing``` \"恰好装满\"，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是```false、+∞、-∞```(无效值)。如果背包并非必须被装满，那么任何容量的背包都有一个合法解\"什么都不装\"，这个解的价值为```0```，所以初始时状态的值也就全部为```0```了。\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    bool canPartition(vector<int>& nums) {\r\n        int n = nums.size();\r\n        if (n == 0) return false;\r\n        int sum = accumulate(nums.begin(), nums.end(), 0);\r\n        if (sum & 1) return false;\r\n\r\n        int target = sum >> 1;\r\n        vector<bool> dp(target, false);\r\n        dp[0] = true;\r\n\r\n        for(int i = 0; i < n; ++i) {\r\n            for(int j = target; j >= 0; --j) {\r\n                if (j >= nums[i]) {\r\n                    dp[j] = dp[j] | dp[j - nums[i]];\r\n                }\r\n            }\r\n        }\r\n        return dp[target];\r\n    }\r\n};\r\n```\r\n[494.目标和](https://leetcode-cn.com/problems/target-sum/)\r\n题意:给数组里的每个数字，添加正负号得到目标值```target```。\r\n**目标值明确**，题目给出```target```，数组和```sum```，正数和```sumA```，负数和```sumB```，有以下关系:\r\n```\r\nsumA + sumB = sum\r\nsumA - sumB = target\r\n推导出 : sumA = (sum + target) / 2\r\n```\r\n转化为 : 在数组中选取出部分元素，给它们加上```+```号，这些元素和，也就是背包容量为```sumA```的方案数，同样是```01背包```\r\n```\r\nclass Solution {\r\npublic:\r\n    int findTargetSumWays(vector<int>& nums, int T) {\r\n        int sum = accumulate(nums.begin(), nums.end(), 0);\r\n        if (T > sum || T < -sum || T + sum < 0 || (T + sum) % 2 == 1) {\r\n            return 0;\r\n        }\r\n        int target = (T + sum) / 2;\r\n        int n = nums.size();\r\n\r\n        vector<int> dp(target + 1);\r\n        dp[0] = 1;\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = target; j >= 0; --j) {\r\n                if (j >= nums[i]) {\r\n                    dp[j] += dp[j - nums[i]];\r\n                }\r\n            }\r\n        }\r\n        return dp[target];\r\n    }\r\n};\r\n```\r\n\r\n看到这里如果有收获，能点一个**赞**，就是对我最大的鼓励了^_^\r\n"
}