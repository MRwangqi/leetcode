{
	"titleSlug": "the-latest-time-to-catch-a-bus",
	"slug": "er-fen-by-inventionliu-l4jt",
	"url": "https://leetcode-cn.com/problems/the-latest-time-to-catch-a-bus/solution/er-fen-by-inventionliu-l4jt/",
	"content": "### 解题思路\n自己看的笔记：\n    第一次找每趟公交的最后一位乘客；\n    第二次找我能踏上当前公交的最晚时间\n\n### 代码\n\n```java\nclass Solution {\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\n        //先对两个数组排序\n        //遍历buses的每个元素：分别在passengers中二分找到能搭上当前公交的最后一位乘客：如果超载了\n        //或者时间超过当前公交的发车时间了就往前搜，否则往后搜，\n        //接着判断：找到的最后一位乘客上车后是否还有位置并且还未到发车时间，是的话，我可以在当前公交的发车时间\n        //到达；否则： 再次二分往前找到第一个不连续的时间的乘客，将其代替，即他的上车时间再早点就行\n        //第二次二分：判断乘客数量是否小于两个乘客的时间差，是的话：往后找，后面肯定还有不连续的上车时间的\n        //乘客；否则：往前找\n\n        //注意：对每趟公交，不要和上一趟的时间重叠了\n        //上一趟公交坐不完的，还会坐下一趟\n\n        Arrays.sort(buses);\n        Arrays.sort(passengers);\n        int res = 1;\n        int curPgId = 0;//当前搜索到此乘客了\n        int preBusTime = 0;//第二次二分更新答案的时候，要大于这个时间,记录的是上一次最后一位乘客的时间\n        for(int buse: buses){\n            if(curPgId==passengers.length){\n                res = buses[buses.length-1];\n                break;\n            }\n            int left1 = curPgId;\n            int right1 = passengers.length-1;\n            int idx1 = -1;\n            while(left1<=right1){\n                int mid = left1 + (right1-left1>>1);\n                if(mid-left1+1<capacity && passengers[mid]<buse){\n                    idx1 = mid;\n                    left1 = mid+1;\n                }else if(mid-left1+1>capacity || passengers[mid]>buse){\n                    right1 = mid-1;\n                }else{\n                    idx1 = mid;\n                    break;\n                }\n            }\n            if(idx1 == -1){\n                //剩余乘客都不能赶上当前公交的发车时间:\n                res = buse;\n            }else{\n                if(idx1-curPgId+1<capacity&&passengers[idx1]<buse){\n                    res = buse;\n                }else{\n                    //第二次二分:\n                    int left2 = curPgId;\n                    int right2 = idx1;\n                    int idx2 = curPgId;//这里初始化成这个\n                    while(left2<=right2){\n                        int mid = left2 + (right2-left2>>1);\n                        if(right2-mid+1<passengers[right2]-passengers[mid]+1){\n                            left2 = mid+1;\n                        }else{\n                            idx2 = mid;\n                            right2 = mid-1;\n                        }\n                    }\n                    if(passengers[idx2]-1>preBusTime){//不要和前面的重叠了\n                        res = passengers[idx2]-1;\n                    }\n                }\n                curPgId = idx1 + 1;\n                preBusTime = passengers[idx1];\n            }\n        }\n        return res;\n    }\n}\n```"
}