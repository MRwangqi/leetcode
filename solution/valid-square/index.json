{
	"titleSlug": "valid-square",
	"slug": "you-xiao-de-zheng-fang-xing-by-leetcode-94t5m",
	"url": "https://leetcode-cn.com/problems/valid-square/solution/you-xiao-de-zheng-fang-xing-by-leetcode-94t5m/",
	"content": "#### 方法一：数学\n\n**思路与算法**\n\n[正方形判定定理](https://baike.baidu.com/item/%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%88%A4%E5%AE%9A%E5%AE%9A%E7%90%86/5599805)是几何学里用于判定一个四边形是否为正方形的判定定理。判别正方形的一般顺序为先说明它是平行四边形；再说明它是菱形（或矩形）；最后说明它是矩形（或菱形）。那么我们可以从枚举四边形的两条斜边入手来进行判断：\n\n1. 如果两条斜边的中点相同：则说明以该两条斜边组成的四边形为「平行四边形」。\n2. 在满足「条件一」的基础上，如果两条斜边的长度相同：则说明以该两条斜边组成的四边形为「矩形」。\n3. 在满足「条件二」的基础上，如果两条斜边的相互垂直：则说明以该两条斜边组成的四边形为「正方形」。\n\n**代码**\n\n```Python [sol1-Python3]\ndef checkLength(v1: Tuple[int, int], v2: Tuple[int, int]) -> bool:\n    return v1[0] * v1[0] + v1[1] * v1[1] == v2[0] * v2[0] + v2[1] * v2[1]\n\ndef checkMidPoint(p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:\n    return p1[0] + p2[0] == p3[0] + p4[0] and p1[1] + p2[1] == p3[1] + p4[1]\n\ndef calCos(v1: Tuple[int, int], v2: Tuple[int, int]) -> int:\n    return v1[0] * v2[0] + v1[1] * v2[1]\n\ndef help(p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:\n    v1 = (p1[0] - p2[0], p1[1] - p2[1])\n    v2 = (p3[0] - p4[0], p3[1] - p4[1])\n    return checkMidPoint(p1, p2, p3, p4) and checkLength(v1, v2) and calCos(v1, v2) == 0\n\nclass Solution:\n    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:\n        if p1 == p2:\n            return False\n        if help(p1, p2, p3, p4):\n            return True\n        if p1 == p3:\n            return False\n        if help(p1, p3, p2, p4):\n            return True\n        if p1 == p4:\n            return False\n        if help(p1, p4, p2, p3):\n            return True\n        return False\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool checkLength(vector<int>& v1, vector<int>& v2) {\n        return (v1[0] * v1[0] + v1[1] * v1[1]) == (v2[0] * v2[0] + v2[1] * v2[1]);\n    }\n\n    bool checkMidPoint(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n        return (p1[0] + p2[0]) == (p3[0] + p4[0]) && (p1[1] + p2[1]) == (p3[1] + p4[1]);\n    }\n\n    int calCos(vector<int>& v1, vector<int>& v2) {\n        return (v1[0] * v2[0] + v1[1] * v2[1]) == 0;\n    }\n\n    bool help(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n        vector<int> v1 = {p1[0] - p2[0], p1[1] - p2[1]};\n        vector<int> v2 = {p3[0] - p4[0], p3[1] - p4[1]};\n        if (checkMidPoint(p1, p2, p3, p4) && checkLength(v1, v2) && calCos(v1, v2)) {\n            return true;\n        } \n        return false;\n    }\n\n    bool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n        if (p1 == p2) {\n            return false;\n        }\n        if (help(p1, p2, p3, p4)) {\n            return true;\n        }\n        if (p1 == p3) {\n            return false;\n        }\n        if (help(p1, p3, p2, p4)) {\n            return true;\n        }\n        if (p1 == p4) {\n            return false;\n        }\n        if (help(p1, p4, p2, p3)) {\n            return true;\n        }\n        return false;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        if (Arrays.equals(p1, p2)) {\n            return false;\n        }\n        if (help(p1, p2, p3, p4)) {\n            return true;\n        }\n        if (Arrays.equals(p1, p3)) {\n            return false;\n        }\n        if (help(p1, p3, p2, p4)) {\n            return true;\n        }\n        if (Arrays.equals(p1, p4)) {\n            return false;\n        }\n        if (help(p1, p4, p2, p3)) {\n            return true;\n        }\n        return false;\n    }\n\n    public boolean help(int[] p1, int[] p2, int[] p3, int[] p4) {\n        int[] v1 = {p1[0] - p2[0], p1[1] - p2[1]};\n        int[] v2 = {p3[0] - p4[0], p3[1] - p4[1]};\n        if (checkMidPoint(p1, p2, p3, p4) && checkLength(v1, v2) && calCos(v1, v2)) {\n            return true;\n        } \n        return false;\n    }\n\n    public boolean checkLength(int[] v1, int[] v2) {\n        return (v1[0] * v1[0] + v1[1] * v1[1]) == (v2[0] * v2[0] + v2[1] * v2[1]);\n    }\n\n    public boolean checkMidPoint(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return (p1[0] + p2[0]) == (p3[0] + p4[0]) && (p1[1] + p2[1]) == (p3[1] + p4[1]);\n    }\n\n    public boolean calCos(int[] v1, int[] v2) {\n        return (v1[0] * v2[0] + v1[1] * v2[1]) == 0;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool ValidSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        if (p1[0] == p2[0] && p1[1] == p2[1]) {\n            return false;\n        }\n        if (Help(p1, p2, p3, p4)) {\n            return true;\n        }\n        if (p1[0] == p3[0] && p1[1] == p3[1]) {\n            return false;\n        }\n        if (Help(p1, p3, p2, p4)) {\n            return true;\n        }\n        if (p1[0] == p4[0] && p1[1] == p4[1]) {\n            return false;\n        }\n        if (Help(p1, p4, p2, p3)) {\n            return true;\n        }\n        return false;\n    }\n\n    public bool Help(int[] p1, int[] p2, int[] p3, int[] p4) {\n        int[] v1 = {p1[0] - p2[0], p1[1] - p2[1]};\n        int[] v2 = {p3[0] - p4[0], p3[1] - p4[1]};\n        if (CheckMidPoint(p1, p2, p3, p4) && CheckLength(v1, v2) && CalCos(v1, v2)) {\n            return true;\n        } \n        return false;\n    }\n\n    public bool CheckLength(int[] v1, int[] v2) {\n        return (v1[0] * v1[0] + v1[1] * v1[1]) == (v2[0] * v2[0] + v2[1] * v2[1]);\n    }\n\n    public bool CheckMidPoint(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return (p1[0] + p2[0]) == (p3[0] + p4[0]) && (p1[1] + p2[1]) == (p3[1] + p4[1]);\n    }\n\n    public bool CalCos(int[] v1, int[] v2) {\n        return (v1[0] * v2[0] + v1[1] * v2[1]) == 0;\n    }\n}\n```\n\n```C [sol1-C]\nstatic inline bool isSamePoint(const int *v1, const int *v2) {\n    return (v1[0] == v2[0]) && (v1[1] == v2[1]);\n}\n\nstatic inline bool checkLength(const int *v1, const int *v2) {\n    return (v1[0] * v1[0] + v1[1] * v1[1]) == (v2[0] * v2[0] + v2[1] * v2[1]);\n}\n\nstatic inline bool checkMidPoint(const int* p1, const int* p2, const int* p3, const int* p4) {\n    return (p1[0] + p2[0]) == (p3[0] + p4[0]) && (p1[1] + p2[1]) == (p3[1] + p4[1]);\n}\n\nstatic inline int calCos(const int *v1, const int *v2) {\n    return (v1[0] * v2[0] + v1[1] * v2[1]) == 0;\n}\n\nbool help(const int* p1, const int* p2, const int* p3, const int* p4) {\n    int v1[2] = {p1[0] - p2[0], p1[1] - p2[1]};\n    int v2[2] = {p3[0] - p4[0], p3[1] - p4[1]};\n    if (checkMidPoint(p1, p2, p3, p4) && checkLength(v1, v2) && calCos(v1, v2)) {\n        return true;\n    } \n    return false;\n}\nbool validSquare(int* p1, int p1Size, int* p2, int p2Size, int* p3, int p3Size, int* p4, int p4Size) {\n    if (isSamePoint(p1, p2) || isSamePoint(p1, p3) || isSamePoint(p1, p4)) {\n        return false;\n    }\n    if (help(p1, p2, p3, p4) || help(p1, p3, p2, p4) || help(p1, p4, p2, p3)) {\n        return true;\n    }\n    return false;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar validSquare = function(p1, p2, p3, p4) {\n    if (_.isEqual(p1, p2)) {\n        return false;\n    }\n    if (help(p1, p2, p3, p4)) {\n        return true;\n    }\n    if (_.isEqual(p1, p3)) {\n        return false;\n    }\n    if (help(p1, p3, p2, p4)) {\n        return true;\n    }\n    if (_.isEqual(p1, p4)) {\n        return false;\n    }\n    if (help(p1, p4, p2, p3)) {\n        return true;\n    }\n    return false;\n}\n\nconst help = (p1, p2, p3, p4) => {\n    const v1 = [p1[0] - p2[0], p1[1] - p2[1]];\n    const v2 = [p3[0] - p4[0], p3[1] - p4[1]];\n    if (checkMidPoint(p1, p2, p3, p4) && checkLength(v1, v2) && calCos(v1, v2)) {\n        return true;\n    } \n    return false;\n}\n\nconst checkLength = (v1, v2) => {\n    return (v1[0] * v1[0] + v1[1] * v1[1]) === (v2[0] * v2[0] + v2[1] * v2[1]);\n}\n\nconst checkMidPoint = (p1, p2, p3, p4) => {\n    return (p1[0] + p2[0]) === (p3[0] + p4[0]) && (p1[1] + p2[1]) === (p3[1] + p4[1]);\n}\n\nconst calCos = (v1, v2) => {\n    return (v1[0] * v2[0] + v1[1] * v2[1]) === 0;\n};\n```\n\n```go [sol1-Golang]\nfunc checkLength(v1, v2 []int) bool {\n    return v1[0]*v1[0]+v1[1]*v1[1] == v2[0]*v2[0]+v2[1]*v2[1]\n}\n\nfunc checkMidPoint(p1, p2, p3, p4 []int) bool {\n    return p1[0]+p2[0] == p3[0]+p4[0] && p1[1]+p2[1] == p3[1]+p4[1]\n}\n\nfunc calCos(v1, v2 []int) int {\n    return v1[0]*v2[0] + v1[1]*v2[1]\n}\n\nfunc help(p1, p2, p3, p4 []int) bool {\n    v1 := []int{p1[0] - p2[0], p1[1] - p2[1]}\n    v2 := []int{p3[0] - p4[0], p3[1] - p4[1]}\n    return checkMidPoint(p1, p2, p3, p4) && checkLength(v1, v2) && calCos(v1, v2) == 0\n}\n\nfunc validSquare(p1, p2, p3, p4 []int) bool {\n    if p1[0] == p2[0] && p1[1] == p2[1] {\n        return false\n    }\n    if help(p1, p2, p3, p4) {\n        return true\n    }\n    if p1[0] == p3[0] && p1[1] == p3[1] {\n        return false\n    }\n    if help(p1, p3, p2, p4) {\n        return true\n    }\n    if p1[0] == p4[0] && p1[1] == p4[1] {\n        return false\n    }\n    if help(p1, p4, p2, p3) {\n        return true\n    }\n    return false\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$。\n\n- 空间复杂度：$O(1)$，仅使用常数变量。"
}