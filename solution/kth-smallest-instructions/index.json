{
	"titleSlug": "kth-smallest-instructions",
	"slug": "di-k-tiao-zui-xiao-zhi-ling-by-zerotrac2",
	"url": "https://leetcode-cn.com/problems/kth-smallest-instructions/solution/di-k-tiao-zui-xiao-zhi-ling-by-zerotrac2/",
	"content": "#### 方法一：优先确定高位 + 组合计数\n\n**思路与算法**\n\n当字符串中每一种字符的数量固定时（例如对于本题，我们需要在字符串中放入 $h$ 个 $\\texttt{H}$ 和 $v$ 个 $\\texttt{V}$），如果需要求出字典序第 $k$ 小的字符串，可以考虑从高位高位向低位依次确定每一个位置的字符。\n\n> 如果我们在最高位放置了 $\\texttt{H}$，那么剩余的 $(h-1,v)$ 就是一个规模减少的相同问题；同理如果我们在最高位放置了 $\\texttt{V}$，那么剩余的 $(h,v-1)$ 也是一个规模减少的相同问题。\n\n我们考虑最高位是放 $\\texttt{H}$ 还是 $\\texttt{V}$。由于后者的字典序较大，因此如果最高位放 $\\texttt{V}$，那么**所有最高位为 $\\texttt{H}$ 的字符串的字典序都比它小**，这样的字符串共有\n\n$$\no = \\binom{h+v-1}{h-1}\n$$\n\n个。也就是**确定了最高位为 $\\texttt{H}$，剩余 $h+v-1$ 个位置中选择 $h-1$ 个放入 $\\texttt{H}$，其余位置自动放入 $\\texttt{V}$** 的方案数。因此：\n\n- 如果 $k$ 大于这个组合数 $o$，那么最高位一定是 $\\texttt{V}$。我们将 $v$ 减少 $1$，**并且需要将 $k$ 减少 $o$**，这是因为剩余部分应当是包含 $(h,v-1)$ 的字典序第 $k-o$ 小的字符串；\n\n- 如果 $k$ 小于 $o$，那么最高位是 $\\texttt{H}$。我们将 $h$ 减少 $1$，但我们不需要改变 $k$ 的值，这是因为剩余部分就是包含 $(h-1,v)$ 的字典序第 $k$ 小的字符串。\n\n这样一来，我们就可以从高位开始，依次确定每一个位置的字符了。需要注意的是，当 $h=0$ 时，我们只能放 $\\texttt{V}$，无需进行判断。\n\n**代码**\n\n对于 `Python` 语言，可以使用 `math.comb()` 方便地求出组合数。但对于 `C++` 而言，由于本题会导致乘法溢出，因此可以考虑使用组合数的递推式\n\n$$\nc[n][k] = c[n-1][k-1] + c[n-1][k]\n$$\n\n预处理处所有可能需要用到的组合数。\n\n本题中，可能需要计算的最大组合数为 $\\dbinom{29}{14}$，在 `C++` 语言中，直接通过先乘法后除法的方法计算该组合数，在乘法过程中就会超出 $64$ 位无符号整数的上限。\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string kthSmallestPath(vector<int>& destination, int k) {\n        int h = destination[1];\n        int v = destination[0];\n        \n        // 预处理组合数\n        vector<vector<int>> comb(h + v, vector<int>(h));\n        comb[0][0] = 1;\n        for (int i = 1; i < h + v; ++i) {\n            comb[i][0] = 1;\n            for (int j = 1; j <= i && j < h; ++j) {\n                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n            }\n        }\n        \n        string ans;\n        for (int i = 0, imax = h + v; i < imax; ++i) {\n            if (h > 0) {\n                int o = comb[h + v - 1][h - 1];\n                if (k > o) {\n                    ans += 'V';\n                    --v;\n                    k -= o;\n                }\n                else {\n                    ans += 'H';\n                    --h;\n                }\n            }\n            else {\n                ans += 'V';\n                --v;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\n        v, h = destination\n        ans = list()\n        for i in range(h + v):\n            if h > 0:\n                o = math.comb(h + v - 1, h - 1)\n                if k > o:\n                    ans.append(\"V\")\n                    v -= 1\n                    k -= o\n                else:\n                    ans.append(\"H\")\n                    h -= 1\n            else:\n                ans.append(\"V\")\n                v -= 1\n        return \"\".join(ans)\n```\n\n**复杂度分析**\n\n- 时间复杂度：\n    \n    - `Python` $O\\big((h+v)h)$。字符串的位数为 $h+v$，对于每一位我们需要计算组合数，时间复杂度为 $O(h)$，相乘即得到时间复杂度；\n\n    - `C++` 同样是 $O\\big((h+v)h)$，但它是预处理组合数的时间复杂度，在枚举字符串的每一位时，我们就可以 $O(1)$ 得到组合数的值。\n\n- 空间复杂度：`Python` $O(1)$，`C++` 需要存储预处理的组合数，因此为 $O\\big((h+v)^2\\big)$。"
}