{
	"titleSlug": "shortest-impossible-sequence-of-rolls",
	"slug": "by-endlesscheng-diiq",
	"url": "https://leetcode-cn.com/problems/shortest-impossible-sequence-of-rolls/solution/by-endlesscheng-diiq/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV16e4y1Q73o?t=15m59s) 已出炉，欢迎点赞三连，在评论区分享你对这场双周赛的看法~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n考虑包含 $1$ 到 $k$ 的最短前缀 ，无法得到的子序列的**第一个数**必然在里面。\r\n\r\n#### 提示 2-1\r\n\r\n这个前缀的最后一个数 $x$，在前缀中只会出现一次。\r\n\r\n反证：如果 $x$ 出现多次，那么我们可以缩短前缀，同样可以包含 $1$ 到 $k$。\r\n\r\n#### 提示 2-2\r\n\r\n我们可以取 $x$ 当做子序列的第一个数。\r\n\r\n#### 提示 3\r\n\r\n去掉这个前缀，考虑**下一个**包含 $1$ 到 $k$ 的最短前缀。在提示 2-2 的前提下，子序列的**第二个数**必然在这个前缀中。同样地，取前缀最后一个数当做子序列的第二个数。\r\n\r\n根据提示 2-1，按照这种取法，取到的这两个数组成的子序列，一定不会都位于第一个前缀中（读者可以用这两个数相同和不同来分类讨论）。因此这种取法是正确的。\r\n\r\n#### 提示 4\r\n\r\n不断重复这一过程，直到剩余部分无法包含 $1$ 到 $k$ 时停止。\r\n\r\n设我们取到了 $m$ 个数，对应着 $\\textit{rolls}$ 的 $m$ 个子段。由于每一段都包含 $1$ 到 $k$，$\\textit{rolls}$ 必然包含长度为 $m$ 的子序列：每一段都选一个元素即可组成这样的子序列。\r\n\r\n因此答案至少为 $m+1$。\r\n\r\n我们可以构造出一个长为 $m+1$ 的子序列，它不在 $\\textit{rolls}$ 中：前 $m$ 个数分别取各个子段的最后一个数，第 $m+1$ 个数取不在剩余部分中的数。因此答案等于 $m+1$。\r\n\r\n代码实现时，可以在遍历数组的同时，用一个 $\\textit{mark}$ 数组标记当前元素属于哪个子段。这种做法的好处是每次调用时只会申请一次空间，效率更高，在 Java 上尤为明显，左侧是数组写法，右侧是哈希表写法：\r\n\r\n![20220728-131906.jpg](https://pic.leetcode-cn.com/1658985603-KuOvNs-20220728-131906.jpg)\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n+k)$，其中 $n$ 为 $\\textit{rolls}$ 的长度。\r\n- 空间复杂度：$O(k)$。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\r\n        mark = [0] * (k + 1)  # mark[v] 标记 v 属于哪个子段\r\n        ans, left = 1, k\r\n        for v in rolls:\r\n            if mark[v] < ans:\r\n                mark[v] = ans\r\n                left -= 1\r\n                if left == 0:\r\n                    left = k\r\n                    ans += 1\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int shortestSequence(int[] rolls, int k) {\r\n        var mark = new int[k + 1]; // mark[v] 标记 v 属于哪个子段\r\n        int ans = 1, left = k;\r\n        for (var v : rolls)\r\n            if (mark[v] < ans) {\r\n                mark[v] = ans;\r\n                if (--left == 0) {\r\n                    left = k;\r\n                    ++ans;\r\n                }\r\n            }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int shortestSequence(vector<int> &rolls, int k) {\r\n        int ans = 1, left = k, mark[k + 1]; // mark[v] 标记 v 属于哪个子段\r\n        memset(mark, 0, sizeof(mark));\r\n        for (int v : rolls)\r\n            if (mark[v] < ans) {\r\n                mark[v] = ans;\r\n                if (--left == 0) {\r\n                    left = k;\r\n                    ++ans;\r\n                }\r\n            }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc shortestSequence(rolls []int, k int) int {\r\n\tmark := make([]int, k+1) // mark[v] 标记 v 属于哪个子段\r\n\tans, left := 1, k\r\n\tfor _, v := range rolls {\r\n\t\tif mark[v] < ans {\r\n\t\t\tmark[v] = ans\r\n\t\t\tif left--; left == 0 {\r\n\t\t\t\tleft = k\r\n\t\t\t\tans++\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n```\r\n\r\n#### 思考题\r\n\r\n给你 $n$，$k$ 和答案 $\\textit{ans}$，请你构造一个长为 $n$ 的 $\\textit{rolls}$ 数组，使得 `shortestSequence(rolls, k)` 的输出恰好为 $\\textit{ans}$。\r\n\r\n"
}