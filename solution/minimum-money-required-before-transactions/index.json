{
	"titleSlug": "minimum-money-required-before-transactions",
	"slug": "by-endlesscheng-lvym",
	"url": "https://leetcode-cn.com/problems/minimum-money-required-before-transactions/solution/by-endlesscheng-lvym/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1MT411u7fW) 已出炉，欢迎点赞三连，在评论区分享你对这场双周赛的看法~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n考虑最坏情况，即先亏钱（$\\textit{cost}>\\textit{cashback}$），再赚钱。\r\n\r\n记 $\\textit{totalLose}$ 为亏钱下的所有 $\\textit{cost}-\\textit{cashback}$ 之和。\r\n\r\n#### 提示 2\r\n\r\n如何最大化初始 $\\textit{money}$ ？\r\n\r\n枚举所有交易，分类讨论：\r\n\r\n- 对于 $\\textit{cost}_i\\le\\textit{cashback}_i$ 的交易，这笔交易可以发生在亏钱后，此时初始 $\\textit{money}=\\textit{totalLose}+\\textit{cost}_i$；\r\n- 对于 $\\textit{cost}_i>\\textit{cashback}_i$ 的交易，这笔交易可以发生在最后一笔亏钱时，由于已经计入 $\\textit{totalLose}$ 中，需要从 $\\textit{totalLose}$ 中减去 $\\textit{cost}_i-\\textit{cashback}_i$，再加上 $\\textit{cost}_i$，化简得到初始 $\\textit{money}=\\textit{totalLose}+\\textit{cashback}_i$。\r\n\r\n取所有初始 $\\textit{money}$ 的最大值，即为答案。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\r\n        total_lose = mx = 0\r\n        for cost, cashback in transactions:\r\n            total_lose += max(cost - cashback, 0)\r\n            mx = max(mx, min(cost, cashback))\r\n        return total_lose + mx\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public long minimumMoney(int[][] transactions) {\r\n        var totalLose = 0L;\r\n        var mx = 0;\r\n        for (var t : transactions) {\r\n            totalLose += Math.max(t[0] - t[1], 0);\r\n            mx = Math.max(mx, Math.min(t[0], t[1]));\r\n        }\r\n        return totalLose + mx;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    long long minimumMoney(vector<vector<int>> &transactions) {\r\n        long total_lose = 0L;\r\n        int mx = 0;\r\n        for (auto &t : transactions) {\r\n            total_lose += max(t[0] - t[1], 0);\r\n            mx = max(mx, min(t[0], t[1]));\r\n        }\r\n        return total_lose + mx;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc minimumMoney(transactions [][]int) int64 {\r\n\ttotalLose, mx := 0, 0\r\n\tfor _, t := range transactions {\r\n\t\ttotalLose += max(t[0]-t[1], 0)\r\n\t\tmx = max(mx, min(t[0], t[1]))\r\n\t}\r\n\treturn int64(totalLose + mx)\r\n}\r\n\r\nfunc min(a, b int) int { if b < a { return b }; return a }\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{transactions}$ 的长度。\r\n- 空间复杂度：$O(1)$，仅用到若干变量。\r\n\r\n#### 思考题\r\n\r\n如果把题干的「任意一种」改成「至少一种」要怎么做？\r\n\r\n可以参考 [1665. 完成所有任务的最少初始能量](https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/)。"
}