{
	"titleSlug": "cousins-in-binary-tree",
	"slug": "er-cha-shu-de-tang-xiong-di-jie-dian-by-mfh2d",
	"url": "https://leetcode-cn.com/problems/cousins-in-binary-tree/solution/er-cha-shu-de-tang-xiong-di-jie-dian-by-mfh2d/",
	"content": "#### å‰è¨€\n\nè¦æƒ³åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹ $x$ å’Œ $y$ æ˜¯å¦ä¸ºå ‚å…„å¼ŸèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°±éœ€è¦æ±‚å‡ºè¿™ä¸¤ä¸ªèŠ‚ç‚¹åˆ†åˆ«çš„ã€Œæ·±åº¦ã€ä»¥åŠã€Œçˆ¶èŠ‚ç‚¹ã€ã€‚\n\nå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œå¯¹æ ‘è¿›è¡Œä¸€æ¬¡éå†ï¼Œåœ¨éå†çš„è¿‡ç¨‹ä¸­ç»´æŠ¤ã€Œæ·±åº¦ã€ä»¥åŠã€Œçˆ¶èŠ‚ç‚¹ã€è¿™ä¸¤ä¸ªä¿¡æ¯ã€‚å½“æˆ‘ä»¬éå†åˆ° $x$ æˆ– $y$ èŠ‚ç‚¹æ—¶ï¼Œå°±å°†ä¿¡æ¯è®°å½•ä¸‹æ¥ï¼›å½“è¿™ä¸¤ä¸ªèŠ‚ç‚¹éƒ½éå†å®Œæˆäº†ä»¥åï¼Œæˆ‘ä»¬å°±å¯ä»¥é€€å‡ºéå†çš„è¿‡ç¨‹ï¼Œåˆ¤æ–­å®ƒä»¬æ˜¯å¦ä¸ºå ‚å…„å¼ŸèŠ‚ç‚¹äº†ã€‚\n\nå¸¸è§çš„éå†æ–¹æ³•æœ‰ä¸¤ç§ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢\n\n**æ€è·¯ä¸ç®—æ³•**\n\næˆ‘ä»¬åªéœ€è¦åœ¨æ·±åº¦ä¼˜å…ˆæœç´¢çš„é€’å½’å‡½æ•°ä¸­å¢åŠ è¡¨ç¤ºã€Œæ·±åº¦ã€ä»¥åŠã€Œçˆ¶èŠ‚ç‚¹ã€çš„ä¸¤ä¸ªå‚æ•°å³å¯ã€‚\n\n**ä»£ç **\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    // x çš„ä¿¡æ¯\n    int x;\n    TreeNode* x_parent;\n    int x_depth;\n    bool x_found = false;\n\n    // y çš„ä¿¡æ¯\n    int y;\n    TreeNode* y_parent;\n    int y_depth;\n    bool y_found = false;\n\npublic:\n    void dfs(TreeNode* node, int depth, TreeNode* parent) {\n        if (!node) {\n            return;\n        }\n\n        if (node->val == x) {\n            tie(x_parent, x_depth, x_found) = tuple{parent, depth, true};\n        }\n        else if (node->val == y) {\n            tie(y_parent, y_depth, y_found) = tuple{parent, depth, true};\n        }\n\n        // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†\n        // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“\n        if (x_found && y_found) {\n            return;\n        }\n\n        dfs(node->left, depth + 1, node);\n\n        if (x_found && y_found) {\n            return;\n        }\n\n        dfs(node->right, depth + 1, node);\n    }\n\n    bool isCousins(TreeNode* root, int x, int y) {\n        this->x = x;\n        this->y = y;\n        dfs(root, 0, nullptr);\n        return x_depth == y_depth && x_parent != y_parent;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    // x çš„ä¿¡æ¯\n    int x;\n    TreeNode xParent;\n    int xDepth;\n    boolean xFound = false;\n\n    // y çš„ä¿¡æ¯\n    int y;\n    TreeNode yParent;\n    int yDepth;\n    boolean yFound = false;\n\n    public boolean isCousins(TreeNode root, int x, int y) {\n        this.x = x;\n        this.y = y;\n        dfs(root, 0, null);\n        return xDepth == yDepth && xParent != yParent;\n    }\n\n    public void dfs(TreeNode node, int depth, TreeNode parent) {\n        if (node == null) {\n            return;\n        }\n\n        if (node.val == x) {\n            xParent = parent;\n            xDepth = depth;\n            xFound = true;\n        } else if (node.val == y) {\n            yParent = parent;\n            yDepth = depth;\n            yFound = true;\n        }\n\n        // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†\n        // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“\n        if (xFound && yFound) {\n            return;\n        }\n\n        dfs(node.left, depth + 1, node);\n\n        if (xFound && yFound) {\n            return;\n        }\n\n        dfs(node.right, depth + 1, node);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    // x çš„ä¿¡æ¯\n    int x;\n    TreeNode xParent;\n    int xDepth;\n    bool xFound = false;\n\n    // y çš„ä¿¡æ¯\n    int y;\n    TreeNode yParent;\n    int yDepth;\n    bool yFound = false;\n\n    public bool IsCousins(TreeNode root, int x, int y) {\n        this.x = x;\n        this.y = y;\n        DFS(root, 0, null);\n        return xDepth == yDepth && xParent != yParent;\n    }\n\n    public void DFS(TreeNode node, int depth, TreeNode parent) {\n        if (node == null) {\n            return;\n        }\n\n        if (node.val == x) {\n            xParent = parent;\n            xDepth = depth;\n            xFound = true;\n        } else if (node.val == y) {\n            yParent = parent;\n            yDepth = depth;\n            yFound = true;\n        }\n\n        // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†\n        // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“\n        if (xFound && yFound) {\n            return;\n        }\n\n        DFS(node.left, depth + 1, node);\n\n        if (xFound && yFound) {\n            return;\n        }\n\n        DFS(node.right, depth + 1, node);\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:\n        # x çš„ä¿¡æ¯\n        x_parent, x_depth, x_found = None, None, False\n        # y çš„ä¿¡æ¯\n        y_parent, y_depth, y_found = None, None, False\n        \n        def dfs(node: TreeNode, depth: int, parent: TreeNode):\n            if not node:\n                return\n            \n            nonlocal x_parent, y_parent, x_depth, y_depth, x_found, y_found\n            \n            if node.val == x:\n                x_parent, x_depth, x_found = parent, depth, True\n            elif node.val == y:\n                y_parent, y_depth, y_found = parent, depth, True\n\n            # å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†\n            # å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“\n            if x_found and y_found:\n                return\n\n            dfs(node.left, depth + 1, node)\n\n            if x_found and y_found:\n                return\n\n            dfs(node.right, depth + 1, node)\n\n        dfs(root, 0, None)\n        return x_depth == y_depth and x_parent != y_parent\n```\n\n```JavaScript [sol1-JavaScript]\nvar isCousins = function(root, x, y) {\n    // x çš„ä¿¡æ¯\n    let x_parent = null, x_depth = null, x_found = false;\n    // y çš„ä¿¡æ¯\n    let y_parent = null, y_depth = null, y_found = false;\n    \n    const dfs = (node, depth, parent) => {\n        if (!node) {\n            return;\n        }\n        if (node.val === x) {\n            [x_parent, x_depth, x_found] = [parent, depth, true];\n        } else if (node.val === y) {\n            [y_parent, y_depth, y_found] = [parent, depth, true];\n        }\n\n        // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†\n        // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“\n        if (x_found && y_found) {\n            return;\n        }\n\n        dfs(node.left, depth + 1, node);\n\n        if (x_found && y_found) {\n            return;\n        }\n\n        dfs(node.right, depth + 1, node);\n    }\n    dfs(root, 0, null);\n    return x_depth === y_depth && x_parent !== y_parent;\n};\n```\n\n```go [sol1-Golang]\nfunc isCousins(root *TreeNode, x, y int) bool {\n    var xParent, yParent *TreeNode\n    var xDepth, yDepth int\n    var xFound, yFound bool\n\n    var dfs func(node, parent *TreeNode, depth int)\n    dfs = func(node, parent *TreeNode, depth int) {\n        if node == nil {\n            return\n        }\n\n        if node.Val == x {\n            xParent, xDepth, xFound = parent, depth, true\n        } else if node.Val == y {\n            yParent, yDepth, yFound = parent, depth, true\n        }\n\n        // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†\n        // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“\n        if xFound && yFound {\n            return\n        }\n\n        dfs(node.Left, node, depth+1)\n\n        if xFound && yFound {\n            return\n        }\n\n        dfs(node.Right, node, depth+1)\n    }\n    dfs(root, nil, 0)\n\n    return xDepth == yDepth && xParent != yParent\n}\n```\n\n```C [sol1-C]\n// x çš„ä¿¡æ¯\nint x_target;\nstruct TreeNode* x_parent;\nint x_depth;\nbool x_found;\n\n// y çš„ä¿¡æ¯\nint y_target;\nstruct TreeNode* y_parent;\nint y_depth;\nbool y_found;\n\nvoid dfs(struct TreeNode* node, int depth, struct TreeNode* parent) {\n    if (!node) {\n        return;\n    }\n\n    if (node->val == x_target) {\n        x_parent = parent;\n        x_depth = depth;\n        x_found = true;\n    } else if (node->val == y_target) {\n        y_parent = parent;\n        y_depth = depth;\n        y_found = true;\n    }\n\n    // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†\n    // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“\n    if (x_found && y_found) {\n        return;\n    }\n\n    dfs(node->left, depth + 1, node);\n\n    if (x_found && y_found) {\n        return;\n    }\n\n    dfs(node->right, depth + 1, node);\n}\n\nbool isCousins(struct TreeNode* root, int x, int y) {\n    x_target = x;\n    y_target = y;\n    x_found = false;\n    y_found = false;\n    dfs(root, 0, NULL);\n    return x_depth == y_depth && x_parent != y_parent;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ ‘ä¸­çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦éå†æ•´æ£µæ ‘ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå³ä¸ºæ·±åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­éœ€è¦ä½¿ç”¨çš„æ ˆç©ºé—´ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œæ ‘å‘ˆç°é“¾çŠ¶ç»“æ„ï¼Œé€’å½’çš„æ·±åº¦ä¸º $O(n)$ã€‚\n\n#### æ–¹æ³•äºŒï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢\n\n**æ€è·¯ä¸ç®—æ³•**\n\nåœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œæ¯å½“æˆ‘ä»¬ä»é˜Ÿé¦–å–å‡ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå®ƒå°±ä¼šä½œä¸ºã€Œçˆ¶èŠ‚ç‚¹ã€ï¼Œå°†æœ€å¤šä¸¤ä¸ªå­èŠ‚ç‚¹æ”¾å…¥é˜Ÿå°¾ã€‚å› æ­¤ï¼Œé™¤äº†èŠ‚ç‚¹ä»¥å¤–ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨é˜Ÿåˆ—ä¸­é¢å¤–å­˜å‚¨ã€Œæ·±åº¦ã€çš„ä¿¡æ¯å³å¯ã€‚\n\n**ä»£ç **\n\n```C++ [sol2-C++]\nclass Solution {\nprivate:\n    // x çš„ä¿¡æ¯\n    int x;\n    TreeNode* x_parent;\n    int x_depth;\n    bool x_found = false;\n\n    // y çš„ä¿¡æ¯\n    int y;\n    TreeNode* y_parent;\n    int y_depth;\n    bool y_found = false;\n\npublic:\n    // ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°\n    void update(TreeNode* node, TreeNode* parent, int depth) {\n        if (node->val == x) {\n            tie(x_parent, x_depth, x_found) = tuple{parent, depth, true};\n        }\n        else if (node->val == y) {\n            tie(y_parent, y_depth, y_found) = tuple{parent, depth, true};\n        }\n    }\n\n    bool isCousins(TreeNode* root, int x, int y) {\n        this->x = x;\n        this->y = y;\n        queue<pair<TreeNode*, int>> q;\n        q.emplace(root, 0);\n        update(root, nullptr, 0);\n\n        while (!q.empty()) {\n            auto&& [node, depth] = q.front();\n            if (node->left) {\n                q.emplace(node->left, depth + 1);\n                update(node->left, node, depth + 1);\n            }\n            if (node->right) {\n                q.emplace(node->right, depth + 1);\n                update(node->right, node, depth + 1);\n            }\n            if (x_found && y_found) {\n                break;\n            }\n            q.pop();\n        }\n\n        return x_depth == y_depth && x_parent != y_parent;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    // x çš„ä¿¡æ¯\n    int x;\n    TreeNode xParent;\n    int xDepth;\n    boolean xFound = false;\n\n    // y çš„ä¿¡æ¯\n    int y;\n    TreeNode yParent;\n    int yDepth;\n    boolean yFound = false;\n\n    public boolean isCousins(TreeNode root, int x, int y) {\n        this.x = x;\n        this.y = y;\n\n        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();\n        Queue<Integer> depthQueue = new LinkedList<Integer>();\n        nodeQueue.offer(root);\n        depthQueue.offer(0);\n        update(root, null, 0);\n\n        while (!nodeQueue.isEmpty()) {\n            TreeNode node = nodeQueue.poll();\n            int depth = depthQueue.poll();\n            if (node.left != null) {\n                nodeQueue.offer(node.left);\n                depthQueue.offer(depth + 1);\n                update(node.left, node, depth + 1);\n            }\n            if (node.right != null) {\n                nodeQueue.offer(node.right);\n                depthQueue.offer(depth + 1);\n                update(node.right, node, depth + 1);\n            }\n            if (xFound && yFound) {\n                break;\n            }\n        }\n\n        return xDepth == yDepth && xParent != yParent;\n    }\n\n    // ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°\n    public void update(TreeNode node, TreeNode parent, int depth) {\n        if (node.val == x) {\n            xParent = parent;\n            xDepth = depth;\n            xFound = true;\n        } else if (node.val == y) {\n            yParent = parent;\n            yDepth = depth;\n            yFound = true;\n        }\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    // x çš„ä¿¡æ¯\n    int x;\n    TreeNode xParent;\n    int xDepth;\n    bool xFound = false;\n\n    // y çš„ä¿¡æ¯\n    int y;\n    TreeNode yParent;\n    int yDepth;\n    bool yFound = false;\n\n    public bool IsCousins(TreeNode root, int x, int y) {\n        this.x = x;\n        this.y = y;\n\n        Queue<Tuple<TreeNode, int>> queue = new Queue<Tuple<TreeNode, int>>();\n        queue.Enqueue(new Tuple<TreeNode, int>(root, 0));\n        Update(root, null, 0);\n\n        while (queue.Count > 0) {\n            Tuple<TreeNode, int> tuple = queue.Dequeue();\n            TreeNode node = tuple.Item1;\n            int depth = tuple.Item2;\n            if (node.left != null) {\n                queue.Enqueue(new Tuple<TreeNode, int>(node.left, depth + 1));\n                Update(node.left, node, depth + 1);\n            }\n            if (node.right != null) {\n                queue.Enqueue(new Tuple<TreeNode, int>(node.right, depth + 1));\n                Update(node.right, node, depth + 1);\n            }\n            if (xFound && yFound) {\n                break;\n            }\n        }\n\n        return xDepth == yDepth && xParent != yParent;\n    }\n\n    // ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°\n    public void Update(TreeNode node, TreeNode parent, int depth) {\n        if (node.val == x) {\n            xParent = parent;\n            xDepth = depth;\n            xFound = true;\n        } else if (node.val == y) {\n            yParent = parent;\n            yDepth = depth;\n            yFound = true;\n        }\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:\n        # x çš„ä¿¡æ¯\n        x_parent, x_depth, x_found = None, None, False\n        # y çš„ä¿¡æ¯\n        y_parent, y_depth, y_found = None, None, False\n        \n        # ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°\n        def update(node: TreeNode, parent: TreeNode, depth: int):\n            if node.val == x:\n                nonlocal x_parent, x_depth, x_found\n                x_parent, x_depth, x_found = parent, depth, True\n            elif node.val == y:\n                nonlocal y_parent, y_depth, y_found\n                y_parent, y_depth, y_found = parent, depth, True\n\n        q = collections.deque([(root, 0)])\n        update(root, None, 0)\n\n        while q:\n            node, depth = q.popleft()\n            if node.left:\n                q.append((node.left, depth + 1))\n                update(node.left, node, depth + 1)\n            if node.right:\n                q.append((node.right, depth + 1))\n                update(node.right, node, depth + 1)\n            \n            if x_found and y_found:\n                break\n\n        return x_depth == y_depth and x_parent != y_parent\n```\n\n```JavaScript [sol2-JavaScript]\nvar isCousins = function(root, x, y) {\n    // x çš„ä¿¡æ¯\n    let x_parent = null, x_depth = null, x_found = false;\n    // y çš„ä¿¡æ¯\n    let y_parent = null, y_depth = null, y_found = false;\n    \n    // ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°\n    const update = (node, parent, depth) => {\n        if (node.val === x) {\n            [x_parent, x_depth, x_found] = [parent, depth, true];\n        } else if (node.val === y) {\n            [y_parent, y_depth, y_found] = [parent, depth, true];\n        }\n    }\n\n    q = [[root, 0]];\n    update(root, null, 0);\n\n    while (q.length) {\n        const [node, depth] = q.shift()\n        if (node.left){\n            q.push([node.left, depth + 1]);\n            update(node.left, node, depth + 1);\n        }\n        if (node.right) {\n            q.push([node.right, depth + 1]);\n            update(node.right, node, depth + 1);\n        }\n        \n        if (x_found && y_found) {\n            break;\n        }\n    }\n\n    return x_depth === y_depth && x_parent !== y_parent;\n};\n```\n\n```go [sol2-Golang]\nfunc isCousins(root *TreeNode, x, y int) bool {\n    var xParent, yParent *TreeNode\n    var xDepth, yDepth int\n    var xFound, yFound bool\n\n    // ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°\n    update := func(node, parent *TreeNode, depth int) {\n        if node.Val == x {\n            xParent, xDepth, xFound = parent, depth, true\n        } else if node.Val == y {\n            yParent, yDepth, yFound = parent, depth, true\n        }\n    }\n\n    type pair struct {\n        node  *TreeNode\n        depth int\n    }\n    q := []pair{{root, 0}}\n    update(root, nil, 0)\n    for len(q) > 0 && (!xFound || !yFound) {\n        node, depth := q[0].node, q[0].depth\n        q = q[1:]\n        if node.Left != nil {\n            q = append(q, pair{node.Left, depth + 1})\n            update(node.Left, node, depth+1)\n        }\n        if node.Right != nil {\n            q = append(q, pair{node.Right, depth + 1})\n            update(node.Right, node, depth+1)\n        }\n    }\n\n    return xDepth == yDepth && xParent != yParent\n}\n```\n\n```C [sol2-C]\n// x çš„ä¿¡æ¯\nint x_target;\nstruct TreeNode* x_parent;\nint x_depth;\nbool x_found;\n\n// y çš„ä¿¡æ¯\nint y_target;\nstruct TreeNode* y_parent;\nint y_depth;\nbool y_found;\n\n// ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°\nvoid update(struct TreeNode* node, struct TreeNode* parent, int depth) {\n    if (node->val == x_target) {\n        x_parent = parent;\n        x_depth = depth;\n        x_found = true;\n    } else if (node->val == y_target) {\n        y_parent = parent;\n        y_depth = depth;\n        y_found = true;\n    }\n}\n\nstruct Node {\n    struct TreeNode* node;\n    int depth;\n};\n\nbool isCousins(struct TreeNode* root, int x, int y) {\n    x_target = x;\n    y_target = y;\n    x_found = false;\n    y_found = false;\n\n    struct Node q[100];\n    int left = 0, right = 0;\n    q[right++] = (struct Node){root, 0};\n    update(root, NULL, 0);\n\n    while (left < right) {\n        if (q[left].node->left) {\n            q[right++] = (struct Node){q[left].node->left, q[left].depth + 1};\n            update(q[left].node->left, q[left].node, q[left].depth + 1);\n        }\n        if (q[left].node->right) {\n            q[right++] = (struct Node){q[left].node->right, q[left].depth + 1};\n            update(q[left].node->right, q[left].node, q[left].depth + 1);\n        }\n        if (x_found && y_found) {\n            break;\n        }\n        left++;\n    }\n\n    return x_depth == y_depth && x_parent != y_parent;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ ‘ä¸­çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦éå†æ•´æ£µæ ‘ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå³ä¸ºå¹¿åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­éœ€è¦ä½¿ç”¨çš„é˜Ÿåˆ—ç©ºé—´ã€‚\n\n---\n## âœ¨æ‰£å‹å¸®å¸®å›¢ - äº’åŠ¨ç­”ç–‘\n\n[![è®¨è®º.jpg](https://pic.leetcode-cn.com/1621178600-MKHFrl-%E8%AE%A8%E8%AE%BA.jpg){:width=260px}](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)\n\n\nå³æ—¥èµ· - 5 æœˆ 30 æ—¥ï¼Œç‚¹å‡»Â [è¿™é‡Œ](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)Â å‰å¾€ã€Œ[æ‰£å‹å¸®å¸®å›¢](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)ã€æ´»åŠ¨é¡µï¼ŒæŠŠä½ é‡åˆ°çš„é—®é¢˜å¤§èƒ†åœ°æå‡ºæ¥ï¼Œè®©æ‰£å‹ä¸ºä½ è§£ç­”ï½\n\n### ğŸ å¥–åŠ±è§„åˆ™\nè¢«é‡‡çº³æ•°é‡æ’å 1ï½3 åï¼šã€ŒåŠ›æ‰£æå®¢å¥—è£…ã€ *1 å¹¶å°†è·å¾—ã€ŒåŠ›æ‰£ç¥ç§˜åº”æ´å›¢ã€å†…æµ‹èµ„æ ¼\nè¢«é‡‡çº³æ•°é‡æ’å 4ï½10 åï¼šã€ŒåŠ›æ‰£é¼ æ ‡å«ã€ *1 å¹¶å°†è·å¾—ã€ŒåŠ›æ‰£ç¥ç§˜åº”æ´å›¢ã€å†…æµ‹èµ„æ ¼\nã€Œè¯²äººä¸å€¦ã€ï¼šæ´»åŠ¨æœŸé—´ã€Œè§£æƒ‘è€…ã€åªè¦æœ‰ 1 ä¸ªå›ç­”è¢«é‡‡çº³ï¼Œå³å¯è·å¾— 20 LeetCoins å¥–åŠ±ï¼\nã€Œæ±‚çŸ¥è‹¥æ¸´ã€ï¼šæ´»åŠ¨æœŸé—´ã€Œæ±‚çŸ¥è€…ã€åœ¨æ´»åŠ¨é¡µå‘èµ·ä¸€æ¬¡ç¬¦åˆè¦æ±‚çš„ç–‘é—®å¸–å¹¶è‡³å°‘é‡‡çº³ä¸€æ¬¡ã€Œè§£æƒ‘è€…ã€çš„å›ç­”ï¼Œå³å¯è·å¾— 20 LeetCoins å¥–åŠ±ï¼\n\næ´»åŠ¨è¯¦æƒ…çŒ›æˆ³é“¾æ¥äº†è§£æ›´å¤šï¼š[æ´»åŠ¨ï½œä½ æœ‰ BUG æˆ‘æ¥å¸® - åŠ›æ‰£äº’åŠ¨ç­”ç–‘å­£](https://leetcode-cn.com/circle/discuss/xtliW6/)"
}