{
	"titleSlug": "number-of-ways-to-reorder-array-to-get-same-bst",
	"slug": "jiang-zi-shu-zu-zhong-xin-pai-xu-de-dao-tong-yi-2",
	"url": "https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/solution/jiang-zi-shu-zu-zhong-xin-pai-xu-de-dao-tong-yi-2/",
	"content": "#### 方法一：动态规划 + 组合计数\n\n**前言**\n\n方法一需要读者掌握如下内容：\n\n- 组合计数。在 $n$ 个物品中选择 $k$ 个（不计顺序）的方案数为 $C_n^k$，称之为「组合数」。组合数也可以写作 $\\binom{n}{k}$，计算公式为：\n\n    $$\n    C_n^k = \\binom{n}{k} = \\frac{n (n-1) \\cdots (n-k+1) }{k!} = \\frac{n!}{k!(n-k)!}\n    $$\n\n    这里定义 $0!=1$，那么有 $C_n^0 = C_n^n = 1$。\n\n    组合数也可以通过递推求出：\n\n    $$\n    C_n^k = C_{n-1}^k + C_{n-1}^{k-1}\n    $$\n\n    直观上来看，从 $n$ 个物品中选择 $k$ 个的方案数，等于从前 $n-1$ 个物品中选择 $k$ 个的方案数，加上从前 $n-1$ 个物品中选择 $k-1$ 个（再选上第 $n$ 个物品）的方案数之和。\n\n**思路与算法**\n\n我们不妨先根据数组 $\\textit{nums}$ 把整棵二叉查找树 $T$ 建立出来。\n\n设某个满足要求的排列为 $a_0, a_1, \\cdots, a_{n-1}$，那么 $a_0$ 必然是树 $T$ 的根节点的元素，也就是 $\\textit{nums}[0]$。\n\n根据二叉查找树的性质，数组 $\\textit{nums}$ 中小于 $a_0$ 的元素会全部出现在根节点的左子树中，而数组 $\\textit{nums}$ 中大于 $a_0$ 的元素会全部出现在根节点的右子树中：\n\n- 左子树即为将数组 $\\textit{nums}$ 中小于 $a_0$ 的元素按照它们的出现顺序，依次插入一棵空的二叉查找树得到的结果；\n\n- 右子树即为将数组 $\\textit{nums}$ 中大于 $a_0$ 的元素按照它们的出现顺序，依次插入一棵空的二叉查找树得到的结果。\n\n这样一来，我们就将原始问题转化成了两个规模更小但完全相同的子问题，因此我们可以尝试使用动态规划来解决本题。\n\n我们设 $f[a_i]$ 表示**对于树 T 中以元素 $a_i$（对应的节点）为根节点的子树，将其中包含的所有元素进行重排列，并按照顺序依次插入一棵空的二叉查找树，可以得到和该子树相同结果的排列数**。对于 $a_i$ 而言，如果其左子树为 $a_{il}$，右子树为 $a_{ir}$，并且我们已经求出了 $f[a_{il}]$ 以及 $f[a_{ir}]$ 的值，那么：\n\n- 设以 $a_i$ 为根节点的子树对应的排列的长度为 $\\text{size}(a_i)$；\n\n- 排列的首个元素为 $a_i$；\n\n- 我们需要在剩余的 $\\text{size}(a_i) - 1$ 个位置中，选择 $\\text{size}(a_{il})$ 个位置用来放置左子树中的元素，剩余 $\\text{size}(a_i) - 1 - \\text{size}(a_{il}) = \\text{size}(a_{ir})$ 个位置用来放置右子树中的元素。\n\n由于在 $\\text{size}(a_i)-1$ 个位置中选择 $\\text{size}(a_{il})$ 个位置的方案数为 $C_{\\text{size}(a_i)-1}^{\\text{size}(a_{il})}$，左子树的排列数为 $f[a_{il}]$，右子树的排列数为 $f[a_{ir}]$，根据乘法原理，可以得到状态转移方程为：\n\n$$\nf[a_i] = C_{\\text{size}(a_i)-1}^{\\text{size}(a_{il})} \\cdot f[a_{il}] \\cdot f[a_{ir}]\n$$\n\n如果 $a_i$ 的某个子树为空，那么对应的 $\\text{size}$ 值为 $0$，$f$ 值为 $1$。最终的答案即为 $f[a_0]$。\n\n由于我们需要将答案对 $10^9+7$ 进行取模，直接计算组合数的公式中包含除法，处理起来十分麻烦。因此我们可以使用递推的方法预处理出所有需要用到的组合数 $C_{n'}^k$，其中 $0 \\leq n' < n$，$0 \\leq k \\leq n'$。\n\n**代码**\n\n```C++ [sol1-C++]\nstruct TNode {\n    TNode* left;\n    TNode* right;\n    int value;\n    int size;\n    int ans;\n    \n    TNode(int val): left(nullptr), right(nullptr), value(val), size(1), ans(0) {}\n};\n\nclass Solution {\nprivate:\n    static constexpr int mod = 1000000007;\n    vector<vector<int>> c;\n\npublic:\n    void insert(TNode* root, int val) {\n        TNode* cur = root;\n        while (true) {\n            ++cur->size;\n            if (val < cur->value) {\n                if (!cur->left) {\n                    cur->left = new TNode(val);\n                    return;\n                }\n                cur = cur->left;\n            }\n            else {\n                if (!cur->right) {\n                    cur->right = new TNode(val);\n                    return;\n                }\n                cur = cur->right;\n            }\n        }\n    }\n\n    void dfs(TNode* node) {\n        if (!node) {\n            return;\n        }\n        dfs(node->left);\n        dfs(node->right);\n        int lsize = node->left ? node->left->size : 0;\n        int rsize = node->right ? node->right->size : 0;\n        int lans = node->left ? node->left->ans : 1;\n        int rans = node->right ? node->right->ans : 1;\n        node->ans = (long long)c[lsize + rsize][lsize] % mod * lans % mod * rans % mod;\n    }\n\n    int numOfWays(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) {\n            return 0;\n        }\n\n        c.assign(n, vector<int>(n));\n        c[0][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            c[i][0] = 1;\n            for (int j = 1; j < n; ++j) {\n                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n            }\n        }\n\n        TNode* root = new TNode(nums[0]);\n        for (int i = 1; i < n; ++i) {\n            int val = nums[i];\n            insert(root, val);\n        }\n\n        dfs(root);\n        return (root->ans - 1 + mod) % mod;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static final int MOD = 1000000007;\n    long[][] c;\n\n    public int numOfWays(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return 0;\n        }\n\n        c = new long[n][n];\n        c[0][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            c[i][0] = 1;\n            for (int j = 1; j < n; ++j) {\n                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n            }\n        }\n\n        TreeNode root = new TreeNode(nums[0]);\n        for (int i = 1; i < n; ++i) {\n            int val = nums[i];\n            insert(root, val);\n        }\n\n        dfs(root);\n        return (root.ans - 1 + MOD) % MOD;\n    }\n\n    public void insert(TreeNode root, int value) {\n        TreeNode cur = root;\n        while (true) {\n            ++cur.size;\n            if (value < cur.value) {\n                if (cur.left == null) {\n                    cur.left = new TreeNode(value);\n                    return;\n                }\n                cur = cur.left;\n            } else {\n                if (cur.right == null) {\n                    cur.right = new TreeNode(value);\n                    return;\n                }\n                cur = cur.right;\n            }\n        }\n    }\n\n    public void dfs(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        dfs(node.left);\n        dfs(node.right);\n        int lsize = node.left != null ? node.left.size : 0;\n        int rsize = node.right != null ? node.right.size : 0;\n        int lans = node.left != null ? node.left.ans : 1;\n        int rans = node.right != null ? node.right.ans : 1;\n        node.ans = (int) (c[lsize + rsize][lsize] % MOD * lans % MOD * rans % MOD);\n    }\n}\n\nclass TreeNode {\n    TreeNode left;\n    TreeNode right;\n    int value;\n    int size;\n    int ans;\n\n    TreeNode(int value) {\n        this.value = value;\n        this.size = 1;\n        this.ans = 0;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass TNode:\n    def __init__(self, val):\n        self.left = None\n        self.right = None\n        self.value = val\n        self.size = 1\n        self.ans = 0\n\nclass Solution:\n    def numOfWays(self, nums: List[int]) -> int:\n        def insert(val: int):\n            cur = root\n            while True:\n                cur.size += 1\n                if val < cur.value:\n                    if not cur.left:\n                        cur.left = TNode(val)\n                        return\n                    cur = cur.left\n                else:\n                    if not cur.right:\n                        cur.right = TNode(val)\n                        return\n                    cur = cur.right\n        \n        def dfs(node: TNode):\n            if not node:\n                return\n            dfs(node.left)\n            dfs(node.right)\n            lsize = node.left.size if node.left else 0\n            rsize = node.right.size if node.right else 0\n            lans = node.left.ans if node.left else 1\n            rans = node.right.ans if node.right else 1\n            node.ans = c[lsize + rsize][lsize] * lans * rans % mod\n\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        mod = 10**9 + 7\n        c = [[0] * n for _ in range(n)]\n        c[0][0] = 1\n        for i in range(1, n):\n            c[i][0] = 1\n            for j in range(1, n):\n                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod\n\n        root = TNode(nums[0])\n        for i in range(1, n):\n            val = nums[i]\n            insert(val)\n\n        dfs(root)\n        return (root.ans - 1 + mod) % mod\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$。时间复杂度由以下三部分组成：\n\n    - 预处理组合数的时间复杂度为 $O(n^2)$；\n\n    - 建立二叉查找树的平均时间复杂度为 $O(n \\log n)$。但在最坏情况下，当数组 $\\textit{nums}$ 中的数单调递增或递减时，二叉查找树退化成链式结构，建立的时间复杂度为 $O(n^2)$。\n\n    - 动态规划的时间复杂度为 $O(n)$，即为对二叉查找树进行遍历需要的时间。\n\n- 空间复杂度：$O(n^2)$。\n\n**小贴士**\n\n上述 `Python` 代码的运行时间较长，具体的原因是 `Python` 对列表 `list` 的访问效率较低，预处理组合数耗费了大部分的时间。根据 `Python` 语言的特性，可以不对组合数进行预处理，而是使用 `math.comb` 或者 `math.factorial` 函数直接计算组合数，可以大大降低运行时间。但这里仍然希望读者能够掌握递推计算组合数的技巧。\n\n#### 方法二：并查集 + 乘法逆元优化\n\n**前言**\n\n方法二为竞赛难度，力求将方法一中的各个部分进行优化，达到更低的时间复杂度，供读者挑战自我。\n\n方法二需要读者掌握如下内容：\n\n- 使用「路径压缩」和「按秩合并」优化的并查集，并且知道并查集实际上是一种树形结构。并查集为面试中常见的数据结构，关于这两种优化的资料也随处可得，故这里不再赘述。\n\n- 乘法逆元。设模数为 $m$，整数 $a~(0 < a < m)$ 在模 $m$ 的意义下存在乘法逆元整数 $b~(0 < b < m)$，当且仅当\n\n    $$\n    ab \\equiv 1 ~ (\\bmod ~ m)\n    $$\n\n    成立。当 $m$ 为质数时，根据上式可得\n\n    $$\n    ab = km + 1, \\quad k \\in \\mathbb{N}^+\n    $$\n\n    整理得\n\n    $$\n    b \\cdot a - k \\cdot m = 1\n    $$\n\n    根据「裴蜀定理」，由于 $\\text{gcd}(a, m) = 1$，因此必存在整数 $b$ 和 $k$ 使得上式成立。如果 $(b_0, k_0)$ 是一组解，那么\n    \n    $$\n    (b_0 + cm, k_0 + ca), \\quad c \\in \\mathbb{Z}\n    $$\n\n    都是上式的解。因此必然存在一组解中的整数 $b$ 满足 $0 < b < m$。\n\n    那么如何求出 $b$ 呢？一种简单的方法是使用「费马小定理」，即\n\n    $$\n    a^{m-1} \\equiv 1 ~ (\\bmod ~ m)\n    $$\n\n    那么有\n\n    $$\n    ab \\equiv a^{m-1} ~ (\\bmod ~ m)\n    $$\n\n    即\n\n    $$\n    b \\equiv a^{m-2} ~ (\\bmod ~ m)\n    $$\n\n    使用「乘法逆元」有什么好处呢？如果我们要求 $\\frac{c}{a}$ 对 $m$ 取模的结果，那么我们可以化除法为乘法，即\n\n    $$\n    \\frac{c}{a} \\equiv c \\cdot b ~ (\\bmod ~ m)\n    $$\n\n    这样一来，我们只要：\n\n    - 预处理出所有 $\\textit{fac}[i] = i! \\bmod m$；\n\n    - 预处理出所有 $\\textit{facInv}[i] = (i!)^{-1} = (i!)^{m-2} \\bmod m$。\n\n    其中 $(i!)^{-1}$ 表示 $i!$ 在模 $m$ 意义下的乘法逆元，就可以快速计算出组合数：\n\n    $$\n    C_n^k = \\frac{n!}{k!(n-k)!} \\equiv \\textit{fac}[n] \\cdot \\textit{facInv}[k] \\cdot \\textit{facInv}[n-k] ~ (\\bmod ~ m)\n    $$\n\n    预处理的时间复杂度为 $O(n \\log m)$，计算组合数的时间复杂度为 $O(1)$。如果读者不知道如何快速计算 $(i!)^{m-2} \\bmod m$，可以参考 [50. Pow(x, n) 的官方题解](https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/)。\n\n    还能做到更快吗？答案是可以的。我们可以使用一个辅助数组 $\\textit{inv}[i]$ 表示数 $i$ 的逆元 $i^{-1}$，这样我们可以使用递推式\n\n    $$\n    \\textit{facInv}[i] = \\textit{facInv}[i-1] \\cdot \\textit{inv}[i]\n    $$\n\n    计算阶乘的乘法逆元。而 $i^{-1}$ 可以快速计算得到。设 $m = u \\cdot i + v$，其中 $(u, v)$ 是 $m$ 除以 $i$ 的商和余数，那么有：\n\n    $$\n    \\begin{aligned}\n    & u \\cdot i + v = m \\equiv 0 \\\\\n    \\Leftrightarrow ~ & u + v \\cdot i^{-1} \\equiv 0 \\\\\n    \\Leftrightarrow ~ & u \\cdot v^{-1} + i^{-1} \\equiv 0 \\\\\n    \\Leftrightarrow ~ & i^{-1} \\equiv -u \\cdot v^{-1} ~ (\\bmod ~ m)\n    \\end{aligned}\n    $$\n\n    由于 $u = \\lfloor m/i \\rfloor$，$v = m ~\\%~ i$，因此有\n\n    $$\n    \\textit{inv}[i] \\equiv -\\lfloor m/i \\rfloor \\cdot \\textit{inv}[m ~\\%~ i] ~ (\\bmod ~ m)\n    $$\n\n    在实际的代码编写中，由于右侧为负数，因此可以将右侧加上 $m \\cdot \\textit{inv}[m ~\\%~ i]$，不会影响取模的结果，得到\n\n    $$\n    \\textit{inv}[i] \\equiv (m-\\lfloor m/i \\rfloor) \\cdot \\textit{inv}[m ~\\%~ i] ~ (\\bmod ~ m)\n    $$\n\n    这样一来，预处理的时间复杂度降低为 $O(n)$，计算组合数的时间复杂度仍然为 $O(1)$。\n\n**思路与算法**\n\n在方法一中的「时间复杂度」部分，我们详细列举了每一部分需要的时间。现在我们已经将预处理组合数的时间复杂度降低至 $O(n)$，并且将空间复杂度从 $O(n^2)$ 减少至 $O(n)$，那么接下来就需要降低建立二叉树的时间复杂度了。\n\n可以发现，在方法一中我们并没有用到数组 $\\textit{nums}$ 是 $1$ 到 $n$ 的一个排列这样的条件：只要数组 $\\textit{nums}$ 中的元素互不相同，方法一都可以得到正确的结果。\n\n对于两个相邻的整数 $a_i$ 和 $a_i-1$，我们可以证明：\n\n- 如果 $a_i$ 在数组 $\\textit{nums}$ 中出现在 $a_i-1$ 之前，那么 $a_i-1$ 必然出现在 $a_i$ 对应的节点的左子树中。这是因为 $a_i-1$ 和 $a_i$ 中没有其它的数出现在数组 $\\textit{nums}$ 中，所以这两个数相较于其它的数要么同时较小，要么同时较大。因此在插入 $a_i-1$ 时，会从根节点走到 $a_i$ 对应的节点，再走到其左子树中；\n\n    - 用相同的方法可以证明：对于两个相邻的整数 $a_i$ 和 $a_i+1$，如果 $a_i$ 在数组 $\\textit{nums}$ 中出现在 $a_i+1$ 之前，那么 $a_i+1$ 必然出现在 $a_i$ 对应的节点的右子树中。\n\n- 如果 $a_i$ 在数组 $\\textit{nums}$ 中出现在 $a_i-1$ 之后，那么 $a_i$ 对应的节点的左子树为空。这是因为 $a_i-1$ 在数组 $\\textit{nums}$ 中出现在 $a_i$ 之前，根据上面的证明，$a_i$ 必然出现在 $a_i-1$ 对应的节点的右子树中，要想成为 $a_i$ 对应的节点的左子树中的元素，必须要小于 $a_i$，但小于 $a_i$ 的数一定都小于 $a_i-1$，会被 $a_i-1$ 对应的节点「拦截」，因此 $a_i$ 对应的节点的左子树为空。\n\n    - 用相同的方法可以证明：如果 $a_i$ 在数组 $\\textit{nums}$ 中出现在 $a_i+1$ 之后，那么 $a_i+1$ 对应的节点的左子树为空。\n\n这样一来，我们只需要逆序地遍历数组 $\\textit{nums}$ 就可以快速地构造出整棵二叉查找树了。当我们遍历到 $\\textit{nums}[i]$ 时：\n\n- 如果 $\\textit{nums}[i]-1$ 已经遍历过，那么 $\\textit{nums}[i]$ 对应的节点的左子树，就是包含 $\\textit{nums}[i]-1$ 的树；否则 $\\textit{nums}[i]$ 的左子树为空；\n\n- 如果 $\\textit{nums}[i]+1$ 已经遍历过，那么 $\\textit{nums}[i]$ 对应的节点的右子树，就是包含 $\\textit{nums}[i]+1$ 的树；否则 $\\textit{nums}[i]$ 的右子树为空；\n\n那么如何得到包含某个元素的树的根节点呢？在构造二叉查找树的同时，我们可以使用并查集维护当前遍历过的元素之间的连通性。在遍历数组 $\\textit{nums}$ 并构造二叉查找树的过程中，元素 $\\textit{nums}[i .. n-1]$ 对应着若干棵二叉查找树，而每棵二叉查找树都**一一对应着**并查集中的一棵树。对于并查集中的每棵树，我们在其根节点上记录**这棵树对应的二叉查找树的根节点**，记为数组 $\\textit{root}$。这样对于任意一个元素，我们在并查集中查找到根，也就能得到其在二叉查找树中的根节点了。\n\n通过并查集辅助二叉查找树的构造，时间复杂度可以降低至 $O(n \\alpha(n))$。\n\n**细节**\n\n当我们需要合并并查集中的两个根节点 $x$ 和 $y$ 时，如何修改 $\\textit{root}[x]$ 和 $\\textit{root}[y]$ 呢？读者可以对这个问题进行思考，也可以参考下面的代码得出答案。\n\n**代码**\n\n```C++ [sol2-C++]\nstruct TNode {\n    TNode* left;\n    TNode* right;\n    int size;\n    int ans;\n    \n    TNode(): left(nullptr), right(nullptr), size(1), ans(0) {}\n};\n\nclass UnionFind {\npublic:\n    vector<int> parent, size, root;\n    int n;\n    \npublic:\n    UnionFind(int _n): n(_n), parent(_n), size(_n, 1), root(_n) {\n        iota(parent.begin(), parent.end(), 0);\n        iota(root.begin(), root.end(), 0);\n    }\n    \n    int findset(int x) {\n        return parent[x] == x ? x : parent[x] = findset(parent[x]);\n    }\n\n    int getroot(int x) {\n        return root[findset(x)];\n    }\n    \n    void unite(int x, int y) {\n        root[y] = root[x];\n        if (size[x] < size[y]) {\n            swap(x, y);\n        }\n        parent[y] = x;\n        size[x] += size[y];\n    }\n    \n    bool findAndUnite(int x, int y) {\n        int x0 = findset(x);\n        int y0 = findset(y);\n        if (x0 != y0) {\n            unite(x0, y0);\n            return true;\n        }\n        return false;\n    }\n};\n\nclass Solution {\nprivate:\n    static constexpr int mod = 1000000007;\n    vector<int> fac, inv, facInv;\n\npublic:\n    int numOfWays(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) {\n            return 0;\n        }\n\n        fac.resize(n);\n        inv.resize(n);\n        facInv.resize(n);\n        fac[0] = inv[0] = facInv[0] = 1;\n        fac[1] = inv[1] = facInv[1] = 1;\n        for (int i = 2; i < n; ++i) {\n            fac[i] = (long long)fac[i - 1] * i % mod;\n            inv[i] = (long long)(mod - mod / i) * inv[mod % i] % mod;\n            facInv[i] = (long long)facInv[i - 1] * inv[i] % mod;\n        }\n\n        unordered_map<int, TNode*> found;\n        UnionFind uf(n);\n        for (int i = n - 1; i >= 0; --i) {\n            int val = nums[i] - 1;\n            TNode* node = new TNode();\n            if (val > 0 && found.count(val - 1)) {\n                int lchild = uf.getroot(val - 1);\n                node->left = found[lchild];\n                node->size += node->left->size;\n                uf.findAndUnite(val, lchild);\n            }\n            if (val < n - 1 && found.count(val + 1)) {\n                int rchild = uf.getroot(val + 1);\n                node->right = found[rchild];\n                node->size += node->right->size;\n                uf.findAndUnite(val, rchild);\n            }\n            \n            int lsize = node->left ? node->left->size : 0;\n            int rsize = node->right ? node->right->size : 0;\n            int lans = node->left ? node->left->ans : 1;\n            int rans = node->right ? node->right->ans : 1;\n            node->ans = (long long)fac[lsize + rsize] * facInv[lsize] % mod * facInv[rsize] % mod * lans % mod * rans % mod;\n            found[val] = node;\n        }\n\n        return (found[nums[0] - 1]->ans - 1 + mod) % mod;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    static final int MOD = 1000000007;\n    long[] fac;\n    long[] inv;\n    long[] facInv;\n\n    public int numOfWays(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return 0;\n        }\n\n        fac = new long[n];\n        inv = new long[n];\n        facInv = new long[n];\n        fac[0] = inv[0] = facInv[0] = 1;\n        fac[1] = inv[1] = facInv[1] = 1;\n        for (int i = 2; i < n; ++i) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;\n            facInv[i] = facInv[i - 1] * inv[i] % MOD;\n        }\n\n        Map<Integer, TreeNode> found = new HashMap<Integer, TreeNode>();\n        UnionFind uf = new UnionFind(n);\n        for (int i = n - 1; i >= 0; --i) {\n            int val = nums[i] - 1;\n            TreeNode node = new TreeNode();\n            if (val > 0 && found.containsKey(val - 1)) {\n                int lchild = uf.getroot(val - 1);\n                node.left = found.get(lchild);\n                node.size += node.left.size;\n                uf.findAndUnite(val, lchild);\n            }\n            if (val < n - 1 && found.containsKey(val + 1)) {\n                int rchild = uf.getroot(val + 1);\n                node.right = found.get(rchild);\n                node.size += node.right.size;\n                uf.findAndUnite(val, rchild);\n            }\n            \n            int lsize = node.left != null ? node.left.size : 0;\n            int rsize = node.right != null ? node.right.size : 0;\n            int lans = node.left != null ? node.left.ans : 1;\n            int rans = node.right != null ? node.right.ans : 1;\n            node.ans = (int) (fac[lsize + rsize] * facInv[lsize] % MOD * facInv[rsize] % MOD * lans % MOD * rans % MOD);\n            found.put(val, node);\n        }\n\n        return (found.get(nums[0] - 1).ans - 1 + MOD) % MOD;\n    }\n}\n\nclass TreeNode {\n    TreeNode left;\n    TreeNode right;\n    int size;\n    int ans;\n\n    TreeNode() {\n        size = 1;\n        ans = 0;\n    }\n}\n\nclass UnionFind {\n    public int[] parent;\n    public int[] size;\n    public int[] root;\n    public int n;\n\n    public UnionFind(int n) {\n        this.n = n;\n        parent = new int[n];\n        size = new int[n];\n        root = new int[n];\n        Arrays.fill(size, 1);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            root[i] = i;\n        }\n    }\n\n    public int findset(int x) {\n        return parent[x] == x ? x : (parent[x] = findset(parent[x]));\n    }\n\n    public int getroot(int x) {\n        return root[findset(x)];\n    }\n    \n    public void unite(int x, int y) {\n        root[y] = root[x];\n        if (size[x] < size[y]) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n        parent[y] = x;\n        size[x] += size[y];\n    }\n    \n    public boolean findAndUnite(int x, int y) {\n        int x0 = findset(x);\n        int y0 = findset(y);\n        if (x0 != y0) {\n            unite(x0, y0);\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass TNode:\n    def __init__(self):\n        self.left = None\n        self.right = None\n        self.size = 1\n        self.ans = 0\n\nclass UnionFind:\n    def __init__(self, n: int):\n        self.n = n\n        self.parent = list(range(n))\n        self.root = list(range(n))\n        self.size = [1] * n\n    \n    def findset(self, x: int) -> int:\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.findset(self.parent[x])\n        return self.parent[x]\n    \n    def getroot(self, x: int) -> int:\n        return self.root[self.findset(x)]\n    \n    def unite(self, x: int, y: int):\n        self.root[y] = self.root[x]\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.parent[y] = x\n        self.size[x] += self.size[y]\n    \n    def findAndUnite(self, x: int, y: int) -> bool:\n        parentX, parentY = self.findset(x), self.findset(y)\n        if parentX != parentY:\n            self.unite(parentX, parentY)\n            return True\n        return False\n\nclass Solution:\n    def numOfWays(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        mod = 10**9 + 7\n        fac = [0] * n\n        inv = [0] * n\n        facInv = [0] * n\n        fac[0] = inv[0] = facInv[0] = 1\n        fac[1] = inv[1] = facInv[1] = 1\n        for i in range(2, n):\n            fac[i] = fac[i - 1] * i % mod\n            inv[i] = (mod - mod // i) * inv[mod % i] % mod\n            facInv[i] = facInv[i - 1] * inv[i] % mod\n\n        found = dict()\n        uf = UnionFind(n)\n        for i in range(n - 1, -1, -1):\n            val = nums[i] - 1\n            node = TNode()\n            if val > 0 and val - 1 in found:\n                lchild = uf.getroot(val - 1)\n                node.left = found[lchild]\n                node.size += node.left.size\n                uf.findAndUnite(val, lchild)\n            if val < n - 1 and val + 1 in found:\n                rchild = uf.getroot(val + 1)\n                node.right = found[rchild]\n                node.size += node.right.size\n                uf.findAndUnite(val, rchild)\n            \n            lsize = node.left.size if node.left else 0\n            rsize = node.right.size if node.right else 0\n            lans = node.left.ans if node.left else 1\n            rans = node.right.ans if node.right else 1\n            node.ans = fac[lsize + rsize] * facInv[lsize] * facInv[rsize] * lans * rans % mod;\n            found[val] = node\n\n        return (found[nums[0] - 1].ans - 1 + mod) % mod\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\alpha(n))$。\n\n- 空间复杂度：$O(n)$。"
}