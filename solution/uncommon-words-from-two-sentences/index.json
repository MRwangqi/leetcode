{
	"titleSlug": "uncommon-words-from-two-sentences",
	"slug": "liang-ju-hua-zhong-de-bu-chang-jian-dan-a8bmz",
	"url": "https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/solution/liang-ju-hua-zhong-de-bu-chang-jian-dan-a8bmz/",
	"content": "#### 方法一：哈希表\n\n**思路与算法**\n\n根据题目要求，我们需要找出「在句子 $s_1$ 中恰好出现一次，但在句子 $s_2$ 中没有出现的单词」或者「在句子 $s_2$ 中恰好出现一次，但在句子 $s_1$ 中没有出现的单词」。这其实等价于找出：\n\n> 在两个句子中一共只出现一次的单词。\n\n因此我们可以使用一个哈希映射统计两个句子中单词出现的次数。对于哈希映射中的每个键值对，键表示一个单词，值表示该单词出现的次数。在统计完成后，我们再对哈希映射进行一次遍历，把所有值为 $1$ 的键放入答案中即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> uncommonFromSentences(string s1, string s2) {\n        unordered_map<string, int> freq;\n        \n        auto insert = [&](const string& s) {\n            stringstream ss(s);\n            string word;\n            while (ss >> word) {\n                ++freq[move(word)];\n            }\n        };\n\n        insert(s1);\n        insert(s2);\n\n        vector<string> ans;\n        for (const auto& [word, occ]: freq) {\n            if (occ == 1) {\n                ans.push_back(word);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String[] uncommonFromSentences(String s1, String s2) {\n        Map<String, Integer> freq = new HashMap<String, Integer>();\n        insert(s1, freq);\n        insert(s2, freq);\n\n        List<String> ans = new ArrayList<String>();\n        for (Map.Entry<String, Integer> entry : freq.entrySet()) {\n            if (entry.getValue() == 1) {\n                ans.add(entry.getKey());\n            }\n        }\n        return ans.toArray(new String[0]);\n    }\n\n    public void insert(String s, Map<String, Integer> freq) {\n        String[] arr = s.split(\" \");\n        for (String word : arr) {\n            freq.put(word, freq.getOrDefault(word, 0) + 1);\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string[] UncommonFromSentences(string s1, string s2) {\n        Dictionary<string, int> freq = new Dictionary<string, int>();\n        Insert(s1, freq);\n        Insert(s2, freq);\n\n        IList<string> ans = new List<string>();\n        foreach (KeyValuePair<string, int> pair in freq) {\n            if (pair.Value == 1) {\n                ans.Add(pair.Key);\n            }\n        }\n        return ans.ToArray();\n    }\n\n    public void Insert(string s, Dictionary<string, int> freq) {\n        string[] arr = s.Split(\" \");\n        foreach (string word in arr) {\n            if (!freq.ContainsKey(word)) {\n                freq.Add(word, 0);\n            }\n            ++freq[word];\n        }\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        freq = Counter(s1.split()) + Counter(s2.split())\n        \n        ans = list()\n        for word, occ in freq.items():\n            if occ == 1:\n                ans.append(word)\n        \n        return ans\n```\n\n```Golang [sol1-Golang]\nfunc uncommonFromSentences(s1 string, s2 string) []string {\n\tfreq := make(map[string]int)\n\n\tinsert := func(s string) {\n\t\twords := strings.Split(s, \" \")\n\t\tfor _, word := range words {\n\t\t\tfreq[word]++\n\t\t}\n\t}\n\n\tinsert(s1)\n\tinsert(s2)\n\n\tans := []string{}\n\tfor word, occ := range freq {\n\t\tif occ == 1 {\n\t\t\tans = append(ans, word)\n\t\t}\n\t}\n\treturn ans\n}\n```\n\n```C [sol1-C]\ntypedef struct  {\n    char * word;            \n    int val;\n    UT_hash_handle hh;\n} HashEntry;\n\nbool insert(char * str, HashEntry ** obj) {\n    HashEntry * pEntry = NULL;\n    char *token = NULL;\n\n    token = strtok(str, \" \");\n    while (token != NULL ) {\n        pEntry = NULL;\n        HASH_FIND_STR(*obj, token, pEntry);\n        if (NULL == pEntry) {\n            HashEntry * pEntry = (HashEntry *)malloc(sizeof(HashEntry));\n            pEntry->word = (char *)malloc(sizeof(char) * (strlen(token) + 1));\n            strcpy(pEntry->word, token);\n            pEntry->val = 1;\n            HASH_ADD_STR(*obj, word, pEntry);\n        } else {\n            pEntry->val++;\n        }\n        token = strtok(NULL, \" \");\n    }\n    return true;\n}\n\nchar ** uncommonFromSentences(char * s1, char * s2, int* returnSize){\n    HashEntry * freq = NULL;\n    HashEntry * pEntry = NULL;\n\n    insert(s1, &freq);\n    insert(s2, &freq);\n    unsigned int sentenceSize = HASH_COUNT(freq);\n    char ** ans = (char **)malloc(sizeof(char *) * sentenceSize);\n    int pos = 0;\n    HashEntry *curr = NULL, *next = NULL;\n    HASH_ITER(hh, freq, curr, next) {\n        if (curr->val == 1) {\n            ans[pos] = (char *)malloc(sizeof(char) * (strlen(curr->word) + 1));\n            strcpy(ans[pos], curr->word);\n            pos++;\n        }\n    }\n    HASH_ITER(hh, freq, curr, next) {\n        free(curr->word);\n        HASH_DEL(freq, curr);\n    }\n    *returnSize = pos;\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar uncommonFromSentences = function(s1, s2) {\n    let freq = new Map();\n    freq = insert(s1, freq);\n    freq = insert(s2, freq);\n\n    const ans = [];\n    for (const entry of freq.entries()) {\n        if (entry[1] === 1) {\n            ans.push(entry[0]);\n        }\n    }\n    return ans;\n};\n\nconst insert = (s, freq) => {\n    const arr = s.split(\" \");\n    for (const word of arr) {\n        freq.set(word, (freq.get(word) || 0) + 1);\n    }\n    return freq;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(|s_1| + |s_2|)$。我们需要 $O(|s_1| + |s_2|)$ 的时间对这两个字符串进行遍历，并将所有的单词放入哈希映射。在这之后，我们还需要对哈希映射进行遍历。在最坏情况下，$s_1$ 和 $s_2$ 包含的单词都不重复，并且长度较短，即哈希映射中单词的个数为 $O(|s_1| + |s_2|)$。此时遍历哈希映射就需要 $O(|s_1| + |s_2|)$ 的时间。\n\n- 空间复杂度：$O(|s_1| + |s_2|)$。即为哈希映射需要使用的空间。此外，在取出两个字符串中的单词时，为了方便也需要 $O(|s_1| + |s_2|)$ 的辅助空间。"
}