{
	"titleSlug": "maximum-ascending-subarray-sum",
	"slug": "zui-da-sheng-xu-zi-shu-zu-he-by-leetcode-0q6v",
	"url": "https://leetcode-cn.com/problems/maximum-ascending-subarray-sum/solution/zui-da-sheng-xu-zi-shu-zu-he-by-leetcode-0q6v/",
	"content": "#### 方法一：动态规划\n\n**思路与算法**\n\n题目给定了一个长度为 $n$ 的正整数数组 $\\textit{nums}$，现在要求一个升序的子数组最大可能的元素和。那么我们设 $\\textit{dp}[i]$ 表示以 $\\textit{nums}[i]$ 结尾的的最长升序子数组的元素和。那么我们考虑如何求解每一个状态：\n\n1. 当 $\\textit{nums}[i] > \\textit{nums}[i - 1]$ 时：\n   $$\\textit{dp}[i] = \\textit{dp}[i - 1] + \\textit{nums}[i]$$\n2. 当 $\\textit{nums}[i] \\le \\textit{nums}[i - 1]$ 时：\n   $$\\textit{dp}[i] = \\textit{nums}[i]$$\n\n以上的讨论是建立在 $i > 0$ 的情况，我们还需要考虑动态规划的边界条件，即 $i = 0$ 的情况：此时 $\\textit{nums}[0]$ 前面没有元素，本身可以构成一个长度为 $1$ 的子数组，即 $\\textit{dp}[0] = \\textit{nums}[0]$。\n\n又因为求解状态的过程只和前一个状态有关， 所以可以用「滚动数组」的方法来进行空间优化。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        ans = 0\n        i, n = 0, len(nums)\n        while i < n:\n            s = nums[i]\n            i += 1\n            while i < n and nums[i] > nums[i - 1]:\n                s += nums[i]\n                i += 1\n            ans = max(ans, s)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxAscendingSum(vector<int>& nums) {\n        int res = 0;\n        int l = 0;\n        while (l < nums.size()) {\n            int cursum = nums[l++];\n            while (l < nums.size() && nums[l] > nums[l - 1]) {\n                cursum += nums[l++];\n            }\n            res = max(res, cursum);\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maxAscendingSum(int[] nums) {\n        int res = 0;\n        int l = 0;\n        while (l < nums.length) {\n            int cursum = nums[l++];\n            while (l < nums.length && nums[l] > nums[l - 1]) {\n                cursum += nums[l++];\n            }\n            res = Math.max(res, cursum);\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MaxAscendingSum(int[] nums) {\n        int res = 0;\n        int l = 0;\n        while (l < nums.Length) {\n            int cursum = nums[l++];\n            while (l < nums.Length && nums[l] > nums[l - 1]) {\n                cursum += nums[l++];\n            }\n            res = Math.Max(res, cursum);\n        }\n        return res;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint maxAscendingSum(int* nums, int numsSize){\n    int res = 0;\n    int l = 0;\n    while (l < numsSize) {\n        int cursum = nums[l++];\n        while (l < numsSize && nums[l] > nums[l - 1]) {\n            cursum += nums[l++];\n        }\n        res = MAX(res, cursum);\n    }\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maxAscendingSum = function(nums) {\n    let res = 0;\n    let l = 0;\n    while (l < nums.length) {\n        let cursum = nums[l++];\n        while (l < nums.length && nums[l] > nums[l - 1]) {\n            cursum += nums[l++];\n        }\n        res = Math.max(res, cursum);\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc maxAscendingSum(nums []int) (ans int) {\n    for i, n := 0, len(nums); i < n; {\n        sum := nums[i]\n        for i++; i < n && nums[i] > nums[i-1]; i++ {\n            sum += nums[i]\n        }\n        if sum > ans {\n            ans = sum\n        }\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度。\n- 空间复杂度：$O(1)$，仅使用常量空间。"
}