{
	"titleSlug": "make-two-arrays-equal-by-reversing-subarrays",
	"slug": "tong-guo-fan-zhuan-zi-shu-zu-shi-liang-g-dueo",
	"url": "https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-subarrays/solution/tong-guo-fan-zhuan-zi-shu-zu-shi-liang-g-dueo/",
	"content": "#### 方法一：哈希表判断数组元素是否相同\n\n**思路**\n\n如果 $\\textit{arr}$ 长度是 $1$，那么只需判断 $\\textit{arr}$ 和 $\\textit{target}$ 是否相同即可。因为此时翻转非空子数组的过程并不会改变数组，只需判断原数组是否相同即可。\n\n如果 $\\textit{arr}$ 长度大于 $1$，那么首先证明通过一次或二次翻转过程，可以实现数组 $\\textit{arr}$ 中任意两个元素交换位置并且保持其他元素不动。如果想要交换两个相邻元素的位置，那么翻转这两个元素组成的子数组即可。如果想要交换两个非相邻元素的位置，那么首先翻转这两个元素及其中间所有元素组成的子数组，再翻转这两个元素中间的元素组成的子数组即可。这样下来，通过一次或二次翻转过程，即可交换数组中任意两个元素的位置。一旦一个数组中任意两个元素可以交换位置，那么这个数组就能实现任意重排。只需要 $\\textit{arr}$ 和 $\\textit{target}$ 元素相同，$\\textit{arr}$ 就能通过若干次操作变成 $\\textit{target}$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        return Counter(target) == Counter(arr)\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean canBeEqual(int[] target, int[] arr) {\n        Map<Integer, Integer> counts1 = new HashMap<Integer, Integer>();\n        Map<Integer, Integer> counts2 = new HashMap<Integer, Integer>();\n        for (int num : target) {\n            counts1.put(num, counts1.getOrDefault(num, 0) + 1);\n        }\n        for (int num : arr) {\n            counts2.put(num, counts2.getOrDefault(num, 0) + 1);\n        }\n        if (counts1.size() != counts2.size()) {\n            return false;\n        }\n        for (Map.Entry<Integer, Integer> entry : counts1.entrySet()) {\n            int key = entry.getKey(), value = entry.getValue();\n            if (!counts2.containsKey(key) || counts2.get(key) != value) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool CanBeEqual(int[] target, int[] arr) {\n        Dictionary<int, int> counts1 = new Dictionary<int, int>();\n        Dictionary<int, int> counts2 = new Dictionary<int, int>();\n        foreach (int num in target) {\n            if (!counts1.ContainsKey(num)) {\n                counts1.Add(num, 0);\n            }\n            counts1[num]++;\n        }\n        foreach (int num in arr) {\n            if (!counts2.ContainsKey(num)) {\n                counts2.Add(num, 0);\n            }\n            counts2[num]++;\n        }\n        if (counts1.Count != counts2.Count) {\n            return false;\n        }\n        foreach (KeyValuePair<int, int> pair in counts1) {\n            int key = pair.Key, value = pair.Value;\n            if (!counts2.ContainsKey(key) || counts2[key] != value) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool canBeEqual(vector<int>& target, vector<int>& arr) {\n        unordered_map<int, int> counts1, counts2;\n        for (int num : target) {\n            counts1[num]++;\n        }\n        for (int num : arr) {\n            counts2[num]++;\n        }\n        if (counts1.size() != counts2.size()) {\n            return false;\n        }\n        for (auto &[key, value] : counts1) {\n            if (!counts2.count(key) || counts2[key] != value) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} HashItem; \n\nHashItem *hashFindItem(HashItem **obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nbool hashAddItem(HashItem **obj, int key, int val) {\n    if (hashFindItem(obj, key)) {\n        return false;\n    }\n    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = key;\n    pEntry->val = val;\n    HASH_ADD_INT(*obj, key, pEntry);\n    return true;\n}\n\nbool hashSetItem(HashItem **obj, int key, int val) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        hashAddItem(obj, key, val);\n    } else {\n        pEntry->val = val;\n    }\n    return true;\n}\n\nint hashGetItem(HashItem **obj, int key, int defaultVal) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        return defaultVal;\n    }\n    return pEntry->val;\n}\n\nvoid hashFree(HashItem **obj) {\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);             \n    }\n}\n\nbool canBeEqual(int* target, int targetSize, int* arr, int arrSize){\n    HashItem *counts1 = NULL, *counts2 = NULL;\n    for (int i = 0; i < targetSize; i++) {\n        hashSetItem(&counts1, target[i], hashGetItem(&counts1, target[i], 0) + 1);\n    }\n    for (int i = 0; i < arrSize; i++) {\n        hashSetItem(&counts2, arr[i], hashGetItem(&counts2, arr[i], 0) + 1);\n    }\n    if (HASH_COUNT(counts1) != HASH_COUNT(counts2)) {\n        return false;\n    }\n    for (HashItem *pEntry = counts1; pEntry != NULL; pEntry = pEntry->hh.next) {\n        int key = pEntry->key, value = pEntry->val;\n        if (hashGetItem(&counts2, key, 0) != value) {\n            return false;\n        }\n    }\n    hashFree(&counts1);\n    hashFree(&counts2);\n    return true;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar canBeEqual = function(target, arr) {\n    const counts1 = new Map();\n    const counts2 = new Map();\n    for (const num of target) {\n        counts1.set(num, (counts1.get(num) || 0) + 1);\n    }\n    for (const num of arr) {\n        counts2.set(num, (counts2.get(num) || 0) + 1);   \n    }\n    if (counts1.size !== counts2.size) {\n        return false;\n    }\n    for (const [key, value] of counts1.entries()) {\n        if (!counts2.has(key) || counts2.get(key) !== value) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n\n```go [sol1-Golang]\nfunc canBeEqual(target, arr []int) bool {\n    cnt := map[int]int{}\n    for i, x := range target {\n        cnt[x]++\n        cnt[arr[i]]--\n    }\n    for _, c := range cnt {\n        if c != 0 {\n            return false\n        }\n    }\n    return true\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是输入数组的长度，统计并判断频次是否相同消耗 $O(n)$。\n\n- 空间复杂度：$O(n)$，哈希表最多消耗 $O(n)$ 空间。\n\n#### 方法二：排序判断数组元素是否相同\n\n**思路**\n\n与方法一类似，但是判断元素是否相同时，可以将两个数组分别排序，再判断排完序的数组是否相同即可。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        target.sort()\n        arr.sort()\n        return target == arr\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean canBeEqual(int[] target, int[] arr) {\n        Arrays.sort(target);\n        Arrays.sort(arr);\n        return Arrays.equals(target, arr);\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public bool CanBeEqual(int[] target, int[] arr) {\n        Array.Sort(target);\n        Array.Sort(arr);\n        return target.SequenceEqual(arr);\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool canBeEqual(vector<int>& target, vector<int>& arr) {\n        sort(target.begin(), target.end());\n        sort(arr.begin(), arr.end());\n        return target == arr;\n    }\n};\n```\n\n```C [sol2-C]\nstatic inline int cmp(const void* pa, const void* pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nbool canBeEqual(int* target, int targetSize, int* arr, int arrSize) {\n    qsort(target, targetSize, sizeof(int), cmp);\n    qsort(arr, arrSize, sizeof(int), cmp);\n    return memcmp(target, arr, sizeof(int) * arrSize) == 0;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar canBeEqual = function(target, arr) {\n    target.sort((a, b) => a - b);\n    arr.sort((a, b) => a - b);\n    return target.toString() === arr.toString();\n};\n```\n\n```go [sol2-Golang]\nfunc canBeEqual(target, arr []int) bool {\n    sort.Ints(target)\n    sort.Ints(arr)\n    for i, x := range target {\n        if x != arr[i] {\n            return false\n        }\n    }\n    return true\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times \\log n)$，其中 $n$ 是输入数组的长度。排序消耗 $O(n \\times \\log n)$ 复杂度，判断是否相同消耗 $O(n)$ 复杂度。\n\n- 空间复杂度：$O(\\log n)$，快速排序递归深度平均为 $O(\\log n)$。"
}