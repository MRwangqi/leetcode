{
	"titleSlug": "find-center-of-star-graph",
	"slug": "zhao-chu-xing-xing-tu-de-zhong-xin-jie-d-1xzm",
	"url": "https://leetcode-cn.com/problems/find-center-of-star-graph/solution/zhao-chu-xing-xing-tu-de-zhong-xin-jie-d-1xzm/",
	"content": "#### 方法一：计算每个节点的度\n\n由 $n$ 个节点组成的星型图中，有一个中心节点，有 $n - 1$ 条边分别连接中心节点和其余的每个节点。因此，中心节点的度是 $n - 1$，其余每个节点的度都是 $1$。一个节点的度的含义是与该节点相连的边数。\n\n遍历 $\\textit{edges}$ 中的每条边并计算每个节点的度，度为 $n - 1$ 的节点即为中心节点。\n\n```Python [sol1-Python3]\nclass Solution:\n    def findCenter(self, edges: List[List[int]]) -> int:\n        n = len(edges) + 1\n        degrees = [0] * (n + 1)\n        for x, y in edges:\n            degrees[x] += 1\n            degrees[y] += 1\n        for i, d in enumerate(degrees):\n            if d == n - 1:\n                return i\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findCenter(int[][] edges) {\n        int n = edges.length + 1;\n        int[] degrees = new int[n + 1];\n        for (int[] edge : edges) {\n            degrees[edge[0]]++;\n            degrees[edge[1]]++;\n        }\n        for (int i = 1; ; i++) {\n            if (degrees[i] == n - 1) {\n                return i;\n            }\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindCenter(int[][] edges) {\n        int n = edges.Length + 1;\n        int[] degrees = new int[n + 1];\n        foreach (int[] edge in edges) {\n            degrees[edge[0]]++;\n            degrees[edge[1]]++;\n        }\n        for (int i = 1; ; i++) {\n            if (degrees[i] == n - 1) {\n                return i;\n            }\n        }\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findCenter(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<int> degrees(n + 1);\n        for (auto & edge : edges) {\n            degrees[edge[0]]++;\n            degrees[edge[1]]++;\n        }\n        for (int i = 1; ; i++) {\n            if (degrees[i] == n - 1) {\n                return i;\n            }\n        }\n    }\n};\n```\n\n```C [sol1-C]\nint findCenter(int** edges, int edgesSize, int* edgesColSize){\n    int n = edgesSize + 1;\n    int * degrees = (int *)malloc(sizeof(int) * (n + 1));\n    memset(degrees,0,sizeof(int) * (n + 1));\n    for (int i = 0; i < edgesSize; i++) {\n        degrees[edges[i][0]]++;\n        degrees[edges[i][1]]++;\n    }\n    for (int i = 1; ; i++) {\n        if (degrees[i] == n - 1) {\n            free(degrees);\n            return i;\n        }\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findCenter = function(edges) {\n    const n = edges.length + 1;\n    const degrees = new Array(n + 1).fill(0);\n    for (const edge of edges) {\n        degrees[edge[0]]++;\n        degrees[edge[1]]++;\n    }\n    for (let i = 1; ; i++) {\n        if (degrees[i] === n - 1) {\n            return i;\n        }\n    }\n};\n```\n\n```go [sol1-Golang]\nfunc findCenter(edges [][]int) int {\n    n := len(edges) + 1\n    degrees := make([]int, n+1)\n    for _, e := range edges {\n        degrees[e[0]]++\n        degrees[e[1]]++\n    }\n    for i, d := range degrees {\n        if d == n-1 {\n            return i\n        }\n    }\n    return -1\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是星型图中的节点数量。需要遍历 $n - 1$ 条边计算每个节点的度，然后遍历 $n$ 个节点寻找中心节点。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是星型图中的节点数量。需要创建数组存储每个节点的度。\n\n#### 方法二：寻找出现在两条边中的节点\n\n由于只有星型图的中心节点的度是 $n - 1$，其余每个节点的度都是 $1$，因此只有星型图在所有的边中都出现，其余每个节点分别只在一条边中出现。\n\n根据星型图的上述性质可知，对于星型图中的任意两条边，星型图的中心节点一定同时在这两条边中出现，其余节点一定不会同时在这两条边中出现。因此，可以任选两条边，然后寻找这两条边的公共节点，该节点即为星型图的中心节点。\n\n具体做法是，选择 $\\textit{edges}[0]$ 和 $\\textit{edges}[1]$ 这两条边，则星型图的中心节点是 $\\textit{edges}[0][0]$ 或者 $\\textit{edges}[0][1]$。如果 $\\textit{edges}[0][0]$ 和 $\\textit{edges}[1]$ 的两个节点之一相同则 $\\textit{edges}[0][0]$ 是星型图的中心节点，如果 $\\textit{edges}[0][0]$ 和 $\\textit{edges}[1]$ 的两个节点都不相同则 $\\textit{edges}[0][1]$ 是星型图的中心节点。\n\n```Python [sol2-Python3]\nclass Solution:\n    def findCenter(self, edges: List[List[int]]) -> int:\n        return edges[0][0] if edges[0][0] == edges[1][0] or edges[0][0] == edges[1][1] else edges[0][1]\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int findCenter(int[][] edges) {\n        return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1] ? edges[0][0] : edges[0][1];\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int FindCenter(int[][] edges) {\n        return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1] ? edges[0][0] : edges[0][1];\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int findCenter(vector<vector<int>>& edges) {\n        return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1] ? edges[0][0] : edges[0][1];\n    }\n};\n```\n\n```C [sol2-C]\nint findCenter(int** edges, int edgesSize, int* edgesColSize){\n    return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1] ? edges[0][0] : edges[0][1];\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar findCenter = function(edges) {\n    return edges[0][0] === edges[1][0] || edges[0][0] === edges[1][1] ? edges[0][0] : edges[0][1];\n};\n```\n\n```go [sol2-Golang]\nfunc findCenter(edges [][]int) int {\n    if edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1] {\n        return edges[0][0]\n    }\n    return edges[0][1]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$。\n\n- 空间复杂度：$O(1)$。"
}