{
	"titleSlug": "longest-word-lcci",
	"slug": "a-fei-suan-fa-mian-shi-ti-1715-zui-chang-c3vr",
	"url": "https://leetcode-cn.com/problems/longest-word-lcci/solution/a-fei-suan-fa-mian-shi-ti-1715-zui-chang-c3vr/",
	"content": "> **欢迎阅读、点赞、转发、订阅，你的举手之间，我的动力源泉。**\r\n\r\n\r\n\r\n![flamingo-4945829_960_720.jpg](https://pic.leetcode-cn.com/1615799010-XXykji-flamingo-4945829_960_720.jpg)\r\n\r\n\r\n\r\n## [面试题 17.15. 最长单词](https://leetcode-cn.com/problems/longest-word-lcci/)\r\n\r\n```\r\n给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。\r\n\r\n示例：\r\n\r\n输入： [\"cat\",\"banana\",\"dog\",\"nana\",\"walk\",\"walker\",\"dogwalker\"]\r\n输出： \"dogwalker\"\r\n解释： \"dogwalker\"可由\"dog\"和\"walker\"组成。\r\n提示：\r\n\r\n0 <= len(words) <= 200\r\n1 <= len(words[i]) <= 100\r\n```\r\n\r\n### 方法1：回溯\r\n\r\n```java\r\npublic String longestWord(String[] words) {\r\n            String res = \"\";\r\n            List<String> wordList = Arrays.asList(words);\r\n            //按字符长度从大到小排列，相同长度的字符，按字典序正序排列，这样第一个返回的是满足题意要求的字符\r\n            wordList.sort((a, b) -> a.length() == b.length() ? a.compareTo(b) : b.length() - a.length());\r\n            for (String target : wordList) {\r\n                if (dfs(target, 0, wordList)) return target;\r\n            }\r\n            return res;\r\n\r\n        }\r\n\r\n        /**\r\n         * @param target   待处理的目标单词\r\n         * @param start    该目标单词目前处理到的的下标索引，初始化的时候是0，从该单词的第一个字符开始\r\n         * @param wordList 包含这个目标单词的所有单词的列表\r\n         * @return\r\n         */\r\n        private boolean dfs(String target, int start, List<String> wordList) {\r\n            if (start == target.length()) return true;//当下标到达字符的结尾时，说明这个是满足条件的\r\n            for (int end = start; end < target.length(); end++) {\r\n                //下面这一行是为了排除目标单词target本身，题意要求由其他的至少两个单词组成\r\n                //当遍历的时候只有一轮，一直没找到其他的目标单词，这个目标单词做为一个候选词，需要被排除掉\r\n                if (end - start + 1 == target.length()) continue;\r\n                String prev = target.substring(start, end + 1);//切出来[start,end]之间的字符作为一个候选单词进入下一轮递归\r\n                //这个切出来的单词是在单词列表&&剩下的单词也在单词列表（可能需要再切）\r\n                if (wordList.contains(prev) && dfs(target, end + 1, wordList)) return true;\r\n            }\r\n            return false;\r\n        }\r\n```\r\n\r\n### 方法2：回溯\r\n\r\n```java\r\npublic String longestWord(String[] words) {\r\n            String res = \"\";\r\n            if (words.length == 0) return res;\r\n            List<String> base = Arrays.asList(words);\r\n            for (String target : words) {\r\n                List<String> list = new ArrayList<>();\r\n                //复制一份单词列表，并且移除这个目标单词本身\r\n                Collections.addAll(list, new String[base.size()]);\r\n                Collections.copy(list, base);\r\n                list.remove(target);\r\n                if (check(target, list)) {\r\n                    //有更长的，选更长的\r\n                    if (target.length() > res.length()) res = target;\r\n                        //单词长度相等，选字典序小的\r\n                    else if (target.length() == res.length() && target.compareTo(res) < 0) {\r\n                        res = target;\r\n                    }\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n\r\n        /**\r\n         * @param target 目标单词\r\n         * @param list   单词列表(已经排除了目标单词本身)\r\n         * @return\r\n         */\r\n        public boolean check(String target, List<String> list) {\r\n            if (target.length() == 0) return true;//每次都剩下单词，是否完美切分出来\r\n            for (int i = 0; i <= target.length(); i++) {//注意 =号 可以取到末尾 substring 取头不取尾 ，取到len-1位置，取完整个字符\r\n//                System.out.printf(\"%s--->%s\\n\", target, target.substring(0, i));\r\n                //当前切出来的单词在单词列表中&&剩下的单词也能在单词列表中找到（可能需要再切分）\r\n                if (list.contains(target.substring(0, i)) && check(target.substring(i), list)) return true;\r\n            }\r\n            return false;\r\n        }\r\n```\r\n\r\n### 方法3：动态规划\r\n\r\n```java\r\npublic String longestWord(String[] words) {\r\n    String res = \"\";\r\n    List<String> wordList = Arrays.asList(words);\r\n    wordList.sort((a, b) -> a.length() == b.length() ? a.compareTo(b) : b.length() - a.length());\r\n    for (String target : wordList) {\r\n        if (check(target, wordList)) return target;\r\n    }\r\n    return res;\r\n}\r\n\r\nprivate boolean check(String target, List<String> wordList) {\r\n    int n = target.length();\r\n    if (n == 0) return false;\r\n    System.out.println(target);\r\n    boolean[] f = new boolean[n];\r\n    for (int i = 0; i < n; i++) {\r\n        //排除自生的结果，先切这部分\r\n        if (i < n - 1 && wordList.contains(target.substring(0, i + 1))) {\r\n            System.out.printf(\"1:%s\\n\", target.substring(0, i + 1));\r\n            f[i] = true;\r\n            continue;\r\n        }\r\n        for (int j = i - 1; j >= 0; j--) {\r\n            System.out.printf(\"2:%s\\n\", target.substring(j + 1, i + 1));\r\n            //如dogwalker时， f[2] = dog 为true  [j+1,i+1] = walk => f[6] = true 同理=> f[8] = true\r\n            if (f[j] && wordList.contains(target.substring(j + 1, i + 1))) {\r\n                f[i] = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n    }\r\n    return f[n - 1];\r\n}\r\n```\r\n\r\n### 方法4：字典树+回溯\r\n\r\n```java\r\nTrieNode root;\r\n\r\npublic String longestWord(String[] words) {\r\n    this.root = new TrieNode();\r\n    String res = \"\";\r\n    List<String> wordList = Arrays.asList(words);\r\n    //排序好，第一个返回的即是结果\r\n    wordList.sort((a, b) -> a.length() == b.length() ? a.compareTo(b) : b.length() - a.length());\r\n    //构造字典树\r\n    for (String word : wordList) insert(word);\r\n    for (String word : wordList) {\r\n        TrieNode cur = root;\r\n        int n = word.length();\r\n        for (int i = 0; i < n; i++) {\r\n            char c = word.charAt(i);\r\n            //排除掉自己组成自己，当前遍历到的字符是个单词，且剩余部分可以再次被切分\r\n            if (i < n - 1 && cur.children[c - 'a'].isEnd && canSplitToWord(word.substring(i + 1))) {\r\n                return word;\r\n            }\r\n            cur = cur.children[c - 'a'];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n/**\r\n * 当前的单词可以被切分，在wordList中找到\r\n *\r\n * @param remain\r\n * @return\r\n */\r\nprivate boolean canSplitToWord(String remain) {\r\n    //当没有可以切分的了 返回True\r\n    if (remain.equals(\"\")) return true;\r\n    TrieNode cur = root;\r\n    for (int i = 0; i < remain.length(); i++) {\r\n        char c = remain.charAt(i);//拿到当前的字符\r\n        if (cur.children[c - 'a'] == null) return false;//这个节点找不到\r\n        //当前的节点是个单词，且剩余部分可以再次被切分\r\n        if (cur.children[c - 'a'].isEnd && canSplitToWord(remain.substring(i + 1))) {\r\n            return true;\r\n        }\r\n        cur = cur.children[c - 'a'];\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Trie树插入一个单词\r\n *\r\n * @param word\r\n */\r\nprivate void insert(String word) {\r\n    TrieNode cur = root;\r\n    for (char c : word.toCharArray()) {\r\n        if (cur.children[c - 'a'] == null) {\r\n            cur.children[c - 'a'] = new TrieNode();\r\n        }\r\n        cur = cur.children[c - 'a'];\r\n    }\r\n    cur.isEnd = true;\r\n}\r\n\r\n/**\r\n * 构建字典树的结构\r\n */\r\nclass TrieNode {\r\n    private TrieNode[] children;\r\n    private boolean isEnd;//当前的字符是否是一个单词的结尾\r\n\r\n    public TrieNode() {\r\n        this.children = new TrieNode[26];\r\n        this.isEnd = false;\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 方法5：字典树+回溯（HashMap）\r\n\r\n```java\r\n TrieNode root;\r\n\r\n        public String longestWord(String[] words) {\r\n            this.root = new TrieNode();\r\n            List<String> wordList = Arrays.asList(words);\r\n            //排序好，第一个返回的即是结果\r\n            wordList.sort((a, b) -> a.length() == b.length() ? a.compareTo(b) : b.length() - a.length());\r\n            //构造字典树\r\n            for (String word : wordList) insert(word);\r\n            for (String word : wordList) {\r\n                TrieNode cur = root;\r\n                int n = word.length();\r\n                for (int i = 0; i < n; i++) {\r\n                    char c = word.charAt(i);\r\n                    //排除掉自己组成自己，当前遍历到的字符是个单词，且剩余部分可以再次被切分\r\n                    if (i < n - 1 && cur.next.get(c).isEnd && canSplitToWord(word.substring(i + 1))) {\r\n                        return word;\r\n                    }\r\n                    cur = cur.next.get(c);\r\n                }\r\n            }\r\n            return \"\";\r\n        }\r\n\r\n\r\n        /**\r\n         * 当前的单词可以被切分，在wordList中找到\r\n         *\r\n         * @param remain\r\n         * @return\r\n         */\r\n        private boolean canSplitToWord(String remain) {\r\n            //当没有可以切分的了 返回True\r\n            if (remain.equals(\"\")) return true;\r\n            TrieNode cur = root;\r\n            for (int i = 0; i < remain.length(); i++) {\r\n                char c = remain.charAt(i);//拿到当前的字符\r\n                if (!cur.next.containsKey(c)) return false;//这个节点找不到\r\n                //当前的节点是个单词，且剩余部分可以再次被切分\r\n                if (cur.next.get(c).isEnd && canSplitToWord(remain.substring(i + 1))) {\r\n                    return true;\r\n                }\r\n                cur = cur.next.get(c);\r\n            }\r\n            return false;\r\n        }\r\n\r\n\r\n        private void insert(String word) {\r\n            TrieNode cur = root;\r\n            for (char c : word.toCharArray()) {\r\n                if (!cur.next.containsKey(c)) {\r\n                    TrieNode t = new TrieNode();\r\n                    cur.next.put(c, t);\r\n                }\r\n                cur = cur.next.get(c);\r\n            }\r\n            cur.isEnd = true;\r\n        }\r\n\r\n\r\n        class TrieNode {\r\n            Map<Character, TrieNode> next = new HashMap<>();\r\n            boolean isEnd = false;\r\n        }\r\n```\r\n\r\n\r\n\r\n\r\n## **更多内容**\r\n- [[阿飞算法]程序员面试金典](https://blog.csdn.net/wat1r/category_11056661.html)\r\n\r\n\r\n## 番外：\r\n\r\n最近阿飞把链接做成了脑图（下图），整理起来，会做成PDF，感兴趣的同学关注下，不迷路，[个人主页【阿飞算法】](https://blog.csdn.net/wat1r/article/details/117533156) ，关注公众号会弹出资料下载地址，每个分支都可以点击链接跳转，欢迎入群交流学习。\r\n\r\n![阿飞算法.png](https://pic.leetcode-cn.com/1630892220-MyzuIE-%E9%98%BF%E9%A3%9E%E7%AE%97%E6%B3%95.png)"
}