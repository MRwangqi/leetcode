{
	"titleSlug": "minimum-white-tiles-after-covering-with-carpets",
	"slug": "by-endlesscheng-pa3v",
	"url": "https://leetcode-cn.com/problems/minimum-white-tiles-after-covering-with-carpets/solution/by-endlesscheng-pa3v/",
	"content": "#### 提示 1\r\n\r\n思考方向？\r\n\r\n看到题目给的数据范围，先想想能否用 DP 做出来。（DP 可以认为是一种更高级的暴力）\r\n\r\n#### 提示 2\r\n\r\n如何定义 DP 的状态？\r\n\r\n一般来说，题目给了什么就用什么定义：地板长度和地毯个数。而地毯长度更适合去划分状态。\r\n\r\n只用地板长度一个维度够吗？\r\n\r\n不够，状态定义没有体现出所使用的地毯的个数。因此需要两个维度。\r\n\r\n#### 提示 3\r\n\r\n状态的值及其转移如何设计？\r\n\r\n一般来说，题目求什么就定义什么：定义 $f[i][j]$ 表示用 $i$ 条地毯覆盖前 $j$ 块板砖时，没被覆盖的白色砖块的最少数目。\r\n\r\n转移时可以考虑**是否使用**第 $i$ 条地毯，且其**末尾**覆盖第 $j$ 块板砖：（为什么是末尾？因为 $f[i][j]$ 的定义是**前** $j$ 块板砖，覆盖 $j$ 后面的板砖完全是在浪费地毯长度）\r\n\r\n- 不使用：$f[i][j] = f[i][j-1] + [\\textit{floor}[j]=\\text{`1'}]$；\r\n- 使用：$f[i][j] = f[i-1][j-\\textit{carpetLen}]$。\r\n\r\n取二者最小值，即\r\n\r\n$$\r\nf[i][j] = \\min(f[i][j-1] + [\\textit{floor}[j]=\\text{`1'}],f[i-1][j-\\textit{carpetLen}])\r\n$$\r\n\r\n注意 $i=0$ 的时候只能不使用，需要单独计算。\r\n\r\n最后答案为 $f[\\textit{numCarpets}][\\textit{floor.length}-1]$。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def minimumWhiteTiles(self, floor: str, n: int, carpetLen: int) -> int:\r\n        m = len(floor)\r\n        if n * carpetLen >= m: return 0  # 剪枝\r\n        f = [[0] * m for _ in range(n + 1)]\r\n        f[0][0] = (floor[0] == '1')\r\n        for i in range(1, m):\r\n            f[0][i] = f[0][i - 1] + (floor[i] == '1')\r\n        for i in range(1, n + 1):\r\n            # j < carpetLen * i 的 f[i][j] 均为 0\r\n            for j in range(carpetLen * i, m):\r\n                f[i][j] = min(f[i][j - 1] + (floor[j] == '1'), f[i - 1][j - carpetLen])\r\n        return f[n][-1]\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int minimumWhiteTiles(String floor, int n, int carpetLen) {\r\n        var m = floor.length();\r\n        if (n * carpetLen >= m) return 0; // 剪枝\r\n        var f = new int[n + 1][m];\r\n        f[0][0] = floor.charAt(0) % 2;\r\n        for (var i = 1; i < m; ++i)\r\n            f[0][i] = f[0][i - 1] + floor.charAt(i) % 2;\r\n        for (var i = 1; i <= n; ++i)\r\n            // j < carpetLen * i 的 f[i][j] 均为 0\r\n            for (var j = carpetLen * i; j < m; ++j)\r\n                f[i][j] = Math.min(f[i][j - 1] + floor.charAt(j) % 2, f[i - 1][j - carpetLen]);\r\n        return f[n][m - 1];\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int minimumWhiteTiles(string &floor, int n, int carpetLen) { // 默认代码没加引用，这里补上\r\n        int m = floor.length();\r\n        if (n * carpetLen >= m) return 0; // 剪枝\r\n        vector<vector<int>> f(n + 1, vector<int>(m));\r\n        f[0][0] = (floor[0] == '1');\r\n        for (int i = 1; i < m; ++i)\r\n            f[0][i] = f[0][i - 1] + (floor[i] == '1');\r\n        for (int i = 1; i <= n; ++i)\r\n            // j < carpetLen * i 的 f[i][j] 均为 0\r\n            for (int j = carpetLen * i; j < m; ++j)\r\n                f[i][j] = min(f[i][j - 1] + (floor[j] == '1'), f[i - 1][j - carpetLen]);\r\n        return f[n][m - 1];\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc minimumWhiteTiles(floor string, n, carpetLen int) int {\r\n\tm := len(floor)\r\n\tif n*carpetLen >= m { // 剪枝\r\n\t\treturn 0\r\n\t}\r\n\tf := make([][]int, n+1)\r\n\tf[0] = make([]int, m)\r\n\tf[0][0] = int(floor[0] & 1)\r\n\tfor i := 1; i < m; i++ {\r\n\t\tf[0][i] = f[0][i-1] + int(floor[i]&1)\r\n\t}\r\n\tfor i := 1; i <= n; i++ {\r\n\t\tf[i] = make([]int, m)\r\n\t\t// j < carpetLen * i 的 f[i][j] 均为 0\r\n\t\tfor j := carpetLen * i; j < m; j++ {\r\n\t\t\tf[i][j] = min(f[i][j-1]+int(floor[j]&1), f[i-1][j-carpetLen])\r\n\t\t}\r\n\t}\r\n\treturn f[n][m-1]\r\n}\r\n\r\nfunc min(a, b int) int { if a > b { return b }; return a }\r\n```\r\n\r\n也可以用滚动数组压缩掉第一维：\r\n\r\n```py [sol2-Python3]\r\nclass Solution:\r\n    def minimumWhiteTiles(self, floor: str, n: int, carpetLen: int) -> int:\r\n        m = len(floor)\r\n        if n * carpetLen >= m: return 0  # 剪枝\r\n        pre, f = [0] * m, [0] * m\r\n        pre[0] = (floor[0] == '1')\r\n        for i in range(1, m):\r\n            pre[i] = pre[i - 1] + (floor[i] == '1')\r\n        for i in range(1, n + 1):\r\n            # j < carpetLen * i 的 f[i][j] 均为 0\r\n            f[carpetLen * i - 1] = 0\r\n            for j in range(carpetLen * i, m):\r\n                f[j] = min(f[j - 1] + (floor[j] == '1'), pre[j - carpetLen])\r\n            pre, f = f, pre\r\n        return pre[-1]\r\n```\r\n\r\n```java [sol2-Java]\r\nclass Solution {\r\n    public int minimumWhiteTiles(String floor, int n, int carpetLen) {\r\n        var m = floor.length();\r\n        if (n * carpetLen >= m) return 0; // 剪枝\r\n        var pre = new int[m];\r\n        var f = new int[m];\r\n        pre[0] = floor.charAt(0) % 2;\r\n        for (var i = 1; i < m; ++i)\r\n            pre[i] = pre[i - 1] + floor.charAt(i) % 2;\r\n        for (var i = 1; i <= n; ++i) {\r\n            // j < carpetLen * i 的 f[i][j] 均为 0\r\n            f[carpetLen * i - 1] = 0;\r\n            for (var j = carpetLen * i; j < m; ++j)\r\n                f[j] = Math.min(f[j - 1] + floor.charAt(j) % 2, pre[j - carpetLen]);\r\n            var tmp = f;\r\n            f = pre;\r\n            pre = tmp;\r\n        }\r\n        return pre[m - 1];\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol2-C++]\r\nclass Solution {\r\npublic:\r\n    int minimumWhiteTiles(string &floor, int n, int carpetLen) { // 默认代码没加引用，这里补上\r\n        int m = floor.length();\r\n        if (n * carpetLen >= m) return 0; // 剪枝\r\n        vector<int> pre(m), f(m);\r\n        pre[0] = (floor[0] == '1');\r\n        for (int i = 1; i < m; ++i)\r\n            pre[i] = pre[i - 1] + (floor[i] == '1');\r\n        for (int i = 1; i <= n; ++i) {\r\n            // j < carpetLen * i 的 f[i][j] 均为 0\r\n            f[carpetLen * i - 1] = 0;\r\n            for (int j = carpetLen * i; j < m; ++j)\r\n                f[j] = min(f[j - 1] + (floor[j] == '1'), pre[j - carpetLen]);\r\n            swap(pre, f);\r\n        }\r\n        return pre[m - 1];\r\n    }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\nfunc minimumWhiteTiles(floor string, n, carpetLen int) int {\r\n\tm := len(floor)\r\n\tif n*carpetLen >= m { // 剪枝\r\n\t\treturn 0\r\n\t}\r\n\tpre := make([]int, m)\r\n\tf := make([]int, m)\r\n\tpre[0] = int(floor[0] & 1)\r\n\tfor i := 1; i < m; i++ {\r\n\t\tpre[i] = pre[i-1] + int(floor[i]&1)\r\n\t}\r\n\tfor i := 1; i <= n; i++ {\r\n\t\t// j < carpetLen * i 的 f[i][j] 均为 0\r\n\t\tf[carpetLen*i-1] = 0\r\n\t\tfor j := carpetLen * i; j < m; j++ {\r\n\t\t\tf[j] = min(f[j-1]+int(floor[j]&1), pre[j-carpetLen])\r\n\t\t}\r\n\t\tpre, f = f, pre\r\n\t}\r\n\treturn pre[m-1]\r\n}\r\n\r\nfunc min(a, b int) int { if a > b { return b }; return a }\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(nm)$，这里 $m$ 是 $\\textit{floor}$ 的长度。\r\n- 空间复杂度：$O(m)$。\r\n\r\n#### 相似题目\r\n\r\n- [Codeforces 467C - George and Job](https://codeforces.com/problemset/problem/467/C)"
}