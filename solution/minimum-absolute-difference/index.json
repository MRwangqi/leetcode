{
	"titleSlug": "minimum-absolute-difference",
	"slug": "zui-xiao-jue-dui-chai-by-leetcode-soluti-7g0e",
	"url": "https://leetcode-cn.com/problems/minimum-absolute-difference/solution/zui-xiao-jue-dui-chai-by-leetcode-soluti-7g0e/",
	"content": "#### 方法一：排序 + 一次遍历\n\n**思路与算法**\n\n首先我们对数组 $\\textit{arr}$ 进行升序排序。这样一来，拥有「最小绝对差」的元素对只能由有序数组中相邻的两个元素构成。\n\n随后我们对数组 $\\textit{arr}$ 进行一次遍历。当遍历到 $\\textit{arr}[i]$ 和 $\\textit{arr}[i+1]$ 时，它们的差为 $\\delta = \\textit{arr}[i+1] - \\textit{arr}[i]$。我们使用一个变量 $\\textit{best}$ 存储当前遇到的最小差，以及一个数组 $\\textit{ans}$ 存储答案：\n\n- 如果 $\\delta < \\textit{best}$，那么说明我们遇到了更小的差值，需要更新 $\\textit{best}$，同时 $\\textit{ans}$ 清空并放入 $\\textit{arr}[i]$ 和 $\\textit{arr}[i+1]$；\n\n- 如果 $\\delta = \\textit{best}$，那么我们只需要将 $\\textit{arr}[i]$ 和 $\\textit{arr}[i+1]$ 放入答案数组即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {\n        int n = arr.size();\n        sort(arr.begin(), arr.end());\n\n        int best = INT_MAX;\n        vector<vector<int>> ans;\n        for (int i = 0; i < n - 1; ++i) {\n            if (int delta = arr[i + 1] - arr[i]; delta < best) {\n                best = delta;\n                ans = {{arr[i], arr[i + 1]}};\n            }\n            else if (delta == best) {\n                ans.emplace_back(initializer_list<int>{arr[i], arr[i + 1]});\n            }\n        }\n\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<List<Integer>> minimumAbsDifference(int[] arr) {\n        int n = arr.length;\n        Arrays.sort(arr);\n\n        int best = Integer.MAX_VALUE;\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n - 1; ++i) {\n            int delta = arr[i + 1] - arr[i];\n            if (delta < best) {\n                best = delta;\n                ans.clear();\n                List<Integer> pair = new ArrayList<Integer>();\n                pair.add(arr[i]);\n                pair.add(arr[i + 1]);\n                ans.add(pair);\n            } else if (delta == best) {\n                List<Integer> pair = new ArrayList<Integer>();\n                pair.add(arr[i]);\n                pair.add(arr[i + 1]);\n                ans.add(pair);\n            }\n        }\n\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<IList<int>> MinimumAbsDifference(int[] arr) {\n        int n = arr.Length;\n        Array.Sort(arr);\n\n        int best = int.MaxValue;\n        IList<IList<int>> ans = new List<IList<int>>();\n        for (int i = 0; i < n - 1; ++i) {\n            int delta = arr[i + 1] - arr[i];\n            if (delta < best) {\n                best = delta;\n                ans.Clear();\n                IList<int> pair = new List<int>();\n                pair.Add(arr[i]);\n                pair.Add(arr[i + 1]);\n                ans.Add(pair);\n            } else if (delta == best) {\n                IList<int> pair = new List<int>();\n                pair.Add(arr[i]);\n                pair.Add(arr[i + 1]);\n                ans.Add(pair);\n            }\n        }\n\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        n = len(arr)\n        arr.sort()\n\n        best, ans = float('inf'), list()\n        for i in range(n - 1):\n            if (delta := arr[i + 1] - arr[i]) < best:\n                best = delta\n                ans = [[arr[i], arr[i + 1]]]\n            elif delta == best:\n                ans.append([arr[i], arr[i + 1]])\n        \n        return ans\n```\n\n```C [sol1-C]\nstatic inline int cmp(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint** minimumAbsDifference(int* arr, int arrSize, int* returnSize, int** returnColumnSizes){\n    qsort(arr, arrSize, sizeof(int), cmp);\n    int best = INT_MAX;\n    int **ans = (int **)malloc(sizeof(int *) * (arrSize - 1));\n    int pos = 0;\n    for (int i = 0; i < arrSize - 1; ++i) {\n        int delta = arr[i + 1] - arr[i];\n        if (delta < best) {\n            best = delta;\n            for (int j = 0; j < pos; j++) {\n                free(ans[j]);\n            }\n            pos = 0;\n            ans[pos] = (int *)malloc(sizeof(int) * 2);\n            memcpy(ans[pos], arr + i, sizeof(int) * 2);\n            pos++;\n        }\n        else if (delta == best) {\n            ans[pos] = (int *)malloc(sizeof(int) * 2);\n            memcpy(ans[pos], arr + i, sizeof(int) * 2);\n            pos++;\n        }\n    }\n    *returnSize = pos;\n    *returnColumnSizes = (int *)malloc(sizeof(int) * pos);\n    for (int i = 0; i < pos; i++) {\n        (*returnColumnSizes)[i] = 2;\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minimumAbsDifference = function(arr) {\n    const n = arr.length;\n    arr.sort((a, b) => a - b);\n\n    let best = Number.MAX_VALUE;\n    let ans = [];\n    for (let i = 0; i < n - 1; ++i) {\n        let delta = arr[i + 1] - arr[i];\n        if (delta < best) {\n            best = delta;\n            ans = [];\n            const pair = [];\n            pair.push(arr[i]);\n            pair.push(arr[i + 1]);\n            ans.push(pair);\n        } else if (delta === best) {\n            const pair = [];\n            pair.push(arr[i]);\n            pair.push(arr[i + 1]);\n            ans.push(pair);\n        }\n    }\n\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc minimumAbsDifference(arr []int) (ans [][]int) {\n    sort.Ints(arr)\n    for i, best := 0, math.MaxInt32; i < len(arr)-1; i++ {\n        if delta := arr[i+1] - arr[i]; delta < best {\n            best = delta\n            ans = [][]int{{arr[i], arr[i+1]}}\n        } else if delta == best {\n            ans = append(ans, []int{arr[i], arr[i+1]})\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度。排序需要的时间为 $O(n \\log n)$，遍历需要的是时间为 $O(n)$，因此总时间复杂度为 $O(n \\log n)$。\n\n- 空间复杂度：$O(\\log n)$，即为排序需要使用的栈空间。这里不计入返回值需要使用的空间。"
}