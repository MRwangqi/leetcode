{
	"titleSlug": "maximum-number-of-achievable-transfer-requests",
	"slug": "zui-duo-ke-da-cheng-de-huan-lou-qing-qiu-ae0e",
	"url": "https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/solution/zui-duo-ke-da-cheng-de-huan-lou-qing-qiu-ae0e/",
	"content": "#### 方法一：回溯 + 枚举\n\n我们可以通过回溯的方式枚举每一个请求是否被选择。\n\n定义函数 $\\text{dfs}(\\textit{pos})$ 表示我们正在枚举第 $\\textit{pos}$ 个请求。同时，我们使用数组 $\\textit{delta}$ 记录每一栋楼的员工变化量，以及变量 $\\textit{cnt}$ 记录被选择的请求数量。\n\n对于第 $\\textit{pos}$ 个请求 $[x,y]$，如果选择该请求，那么就需要将 $\\textit{delta}[x]$ 的值减 $1$，$\\textit{delta}[y]$ 的值加 $1$，$\\textit{cnt}$ 的值加 $1$；如果不选择该请求，则不需要进行任何操作。在这之后，我们调用 $\\text{dfs}(\\textit{pos}+1)$ 枚举下一个请求。\n\n如果我们枚举完了全部请求，则需要判断是否满足要求，也就是判断 $\\textit{delta}$ 中的所有值是否均为 $0$。若满足要求，则更新答案的最大值。\n\n代码实现时，可以在修改 $\\textit{delta}$ 的同时维护 $\\textit{delta}$ 中的 $0$ 的个数，记作 $\\textit{zero}$，初始值为 $n$。如果 $\\textit{delta}[x]$ 增加或减少前为 $0$，则将 $\\textit{zero}$ 减 $1$；如果 $\\textit{delta}[x]$ 增加或减少后为 $0$，则将 $\\textit{zero}$ 加 $1$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\n        delta = [0] * n\n        ans, cnt, zero = 0, 0, n\n\n        def dfs(pos: int) -> None:\n            nonlocal ans, cnt, zero\n            if pos == len(requests):\n                if zero == n:\n                    ans = max(ans, cnt)\n                return\n\n            # 不选 requests[pos]\n            dfs(pos + 1)\n\n            # 选 requests[pos]\n            z = zero\n            cnt += 1\n            x, y = requests[pos]\n            zero -= delta[x] == 0\n            delta[x] -= 1\n            zero += delta[x] == 0\n            zero -= delta[y] == 0\n            delta[y] += 1\n            zero += delta[y] == 0\n            dfs(pos + 1)\n            delta[y] -= 1\n            delta[x] += 1\n            cnt -= 1\n            zero = z\n\n        dfs(0)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    vector<int> delta;\n    int ans = 0, cnt = 0, zero, n;\n\npublic:\n    void dfs(vector<vector<int>> &requests, int pos) {\n        if (pos == requests.size()) {\n            if (zero == n) {\n                ans = max(ans, cnt);\n            }\n            return;\n        }\n\n        // 不选 requests[pos]\n        dfs(requests, pos + 1);\n\n        // 选 requests[pos]\n        int z = zero;\n        ++cnt;\n        auto &r = requests[pos];\n        int x = r[0], y = r[1];\n        zero -= delta[x] == 0;\n        --delta[x];\n        zero += delta[x] == 0;\n        zero -= delta[y] == 0;\n        ++delta[y];\n        zero += delta[y] == 0;\n        dfs(requests, pos + 1);\n        --delta[y];\n        ++delta[x];\n        --cnt;\n        zero = z;\n    }\n\n    int maximumRequests(int n, vector<vector<int>> &requests) {\n        delta.resize(n);\n        zero = n;\n        this->n = n;\n        dfs(requests, 0);\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    int[] delta;\n    int ans = 0, cnt = 0, zero, n;\n\n    public int maximumRequests(int n, int[][] requests) {\n        delta = new int[n];\n        zero = n;\n        this.n = n;\n        dfs(requests, 0);\n        return ans;\n    }\n\n    public void dfs(int[][] requests, int pos) {\n        if (pos == requests.length) {\n            if (zero == n) {\n                ans = Math.max(ans, cnt);\n            }\n            return;\n        }\n\n        // 不选 requests[pos]\n        dfs(requests, pos + 1);\n\n        // 选 requests[pos]\n        int z = zero;\n        ++cnt;\n        int[] r = requests[pos];\n        int x = r[0], y = r[1];\n        zero -= delta[x] == 0 ? 1 : 0;\n        --delta[x];\n        zero += delta[x] == 0 ? 1 : 0;\n        zero -= delta[y] == 0 ? 1 : 0;\n        ++delta[y];\n        zero += delta[y] == 0 ? 1 : 0;\n        dfs(requests, pos + 1);\n        --delta[y];\n        ++delta[x];\n        --cnt;\n        zero = z;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    int[] delta;\n    int ans = 0, cnt = 0, zero, n;\n\n    public int MaximumRequests(int n, int[][] requests) {\n        delta = new int[n];\n        zero = n;\n        this.n = n;\n        DFS(requests, 0);\n        return ans;\n    }\n\n    public void DFS(int[][] requests, int pos) {\n        if (pos == requests.Length) {\n            if (zero == n) {\n                ans = Math.Max(ans, cnt);\n            }\n            return;\n        }\n\n        // 不选 requests[pos]\n        DFS(requests, pos + 1);\n\n        // 选 requests[pos]\n        int z = zero;\n        ++cnt;\n        int[] r = requests[pos];\n        int x = r[0], y = r[1];\n        zero -= delta[x] == 0 ? 1 : 0;\n        --delta[x];\n        zero += delta[x] == 0 ? 1 : 0;\n        zero -= delta[y] == 0 ? 1 : 0;\n        ++delta[y];\n        zero += delta[y] == 0 ? 1 : 0;\n        DFS(requests, pos + 1);\n        --delta[y];\n        ++delta[x];\n        --cnt;\n        zero = z;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc maximumRequests(n int, requests [][]int) (ans int) {\n\tdelta := make([]int, n)\n\tcnt, zero := 0, n\n\tvar dfs func(int)\n\tdfs = func(pos int) {\n\t\tif pos == len(requests) {\n\t\t\tif zero == n && cnt > ans {\n\t\t\t\tans = cnt\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// 不选 requests[pos]\n\t\tdfs(pos + 1)\n\n\t\t// 选 requests[pos]\n\t\tz := zero\n\t\tcnt++\n\t\tr := requests[pos]\n\t\tx, y := r[0], r[1]\n\t\tif delta[x] == 0 {\n\t\t\tzero--\n\t\t}\n\t\tdelta[x]--\n\t\tif delta[x] == 0 {\n\t\t\tzero++\n\t\t}\n\t\tif delta[y] == 0 {\n\t\t\tzero--\n\t\t}\n\t\tdelta[y]++\n\t\tif delta[y] == 0 {\n\t\t\tzero++\n\t\t}\n\t\tdfs(pos + 1)\n\t\tdelta[y]--\n\t\tdelta[x]++\n\t\tcnt--\n\t\tzero = z\n\t}\n\tdfs(0)\n\treturn\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nvoid dfs(const int** requests, int requestsSize,int n, int pos, int * delta, int * ans, int * cnt, int * zero) {\n    if (pos == requestsSize) {\n        if (*zero == n) {\n            *ans = MAX(*ans, *cnt);\n        }\n        return;\n    }\n\n    // 不选 requests[pos]\n    dfs(requests, requestsSize, n, pos + 1, delta, ans, cnt, zero);\n\n    // 选 requests[pos]\n    int z = *zero;\n    ++*cnt;\n    const int * r = requests[pos];\n    int x = r[0], y = r[1];\n    *zero -= delta[x] == 0;\n    --delta[x];\n    *zero += delta[x] == 0;\n    *zero -= delta[y] == 0;\n    ++delta[y];\n    *zero += delta[y] == 0;\n    dfs(requests, requestsSize, n, pos + 1, delta, ans, cnt, zero);\n    --delta[y];\n    ++delta[x];\n    --*cnt;\n    *zero = z;\n}\n\nint maximumRequests(int n, int** requests, int requestsSize, int* requestsColSize) {\n    int * delta = (int *)malloc(sizeof(int) * n);\n    memset(delta, 0, sizeof(int) * n);\n    int ans = 0, cnt = 0, zero = n;\n    dfs(requests, requestsSize, n, 0, delta, &ans, &cnt, &zero);\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maximumRequests = function(n, requests) {\n    const delta = new Array(n).fill(0);\n    let zero = n, ans = 0, cnt = 0;\n    const dfs = (requests, pos) => {\n        if (pos === requests.length) {\n            if (zero === n) {\n                ans = Math.max(ans, cnt);\n            }\n            return;\n        }\n\n        // 不选 requests[pos]\n        dfs(requests, pos + 1);\n\n        // 选 requests[pos]\n        let z = zero;\n        ++cnt;\n        const r = requests[pos];\n        let x = r[0], y = r[1];\n        zero -= delta[x] == 0 ? 1 : 0;\n        --delta[x];\n        zero += delta[x] == 0 ? 1 : 0;\n        zero -= delta[y] == 0 ? 1 : 0;\n        ++delta[y];\n        zero += delta[y] == 0 ? 1 : 0;\n        dfs(requests, pos + 1);\n        --delta[y];\n        ++delta[x];\n        --cnt;\n        zero = z;\n    }\n    dfs(requests, 0);\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(2^m)$，其中 $m$ 是数组 $\\textit{requests}$ 的长度，即请求的数量。从 $m$ 个请求中任意选择请求的方案数为 $2^m$，对于每一种方案，我们需要 $O(1)$ 的时间判断其是否满足要求。\n\n- 空间复杂度：$O(m+n)$。递归需要 $O(m)$ 的栈空间，数组 $\\textit{delta}$ 需要 $O(n)$ 的空间。\n\n#### 方法二：二进制枚举\n\n我们可以使用一个长度为 $m$ 的二进制数 $\\textit{mask}$ 表示所有的请求，其中 $\\textit{mask}$ 从低到高的第 $i$ 位为 $1$ 表示选择第 $i$ 个请求，为 $0$ 表示不选第 $i$ 个请求。我们可以枚举 $[0,2^m-1]$ 范围内的所有 $\\textit{mask}$，对于每个 $\\textit{mask}$，依次枚举其每一位，判断是否为 $1$，并使用与方法一相同的数组 $\\textit{delta}$ 以及变量 $\\textit{cnt}$ 进行统计，在满足要求时更新答案。\n\n```Python [sol2-Python3]\nclass Solution:\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\n        ans = 0\n        for mask in range(1 << len(requests)):\n            cnt = mask.bit_count()\n            if cnt <= ans:\n                continue\n            delta = [0] * n\n            for i, (x, y) in enumerate(requests):\n                if mask & (1 << i):\n                    delta[x] += 1\n                    delta[y] -= 1\n            if all(x == 0 for x in delta):\n                ans = cnt\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int maximumRequests(int n, vector<vector<int>> &requests) {\n        vector<int> delta(n);\n        int ans = 0, m = requests.size();\n        for (int mask = 0; mask < (1 << m); ++mask) {\n            int cnt = __builtin_popcount(mask);\n            if (cnt <= ans) {\n                continue;\n            }\n            fill(delta.begin(), delta.end(), 0);\n            for (int i = 0; i < m; ++i) {\n                if (mask & (1 << i)) {\n                    ++delta[requests[i][0]];\n                    --delta[requests[i][1]];\n                }\n            }\n            if (all_of(delta.begin(), delta.end(), [](int x) { return x == 0; })) {\n                ans = cnt;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int maximumRequests(int n, int[][] requests) {\n        int[] delta = new int[n];\n        int ans = 0, m = requests.length;\n        for (int mask = 0; mask < (1 << m); ++mask) {\n            int cnt = Integer.bitCount(mask);\n            if (cnt <= ans) {\n                continue;\n            }\n            Arrays.fill(delta, 0);\n            for (int i = 0; i < m; ++i) {\n                if ((mask & (1 << i)) != 0) {\n                    ++delta[requests[i][0]];\n                    --delta[requests[i][1]];\n                }\n            }\n            boolean flag = true;\n            for (int x : delta) {\n                if (x != 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                ans = cnt;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int MaximumRequests(int n, int[][] requests) {\n        int[] delta = new int[n];\n        int ans = 0, m = requests.Length;\n        for (int mask = 0; mask < (1 << m); ++mask) {\n            int cnt = BitCount(mask);\n            if (cnt <= ans) {\n                continue;\n            }\n            Array.Fill(delta, 0);\n            for (int i = 0; i < m; ++i) {\n                if ((mask & (1 << i)) != 0) {\n                    ++delta[requests[i][0]];\n                    --delta[requests[i][1]];\n                }\n            }\n            bool flag = true;\n            foreach (int x in delta) {\n                if (x != 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                ans = cnt;\n            }\n        }\n        return ans;\n    }\n\n    private static int BitCount(int i) {\n        i = i - ((i >> 1) & 0x55555555);\n        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n        i = (i + (i >> 4)) & 0x0f0f0f0f;\n        i = i + (i >> 8);\n        i = i + (i >> 16);\n        return i & 0x3f;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc maximumRequests(n int, requests [][]int) (ans int) {\nnext:\n    for mask := 0; mask < 1<<len(requests); mask++ {\n        cnt := bits.OnesCount(uint(mask))\n        if cnt <= ans {\n            continue\n        }\n        delta := make([]int, n)\n        for i, r := range requests {\n            if mask>>i&1 == 1 {\n                delta[r[0]]++\n                delta[r[1]]--\n            }\n        }\n        for _, d := range delta {\n            if d != 0 {\n                continue next\n            }\n        }\n        ans = cnt\n    }\n    return\n}\n```\n\n```C [sol2-C]\nint maximumRequests(int n, int** requests, int requestsSize, int* requestsColSize) {\n    int * delta = (int *)malloc(sizeof(int) * n);\n    int ans = 0, m = requestsSize;\n    for (int mask = 0; mask < (1 << m); ++mask) {\n        int cnt = __builtin_popcount(mask);\n        if (cnt <= ans) {\n            continue;\n        }\n        memset(delta, 0, sizeof(int) * n);\n        for (int i = 0; i < m; ++i) {\n            if (mask & (1 << i)) {\n                ++delta[requests[i][0]];\n                --delta[requests[i][1]];\n            }\n        }\n        bool flag = true;\n        for (int i = 0; i < n; i++) {\n            if (delta[i] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            ans = cnt;\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar maximumRequests = function(n, requests) {\n    const delta = new Array(n).fill(0);\n    let ans = 0, m = requests.length;\n    for (let mask = 0; mask < (1 << m); ++mask) {\n        let cnt = mask.toString(2).split('0').join('').length;\n        if (cnt <= ans) {\n            continue;\n        }\n        delta.fill(0);\n        for (let i = 0; i < m; ++i) {\n            if ((mask & (1 << i)) !== 0) {\n                ++delta[requests[i][0]];\n                --delta[requests[i][1]];\n            }\n        }\n        let flag = true;\n        for (const x of delta) {\n            if (x !== 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            ans = cnt;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(2^m \\times n)$，其中 $m$ 是数组 $\\textit{requests}$ 的长度，即请求的数量。从 $m$ 个请求中任意选择请求的方案数为 $2^m$，对于每一种方案，我们需要 $O(n)$ 的时间判断其是否满足要求。\n\n- 空间复杂度：$O(n)$。数组 $\\textit{delta}$ 需要 $O(n)$ 的空间。"
}