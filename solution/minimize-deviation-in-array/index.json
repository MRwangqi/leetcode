{
	"titleSlug": "minimize-deviation-in-array",
	"slug": "er-xu-cheng-ming-jiu-xu-zui-python3tan-x-g1xl",
	"url": "https://leetcode-cn.com/problems/minimize-deviation-in-array/solution/er-xu-cheng-ming-jiu-xu-zui-python3tan-x-g1xl/",
	"content": "## 【儿须成名酒须醉】Python3+贪心+堆（优先队列）\n***\n### 提交结果\n- 执行用时： 1052 ms , 在所有 Python3 提交中击败了 90.97% 的用户\n- 内存消耗： 21.9 MB , 在所有 Python3 提交中击败了 54.86% 的用户\n- 通过测试用例： 75 / 75\n\n### 解题思路\n\n1. 对于偶数来说可以一直除以2，因此可先将奇数*2，统一成偶数问题\n2. 使用优先队列，不断取出最大的数，假如是偶数则除以2后再加入队列\n3. 假如时奇数，则差距没办法再缩小\n\n### 性能优化\n\n- 无\n\n### 复杂度分析\n设数组长度为$n$，则有\n- 时间复杂度$O(nlogn)$\n- 空间复杂度$O(n)$\n\n### 代码\n\n```python3\nimport heapq\n\n\nclass Solution:\n    def minimumDeviation(self, nums: List[int]) -> int:\n        stack = []\n        \n        # 维护最大值与最小值\n        high = 0\n        low = 10**9 + 7\n        for num in nums:\n            \n            # 偶数不变，奇数*2\n            if num % 2:\n                stack.append(-num * 2)\n            else:\n                stack.append(-num)\n                \n            # 计算当前的最大值与最小值\n            low = low if low < -stack[-1] else -stack[-1]\n            high = high if high > -stack[-1] else -stack[-1]\n        ans = high - low\n        heapq.heapify(stack)\n        \n        # 将最大的偶数依次出栈//2\n        while True:\n            cur = -heapq.heappop(stack)\n            ans = ans if ans < cur - low else cur - low\n            \n            # 最大值为奇数时不能再缩小此时差距最少\n            if cur % 2:\n                return ans\n            \n            cur //= 2\n            low = low if low < cur else cur\n            heapq.heappush(stack, -cur)\n```"
}