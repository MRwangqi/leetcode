{
	"titleSlug": "design-circular-queue",
	"slug": "she-ji-xun-huan-dui-lie-by-leetcode-solu-1w0a",
	"url": "https://leetcode-cn.com/problems/design-circular-queue/solution/she-ji-xun-huan-dui-lie-by-leetcode-solu-1w0a/",
	"content": "#### 方法一：数组\n\n关于循环队列的概念可以参考：「[循环队列](https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/3685773?fr=aladdin)」，我们可以通过一个数组进行模拟，通过操作数组的索引构建一个虚拟的首尾相连的环。在循环队列结构中，设置一个队尾 $\\textit{rear}$ 与队首 $\\textit{front}$，且大小固定，结构如下图所示:\n![1](https://assets.leetcode-cn.com/solution-static/622/622_1.png)\n在循环队列中，当队列为空，可知 $\\textit{front}=\\textit{rear}$；而当所有队列空间全占满时，也有 $\\textit{front}=\\textit{rear}$。为了区别这两种情况，假设队列使用的数组有 $\\textit{capacity}$ 个存储空间，则此时规定循环队列最多只能有$\\textit{capacity} - 1$ 个队列元素，当循环队列中只剩下一个空存储单元时，则表示队列已满。根据以上可知，队列判空的条件是 $\\textit{front}=\\textit{rear}$，而队列判满的条件是 $\\textit{front} = (\\textit{rear} + 1) \\bmod \\textit{capacity}$。 \n对于一个固定大小的数组，只要知道队尾 $\\textit{rear}$ 与队首 $\\textit{front}$，即可计算出队列当前的长度：\n$$\n(\\textit{rear} - \\textit{front} + \\textit{capacity}) \\bmod \\textit{capacity}\n$$\n\n循环队列的属性如下:\n+ $\\textit{elements}$：一个固定大小的数组，用于保存循环队列的元素。\n+ $\\textit{capacity}$：循环队列的容量，即队列中最多可以容纳的元素数量。\n+ $\\textit{front}$：队列首元素对应的数组的索引。\n+ $\\textit{rear}$：队列尾元素对应的索引的下一个索引。\n\n循环队列的接口方法如下：\n+ $\\texttt{MyCircularQueue(int k)}$: 初始化队列，同时$\\textit{base}$ 数组的空间初始化大小为 $k + 1$。$\\textit{front}, \\textit{rear}$ 全部初始化为 $0$。\n+ $\\texttt{enQueue(int value)}$：在队列的尾部插入一个元素，并同时将队尾的索引 $\\textit{rear}$ 更新为 $(\\textit{rear} + 1) \\bmod capacity$。\n+ $\\texttt{deQueue()}$：从队首取出一个元素，并同时将队首的索引 $\\textit{front}$ 更新为 $(\\textit{front} + 1) \\bmod capacity$。\n+ $\\texttt{Front()}$：返回队首的元素，需要检测队列是否为空。\n+ $\\texttt{Rear()}$：返回队尾的元素，需要检测队列是否为空。\n+ $\\texttt{isEmpty()}$：检测队列是否为空，根据之前的定义只需判断 $\\textit{rear}$ 是否等于 $\\textit{front}$。\n+ $\\texttt{isFull()}$：检测队列是否已满，根据之前的定义只需判断 $\\textit{front}$ 是否等于 $(\\textit{rear} + 1) \\bmod \\textit{capacity}$。\n\n```Python [sol1-Python3]\nclass MyCircularQueue:\n    def __init__(self, k: int):\n        self.front = self.rear = 0\n        self.elements = [0] * (k + 1)\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.elements[self.rear] = value\n        self.rear = (self.rear + 1) % len(self.elements)\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.front = (self.front + 1) % len(self.elements)\n        return True\n\n    def Front(self) -> int:\n        return -1 if self.isEmpty() else self.elements[self.front]\n\n    def Rear(self) -> int:\n        return -1 if self.isEmpty() else self.elements[(self.rear - 1) % len(self.elements)]\n\n    def isEmpty(self) -> bool:\n        return self.rear == self.front\n\n    def isFull(self) -> bool:\n        return (self.rear + 1) % len(self.elements) == self.front\n```\n\n```C++ [sol1-C++]\nclass MyCircularQueue {\nprivate:\n    int front;\n    int rear;\n    int capacity;\n    vector<int> elements;\n\npublic:\n    MyCircularQueue(int k) {\n        this->capacity = k + 1;\n        this->elements = vector<int>(capacity);\n        rear = front = 0;\n    }\n\n    bool enQueue(int value) {\n        if (isFull()) {\n            return false;\n        }\n        elements[rear] = value;\n        rear = (rear + 1) % capacity;\n        return true;\n    }\n\n    bool deQueue() {\n        if (isEmpty()) {\n            return false;\n        }\n        front = (front + 1) % capacity;\n        return true;\n    }\n\n    int Front() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return elements[front];\n    }\n\n    int Rear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return elements[(rear - 1 + capacity) % capacity];\n    }\n\n    bool isEmpty() {\n        return rear == front;\n    }\n\n    bool isFull() {\n        return ((rear + 1) % capacity) == front;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass MyCircularQueue {\n    private int front;\n    private int rear;\n    private int capacity;\n    private int[] elements;\n\n    public MyCircularQueue(int k) {\n        capacity = k + 1;\n        elements = new int[capacity];\n        rear = front = 0;\n    }\n\n    public boolean enQueue(int value) {\n        if (isFull()) {\n            return false;\n        }\n        elements[rear] = value;\n        rear = (rear + 1) % capacity;\n        return true;\n    }\n\n    public boolean deQueue() {\n        if (isEmpty()) {\n            return false;\n        }\n        front = (front + 1) % capacity;\n        return true;\n    }\n\n    public int Front() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return elements[front];\n    }\n\n    public int Rear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return elements[(rear - 1 + capacity) % capacity];\n    }\n\n    public boolean isEmpty() {\n        return rear == front;\n    }\n\n    public boolean isFull() {\n        return ((rear + 1) % capacity) == front;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class MyCircularQueue {\n    private int front;\n    private int rear;\n    private int capacity;\n    private int[] elements;\n\n    public MyCircularQueue(int k) {\n        capacity = k + 1;\n        elements = new int[capacity];\n        rear = front = 0;\n    }\n\n    public bool EnQueue(int value) {\n        if (IsFull()) {\n            return false;\n        }\n        elements[rear] = value;\n        rear = (rear + 1) % capacity;\n        return true;\n    }\n\n    public bool DeQueue() {\n        if (IsEmpty()) {\n            return false;\n        }\n        front = (front + 1) % capacity;\n        return true;\n    }\n\n    public int Front() {\n        if (IsEmpty()) {\n            return -1;\n        }\n        return elements[front];\n    }\n\n    public int Rear() {\n        if (IsEmpty()) {\n            return -1;\n        }\n        return elements[(rear - 1 + capacity) % capacity];\n    }\n\n    public bool IsEmpty() {\n        return rear == front;\n    }\n\n    public bool IsFull() {\n        return ((rear + 1) % capacity) == front;\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int front;\n    int rear;\n    int capacity;\n    int *elements;\n} MyCircularQueue;\n\nMyCircularQueue* myCircularQueueCreate(int k) {\n    MyCircularQueue *obj = (MyCircularQueue *)malloc(sizeof(MyCircularQueue));\n    obj->capacity = k + 1;\n    obj->rear = obj->front = 0;\n    obj->elements = (int *)malloc(sizeof(int) * obj->capacity);\n    return obj;\n}\n\nbool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {\n    if ((obj->rear + 1) % obj->capacity == obj->front) {\n        return false;\n    }\n    obj->elements[obj->rear] = value;\n    obj->rear = (obj->rear + 1) % obj->capacity;\n    return true;\n}\n\nbool myCircularQueueDeQueue(MyCircularQueue* obj) {\n    if (obj->rear == obj->front) {\n        return false;\n    }\n    obj->front = (obj->front + 1) % obj->capacity;\n    return true;\n}\n\nint myCircularQueueFront(MyCircularQueue* obj) {\n    if (obj->rear == obj->front) {\n        return -1;\n    }\n    return obj->elements[obj->front];\n}\n\nint myCircularQueueRear(MyCircularQueue* obj) {\n    if (obj->rear == obj->front) {\n        return -1;\n    }\n    return obj->elements[(obj->rear - 1 + obj->capacity) % obj->capacity];\n}\n\nbool myCircularQueueIsEmpty(MyCircularQueue* obj) {\n    return obj->rear == obj->front;\n}\n\nbool myCircularQueueIsFull(MyCircularQueue* obj) {\n    return (obj->rear + 1) % obj->capacity == obj->front;\n}\n\nvoid myCircularQueueFree(MyCircularQueue* obj) {\n    free(obj->elements);\n    free(obj);\n}\n```\n\n```go [sol1-Golang]\ntype MyCircularQueue struct {\n    front, rear int\n    elements    []int\n}\n\nfunc Constructor(k int) MyCircularQueue {\n    return MyCircularQueue{elements: make([]int, k+1)}\n}\n\nfunc (q *MyCircularQueue) EnQueue(value int) bool {\n    if q.IsFull() {\n        return false\n    }\n    q.elements[q.rear] = value\n    q.rear = (q.rear + 1) % len(q.elements)\n    return true\n}\n\nfunc (q *MyCircularQueue) DeQueue() bool {\n    if q.IsEmpty() {\n        return false\n    }\n    q.front = (q.front + 1) % len(q.elements)\n    return true\n}\n\nfunc (q MyCircularQueue) Front() int {\n    if q.IsEmpty() {\n        return -1\n    }\n    return q.elements[q.front]\n}\n\nfunc (q MyCircularQueue) Rear() int {\n    if q.IsEmpty() {\n        return -1\n    }\n    return q.elements[(q.rear-1+len(q.elements))%len(q.elements)]\n}\n\nfunc (q MyCircularQueue) IsEmpty() bool {\n    return q.rear == q.front\n}\n\nfunc (q MyCircularQueue) IsFull() bool {\n    return (q.rear+1)%len(q.elements) == q.front\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar MyCircularQueue = function(k) {\n    this.capacity = k + 1;\n    this.elements = new Array(this.capacity).fill(0);\n    this.rear = 0;\n    this.front = 0;\n};\n\nMyCircularQueue.prototype.enQueue = function(value) {\n    if (this.isFull()) {\n        return false;\n    }\n    this.elements[this.rear] = value;\n    this.rear = (this.rear + 1) % this.capacity;\n    return true;\n};\n\nMyCircularQueue.prototype.deQueue = function() {\n    if (this.isEmpty()) {\n        return false;\n    }\n    this.front = (this.front + 1) % this.capacity;\n    return true;\n};\n\nMyCircularQueue.prototype.Front = function() {\n    if (this.isEmpty()) {\n        return -1;\n    }\n    return this.elements[this.front];\n};\n\nMyCircularQueue.prototype.Rear = function() {\n    if (this.isEmpty()) {\n        return -1;\n    }\n    return this.elements[(this.rear - 1 + this.capacity) % this.capacity];\n};\n\nMyCircularQueue.prototype.isEmpty = function() {\n    return this.rear == this.front;\n};\n\nMyCircularQueue.prototype.isFull = function() {\n    return ((this.rear + 1) % this.capacity) === this.front;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化和每项操作的时间复杂度均为 $O(1)$。\n\n- 空间复杂度：$O(k)$，其中 $k$ 为给定的队列元素数目。\n\n#### 方法二：链表\n\n我们同样可以用链表实现队列，用链表实现队列则较为简单，因为链表可以在 $O(1)$ 时间复杂度完成插入与删除。入队列时，将新的元素插入到链表的尾部；出队列时，将链表的头节点返回，并将头节点指向下一个节点。\n\n循环队列的属性如下:\n+ $\\textit{head}$：链表的头节点，队列的头节点。\n+ $\\textit{tail}$：链表的尾节点，队列的尾节点。\n+ $\\textit{capacity}$：队列的容量，即队列可以存储的最大元素数量。\n+ $\\textit{size}$：队列当前的元素的数量。\n\n```Python [sol2-Python3]\nclass MyCircularQueue:\n    def __init__(self, k: int):\n        self.head = self.tail = None\n        self.capacity = k\n        self.size = 0\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        node = ListNode(value)\n        if self.head is None:\n            self.head = node\n            self.tail = node\n        else:\n            self.tail.next = node\n            self.tail = node\n        self.size += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.head = self.head.next\n        self.size -= 1\n        return True\n\n    def Front(self) -> int:\n        return -1 if self.isEmpty() else self.head.val\n\n    def Rear(self) -> int:\n        return -1 if self.isEmpty() else self.tail.val\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n    def isFull(self) -> bool:\n        return self.size == self.capacity\n```\n\n```C++ [sol2-C++]\nclass MyCircularQueue {\nprivate:\n    ListNode *head;\n    ListNode *tail;\n    int capacity;\n    int size;\n\npublic:\n    MyCircularQueue(int k) {\n        this->capacity = k;\n        this->size = 0;\n        this->head = this->tail = nullptr;\n    }\n\n    bool enQueue(int value) {\n        if (isFull()) {\n            return false;\n        }\n        ListNode *node = new ListNode(value);\n        if (!head) {\n            head = tail = node;\n        } else {\n            tail->next = node;\n            tail = node;\n        }\n        size++;\n        return true;\n    }\n\n    bool deQueue() {\n        if (isEmpty()) {\n            return false;\n        }\n        ListNode *node = head;\n        head = head->next;  \n        size--;\n        delete node;\n        return true;\n    }\n\n    int Front() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return head->val;\n    }\n\n    int Rear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return tail->val;\n    }\n\n    bool isEmpty() {\n        return size == 0;\n    }\n\n    bool isFull() {\n        return size == capacity;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass MyCircularQueue {\n    private ListNode head;\n    private ListNode tail;\n    private int capacity;\n    private int size;\n\n    public MyCircularQueue(int k) {\n        capacity = k;\n        size = 0;\n    }\n\n    public boolean enQueue(int value) {\n        if (isFull()) {\n            return false;\n        }\n        ListNode node = new ListNode(value);\n        if (head == null) {\n            head = tail = node;\n        } else {\n            tail.next = node;\n            tail = node;\n        }\n        size++;\n        return true;\n    }\n\n    public boolean deQueue() {\n        if (isEmpty()) {\n            return false;\n        }\n        ListNode node = head;\n        head = head.next;  \n        size--;\n        return true;\n    }\n\n    public int Front() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return head.val;\n    }\n\n    public int Rear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return tail.val;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class MyCircularQueue {\n    private ListNode head;\n    private ListNode tail;\n    private int capacity;\n    private int size;\n\n    public MyCircularQueue(int k) {\n        capacity = k;\n        size = 0;\n    }\n\n    public bool EnQueue(int value) {\n        if (IsFull()) {\n            return false;\n        }\n        ListNode node = new ListNode(value);\n        if (head == null) {\n            head = tail = node;\n        } else {\n            tail.next = node;\n            tail = node;\n        }\n        size++;\n        return true;\n    }\n\n    public bool DeQueue() {\n        if (IsEmpty()) {\n            return false;\n        }\n        ListNode node = head;\n        head = head.next;  \n        size--;\n        return true;\n    }\n\n    public int Front() {\n        if (IsEmpty()) {\n            return -1;\n        }\n        return head.val;\n    }\n\n    public int Rear() {\n        if (IsEmpty()) {\n            return -1;\n        }\n        return tail.val;\n    }\n\n    public bool IsEmpty() {\n        return size == 0;\n    }\n\n    public bool IsFull() {\n        return size == capacity;\n    }\n}\n```\n\n```C [sol2-C]\ntypedef struct {\n    struct ListNode *head;\n    struct ListNode *tail;\n    int capacity;\n    int size;\n} MyCircularQueue;\n\n\nMyCircularQueue* myCircularQueueCreate(int k) {\n    MyCircularQueue *obj = (MyCircularQueue *)malloc(sizeof(MyCircularQueue));\n    obj->capacity = k;\n    obj->size = 0;\n    obj->head = obj->tail = NULL;\n    return obj;\n}\n\nbool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {\n    if (obj->size >= obj->capacity) {\n        return false;\n    }\n    struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));\n    node->val = value;\n    node->next = NULL;\n    if (!obj->head) {\n        obj->head = obj->tail = node;\n    } else {\n        obj->tail->next = node;\n        obj->tail = node;\n    }\n    obj->size++;\n    return true;\n}\n\nbool myCircularQueueDeQueue(MyCircularQueue* obj) {\n    if (obj->size == 0) {\n        return false;\n    }\n    struct ListNode *node = obj->head;\n    obj->head = obj->head->next;  \n    obj->size--;\n    free(node);\n    return true;\n}\n\nint myCircularQueueFront(MyCircularQueue* obj) {\n    if (obj->size == 0) {\n        return -1;\n    }\n    return obj->head->val;\n}\n\nint myCircularQueueRear(MyCircularQueue* obj) {\n    if (obj->size == 0) {\n        return -1;\n    }\n    return obj->tail->val;\n}\n\nbool myCircularQueueIsEmpty(MyCircularQueue* obj) {\n    return obj->size == 0;\n}\n\nbool myCircularQueueIsFull(MyCircularQueue* obj) {\n    return obj->size == obj->capacity;\n}\n\nvoid myCircularQueueFree(MyCircularQueue* obj) {\n    for (struct ListNode *curr = obj->head; curr;) {\n        struct ListNode *node = curr;\n        curr = curr->next;\n        free(node);\n    }\n    free(obj);\n}\n```\n\n```go [sol2-Golang]\ntype MyCircularQueue struct {\n    head, tail     *ListNode\n    capacity, size int\n}\n\nfunc Constructor(k int) MyCircularQueue {\n    return MyCircularQueue{capacity: k}\n}\n\nfunc (q *MyCircularQueue) EnQueue(value int) bool {\n    if q.IsFull() {\n        return false\n    }\n    node := &ListNode{Val: value}\n    if q.head == nil {\n        q.head = node\n        q.tail = node\n    } else {\n        q.tail.Next = node\n        q.tail = node\n    }\n    q.size++\n    return true\n}\n\nfunc (q *MyCircularQueue) DeQueue() bool {\n    if q.IsEmpty() {\n        return false\n    }\n    q.head = q.head.Next\n    q.size--\n    return true\n}\n\nfunc (q MyCircularQueue) Front() int {\n    if q.IsEmpty() {\n        return -1\n    }\n    return q.head.Val\n}\n\nfunc (q MyCircularQueue) Rear() int {\n    if q.IsEmpty() {\n        return -1\n    }\n    return q.tail.Val\n}\n\nfunc (q MyCircularQueue) IsEmpty() bool {\n    return q.size == 0\n}\n\nfunc (q MyCircularQueue) IsFull() bool {\n    return q.size == q.capacity\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化和每项操作的时间复杂度均为 $O(1)$。\n\n- 空间复杂度：$O(k)$，其中 $k$ 为给定的队列元素数目。"
}