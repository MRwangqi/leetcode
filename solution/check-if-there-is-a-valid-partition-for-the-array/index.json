{
	"titleSlug": "check-if-there-is-a-valid-partition-for-the-array",
	"slug": "by-endlesscheng-8y73",
	"url": "https://leetcode-cn.com/problems/check-if-there-is-a-valid-partition-for-the-array/solution/by-endlesscheng-8y73/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1CN4y1V7uE) 已出炉，欢迎点赞三连，在评论区分享你对这场周赛的看法~\r\n \r\n---  \r\n\r\n看到**划分**，想一想是否有子问题，引出 DP 的思路（回顾一下经典题 [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)）。\r\n\r\n定义 $f[i+1]$ 表示从 $\\textit{nums}[0]$ 到 $\\textit{nums}[i]$ 的这些元素能否有效划分。那么 $f[0] = \\texttt{true}$，答案为 $f[n]$。\r\n\r\n根据题意，有\r\n\r\n$$\r\nf[i+1] = \\text{OR}\r\n\\begin{cases} \r\nf[i-1]\\ \\text{AND}\\ \\textit{nums}[i] = \\textit{nums}[i-1],&i>0\\\\\r\nf[i-2]\\ \\text{AND}\\ \\textit{nums}[i] = \\textit{nums}[i-1] = \\textit{nums}[i-2],&i>1\\\\\r\nf[i-2]\\ \\text{AND}\\ \\textit{nums}[i] = \\textit{nums}[i-1]+1 = \\textit{nums}[i-2]+2,&i>1\r\n\\end{cases}\r\n$$\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{nums}$ 的长度。\r\n- 空间复杂度：$O(n)$。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def validPartition(self, nums: List[int]) -> bool:\r\n        n = len(nums)\r\n        f = [True] + [False] * n\r\n        for i, x in enumerate(nums):\r\n            if i > 0 and f[i - 1] and x == nums[i - 1] or \\\r\n               i > 1 and f[i - 2] and (x == nums[i - 1] == nums[i - 2] or\r\n                                       x == nums[i - 1] + 1 == nums[i - 2] + 2):\r\n               f[i + 1] = True\r\n        return f[n]\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public boolean validPartition(int[] nums) {\r\n        var n = nums.length;\r\n        var f = new boolean[n + 1];\r\n        f[0] = true;\r\n        for (var i = 1; i < n; ++i)\r\n            if (f[i - 1] && nums[i] == nums[i - 1] ||\r\n                i > 1 && f[i - 2] && (nums[i] == nums[i - 1] && nums[i] == nums[i - 2] ||\r\n                                      nums[i] == nums[i - 1] + 1 && nums[i] == nums[i - 2] + 2))\r\n                f[i + 1] = true;\r\n        return f[n];\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    bool validPartition(vector<int> &nums) {\r\n        int n = nums.size();\r\n        bool f[n + 1]; memset(f, 0, sizeof(f));\r\n        f[0] = true;\r\n        for (int i = 1; i < n; ++i)\r\n            if (f[i - 1] && nums[i] == nums[i - 1] ||\r\n                i > 1 && f[i - 2] && (nums[i] == nums[i - 1] && nums[i] == nums[i - 2] ||\r\n                                      nums[i] == nums[i - 1] + 1 && nums[i] == nums[i - 2] + 2))\r\n                f[i + 1] = true;\r\n        return f[n];\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc validPartition(nums []int) bool {\r\n\tn := len(nums)\r\n\tf := make([]bool, n+1)\r\n\tf[0] = true\r\n\tfor i, x := range nums {\r\n\t\tif i > 0 && f[i-1] && x == nums[i-1] ||\r\n\t\t\ti > 1 && f[i-2] && (x == nums[i-1] && x == nums[i-2] ||\r\n\t\t\t\t                x == nums[i-1]+1 && x == nums[i-2]+2) {\r\n\t\t\tf[i+1] = true\r\n\t\t}\r\n\t}\r\n\treturn f[n]\r\n}\r\n```\r\n\r\n#### 思考题\r\n\r\n如何求出所有有效划分的方案数？\r\n"
}