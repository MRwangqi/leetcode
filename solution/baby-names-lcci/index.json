{
	"titleSlug": "baby-names-lcci",
	"slug": "-by-jin-xi-he-xi-h-nv8l",
	"url": "https://leetcode-cn.com/problems/baby-names-lcci/solution/-by-jin-xi-he-xi-h-nv8l/",
	"content": "### 解题思路\n使用传统的数组index的方式实现并查集，感觉不太好写，因此在实现方面使用了哈希表string到string方式来替代数组方式：\n**unordered_map<string, string>parent：哈希表的key代表当前名字，value代表父节点的名字**\n例如：我们在遍历synonyms，第一个字符串为\"(Jon,John)\"，我们要先判断哪个字符串字典序更小，更小的作为父节点（题中要求），在这里John更小，因此parent[Jon]=John。同理其他字符串。\n\n当我们完成上述步骤之后，就会得到并查集，然后遍历字符串数组names来得到个数，最后统计到结果字符串数组中即可。\n![1659511720217.png](https://pic.leetcode-cn.com/1659511763-LbuQQt-1659511720217.png)\n\n\n### 代码\n\n```cpp\nclass Solution {\nprivate:\n\tunordered_map<string, string>parent;\n\t//查找父节点\n\tstring find(string& name) {\n\t\tif (parent.count(name) == 0)//如果parent中没有这个键值对，我们要添加进去。这步也就相当于初始化操作，将自己设置为自己的父节点\n\t\t\treturn parent[name] = name;\n\n\t\tif (parent[name] != name) {\n\t\t\tparent[name] = find(parent[name]);\n\t\t}\n\t\treturn parent[name];\n\t}\n\t//合并两个节点\n\tvoid merge(string& name1, string& name2) {\n\t\tstring rootname1 = find(name1), rootname2 = find(name2);\n\t\tif (rootname1 < rootname2)parent[rootname2] = rootname1;\n\t\telse parent[rootname1] = parent[rootname2];\n\t}\n\npublic:\n\tvector<string> trulyMostPopular(vector<string>& names, vector<string>& synonyms) {\n\t\tfor (auto& x : synonyms) {\n\t\t\tint len = x.find(',');\n\t\t\tstring one = x.substr(1, len - 1);\n\t\t\tstring two = x.substr(len + 1, x.size() - 2 - len);\n\t\t\tmerge(one, two);\n\t\t}\n\n\t\tunordered_map<string, int>nameNum;//存储的是名字的个数，key是名字，value是个数\n\t\tfor (auto& name : names) {\n\t\t\tint pos1 = name.find('('), pos2 = name.find(')');\n\t\t\tstring curName = string(name.begin(), name.begin() + pos1);\n\t\t\tint curNum = stoi(string(name.begin() + pos1 + 1, name.begin() + pos2));\n\t\t\tnameNum[find(curName)] += curNum;//查找每一个名字的根节点，然后把当前名字的数量加到根节点上去\n\t\t}\n\n\t\tvector<string>ans;\n\t\tfor (auto& n : nameNum) {\n\t\t\tstring s = n.first + '(' + to_string(n.second) + ')';\n\t\t\tans.push_back(s);\n\t\t}\n\t\treturn ans;\n\t}\n};\n```"
}