{
	"titleSlug": "sum-of-prefix-scores-of-strings",
	"slug": "by-lfool-w82u",
	"url": "https://leetcode-cn.com/problems/sum-of-prefix-scores-of-strings/solution/by-lfool-w82u/",
	"content": "# [如果想要查看作者更多文章，可以点击此处！！！🔥🔥🔥](https://lfool.github.io/LFool-Notes/)\n\n# [为了本篇文章更好的观感，可以点击此处！！！](https://lfool.github.io/LFool-Notes/algorithm/详解前缀树TrieTree.html)\n\n[208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)\n\n[648. 单词替换](https://leetcode.cn/problems/replace-words/)\n\n[211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)\n\n[677. 键值映射](https://leetcode.cn/problems/map-sum-pairs/)\n\n[676. 实现一个魔法字典](https://leetcode.cn/problems/implement-magic-dictionary/)\n\n[745. 前缀和后缀搜索](https://leetcode.cn/problems/prefix-and-suffix-search/)\n\n[6183. 字符串的前缀分数和](https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/)\n\n---\n\n***如果只想看本题的解法，可直接跳到文章末尾，有详细分析过程！！🔥🔥🔥***\n\n---\n\n「前缀树」又叫「字典树」或「单词查找树」，总之它们是一个意思！\n\n「前缀树」的应用场景：给定一个字符串集合构建一棵前缀树，然后给一个字符串，判断前缀树中是否存在该字符串或者该字符串的前缀\n\n可以结合题目 **[单词替换](https://leetcode.cn/problems/replace-words/)** 理解！我们需要根据 `dictionary` 构建前缀树，然后判断 `sentence` 中的每个单词是否在前缀树中\n\n## 分析\n\n一般而言，字符串的集合都是仅由小写字母构成，所以本文章都是基于该情况展开分析！\n\n字符串集合：`[them, zip, team, the, app, that]`。这个样例的前缀树长什么样呢？\n\n![1.svg](https://pic.leetcode-cn.com/1657540498-HHnzlV-1.svg)\n\n由于都是小写字母，所以对于每个节点，均有 26 个孩子节点，上图中没有画出来，省略了而已...，但是要记住：**每个节点均有 26 个孩子节点**\n\n**还有一个点要明确：节点仅仅表示从根节点到本节点的路径构成的字符串是否有效而已**\n\n对于上图中橙色的节点，均为有效节点，即：从根节点到橙色节点的路径构成的字符串均在集合中\n\n如果现在要找前缀 `te` 是否存在，分两步：\n\n- 首先看看表示 `te` 字符串的路径是否存在，这个例子是存在的\n- 其次看看该路径的终点处的节点是否有效，很遗憾，此处为白色，无效\n- 所以前缀 `te` 不存在！！\n\n## 数据结构\n\n现在看看如何表示这棵「前缀树」，即数据结构该如何定义。其实就是一棵多叉树，有 26 个孩子节点的多叉树而已！！\n\n现在来思考节点的值又该如何表示呢？\n\n在上面的例子中，节点仅仅表示路径构成的字符串是否有效而已，所以节点可以用 `boolean` 类型来表示\n\n还有一类情况就是每个字符串都有一个权值，所以节点的值可以用一个数值来表示\n\n```java\n// 前缀树的数据结构\nclass TrieNode {\n    boolean val;\n    TrieNode[] children = new TrieNode[26];\n}\n// 前缀树的根节点\nprivate TrieNode root = new TrieNode();\n```\n\n## 常用操作\n\n根据上面的分析，其实「前缀树」常用操作就三种\n\n- 根据所给字符串集合构建前缀树\n- 判断前缀树中是否存在目标字符串\n- 在前缀树中找出目标字符串的最短前缀\n\n### 构建前缀树\n\n最初，我们只有一个根节点 `root`，孩子节点也都还没初始化！\n\n所以直接看代码：\n\n```java\n// 往前缀树中插入一个新的字符串\npublic void insert(String word) {\n    TrieNode p = root;\n    for (char c : word.toCharArray()) {\n        // char -> int\n        int i = c - 'a';\n        // 初始化孩子节点\n        if (p.children[i] == null) p.children[i] = new TrieNode();\n        // 节点下移\n        p = p.children[i];\n    }\n    // 此时 p 指向目标字符串的终点\n    p.val = true;\n}\n```\n\n为了扩展思维，这里再给出递归的实现方法：(和树的遍历很像)\n\n```java\npublic TrieNode insert(TrieNode node, String word, int index) {\n    // 初始化\n    if (node == null) node = new TrieNode();\n    // 到了终点\n    if (index == word.length()) {\n        node.val = true;\n        return node;\n    }\n    int i = word.charAt(index) - 'a';\n    node.children[i] = insert(node.children[i], word, index + 1);\n    return node;\n}\n// 调用方法\nroot = insert(root, word, 0);\n```\n\n### 寻找目标字符串\n\n当「前缀树」构建好了后，寻找目标字符串也就大同小异了\n\n复习一下寻找的两个步骤：\n\n- 首先看看表示字符串的路径是否存在\n- 其次看看该路径的终点处的节点是否有效\n\n```java\npublic boolean query(String word) {\n    TrieNode p = root;\n    for (char c : word.toCharArray()) {\n        int i = c - 'a';\n        // 路径不存在的情况，直接返回 false\n        if (p.children[i] == null) return false;\n        p = p.children[i];\n    }\n    // 路径存在，直接返回该路径的终点处的节点的有效性\n    return p.val;\n}\n```\n\n同样的，为了扩展思维，这里再给出递归的实现方法：(和树的遍历很像)\n\n```java\npublic boolean query(TrieNode node, String word, int index) {\n    // 路径不存在的情况\n    if (node == null) return false;\n    // 路径存在，直接返回该路径的终点处的节点的有效性\n    if (index == word.length()) return node.val;\n    \n    int i = word.charAt(index) - 'a';\n    return query(node.children[i], word, index + 1);\n}\n// 调用方法\nquery(root, word, 0);\n```\n\n### 寻找最短前缀\n\n和「寻找目标字符串」差不多，但又有些许不同\n\n- 「寻找目标字符串」必须遍历到目标字符串的末尾，然后再判断路径是否有效\n\n- 「寻找最短前缀」只要在遍历的过程有中，首次出现了有效路径，即为找到！！\n\n```java\npublic String shortestPrefixOf(String word) {\n    TrieNode p = root;\n    StringBuffer sb = new StringBuffer();\n    for (char c : word.toCharArray()) {\n        int i = c - 'a';\n        // 首次遇到有效路径，直接返回\n        if (p.val) return sb.toString();\n        sb.append(c);\n        // 路径不存在的情况，直接返回 \"\"\n        if (p.children[i] == null) return \"\";\n        p = p.children[i];\n    }\n    // 没找到\n    return \"\";\n}\n```\n\n## 高级操作\n\n### 含有通配符的寻找\n\n顾名思义，`.`可以表示任何字符。比如：`a.c` 是可以和 `[abc, aec]` 匹配的\n\n```java\npublic boolean keysWithPattern(TrieNode node, String pattern, int index) {\n    if (node == null) return false;\n    if (index == key.length()) return node.val;\n    int i = key.charAt(index) - 'a';\n    // 如果是通配符，直接和 26 个字母匹配 (简单粗暴！！)\n    if (key.charAt(index) == '.') {\n        for (int j = 0; j < 26; j++) {\n            if (search(node.children[j], key, index + 1)) return true;\n        }\n        return false;\n    } else {\n        return search(node.children[i], key, index + 1);\n    }\n}\n```\n\n## 题目实战\n\n### 实现 Trie (前缀树)\n\n**题目详情可见 [实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)**\n\n```java\nclass Trie {\n    class TrieNode {\n        boolean val;\n        TrieNode[] children = new TrieNode[26];\n    }\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n    \n    public void insert(String word) {\n        TrieNode p = root;\n        for (char c : word.toCharArray()) {\n            int i = c - 'a';\n            if (p.children[i] == null) p.children[i] = new TrieNode();\n            p = p.children[i];\n        }\n        p.val = true;\n    }\n    \n    public boolean search(String word) {\n        TrieNode p = root;\n        for (char c : word.toCharArray()) {\n            int i = c - 'a';\n            if (p.children[i] == null) return false;\n            p = p.children[i];\n        }\n        return p.val;\n    }\n    \n    public boolean startsWith(String prefix) {\n        TrieNode p = root;\n        for (char c : prefix.toCharArray()) {\n            int i = c - 'a';\n            if (p.children[i] == null) return false;\n            p = p.children[i];\n        }\n        return true;\n    }\n}\n```\n\n### 单词替换\n\n**题目详情可见 [单词替换](https://leetcode.cn/problems/replace-words/)**\n\n```java\nclass Solution {\n    class TrieNode {\n        boolean val;\n        TrieNode[] children = new TrieNode[26];\n    }\n    \n    private TrieNode root = new TrieNode();\n    \n    public String replaceWords(List<String> dictionary, String sentence) {\n        for (String d : dictionary) root = insert(root, d, 0);\n        StringBuffer ans = new StringBuffer();\n        for (String s : sentence.split(\" \")) {\n            String q = query(s);\n            if (\"\".equals(q)) ans.append(s).append(\" \");\n            else ans.append(q).append(\" \");\n        }\n        ans.deleteCharAt(ans.length() - 1);\n        return ans.toString();\n    }\n    \n    private TrieNode insert(TrieNode node, String key, int index) {\n        if (node == null) node = new TrieNode();\n        if (index == key.length()) {\n            node.val = true;\n            return node;\n        }\n        int i = key.charAt(index) - 'a';\n        node.children[i] = insert(node.children[i], key, index + 1);\n        return node;\n    }\n    \n    private String query(String key) {\n        TrieNode p = root;\n        StringBuffer ans = new StringBuffer();\n        for (char c : key.toCharArray()) {\n            int i = c - 'a';\n            if (p.val) return ans.toString();\n            ans.append(c);\n            if (p.children[i] == null) return \"\";\n            p = p.children[i];\n        }\n        return \"\";\n    }\n}\n```\n\n### 添加与搜索单词 - 数据结构设计\n\n**题目详情可见 [添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)**\n\n```java\nclass WordDictionary {\n\n    class TrieNode {\n        boolean val;\n        TrieNode[] children = new TrieNode[26];\n    }\n\n    private TrieNode root;\n\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode p = root;\n        for (char c : word.toCharArray()) {\n            int i = c - 'a';\n            if (p.children[i] == null) p.children[i] = new TrieNode();\n            p = p.children[i];\n        }\n        p.val = true;\n    }\n    \n    public boolean search(String word) {\n        return search(root, word, 0);\n    }\n\n    private boolean search(TrieNode node, String key, int index) {\n        if (node == null) return false;\n        if (index == key.length()) return node.val;\n        int i = key.charAt(index) - 'a';\n        if (key.charAt(index) == '.') {\n            for (int j = 0; j < 26; j++) {\n                if (search(node.children[j], key, index + 1)) return true;\n            }\n            return false;\n        } else {\n            return search(node.children[i], key, index + 1);\n        }\n    }\n}\n```\n\n### 键值映射\n\n**题目详情可见 [键值映射](https://leetcode.cn/problems/map-sum-pairs/)**\n\n这个题目些许不同，每个节点表示的不再是是否有效，而是一个值\n\n```java\nclass MapSum {\n\n    class TrieNode {\n        int val;\n        TrieNode[] children = new TrieNode[26];\n    }\n\n    private TrieNode root;\n\n    public MapSum() {\n        root = new TrieNode();\n    }\n    \n    public void insert(String key, int val) {\n        TrieNode p = root;\n        for (char c : key.toCharArray()) {\n            int i = c - 'a';\n            if (p.children[i] == null) p.children[i] = new TrieNode();\n            p = p.children[i];\n        }\n        p.val = val;\n    }\n    \n    public int sum(String prefix) {\n        TrieNode p = root;\n        // 找到前缀 prefix 的最后一个节点\n        for (char c : prefix.toCharArray()) {\n            int i = c - 'a';\n            if (p.children[i] == null) return 0;\n            p = p.children[i];\n        }\n        return getAllSum(p);\n    }\n    // 辅助函数，求以 node 为根节点的子树的节点和 \n    private int getAllSum(TrieNode node) {\n        if (node == null) return 0;\n        int sum = 0;\n        for (int i = 0; i < 26; i++) {\n            sum += getAllSum(node.children[i]);\n        }\n        return sum + node.val;\n    }\n}\n```\n\n### 实现一个魔法字典\n\n**题目详情可见 [实现一个魔法字典](https://leetcode.cn/problems/implement-magic-dictionary/)**\n\n由于本题目必须替换一次，所以采取了一个傻办法：遍历每一种替换的情况\n\n```java\nclass MagicDictionary {\n\n    class TrieNode {\n        boolean val;\n        TrieNode[] children = new TrieNode[26];\n    }\n\n    private TrieNode root;\n\n    public MagicDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void buildDict(String[] dictionary) {\n        for (String word : dictionary) {\n            TrieNode p = root;\n            for (char c : word.toCharArray()) {\n                int i = c - 'a';\n                if (p.children[i] == null) p.children[i] = new TrieNode();\n                p = p.children[i];\n            }\n            p.val = true;\n        }\n    }\n    \n    public boolean search(String searchWord) {\n        // 遍历每一种替换的情况\n        for (int i = 0; i < searchWord.length(); i++) {\n            if (search(root, searchWord, 0, i)) return true;\n        }\n        return false;\n    }\n\n    private boolean search(TrieNode node, String searchWord, int index, int changeId) {\n        if (node == null) return false;\n        if (index == searchWord.length()) return node.val;\n        int i = searchWord.charAt(index) - 'a';\n        if (index == changeId) {\n            for (int j = 0; j < 26; j++) {\n                if (j == i) continue;\n                if (search(node.children[j], searchWord, index + 1, changeId)) return true;\n            }\n            return false;\n        }\n        return search(node.children[i], searchWord, index + 1, changeId);\n    }\n}\n```\n\n### 前缀和后缀搜索\n\n**题目详情可见 [前缀和后缀搜索](https://leetcode.cn/problems/prefix-and-suffix-search/)**\n\n前面的题目，节点表示的要么是有效性，要么是字符串的权值，而这个题目需要从前缀和后缀同时搜索 🔍\n\n我们的可以采取的思路：同时维护两棵树 -> 「前缀树」和「后缀树」，树的每个节点表示以「从根节点到该节点路径构成的字符串」为前缀的单词的下标\n\n表述的可能比较抽象，直接看图：(我们还是以 `[them, zip, team, the, app, that]` 这个样例为基础)\n\n![4.svg](https://pic.leetcode-cn.com/1657779076-lKPawY-4.svg)\n\n当我们需要寻找以 `t` 为前缀，以 `m` 为后缀的下标最大的字符串\n\n显然我们可以很容易找到图中绿色的两个节点，对应的下标 `List` 为 `[0, 2, 3, 5]` 和 `[0, 2]`\n\n**解释**：以 `t` 为前缀的单词有 `[them, team, the, that]`，其对应的下标为 `[0, 2, 3, 5]`\n\n**同理**：以 `m` 为后缀的单词有 `[them, team]`，其对应的下标为 `[0, 2]`\n\n然后根据有序链表合并的思路，从后往前找到第一个相同的下标，即为最大下标！！\n\n```java\nclass WordFilter {\n\n    class TrieNode {\n        List<Integer> list = new ArrayList<>();\n        TrieNode[] children = new TrieNode[26];\n    }\n\n    private TrieNode prefix = new TrieNode();\n    private TrieNode suffix = new TrieNode();\n\n    public WordFilter(String[] words) {\n        build(prefix, words, true);\n        build(suffix, words, false);\n    }\n    \n    public int f(String pref, String suff) {\n        List<Integer> prefList = query(prefix, pref, true);\n        List<Integer> suffList = query(suffix, suff, false);\n        int i = prefList.size() - 1, j = suffList.size() - 1;\n        while (i >= 0 && j >= 0) {\n            // 注意：比较 Integer 类变量最好不要直接比较，自动拆箱成 int 后再比较\n            int l1 = prefList.get(i), l2 = suffList.get(j);\n            if (l1 == l2) return l1;\n            else if (l1 > l2) i--;\n            else j--;\n        }\n        return -1;\n    }\n\n    private void build(TrieNode root, String[] words, boolean isPref) {\n        for (int i = 0; i < words.length; i++) {\n            TrieNode p = root;\n            int len = words[i].length();\n            for (int j = isPref ? 0 : len - 1; j >= 0 && j < len; j = isPref ? j + 1 : j - 1) {\n                int cur = words[i].charAt(j) - 'a';\n                if (p.children[cur] == null) p.children[cur] = new TrieNode();\n                p = p.children[cur];\n                p.list.add(i);\n            }\n        }\n    }\n\n    private List<Integer> query(TrieNode root, String s, boolean isPref) {\n        TrieNode p = root;\n        int len = s.length();\n        for (int i = isPref ? 0 : len - 1; i >= 0 && i < len; i = isPref ? i + 1 : i - 1) {\n            int cur = s.charAt(i) - 'a';\n            if (p.children[cur] == null) return new ArrayList<>();\n            p = p.children[cur];\n        }\n        return p.list;\n    }\n}\n```\n\n### 字符串的前缀分数和\n\n**题目详情可见 [前缀和后缀搜索](https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/)**\n\n这个题也是「前缀树」的模版题，只不过每个节点的含义需要重新定义一下：**表示以该路径为前缀的单词数量**\n\n可能表述的有些抽象，以 `[\"abc\",\"ab\",\"bc\",\"b\"]` 为例，直接看图：\n\n![432.svg](https://pic.leetcode-cn.com/1663472794-nWROae-432.svg)\n\n构建好了前缀树，如果我们需要查询某个单词的前缀分数和，如 `\"abc\"`，只需要路径 `abc` 的节点累加即可，2 + 2 + 1 = 5\n\n下面给出代码：\n\n```java\npublic int[] sumPrefixScores(String[] words) {\n    for (String word : words) {\n        // 插入所有节点\n        insert(word);\n    }\n    int[] ans = new int[words.length];\n    for (int i = 0; i < words.length; i++) {\n        // 查询所有节点\n        ans[i] = query(words[i]);\n    }\n    return ans;\n}\n\n// ********** 以下是模版 **********\n\n// 前缀树的数据结构\nclass TrieNode {\n    int val;\n    TrieNode[] children = new TrieNode[26];\n}\n// 前缀树的根节点\nprivate TrieNode root = new TrieNode();\n\n// 往前缀树中插入一个新的字符串\npublic void insert(String word) {\n    TrieNode p = root;\n    for (char c : word.toCharArray()) {\n        int i = c - 'a';\n        // 初始化孩子节点\n        if (p.children[i] == null) p.children[i] = new TrieNode();\n        \n        // 注意：途经的节点均需要 ➕1\n        p.children[i].val += 1;\n        \n        // 节点下移\n        p = p.children[i];\n    }\n}\npublic int query(String word) {\n    TrieNode p = root;\n    int cnt = 0;\n    for (char c : word.toCharArray()) {\n        int i = c - 'a';\n        if (p.children[i] == null) return cnt;\n        p = p.children[i];\n        // 累加节点和\n        cnt += p.val;\n    }\n    return cnt;\n}\n```"
}