{
	"titleSlug": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
	"slug": "longest-continuous-subarray-by-ikaruga",
	"url": "https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/longest-continuous-subarray-by-ikaruga/",
	"content": "### 解题思路\r\n1. 使用滑动窗口保持符合条件的子数组，记录最长长度\r\n2. 怎样确定子数组是否符合条件，需要知道两个关键数据\r\n    21. 子数组中的最大值\r\n    22. 子数组中的最小值\r\n3. 需要对滑入窗口的数据记录，滑出的数据删除，并且使这些记录方便的算出最大值和最小值\r\n    31. 使用 `map` / `multiset` 可以在滑入滑出的时候方便的增减对应数据\r\n    32. 同时 `map` / `multiset` 本身是有序的，可以方便的找出最大值最小值\r\n\r\n### 图解\r\n<![image.png](https://pic.leetcode-cn.com/1613918957-gNuCDj-image.png),![image.png](https://pic.leetcode-cn.com/1613919014-djJGuI-image.png),![image.png](https://pic.leetcode-cn.com/1613919026-zcLpdc-image.png),![image.png](https://pic.leetcode-cn.com/1613919166-PNSwSt-image.png),![image.png](https://pic.leetcode-cn.com/1613919182-AGZFUq-image.png),![image.png](https://pic.leetcode-cn.com/1613919204-wZdWna-image.png),![image.png](https://pic.leetcode-cn.com/1613919214-Lbrajn-image.png),![image.png](https://pic.leetcode-cn.com/1613919225-wQXavt-image.png),![image.png](https://pic.leetcode-cn.com/1613919237-HApXJa-image.png)>\r\n\r\n\r\n### 答题\r\n```C++ []\r\n    int longestSubarray(vector<int>& nums, int limit) {\r\n        map<int, int> m;\r\n        int ans = 0;\r\n        int i = 0;\r\n        for (int j = 0; j < nums.size(); j++) {\r\n            m[nums[j]]++;\r\n            while (m.rbegin()->first - m.begin()->first > limit) {\r\n                m[nums[i]]--;\r\n                if (m[nums[i]] == 0) {\r\n                    m.erase(nums[i]);\r\n                }\r\n                i++;\r\n            }\r\n            ans = max(ans, j - i + 1);\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n```C++ []\r\n    int longestSubarray(vector<int>& nums, int limit) {\r\n        multiset<int> s;\r\n        int ans = 0;\r\n        int i = 0;\r\n        for (int j = 0; j < nums.size(); j++) {\r\n            s.insert(nums[j]);\r\n            while (*s.rbegin() - *s.begin() > limit) {\r\n                s.erase(s.find(nums[i]));\r\n                i++;\r\n            }\r\n            ans = max(ans, j - i + 1);\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n`map<int, int>` 版本和 `multiset<int>` 版本点击分页切换\r\n\r\n\r\n\r\n### 致谢\r\n\r\n感谢您的观看，如果感觉还不错就点个赞吧，关注我的 [力扣个人主页](https://leetcode-cn.com/u/ikaruga/) ，欢迎热烈的交流！\r\n"
}