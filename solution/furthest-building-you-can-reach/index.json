{
	"titleSlug": "furthest-building-you-can-reach",
	"slug": "zhu-yao-si-xiang-by-zhen-tian-xia-1no0",
	"url": "https://leetcode-cn.com/problems/furthest-building-you-can-reach/solution/zhu-yao-si-xiang-by-zhen-tian-xia-1no0/",
	"content": "### 解题思路\n主要思想注释所示：\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    long max(long x, long y){\n        if(x>y) return x;\n        return y;\n    }\n    int furthestBuilding(vector<int>& heights, int bricks, int ladders) {\n        // 对于一个需要跳跃的地方，是用砖块好还是用梯子好\n        // 把需要跳跃的绝对高度记录下来[x0,x1,x2,x3,x4,x5,...xn]\n        // 假设可以达到xi,则要去除[0,i]中ladders个最大值，其他的总和要小于等于bricks\n        // 优先队列来做\n        int n = heights.size();\n        vector<long> check(n,0);\n        vector<long> presum(n,0);\n        // check[i]表示要达到 i 位置最后一次需要增高多少\n        check[0] = 0;\n        for(int i = 1; i < n; i++){\n            check[i] = max(check[i], heights[i] - heights[i - 1]);\n            presum[i] = presum[i - 1] + check[i];\n            if(ladders == 0 && presum[i] > bricks) return i - 1;\n        }\n        if(ladders == 0){\n            return n - 1;\n        }\n        // 我们需要一个数据结构来维护这 ladders 个最大值，使之可以方便地取出最小值进行替换，所以应该是最小堆\n        priority_queue<int,vector<int>,greater<>> q;\n        long sumofmax = 0;\n        int maxid = 0;\n        for(int i = 0; i < n; i++){\n            if(check[i] == 0) {maxid = i;continue;}\n            if(q.size() < ladders){\n                q.push(check[i]);\n                sumofmax += check[i];\n                maxid = i;\n            }\n            else{\n                if(q.top() < check[i]){\n                    int tmp = q.top(); q.pop();\n                    sumofmax += (check[i] - tmp);\n                    q.push(check[i]);\n                }\n            }\n            if(bricks >= presum[i] - sumofmax){\n                maxid = i;\n            }\n            else break;\n        }\n        return maxid;\n    }\n};\n```"
}