{
	"titleSlug": "palindrome-pairs",
	"slug": "hui-wen-dui-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/palindrome-pairs/solution/hui-wen-dui-by-leetcode-solution/",
	"content": "#### 前言\n\n本题可以想到暴力做法，我们枚举每一对字符串的组合，暴力判断它们是否能够构成回文串即可。时间复杂度 $O(n^2\\times m)$，其中 $n$ 是字符串的数量，$m$ 是字符串的平均长度。时间复杂度并不理想，考虑进行优化。\n\n#### 方法一：枚举前缀和后缀\n\n**思路及算法**\n\n假设存在两个字符串 $s_1$ 和 $s_2$，$s_1+s_2$ 是一个回文串，记这两个字符串的长度分别为 $len_1$ 和 $len_2$，我们分三种情况进行讨论：\n\n1. $\\textit{len}_1 = \\textit{len}_2$，这种情况下 $s_1$ 是 $s_2$ 的翻转。\n2. $\\textit{len}_1 > \\textit{len}_2$，这种情况下我们可以将 $s_1$ 拆成左右两部分：$t_1$ 和 $t_2$，其中 $t_1$ 是 $s_2$ 的翻转，$t_2$ 是一个回文串。\n3. $\\textit{len}_1 < \\textit{len}_2$，这种情况下我们可以将 $s_2$ 拆成左右两部分：$t_1$ 和 $t_2$，其中 $t_2$ 是 $s_1$ 的翻转，$t_1$ 是一个回文串。\n\n这样，对于每一个字符串，我们令其为 $s_1$ 和 $s_2$ 中较长的那一个，然后找到可能和它构成回文串的字符串即可。\n\n具体地说，我们枚举每一个字符串 $k$，令其为 $s_1$ 和 $s_2$ 中较长的那一个，那么 $k$ 可以被拆分为两部分，$t_1$ 和 $t_2$。\n\n1. 当 $t_1$ 是回文串时，符合情况 $3$，我们只需要查询给定的字符串序列中是否包含 $t_2$ 的翻转。\n2. 当 $t_2$ 是回文串时，符合情况 $2$，我们只需要查询给定的字符串序列中是否包含 $t_1$ 的翻转。\n\n也就是说，我们要枚举字符串 $k$ 的每一个前缀和后缀，判断其是否为回文串。如果是回文串，我们就查询其剩余部分的翻转是否在给定的字符串序列中出现即可。\n\n注意到空串也是回文串，所以我们可以将 $k$ 拆解为 $k+\\varnothing$ 或 $\\varnothing+k$，这样我们就能将情况 $1$ 也解释为特殊的情况 $2$ 或情况 $3$。\n\n而要实现这些操作，我们只需要设计一个能够在一系列字符串中查询「某个字符串的子串的翻转」是否存在的数据结构，有两种实现方法：\n\n- 我们可以使用字典树存储所有的字符串。在进行查询时，我们将待查询串的子串逆序地在字典树上进行遍历，即可判断其是否存在。\n\n- 我们可以使用哈希表存储所有字符串的翻转串。在进行查询时，我们判断带查询串的子串是否在哈希表中出现，就等价于判断了其翻转是否存在。\n\n**代码**\n\n下面给出的是使用字典树的代码：\n\n```C++ [sol11-C++]\nclass Solution {\npublic:\n    struct node {\n        int ch[26];\n        int flag;\n        node() {\n            flag = -1;\n            memset(ch, 0, sizeof(ch));\n        }\n    };\n\n    vector<node> tree;\n\n    void insert(string& s, int id) {\n        int len = s.length(), add = 0;\n        for (int i = 0; i < len; i++) {\n            int x = s[i] - 'a';\n            if (!tree[add].ch[x]) {\n                tree.emplace_back();\n                tree[add].ch[x] = tree.size() - 1;\n            }\n            add = tree[add].ch[x];\n        }\n        tree[add].flag = id;\n    }\n\n    int findWord(string& s, int left, int right) {\n        int add = 0;\n        for (int i = right; i >= left; i--) {\n            int x = s[i] - 'a';\n            if (!tree[add].ch[x]) {\n                return -1;\n            }\n            add = tree[add].ch[x];\n        }\n        return tree[add].flag;\n    }\n\n    bool isPalindrome(string& s, int left, int right) {\n        int len = right - left + 1;\n        for (int i = 0; i < len / 2; i++) {\n            if (s[left + i] != s[right - i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<vector<int>> palindromePairs(vector<string>& words) {\n        tree.emplace_back(node());\n        int n = words.size();\n        for (int i = 0; i < n; i++) {\n            insert(words[i], i);\n        }\n        vector<vector<int>> ret;\n        for (int i = 0; i < n; i++) {\n            int m = words[i].size();\n            for (int j = 0; j <= m; j++) {\n                if (isPalindrome(words[i], j, m - 1)) {\n                    int left_id = findWord(words[i], 0, j - 1);\n                    if (left_id != -1 && left_id != i) {\n                        ret.push_back({i, left_id});\n                    }\n                }\n                if (j && isPalindrome(words[i], 0, j - 1)) {\n                    int right_id = findWord(words[i], j, m - 1);\n                    if (right_id != -1 && right_id != i) {\n                        ret.push_back({right_id, i});\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol11-Java]\nclass Solution {\n    class Node {\n        int[] ch = new int[26];\n        int flag;\n\n        public Node() {\n            flag = -1;\n        }\n    }\n\n    List<Node> tree = new ArrayList<Node>();\n\n    public List<List<Integer>> palindromePairs(String[] words) {\n        tree.add(new Node());\n        int n = words.length;\n        for (int i = 0; i < n; i++) {\n            insert(words[i], i);\n        }\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n; i++) {\n            int m = words[i].length();\n            for (int j = 0; j <= m; j++) {\n                if (isPalindrome(words[i], j, m - 1)) {\n                    int leftId = findWord(words[i], 0, j - 1);\n                    if (leftId != -1 && leftId != i) {\n                        ret.add(Arrays.asList(i, leftId));\n                    }\n                }\n                if (j != 0 && isPalindrome(words[i], 0, j - 1)) {\n                    int rightId = findWord(words[i], j, m - 1);\n                    if (rightId != -1 && rightId != i) {\n                        ret.add(Arrays.asList(rightId, i));\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n\n    public void insert(String s, int id) {\n        int len = s.length(), add = 0;\n        for (int i = 0; i < len; i++) {\n            int x = s.charAt(i) - 'a';\n            if (tree.get(add).ch[x] == 0) {\n                tree.add(new Node());\n                tree.get(add).ch[x] = tree.size() - 1;\n            }\n            add = tree.get(add).ch[x];\n        }\n        tree.get(add).flag = id;\n    }\n\n    public boolean isPalindrome(String s, int left, int right) {\n        int len = right - left + 1;\n        for (int i = 0; i < len / 2; i++) {\n            if (s.charAt(left + i) != s.charAt(right - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public int findWord(String s, int left, int right) {\n        int add = 0;\n        for (int i = right; i >= left; i--) {\n            int x = s.charAt(i) - 'a';\n            if (tree.get(add).ch[x] == 0) {\n                return -1;\n            }\n            add = tree.get(add).ch[x];\n        }\n        return tree.get(add).flag;\n    }\n}\n```\n\n```Python [sol11-Python3]\nclass Node:\n    def __init__(self):\n        self.ch = [0] * 26\n        self.flag = -1\n\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        tree = [Node()]\n\n        def insert(s: str, index: int):\n            length = len(s)\n            add = 0\n            for i in range(length):\n                x = ord(s[i]) - ord(\"a\")\n                if tree[add].ch[x] == 0:\n                    tree.append(Node())\n                    tree[add].ch[x] = len(tree) - 1\n                add = tree[add].ch[x]\n            tree[add].flag = index\n        \n        def findWord(s: str, left: int, right: int) -> int:\n            add = 0\n            for i in range(right, left - 1, -1):\n                x = ord(s[i]) - ord(\"a\")\n                if tree[add].ch[x] == 0:\n                    return -1\n                add = tree[add].ch[x]\n            return tree[add].flag\n        \n        def isPalindrome(s: str, left: int, right: int) -> bool:\n            length = right - left + 1\n            return length < 0 or all(s[left + i] == s[right - i] for i in range(length // 2))\n        \n        n = len(words)\n        for i, word in enumerate(words):\n            insert(word, i)\n        \n        ret = list()\n        for i, word in enumerate(words):\n            m = len(word)\n            for j in range(m + 1):\n                if isPalindrome(word, j, m - 1):\n                    leftId = findWord(word, 0, j - 1)\n                    if leftId != -1 and leftId != i:\n                        ret.append([i, leftId])\n                if j and isPalindrome(word, 0, j - 1):\n                    rightId = findWord(word, j, m - 1)\n                    if rightId != -1 and rightId != i:\n                        ret.append([rightId, i])\n\n        return ret\n```\n\n```golang [sol11-Golang]\ntype Node struct {\n    ch [26]int\n    flag int\n}\n\nvar tree []Node\n\nfunc palindromePairs(words []string) [][]int {\n    tree = []Node{Node{[26]int{}, -1}}\n    n := len(words)\n    for i := 0; i < n; i++ {\n        insert(words[i], i)\n    }\n    ret := [][]int{}\n    for i := 0; i < n; i++ {\n        word := words[i]\n        m := len(word)\n        for j := 0; j <= m; j++ {\n            if isPalindrome(word, j, m - 1) {\n                leftId := findWord(word, 0, j - 1)\n                if leftId != -1 && leftId != i {\n                    ret = append(ret, []int{i, leftId})\n                }\n            }\n            if j != 0 && isPalindrome(word, 0, j - 1) {\n                rightId := findWord(word, j, m - 1)\n                if rightId != -1 && rightId != i {\n                    ret = append(ret, []int{rightId, i})\n                }\n            }\n        }\n    }\n    return ret\n}\n\nfunc insert(s string, id int) {\n    add := 0\n    for i := 0; i < len(s); i++ {\n        x := int(s[i] - 'a')\n        if tree[add].ch[x] == 0 {\n            tree = append(tree, Node{[26]int{}, -1})\n            tree[add].ch[x] = len(tree) - 1\n        }\n        add = tree[add].ch[x]\n    }\n    tree[add].flag = id\n}\n\nfunc findWord(s string, left, right int) int {\n    add := 0\n    for i := right; i >= left; i-- {\n        x := int(s[i] - 'a')\n        if tree[add].ch[x] == 0 {\n            return -1\n        }\n        add = tree[add].ch[x]\n    }\n    return tree[add].flag\n}\n\nfunc isPalindrome(s string, left, right int) bool {\n    for i := 0; i < (right - left + 1) / 2; i++ {\n        if s[left + i] != s[right - i] {\n            return false\n        }\n    }\n    return true\n}\n```\n\n```C [sol11-C]\nstruct node {\n    int ch[26];\n    int flag;\n} tree[100001];\nint tree_len;\n\nvoid reset(struct node* p) {\n    memset(p->ch, 0, sizeof(int) * 26);\n    p->flag = -1;\n}\n\nvoid insert(char* s, int id) {\n    int len = strlen(s), add = 0;\n    for (int i = 0; i < len; i++) {\n        int x = s[i] - 'a';\n        if (!tree[add].ch[x]) {\n            tree_len++;\n            reset(&tree[tree_len - 1]);\n            tree[add].ch[x] = tree_len - 1;\n        }\n        add = tree[add].ch[x];\n    }\n    tree[add].flag = id;\n}\n\nint findWord(char* s, int left, int right) {\n    int add = 0;\n    for (int i = right; i >= left; i--) {\n        int x = s[i] - 'a';\n        if (!tree[add].ch[x]) {\n            return -1;\n        }\n        add = tree[add].ch[x];\n    }\n    return tree[add].flag;\n}\n\nbool isPalindrome(char* s, int left, int right) {\n    int len = right - left + 1;\n    for (int i = 0; i < len / 2; i++) {\n        if (s[left + i] != s[right - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint** palindromePairs(char** words, int wordsSize, int* returnSize, int** returnColumnSizes) {\n    reset(&tree[0]);\n    tree_len = 1;\n    for (int i = 0; i < wordsSize; i++) {\n        insert(words[i], i);\n    }\n    int** ret = malloc(sizeof(int*) * 10001);\n    (*returnColumnSizes) = malloc(sizeof(int) * 10001);\n    for (int i = 0; i < 10001; i++) {\n        ret[i] = malloc(sizeof(int) * 2);\n        (*returnColumnSizes)[i] = 2;\n    }\n    int ret_len = 0;\n    for (int i = 0; i < wordsSize; i++) {\n        int m = strlen(words[i]);\n        for (int j = 0; j <= m; j++) {\n            if (isPalindrome(words[i], j, m - 1)) {\n                int left_id = findWord(words[i], 0, j - 1);\n                if (left_id != -1 && left_id != i) {\n                    ret_len++;\n                    ret[ret_len - 1][0] = i;\n                    ret[ret_len - 1][1] = left_id;\n                }\n            }\n            if (j && isPalindrome(words[i], 0, j - 1)) {\n                int right_id = findWord(words[i], j, m - 1);\n                if (right_id != -1 && right_id != i) {\n                    ret_len++;\n                    ret[ret_len - 1][0] = right_id;\n                    ret[ret_len - 1][1] = i;\n                }\n            }\n        }\n    }\n    (*returnSize) = ret_len;\n    return ret;\n}\n```\n\n下面给出的是使用哈希表的代码：\n\n```C++ [sol12-C++]\nclass Solution {\nprivate:\n    vector<string> wordsRev;\n    unordered_map<string_view, int> indices;\n\npublic:\n    int findWord(const string_view& s, int left, int right) {\n        auto iter = indices.find(s.substr(left, right - left + 1));\n        return iter == indices.end() ? -1 : iter->second;\n    }\n\n    bool isPalindrome(const string_view& s, int left, int right) {\n        int len = right - left + 1;\n        for (int i = 0; i < len / 2; i++) {\n            if (s[left + i] != s[right - i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<vector<int>> palindromePairs(vector<string>& words) {\n        int n = words.size();\n        for (const string& word: words) {\n            wordsRev.push_back(word);\n            reverse(wordsRev.back().begin(), wordsRev.back().end());\n        }\n        for (int i = 0; i < n; ++i) {\n            indices.emplace(wordsRev[i], i);\n        }\n\n        vector<vector<int>> ret;\n        for (int i = 0; i < n; i++) {\n            int m = words[i].size();\n            if (!m) {\n                continue;\n            }\n            string_view wordView(words[i]);\n            for (int j = 0; j <= m; j++) {\n                if (isPalindrome(wordView, j, m - 1)) {\n                    int left_id = findWord(wordView, 0, j - 1);\n                    if (left_id != -1 && left_id != i) {\n                        ret.push_back({i, left_id});\n                    }\n                }\n                if (j && isPalindrome(wordView, 0, j - 1)) {\n                    int right_id = findWord(wordView, j, m - 1);\n                    if (right_id != -1 && right_id != i) {\n                        ret.push_back({right_id, i});\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol12-Java]\nclass Solution {\n    List<String> wordsRev = new ArrayList<String>();\n    Map<String, Integer> indices = new HashMap<String, Integer>();\n\n    public List<List<Integer>> palindromePairs(String[] words) {\n        int n = words.length;\n        for (String word: words) {\n            wordsRev.add(new StringBuffer(word).reverse().toString());\n        }\n        for (int i = 0; i < n; ++i) {\n            indices.put(wordsRev.get(i), i);\n        }\n\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n; i++) {\n            String word = words[i];\n            int m = words[i].length();\n            if (m == 0) {\n                continue;\n            }\n            for (int j = 0; j <= m; j++) {\n                if (isPalindrome(word, j, m - 1)) {\n                    int leftId = findWord(word, 0, j - 1);\n                    if (leftId != -1 && leftId != i) {\n                        ret.add(Arrays.asList(i, leftId));\n                    }\n                }\n                if (j != 0 && isPalindrome(word, 0, j - 1)) {\n                    int rightId = findWord(word, j, m - 1);\n                    if (rightId != -1 && rightId != i) {\n                        ret.add(Arrays.asList(rightId, i));\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n\n    public boolean isPalindrome(String s, int left, int right) {\n        int len = right - left + 1;\n        for (int i = 0; i < len / 2; i++) {\n            if (s.charAt(left + i) != s.charAt(right - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public int findWord(String s, int left, int right) {\n        return indices.getOrDefault(s.substring(left, right + 1), -1);\n    }\n}\n```\n\n```Python [sol12-Python3]\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n\n        def findWord(s: str, left: int, right: int) -> int:\n            return indices.get(s[left:right+1], -1)\n        \n        def isPalindrome(s: str, left: int, right: int) -> bool:\n            return (sub := s[left:right+1]) == sub[::-1]\n        \n        n = len(words)\n        indices = {word[::-1]: i for i, word in enumerate(words)}\n        \n        ret = list()\n        for i, word in enumerate(words):\n            m = len(word)\n            for j in range(m + 1):\n                if isPalindrome(word, j, m - 1):\n                    leftId = findWord(word, 0, j - 1)\n                    if leftId != -1 and leftId != i:\n                        ret.append([i, leftId])\n                if j and isPalindrome(word, 0, j - 1):\n                    rightId = findWord(word, j, m - 1)\n                    if rightId != -1 and rightId != i:\n                        ret.append([rightId, i])\n\n        return ret\n```\n\n```golang [sol12-Golang]\nfunc palindromePairs(words []string) [][]int {\n    wordsRev := []string{}\n    indices := map[string]int{}\n\n    n := len(words)\n    for _, word := range words {\n        wordsRev = append(wordsRev, reverse(word))\n    }\n    for i := 0; i < n; i++ {\n        indices[wordsRev[i]] = i\n    }\n\n    ret := [][]int{}\n    for i := 0; i < n; i++ {\n        word := words[i]\n        m := len(word)\n        if m == 0 {\n            continue\n        }\n        for j := 0; j <= m; j++ {\n            if isPalindrome(word, j, m - 1) {\n                leftId := findWord(word, 0, j - 1, indices)\n                if leftId != -1 && leftId != i {\n                    ret = append(ret, []int{i, leftId})\n                }\n            }\n            if j != 0 && isPalindrome(word, 0, j - 1) {\n                rightId := findWord(word, j, m - 1, indices)\n                if rightId != -1 && rightId != i {\n                    ret = append(ret, []int{rightId, i})\n                }\n            }\n        }\n    }\n    return ret\n}\n\nfunc findWord(s string, left, right int, indices map[string]int) int {\n    if v, ok := indices[s[left:right+1]]; ok {\n        return v\n    }\n    return -1\n}\n\nfunc isPalindrome(s string, left, right int) bool {\n    for i := 0; i < (right - left + 1) / 2; i++ {\n        if s[left + i] != s[right - i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc reverse(s string) string {\n    n := len(s)\n    b := []byte(s)\n    for i := 0; i < n/2; i++ {\n        b[i], b[n-i-1] = b[n-i-1], b[i]\n    }\n    return string(b)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times m^2)$，其中 $n$ 是字符串的数量，$m$ 是字符串的平均长度。对于每一个字符串，我们需要 $O(m^2)$ 地判断其所有前缀与后缀是否是回文串，并 $O(m^2)$ 地寻找其所有前缀与后缀是否在给定的字符串序列中出现。\n\n- 空间复杂度：$O(n \\times m)$，其中 $n$ 是字符串的数量，$m$ 是字符串的平均长度。为字典树的空间开销。\n\n#### 方法二：字典树 + Manacher\n\n**说明**\n\n方法二为竞赛难度，在面试中不作要求。学有余力的读者可以学习在字符串中寻找最长回文串的「Manacher 算法」。\n\n**思路及算法**\n\n注意到方法一中，对于每一个字符串 $k$，我们需要 $O(m^2)$ 地判断 $k$ 的所有前缀与后缀是否是回文串，还需要 $O(m^2)$ 地判断 $k$ 的所有前缀与后缀是否在给定字符串序列中出现。我们可以优化这两部分的时间复杂度。\n\n- 对于判断其所有前缀与后缀是否是回文串：\n\n  - 利用 Manacher 算法，可以线性地处理出每一个前后缀是否是回文串。\n\n- 对于判断其所有前缀与后缀是否在给定的字符串序列中出现：\n\n  - 对于给定的字符串序列，分别正向与反向建立字典树，利用正向建立的字典树验证 $k$ 的后缀的翻转，利用反向建立的字典树验证 $k$ 的前缀的翻转。\n\n这样我们就可以快速找出能够和字符串 $k$ 构成回文串的字符串。\n\n**注意**：因为该解法常数较大，因此在随机数据下的表现并没有方法一优秀。\n\n**代码**\n\n```C++ [sol2-C++]\nstruct Trie {\n    struct node {\n        int ch[26];\n        int flag;\n        node() {\n            flag = -1;\n            memset(ch, 0, sizeof(ch));\n        }\n    };\n\n    vector<node> tree;\n\n    Trie() { tree.emplace_back(); }\n\n    void insert(string& s, int id) {\n        int len = s.length(), add = 0;\n        for (int i = 0; i < len; i++) {\n            int x = s[i] - 'a';\n            if (!tree[add].ch[x]) {\n                tree.emplace_back();\n                tree[add].ch[x] = tree.size() - 1;\n            }\n            add = tree[add].ch[x];\n        }\n        tree[add].flag = id;\n    }\n\n    vector<int> query(string& s) {\n        int len = s.length(), add = 0;\n        vector<int> ret(len + 1, -1);\n        for (int i = 0; i < len; i++) {\n            ret[i] = tree[add].flag;\n            int x = s[i] - 'a';\n            if (!tree[add].ch[x]) {\n                return ret;\n            }\n            add = tree[add].ch[x];\n        }\n        ret[len] = tree[add].flag;\n        return ret;\n    }\n};\n\nclass Solution {\npublic:\n    vector<pair<int, int>> manacher(string& s) {\n        int n = s.length();\n        string tmp = \"#\";\n        tmp += s[0];\n        for (int i = 1; i < n; i++) {\n            tmp += '*';\n            tmp += s[i];\n        }\n        tmp += '!';\n        int m = n * 2;\n        vector<int> len(m);\n        vector<pair<int, int>> ret(n);\n        int p = 0, maxn = -1;\n        for (int i = 1; i < m; i++) {\n            len[i] = maxn >= i ? min(len[2 * p - i], maxn - i) : 0;\n            while (tmp[i - len[i] - 1] == tmp[i + len[i] + 1]) {\n                len[i]++;\n            }\n            if (i + len[i] > maxn) {\n                p = i, maxn = i + len[i];\n            }\n            if (i - len[i] == 1) {\n                ret[(i + len[i]) / 2].first = 1;\n            }\n            if (i + len[i] == m - 1) {\n                ret[(i - len[i]) / 2].second = 1;\n            }\n        }\n        return ret;\n    }\n\n    vector<vector<int>> palindromePairs(vector<string>& words) {\n        Trie trie1, trie2;\n\n        int n = words.size();\n        for (int i = 0; i < n; i++) {\n            trie1.insert(words[i], i);\n            string tmp = words[i];\n            reverse(tmp.begin(), tmp.end());\n            trie2.insert(tmp, i);\n        }\n\n        vector<vector<int>> ret;\n        for (int i = 0; i < n; i++) {\n            const vector<pair<int, int>>& rec = manacher(words[i]);\n\n            const vector<int>& id1 = trie2.query(words[i]);\n            reverse(words[i].begin(), words[i].end());\n            const vector<int>& id2 = trie1.query(words[i]);\n\n            int m = words[i].size();\n\n            int all_id = id1[m];\n            if (all_id != -1 && all_id != i) {\n                ret.push_back({i, all_id});\n            }\n            for (int j = 0; j < m; j++) {\n                if (rec[j].first) {\n                    int left_id = id2[m - j - 1];\n                    if (left_id != -1 && left_id != i) {\n                        ret.push_back({left_id, i});\n                    }\n                }\n                if (rec[j].second) {\n                    int right_id = id1[j];\n                    if (right_id != -1 && right_id != i) {\n                        ret.push_back({i, right_id});\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public List<List<Integer>> palindromePairs(String[] words) {\n        Trie trie1 = new Trie();\n        Trie trie2 = new Trie();\n\n        int n = words.length;\n        for (int i = 0; i < n; i++) {\n            trie1.insert(words[i], i);\n            StringBuffer tmp = new StringBuffer(words[i]);\n            tmp.reverse();\n            trie2.insert(tmp.toString(), i);\n        }\n\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n; i++) {\n            int[][] rec = manacher(words[i]);\n\n            int[] id1 = trie2.query(words[i]);\n            words[i] = new StringBuffer(words[i]).reverse().toString();\n            int[] id2 = trie1.query(words[i]);\n\n            int m = words[i].length();\n\n            int allId = id1[m];\n            if (allId != -1 && allId != i) {\n                ret.add(Arrays.asList(i, allId));\n            }\n            for (int j = 0; j < m; j++) {\n                if (rec[j][0] != 0) {\n                    int leftId = id2[m - j - 1];\n                    if (leftId != -1 && leftId != i) {\n                        ret.add(Arrays.asList(leftId, i));\n                    }\n                }\n                if (rec[j][1] != 0) {\n                    int rightId = id1[j];\n                    if (rightId != -1 && rightId != i) {\n                        ret.add(Arrays.asList(i, rightId));\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n\n    public int[][] manacher(String s) {\n        int n = s.length();\n        StringBuffer tmp = new StringBuffer(\"#\");\n        for (int i = 0; i < n; i++) {\n            if (i > 0) {\n                tmp.append('*');\n            }\n            tmp.append(s.charAt(i));\n        }\n        tmp.append('!');\n        int m = n * 2;\n        int[] len = new int[m];\n        int[][] ret = new int[n][2];\n        int p = 0, maxn = -1;\n        for (int i = 1; i < m; i++) {\n            len[i] = maxn >= i ? Math.min(len[2 * p - i], maxn - i) : 0;\n            while (tmp.charAt(i - len[i] - 1) == tmp.charAt(i + len[i] + 1)) {\n                len[i]++;\n            }\n            if (i + len[i] > maxn) {\n                p = i;\n                maxn = i + len[i];\n            }\n            if (i - len[i] == 1) {\n                ret[(i + len[i]) / 2][0] = 1;\n            }\n            if (i + len[i] == m - 1) {\n                ret[(i - len[i]) / 2][1] = 1;\n            }\n        }\n        return ret;\n    }\n}\n\nclass Trie {\n    class Node {\n        int[] ch = new int[26];\n        int flag;\n\n        public Node() {\n            flag = -1;\n        }\n    }\n\n    List<Node> tree = new ArrayList<Node>();\n\n    public Trie() {\n        tree.add(new Node());\n    }\n\n    public void insert(String s, int id) {\n        int len = s.length(), add = 0;\n        for (int i = 0; i < len; i++) {\n            int x = s.charAt(i) - 'a';\n            if (tree.get(add).ch[x] == 0) {\n                tree.add(new Node());\n                tree.get(add).ch[x] = tree.size() - 1;\n            }\n            add = tree.get(add).ch[x];\n        }\n        tree.get(add).flag = id;\n    }\n\n    public int[] query(String s) {\n        int len = s.length(), add = 0;\n        int[] ret = new int[len + 1];\n        Arrays.fill(ret, -1);\n        for (int i = 0; i < len; i++) {\n            ret[i] = tree.get(add).flag;\n            int x = s.charAt(i) - 'a';\n            if (tree.get(add).ch[x] == 0) {\n                return ret;\n            }\n            add = tree.get(add).ch[x];\n        }\n        ret[len] = tree.get(add).flag;\n        return ret;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times m)$，其中 $n$ 是字符串的数量，$m$ 是字符串的平均长度。对于每一个字符串，我们需要 $O(m)$ 地判断其所有前缀与后缀是否是回文串，并 $O(m)$ 地寻找其所有前缀与后缀是否在给定的字符串序列中出现。\n\n- 空间复杂度：$O(n \\times m)$，其中 $n$ 是字符串的数量，$m$ 是字符串的平均长度。为字典树的空间开销。"
}