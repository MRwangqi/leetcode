{
	"titleSlug": "minimize-maximum-of-array",
	"slug": "cppjava-you-shi-yi-dao-jing-dian-de-er-f-w3i6",
	"url": "https://leetcode-cn.com/problems/minimize-maximum-of-array/solution/cppjava-you-shi-yi-dao-jing-dian-de-er-f-w3i6/",
	"content": "#### 前言\r\n\r\n-----\r\n\r\n有关于二分答案的类型题，可以看我这道题的题解[链接🔗](https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/solution/by-relll-1037-dhhf/)\r\n\r\n#### 题意分析\r\n\r\n-----\r\n\r\n给你一个数组，对于`1 <= i < len(nums)`的`i`可以有以下操作\r\n\r\n+ 将`nums[i]--`，`nums[i-1]++`\r\n+ `nums[i] > 0`\r\n\r\n对于这个条件，我们应该得到这样的理解：\r\n\r\n+ 前方的较小数可以接受后方较大数多余的数字\r\n\r\n可能这句话有些晦涩难懂，下面举一个例子具体分析\r\n\r\n> 设`nums = [2,3,7,1,6]`\r\n>\r\n> 由对前三个数进行**操作**，则我们可以得到的**最小最大值**为`4`\r\n>\r\n> 怎么做到的捏？我们来一步步走\r\n>\r\n> [2,3,7]\r\n>\r\n> [3,2,7]\r\n>\r\n> [4,1,7]\r\n>\r\n> [4,2,6]\r\n>\r\n> [4,3,5]\r\n>\r\n> [4,4,4]\r\n>\r\n> 一步步下来，我们发现，前方的较小的2和3承接了来自后方的7中的数，最终使得整个数组都整体变小了\r\n>\r\n> 2承载了最终答案4中的，**来自于7中的两个1**\r\n>\r\n> 3承载了最终答案4中的，**来自于7中的一个1**\r\n\r\n由此我们可以由局部推广到整体，我们只需要检查数组在小数承载大数的基础上，是否可以全部都不大于`k`\r\n\r\n\r\n\r\n那么要检查的数从哪里来捏？即答：“二分查找”\r\n\r\n由于数组中`0 <= a[i] <= 1e9`故不能一个个检查所有数，二分查找便可以帮助我们快速定位答案\r\n\r\n#### 参考代码\r\n\r\n---------\r\n\r\n```cpp []\r\nclass Solution {\r\npublic:\r\n    static bool check(vector<int> &nums, int k) {\r\n        long long have = 0;//前方的数字还可以帮我们后方的大数承载多少数字\r\n        for (int n : nums) {\r\n            if (n <= k) {\r\n                have += k - n;//较小数，可以算入承载量\r\n            } else {\r\n                if (have < n - k) return 0;//承载不了了，该答案不可行\r\n                else have -= (n - k);//减去承载量\r\n            }\r\n        }\r\n        return 1;\r\n    }\r\n\r\n    int minimizeArrayValue(vector<int> &nums) {\r\n        int left = 0, right = *max_element(nums.begin(), nums.end());\r\n        while (left < right) {//二分答案，寻找最大值\r\n            int mid = left + (right - left) / 2;\r\n            if (check(nums, mid)) right = mid;\r\n            else left = mid + 1;\r\n        }\r\n        return left;\r\n    }\r\n};\r\n```\r\n```java []\r\nclass Solution {\r\n    static boolean check(int[] nums, int k) {\r\n        long have = 0;//前方的数字还可以帮我们后方的大数承载多少数字\r\n        for (int n : nums) {\r\n            if (n <= k) {\r\n                have += k - n;//较小数，可以算入承载量\r\n            } else {\r\n                if (have < n - k) return false;//承载不了了，该答案不可行\r\n                else have -= (n - k);//减去承载量\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    public int minimizeArrayValue(int[] nums) {\r\n        int left = 0, right = 1000000000;\r\n        while (left < right) {//二分答案，寻找最大值\r\n            int mid = left + (right - left) / 2;\r\n            if (check(nums, mid)) right = mid;\r\n            else left = mid + 1;\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n```python3 []\r\nclass Solution:\r\n    def check(self, nums: List[int], k: int) -> bool:\r\n        have = 0\r\n        for n in nums:\r\n            if n <= k:\r\n                have += k - n\r\n            else:\r\n                if have < n - k:\r\n                    return False\r\n                else:\r\n                    have -= (n - k)\r\n        return True\r\n    \r\n    def minimizeArrayValue(self, nums: List[int]) -> int:\r\n        left, right = 0, max(nums)\r\n        while left < right:\r\n            mid = left + (right - left) // 2\r\n            if self.check(nums, mid):\r\n                right = mid\r\n            else:\r\n                left = mid + 1\r\n        return left\r\n```"
}