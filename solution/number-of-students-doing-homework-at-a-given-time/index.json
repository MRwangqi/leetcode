{
	"titleSlug": "number-of-students-doing-homework-at-a-given-time",
	"slug": "zai-ji-ding-shi-jian-zuo-zuo-ye-de-xue-s-uv49",
	"url": "https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/solution/zai-ji-ding-shi-jian-zuo-zuo-ye-de-xue-s-uv49/",
	"content": "#### 方法一：枚举\n\n题目要求找到 $\\textit{queryTime}$ 时正在做作业的学生人数，第 $i$ 名学生的起始时间 $\\textit{startTime}[i]$ 和完成时间 $\\textit{endTime}[i]$ 如果满足 $\\textit{startTime}[i] \\le \\textit{queryTime} \\le \\textit{endTime}[i]$，则可知该名学生在 $\\textit{queryTime}$ 时一定正在作业。我们遍历所有学生的起始时间和结束时间，统计符合上述条件的学生总数即可。\n\n```Python [sol1-Python3]\nclass Solution:\n    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\n        return sum(s <= queryTime <= e for s, e in zip(startTime, endTime))\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {\n        int n = startTime.size();\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (startTime[i] <= queryTime && endTime[i] >= queryTime) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n = startTime.length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (startTime[i] <= queryTime && endTime[i] >= queryTime) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int BusyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n = startTime.Length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (startTime[i] <= queryTime && endTime[i] >= queryTime) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\nint busyStudent(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int queryTime){\n    int ans = 0;\n    for (int i = 0; i < startTimeSize; i++) {\n        if (startTime[i] <= queryTime && endTime[i] >= queryTime) {\n            ans++;\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar busyStudent = function(startTime, endTime, queryTime) {\n    const n = startTime.length;\n    let ans = 0;\n    for (let i = 0; i < n; i++) {\n        if (startTime[i] <= queryTime && endTime[i] >= queryTime) {\n            ans++;\n        }\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc busyStudent(startTime []int, endTime []int, queryTime int) (ans int) {\n    for i, s := range startTime {\n        if s <= queryTime && queryTime <= endTime[i] {\n            ans++\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为 数组的长度。只需遍历一遍数组即可。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：差分数组\n\n利用差分数组的思想，对差分数组求前缀和，可以得到统计出 $t$ 时刻正在做作业的人数。我们初始化差分数组 $\\textit{cnt}$ 每个元素都为 $0$，在每个学生的起始时间处 $\\textit{cnt}[\\textit{startTime}[i]]$ 加 $1$，在每个学生的结束时间处 $\\textit{cnt}[\\textit{endTime}[i] + 1]$ 减 $1$，因此我们可以统计出 $\\textit{queryTime}$ 时刻正在做作业的人数为 $\\sum_{j=0}^{\\textit{queryTime}}\\textit{cnt}[j]$。\n\n```Python [sol2-Python3]\nclass Solution:\n    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\n        maxEndTime = max(endTime)\n        if queryTime > maxEndTime:\n            return 0\n        cnt = [0] * (maxEndTime + 2)\n        for s, e in zip(startTime, endTime):\n            cnt[s] += 1\n            cnt[e + 1] -= 1\n        return sum(cnt[:queryTime + 1])\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {\n        int n = startTime.size();\n        int maxEndTime = *max_element(endTime.begin(), endTime.end());\n        if (queryTime > maxEndTime) {\n            return 0;\n        }\n        vector<int> cnt(maxEndTime + 2);\n        for (int i = 0; i < n; i++) {\n            cnt[startTime[i]]++;\n            cnt[endTime[i] + 1]--;\n        }\n        int ans = 0;\n        for (int i = 0; i <= queryTime; i++) {\n            ans += cnt[i];\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n = startTime.length;\n        int maxEndTime = Arrays.stream(endTime).max().getAsInt();\n        if (queryTime > maxEndTime) {\n            return 0;\n        }\n        int[] cnt = new int[maxEndTime + 2];\n        for (int i = 0; i < n; i++) {\n            cnt[startTime[i]]++;\n            cnt[endTime[i] + 1]--;\n        }\n        int ans = 0;\n        for (int i = 0; i <= queryTime; i++) {\n            ans += cnt[i];\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int BusyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n = startTime.Length;\n        int maxEndTime = endTime.Max();\n        if (queryTime > maxEndTime) {\n            return 0;\n        }\n        int[] cnt = new int[maxEndTime + 2];\n        for (int i = 0; i < n; i++) {\n            cnt[startTime[i]]++;\n            cnt[endTime[i] + 1]--;\n        }\n        int ans = 0;\n        for (int i = 0; i <= queryTime; i++) {\n            ans += cnt[i];\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint busyStudent(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int queryTime){\n    int maxEndTime = 0;\n    for (int i = 0; i < endTimeSize; i++) {\n        maxEndTime = MAX(maxEndTime, endTime[i]);\n    }\n    if (queryTime > maxEndTime) {\n        return 0;\n    }\n    int *cnt = (int *)malloc(sizeof(int) * (maxEndTime + 2));\n    memset(cnt, 0, sizeof(maxEndTime) * (maxEndTime + 2));\n    for (int i = 0; i < startTimeSize; i++) {\n        cnt[startTime[i]]++;\n        cnt[endTime[i] + 1]--;\n    }\n    int ans = 0;\n    for (int i = 0; i <= queryTime; i++) {\n        ans += cnt[i];\n    }\n    free(cnt);\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar busyStudent = function(startTime, endTime, queryTime) {\n    const n = startTime.length;\n    const maxEndTime = _.max(endTime);\n    if (queryTime > maxEndTime) {\n        return 0;\n    }\n    const cnt = new Array(maxEndTime + 2).fill(0);\n    for (let i = 0; i < n; i++) {\n        cnt[startTime[i]]++;\n        cnt[endTime[i] + 1]--;\n    }\n    let ans = 0;\n    for (let i = 0; i <= queryTime; i++) {\n        ans += cnt[i];\n    }\n    return ans;\n};\n```\n\n```go [sol2-Golang]\nfunc busyStudent(startTime []int, endTime []int, queryTime int) (ans int) {\n    maxEndTime := 0\n    for _, e := range endTime {\n        maxEndTime = max(maxEndTime, e)\n    }\n    if queryTime > maxEndTime {\n        return\n    }\n    cnt := make([]int, maxEndTime+2)\n    for i, s := range startTime {\n        cnt[s]++\n        cnt[endTime[i]+1]--\n    }\n    for _, c := range cnt[:queryTime+1] {\n        ans += c\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + \\textit{queryTime})$，其中 $n$ 为数组的长度，$\\textit{queryTime}$ 为给定的查找时间。首先需要遍历一遍数组，需要的时间为 $O(n)$，然后需要查分求和求出 $\\textit{queryTime}$ 时间点正在作业的学生总数，需要的时间为 $O(\\textit{queryTime})$，因此总的时间为 $O(n + \\textit{queryTime})$。\n\n- 空间复杂度：$O(\\max(\\textit{endTime}))$。\n\n#### 方法三：二分查找\n\n对于每个学生的作业时间 $[\\textit{startTime}[i], \\textit{endTime}[i]]$，一定满足 $\\textit{startTime}[i]\\le \\textit{endTime}[i]$。如果第 $i$ 名学生在 $\\textit{queryTime}$ 时正在作业，则一定满足 $\\textit{startTime}[i] \\le \\textit{queryTime} \\le \\textit{endTime}[i]$。设起始时间小于等于 $\\textit{queryTime}$ 的学生集合为 $\\textit{lessStart}$，设结束时间小于 $\\textit{queryTime}$ 的学生集合为 $\\textit{lessEnd}$，则根据上述推理可以知道 $\\textit{lessEnd} \\in \\textit{lessStart}$，我们从 $\\textit{lessStart}$ 去除 $\\textit{lessEnd}$ 的子集部分即为符合条件的学生集合。因此我们通过二分查找找到始时间小于等于 $\\textit{queryTime}$ 的学生人数，然后减去结束时间小于 $\\textit{queryTime}$ 的学生人数，最终结果即为符合条件要求。\n\n```Python [sol3-Python3]\nclass Solution:\n    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\n        startTime.sort()\n        endTime.sort()\n        return bisect_right(startTime, queryTime) - bisect_left(endTime, queryTime)\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic: \n    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {\n        sort(startTime.begin(), startTime.end());\n        sort(endTime.begin(), endTime.end());\n        int lessStart = upper_bound(startTime.begin(), startTime.end(), queryTime) - startTime.begin();\n        int lessEnd = lower_bound(endTime.begin(), endTime.end(), queryTime) - endTime.begin();\n        return lessStart - lessEnd;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        Arrays.sort(startTime);\n        Arrays.sort(endTime);\n        int lessStart = upperbound(startTime, 0, startTime.length - 1, queryTime);\n        int lessEnd = lowerbound(endTime, 0, endTime.length - 1, queryTime);\n        return lessStart - lessEnd;\n    }\n\n    public static int upperbound(int[] arr, int l, int r, int target) {\n        int ans = r + 1;\n        while (l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if (arr[mid] > target) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    public static int lowerbound(int[] arr, int l, int r, int target) {\n        int ans = r + 1;\n        while (l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if (arr[mid] >= target) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int BusyStudent(int[] startTime, int[] endTime, int queryTime) {\n        Array.Sort(startTime);\n        Array.Sort(endTime);\n        int lessStart = Upperbound(startTime, 0, startTime.Length - 1, queryTime);\n        int lessEnd = Lowerbound(endTime, 0, endTime.Length - 1, queryTime);\n        return lessStart - lessEnd;\n    }\n\n    public static int Upperbound(int[] arr, int l, int r, int target) {\n        int ans = r + 1;\n        while (l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if (arr[mid] > target) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    public static int Lowerbound(int[] arr, int l, int r, int target) {\n        int ans = r + 1;\n        while (l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if (arr[mid] >= target) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol3-C]\nstatic inline int cmp(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nstatic int upperbound(const int *arr, int l, int r, int target) {\n    int ans = r + 1;\n    while (l <= r) {\n        int mid = l + ((r - l) >> 1);\n        if (arr[mid] > target) {\n            ans = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return ans;\n}\n\nstatic int lowerbound(const int *arr, int l, int r, int target) {\n    int ans = r + 1;\n    while (l <= r) {\n        int mid = l + ((r - l) >> 1);\n        if (arr[mid] >= target) {\n            ans = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return ans;\n}\n\nint busyStudent(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int queryTime){\n    qsort(startTime, startTimeSize, sizeof(int), cmp);\n    qsort(endTime, endTimeSize, sizeof(int), cmp);\n    int lessStart = upperbound(startTime, 0, startTimeSize - 1, queryTime);\n    int lessEnd = lowerbound(endTime, 0, endTimeSize - 1, queryTime);\n    return lessStart - lessEnd;\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar busyStudent = function(startTime, endTime, queryTime) {\n    startTime.sort((a, b) => a - b);\n    endTime.sort((a, b) => a - b);\n    const lessStart = upperbound(startTime, 0, startTime.length - 1, queryTime);\n    const lessEnd = lowerbound(endTime, 0, endTime.length - 1, queryTime);\n    return lessStart - lessEnd;\n}\n\nconst upperbound = (arr, l, r, target) => {\n    let ans = r + 1;\n    while (l <= r) {\n        const mid = l + ((r - l) >> 1);\n        if (arr[mid] > target) {\n            ans = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return ans;\n}\n\nconst lowerbound = (arr, l, r, target) => {\n    let ans = r + 1;\n    while (l <= r) {\n        let mid = l + ((r - l) >> 1);\n        if (arr[mid] >= target) {\n            ans = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return ans;\n};\n```\n\n```go [sol3-Golang]\nfunc busyStudent(startTime []int, endTime []int, queryTime int) (ans int) {\n    sort.Ints(startTime)\n    sort.Ints(endTime)\n    return sort.SearchInts(startTime, queryTime+1) - sort.SearchInts(endTime, queryTime)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 为 数组的长度。排序需要的时间为 $O(n \\log n)$，二分查找的时间复杂度为 $O(\\log n)$。\n\n- 空间复杂度：$O(\\log n)$。排序需要的栈空间为 $O(\\log n)$。"
}