{
	"titleSlug": "ransom-note",
	"slug": "shu-jin-xin-by-leetcode-solution-ji8a",
	"url": "https://leetcode-cn.com/problems/ransom-note/solution/shu-jin-xin-by-leetcode-solution-ji8a/",
	"content": "#### 方法一：字符统计\n\n题目要求使用字符串 $\\textit{magazine}$ 中的字符来构建新的字符串 $\\textit{ransomNote}$，且$\\textit{ransomNote}$ 中的每个字符只能使用一次，只需要满足字符串 $\\textit{magazine}$ 中的每个英文字母 $(\\texttt{'a'-'z'})$ 的统计次数都大于等于 $\\textit{ransomNote}$ 中相同字母的统计次数即可。\n- 如果字符串 $\\textit{magazine}$ 的长度小于字符串 $\\textit{ransomNote}$ 的长度，则我们可以肯定 $\\textit{magazine}$ 无法构成 $\\textit{ransomNote}$，此时直接返回 $\\textit{false}$。\n- 首先统计 $\\textit{magazine}$ 中每个英文字母 $a$ 的次数 $\\textit{cnt}[a]$，再遍历统计 $\\textit{ransomNote}$ 中每个英文字母的次数，如果发现 $\\textit{ransomNote}$ 中存在某个英文字母 $c$ 的统计次数大于 $\\textit{magazine}$ 中该字母统计次数 $\\textit{cnt}[c]$，则此时我们直接返回 $\\textit{false}$。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        if (ransomNote.length() > magazine.length()) {\n            return false;\n        }\n        int[] cnt = new int[26];\n        for (char c : magazine.toCharArray()) {\n            cnt[c - 'a']++;\n        }\n        for (char c : ransomNote.toCharArray()) {\n            cnt[c - 'a']--;\n            if(cnt[c - 'a'] < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        if (ransomNote.size() > magazine.size()) {\n            return false;\n        }\n        vector<int> cnt(26);\n        for (auto & c : magazine) {\n            cnt[c - 'a']++;\n        }\n        for (auto & c : ransomNote) {\n            cnt[c - 'a']--;\n            if (cnt[c - 'a'] < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool CanConstruct(string ransomNote, string magazine) {\n        if (ransomNote.Length > magazine.Length) {\n            return false;\n        }\n        int[] cnt = new int[26];\n        foreach (char c in magazine) {\n            cnt[c - 'a']++;\n        }\n        foreach (char c in ransomNote) {\n            cnt[c - 'a']--;\n            if (cnt[c - 'a'] < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        if len(ransomNote) > len(magazine):\n            return False\n        return not collections.Counter(ransomNote) - collections.Counter(magazine)\n```\n\n```JavaScript [sol1-JavaScript]\nvar canConstruct = function(ransomNote, magazine) {\n    if (ransomNote.length > magazine.length) {\n        return false;\n    }\n    const cnt = new Array(26).fill(0);\n    for (const c of magazine) {\n        cnt[c.charCodeAt() - 'a'.charCodeAt()]++;\n    }\n    for (const c of ransomNote) {\n        cnt[c.charCodeAt() - 'a'.charCodeAt()]--;\n        if(cnt[c.charCodeAt() - 'a'.charCodeAt()] < 0) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n\n```go [sol1-Golang]\nfunc canConstruct(ransomNote, magazine string) bool {\n    if len(ransomNote) > len(magazine) {\n        return false\n    }\n    cnt := [26]int{}\n    for _, ch := range magazine {\n        cnt[ch-'a']++\n    }\n    for _, ch := range ransomNote {\n        cnt[ch-'a']--\n        if cnt[ch-'a'] < 0 {\n            return false\n        }\n    }\n    return true\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m + n)$，其中 $m$ 是字符串 $\\textit{ransomNote}$ 的长度，$n$ 是字符串 $\\textit{magazine}$ 的长度，我们只需要遍历两个字符一次即可。\n\n- 空间复杂度：$O(|S|)$，$S$ 是字符集，这道题中 $S$ 为全部小写英语字母，因此 $|S| = 26$。"
}