{
	"titleSlug": "count-of-matches-in-tournament",
	"slug": "bi-sai-zhong-de-pei-dui-ci-shu-by-leetco-ugvj",
	"url": "https://leetcode-cn.com/problems/count-of-matches-in-tournament/solution/bi-sai-zhong-de-pei-dui-ci-shu-by-leetco-ugvj/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n我们直接模拟题目描述中的赛制即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int numberOfMatches(int n) {\n        int ans = 0;\n        while (n > 1) {\n            if (n % 2 == 0) {\n                ans += n / 2;\n                n /= 2;\n            }\n            else {\n                ans += (n - 1) / 2;\n                n = (n - 1) / 2 + 1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int numberOfMatches(int n) {\n        int ans = 0;\n        while (n > 1) {\n            if (n % 2 == 0) {\n                ans += n / 2;\n                n /= 2;\n            } else {\n                ans += (n - 1) / 2;\n                n = (n - 1) / 2 + 1;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int NumberOfMatches(int n) {\n        int ans = 0;\n        while (n > 1) {\n            if (n % 2 == 0) {\n                ans += n / 2;\n                n /= 2;\n            } else {\n                ans += (n - 1) / 2;\n                n = (n - 1) / 2 + 1;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def numberOfMatches(self, n: int) -> int:\n        ans = 0\n        while n > 1:\n            if n % 2 == 0:\n                ans += n // 2\n                n //= 2\n            else:\n                ans += (n - 1) // 2\n                n = (n - 1) // 2 + 1\n        return ans\n```\n\n```Golang [sol1-Golang]\nfunc numberOfMatches(n int) int {\n\tans := 0\n\tfor n > 1 {\n\t\tif n%2 == 0 {\n\t\t\tans += n / 2\n\t\t\tn /= 2\n\t\t} else {\n\t\t\tans += (n - 1) / 2\n\t\t\tn = (n-1)/2 + 1\n\t\t}\n\t}\n\treturn ans\n}\n```\n\n```C [sol1-C]\nint numberOfMatches(int n){\n    int ans = 0;\n    while (n > 1) {\n        if (n % 2 == 0) {\n            ans += n / 2;\n            n /= 2;\n        } else {\n            ans += (n - 1) / 2;\n            n = (n - 1) / 2 + 1;\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar numberOfMatches = function(n) {\n    let ans = 0;\n    while (n > 1) {\n        if (n % 2 === 0) {\n            ans += Math.floor(n / 2);\n            n /= 2;\n        } else {\n            ans += Math.floor((n - 1) / 2);\n            n = Math.floor((n - 1) / 2) + 1;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$。每一轮后会有一半（向下取整）数量的队伍无法晋级，因此轮数为 $O(\\log n)$。每一轮需要 $O(1)$ 的时间进行计算。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：数学\n\n**思路与算法**\n\n在每一场比赛中，输的队伍无法晋级，且不会再参加后续的比赛。由于最后只决出一个获胜队伍，因此就有 $n-1$ 个无法晋级的队伍，也就是会有 $n-1$ 场比赛。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int numberOfMatches(int n) {\n        return n - 1;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int numberOfMatches(int n) {\n        return n - 1;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int NumberOfMatches(int n) {\n        return n - 1;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def numberOfMatches(self, n: int) -> int:\n        return n - 1\n```\n\n```Golang [sol2-Golang]\nfunc numberOfMatches(n int) int {\n\treturn n - 1\n}\n```\n\n```C [sol2-C]\nint numberOfMatches(int n){\n    return n - 1;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar numberOfMatches = function(n) {\n    return n - 1\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$。\n\n- 空间复杂度：$O(1)$。"
}