{
	"titleSlug": "special-array-with-x-elements-greater-than-or-equal-x",
	"slug": "te-shu-shu-zu-de-te-zheng-zhi-by-leetcod-9wfo",
	"url": "https://leetcode-cn.com/problems/special-array-with-x-elements-greater-than-or-equal-x/solution/te-shu-shu-zu-de-te-zheng-zhi-by-leetcod-9wfo/",
	"content": "#### 方法一：降序排序 + 一次遍历\n\n**思路与算法**\n\n我们可以首先将数组进行降序排序，这样一来，我们就可以通过遍历的方式得到数组的特征值了。\n\n根据特征值 $x$ 的定义，$x$ 一定是在 $[1, n]$ 范围内的一个整数，其中 $n$ 是数组 $\\textit{nums}$ 的长度。因此，我们可以遍历 $[1, n]$ 并判断某个整数 $i$ 是否为特征值。\n\n若 $i$ 为特征值，那么 $\\textit{nums}$ 中恰好有 $i$ 个元素大于等于 $i$。由于数组已经降序排序，说明 $\\textit{nums}[i-1]$ 必须大于等于 $i$，并且 $\\textit{nums}[i]$（如果存在）必须小于 $i$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int specialArray(vector<int>& nums) {\n        sort(nums.begin(), nums.end(), greater<int>());\n        int n = nums.size();\n        for (int i = 1; i <= n; ++i) {\n            if (nums[i - 1] >= i && (i == n || nums[i] < i)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int specialArray(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        for (int i = 0, j = n - 1; i < j; i++, j--) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (nums[i - 1] >= i && (i == n || nums[i] < i)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int SpecialArray(int[] nums) {\n        Array.Sort(nums);\n        int n = nums.Length;\n        for (int i = 0, j = n - 1; i < j; i++, j--) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (nums[i - 1] >= i && (i == n || nums[i] < i)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def specialArray(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        n = len(nums)\n        for i in range(1, n + 1):\n            if nums[i - 1] >= i and (i == n or nums[i] < i):\n                return i\n        return -1\n```\n\n```C [sol1-C]\nstatic inline int cmp(const void *pa, const void *pb) {\n    return *(int *)pb - *(int *)pa;\n}\n\nint specialArray(int* nums, int numsSize) {\n    qsort(nums, numsSize, sizeof(int), cmp);\n    for (int i = 1; i <= numsSize; ++i) {\n        if (nums[i - 1] >= i && (i == numsSize || nums[i] < i)) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n```go [sol1-Golang]\nfunc specialArray(nums []int) int {\n    sort.Sort(sort.Reverse(sort.IntSlice(nums)))\n    for i, n := 1, len(nums); i <= n; i++ {\n        if nums[i-1] >= i && (i == n || nums[i] < i) {\n            return i\n        }\n    }\n    return -1\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar specialArray = function(nums) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    for (let i = 0, j = n - 1; i < j; i++, j--) {\n        const temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (nums[i - 1] >= i && (i === n || nums[i] < i)) {\n            return i;\n        }\n    }\n    return -1;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(\\log n)$，即为排序需要的栈空间。"
}