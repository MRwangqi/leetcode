{
	"titleSlug": "minimum-difficulty-of-a-job-schedule",
	"slug": "-by-lucian-6-8smp",
	"url": "https://leetcode-cn.com/problems/minimum-difficulty-of-a-job-schedule/solution/-by-lucian-6-8smp/",
	"content": "# **思路：**\r\n1.工作必须顺序完成，那么后面的最大工作难度与前面的相关，可以想到动态规划\r\n2.天数为d，故而需要对d天的每天的工作难度进行计算，设dp数组为`f[n][d + 1]`\r\n3.其中第二天的最小值`f[i][2]` = `f[j][1]`在`[0, i - 1]`的最小值 + `jobDifficult[j + 1, i]`的最大难度。\r\n其他天数以此类推....\r\n```\r\nclass Solution {\r\n    public int minDifficulty(int[] jd, int d) {\r\n        int n = jd.length;\r\n        //总天数小于计划天数直接返回-1\r\n        if(n < d) return -1;\r\n        int[][] f = new int[n][d + 1];\r\n        for(int i = 0; i < n; i++){\r\n            Arrays.fill(f[i], Integer.MAX_VALUE / 2);\r\n        }\r\n        //初始化\r\n        f[0][1] = jd[0];\r\n        for(int i = 1; i < n; i++){\r\n            int[] max = new int[i + 1];\r\n            max[i] = jd[i];\r\n            //倒序从i到0的最大值\r\n            for(int k = i - 1; k >= 0; k--){\r\n                max[k] = Math.max(max[k + 1], jd[k]);\r\n            }\r\n            //当前可以组成的最大天数为min(i + 1, d)\r\n            for(int j = Math.min(i + 1, d); j > 1 ; j--){\r\n                //求出当前计划天数难度和的最小值\r\n                //因为后面的各个难度和需要用到前面的各个难度和的最小值，所以需要正序遍历\r\n                for(int k = 0; k < i; k++){\r\n                    f[i][j] = Math.min(f[i][j], f[k][j - 1] + max[k + 1]);    \r\n                }    \r\n            }\r\n            //max[0]表示[0, i]难度的最大值\r\n            f[i][1] = max[0];\r\n        }\r\n        return f[n - 1][d];\r\n    }\r\n}\r\n```\r\n"
}