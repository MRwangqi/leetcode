{
	"titleSlug": "shortest-supersequence-lcci",
	"slug": "by-stormsunshine-4i14",
	"url": "https://leetcode-cn.com/problems/shortest-supersequence-lcci/solution/by-stormsunshine-4i14/",
	"content": "# 解法\r\n\r\n## 思路和算法\r\n\r\n如果长数组的下标范围 $[\\textit{start}, \\textit{end}]$ 的子数组包含短数组中的每个元素，则将子数组的左端点向左移动或将子数组的右端点向右移动之后，得到更长的子数组，同样包含短数组中的每个元素。以下将长数组中包含短数组所有的元素的子数组称为「包含子数组」，将长数组中包含短数组所有的元素的最短子数组称为「最短包含子数组」。\r\n\r\n考虑两个不同下标 $\\textit{end}_1$ 和 $\\textit{end}_2$，其中 $\\textit{end}_1 < \\textit{end}_2$，分别以这两个下标作为结束下标，寻找最短包含子数组，将这两个最短包含子数组的开始下标分别记为 $\\textit{start}_1$ 和 $\\textit{start}_2$，则必有 $\\textit{start}_1 \\le \\textit{start}_2$。因此，需要对长数组中的每个下标寻找以该下标作为结束下标的最短包含子数组。\r\n\r\n可以使用变长滑动窗口寻找长数组中的以每个下标作为结束下标的最短包含子数组。用 $[\\textit{start}, \\textit{end}]$ 表示滑动窗口，初始时 $\\textit{start} = \\textit{end} = 0$。将滑动窗口的右端点 $\\textit{end}$ 向右移动，移动过程中维护滑动窗口的左端点 $\\textit{start}$，对于每个 $\\textit{end}$ 寻找最短包含子数组。\r\n\r\n初始时，最短包含子数组的开始下标为 $-1$，长度为 $+\\infty$。使用哈希表记录每个元素在子数组中的出现次数与在短数组中的出现次数之差，哈希表只记录在短数组中出现的元素。\r\n\r\n由于短数组中的每个元素各不相同，因此首先遍历短数组，将短数组中的每个元素在哈希表中的出现次数记为 $-1$，然后使用滑动窗口遍历长数组。对于每个右端点 $\\textit{end}$，执行如下操作。\r\n\r\n1. 如果 $\\textit{big}[\\textit{end}]$ 在哈希表中，则将该元素在哈希表中的次数加 $1$。\r\n\r\n2. 如果滑动窗口 $[\\textit{start}, \\textit{end}]$ 中的子数组是包含子数组，执行如下操作，直到滑动窗口 $[\\textit{start}, \\textit{end}]$ 中的子数组不是包含子数组。\r\n\r\n   1. 如果当前子数组的长度小于最短包含子数组的长度，则将最短包含子数组的开始下标更新为 $\\textit{start}$，长度更新为 $\\textit{end} - \\textit{start} + 1$。\r\n\r\n   2. 如果 $\\textit{big}[\\textit{start}]$ 在哈希表中，则将该元素在哈希表中的次数减 $1$。\r\n\r\n   3. 将 $\\textit{start}$ 向右移动一位。\r\n\r\n3. 此时的滑动窗口 $[\\textit{start}, \\textit{end}]$ 中的子数组为以 $\\textit{end}$ 作为结束下标的最长非包含子数组。如果 $\\textit{start} > 0$，则以 $\\textit{end}$ 作为结束下标的最短包含子数组为下标范围 $[\\textit{start} - 1, \\textit{end}]$ 的子数组，该子数组已经被遍历到。\r\n\r\n上述过程中，判断一个子数组是否为包含子数组的依据是哈希表中的每个元素的出现次数之差，如果哈希表中的每个元素的出现次数之差都非负则子数组是包含子数组，否则子数组不是包含子数组。\r\n\r\n哈希表中包含短数组的所有元素，如果直接遍历哈希表判断子数组是否为包含子数组，则时间复杂度过高。由于每次移动时，只会有一个元素的出现次数有变化，因此可以将每个子数组的判断时间降低到 $O(1)$。\r\n\r\n遍历短数组并更新哈希表之后，哈希表中的元素个数即为短数组的长度。维护一个计数器统计出现次数之差非负的元素个数，则可根据计数器的值判断当前子数组是否为包含子数组。\r\n\r\n初始时，计数器的值为 $0$。对于每个在短数组中出现的元素，每次更新元素在哈希表中的次数之后，需要更新计数器的值，更新方法如下。\r\n\r\n- 当一个元素在哈希表中的次数加 $1$ 之后，如果次数变成 $0$，则将计数器的值加 $1$。\r\n\r\n- 当一个元素在哈希表中的次数减 $1$ 之后，如果次数变成 $-1$，则将计数器的值减 $1$。\r\n\r\n根据计数器的值即可快速判断当前子数组是否为包含子数组。当计数器的值等于短数组的长度，当前子数组为包含子数组，否则当前子数组不为包含子数组。由此可以不需要遍历哈希表，在 $O(1)$ 时间内判断每个子数组是否为包含子数组。\r\n\r\n遍历结束之后，即可得到长数组中的最短包含子数组。由于滑动窗口的遍历方向是从左到右，且只有当子数组的长度严格小于最短包含子数组的长度时才会更新最短包含子数组的开始下标和长度，因此当有多个最短包含子数组时，得到的是开始下标最小的最短包含子数组。\r\n\r\n特别地，如果遍历结束之后，最短包含子数组的开始下标为 $-1$，则长数组中不存在包含子数组，返回空数组。\r\n\r\n## 证明\r\n\r\n为了证明上述解法的正确性，需要证明对于每个 $\\textit{start}$，其对应的 $\\textit{end}$ 满足下标范围 $[\\textit{start}, \\textit{end}]$ 中的子数组为以 $\\textit{start}$ 作为开始下标的最短包含子数组。这里的对应表示当结束下标位于 $\\textit{end}$ 时，开始下标会经过 $\\textit{start}$。\r\n\r\n假设以 $\\textit{start}$ 作为开始下标的最短包含子数组的下标范围不是 $[\\textit{start}, \\textit{end}]$，则存在下标 $\\textit{end}' < \\textit{end}$ 使得下标范围 $[\\textit{start}, \\textit{end}']$ 中的子数组为以 $\\textit{start}$ 作为开始下标的最短包含子数组。当结束下标位于 $\\textit{end}'$ 时，对于所有 $\\textit{start}' \\le \\textit{start}$，下标范围 $[\\textit{start}', \\textit{end}']$ 中的子数组都是包含子数组，因此开始下标会向右移动到 $\\textit{start}$ 右边。当结束下标位于 $\\textit{end}$ 时，开始下标已经大于 $\\textit{start}$，与 $\\textit{start}$ 对应 $\\textit{end}$ 矛盾。\r\n\r\n因此，以 $\\textit{start}$ 作为开始下标的最短包含子数组的下标范围是 $[\\textit{start}, \\textit{end}]$。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public int[] shortestSeq(int[] big, int[] small) {\r\n        int shortestStart = -1;\r\n        int shortestLength = Integer.MAX_VALUE;\r\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\r\n        int m = big.length, n = small.length;\r\n        for (int i = 0; i < n; i++) {\r\n            int num = small[i];\r\n            counts.put(num, -1);\r\n        }\r\n        int meets = 0;\r\n        int start = 0, end = 0;\r\n        while (end < m) {\r\n            int curr = big[end];\r\n            if (counts.containsKey(curr)) {\r\n                counts.put(curr, counts.getOrDefault(curr, 0) + 1);\r\n                if (counts.get(curr) == 0) {\r\n                    meets++;\r\n                }\r\n            }\r\n            while (meets == n) {\r\n                if (end - start + 1 < shortestLength) {\r\n                    shortestStart = start;\r\n                    shortestLength = end - start + 1;\r\n                }\r\n                int prev = big[start];\r\n                if (counts.containsKey(prev)) {\r\n                    counts.put(prev, counts.get(prev) - 1);\r\n                    if (counts.get(prev) < 0) {\r\n                        meets--;\r\n                    }\r\n                }\r\n                start++;\r\n            }\r\n            end++;\r\n        }\r\n        return shortestStart < 0 ? new int[0] : new int[]{shortestStart, shortestStart + shortestLength - 1};\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public int[] ShortestSeq(int[] big, int[] small) {\r\n        int shortestStart = -1;\r\n        int shortestLength = int.MaxValue;\r\n        IDictionary<int, int> counts = new Dictionary<int, int>();\r\n        int m = big.Length, n = small.Length;\r\n        for (int i = 0; i < n; i++) {\r\n            int num = small[i];\r\n            counts.Add(num, -1);\r\n        }\r\n        int meets = 0;\r\n        int start = 0, end = 0;\r\n        while (end < m) {\r\n            int curr = big[end];\r\n            if (counts.ContainsKey(curr)) {\r\n                counts.TryAdd(curr, 0);\r\n                counts[curr]++;\r\n                if (counts[curr] == 0) {\r\n                    meets++;\r\n                }\r\n            }\r\n            while (meets == n) {\r\n                if (end - start + 1 < shortestLength) {\r\n                    shortestStart = start;\r\n                    shortestLength = end - start + 1;\r\n                }\r\n                int prev = big[start];\r\n                if (counts.ContainsKey(prev)) {\r\n                    counts[prev]--;\r\n                    if (counts[prev] < 0) {\r\n                        meets--;\r\n                    }\r\n                }\r\n                start++;\r\n            }\r\n            end++;\r\n        }\r\n        return shortestStart < 0 ? new int[0] : new int[]{shortestStart, shortestStart + shortestLength - 1};\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(m + n)$，其中 $m$ 和 $n$ 分别是长数组和短数组的长度。需要首先遍历短数组计算每个元素的次数，然后使用滑动窗口遍历长数组，滑动窗口的左右端点最多各遍历长数组一次，每次移动需要 $O(1)$ 的时间判断当前子数组是否为包含子数组，因此时间复杂度是 $O(m + n)$。\r\n\r\n- 空间复杂度：$O(n)$，其中 $n$ 是长数组和短数组的长度。哈希表需要 $O(n)$ 的空间。"
}