{
	"titleSlug": "maximum-binary-tree",
	"slug": "zui-da-er-cha-shu-by-leetcode-solution-lbeo",
	"url": "https://leetcode-cn.com/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/",
	"content": "#### 方法一：递归\n\n**思路与算法**\n\n最简单的方法是直接按照题目描述进行模拟。\n\n我们用递归函数 $\\text{construct}(\\textit{nums}, \\textit{left}, \\textit{right})$ 表示对数组 $\\textit{nums}$ 中从 $\\textit{nums}[\\textit{left}]$ 到 $\\textit{nums}[\\textit{right}]$ 的元素构建一棵树。我们首先找到这一区间中的最大值，记为 $\\textit{nums}$ 中从 $\\textit{nums}[\\textit{best}]$，这样就确定了根节点的值。随后我们就可以进行递归：\n\n- 左子树为 $\\text{construct}(\\textit{nums}, \\textit{left}, \\textit{best}-1)$；\n\n- 右子树为 $\\text{construct}(\\textit{nums}, \\textit{best}+1, \\textit{right})$。\n\n当递归到一个无效的区间（即 $\\textit{left} > \\textit{right}$）时，便可以返回一棵空的树。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        return construct(nums, 0, nums.size() - 1);\n    }\n\n    TreeNode* construct(const vector<int>& nums, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int best = left;\n        for (int i = left + 1; i <= right; ++i) {\n            if (nums[i] > nums[best]) {\n                best = i;\n            }\n        }\n        TreeNode* node = new TreeNode(nums[best]);\n        node->left = construct(nums, left, best - 1);\n        node->right = construct(nums, best + 1, right);\n        return node;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        return construct(nums, 0, nums.length - 1);\n    }\n\n    public TreeNode construct(int[] nums, int left, int right) {\n        if (left > right) {\n            return null;\n        }\n        int best = left;\n        for (int i = left + 1; i <= right; ++i) {\n            if (nums[i] > nums[best]) {\n                best = i;\n            }\n        }\n        TreeNode node = new TreeNode(nums[best]);\n        node.left = construct(nums, left, best - 1);\n        node.right = construct(nums, best + 1, right);\n        return node;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public TreeNode ConstructMaximumBinaryTree(int[] nums) {\n        return Construct(nums, 0, nums.Length - 1);\n    }\n\n    public TreeNode Construct(int[] nums, int left, int right) {\n        if (left > right) {\n            return null;\n        }\n        int best = left;\n        for (int i = left + 1; i <= right; ++i) {\n            if (nums[i] > nums[best]) {\n                best = i;\n            }\n        }\n        TreeNode node = new TreeNode(nums[best]);\n        node.left = Construct(nums, left, best - 1);\n        node.right = Construct(nums, best + 1, right);\n        return node;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:\n        def construct(left: int, right: int) -> Optional[TreeNode]:\n            if left > right:\n                return None\n            \n            best = left\n            for i in range(left + 1, right + 1):\n                if nums[i] > nums[best]:\n                    best = i\n        \n            node = TreeNode(nums[best])\n            node.left = construct(left, best - 1)\n            node.right = construct(best + 1, right)\n            return node\n        \n        return construct(0, len(nums) - 1)\n```\n\n```C [sol1-C]\nstruct TreeNode* construct(const int* nums, int left, int right) {\n    if (left > right) {\n        return NULL;\n    }\n    int best = left;\n    for (int i = left + 1; i <= right; ++i) {\n        if (nums[i] > nums[best]) {\n            best = i;\n        }\n    }\n    struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    node->val = nums[best];\n    node->left = construct(nums, left, best - 1);\n    node->right = construct(nums, best + 1, right);\n    return node;\n}\n\nstruct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize){\n    return construct(nums, 0, numsSize - 1);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar constructMaximumBinaryTree = function(nums) {\n    const construct = (nums, left, right) => {\n        if (left > right) {\n            return null;\n        }\n        let best = left;\n        for (let i = left + 1; i <= right; ++i) {\n            if (nums[i] > nums[best]) {\n                best = i;\n            }\n        }\n        const node = new TreeNode(nums[best]);\n        node.left = construct(nums, left, best - 1);\n        node.right = construct(nums, best + 1, right);\n        return node;\n    }\n    return construct(nums, 0, nums.length - 1);\n};\n```\n\n```go [sol1-Golang]\nfunc constructMaximumBinaryTree(nums []int) *TreeNode {\n    if len(nums) == 0 {\n        return nil\n    }\n    best := 0\n    for i, num := range nums {\n        if num > nums[best] {\n            best = i\n        }\n    }\n    return &TreeNode{nums[best], constructMaximumBinaryTree(nums[:best]), constructMaximumBinaryTree(nums[best+1:])}\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。在最坏的情况下，数组严格递增或递减，需要递归 $n$ 层，第 $i~(0 \\leq i < n)$ 层需要遍历 $n-i$ 个元素以找出最大值，总时间复杂度为 $O(n^2)$。\n\n- 空间复杂度：$O(n)$，即为最坏情况下需要使用的栈空间。\n\n#### 方法二：单调栈\n\n**思路与算法**\n\n我们可以将题目中构造树的过程等价转换为下面的构造过程：\n\n- 初始时，我们只有一个根节点，其中存储了整个数组；\n\n- 在每一步操作中，我们可以「任选」一个存储了超过一个数的节点，找出其中的最大值并存储在该节点。最大值左侧的数组部分下放到该节点的左子节点，右侧的数组部分下放到该节点的右子节点；\n\n- 如果所有的节点都恰好存储了一个数，那么构造结束。\n\n由于最终构造出的是一棵树，因此无需按照题目的要求「递归」地进行构造，而是每次可以「任选」一个节点进行构造。这里可以类比一棵树的「深度优先搜索」和「广度优先搜索」，二者都可以起到遍历整棵树的效果。\n\n既然可以任意进行选择，那么我们不妨每次选择数组中最大值**最大**的那个节点进行构造。这样一来，我们就可以保证按照数组中元素降序排序的顺序依次构造每个节点。因此：\n\n> 当我们选择的节点中数组的最大值为 $\\textit{nums}[i]$ 时，所有大于 $\\textit{nums}[i]$ 的元素已经被构造过（即被单独放入某一个节点中），所有小于 $\\textit{nums}[i]$ 的元素还没有被构造过。\n\n这就说明：\n\n> 在最终构造出的树上，以 $\\textit{nums}[i]$ 为根节点的子树，在原数组中对应的区间，左边界为 **$\\textit{nums}[i]$ 左侧第一个比它大的元素所在的位置**，右边界为 **$\\textit{nums}[i]$ 右侧第一个比它大的元素所在的位置**。左右边界均为开边界。\n> \n> 如果某一侧边界不存在，则那一侧边界为数组的边界。如果两侧边界均不存在，说明其为最大值，即根节点。\n\n并且：\n\n> $\\textit{nums}[i]$ 的父结点是两个边界中较小的那个元素对应的节点。\n\n因此，我们的任务变为：找出每一个元素左侧和右侧第一个比它大的元素所在的位置。这就是一个经典的单调栈问题了，可以参考 [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)。如果左侧的元素较小，那么该元素就是左侧元素的右子节点；如果右侧的元素较小，那么该元素就是右侧元素的左子节点。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> stk;\n        vector<int> left(n, -1), right(n, -1);\n        vector<TreeNode*> tree(n);\n        for (int i = 0; i < n; ++i) {\n            tree[i] = new TreeNode(nums[i]);\n            while (!stk.empty() && nums[i] > nums[stk.back()]) {\n                right[stk.back()] = i;\n                stk.pop_back();\n            }\n            if (!stk.empty()) {\n                left[i] = stk.back();\n            }\n            stk.push_back(i);\n        }\n\n        TreeNode* root = nullptr;\n        for (int i = 0; i < n; ++i) {\n            if (left[i] == -1 && right[i] == -1) {\n                root = tree[i];\n            }\n            else if (right[i] == -1 || (left[i] != -1 && nums[left[i]] < nums[right[i]])) {\n                tree[left[i]]->right = tree[i];\n            }\n            else {\n                tree[right[i]]->left = tree[i];\n            }\n        }\n        return root;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        int n = nums.length;\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Arrays.fill(left, -1);\n        Arrays.fill(right, -1);\n        TreeNode[] tree = new TreeNode[n];\n        for (int i = 0; i < n; ++i) {\n            tree[i] = new TreeNode(nums[i]);\n            while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {\n                right[stack.pop()] = i;\n            }\n            if (!stack.isEmpty()) {\n                left[i] = stack.peek();\n            }\n            stack.push(i);\n        }\n\n        TreeNode root = null;\n        for (int i = 0; i < n; ++i) {\n            if (left[i] == -1 && right[i] == -1) {\n                root = tree[i];\n            } else if (right[i] == -1 || (left[i] != -1 && nums[left[i]] < nums[right[i]])) {\n                tree[left[i]].right = tree[i];\n            } else {\n                tree[right[i]].left = tree[i];\n            }\n        }\n        return root;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public TreeNode ConstructMaximumBinaryTree(int[] nums) {\n        int n = nums.Length;\n        Stack<int> stack = new Stack<int>();\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Array.Fill(left, -1);\n        Array.Fill(right, -1);\n        TreeNode[] tree = new TreeNode[n];\n        for (int i = 0; i < n; ++i) {\n            tree[i] = new TreeNode(nums[i]);\n            while (stack.Count > 0 && nums[i] > nums[stack.Peek()]) {\n                right[stack.Pop()] = i;\n            }\n            if (stack.Count > 0) {\n                left[i] = stack.Peek();\n            }\n            stack.Push(i);\n        }\n\n        TreeNode root = null;\n        for (int i = 0; i < n; ++i) {\n            if (left[i] == -1 && right[i] == -1) {\n                root = tree[i];\n            } else if (right[i] == -1 || (left[i] != -1 && nums[left[i]] < nums[right[i]])) {\n                tree[left[i]].right = tree[i];\n            } else {\n                tree[right[i]].left = tree[i];\n            }\n        }\n        return root;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:\n        n = len(nums)\n        stk = list()\n        left, right = [-1] * n, [-1] * n\n        tree = [None] * n\n\n        for i in range(n):\n            tree[i] = TreeNode(nums[i])\n            while stk and nums[i] > nums[stk[-1]]:\n                right[stk[-1]] = i\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        \n        root = None\n        for i in range(n):\n            if left[i] == right[i] == -1:\n                root = tree[i]\n            elif right[i] == -1 or (left[i] != -1 and nums[left[i]] < nums[right[i]]):\n                tree[left[i]].right = tree[i]\n            else:\n                tree[right[i]].left = tree[i]\n        \n        return root\n```\n\n```C [sol2-C]\nstruct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize) {\n    int *stack = (int *)malloc(sizeof(int) * numsSize);\n    int *left = (int *)malloc(sizeof(int) * numsSize);\n    int *right = (int *)malloc(sizeof(int) * numsSize);\n    memset(left, -1, sizeof(int) * numsSize);\n    memset(right, -1, sizeof(int) * numsSize);\n    struct TreeNode** tree = (struct TreeNode **)malloc(sizeof(struct TreeNode*) * numsSize);\n    int top = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        tree[i] = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        tree[i]->val = nums[i];\n        tree[i]->left = NULL;\n        tree[i]->right = NULL;\n        while (top > 0 && nums[i] > nums[stack[top - 1]]) {\n            right[stack[top - 1]] = i;\n            top--;\n        }\n        if (top > 0) {\n            left[i] = stack[top - 1];\n        }\n        stack[top++] = i;\n    }\n\n    struct TreeNode* root = NULL;\n    for (int i = 0; i < numsSize; ++i) {\n        if (left[i] == -1 && right[i] == -1) {\n            root = tree[i];\n        }\n        else if (right[i] == -1 || (left[i] != -1 && nums[left[i]] < nums[right[i]])) {\n            tree[left[i]]->right = tree[i];\n        }\n        else {\n            tree[right[i]]->left = tree[i];\n        }\n    }\n    free(left);\n    free(right);\n    free(stack);\n    return root;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar constructMaximumBinaryTree = function(nums) {\n    const n = nums.length;\n    const stack = [];\n    const left = new Array(n).fill(-1);\n    const right = new Array(n).fill(-1);\n    const tree = new Array(n).fill(-1);\n    for (let i = 0; i < n; ++i) {\n        tree[i] = new TreeNode(nums[i]);\n        while (stack.length && nums[i] > nums[stack[stack.length - 1]]) {\n            right[stack.pop()] = i;\n        }\n        if (stack.length) {\n            left[i] = stack[stack.length - 1];\n        }\n        stack.push(i);\n    }\n\n    let root = null;\n    for (let i = 0; i < n; ++i) {\n        if (left[i] === -1 && right[i] === -1) {\n            root = tree[i];\n        } else if (right[i] === -1 || (left[i] !== -1 && nums[left[i]] < nums[right[i]])) {\n            tree[left[i]].right = tree[i];\n        } else {\n            tree[right[i]].left = tree[i];\n        }\n    }\n    return root;\n};\n```\n\n```go [sol2-Golang]\nfunc constructMaximumBinaryTree(nums []int) *TreeNode {\n    n := len(nums)\n    left := make([]int, n)\n    right := make([]int, n)\n    for i := range right {\n        right[i] = -1\n    }\n    tree := make([]*TreeNode, n)\n    stk := []int{-1}\n    for i, num := range nums {\n        tree[i] = &TreeNode{Val: num}\n        for len(stk) > 1 && num > nums[stk[len(stk)-1]] {\n            right[stk[len(stk)-1]] = i\n            stk = stk[:len(stk)-1]\n        }\n        left[i] = stk[len(stk)-1]\n        stk = append(stk, i)\n    }\n\n    var root *TreeNode\n    for i, node := range tree {\n        l, r := left[i], right[i]\n        if l == -1 && r == -1 {\n            root = node\n        } else if r == -1 || l != -1 && nums[l] < nums[r] {\n            tree[l].Right = node\n        } else {\n            tree[r].Left = node\n        }\n    }\n    return root\n}\n```\n\n我们还可以把最后构造树的过程放进单调栈求解的步骤中，省去用来存储左右边界的数组。下面的代码理解起来较为困难，同一个节点的左右子树会被多次赋值，读者可以仔细品味其妙处所在。\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> stk;\n        vector<TreeNode*> tree(n);\n        for (int i = 0; i < n; ++i) {\n            tree[i] = new TreeNode(nums[i]);\n            while (!stk.empty() && nums[i] > nums[stk.back()]) {\n                tree[i]->left = tree[stk.back()];\n                stk.pop_back();\n            }\n            if (!stk.empty()) {\n                tree[stk.back()]->right = tree[i];\n            }\n            stk.push_back(i);\n        }\n        return tree[stk[0]];\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        int n = nums.length;\n        List<Integer> stack = new ArrayList<Integer>();\n        TreeNode[] tree = new TreeNode[n];\n        for (int i = 0; i < n; ++i) {\n            tree[i] = new TreeNode(nums[i]);\n            while (!stack.isEmpty() && nums[i] > nums[stack.get(stack.size() - 1)]) {\n                tree[i].left = tree[stack.get(stack.size() - 1)];\n                stack.remove(stack.size() - 1);\n            }\n            if (!stack.isEmpty()) {\n                tree[stack.get(stack.size() - 1)].right = tree[i];\n            }\n            stack.add(i);\n        }\n        return tree[stack.get(0)];\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public TreeNode ConstructMaximumBinaryTree(int[] nums) {\n        int n = nums.Length;\n        IList<int> stack = new List<int>();\n        TreeNode[] tree = new TreeNode[n];\n        for (int i = 0; i < n; ++i) {\n            tree[i] = new TreeNode(nums[i]);\n            while (stack.Count > 0 && nums[i] > nums[stack[stack.Count - 1]]) {\n                tree[i].left = tree[stack[stack.Count - 1]];\n                stack.RemoveAt(stack.Count - 1);\n            }\n            if (stack.Count > 0) {\n                tree[stack[stack.Count - 1]].right = tree[i];\n            }\n            stack.Add(i);\n        }\n        return tree[stack[0]];\n    }\n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:\n        n = len(nums)\n        stk = list()\n        tree = [None] * n\n\n        for i in range(n):\n            tree[i] = TreeNode(nums[i])\n            while stk and nums[i] > nums[stk[-1]]:\n                tree[i].left = tree[stk[-1]]\n                stk.pop()\n            if stk:\n                tree[stk[-1]].right = tree[i]\n            stk.append(i)\n        \n        return tree[stk[0]]\n```\n\n```C [sol3-C]\nstruct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize) {\n    int *stack = (int *)malloc(sizeof(int) * numsSize);\n    struct TreeNode** tree = (struct TreeNode **)malloc(sizeof(struct TreeNode*) * numsSize);\n    int top = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        tree[i] = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n        tree[i]->val = nums[i];\n        tree[i]->left = NULL;\n        tree[i]->right = NULL;\n        while (top > 0 && nums[i] > nums[stack[top - 1]]) {\n            tree[i]->left = tree[stack[top - 1]];\n            top--;\n        }\n        if (top > 0) {\n            tree[stack[top - 1]]->right = tree[i];\n        }\n        stack[top++] = i;\n    }\n    int root = stack[0];\n    free(stack);\n    return tree[root];\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar constructMaximumBinaryTree = function(nums) {\n    const n = nums.length;\n    const stack = [];\n    const tree = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        tree[i] = new TreeNode(nums[i]);\n        while (stack.length && nums[i] > nums[stack[stack.length - 1]]) {\n            tree[i].left = tree[stack[stack.length - 1]];\n            stack.pop();\n        }\n        if (stack.length) {\n            tree[stack[stack.length - 1]].right = tree[i];\n        }\n        stack.push(i);\n    }\n    return tree[stack[0]];\n};\n```\n\n```go [sol3-Golang]\nfunc constructMaximumBinaryTree(nums []int) *TreeNode {\n    tree := make([]*TreeNode, len(nums))\n    stk := []int{}\n    for i, num := range nums {\n        tree[i] = &TreeNode{Val: num}\n        for len(stk) > 0 && num > nums[stk[len(stk)-1]] {\n            tree[i].Left = tree[stk[len(stk)-1]]\n            stk = stk[:len(stk)-1]\n        }\n        if len(stk) > 0 {\n            tree[stk[len(stk)-1]].Right = tree[i]\n        }\n        stk = append(stk, i)\n    }\n    return tree[stk[0]]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。单调栈求解左右边界和构造树均需要 $O(n)$ 的时间。\n\n- 空间复杂度：$O(n)$，即为单调栈和数组 $\\textit{tree}$ 需要使用的空间。"
}