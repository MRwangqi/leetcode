{
	"titleSlug": "reverse-odd-levels-of-binary-tree",
	"slug": "zhi-jie-jiao-huan-zhi-by-endlesscheng-o8ze",
	"url": "https://leetcode-cn.com/problems/reverse-odd-levels-of-binary-tree/solution/zhi-jie-jiao-huan-zhi-by-endlesscheng-o8ze/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1AP411p7pK) 已出炉，欢迎点赞三连，在评论区分享你对这场周赛的看法~\r\n\r\n---\r\n\r\n#### 方法一：BFS\r\n\r\nBFS 这棵树，对于奇数层，直接交换层里面的所有元素值（交换的是元素值，不是节点）。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\r\n        q, level = [root], 0\r\n        while q[0].left:\r\n            q = list(chain.from_iterable((node.left, node.right) for node in q))\r\n            if level == 0:\r\n                for i in range(len(q) // 2):\r\n                    x, y = q[i], q[len(q) - 1 - i]\r\n                    x.val, y.val = y.val, x.val\r\n            level ^= 1\r\n        return root\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc reverseOddLevels(root *TreeNode) *TreeNode {\r\n\tq := []*TreeNode{root}\r\n\tfor level := 0; q[0].Left != nil; level ^= 1 {\r\n\t\tnext := make([]*TreeNode, 0, len(q)*2)\r\n\t\tfor _, node := range q {\r\n\t\t\tnext = append(next, node.Left, node.Right)\r\n\t\t}\r\n\t\tq = next\r\n\t\tif level == 0 {\r\n\t\t\tfor i, n := 0, len(q); i < n/2; i++ {\r\n\t\t\t\tx, y := q[i], q[n-1-i]\r\n\t\t\t\tx.Val, y.Val = y.Val, x.Val\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn root\r\n}\r\n```\r\n\r\n#### 方法二：DFS\r\n\r\n依然是交换值的思路，通过同时递归左右子树实现。\r\n\r\n不了解这一做法的同学可以做做 [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)。\r\n\r\n```py [sol2-Python3]\r\nclass Solution:\r\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\r\n        def dfs(node1: Optional[TreeNode], node2: Optional[TreeNode], is_odd_level: bool) -> None:\r\n            if node1 is None: return\r\n            if is_odd_level: node1.val, node2.val = node2.val, node1.val\r\n            dfs(node1.left, node2.right, not is_odd_level)\r\n            dfs(node1.right, node2.left, not is_odd_level)\r\n        dfs(root.left, root.right, True)\r\n        return root\r\n```\r\n\r\n```go [sol2-Go]\r\nfunc dfs(node1 *TreeNode, node2 *TreeNode, isOddLevel bool) {\r\n\tif node1 == nil {\r\n\t\treturn\r\n\t}\r\n\tif isOddLevel {\r\n\t\tnode1.Val, node2.Val = node2.Val, node1.Val\r\n\t}\r\n\tdfs(node1.Left, node2.Right, !isOddLevel)\r\n\tdfs(node1.Right, node2.Left, !isOddLevel)\r\n}\r\n\r\nfunc reverseOddLevels(root *TreeNode) *TreeNode {\r\n\tdfs(root.Left, root.Right, true)\r\n\treturn root\r\n}\r\n```\r\n"
}