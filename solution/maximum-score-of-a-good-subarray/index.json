{
	"titleSlug": "maximum-score-of-a-good-subarray",
	"slug": "by-zhen-tian-xia-tasi",
	"url": "https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray/solution/by-zhen-tian-xia-tasi/",
	"content": "### 解题思路\n此处撰写解题思路\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        //  我们考虑，对于一个数，它做最小值，它往右最多扩展到哪里，它往左最多扩展到哪里（严格大于它的下标）、\n        //  然后我们判断，它最为最小值覆盖的区间是否包含了 k ，这样就可以遍历\n        int n = nums.size();\n        vector<int> left(n,-1);\n        vector<int> right(n, n);\n        stack<int> stk;\n        for(int i = 0; i < n; i++){\n            while(!stk.empty() && nums[i] <= nums[stk.top()]){\n                stk.pop();\n            }\n            if(stk.empty()) left[i] = -1;\n            else left[i] = stk.top();\n            stk.push(i);\n        }\n        while(!stk.empty()) \n            stk.pop();\n        for(int i = n - 1; i >= 0; i--){\n            while(!stk.empty() && nums[i] <= nums[stk.top()]){\n                stk.pop();\n            }\n            if(stk.empty()) right[i] = n;\n            else right[i] = stk.top();\n            stk.push(i);\n        }\n        int ans = nums[k];\n        for(int i = 0; i < n; i++){\n            if(left[i] < k && right[i] > k){\n                ans = max(ans,nums[i]*(right[i] - left[i] - 1));\n            }\n        }\n        return ans;\n    }\n};\n```"
}