{
	"titleSlug": "uOAnQW",
	"slug": "jian-dan-mo-by-xk_-hby7",
	"url": "https://leetcode-cn.com/problems/uOAnQW/solution/jian-dan-mo-by-xk_-hby7/",
	"content": "排序，保证前cnt个最大，偶数即返回。\r\n如果是奇数：\r\n    1.找前cnt中最小的偶数，和后cnt中最大的奇数交换。\r\n    2.找前cnt中最小的奇数，和后cnt中最大的偶数交换。\r\n    3.返回1和2中较大那个\r\n    4.不存在1、2中的奇偶对，就返回0\r\n\r\n这题其实连排序都可以不需要。O(n)即可找到答案。\r\n\r\n```python\r\nclass Solution:\r\n    def maxmiumScore(self, cards: List[int], cnt: int) -> int:\r\n        cards.sort(reverse=True)\r\n        res = sum(cards[:cnt])\r\n        if res % 2 == 0:\r\n            return res\r\n        else:\r\n            last_odd,last_even=-1,-1\r\n            for i in range(cnt):\r\n                if cards[i] % 2 == 0:\r\n                    last_even = cards[i]\r\n                else:\r\n                    last_odd = cards[i]\r\n            top_odd,top_even=-1,-1\r\n            for j in range(len(cards)-1,cnt-1,-1):\r\n                if cards[j] % 2 == 0:\r\n                    top_even = cards[j]\r\n                else:\r\n                    top_odd = cards[j]\r\n            ans=0\r\n            if last_even != -1 and top_odd != -1:\r\n                ans = res - last_even + top_odd\r\n            if last_odd != -1 and top_even != -1:\r\n                t = res - last_odd + top_even\r\n                if ans > 0:\r\n                    ans = max(ans, t) \r\n                else:\r\n                    ans = t\r\n            return ans\r\n\r\n        \r\n```\r\n"
}