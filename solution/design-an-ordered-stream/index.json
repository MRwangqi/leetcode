{
	"titleSlug": "design-an-ordered-stream",
	"slug": "she-ji-you-xu-liu-by-leetcode-solution-3imb",
	"url": "https://leetcode-cn.com/problems/design-an-ordered-stream/solution/she-ji-you-xu-liu-by-leetcode-solution-3imb/",
	"content": "#### 方法一：使用数组存储 + 遍历\n\n**思路与算法**\n\n对于 $\\text{OrderedStream(int n)}$，我们在初始化时开辟一个长度为 $n+1$ 的数组 $\\textit{stream}$，用来存储后续的字符串。注意到题目中指针 $\\textit{ptr}$ 的初始值为 $1$，而多数语言数组的下标是从 $0$ 开始的，因此使用长度为 $n+1$ 的数组可以使得编码更加容易。\n\n对于 $\\text{String[] insert(int id, String value)}$，我们直接根据题目描述中的要求进行遍历即可。我们首先将 $\\textit{stream}[\\textit{id}]$ 置为 $\\textit{value}$。随后，如果 $\\textit{stream}[\\textit{id}]$ 不为空，我们就将其加入答案，并将 $\\textit{ptr}$ 增加 $1$，直到指针超出边界或 $\\textit{stream}[\\textit{id}]$ 为空时结束并返回答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass OrderedStream {\npublic:\n    OrderedStream(int n) {\n        stream.resize(n + 1);\n        ptr = 1;\n    }\n    \n    vector<string> insert(int idKey, string value) {\n        stream[idKey] = value;\n        vector<string> res;\n        while (ptr < stream.size() && !stream[ptr].empty()) {\n            res.push_back(stream[ptr]);\n            ++ptr;\n        }\n        return res;\n    }\n\nprivate:\n    vector<string> stream;\n    int ptr;\n};\n```\n\n```Java [sol1-Java]\nclass OrderedStream {\n    private String[] stream;\n    private int ptr;\n\n    public OrderedStream(int n) {\n        stream = new String[n + 1];\n        ptr = 1;\n    }\n\n    public List<String> insert(int idKey, String value) {\n        stream[idKey] = value;\n        List<String> res = new ArrayList<String>();\n        while (ptr < stream.length && stream[ptr] != null) {\n            res.add(stream[ptr]);\n            ++ptr;\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class OrderedStream {\n    private string[] stream;\n    private int ptr;\n\n    public OrderedStream(int n) {\n        stream = new string[n + 1];\n        ptr = 1;\n    }\n\n    public IList<string> Insert(int idKey, string value) {\n        stream[idKey] = value;\n        IList<string> res = new List<string>();\n        while (ptr < stream.Length && stream[ptr] != null) {\n            res.Add(stream[ptr]);\n            ++ptr;\n        }\n        return res;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass OrderedStream:\n\n    def __init__(self, n: int):\n        self.stream = [\"\"] * (n + 1)\n        self.ptr = 1\n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        stream_ = self.stream\n\n        stream_[idKey] = value\n        res = list()\n        while self.ptr < len(stream_) and stream_[self.ptr]:\n            res.append(stream_[self.ptr])\n            self.ptr += 1\n        \n        return res\n```\n\n```C [sol1-C]\ntypedef struct {\n    char **stream;\n    int streamSize;\n    int ptr;\n} OrderedStream;\n\nOrderedStream* orderedStreamCreate(int n) {\n    OrderedStream *obj = (OrderedStream *)malloc(sizeof(OrderedStream));\n    obj->stream = (char **)malloc(sizeof(char *) * (n + 1));\n    for (int i = 0; i <= n; i++) {\n        obj->stream[i] = NULL;\n    }\n    obj->streamSize = n + 1;\n    obj->ptr = 1;\n    return obj;\n}\n\nchar ** orderedStreamInsert(OrderedStream* obj, int idKey, char * value, int* retSize) {\n    obj->stream[idKey] = value;\n    char **res = (char **)malloc(sizeof(char *) * obj->streamSize);\n    int pos = 0;\n    while (obj->ptr < obj->streamSize && obj->stream[obj->ptr]) {\n        res[pos++] = obj->stream[obj->ptr];\n        obj->ptr++;\n    }\n    *retSize = pos;\n    return res;\n}\n\nvoid orderedStreamFree(OrderedStream* obj) {\n    free(obj->stream);\n    free(obj);\n}\n```\n\n```go [sol1-Golang]\ntype OrderedStream struct {\n    stream []string\n    ptr    int\n}\n\nfunc Constructor(n int) OrderedStream {\n    return OrderedStream{make([]string, n+1), 1}\n}\n\nfunc (s *OrderedStream) Insert(idKey int, value string) []string {\n    s.stream[idKey] = value\n    start := s.ptr\n    for s.ptr < len(s.stream) && s.stream[s.ptr] != \"\" {\n        s.ptr++\n    }\n    return s.stream[start:s.ptr]\n}\n```\n\n**复杂度分析**\n\n注意这里我们将字符串的固定常数 $5$ 看成常数。\n\n- 时间复杂度：\n\n    - $\\text{OrderedStream(int n)}$ 的时间复杂度为 $O(n)$；\n    \n    - $\\text{String[] insert(int id, String value)}$ 的时间复杂度为均摊 $O(1)$，这是因为我们会恰好调用该函数 $n$ 次，那么每一个字符串最多会被包含在返回数组中一次；    \n\n- 空间复杂度：$O(n)$，即为存储 $n$ 个字符串需要的空间。"
}