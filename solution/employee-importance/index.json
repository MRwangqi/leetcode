{
	"titleSlug": "employee-importance",
	"slug": "yuan-gong-de-zhong-yao-xing-by-leetcode-h6xre",
	"url": "https://leetcode-cn.com/problems/employee-importance/solution/yuan-gong-de-zhong-yao-xing-by-leetcode-h6xre/",
	"content": "#### 前言\n\n由于一个员工最多有一个直系领导，可以有零个或若干个直系下属，因此员工之间的领导和下属关系构成树的结构。给定一个员工编号，要求计算这个员工及其所有下属的重要性之和，即为找到以该员工为根节点的子树的结构中，每个员工的重要性之和。\n\n对于树结构的问题，可以使用深度优先搜索或广度优先搜索的方法解决。\n\n#### 方法一：深度优先搜索\n\n深度优先搜索的做法非常直观。根据给定的员工编号找到员工，从该员工开始遍历，对于每个员工，将其重要性加到总和中，然后对该员工的每个直系下属继续遍历，直到所有下属遍历完毕，此时的总和即为给定的员工及其所有下属的重要性之和。\n\n实现方面，由于给定的是员工编号，且每个员工的编号都不相同，因此可以使用哈希表存储每个员工编号和对应的员工，即可通过员工编号得到对应的员工。\n\n```Java [sol1-Java]\nclass Solution {\n    Map<Integer, Employee> map = new HashMap<Integer, Employee>();\n\n    public int getImportance(List<Employee> employees, int id) {\n        for (Employee employee : employees) {\n            map.put(employee.id, employee);\n        }\n        return dfs(id);\n    }\n\n    public int dfs(int id) {\n        Employee employee = map.get(id);\n        int total = employee.importance;\n        List<Integer> subordinates = employee.subordinates;\n        for (int subId : subordinates) {\n            total += dfs(subId);\n        }\n        return total;\n    }\n}\n```\n\n```C# [sol1-C#]\nclass Solution {\n    Dictionary<int, Employee> dictionary = new Dictionary<int, Employee>();\n\n    public int GetImportance(IList<Employee> employees, int id) {\n        foreach (Employee employee in employees) {\n            dictionary.Add(employee.id, employee);\n        }\n        return DFS(id);\n    }\n\n    public int DFS(int id) {\n        Employee employee = dictionary[id];\n        int total = employee.importance;\n        IList<int> subordinates = employee.subordinates;\n        foreach (int subId in subordinates) {\n            total += DFS(subId);\n        }\n        return total;\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar GetImportance = function(employees, id) {\n    const map = new Map();\n    for (const employee of employees) {\n        map.set(employee.id, employee);\n    }\n    const dfs = (id) => {\n        const employee = map.get(id);\n        let total = employee.importance;\n        const subordinates = employee.subordinates;\n        for (const subId of subordinates) {\n            total += dfs(subId);\n        }\n        return total;\n        \n    }\n\n    return dfs(id);\n};\n```\n\n```go [sol1-Golang]\nfunc getImportance(employees []*Employee, id int) (total int) {\n    mp := map[int]*Employee{}\n    for _, employee := range employees {\n        mp[employee.Id] = employee\n    }\n\n    var dfs func(int)\n    dfs = func(id int) {\n        employee := mp[id]\n        total += employee.Importance\n        for _, subId := range employee.Subordinates {\n            dfs(subId)\n        }\n    }\n    dfs(id)\n    return\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    unordered_map<int, Employee *> mp;\n\n    int dfs(int id) {\n        Employee *employee = mp[id];\n        int total = employee->importance;\n        for (int subId : employee->subordinates) {\n            total += dfs(subId);\n        }\n        return total;\n    }\n\n    int getImportance(vector<Employee *> employees, int id) {\n        for (auto &employee : employees) {\n            mp[employee->id] = employee;\n        }\n        return dfs(id);\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def getImportance(self, employees: List['Employee'], idx: int) -> int:\n        mp = {employee.id: employee for employee in employees}\n\n        def dfs(idx: int) -> int:\n            employee = mp[idx]\n            total = employee.importance + sum(dfs(subIdx) for subIdx in employee.subordinates)\n            return total\n        \n        return dfs(idx)\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是员工数量。需要遍历所有员工，在哈希表中存储员工编号和员工的对应关系，深度优先搜索对每个员工遍历一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是员工数量。空间复杂度主要取决于哈希表的空间和递归调用栈的空间，哈希表的大小为 $n$，栈的深度不超过 $n$。\n\n#### 方法二：广度优先搜索\n\n也可以使用广度优先搜索的做法。\n\n和深度优先搜索一样，使用哈希表存储每个员工编号和对应的员工，即可通过员工编号得到对应的员工。根据给定的员工编号找到员工，从该员工开始广度优先搜索，对于每个遍历到的员工，将其重要性加到总和中，最终得到的总和即为给定的员工及其所有下属的重要性之和。\n\n```Java [sol2-Java]\nclass Solution {\n    public int getImportance(List<Employee> employees, int id) {\n        Map<Integer, Employee> map = new HashMap<Integer, Employee>();\n        for (Employee employee : employees) {\n            map.put(employee.id, employee);\n        }\n        int total = 0;\n        Queue<Integer> queue = new LinkedList<Integer>();\n        queue.offer(id);\n        while (!queue.isEmpty()) {\n            int curId = queue.poll();\n            Employee employee = map.get(curId);\n            total += employee.importance;\n            List<Integer> subordinates = employee.subordinates;\n            for (int subId : subordinates) {\n                queue.offer(subId);\n            }\n        }\n        return total;\n    }\n}\n```\n\n```C# [sol2-C#]\nclass Solution {\n    public int GetImportance(IList<Employee> employees, int id) {\n        Dictionary<int, Employee> dictionary = new Dictionary<int, Employee>();\n        foreach (Employee employee in employees) {\n            dictionary.Add(employee.id, employee);\n        }\n        int total = 0;\n        Queue<int> queue = new Queue<int>();\n        queue.Enqueue(id);\n        while (queue.Count > 0) {\n            int curId = queue.Dequeue();\n            Employee employee = dictionary[curId];\n            total += employee.importance;\n            IList<int> subordinates = employee.subordinates;\n            foreach (int subId in subordinates) {\n                queue.Enqueue(subId);\n            }\n        }\n        return total;\n    }\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar GetImportance = function(employees, id) {\n    const map = new Map();\n    for (const employee of employees) {\n        map.set(employee.id, employee);\n    }\n    let total = 0;\n    const queue = [];\n    queue.push(id);\n    while (queue.length) {\n        const curId = queue.shift();\n        const employee = map.get(curId);\n        total += employee.importance;\n        const subordinates = employee.subordinates;\n        for (const subId of subordinates) {\n            queue.push(subId);\n        }\n    }\n    return total;\n};\n```\n\n```go [sol2-Golang]\nfunc getImportance(employees []*Employee, id int) (total int) {\n    mp := map[int]*Employee{}\n    for _, employee := range employees {\n        mp[employee.Id] = employee\n    }\n\n    queue := []int{id}\n    for len(queue) > 0 {\n        employee := mp[queue[0]]\n        queue = queue[1:]\n        total += employee.Importance\n        for _, subId := range employee.Subordinates {\n            queue = append(queue, subId)\n        }\n    }\n    return\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int getImportance(vector<Employee *> employees, int id) {\n        unordered_map<int, Employee *> mp;\n        for (auto &employee : employees) {\n            mp[employee->id] = employee;\n        }\n\n        int total = 0;\n        queue<int> que;\n        que.push(id);\n        while (!que.empty()) {\n            int curId = que.front();\n            que.pop();\n            Employee *employee = mp[curId];\n            total += employee->importance;\n            for (int subId : employee->subordinates) {\n                que.push(subId);\n            }\n        }\n        return total;\n    }\n};\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def getImportance(self, employees: List['Employee'], idx: int) -> int:\n        mp = {employee.id: employee for employee in employees}\n\n        total = 0\n        que = collections.deque([idx])\n        while que:\n            curIdx = que.popleft()\n            employee = mp[curIdx]\n            total += employee.importance\n            for subIdx in employee.subordinates:\n                que.append(subIdx)\n        \n        return total\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是员工数量。需要遍历所有员工，在哈希表中存储员工编号和员工的对应关系，广度优先搜索对每个员工遍历一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是员工数量。空间复杂度主要取决于哈希表的空间和队列的空间，哈希表的大小为 $n$，队列的大小不超过 $n$。"
}