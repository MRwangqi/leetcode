{
	"titleSlug": "subarray-with-elements-greater-than-varying-threshold",
	"slug": "by-endlesscheng-j6pp",
	"url": "https://leetcode-cn.com/problems/subarray-with-elements-greater-than-varying-threshold/solution/by-endlesscheng-j6pp/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1Le4y1R7xu) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n## 方法一：并查集\r\n\r\n#### 提示 1\r\n\r\n数组中的元素越大越好，不妨从大往小考虑 $\\textit{nums}[i]$。\r\n\r\n#### 提示 2\r\n\r\n子数组的长度 $k$ 越大，$\\dfrac{\\textit{threshold}}{k}$ 就越小，越能满足要求。\r\n\r\n#### 提示 3\r\n\r\n把考虑过的元素都串起来，这条链的长度就是 $k$。\r\n\r\n于是关键在于如何动态维护每条链的长度，高效地串联两条链。\r\n\r\n#### 提示 4\r\n\r\n用并查集，遍历到 $\\textit{nums}[i]$ 时，用并查集合并 $i$ 和 $i+1$，这样可以把连续访问过的位置串起来，同时维护链的长度。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\log n)$。瓶颈在排序上。\r\n- 空间复杂度：$O(n)$。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\r\n        n = len(nums)\r\n        fa = list(range(n + 1))\r\n        sz = [0] * (n + 1)\r\n        def find(x: int) -> int:\r\n            if fa[x] != x:\r\n                fa[x] = find(fa[x])\r\n            return fa[x]\r\n        for num, i in sorted(zip(nums, range(n)), reverse=True):\r\n            j = find(i + 1)\r\n            fa[i] = j  # 合并 i 和 i+1\r\n            sz[j] += sz[i] + 1\r\n            if num > threshold // sz[j]: return sz[j]\r\n        return -1\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    int[] fa;\r\n\r\n    public int validSubarraySize(int[] nums, int threshold) {\r\n        var n = nums.length;\r\n        fa = new int[n + 1];\r\n        for (var i = 0; i <= n; i++) fa[i] = i;\r\n        var sz = new int[n + 1];\r\n\r\n        var ids = IntStream.range(0, n).boxed().toArray(Integer[]::new);\r\n        Arrays.sort(ids, (i, j) -> nums[j] - nums[i]);\r\n        for (var i : ids) {\r\n            var j = find(i + 1);\r\n            fa[i] = j; // 合并 i 和 i+1\r\n            sz[j] += sz[i] + 1;\r\n            if (nums[i] > threshold / sz[j]) return sz[j];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    int find(int x) {\r\n        if (fa[x] != x) fa[x] = find(fa[x]);\r\n        return fa[x];\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int validSubarraySize(vector<int> &nums, int threshold) {\r\n        int n = nums.size();\r\n        int fa[n + 1], sz[n + 1];\r\n        iota(fa, fa + n + 1, 0);\r\n        memset(sz, 0, sizeof(sz));\r\n        function<int(int)> find = [&](int x) -> int { return fa[x] == x ? x : fa[x] = find(fa[x]); };\r\n\r\n        int ids[n];\r\n        iota(ids, ids + n, 0);\r\n        sort(ids, ids + n, [&](int i, int j) { return nums[i] > nums[j]; });\r\n        for (int i : ids) {\r\n            int j = find(i + 1);\r\n            fa[i] = j; // 合并 i 和 i+1\r\n            sz[j] += sz[i] + 1;\r\n            if (nums[i] > threshold / sz[j]) return sz[j];\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc validSubarraySize(nums []int, threshold int) int {\r\n\tn := len(nums)\r\n\ttype pair struct{ v, i int }\r\n\ta := make([]pair, n)\r\n\tfor i, v := range nums {\r\n\t\ta[i] = pair{v, i}\r\n\t}\r\n\tsort.Slice(a, func(i, j int) bool { return a[i].v > a[j].v })\r\n\r\n\tfa := make([]int, n+1)\r\n\tfor i := range fa {\r\n\t\tfa[i] = i\r\n\t}\r\n\tsz := make([]int, n+1)\r\n\tvar find func(int) int\r\n\tfind = func(x int) int {\r\n\t\tif fa[x] != x {\r\n\t\t\tfa[x] = find(fa[x])\r\n\t\t}\r\n\t\treturn fa[x]\r\n\t}\r\n\tfor _, p := range a {\r\n\t\ti := p.i\r\n\t\tj := find(i + 1)\r\n\t\tfa[i] = j // 合并 i 和 i+1\r\n\t\tsz[j] += sz[i] + 1\r\n\t\tif p.v > threshold/sz[j] {\r\n\t\t\treturn sz[j]\r\n\t\t}\r\n\t}\r\n\treturn -1\r\n}\r\n```\r\n \r\n#### 方法二：单调栈\r\n\r\n#### 提示 1\r\n\r\n枚举每个元素，假设它是子数组中的最小值。\r\n\r\n#### 提示 2\r\n\r\n子数组的左右边界最远能到哪？\r\n\r\n#### 提示 3\r\n\r\n用**单调栈**来计算左右边界。\r\n\r\n不了解单调栈的同学可以看一下 [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)。本题求的是更小元素。\r\n\r\n知道了左右边界也就知道了子数组的长度 $k$。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$。\r\n- 空间复杂度：$O(n)$。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\r\n        n = len(nums)\r\n        left, st = [-1] * n, []  # left[i] 为左侧小于 nums[i] 的最近元素位置（不存在时为 -1）\r\n        for i, v in enumerate(nums):\r\n            while st and nums[st[-1]] >= v: st.pop()\r\n            if st: left[i] = st[-1]\r\n            st.append(i)\r\n\r\n        right, st = [n] * n, []  # right[i] 为右侧小于 nums[i] 的最近元素位置（不存在时为 n）\r\n        for i in range(n - 1, -1, -1):\r\n            while st and nums[st[-1]] >= nums[i]: st.pop()\r\n            if st: right[i] = st[-1]\r\n            st.append(i)\r\n\r\n        for num, l, r in zip(nums, left, right):\r\n            k = r - l - 1\r\n            if num > threshold // k: return k\r\n        return -1\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int validSubarraySize(int[] nums, int threshold) {\r\n        var n = nums.length;\r\n        var left = new int[n]; // left[i] 为左侧小于 nums[i] 的最近元素位置（不存在时为 -1）\r\n        var st = new ArrayDeque<Integer>();\r\n        for (var i = 0; i < n; i++) {\r\n            while (!st.isEmpty() && nums[st.peek()] >= nums[i]) st.pop();\r\n            left[i] = st.isEmpty() ? -1 : st.peek();\r\n            st.push(i);\r\n        }\r\n\r\n        var right = new int[n]; // right[i] 为右侧小于 nums[i] 的最近元素位置（不存在时为 n）\r\n        st = new ArrayDeque<>();\r\n        for (var i = n - 1; i >= 0; i--) {\r\n            while (!st.isEmpty() && nums[st.peek()] >= nums[i]) st.pop();\r\n            right[i] = st.isEmpty() ? n : st.peek();\r\n            st.push(i);\r\n        }\r\n\r\n        for (var i = 0; i < n; ++i) {\r\n            var k = right[i] - left[i] - 1;\r\n            if (nums[i] > threshold / k) return k;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int validSubarraySize(vector<int> &nums, int threshold) {\r\n        int n = nums.size();\r\n        int left[n]; // left[i] 为左侧小于 nums[i] 的最近元素位置（不存在时为 -1）\r\n        stack<int> s;\r\n        for (int i = 0; i < n; ++i) {\r\n            while (!s.empty() && nums[s.top()] >= nums[i]) s.pop();\r\n            left[i] = s.empty() ? -1 : s.top();\r\n            s.push(i);\r\n        }\r\n\r\n        int right[n]; // right[i] 为右侧小于 nums[i] 的最近元素位置（不存在时为 n）\r\n        s = stack<int>();\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            while (!s.empty() && nums[s.top()] >= nums[i]) s.pop();\r\n            right[i] = s.empty() ? n : s.top();\r\n            s.push(i);\r\n        }\r\n\r\n        for (int i = 0; i < n; ++i) {\r\n            int k = right[i] - left[i] - 1;\r\n            if (nums[i] > threshold / k) return k;\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc validSubarraySize(nums []int, threshold int) int {\r\n\tn := len(nums)\r\n\tleft := make([]int, n) // left[i] 为左侧小于 nums[i] 的最近元素位置（不存在时为 -1）\r\n\tst := []int{-1}\r\n\tfor i, v := range nums {\r\n\t\tfor len(st) > 1 && nums[st[len(st)-1]] >= v {\r\n\t\t\tst = st[:len(st)-1]\r\n\t\t}\r\n\t\tleft[i] = st[len(st)-1]\r\n\t\tst = append(st, i)\r\n\t}\r\n\r\n\tright := make([]int, n) // right[i] 为右侧小于 nums[i] 的最近元素位置（不存在时为 n）\r\n\tst = []int{n}\r\n\tfor i := n - 1; i >= 0; i-- {\r\n\t\tfor len(st) > 1 && nums[st[len(st)-1]] >= nums[i] {\r\n\t\t\tst = st[:len(st)-1]\r\n\t\t}\r\n\t\tright[i] = st[len(st)-1]\r\n\t\tst = append(st, i)\r\n\t}\r\n\r\n\tfor i, num := range nums {\r\n\t\tk := right[i] - left[i] - 1\r\n\t\tif num > threshold/k {\r\n\t\t\treturn k\r\n\t\t}\r\n\t}\r\n\treturn -1\r\n}\r\n```\r\n\r\n"
}