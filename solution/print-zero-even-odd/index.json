{
	"titleSlug": "print-zero-even-odd",
	"slug": "by-be_a_better_coder-axp4",
	"url": "https://leetcode-cn.com/problems/print-zero-even-odd/solution/by-be_a_better_coder-axp4/",
	"content": "使用 **synchronized** 的解法\r\n\r\n```Java\r\nclass ZeroEvenOdd {\r\n    private int n;\r\n    private volatile int flag = 1;\r\n    \r\n    public ZeroEvenOdd(int n) {\r\n        this.n = n;\r\n    }\r\n\r\n    // printNumber.accept(x) outputs \"x\", where x is an integer.\r\n    public void zero(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i++) {\r\n            synchronized (this) {\r\n                while (flag % 2 == 0) wait();\r\n                printNumber.accept(0);\r\n                flag ++;\r\n                notifyAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void even(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=2; i<=n; i+=2) {\r\n            synchronized (this) {\r\n                while (flag % 4 != 0) wait();\r\n                printNumber.accept(i);\r\n                flag ++;\r\n                notifyAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void odd(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i+=2) {\r\n            synchronized(this) {\r\n                while (flag % 4 != 2) wait();\r\n                printNumber.accept(i);\r\n                flag ++;\r\n                notifyAll();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n使用 **LockSupport** 的解法\r\n\r\n```Java\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.locks.LockSupport;\r\n\r\nclass ZeroEvenOdd {\r\n    private int n;\r\n    volatile int flag = 1;\r\n    ConcurrentHashMap<Integer, Thread> map = new ConcurrentHashMap<>();\r\n\r\n    public ZeroEvenOdd(int n) {\r\n        this.n = n;\r\n    }\r\n\r\n    // printNumber.accept(x) outputs \"x\", where x is an integer.\r\n    public void zero(IntConsumer printNumber) throws InterruptedException {\r\n        map.putIfAbsent(1, Thread.currentThread());\r\n\r\n        for (int i=1; i<=n; i++) {\r\n            while (flag % 2 == 0) LockSupport.park();\r\n            printNumber.accept(0);\r\n            flag ++;\r\n            if (flag % 4 == 0) LockSupport.unpark(map.get(0));\r\n            if (flag % 4 == 2) LockSupport.unpark(map.get(1));\r\n        }\r\n    }\r\n\r\n    public void even(IntConsumer printNumber) throws InterruptedException {\r\n        map.putIfAbsent(0, Thread.currentThread());\r\n        for (int i=2; i<=n; i+=2) {\r\n            while (flag % 4 != 0) LockSupport.park();\r\n            printNumber.accept(i);\r\n            flag ++;\r\n            LockSupport.unpark(map.get(1));\r\n        }\r\n    }\r\n\r\n    public void odd(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i+=2) {\r\n            while (flag % 4 != 2) LockSupport.park();\r\n            printNumber.accept(i);\r\n            flag ++;\r\n            LockSupport.unpark(map.get(1));\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n使用 **yield + 原子类** 的解法\r\n\r\n```Java\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\nclass ZeroEvenOdd {\r\n    private int n;\r\n    volatile AtomicInteger dice = new AtomicInteger(1);\r\n\r\n\r\n    public ZeroEvenOdd(int n) {\r\n        this.n = n;\r\n    }\r\n\r\n    // printNumber.accept(x) outputs \"x\", where x is an integer.\r\n    public void zero(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i++) {\r\n            while (dice.get() % 2 == 0) Thread.yield();\r\n            printNumber.accept(0);\r\n            dice.getAndIncrement();\r\n        }\r\n    }\r\n\r\n    public void even(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=2; i<=n; i+=2) {\r\n            while (dice.get() % 4 != 0) Thread.yield();\r\n            printNumber.accept(i);\r\n            dice.getAndIncrement();\r\n        }\r\n    }\r\n\r\n    public void odd(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i+=2) {\r\n            while (dice.get() % 4 != 2) Thread.yield();\r\n            printNumber.accept(i);\r\n            dice.getAndIncrement();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n使用 **ReentrantLock + Condition** 的解法1\r\n\r\n```Java\r\nclass ZeroEvenOdd {\r\n    private int n;\r\n    private volatile int flag = 1;\r\n    private ReentrantLock lock = new ReentrantLock();\r\n    private Condition condition = lock.newCondition();\r\n    \r\n    public ZeroEvenOdd(int n) {\r\n        this.n = n;\r\n    }\r\n\r\n    // printNumber.accept(x) outputs \"x\", where x is an integer.\r\n    public void zero(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i++) {\r\n            lock.lock();\r\n            printNumber.accept(0);\r\n            flag ++;\r\n            condition.signalAll();\r\n            while (flag %2 == 0) condition.await();\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public void even(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=2; i<=n; i+=2) {\r\n            lock.lock();\r\n            while (flag % 4 != 0) condition.await();\r\n            printNumber.accept(i);\r\n            flag ++;\r\n            condition.signalAll();\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public void odd(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i+=2) {\r\n            lock.lock();\r\n            while (flag % 4 != 2) condition.await();\r\n            printNumber.accept(i);\r\n            flag ++;\r\n            condition.signalAll();\r\n            lock.unlock();\r\n        }       \r\n    }\r\n}\r\n```\r\n\r\n使用 **ReentrantLock + Condition** 解法2:\r\n\r\n```Java\r\nimport java.util.concurrent.locks.Condition;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\nclass ZeroEvenOdd {\r\n    private int n;\r\n    private volatile int flag = 1;\r\n    private ReentrantLock lock = new ReentrantLock();\r\n    private Condition[] conditions = new Condition[3];\r\n\r\n    public ZeroEvenOdd(int n) {\r\n        this.n = n;\r\n        for (int i=0; i<conditions.length; i++) conditions[i] = lock.newCondition();\r\n    }\r\n\r\n    // printNumber.accept(x) outputs \"x\", where x is an integer.\r\n    public void zero(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i++) {\r\n            lock.lock();\r\n            printNumber.accept(0);\r\n            flag ++;\r\n            if (flag % 4 == 2) {\r\n                conditions[1].signal();\r\n            }\r\n            if (flag % 4 == 0) {\r\n                conditions[2].signal();\r\n            }\r\n            if (flag % 2 == 0) {\r\n                conditions[0].await();\r\n            }\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public void even(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=2; i<=n; i+=2) {\r\n            lock.lock();\r\n            if (flag % 4 != 0) conditions[2].await();\r\n            printNumber.accept(i);\r\n            flag ++;\r\n            conditions[0].signal();\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public void odd(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i+=2) {\r\n            lock.lock();\r\n            if (flag % 4 != 2) conditions[1].await();\r\n            printNumber.accept(i);\r\n            flag ++;\r\n            conditions[0].signal();\r\n            lock.unlock();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n使用 **Semaphore** 的解法\r\n\r\n```Java\r\nimport java.util.concurrent.Semaphore;\r\n\r\nclass ZeroEvenOdd {\r\n    private int n;\r\n    Semaphore[] semaphores = new Semaphore[3];\r\n\r\n    public ZeroEvenOdd(int n) {\r\n        this.n = n;\r\n        semaphores[0] = new Semaphore(1);\r\n        semaphores[1] = new Semaphore(0);\r\n        semaphores[2] = new Semaphore(0);\r\n    }\r\n\r\n    // printNumber.accept(x) outputs \"x\", where x is an integer.\r\n    public void zero(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i++) {\r\n            semaphores[0].acquire();\r\n            printNumber.accept(0);\r\n            if (i % 2 == 0) semaphores[1].release();\r\n            else semaphores[2].release();\r\n        }\r\n    }\r\n\r\n    public void even(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=2; i<=n; i=i+2) {\r\n            semaphores[1].acquire();\r\n            printNumber.accept(i);\r\n            semaphores[0].release();\r\n        }\r\n    }\r\n\r\n    public void odd(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i=i+2) {\r\n            semaphores[2].acquire();\r\n            printNumber.accept(i);\r\n            semaphores[0].release();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n使用 **SynchronousQueue** 的解法 \r\n\r\n```Java\r\nimport java.util.concurrent.SynchronousQueue;\r\n\r\nclass ZeroEvenOdd {\r\n    private int n;\r\n    private SynchronousQueue<Integer>[] queues = new SynchronousQueue[3];\r\n\r\n    public ZeroEvenOdd(int n) {\r\n        this.n = n;\r\n        for (int i=0; i<queues.length; i++) queues[i] = new SynchronousQueue<>();\r\n    }\r\n\r\n    // printNumber.accept(x) outputs \"x\", where x is an integer.\r\n    public void zero(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i++) {\r\n            printNumber.accept(0);\r\n            if (i % 2 == 1) {\r\n                queues[1].put(1);\r\n            } else {\r\n                queues[2].put(1);\r\n            }\r\n            queues[0].take();\r\n        }\r\n    }\r\n\r\n    public void even(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=2; i<=n; i+=2) {\r\n            queues[2].take();\r\n            printNumber.accept(i);\r\n            queues[0].put(1);\r\n        }\r\n    }\r\n\r\n    public void odd(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i+=2) {\r\n            queues[1].take();\r\n            printNumber.accept(i);\r\n            queues[0].put(1);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n使用 **LinkedBlockingQueue** 的解法，使用 **BlockingQueue** 的其他子类，也可以类似的解出来。\r\n\r\n```Java\r\nimport java.util.concurrent.LinkedBlockingQueue;\r\n\r\nclass ZeroEvenOdd {\r\n    private int n;\r\n    private LinkedBlockingQueue<Integer>[] queues = new LinkedBlockingQueue[3];\r\n\r\n    public ZeroEvenOdd(int n) {\r\n        this.n = n;\r\n        for (int i=0; i<queues.length; i++) {\r\n            queues[i] = new LinkedBlockingQueue<>(1);\r\n        }\r\n    }\r\n\r\n    // printNumber.accept(x) outputs \"x\", where x is an integer.\r\n    public void zero(IntConsumer printNumber) throws InterruptedException {\r\n        queues[0].put(1);\r\n        for (int i=1; i<=n; i++) {\r\n            queues[0].take();\r\n            printNumber.accept(0);\r\n            if (i % 2 == 0) {\r\n                queues[2].put(1);\r\n            } else {\r\n                queues[1].put(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void even(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=2; i<=n; i+=2) {\r\n            queues[2].take();\r\n            printNumber.accept(i);\r\n            if (i < n) queues[0].put(1);\r\n        }\r\n    }\r\n\r\n    public void odd(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i+=2) {\r\n            queues[1].take();\r\n            printNumber.accept(i);\r\n            if (i < n) queues[0].put(1);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n使用 **CyclicBarrier** 的解法\r\n\r\n```Java\r\nimport java.util.concurrent.BrokenBarrierException;\r\nimport java.util.concurrent.CyclicBarrier;\r\n\r\nclass ZeroEvenOdd {\r\n    private int n;\r\n    CyclicBarrier[] cbs = new CyclicBarrier[3];\r\n\r\n    public ZeroEvenOdd(int n) {\r\n        this.n = n;\r\n        for (int i=0; i<cbs.length; i++) cbs[i] = new CyclicBarrier(2);\r\n    }\r\n\r\n    // printNumber.accept(x) outputs \"x\", where x is an integer.\r\n    public void zero(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i++) {\r\n            printNumber.accept(0);\r\n            try {\r\n                if (i % 2 == 1) {\r\n                    cbs[1].await();\r\n                } else {\r\n                    cbs[2].await();\r\n                }\r\n                cbs[0].await();\r\n            } catch (BrokenBarrierException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void even(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=2; i<=n; i+=2) {\r\n            try {\r\n                cbs[2].await();\r\n                printNumber.accept(i);\r\n                cbs[0].await();\r\n            } catch (BrokenBarrierException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void odd(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i+=2) {\r\n            try {\r\n                cbs[1].await();\r\n                printNumber.accept(i);\r\n                cbs[0].await();\r\n            } catch (BrokenBarrierException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n使用 **Exchanger** 的解法\r\n\r\n```Java\r\nimport java.util.concurrent.Exchanger;\r\n\r\nclass ZeroEvenOdd {\r\n    private int n;\r\n    Exchanger<Integer>[] exchanges = new Exchanger[3];\r\n\r\n    public ZeroEvenOdd(int n) {\r\n        this.n = n;\r\n        for (int i=0; i< exchanges.length; i++) exchanges[i] = new Exchanger<>();\r\n    }\r\n\r\n    // printNumber.accept(x) outputs \"x\", where x is an integer.\r\n    public void zero(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i++) {\r\n            printNumber.accept(0);\r\n            if (i % 2 == 1) {\r\n                exchanges[1].exchange(1);\r\n            } else {\r\n                exchanges[2].exchange(1);\r\n            }\r\n            exchanges[0].exchange(1);\r\n        }\r\n    }\r\n\r\n    public void even(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=2; i<=n; i+=2) {\r\n            exchanges[2].exchange(1);\r\n            printNumber.accept(i);\r\n            exchanges[0].exchange(1);\r\n        }\r\n    }\r\n\r\n    public void odd(IntConsumer printNumber) throws InterruptedException {\r\n        for (int i=1; i<=n; i+=2) {\r\n            exchanges[1].exchange(1);\r\n            printNumber.accept(i);\r\n            exchanges[0].exchange(1);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\nTODO: **Phaser** 怎么使用。\r\n\r\n不太适合使用 **CountDownLatch** 来实现。\r\n"
}