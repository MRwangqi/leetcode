{
	"titleSlug": "valid-arrangement-of-pairs",
	"slug": "he-fa-zhong-xin-pai-lie-shu-dui-by-leetc-h8rl",
	"url": "https://leetcode-cn.com/problems/valid-arrangement-of-pairs/solution/he-fa-zhong-xin-pai-lie-shu-dui-by-leetc-h8rl/",
	"content": "#### 方法一：有向图的欧拉通路\n\n**思路与算法**\n\n如果我们把数组 $\\textit{pairs}$ 中出现的每个数看成一个节点，$(\\textit{start}_i, \\textit{end}_i)$ 看成从 $\\textit{start}_i$ 到 $\\textit{end}_i$ 的一条有向边，那么 $\\textit{pairs}$ 的一个合法排列就对应着：\n\n- 从节点 $\\textit{pairs}[0][0]$ 开始；\n\n- 依次经过 $\\textit{pairs}[0][1], \\textit{pairs}[1][1], \\cdots, \\textit{pairs}[n-1][1]$；\n\n的一条路径，其中 $n$ 是数组 $\\textit{pairs}$ 的长度。这条路径经过了图上的每一条边恰好一次，是一条「欧拉通路」，因此我们的目标就是找出图上的任意一条欧拉通路。\n\n求解欧拉通路可以使用深度优先搜索，这里对算法本身不再赘述，感兴趣的读者可以参考[「OI Wiki — 欧拉图」](https://oi-wiki.org/graph/euler/) 或其它资料，我们一般使用 $\\text{Hierholzer}$ 算法求解欧拉通路，在力扣平台上还有如下与欧拉回路或欧拉通路有关的题目：\n\n- [「332. 重新安排行程」](https://leetcode-cn.com/problems/reconstruct-itinerary/)\n\n- [「753. 破解保险箱」](https://leetcode-cn.com/problems/cracking-the-safe/)\n\n对于本题而言，我们首先需要找到欧拉通路的起始节点：如果图中所有节点的入度和出度都相等，那么从任意节点开始都存在欧拉通路；如果图中存在一个节点的出度比入度恰好多 $1$，另一个节点的入度恰好比出度多 $1$，那么欧拉通路必须从前一个节点开始，到后一个节点结束。除此之外的有向图都不存在欧拉通路，本体保证了至少存在一个合法排列，因此图已经是上述的两种情况之一。\n\n当我们确定起始节点后，就可以使用深度优先搜索求解欧拉通路了。如果我们得到的欧拉通路为：\n\n$$\nv_1, v_2, v_3, \\cdots, v_n, v_{n+1}\n$$\n\n那么 $[[v_1, v_2], [v_2, v_3], \\cdots, [v_n, v_{n+1}]]$ 就是一个合法排列。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\n        // 存储图\n        unordered_map<int, vector<int>> edges;\n        // 存储入度和出度\n        unordered_map<int, int> indeg, outdeg;\n        for (const auto& p: pairs) {\n            int x = p[0], y = p[1];\n            edges[x].push_back(y);\n            ++indeg[y];\n            ++outdeg[x];\n        }\n        \n        // 寻找起始节点\n        int start = pairs[0][0];\n        for (const auto& [x, occ]: outdeg) {\n            // 如果有节点出度比入度恰好多 1，那么只有它才能是起始节点\n            if (occ == indeg[x] + 1) {\n                start = x;\n                break;\n            }\n        }\n        \n        vector<vector<int>> ans;\n        \n        // 深度优先搜索（Hierholzer 算法）求解欧拉通路\n        function<void(int)> dfs = [&](int u) {\n            while (!edges[u].empty()) {\n                int v = edges[u].back();\n                edges[u].pop_back();\n                dfs(v);\n                ans.push_back({u, v});\n            }\n        };\n        \n        dfs(start);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        # 存储图\n        edges = defaultdict(list)\n        # 存储入度和出度\n        indeg, outdeg = Counter(), Counter()\n        for x, y in pairs:\n            edges[x].append(y)\n            indeg[y] += 1\n            outdeg[x] += 1\n        \n        # 寻找起始节点\n        start = pairs[0][0]\n        for x in outdeg:\n            # 如果有节点出度比入度恰好多 1，那么只有它才能是起始节点\n            if outdeg[x] == indeg[x] + 1:\n                start = x\n                break\n        \n        ans = list()\n        \n        # 深度优先搜索（Hierholzer 算法）求解欧拉通路\n        def dfs(u: int) -> None:\n            while edges[u]:\n                v = edges[u].pop()\n                dfs(v)\n                ans.append([u, v])\n        \n        dfs(start)\n        return ans[::-1]\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{pairs}$ 的长度。图中有不超过 $n+1$ 个节点和 $n$ 条边，因此求解欧拉通路需要的时间为 $O(n)$。\n\n- 空间复杂度：$O(n)$，即为存储图需要使用的空间。"
}