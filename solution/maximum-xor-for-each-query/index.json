{
	"titleSlug": "maximum-xor-for-each-query",
	"slug": "mei-ge-cha-xun-de-zui-da-yi-huo-zhi-by-l-haol",
	"url": "https://leetcode-cn.com/problems/maximum-xor-for-each-query/solution/mei-ge-cha-xun-de-zui-da-yi-huo-zhi-by-l-haol/",
	"content": "#### 方法一：位运算\n\n**提示 $1$**\n\n我们用 $\\oplus$ 表示按位异或运算。\n\n根据按位异或运算的性质 $a \\oplus b \\oplus b = a$，我们可以在 $O(1)$ 的时间，根据上一次询问需要的异或前缀和，得到当前询问需要的异或前缀和。\n\n为了方便叙述，我们将第 $i$ 次询问对应的异或前缀和记为\n\n$$\n\\textit{xorsum}_i = \\textit{nums}[0] \\oplus \\textit{nums}[1] \\oplus \\cdots \\oplus \\textit{nums}[n-1-i]\n$$\n\n**提示 $2$**\n\n我们需要挑选一个包含不超过 $\\textit{maximumBit}$ 个二进制位的非负整数 $k$，使得 $k \\oplus \\textit{xorsum}$ 的值最大。由于题目保证了数组 $\\textit{nums}$ 中的元素一定小于等于 $2^\\textit{maximumBit} - 1$，你是否可以直接构造出 $k$ 值？\n\n**思路与算法**\n\n首先我们可以通过\n\n$$\n\\textit{xorsum}_{i-1} = \\textit{xorsum}_i \\oplus \\textit{nums}[n-1-i]\n$$\n\n在 $O(1)$ 的时间更新每一次询问需要的异或前缀和。\n\n再者，由于数组 $\\textit{nums}$ 的元素一定小于等于 $2^\\textit{maximumBit} - 1$，而 $2^\\textit{maximumBit} - 1$ 是一个二进制表示全部为 $1$ 的数，因此数组 $\\textit{nums}$ 中的任意异或前缀和一定也小于等于 $2^\\textit{maximumBit} - 1$。这样一来，我们令 $k = \\textit{xorsum} \\oplus (2^\\textit{maximumBit} - 1)$，$k \\oplus \\textit{xorsum}$ 就可以得到最大值 $2^\\textit{maximumBit} - 1$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {\n        int n = nums.size();\n        int mask = (1 << maximumBit) - 1;\n        int xorsum = accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\n        \n        vector<int> ans;\n        for (int i = n - 1; i >= 0; --i) {\n            ans.push_back(xorsum ^ mask);\n            xorsum ^= nums[i];\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:\n        n = len(nums)\n        mask = (1 << maximumBit) - 1\n        xorsum = reduce(xor, nums)\n        \n        ans = list()\n        for i in range(n - 1, -1, -1):\n            ans.append(xorsum ^ mask)\n            xorsum ^= nums[i]\n        \n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。\n\n- 空间复杂度：$O(1)$。这里不包括存储返回答案需要的空间。"
}