{
	"titleSlug": "minimum-height-trees",
	"slug": "zui-xiao-gao-du-shu-by-leetcode-solution-6v6f",
	"url": "https://leetcode-cn.com/problems/minimum-height-trees/solution/zui-xiao-gao-du-shu-by-leetcode-solution-6v6f/",
	"content": "#### 方法一：广度优先搜索\n\n**思路与算法**\n\n题目中给定的含有 $n$ 个节点的树，可以推出含有以下特征：\n+ 任意两个节点之间有且仅有一条路径；\n+ 树中的共有 $n-1$ 条不同的边；\n+ 叶子节点的度为 $1$，非叶子节点的度至少为 $2$；\n+ 树的高度由根节点到叶子节点的最大距离决定。\n\n最直接的解法是，枚举以每个节点为根构成的树，然后求出该树的高度，所有树的最小高度即为答案，需要的时间复杂度为 $O(n^2)$，在此不再描述。\n\n设 $\\textit{dist}[x][y]$ 表示从节点 $x$ 到节点 $y$ 的距离，假设树中距离最长的两个节点为 $(x,y)$，它们之间的距离为 $\\textit{maxdist} = \\textit{dist}[x][y]$，则可以推出以任意节点构成的树最小高度一定为 $\\textit{minheight} = \\Big \\lceil  \\dfrac{\\textit{maxdist}}{2} \\Big \\rceil$，且最小高度的树根节点一定在 节点 $x$ 到节点 $y$ 的路径上。\n\n+ 首先证明树的高度一定为 $\\textit{minheight} = \\Big \\lceil  \\dfrac{\\textit{maxdist}}{2} \\Big \\rceil$，可以用反证法证明，假设存在节点 $z$，以节点 $z$ 为根的树的高度 $h < \\textit{minheight}$，则可以推出：\n\n  + 如果节点 $z$ 存在于从 $x$ 到 $y$ 的路径上，由于 $x$ 与 $y$ 均为叶子节点，则可以知道 $x$ 到 $z$ 距离与 $y$ 到 $z$ 距离均小于 $\\textit{minheight}$，$\\textit{dist}[x][y] = \\textit{dist}[x][z] + \\textit{dist}[z][y] \\le 2 \\times \\Big \\lceil \\dfrac{\\textit{dist}[x][y]}{2} \\Big \\rceil - 2 < \\textit{dist}[x][y]$，这与 $x$ 到 $y$ 的距离为 $\\textit{dist}[x][y]$ 相矛盾；\n\n  + 如果节点 $z$ 不存在于 $x$ 到 $y$ 的路径上，假设 $z$ 到 $x$ 的路径为 $z \\rightarrow \\cdots \\rightarrow a \\rightarrow \\cdots \\rightarrow x$，$z$ 到 $y$ 的路径为 $z \\rightarrow \\cdots \\rightarrow a \\rightarrow \\cdots \\rightarrow y$，这两个路径之间一定存在公共的交叉点，假设交叉点为 $a$，则可以知道此时 $z$ 到 $x$ 的距离为 $\\textit{dist}[z][x] = \\textit{dist}[z][a] + \\textit{dist}[a][x]$，$z$ 到 $y$ 的距离为 $\\textit{dist}[z][y] = \\textit{dist}[z][a] + \\textit{dist}[a][y]$，由于树的高度小于 $h < \\textit{minheight}$，所以可以推出 $\\textit{dist}[z][a] + \\textit{dist}[a][x] < \\textit{minheight}$，$\\textit{dist}[z][a] + \\textit{dist}[a][y] < \\textit{minheight}$，即可以推出 $\\textit{dist}[a][x] + \\textit{dist}[a][y] \\le 2 \\times \\textit{minheight} - 2 = 2 \\times \\Big \\lceil  \\dfrac{\\textit{dist}[x][y]}{2} \\Big \\rceil - 2 < \\textit{dist}[x][y]$，这与 $x$ 到 $y$ 的距离为 $\\textit{dist}[x][y]$ 相矛盾；\n\n+ 其次证明最小高度树的根节点一定存在于 $x$ 到 $y$ 的路径上，假设存在节点 $z$ 它的最小高度为 $\\textit{minheight}$，但节点 $z$ 不存在于 $x$ 到 $y$ 之间的路径上：\n  + 设 $z$ 到 $x$ 的路径为 $z \\rightarrow \\cdots \\rightarrow a \\rightarrow \\cdots \\rightarrow x$，$z$ 到 $y$ 的路径为 $z \\rightarrow \\cdots \\rightarrow a \\rightarrow \\cdots \\rightarrow y$，这两个路径之间一定存在公共的交叉点，假设交叉点为 $a$, 则可以知道此时 $z$ 到 $x$ 的距离为 $\\textit{dist}[z][x] = \\textit{dist}[z][a] + \\textit{dist}[a][x]$，$z$ 到 $y$ 的距离为 $\\textit{dist}[z][y] = \\textit{dist}[z][a] + \\textit{dist}[a][y]$，由于树的高度小 $h = \\textit{minheight}$，所以可以推出 $\\textit{dist}[z][a] + \\textit{dist}[a][x] \\le \\textit{minheight}$，$\\textit{dist}[z][a] + \\textit{dist}[a][y] \\le \\textit{minheight}$，由于 $z$ 不在 $x$ 到 $y$ 的路径上，所以可以知道 $\\textit{dist}[z][a] \\ge 1$，即可以推出 $\\textit{dist}[a][x] < \\textit{minheight}，\\textit{dist}[a][y] < \\textit{minheight}$，即可以推出 $\\textit{dist}[a][x] + \\textit{dist}[a][y] \\le 2 \\times \\textit{minheight} - 2 = 2 \\times \\Big \\lceil \\dfrac{\\textit{dist}[x][y]}{2} \\Big \\rceil - 2 < \\textit{dist}[x][y]$，这与 $x$ 到 $y$ 的距离为 $\\textit{dist}[x][y]$ 相矛盾。\n\n综合上述推理，设两个叶子节点的最长距离为 $\\textit{maxdist}$，可以得到结论最小高度树的高度为 $\\Big \\lceil  \\dfrac{\\textit{maxdist}}{2} \\Big \\rceil$，且最小高度树的根节点一定存在其最长路径上。假设最长的路径的 $m$ 个节点依次为 $p_1 \\rightarrow p_2 \\rightarrow \\cdots \\rightarrow p_m$，最长路径的长度为 $m-1$，可以得到以下结论：\n\n+ 如果 $m$ 为偶数，此时最小高度树的根节点为 $p_{\\frac{m}{2}}$ 或者 $p_{\\frac{m}{2} + 1}$，且此时最小的高度为 $\\dfrac{m}{2}$；\n\n+ 如果 $m$ 为奇数，此时最小高度树的根节点为 $p_{\\frac{m+1}{2}}$，且此时最小的高度为 $\\dfrac{m-1}{2}$。\n\n因此我们只需要求出路径最长的两个叶子节点即可，并求出其路径的最中间的节点即为最小高度树的根节点。可以利用以下算法找到图中距离最远的两个节点与它们之间的路径：\n\n+ 以任意节点 $p$ 出现，利用广度优先搜索或者深度优先搜索找到以 $p$ 为起点的最长路径的终点 $x$；\n\n+ 以节点 $x$ 出发，找到以 $x$ 为起点的最长路径的终点 $y$；\n\n+ $x$ 到 $y$ 之间的路径即为图中的最长路径，找到路径的中间节点即为根节点。\n\n上述算法的证明可以参考「[算法导论习题解答 9-1](http://courses.csail.mit.edu/6.046/fall01/handouts/ps9sol.pdf)」。在此我们利用广度优先搜索来找到节点的最长路径，首先找到距离节点 $0$ 的最远节点 $x$，然后找到距离节点 $x$ 的最远节点 $y$，然后找到节点 $x$ 与节点 $y$ 的路径，然后找到根节点。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n        if n == 1:\n            return [0]\n\n        g = [[] for _ in range(n)]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n        parents = [0] * n\n\n        def bfs(start: int):\n            vis = [False] * n\n            vis[start] = True\n            q = deque([start])\n            while q:\n                x = q.popleft()\n                for y in g[x]:\n                    if not vis[y]:\n                        vis[y] = True\n                        parents[y] = x\n                        q.append(y)\n            return x\n        x = bfs(0)  # 找到与节点 0 最远的节点 x\n        y = bfs(x)  # 找到与节点 x 最远的节点 y\n\n        path = []\n        parents[x] = -1\n        while y != -1:\n            path.append(y)\n            y = parents[y]\n        m = len(path)\n        return [path[m // 2]] if m % 2 else [path[m // 2 - 1], path[m // 2]]\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findLongestNode(int u, vector<int> & parent, vector<vector<int>>& adj) {\n        int n = adj.size();\n        queue<int> qu;\n        vector<bool> visit(n);\n        qu.emplace(u);\n        visit[u] = true;\n        int node = -1;\n  \n        while (!qu.empty()) {\n            int curr = qu.front();\n            qu.pop();\n            node = curr;\n            for (auto & v : adj[curr]) {\n                if (!visit[v]) {\n                    visit[v] = true;\n                    parent[v] = curr;\n                    qu.emplace(v);\n                }\n            }\n        }\n        return node;\n    }\n\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if (n == 1) {\n            return {0};\n        }\n        vector<vector<int>> adj(n);\n        for (auto & edge : edges) {\n            adj[edge[0]].emplace_back(edge[1]);\n            adj[edge[1]].emplace_back(edge[0]);\n        }\n        \n        vector<int> parent(n, -1);\n        /* 找到与节点 0 最远的节点 x */\n        int x = findLongestNode(0, parent, adj);\n        /* 找到与节点 x 最远的节点 y */\n        int y = findLongestNode(x, parent, adj);\n        /* 求出节点 x 到节点 y 的路径 */\n        vector<int> path;\n        parent[x] = -1;\n        while (y != -1) {\n            path.emplace_back(y);\n            y = parent[y];\n        }\n        int m = path.size();\n        if (m % 2 == 0) {\n            return {path[m / 2 - 1], path[m / 2]};\n        } else {\n            return {path[m / 2]};\n        }\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        List<Integer> ans = new ArrayList<Integer>();\n        if (n == 1) {\n            ans.add(0);\n            return ans;\n        }\n        List<Integer>[] adj = new List[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new ArrayList<Integer>();\n        }\n        for (int[] edge : edges) {\n            adj[edge[0]].add(edge[1]);\n            adj[edge[1]].add(edge[0]);\n        }\n\n        int[] parent = new int[n];\n        Arrays.fill(parent, -1);\n        /* 找到与节点 0 最远的节点 x */\n        int x = findLongestNode(0, parent, adj);\n        /* 找到与节点 x 最远的节点 y */\n        int y = findLongestNode(x, parent, adj);\n        /* 求出节点 x 到节点 y 的路径 */\n        List<Integer> path = new ArrayList<Integer>();\n        parent[x] = -1;\n        while (y != -1) {\n            path.add(y);\n            y = parent[y];\n        }\n        int m = path.size();\n        if (m % 2 == 0) {\n            ans.add(path.get(m / 2 - 1));\n        }\n        ans.add(path.get(m / 2));\n        return ans;\n    }\n\n    public int findLongestNode(int u, int[] parent, List<Integer>[] adj) {\n        int n = adj.length;\n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        boolean[] visit = new boolean[n];\n        queue.offer(u);\n        visit[u] = true;\n        int node = -1;\n  \n        while (!queue.isEmpty()) {\n            int curr = queue.poll();\n            node = curr;\n            for (int v : adj[curr]) {\n                if (!visit[v]) {\n                    visit[v] = true;\n                    parent[v] = curr;\n                    queue.offer(v);\n                }\n            }\n        }\n        return node;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> FindMinHeightTrees(int n, int[][] edges) {\n        IList<int> ans = new List<int>();\n        if (n == 1) {\n            ans.Add(0);\n            return ans;\n        }\n        IList<int>[] adj = new IList<int>[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new List<int>();\n        }\n        foreach (int[] edge in edges) {\n            adj[edge[0]].Add(edge[1]);\n            adj[edge[1]].Add(edge[0]);\n        }\n\n        int[] parent = new int[n];\n        Array.Fill(parent, -1);\n        /* 找到与节点 0 最远的节点 x */\n        int x = FindLongestNode(0, parent, adj);\n        /* 找到与节点 x 最远的节点 y */\n        int y = FindLongestNode(x, parent, adj);\n        /* 求出节点 x 到节点 y 的路径 */\n        IList<int> path = new List<int>();\n        parent[x] = -1;\n        while (y != -1) {\n            path.Add(y);\n            y = parent[y];\n        }\n        int m = path.Count;\n        if (m % 2 == 0) {\n            ans.Add(path[m / 2 - 1]);\n        }\n        ans.Add(path[m / 2]);\n        return ans;\n    }\n\n    public int FindLongestNode(int u, int[] parent, IList<int>[] adj) {\n        int n = adj.Length;\n        Queue<int> queue = new Queue<int>();\n        bool[] visit = new bool[n];\n        queue.Enqueue(u);\n        visit[u] = true;\n        int node = -1;\n  \n        while (queue.Count > 0) {\n            int curr = queue.Dequeue();\n            node = curr;\n            foreach (int v in adj[curr]) {\n                if (!visit[v]) {\n                    visit[v] = true;\n                    parent[v] = curr;\n                    queue.Enqueue(v);\n                }\n            }\n        }\n        return node;\n    }\n}\n```\n\n```C [sol1-C]\nint findLongestNode(int u, int * parent, const struct ListNode ** adj, int n) {\n    int * queue = (int *)malloc(sizeof(int) * n);\n    int head = 0, tail = 0;\n    bool * visit = (bool *)malloc(sizeof(bool) * n);\n    memset(visit, 0, sizeof(bool) * n);\n    queue[tail++] = u;\n    visit[u] = true;\n    int res = -1;\n\n    while (head != tail) {\n        int curr = queue[head++];\n        res = curr;\n        struct ListNode * node = adj[curr];\n        while (node) {\n            if (!visit[node->val]) {\n                visit[node->val] = true;\n                parent[node->val] = curr;\n                queue[tail++] = node->val;\n            }\n            node = node->next;\n        }\n    }\n    free(queue);\n    free(visit);\n    return res;\n}\n\nint* findMinHeightTrees(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n    int * res = NULL;\n    if (n == 1) {\n        res = (int *)malloc(sizeof(int));\n        *res = 0;\n        *returnSize = 1;\n        return res;\n    }\n\n    struct ListNode ** adj = (struct ListNode *)malloc(sizeof(struct ListNode *) * n);\n    for (int i = 0; i < n; i++) {\n        adj[i] = NULL;\n    }\n    for (int i = 0; i < edgesSize; i++) {\n        int u = edges[i][0];\n        int v = edges[i][1];\n        struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = u;\n        node->next = adj[v];\n        adj[v] = node;\n        node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = v;\n        node->next = adj[u];\n        adj[u] = node;\n    }\n    \n    int * parent = (int *)malloc(sizeof(int) * n);\n    /* 找到与节点 0 最远的节点 x */\n    int x = findLongestNode(0, parent, adj, n);\n    /* 找到与节点 x 最远的节点 y */\n    int y = findLongestNode(x, parent, adj, n);\n    /* 求出节点 x 到节点 y 的路径 */\n    int * path = (int *)malloc(sizeof(int) * n);\n    int pos = 0;\n    parent[x] = -1;\n    while (y != -1) {\n        path[pos++] = y;\n        y = parent[y];\n    }\n    if (pos % 2 == 0) {\n        res = (int *)malloc(sizeof(int) * 2);\n        res[0] = path[pos / 2 - 1];\n        res[1] = path[pos / 2];\n        *returnSize = 2;\n    } else {\n        res = (int *)malloc(sizeof(int));\n        *res = path[pos / 2];\n        *returnSize = 1;\n    }\n    free(path);\n    free(parent);\n    for (int i = 0; i < n; i++) {\n        struct ListNode * node = adj[i];\n        while (node) {\n            struct ListNode * curr = node;\n            node = curr->next;\n            free(curr);\n        }\n    }\n    free(adj);\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findMinHeightTrees = function(n, edges) {\n    const ans = [];\n    if (n === 1) {\n        ans.push(0);\n        return ans;\n    }\n    const adj = new Array(n).fill(0).map(() => new Array());\n    for (const edge of edges) {\n        adj[edge[0]].push(edge[1]);\n        adj[edge[1]].push(edge[0]);\n    }\n\n    const parent = new Array(n).fill(-1);\n    /* 找到与节点 0 最远的节点 x */\n    const x = findLongestNode(0, parent, adj);\n    /* 找到与节点 x 最远的节点 y */\n    let y = findLongestNode(x, parent, adj);\n    /* 求出节点 x 到节点 y 的路径 */\n    const path = [];\n    parent[x] = -1;\n    while (y !== -1) {\n        path.push(y);\n        y = parent[y];\n    }\n    const m = path.length;\n    if (m % 2 === 0) {\n        ans.push(path[Math.floor(m / 2) - 1]);\n    }\n    ans.push(path[Math.floor(m / 2)]);\n    return ans;\n}\n\nconst findLongestNode = (u, parent, adj) => {\n    const n = adj.length;\n    const queue = [];\n    const visit = new Array(n).fill(false);\n    queue.push(u);\n    visit[u] = true;\n    let node = -1;\n\n    while (queue.length) {\n        const curr = queue.shift();\n        node = curr;\n        for (const v of adj[curr]) {\n            if (!visit[v]) {\n                visit[v] = true;\n                parent[v] = curr;\n                queue.push(v);\n            }\n        }\n    }\n    return node;\n};\n```\n\n```go [sol1-Golang]\nfunc findMinHeightTrees(n int, edges [][]int) []int {\n    if n == 1 {\n        return []int{0}\n    }\n\n    g := make([][]int, n)\n    for _, e := range edges {\n        x, y := e[0], e[1]\n        g[x] = append(g[x], y)\n        g[y] = append(g[y], x)\n    }\n\n    parents := make([]int, n)\n    bfs := func(start int) (x int) {\n        vis := make([]bool, n)\n        vis[start] = true\n        q := []int{start}\n        for len(q) > 0 {\n            x, q = q[0], q[1:]\n            for _, y := range g[x] {\n                if !vis[y] {\n                    vis[y] = true\n                    parents[y] = x\n                    q = append(q, y)\n                }\n            }\n        }\n        return\n    }\n    x := bfs(0) // 找到与节点 0 最远的节点 x\n    y := bfs(x) // 找到与节点 x 最远的节点 y\n\n    path := []int{}\n    parents[x] = -1\n    for y != -1 {\n        path = append(path, y)\n        y = parents[y]\n    }\n    m := len(path)\n    if m%2 == 0 {\n        return []int{path[m/2-1], path[m/2]}\n    }\n    return []int{path[m/2]}\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是为节点的个数。图中边的个数为 $n-1$，因此建立图的关系需要的时间复杂度为 $O(n)$，通过广度优先搜索需要的时间复杂度为 $O(n + n - 1)$，求最长路径的时间复杂度为 $O(n)$，因此总的时间复杂度为 $O(n)$。\n\n+ 空间复杂度：$O(n)$，其中 $n$ 是节点的个数。由于题目给定的图中任何两个顶点都只有一条路径连接，因此图中边的数目刚好等于 $n-1$，用邻接表构造图所需的空间刚好为 $O(2 \\times n)$，存储每个节点的距离和父节点均为 $O(n)$，使用广度优先搜索时，队列中最多有 $n$ 个元素，所需的空间也为 $O(n)$，因此空间复杂度为 $O(n)$。\n\n#### 方法二：深度优先搜索\n\n**思路与算法**\n\n方法一中使用广度优先搜索求出路径最长的节点与路径，我们还可以使用深度优先搜索来实现。首先找到距离节点 $0$ 的最远节点 $x$，然后找到距离节点 $x$ 的最远节点 $y$，然后找到节点 $x$ 与节点 $y$ 的路径，然后找到根节点。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n        if n == 1:\n            return [0]\n\n        g = [[] for _ in range(n)]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n        parents = [0] * n\n        maxDepth, node = 0, -1\n\n        def dfs(x: int, pa: int, depth: int):\n            nonlocal maxDepth, node\n            if depth > maxDepth:\n                maxDepth, node = depth, x\n            parents[x] = pa\n            for y in g[x]:\n                if y != pa:\n                    dfs(y, x, depth + 1)\n        dfs(0, -1, 1)\n        maxDepth = 0\n        dfs(node, -1, 1)\n\n        path = []\n        while node != -1:\n            path.append(node)\n            node = parents[node]\n        m = len(path)\n        return [path[m // 2]] if m % 2 else [path[m // 2 - 1], path[m // 2]]\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    void dfs(int u, vector<int> & dist, vector<int> & parent, const vector<vector<int>> & adj) {\n        for (auto & v : adj[u]) {\n            if (dist[v] < 0) {\n                dist[v] = dist[u] + 1;\n                parent[v] = u;\n                dfs(v, dist, parent, adj); \n            }\n        }\n    }\n\n    int findLongestNode(int u, vector<int> & parent, const vector<vector<int>> & adj) {\n        int n = adj.size();\n        vector<int> dist(n, -1);\n        dist[u] = 0;\n        dfs(u, dist, parent, adj);\n        int maxdist = 0;\n        int node = -1;\n        for (int i = 0; i < n; i++) {\n            if (dist[i] > maxdist) {\n                maxdist = dist[i];\n                node = i;\n            }\n        }\n        return node;\n    }\n\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if (n == 1) {\n            return {0};\n        }\n        vector<vector<int>> adj(n);\n        for (auto & edge : edges) {\n            adj[edge[0]].emplace_back(edge[1]);\n            adj[edge[1]].emplace_back(edge[0]);\n        }\n        vector<int> parent(n, -1);\n        /* 找到距离节点 0 最远的节点  x */\n        int x = findLongestNode(0, parent, adj);\n        /* 找到距离节点 x 最远的节点  y */\n        int y = findLongestNode(x, parent, adj);\n        /* 找到节点 x 到节点 y 的路径 */\n        vector<int> path;\n        parent[x] = -1;\n        while (y != -1) {\n            path.emplace_back(y);\n            y = parent[y];\n        }\n        int m = path.size();\n        if (m % 2 == 0) {\n            return {path[m / 2 - 1], path[m / 2]};\n        } else {\n            return {path[m / 2]};\n        }\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        List<Integer> ans = new ArrayList<Integer>();\n        if (n == 1) {\n            ans.add(0);\n            return ans;\n        }\n        List<Integer>[] adj = new List[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new ArrayList<Integer>();\n        }\n        for (int[] edge : edges) {\n            adj[edge[0]].add(edge[1]);\n            adj[edge[1]].add(edge[0]);\n        }\n\n        int[] parent = new int[n];\n        Arrays.fill(parent, -1);\n        /* 找到与节点 0 最远的节点 x */\n        int x = findLongestNode(0, parent, adj);\n        /* 找到与节点 x 最远的节点 y */\n        int y = findLongestNode(x, parent, adj);\n        /* 求出节点 x 到节点 y 的路径 */\n        List<Integer> path = new ArrayList<Integer>();\n        parent[x] = -1;\n        while (y != -1) {\n            path.add(y);\n            y = parent[y];\n        }\n        int m = path.size();\n        if (m % 2 == 0) {\n            ans.add(path.get(m / 2 - 1));\n        }\n        ans.add(path.get(m / 2));\n        return ans;\n    }\n\n    public int findLongestNode(int u, int[] parent, List<Integer>[] adj) {\n        int n = adj.length;\n        int[] dist = new int[n];\n        Arrays.fill(dist, -1);\n        dist[u] = 0;\n        dfs(u, dist, parent, adj);\n        int maxdist = 0;\n        int node = -1;\n        for (int i = 0; i < n; i++) {\n            if (dist[i] > maxdist) {\n                maxdist = dist[i];\n                node = i;\n            }\n        }\n        return node;\n    }\n\n    public void dfs(int u, int[] dist, int[] parent, List<Integer>[] adj) {\n        for (int v : adj[u]) {\n            if (dist[v] < 0) {\n                dist[v] = dist[u] + 1;\n                parent[v] = u;\n                dfs(v, dist, parent, adj); \n            }\n        }\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public IList<int> FindMinHeightTrees(int n, int[][] edges) {\n        IList<int> ans = new List<int>();\n        if (n == 1) {\n            ans.Add(0);\n            return ans;\n        }\n        IList<int>[] adj = new IList<int>[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new List<int>();\n        }\n        foreach (int[] edge in edges) {\n            adj[edge[0]].Add(edge[1]);\n            adj[edge[1]].Add(edge[0]);\n        }\n\n        int[] parent = new int[n];\n        Array.Fill(parent, -1);\n        /* 找到与节点 0 最远的节点 x */\n        int x = FindLongestNode(0, parent, adj);\n        /* 找到与节点 x 最远的节点 y */\n        int y = FindLongestNode(x, parent, adj);\n        /* 求出节点 x 到节点 y 的路径 */\n        IList<int> path = new List<int>();\n        parent[x] = -1;\n        while (y != -1) {\n            path.Add(y);\n            y = parent[y];\n        }\n        int m = path.Count;\n        if (m % 2 == 0) {\n            ans.Add(path[m / 2 - 1]);\n        }\n        ans.Add(path[m / 2]);\n        return ans;\n    }\n\n    public int FindLongestNode(int u, int[] parent, IList<int>[] adj) {\n        int n = adj.Length;\n        int[] dist = new int[n];\n        Array.Fill(dist, -1);\n        dist[u] = 0;\n        DFS(u, dist, parent, adj);\n        int maxdist = 0;\n        int node = -1;\n        for (int i = 0; i < n; i++) {\n            if (dist[i] > maxdist) {\n                maxdist = dist[i];\n                node = i;\n            }\n        }\n        return node;\n    }\n\n    public void DFS(int u, int[] dist, int[] parent, IList<int>[] adj) {\n        foreach (int v in adj[u]) {\n            if (dist[v] < 0) {\n                dist[v] = dist[u] + 1;\n                parent[v] = u;\n                DFS(v, dist, parent, adj); \n            }\n        }\n    }\n}\n```\n\n```C [sol2-C]\nvoid dfs(int u, int * dist, int * parent, const struct ListNode ** adj) {\n    for (struct ListNode * node = adj[u]; node; node = node->next) {\n        int v = node->val;\n        if (dist[v] < 0) {\n            dist[v] = dist[u] + 1;\n            parent[v] = u;\n            dfs(v, dist, parent, adj); \n        }\n    }\n}\n\nint findLongestNode(int u, int * parent, const struct ListNode ** adj, int n) {\n    int * dist = (int *)malloc(sizeof(int) * n);\n    memset(dist, -1, sizeof(int) * n);\n    dist[u] = 0;\n    dfs(u, dist, parent, adj);\n    int maxdist = 0;\n    int node = -1;\n    for (int i = 0; i < n; i++) {\n        if (dist[i] > maxdist) {\n            maxdist = dist[i];\n            node = i;\n        }\n    }\n    free(dist);\n    return node;\n}\n\nint* findMinHeightTrees(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n    int * res = NULL;\n    if (n == 1) {\n        res = (int *)malloc(sizeof(int));\n        *res = 0;\n        *returnSize = 1;\n        return res;\n    }\n\n    struct ListNode ** adj = (struct ListNode *)malloc(sizeof(struct ListNode *) * n);\n    for (int i = 0; i < n; i++) {\n        adj[i] = NULL;\n    }\n    for (int i = 0; i < edgesSize; i++) {\n        int u = edges[i][0];\n        int v = edges[i][1];\n        struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = u;\n        node->next = adj[v];\n        adj[v] = node;\n        node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = v;\n        node->next = adj[u];\n        adj[u] = node;\n    }\n    \n    int * parent = (int *)malloc(sizeof(int) * n);\n    /* 找到与节点 0 最远的节点 x */\n    int x = findLongestNode(0, parent, adj, n);\n    /* 找到与节点 x 最远的节点 y */\n    int y = findLongestNode(x, parent, adj, n);\n    /* 求出节点 x 到节点 y 的路径 */\n    int * path = (int *)malloc(sizeof(int) * n);\n    int pos = 0;\n    parent[x] = -1;\n    while (y != -1) {\n        path[pos++] = y;\n        y = parent[y];\n    }\n    if (pos % 2 == 0) {\n        res = (int *)malloc(sizeof(int) * 2);\n        res[0] = path[pos / 2 - 1];\n        res[1] = path[pos / 2];\n        *returnSize = 2;\n    } else {\n        res = (int *)malloc(sizeof(int));\n        *res = path[pos / 2];\n        *returnSize = 1;\n    }\n    free(path);\n    free(parent);\n    for (int i = 0; i < n; i++) {\n        struct ListNode * node = adj[i];\n        while (node) {\n            struct ListNode * curr = node;\n            node = curr->next;\n            free(curr);\n        }\n    }\n    free(adj);\n    return res;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar findMinHeightTrees = function(n, edges) {\n    const ans = [];\n    if (n === 1) {\n        ans.push(0);\n        return ans;\n    }\n    const adj = new Array(n).fill(0).map(() => new Array());\n    for (const edge of edges) {\n        adj[edge[0]].push(edge[1]);\n        adj[edge[1]].push(edge[0]);\n    }\n\n    const parent = new Array(n).fill(-1);\n    /* 找到与节点 0 最远的节点 x */\n    let x = findLongestNode(0, parent, adj);\n    /* 找到与节点 x 最远的节点 y */\n    let y = findLongestNode(x, parent, adj);\n    /* 求出节点 x 到节点 y 的路径 */\n    const path = [];\n    parent[x] = -1;\n    while (y !== -1) {\n        path.push(y);\n        y = parent[y];\n    }\n    const m = path.length;\n    if (m % 2 === 0) {\n        ans.push(path[Math.floor(m / 2) - 1]);\n    }\n    ans.push(path[Math.floor(m / 2)]);\n    return ans;\n}\n\nconst findLongestNode = (u, parent, adj) => {\n    const n = adj.length;\n    const dist = new Array(n).fill(-1);\n    dist[u] = 0;\n\n    const dfs = (u, dist, parent, adj) => {\n        for (const v of adj[u]) {\n            if (dist[v] < 0) {\n                dist[v] = dist[u] + 1;\n                parent[v] = u;\n                dfs(v, dist, parent, adj); \n            }\n        }\n    }\n\n    dfs(u, dist, parent, adj);\n    let maxdist = 0;\n    let node = -1;\n    for (let i = 0; i < n; i++) {\n        if (dist[i] > maxdist) {\n            maxdist = dist[i];\n            node = i;\n        }\n    }\n    return node;\n}\n```\n\n```go [sol2-Golang]\nfunc findMinHeightTrees(n int, edges [][]int) []int {\n    if n == 1 {\n        return []int{0}\n    }\n\n    g := make([][]int, n)\n    for _, e := range edges {\n        x, y := e[0], e[1]\n        g[x] = append(g[x], y)\n        g[y] = append(g[y], x)\n    }\n\n    parents := make([]int, n)\n    maxDepth, node := 0, -1\n    var dfs func(int, int, int)\n    dfs = func(x, pa, depth int) {\n        if depth > maxDepth {\n            maxDepth, node = depth, x\n        }\n        parents[x] = pa\n        for _, y := range g[x] {\n            if y != pa {\n                dfs(y, x, depth+1)\n            }\n        }\n    }\n    dfs(0, -1, 1)\n    maxDepth = 0\n    dfs(node, -1, 1)\n\n    path := []int{}\n    for node != -1 {\n        path = append(path, node)\n        node = parents[node]\n    }\n    m := len(path)\n    if m%2 == 0 {\n        return []int{path[m/2-1], path[m/2]}\n    }\n    return []int{path[m/2]}\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是为节点的个数。图中边的个数为 $n-1$，因此建立图的关系需要的时间复杂度为 $O(n)$，通过深度优先搜索需要的时间复杂度为 $O(n + n - 1)$，求最长路径的时间复杂度为 $O(n)$，因此总的时间复杂度为 $O(n)$。\n\n+ 空间复杂度：$O(n)$，其中 $n$ 是节点的个数。由于题目给定的图中任何两个顶点都只有一条路径连接，因此图中边的数目刚好等于 $n-1$，用邻接表构造图所需的空间刚好为 $O(2 \\times n)$，存储每个节点的距离和父节点均为 $O(n)$，使用深度优先搜索时，递归的最大深度为 $O(n)$，所需的空间也为 $O(n)$，因此总的空间复杂度为 $O(n)$。\n\n#### 方法三：拓扑排序\n\n**思路与算法**\n\n由于树的高度由根节点到叶子节点之间的最大距离构成，假设树中距离最长的两个节点为 $(x,y)$，它们之间的距离为 $\\textit{maxdist} = \\textit{dist}[x][y]$，假设 $x$ 到 $y$ 的路径为 $x \\rightarrow p_1 \\rightarrow p_2 \\rightarrow \\cdots \\rightarrow p_{k-1} \\rightarrow p_k \\rightarrow y$，根据方法一的证明已知最小树的根节点一定为该路径中的中间节点，我们尝试删除最外层的度为 $1$ 的节点  $x,y$ 后，则可以知道路径中与 $x,y$ 相邻的节点 $p_1, p_k$ 此时也变为度为 $1$ 的节点，此时我们再次删除最外层度为 $1$ 的节点直到剩下根节点为止。\n\n可以用反证法证明，删除节点 $x, y$ 之后，节点 $p_1, p_k$ 一定变为度为 $1$ 的叶子节点，假设删除 $x, y$ 之后，节点 $p_1, p_k$ 的度不为 $1$，可以假设 $p_1$ 的度不为 $1$, 则此时与 $p_1$ 相邻的节点除了 $p_2$ 外还有其余节点 $q$ 且 $q$ 不在最长的路径中，此时我们知道在最开始的树中节点 $q$ 的度一定不为 $1$，与 $q$ 连接的节点为 $q'$，则此时经过节点 $q'$ 的路径 $\\textit{dist}[q'][y] = \\textit{dist}[p_1][y] + 2 > \\textit{dist}[x][y]$，这与 $\\textit{dist}[x][y]$ 为树中的最长路径相矛盾。\n\n实际做法如下：\n+ 首先找到所有度为 $1$ 的节点压入队列，此时令节点剩余计数 $\\textit{remainNodes} = n$；\n\n+ 同时将当前 $\\textit{remainNodes}$ 计数减去出度为 $1$ 的节点数目，将最外层的度为 $1$ 的叶子节点取出，并将与之相邻的节点的度减少，重复上述步骤将当前节点中度为 $1$ 的节点压入队列中；\n\n+ 重复上述步骤，直到剩余的节点数组 $\\textit{remainNodes} \\le 2$ 时，此时剩余的节点即为当前高度最小树的根节点。\n\n**代码**\n\n```Python [sol3-Python3]\nclass Solution:\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n        if n == 1:\n            return [0]\n\n        g = [[] for _ in range(n)]\n        deg = [0] * n\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n            deg[x] += 1\n            deg[y] += 1\n\n        q = [i for i, d in enumerate(deg) if d == 1]\n        remainNodes = n\n        while remainNodes > 2:\n            remainNodes -= len(q)\n            tmp = q\n            q = []\n            for x in tmp:\n                for y in g[x]:\n                    deg[y] -= 1\n                    if deg[y] == 1:\n                        q.append(y)\n        return q\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if (n == 1) {\n            return {0};\n        }\n        vector<int> degree(n);\n        vector<vector<int>> adj(n);\n        for (auto & edge : edges){\n            adj[edge[0]].emplace_back(edge[1]);\n            adj[edge[1]].emplace_back(edge[0]);\n            degree[edge[0]]++;\n            degree[edge[1]]++;\n        }\n        queue<int> qu;\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 1) {\n                qu.emplace(i);\n            }\n        }\n        int remainNodes = n;\n        while (remainNodes > 2) {\n            int sz = qu.size();\n            remainNodes -= sz;\n            for (int i = 0; i < sz; i++) {\n                int curr = qu.front();\n                qu.pop();\n                for (auto & v : adj[curr]) {\n                    if (--degree[v] == 1) {\n                        qu.emplace(v);\n                    }\n                }\n            }\n        }\n        while (!qu.empty()) {\n            ans.emplace_back(qu.front());\n            qu.pop();\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        List<Integer> ans = new ArrayList<Integer>();\n        if (n == 1) {\n            ans.add(0);\n            return ans;\n        }\n        int[] degree = new int[n];\n        List<Integer>[] adj = new List[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new ArrayList<Integer>();\n        }\n        for (int[] edge : edges) {\n            adj[edge[0]].add(edge[1]);\n            adj[edge[1]].add(edge[0]);\n            degree[edge[0]]++;\n            degree[edge[1]]++;\n        }\n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 1) {\n                queue.offer(i);\n            }\n        }\n        int remainNodes = n;\n        while (remainNodes > 2) {\n            int sz = queue.size();\n            remainNodes -= sz;\n            for (int i = 0; i < sz; i++) {\n                int curr = queue.poll();\n                for (int v : adj[curr]) {\n                    degree[v]--;\n                    if (degree[v] == 1) {\n                        queue.offer(v);\n                    }\n                }\n            }\n        }\n        while (!queue.isEmpty()) {\n            ans.add(queue.poll());\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public IList<int> FindMinHeightTrees(int n, int[][] edges) {\n        IList<int> ans = new List<int>();\n        if (n == 1) {\n            ans.Add(0);\n            return ans;\n        }\n        int[] degree = new int[n];\n        IList<int>[] adj = new IList<int>[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new List<int>();\n        }\n        foreach (int[] edge in edges) {\n            adj[edge[0]].Add(edge[1]);\n            adj[edge[1]].Add(edge[0]);\n            degree[edge[0]]++;\n            degree[edge[1]]++;\n        }\n        Queue<int> queue = new Queue<int>();\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 1) {\n                queue.Enqueue(i);\n            }\n        }\n        int remainNodes = n;\n        while (remainNodes > 2) {\n            int sz = queue.Count;\n            remainNodes -= sz;\n            for (int i = 0; i < sz; i++) {\n                int curr = queue.Dequeue();\n                foreach (int v in adj[curr]) {\n                    degree[v]--;\n                    if (degree[v] == 1) {\n                        queue.Enqueue(v);\n                    }\n                }\n            }\n        }\n        while (queue.Count > 0) {\n            ans.Add(queue.Dequeue());\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol3-C]\nint* findMinHeightTrees(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n    int * res = NULL;\n    if (n == 1) {\n        res = (int *)malloc(sizeof(int));\n        *res = 0;\n        *returnSize = 1;\n        return res;\n    }\n\n    struct ListNode ** adj = (struct ListNode *)malloc(sizeof(struct ListNode *) * n);\n    int * degree = (int *)malloc(sizeof(int) * n);\n    memset(degree, 0, sizeof(int) * n);\n    for (int i = 0; i < n; i++) {\n        adj[i] = NULL;\n    }\n    for (int i = 0; i < edgesSize; i++) {\n        int u = edges[i][0];\n        int v = edges[i][1];\n        struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = u;\n        node->next = adj[v];\n        adj[v] = node;\n        node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = v;\n        node->next = adj[u];\n        adj[u] = node;\n        degree[u]++;\n        degree[v]++;\n    }\n    \n    int * queue = (int *)malloc(sizeof(int) * n);\n    int head = 0;\n    int tail = 0;\n    for (int i = 0; i < n; i++) {\n        if (degree[i] == 1) {\n            queue[tail++] = i;\n        }\n    }\n    int remainNodes = n;\n    while (remainNodes > 2) {\n        int sz = tail - head;\n        remainNodes -= sz;\n        for (int i = 0; i < sz; i++) {\n            int curr = queue[head++];\n            struct ListNode * node = adj[curr];\n            while (node) {\n                int v = node->val;\n                degree[v]--;\n                if (degree[v] == 1) {\n                    queue[tail++] = v;\n                }\n                node = node->next;\n            }\n        }\n    }\n    res = (int *)malloc(sizeof(int) * remainNodes);\n    *returnSize = remainNodes;\n    int pos = 0;\n    while (head != tail) {\n        res[pos++] = queue[head++];\n    }\n    free(queue);\n    free(degree);\n    for (int i = 0; i < n; i++) {\n        struct ListNode * node = adj[i];\n        while (node) {\n            struct ListNode * curr = node;\n            node = curr->next;\n            free(curr);\n        }\n    }\n    free(adj);\n    return res;\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar findMinHeightTrees = function(n, edges) {\n    const ans = [];\n    if (n === 1) {\n        ans.push(0);\n        return ans;\n    }\n    const degree = new Array(n).fill(0);\n    const adj = new Array(n).fill(0).map(() => new Array());\n    for (const edge of edges) {\n        adj[edge[0]].push(edge[1]);\n        adj[edge[1]].push(edge[0]);\n        degree[edge[0]]++;\n        degree[edge[1]]++;\n    }\n    const queue = [];\n    for (let i = 0; i < n; i++) {\n        if (degree[i] === 1) {\n            queue.push(i);\n        }\n    }\n    let remainNodes = n;\n    while (remainNodes > 2) {\n        const sz = queue.length;\n        remainNodes -= sz;\n        for (let i = 0; i < sz; i++) {\n            const curr = queue.shift();\n            for (const v of adj[curr]) {\n                degree[v]--;\n                if (degree[v] === 1) {\n                    queue.push(v);\n                }\n            }\n        }\n    }\n    while (queue.length) {\n        ans.push(queue.shift());\n    }\n    return ans;\n};\n```\n\n```go [sol3-Golang]\nfunc findMinHeightTrees(n int, edges [][]int) []int {\n    if n == 1 {\n        return []int{0}\n    }\n\n    g := make([][]int, n)\n    deg := make([]int, n)\n    for _, e := range edges {\n        x, y := e[0], e[1]\n        g[x] = append(g[x], y)\n        g[y] = append(g[y], x)\n        deg[x]++\n        deg[y]++\n    }\n\n    q := []int{}\n    for i, d := range deg {\n        if d == 1 {\n            q = append(q, i)\n        }\n    }\n\n    remainNodes := n\n    for remainNodes > 2 {\n        remainNodes -= len(q)\n        tmp := q\n        q = nil\n        for _, x := range tmp {\n            for _, y := range g[x] {\n                deg[y]--\n                if deg[y] == 1 {\n                    q = append(q, y)\n                }\n            }\n        }\n    }\n    return q\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是为节点的个数。图中边的个数为 $n-1$，因此建立图的关系需要的时间复杂度为 $O(n)$，通过广度优先搜索需要的时间复杂度为 $O(n + n - 1)$，求最长路径的时间复杂度为 $O(n)$，因此总的时间复杂度为 $O(n)$。\n\n+ 空间复杂度：$O(n)$，其中 $n$ 是节点的个数。由于题目给定的图中任何两个顶点都只有一条路径连接，因此图中边的数目刚好等于 $n-1$，用邻接表构造图所需的空间刚好为 $O(2 \\times n)$，存储每个节点的距离和父节点均为 $O(n)$，使用广度优先搜索时，队列中最多有 $n$ 个元素，所需的空间也为 $O(n)$，因此空间复杂度为 $O(n)$。"
}