{
	"titleSlug": "cheapest-flights-within-k-stops",
	"slug": "gong-shui-san-xie-xiang-jie-bellman-ford-dc94",
	"url": "https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/solution/gong-shui-san-xie-xiang-jie-bellman-ford-dc94/",
	"content": "## 基本分析\n\n从题面看就能知道，这是一类「有限制」的最短路问题。\n\n「限制最多经过不超过 $k$ 个点」等价于「限制最多不超过 $k + 1$ 条边」，而解决「有边数限制的最短路问题」是 SPFA 所不能取代 Bellman Ford 算法的经典应用之一（SPFA 能做，但不能直接做）。\n\n**Bellman Ford/SPFA 都是基于动态规划，其原始的状态定义为 $f[i][k]$ 代表从起点到 $i$ 点，且经过最多 $k$ 条边的最短路径。这样的状态定义引导我们能够使用 Bellman Ford 来解决有边数限制的最短路问题。**\n\n**同样多源汇最短路算法 Floyd 也是基于动态规划，其原始的三维状态定义为 $f[i][j][k]$ 代表从点 $i$ 到点 $j$，且经过的所有点编号不会超过 $k$（即可使用点编号范围为 $[1, k]$）的最短路径。这样的状态定义引导我们能够使用 Floyd 求最小环或者求“重心点”（即删除该点后，最短路值会变大）。**\n\n如果你对几类最短算法不熟悉，可以看 [这里](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488007&idx=1&sn=9d0dcfdf475168d26a5a4bd6fcd3505d&chksm=fd9cb918caeb300e1c8844583db5c5318a89e60d8d552747ff8c2256910d32acd9013c93058f&token=754098973&lang=zh_CN#rd)，里面涵盖所有的「最短路算法」和「存图方式」。\n \n---\n\n## Bellman Ford + 邻接矩阵\n\n回到本题，「限制最多经过不超过 $k$ 个点」等价于「限制最多不超过 $k + 1$ 条边」，因此可以使用 Bellman Ford 来求解。\n\n点的数量只有 $100$，可以直接使用「邻接矩阵」的方式进行存图。\n\n> 需要注意的是，在遍历所有的“点对/边”进行松弛操作前，需要先对 $dist$ 进行备份，否则会出现「本次松弛操作所使用到的边，也是在同一次迭代所更新的」，从而不满足边数限制的要求。\n举个 🌰，例如本次松弛操作使用了从 $a$ 到 $b$ 的当前最短距离来更新 $dist[b]$，直接使用 $dist[a]$ 的话，不能确保 $dist[a]$ 不是在同一次迭代中所更新，如果 $dist[a]$ 是同一次迭代所更新的话，那么使用的边数将会大于 $k$ 条。\n因此在每次迭代开始前，我们都应该对 $dist$ 进行备份，在迭代时使用备份来进行松弛操作。\n\n![image.png](https://pic.leetcode-cn.com/1629775402-BKrDNg-image.png)\n\n代码：\n```Java []\nclass Solution {\n    int N = 110, INF = 0x3f3f3f3f;\n    int[][] g = new int[N][N];\n    int[] dist = new int[N];\n    int n, m, s, t, k;\n    public int findCheapestPrice(int _n, int[][] flights, int _src, int _dst, int _k) {\n        n = _n; s = _src; t = _dst; k = _k + 1;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                g[i][j] = i == j ? 0 : INF;\n            }\n        }\n        for (int[] f : flights) {\n            g[f[0]][f[1]] = f[2];\n        }\n        int ans = bf();\n        return ans > INF / 2 ? -1 : ans;\n    }\n    int bf() {\n        Arrays.fill(dist, INF);\n        dist[s] = 0;\n        for (int limit = 0; limit < k; limit++) {\n            int[] clone = dist.clone();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    dist[j] = Math.min(dist[j], clone[i] + g[i][j]);\n                }\n            }\n        }\n        return dist[t];\n    }\n}\n```\n* 时间复杂度：$O(k * n^2)$\n* 空间复杂度：$O(n^2)$\n\n\n---\n\n## Bellman Ford + 类\n\n我们知道 Bellman Ford 需要遍历所有的边，而使用「邻接矩阵」的存图方式让我们不得不遍历所有的点对，复杂度为 $O(n^2)$。\n\n而边的数量 $m$ 的数据范围为 $0 <= flights.length <= (n * (n - 1) / 2)$，因此我们可以使用「类」的方式进行存图，从而确保在遍历所有边的时候，复杂度严格为 $O(m)$，而不是 $O(n^2)$。\n\n![image.png](https://pic.leetcode-cn.com/1629775378-YcJJzg-image.png)\n\n代码：\n```Java []\nclass Solution {\n    class Edge {\n        int x, y, w;\n        Edge(int _x, int _y, int _w) {\n            x = _x; y = _y; w = _w;\n        }\n    }\n    int N = 110, INF = 0x3f3f3f3f;\n    int[] dist = new int[N];\n    List<Edge> list = new ArrayList<>();\n    int n, m, s, t, k;\n    public int findCheapestPrice(int _n, int[][] flights, int _src, int _dst, int _k) {\n        n = _n; s = _src; t = _dst; k = _k + 1;\n        for (int[] f : flights) {\n            list.add(new Edge(f[0], f[1], f[2]));\n        }\n        m = list.size();\n        int ans = bf();\n        return ans > INF / 2 ? -1 : ans;\n    }\n    int bf() {\n        Arrays.fill(dist, INF);\n        dist[s] = 0;\n        for (int i = 0; i < k; i++) {\n            int[] clone = dist.clone();\n            for (Edge e : list) {\n                int x = e.x, y = e.y, w = e.w;\n                dist[y] = Math.min(dist[y], clone[x] + w);\n            }\n        }\n        return dist[t];\n    }\n}\n```\n* 时间复杂度：共进行 $k + 1$ 次迭代，每次迭代备份数组复杂度为 $O(n)$，然后遍历所有的边进行松弛操作，复杂度为 $O(m)$。整体复杂度为 $O(k * (n + m))$\n* 空间复杂度：$O(n + m)$\n\n---\n\n## Bellman Ford\n\n更进一步，由于 Bellman Ford 核心操作需要遍历所有的边，因此也可以直接使用 $flights$ 数组作为存图信息，而无须额外存图。\n\n![image.png](https://pic.leetcode-cn.com/1629775353-jTgEoB-image.png)\n\n代码：\n```Java []\nclass Solution {\n    int N = 110, INF = 0x3f3f3f3f;\n    int[] dist = new int[N];\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        Arrays.fill(dist, INF);\n        dist[src] = 0;\n        for (int limit = 0; limit < k + 1; limit++) {\n            int[] clone = dist.clone();\n            for (int[] f : flights) {\n                int x = f[0], y = f[1], w = f[2];\n                dist[y] = Math.min(dist[y], clone[x] + w);\n            }\n        }\n        return dist[dst] > INF / 2 ? -1 : dist[dst];\n    }\n}\n```\n* 时间复杂度：共进行 $k + 1$ 次迭代，每次迭代备份数组复杂度为 $O(n)$，然后遍历所有的边进行松弛操作，复杂度为 $O(m)$。整体复杂度为 $O(k * (n + m))$\n* 空间复杂度：$O(n)$\n\n---\n\n## 最后\n\n**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ (\"▔□▔)/**\n\n也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png)（公主号后台回复「送书」即可参与长期看题解学算法送实体书活动）或 加入[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。\n\n所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~ "
}