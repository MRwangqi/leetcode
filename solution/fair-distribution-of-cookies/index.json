{
	"titleSlug": "fair-distribution-of-cookies",
	"slug": "jian-zhi-hui-su-by-baoya_uncle-7s48",
	"url": "https://leetcode-cn.com/problems/fair-distribution-of-cookies/solution/jian-zhi-hui-su-by-baoya_uncle-7s48/",
	"content": "首先容易想到了暴力解法：\r\n\r\n每一个饼干包（一共有n个）可以分给任意k个小朋友，一共有k^n种分法。暴力枚举一遍，找最大饼干数的最小值就行了。n和k最大取值为8，枚举方案一共有8^8个，有点大，暴力可能超时。\r\n\r\n\r\n那么可以用回溯+剪枝。回溯本身也类似于暴力法，只不过通过适当的剪枝可以将时间复杂度显著降低。\r\n\r\n\r\n一个技巧+三个剪枝方法：\r\n\r\n`技巧：`一开始对数组进行排序，先发放饼干较多的包，这样可以减少平均回溯深度。\r\n\r\n\r\n`剪枝1：`如果剩余的饼干包不够还没有拿到饼干的小朋友分了，直接返回。\r\n\r\n\r\n`剪枝2：`如果当前状态下某位小朋友的饼干数量比当前的答案还多，显然继续回溯下去也无法成为最优答案，直接返回。\r\n\r\n\r\n`剪枝3：`第一个零食包不管给哪个小朋友，所开启的回溯树都一样，所以首个饼干包只要给第一个小朋友就行了，这样的回溯树只有一个根节点（一个回溯树），否则有k个回溯树。\r\n\r\n\r\n有三道题跟这道题非常类似，没做过的可以去秒了，代码几乎可以复用：\r\n\r\n[473. 火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)\r\n[698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)\r\n[1723. 完成所有工作的最短时间](https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/)\r\n\r\n代码：\r\n\r\n```java\r\nclass Solution {\r\n    \r\n    int ans = Integer.MAX_VALUE;\r\n    int[] cookies;\r\n    int n;\r\n    int k;\r\n    \r\n    public int distributeCookies(int[] cookies, int k) {\r\n        \r\n        //技巧：先发饼干较多的包，这样让回溯过程更快。下面的回溯代码是从最后一个饼干包开始发所以这里是从小到大排序\r\n        Arrays.sort(cookies);\r\n        \r\n        this.cookies = cookies;\r\n        n = cookies.length;\r\n        this.k = k;\r\n        \r\n        //启动回溯\r\n        backtrack(new int[k], n-1);\r\n        \r\n        return ans;\r\n    }\r\n    \r\n    //bucket数组存放k个小朋友每个人当前的饼干数量，start为下一个要分发的饼干包下标\r\n    public void backtrack(int[] bucket, int start){\r\n        \r\n        //饼干发完了，统计哪个小朋友获得的饼干最多，更新答案。\r\n        if (start < 0){\r\n            int curAns = Integer.MIN_VALUE;\r\n            for (int count : bucket){\r\n                curAns = Math.max(curAns, count);\r\n            }\r\n            ans = Math.min(ans, curAns);\r\n            return;\r\n        }\r\n        \r\n        //剪枝1：如果剩余的饼干包不够空手的小朋友分了，直接返回。\r\n        int zeroCount = 0;\r\n        for (int count : bucket){\r\n            if (count == 0) zeroCount++;\r\n        }\r\n        if (zeroCount > start + 1) return;\r\n        \r\n        //剪枝2：如果某位小朋友的饼干数量比当前的答案还多，显然继续回溯下去也无法成为最优答案，直接返回。\r\n        for (int i = 0; i < k; i++){\r\n            if (bucket[i] > ans) return;\r\n        }\r\n        \r\n        for (int i = 0; i < k; i++){\r\n            //剪枝3：第一个零食包不管给哪个小朋友，所开启的回溯树都一样，只要给一个小朋友就行了，这样的回溯树一下子就少了很多。\r\n            if (start == n - 1 && i > 0) return;\r\n            \r\n            //标准回溯代码\r\n            bucket[i] += cookies[start];\r\n            backtrack(bucket, start - 1);\r\n            bucket[i] -= cookies[start];\r\n        }\r\n        return;\r\n    }\r\n}\r\n```\r\n"
}