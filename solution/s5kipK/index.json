{
	"titleSlug": "s5kipK",
	"slug": "by-tsreaper-z8by",
	"url": "https://leetcode-cn.com/problems/s5kipK/solution/by-tsreaper-z8by/",
	"content": "## 解法：点双连通分量缩点\r\n要求保留连通性，很容易想到点双连通分量和割点。\r\n\r\n### 简化问题：树上的情况\r\n首先考虑简化问题：题目给出的是一棵树，并按要求夺回据点。\r\n\r\n容易发现，一开始只能选择叶子节点（选非叶子节点树直接不连通），而且若这棵树有 $k$ 个叶子，我们至少选择其中的 $(k - 1)$ 个。因此我们选择权值最小的 $(k - 1)$ 个叶子即可。\r\n\r\n### 原问题\r\n将所有点双连通分量 [缩点](https://blog.51cto.com/u_15127597/3992474) 得到一棵树，题目转换为树上的情况。每个点的权值是该双连通分量中非割点权值的最小值。\r\n\r\n这个做法的正确性建立在如下事实的基础上：\r\n* 考虑一个单独的点双连通分量，一开始只需要选一个点，就能合法地占领整个点双连通分量；\r\n* 点双连通分量缩点后得到的一定是一棵树；\r\n* 缩点后得到的树的叶子一定不是原图中的割点。\r\n\r\n~~证明留给读者思考~~。\r\n\r\n## 参考代码（c++）\r\n```c++\r\nclass Solution {\r\n    const int S = 0;\r\n    int n;\r\n\r\n    vector<vector<int>> e;\r\n    vector<bool> isCut;\r\n    vector<int> dfn, low;\r\n    int clk = 0;\r\n    stack<int> stk;\r\n    // 所有点双连通分量\r\n    vector<vector<int>> dcc;\r\n\r\n    void tarjan(int sn) {\r\n        dfn[sn] = low[sn] = ++clk;\r\n        stk.push(sn);\r\n        int flag = 0;\r\n        for (int fn : e[sn]) {\r\n            if (!dfn[fn]) {\r\n                tarjan(fn);\r\n                low[sn] = min(low[sn], low[fn]);\r\n                if (low[fn] >= dfn[sn]) {\r\n                    flag++;\r\n                    if (sn != S || flag > 1) isCut[sn] = true;\r\n                    int t;\r\n                    dcc.push_back(vector<int>());\r\n                    do {\r\n                        t = stk.top(); stk.pop();\r\n                        dcc.back().push_back(t);\r\n                    } while (t != fn);\r\n                    dcc.back().push_back(sn);\r\n                }\r\n            } else low[sn] = min(low[sn], dfn[fn]);\r\n        }\r\n    }\r\n\r\npublic:\r\n    long long minimumCost(vector<int>& cost, vector<vector<int>>& roads) {\r\n        n = cost.size();\r\n        if (n == 1) return cost[0];\r\n\r\n        e = vector<vector<int>>(n);\r\n        for (auto &r : roads) e[r[0]].push_back(r[1]), e[r[1]].push_back(r[0]);\r\n        isCut = vector<bool>(n);\r\n        dfn = low = vector<int>(n);\r\n        tarjan(S);\r\n\r\n        // 整张图是一个双连通分量，选择整张图权值最小的点即可\r\n        if (dcc.size() == 1) {\r\n            int ans = 2e9;\r\n            for (int x : cost) ans = min(ans, x);\r\n            return ans;\r\n        }\r\n\r\n        vector<int> vec;\r\n        for (auto &c : dcc) {\r\n            int cnt = 0, mn = 2e9;\r\n            for (int x : c) {\r\n                if (isCut[x]) cnt++;\r\n                else mn = min(mn, cost[x]);\r\n            }\r\n            // 该双连通分量只和一个割点相连，是缩点形成的树的叶子节点\r\n            if (cnt == 1) vec.push_back(mn);\r\n        }\r\n        sort(vec.begin(), vec.end());\r\n        long long ans = 0;\r\n        for (int i = 0; i + 1 < vec.size(); i++) ans += vec[i];\r\n        return ans;\r\n    }\r\n};\r\n\r\n```"
}