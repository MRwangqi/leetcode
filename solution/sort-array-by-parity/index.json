{
	"titleSlug": "sort-array-by-parity",
	"slug": "an-qi-ou-pai-xu-shu-zu-by-leetcode-solut-gpmm",
	"url": "https://leetcode-cn.com/problems/sort-array-by-parity/solution/an-qi-ou-pai-xu-shu-zu-by-leetcode-solut-gpmm/",
	"content": "#### 方法一：两次遍历\n\n**思路**\n\n新建一个数组 $\\textit{res}$ 用来保存排序完毕的数组。遍历两次 $\\textit{nums}$，第一次遍历时把所有偶数依次追加到 $\\textit{res}$ 中，第二次遍历时把所有奇数依次追加到 $\\textit{res}$ 中。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def sortArrayByParity(self, nums: List[int]) -> List[int]:\n        return [num for num in nums if num % 2 == 0] + [num for num in nums if num % 2 == 1]\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> sortArrayByParity(vector<int>& nums) {\n        vector<int> res;\n        for (auto & num : nums) {\n            if (num % 2 == 0) {\n                res.push_back(num);\n            }\n        }\n        for (auto & num : nums) {\n            if (num % 2 == 1) {\n                res.push_back(num);\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] sortArrayByParity(int[] nums) {\n        int n = nums.length, index = 0;\n        int[] res = new int[n];\n        for (int num : nums) {\n            if (num % 2 == 0) {\n                res[index++] = num;\n            }\n        }\n        for (int num : nums) {\n            if (num % 2 == 1) {\n                res[index++] = num;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] SortArrayByParity(int[] nums) {\n        int n = nums.Length, index = 0;\n        int[] res = new int[n];\n        foreach (int num in nums) {\n            if (num % 2 == 0) {\n                res[index++] = num;\n            }\n        }\n        foreach (int num in nums) {\n            if (num % 2 == 1) {\n                res[index++] = num;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol1-C]\nint* sortArrayByParity(int* nums, int numsSize, int* returnSize) {\n    int *res = (int *)malloc(sizeof(int) * numsSize), index = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] % 2 == 0) {\n            res[index++] = nums[i];\n        }\n    }\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] % 2 == 1) {\n            res[index++] = nums[i];\n        }\n    }\n    *returnSize = numsSize;\n    return res;\n}\n```\n\n```go [sol1-Golang]\nfunc sortArrayByParity(nums []int) []int {\n    ans := make([]int, 0, len(nums))\n    for _, num := range nums {\n        if num%2 == 0 {\n            ans = append(ans, num)\n        }\n    }\n    for _, num := range nums {\n        if num%2 == 1 {\n            ans = append(ans, num)\n        }\n    }\n    return ans\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar sortArrayByParity = function(nums) {\n    let n = nums.length, index = 0;\n    const res = new Array(n).fill(0);\n    for (const num of nums) {\n        if (num % 2 === 0) {\n            res[index++] = num;\n        }\n    }\n    for (const num of nums) {\n        if (num % 2 === 1) {\n            res[index++] = num;\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度。需遍历 $\\textit{nums}$ 两次。\n\n- 空间复杂度：$O(1)$。结果不计入空间复杂度。\n\n#### 方法二：双指针 + 一次遍历\n\n**思路**\n\n记数组 $\\textit{nums}$ 的长度为 $n$。方法一需要遍历两次 $\\textit{nums}$，第一次遍历时遇到奇数会跳过，第二次遍历时遇到偶数会跳过，这部分可以优化。\n\n新建一个长度为 $n$ 的数组 $\\textit{res}$ 用来保存排完序的数组。遍历一遍 $\\textit{nums}$，遇到偶数则从 $\\textit{res}$ 左侧开始替换元素，遇到奇数则从 $\\textit{res}$ 右侧开始替换元素。遍历完成后，$\\textit{res}$ 就保存了排序完毕的数组。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def sortArrayByParity(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        res, left, right = [0] * n, 0, n - 1\n        for num in nums:\n            if num % 2 == 0:\n                res[left] = num\n                left += 1\n            else:\n                res[right] = num\n                right -= 1\n        return res\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> sortArrayByParity(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> res(n);\n        int left = 0, right = n - 1;\n        for (auto & num : nums) {\n            if (num % 2 == 0) {\n                res[left++] = num;\n            } else {\n                res[right--] = num;\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int[] sortArrayByParity(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        int left = 0, right = n - 1;\n        for (int num : nums) {\n            if (num % 2 == 0) {\n                res[left++] = num;\n            } else {\n                res[right--] = num;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int[] SortArrayByParity(int[] nums) {\n        int n = nums.Length;\n        int[] res = new int[n];\n        int left = 0, right = n - 1;\n        foreach (int num in nums) {\n            if (num % 2 == 0) {\n                res[left++] = num;\n            } else {\n                res[right--] = num;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol2-C]\nint* sortArrayByParity(int* nums, int numsSize, int* returnSize) {\n    int *res = (int *)malloc(sizeof(int) * numsSize);\n    int left = 0, right = numsSize - 1;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] % 2 == 0) {\n            res[left++] = nums[i];\n        } else {\n            res[right--] = nums[i];\n        }\n    }\n    *returnSize = numsSize;\n    return res;\n}\n```\n\n```go [sol2-Golang]\nfunc sortArrayByParity(nums []int) []int {\n    n := len(nums)\n    ans := make([]int, n)\n    left, right := 0, n-1\n    for _, num := range nums {\n        if num%2 == 0 {\n            ans[left] = num\n            left++\n        } else {\n            ans[right] = num\n            right--\n        }\n    }\n    return ans\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar sortArrayByParity = function(nums) {\n    const n = nums.length;\n    const res = new Array(n).fill(0);\n    let left = 0, right = n - 1;\n    for (const num of nums) {\n        if (num % 2 === 0) {\n            res[left++] = num;\n        } else {\n            res[right--] = num;\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度。只需遍历 $\\textit{nums}$ 一次。\n\n- 空间复杂度：$O(1)$。结果不计入空间复杂度。\n\n#### 方法三：原地交换\n\n**思路**\n\n记数组 $\\textit{nums}$ 的长度为 $n$。先从 $\\textit{nums}$ 左侧开始遍历，如果遇到的是偶数，就表示这个元素已经排好序了，继续从左往右遍历，直到遇到一个奇数。然后从 $\\textit{nums}$ 右侧开始遍历，如果遇到的是奇数，就表示这个元素已经排好序了，继续从右往左遍历，直到遇到一个偶数。交换这个奇数和偶数的位置，并且重复两边的遍历，直到在中间相遇，$\\textit{nums}$ 排序完毕。\n\n**代码**\n\n```Python [sol3-Python3]\nclass Solution:\n    def sortArrayByParity(self, nums: List[int]) -> List[int]:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            while left < right and nums[left] % 2 == 0:\n                left += 1\n            while left < right and nums[right] % 2 == 1:\n                right -= 1\n            if left < right:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n                right -= 1\n        return nums\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    vector<int> sortArrayByParity(vector<int>& nums) {\n        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            while (left < right and nums[left] % 2 == 0) {\n                left++;\n            }\n            while (left < right and nums[right] % 2 == 1) {\n                right--;\n            }\n            if (left < right) {\n                swap(nums[left++], nums[right--]);\n            }\n        }\n        return nums;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int[] sortArrayByParity(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            while (left < right && nums[left] % 2 == 0) {\n                left++;\n            }\n            while (left < right && nums[right] % 2 == 1) {\n                right--;\n            }\n            if (left < right) {\n                int temp = nums[left];\n                nums[left] = nums[right];\n                nums[right] = temp;\n                left++;\n                right--;\n            }\n        }\n        return nums;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int[] SortArrayByParity(int[] nums) {\n        int left = 0, right = nums.Length - 1;\n        while (left < right) {\n            while (left < right && nums[left] % 2 == 0) {\n                left++;\n            }\n            while (left < right && nums[right] % 2 == 1) {\n                right--;\n            }\n            if (left < right) {\n                int temp = nums[left];\n                nums[left] = nums[right];\n                nums[right] = temp;\n                left++;\n                right--;\n            }\n        }\n        return nums;\n    }\n}\n```\n\n```C [sol3-C]\nint* sortArrayByParity(int* nums, int numsSize, int* returnSize) {\n    int left = 0, right = numsSize - 1;\n    while (left < right) {\n        while (left < right && nums[left] % 2 == 0) {\n            left++;\n        }\n        while (left < right && nums[right] % 2 == 1) {\n            right--;\n        }\n        if (left < right) {\n            int tmp = nums[left];\n            nums[left] = nums[right];\n            nums[right] = tmp;\n            left++;\n            right--;\n        }\n    }\n    *returnSize = numsSize;\n    return nums;\n}\n```\n\n```go [sol3-Golang]\nfunc sortArrayByParity(nums []int) []int {\n    left, right := 0, len(nums)-1\n    for left < right {\n        for left < right && nums[left]%2 == 0 {\n            left++\n        }\n        for left < right && nums[right]%2 == 1 {\n            right--\n        }\n        if left < right {\n            nums[left], nums[right] = nums[right], nums[left]\n            left++\n            right--\n        }\n    }\n    return nums\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar sortArrayByParity = function(nums) {\n    let left = 0, right = nums.length - 1;\n    while (left < right) {\n        while (left < right && nums[left] % 2 === 0) {\n            left++;\n        }\n        while (left < right && nums[right] % 2 === 1) {\n            right--;\n        }\n        if (left < right) {\n            const temp = nums[left];\n            nums[left] = nums[right];\n            nums[right] = temp;\n            left++;\n            right--;\n        }\n    }\n    return nums;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。原数组中每个元素只遍历一次。\n\n- 空间复杂度：$O(1)$。原地排序，只消耗常数空间。"
}