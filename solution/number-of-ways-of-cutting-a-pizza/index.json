{
	"titleSlug": "number-of-ways-of-cutting-a-pizza",
	"slug": "shi-zai-by-thdlrt-lge3",
	"url": "https://leetcode-cn.com/problems/number-of-ways-of-cutting-a-pizza/solution/shi-zai-by-thdlrt-lge3/",
	"content": "### 解题思路\nctrlv的，作为笔记记录下\nnum计算思想\n![E8F5DFE1-D9B1-445F-A658-1CF21DB0D7BC.jpeg](https://pic.leetcode-cn.com/1665110923-TBLbXQ-E8F5DFE1-D9B1-445F-A658-1CF21DB0D7BC.jpeg)\n\n### 代码\n\n```cpp\n#define ll long long int\n\nclass Solution {\npublic:\n\n    const ll mod=1e9+7;\n    int ways(vector<string>& pizza, int k) {\n        int row=pizza.size(),col=pizza[0].length();\n        //计算num\n        vector<vector<int>> num(row,vector<int>(col,0));\n        if(pizza[0][0]=='A') num[0][0]=1;//前缀和，记录[0][0]到[i][j]内A的数目\n        for(int i=1;i<row;i++) num[i][0]=num[i-1][0]+(pizza[i][0]=='A');\n        for(int i=1;i<col;i++) num[0][i]=num[0][i-1]+(pizza[0][i]=='A');//边界初始化\n        for(int i=1;i<row;i++) for(int j=1;j<col;j++)//动态规划\n                num[i][j]=num[i-1][j]+num[i][j-1]-num[i-1][j-1]+(pizza[i][j]=='A');\n        //容斥原理\n            \n        //初始化dp\n        vector<vector<vector<ll>>> dp(row,vector<vector<ll>>(col,vector<ll>(k+1,0)));\n        dp[0][0][1]=1;//分一块也就是不分，方法数是1\n\n        //从k=2开始填充\n        for(int x=2;x<=k;x++){\n            for(int i=0;i<row;i++){\n                for(int j=0;j<col;j++){\n                    //dp为0代表不存在这种情况\n                    if(dp[i][j][x-1]==0)\n                        continue;\n                    //穷举水平切\n                    for(int z=i+1;z<row;z++){\n                        if(hasA(num,i,j,z-1,col-1) && hasA(num,z,j,row-1,col-1)){\n                            dp[z][j][x]+=dp[i][j][x-1];\n                            dp[z][j][x]%=mod;\n                        }\n                    }\n                    //穷举垂直切\n                    for(int z=j+1;z<col;z++){\n                        if(hasA(num,i,j,row-1,z-1) && hasA(num,i,z,row-1,col-1)){\n                            dp[i][z][x]+=dp[i][j][x-1];\n                           dp[i][z][x]%=mod;\n                        }\n                    }\n                }\n            }\n        }\n            \n        //计算答案\n        ll ans=0;\n        for(int i=0;i<row;i++){\n            for(int j=0;j<col;j++){\n                ans+=dp[i][j][k];\n            }\n            ans%=mod;\n        }\n        return ans;\n    }\n        \n    //计算存在A吗\n    bool hasA(vector<vector<int>>& num,int sr,int sc,int er,int ec){\n        int num1=0,num2=0,num3=0,res;\n        if(sr!=0 && sc!=0) num1=num[sr-1][sc-1];\n        if(sr!=0) num2=num[sr-1][ec];\n        if(sc!=0) num3=num[er][sc-1];\n        return num[er][ec]-num2-num3+num1>0;//容斥\n    }\n};\n\n```"
}