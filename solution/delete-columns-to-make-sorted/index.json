{
	"titleSlug": "delete-columns-to-make-sorted",
	"slug": "shan-lie-zao-xu-by-leetcode-solution-bqyy",
	"url": "https://leetcode-cn.com/problems/delete-columns-to-make-sorted/solution/shan-lie-zao-xu-by-leetcode-solution-bqyy/",
	"content": "#### 方法一：直接遍历\n\n**思路与算法**\n\n题目要求删除不是按字典序升序排列的列，由于每个字符串的长度都相等，我们可以逐列访问字符串数组，统计不是按字典序升序排列的列。\n\n对于第 $j$ 列的字符串，我们需要检测所有相邻字符是否均满足 $\\textit{strs}[i-1][j] \\le \\textit{strs}[i][j]$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        return sum(any(x > y for x, y in pairwise(col)) for col in zip(*strs))  # 空间复杂度为 O(m)，改用下标枚举可以达到 O(1)\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minDeletionSize(String[] strs) {\n        int row = strs.length;\n        int col = strs[0].length();\n        int ans = 0;\n        for (int j = 0; j < col; ++j) {\n            for (int i = 1; i < row; ++i) {\n                if (strs[i - 1].charAt(j) > strs[i].charAt(j)) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minDeletionSize(vector<string>& strs) {\n        int row = strs.size();\n        int col = strs[0].size();\n        int ans = 0;\n        for (int j = 0; j < col; ++j) {\n            for (int i = 1; i < row; ++i) {\n                if (strs[i - 1][j] > strs[i][j]) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinDeletionSize(string[] strs) {\n        int row = strs.Length;\n        int col = strs[0].Length;\n        int ans = 0;\n        for (int j = 0; j < col; ++j) {\n            for (int i = 1; i < row; ++i) {\n                if (strs[i - 1][j] > strs[i][j]) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\nint minDeletionSize(char ** strs, int strsSize) {\n    int row = strsSize;\n    int col = strlen(strs[0]);\n    int ans = 0;\n    for (int j = 0; j < col; ++j) {\n        for (int i = 1; i < row; ++i) {\n            if (strs[i - 1][j] > strs[i][j]) {\n                ans++;\n                break;\n            }\n        }\n    }\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc minDeletionSize(strs []string) (ans int) {\n    for j := range strs[0] {\n        for i := 1; i < len(strs); i++ {\n            if strs[i-1][j] > strs[i][j] {\n                ans++\n                break\n            }\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minDeletionSize = function(strs) {\n    const row = strs.length;\n    const col = strs[0].length;\n    let ans = 0;\n    for (let j = 0; j < col; ++j) {\n        for (let i = 1; i < row; ++i) {\n            if (strs[i - 1][j] > strs[i][j]) {\n                ans++;\n                break;\n            }\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m \\times n)$，其中 $m$ 为字符串数组的长度，$n$ 为数组中每个字符串的长度，判定每一列的的字典序需要遍历字符串数组每一列，因此时间复杂度为 $O(m \\times n)$。\n\n- 空间复杂度：$O(1)$。"
}