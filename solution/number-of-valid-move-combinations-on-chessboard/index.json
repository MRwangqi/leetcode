{
	"titleSlug": "number-of-valid-move-combinations-on-chessboard",
	"slug": "bao-li-po-jie-de-si-lu-xiang-jie-fu-java-t437",
	"url": "https://leetcode-cn.com/problems/number-of-valid-move-combinations-on-chessboard/solution/bao-li-po-jie-de-si-lu-xiang-jie-fu-java-t437/",
	"content": "这题真的很麻烦，就是硬做。\n找到所有的可能的移动组合，然后检查是不是有效的组合。\n\n### 审题\n**三种棋子的鄙视链：**\n- 后：无敌，8个方向移动\n- 车：水平移动，只有4个行动方向\n- 象：对角线移动，4个行动方向\n\n**整体策略：**\n我们需要记录下每个组合中每个棋子的中转位置和最终位置。\n假设一共有n个棋子，我们用一个n\\*8\\*8的三维数组来存储每一个棋子的情况。\n按照棋子的顺序，从左至右，我们依次遍历棋子的移动情况。\n当第一个棋子在完成移动之后，我们递归调用遍历方法，考虑第二个棋子的移动，直到考虑完所有棋子的情况。\n\n🌰举个例子：\n假设一共有2个棋子，我们用一个2\\*8\\*8的三维数组来存储每一个棋子的情况。\n按照棋子的顺序，从左至右，我们依次遍历棋子的移动情况。\n当第一个棋子在完成移动之后，我们考虑第二个棋子的移动。\n在考虑第二个棋子的移动时，我们需要结合第一个棋子的情况进行判断。具体方法如下。\n\n**单个棋子移动策略：**\n每个棋子准备移动到下一位置时，\n首先，需要考虑下一位置是否在棋盘内，\n其次，移动后，它有两个选择：\n1. 停在当前位置，不再移动\n只有当以下条件，对于所有之前棋子都满足时，棋子才可以在这个位置上停留：\n•  没有其他棋子在这次移动组合中停留在这个位置上\n•  没有其他棋子需要在这一时间后经过这个位置\n2. 继续移动\n若选择继续移动，则需要考虑下一次移动的位置的以下几点：\n•  是否有其他棋子同时经过\n•  是否有其他棋子早于或等于当前时间停留在这个位置上\n如果有以上一点发生，那么当前这个组合就不是一个有效的组合\n\n**特别地，**\n从上面的描述可以看出，中转位置和最终位置，对于后续棋子移动的影响是不一样的。最终位置会阻碍下一棋子对于这一方向的后续所有行动。所以，我们需要在棋盘上区别中转位置和最终位置。这里用到的一个技巧就是，对于最终位置，我们用负数表示，而中转位置能用时间t正数表示。\n\n话不多说，来上代码吧\n\n```java_详细注释 []\nclass Solution {\n    // 所有可能的移动方向，“后”可以向全部方向，“车”可以移动前四个方向，“象”可以移动后四个方向\n    int[][] dirs = new int[][] {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, -1}, {-1, 1}};\n    int[][][] board;\n\n    public int countCombinations(String[] pieces, int[][] positions) {\n        board = new int[positions.length][8][8];\n        return count_recursive(pieces, positions, 0); // 从第一个棋子的初始位置开始考虑\n    }\n\n    // 考虑第i个棋子，在前i-1个棋子位置已经确定的情况下，可以移动的组合数量\n    public int count_recursive(String[] pieces, int[][] positions, int i) {\n        if (i >= pieces.length)\n           return 1; // 如果后面没有其它棋子了，那么当前组合的数量只有1\n\n        int x = positions[i][0] - 1, y = positions[i][1] - 1, res = 0; // 起始位置开始考虑\n        for (int d = 0; d < 8; d++){ // 遍历各个方向\n            if ((d < 4 && pieces[i].equals(\"bishop\")) || (d >= 4 && pieces[i].equals(\"rook\")))\n               continue;\n\n            boolean blocked = false;           \n            for (int step = res == 0 ? 1 : 2; !blocked; step++) { // 因为起始位置在8个方向中只能考虑一次，所以我们用res作为旗帜，只有第一次移动时会考虑停留在初始位置\n                int nx = x + (step-1) * dirs[d][0]; // 新坐标\n                int ny = y + (step-1) * dirs[d][1];\n\n                if (nx < 0 || nx >= 8 || ny < 0 || ny >= 8) // 棋盘外了，无效移动，放弃这个方向\n                    break;\n\n                boolean canStop = true;\n                for (int j = 0; j < i; j++) { // 检查前i-1个棋子的在当前位置的情况，判断我们是否可以选择停留或继续前进\n                    // 只有当前i-1个棋子都没有停留，并且没有棋子会在之后经过，第i个棋子才可以在当前位置停留\n                    canStop = canStop && (board[j][nx][ny] >= 0) && (board[j][nx][ny] < step);\n                    // 如果前i-1个棋子在当前时间之前停留在此位置，或者有棋子同时经过这里，第i个棋子就不可以继续前进了\n                    blocked = blocked || ((board[j][nx][ny] < 0) && (-board[j][nx][ny] <= step)) || (board[j][nx][ny] == step);\n                }\n\n                if (!canStop)  { // 如果可以停留\n                    board[i][nx][ny] = -step; // 用负数标记当前位置为棋子i的停留位\n                    res += count_recursive(pieces, positions, i+1); // 考虑下一个棋子的移动的可能性\n                }\n                board[i][nx][ny] = step; // 选择继续移动\n            }\n            board[i] = new int[8][8]; // 当前方向考虑结束，清空棋盘，考虑下一个方向\n        }\n        return res; // 返回可能的总数\n    }\n}\n```\n```java_纯享版 []\nclass Solution {\n    int[][] dirs = new int[][] {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, -1}, {-1, 1}};\n    int[][][] board;\n\n    public int countCombinations(String[] pieces, int[][] positions) {\n        board = new int[positions.length][8][8];\n        return count_recursive(pieces, positions, 0);\n    }\n\n    public int count_recursive(String[] pieces, int[][] positions, int i) {\n        if (i >= pieces.length)\n           return 1;\n        int x = positions[i][0] - 1, y = positions[i][1] - 1, res = 0;\n\n        for (int d = 0; d < 8; d++){\n            if ((d < 4 && pieces[i].equals(\"bishop\")) || (d >= 4 && pieces[i].equals(\"rook\")))\n               continue;\n\n            boolean blocked = false;           \n            for (int step = res == 0 ? 1 : 2; !blocked; step++) { // ?\n                int nx = x + (step-1) * dirs[d][0];\n                int ny = y + (step-1) * dirs[d][1];\n\n                if (nx < 0 || nx >= 8 || ny < 0 || ny >= 8) //if goes out of board\n                    break;\n\n                boolean canStop = true;\n                for (int j = 0; j < i; j++) {\n                    canStop = canStop && (board[j][nx][ny] >= 0) && (board[j][nx][ny] < step);\n                    blocked = blocked || ((board[j][nx][ny] < 0) && (-board[j][nx][ny] <= step)) || (board[j][nx][ny] == step);\n                }\n\n                if (canStop)  {\n                    board[i][nx][ny] = -step;\n                    res += count_recursive(pieces, positions, i+1);\n                }\n                board[i][nx][ny] = step;\n            }\n            board[i] = new int[8][8];\n        }\n        return res;\n    }\n}\n```\n\n\n\n"
}