{
	"titleSlug": "possible-bipartition",
	"slug": "ke-neng-de-er-fen-fa-by-leetcode-solutio-guo7",
	"url": "https://leetcode-cn.com/problems/possible-bipartition/solution/ke-neng-de-er-fen-fa-by-leetcode-solutio-guo7/",
	"content": "#### 方法一：深度优先搜索\n\n**思路与算法**\n\n首先题目给定 $n$ 个人为一组（编号为 $1, 2, \\dots, n$），其中 $n$ 为偶数，并给出数组 $\\textit{dislike}$，其中 $\\textit{dislike}[i] = \\{a_i, b_i\\}$ 表示编号 $a_i$ 的用户不喜欢用户 $b_i$，$1 \\le a_i < b_i \\le n$。现在判断是否能将 $n$ 个人分成两组，并满足当一个人不喜欢某一个人时，该两人不在同一组中出现。\n\n我们可以尝试用「染色法」来解决问题：假设第一组中的人是红色，第二组中的人为蓝色。我们依次遍历每一个人，如果当前的人没有被分组，就将其分到第一组（即染为红色），那么这个人不喜欢的人必须分到第二组中（染为蓝色）。然后任何新被分到第二组中的人，其不喜欢的人必须被分到第一组，依此类推。如果在染色的过程中存在冲突，就表示这个任务是不可能完成的，否则说明染色的过程有效（即存在合法的分组方案）。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        g = [[] for _ in range(n)]\n        for x, y in dislikes:\n            g[x - 1].append(y - 1)\n            g[y - 1].append(x - 1)\n        color = [0] * n  # color[x] = 0 表示未访问节点 x\n        def dfs(x: int, c: int) -> bool:\n            color[x] = c\n            return all(color[y] != c and (color[y] or dfs(y, -c)) for y in g[x])\n        return all(c or dfs(i, 1) for i, c in enumerate(color))\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool dfs(int curnode, int nowcolor, vector<int>& color, const vector<vector<int>>& g) {\n        color[curnode] = nowcolor;\n        for (auto& nextnode : g[curnode]) {\n            if (color[nextnode] && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (!color[nextnode] && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> color(n + 1, 0);\n        vector<vector<int>> g(n + 1);\n        for (auto& p : dislikes) {\n            g[p[0]].push_back(p[1]);\n            g[p[1]].push_back(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] color = new int[n + 1];\n        List<Integer>[] g = new List[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean dfs(int curnode, int nowcolor, int[] color, List<Integer>[] g) {\n        color[curnode] = nowcolor;\n        for (int nextnode : g[curnode]) {\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] == 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool PossibleBipartition(int n, int[][] dislikes) {\n        int[] color = new int[n + 1];\n        IList<int>[] g = new IList<int>[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new List<int>();\n        }\n        foreach (int[] p in dislikes) {\n            g[p[0]].Add(p[1]);\n            g[p[1]].Add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !DFS(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public bool DFS(int curnode, int nowcolor, int[] color, IList<int>[] g) {\n        color[curnode] = nowcolor;\n        foreach (int nextnode in g[curnode]) {\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] == 0 && !DFS(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C [sol1-C]\nbool dfs(int curnode, int nowcolor, int *color, struct ListNode **g) {\n    color[curnode] = nowcolor;\n    for (struct ListNode *nextnode = g[curnode]; nextnode; nextnode = nextnode->next) {\n        if (color[nextnode->val] && color[nextnode->val] == color[curnode]) {\n            return false;\n        }\n        if (!color[nextnode->val] && !dfs(nextnode->val, 3 ^ nowcolor, color, g)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize) {\n    int color[n + 1];\n    struct ListNode *g[n + 1];\n    for (int i = 0; i <= n; i++) {\n        color[i] = 0;\n        g[i] = NULL;\n    }\n    for (int i = 0; i < dislikesSize; i++) {\n        int a = dislikes[i][0], b = dislikes[i][1];\n        struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = a;\n        node->next = g[b];\n        g[b] = node;\n        node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = b;\n        node->next = g[a];\n        g[a] = node;\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (color[i] == 0 && !dfs(i, 1, color, g)) {\n            for (int j = 0; j <= n; j++) {\n                struct ListNode * node = g[j];\n                while (node) {\n                    struct ListNode * prev = node;\n                    node = node->next;\n                    free(prev);\n                }\n            }\n            return false;\n        }\n    }\n    for (int j = 0; j <= n; j++) {\n        struct ListNode * node = g[j];\n        while (node) {\n            struct ListNode * prev = node;\n            node = node->next;\n            free(prev);\n        }\n    }\n    return true;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar possibleBipartition = function(n, dislikes) {\n    const dfs = (curnode, nowcolor, color, g) => {\n        color[curnode] = nowcolor;\n        for (const nextnode of g[curnode]) {\n            if (color[nextnode] !== 0 && color[nextnode] === color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] === 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    const color = new Array(n + 1).fill(0);\n    const g = new Array(n + 1).fill(0);\n    for (let i = 0; i <= n; ++i) {\n        g[i] = [];\n    }\n    for (const p of dislikes) {\n        g[p[0]].push(p[1]);\n        g[p[1]].push(p[0]);\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (color[i] === 0 && !dfs(i, 1, color, g)) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n\n```go [sol1-Golang]\nfunc possibleBipartition(n int, dislikes [][]int) bool {\n    g := make([][]int, n)\n    for _, d := range dislikes {\n        x, y := d[0]-1, d[1]-1\n        g[x] = append(g[x], y)\n        g[y] = append(g[y], x)\n    }\n    color := make([]int, n) // color[x] = 0 表示未访问节点 x\n    var dfs func(int, int) bool\n    dfs = func(x, c int) bool {\n        color[x] = c\n        for _, y := range g[x] {\n            if color[y] == c || color[y] == 0 && !dfs(y, 3^c) {\n                return false\n            }\n        }\n        return true\n    }\n    for i, c := range color {\n        if c == 0 && !dfs(i, 1) {\n            return false\n        }\n    }\n    return true\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + m)$，其中 $n$ 题目给定的人数，$m$ 为给定的 $\\textit{dislike}$ 数组的大小。\n- 空间复杂度：$O(n + m)$，其中 $n$ 题目给定的人数，$m$ 为给定的 $\\textit{dislike}$ 数组的大小。\n\n#### 方法二：广度优先搜索\n\n**思路与算法**\n\n同样我们也可以通过「广度优先搜索」来实现「方法一」中「染色法」的过程。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        g = [[] for _ in range(n)]\n        for x, y in dislikes:\n            g[x - 1].append(y - 1)\n            g[y - 1].append(x - 1)\n        color = [0] * n  # color[x] = 0 表示未访问节点 x\n        for i, c in enumerate(color):\n            if c == 0:\n                q = deque([i])\n                color[i] = 1\n                while q:\n                    x = q.popleft()\n                    for y in g[x]:\n                        if color[y] == color[x]:\n                            return False\n                        if color[y] == 0:\n                            color[y] = -color[x]\n                            q.append(y)\n        return True\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> color(n + 1, 0);\n        vector<vector<int>> g(n + 1);\n        for (auto& p : dislikes) {\n            g[p[0]].push_back(p[1]);\n            g[p[1]].push_back(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0) {\n                queue<int> q;\n                q.push(i);\n                color[i] = 1;\n                while (!q.empty()) {\n                    auto t = q.front();\n                    q.pop();\n                    for (auto& next : g[t]) {\n                        if (color[next] > 0 && color[next] == color[t]) {\n                            return false;\n                        }\n                        if (color[next] == 0) {\n                            color[next] = 3 ^ color[t];\n                            q.push(next);\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] color = new int[n + 1];\n        List<Integer>[] g = new List[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0) {\n                Queue<Integer> queue = new ArrayDeque<Integer>();\n                queue.offer(i);\n                color[i] = 1;\n                while (!queue.isEmpty()) {\n                    int t = queue.poll();\n                    for (int next : g[t]) {\n                        if (color[next] > 0 && color[next] == color[t]) {\n                            return false;\n                        }\n                        if (color[next] == 0) {\n                            color[next] = 3 ^ color[t];\n                            queue.offer(next);\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public bool PossibleBipartition(int n, int[][] dislikes) {\n        int[] color = new int[n + 1];\n        IList<int>[] g = new IList<int>[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new List<int>();\n        }\n        foreach (int[] p in dislikes) {\n            g[p[0]].Add(p[1]);\n            g[p[1]].Add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0) {\n                Queue<int> queue = new Queue<int>();\n                queue.Enqueue(i);\n                color[i] = 1;\n                while (queue.Count > 0) {\n                    int t = queue.Dequeue();\n                    foreach (int next in g[t]) {\n                        if (color[next] > 0 && color[next] == color[t]) {\n                            return false;\n                        }\n                        if (color[next] == 0) {\n                            color[next] = 3 ^ color[t];\n                            queue.Enqueue(next);\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C [sol2-C]\nbool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize) {\n    int color[n + 1];\n    struct ListNode *g[n + 1];\n    for (int i = 0; i <= n; i++) {\n        color[i] = 0;\n        g[i] = NULL;\n    }\n    for (int i = 0; i < dislikesSize; i++) {\n        int a = dislikes[i][0], b = dislikes[i][1];\n        struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = a;\n        node->next = g[b];\n        g[b] = node;\n        node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = b;\n        node->next = g[a];\n        g[a] = node;\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (color[i] == 0) {\n            int queue[n];\n            int head = 0, tail = 0;\n            queue[tail++] = i;\n            color[i] = 1;\n            while (head != tail) {\n                int t = queue[head++];\n                for (struct ListNode *nextNode = g[t]; nextNode; nextNode = nextNode->next) {\n                    int next = nextNode->val;\n                    if (color[next] > 0 && color[next] == color[t]) {\n                        for (int j = 0; j <= n; j++) {\n                            struct ListNode * node = g[j];\n                            while (node) {\n                                struct ListNode * prev = node;\n                                node = node->next;\n                                free(prev);\n                            }\n                        }\n                        return false;\n                    }\n                    if (color[next] == 0) {\n                        color[next] = 3 ^ color[t];\n                        queue[tail++] = next;\n                    }\n                }\n            }\n        }\n    }\n    for (int j = 0; j <= n; j++) {\n        struct ListNode * node = g[j];\n        while (node) {\n            struct ListNode * prev = node;\n            node = node->next;\n            free(prev);\n        }\n    }\n    return true;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar possibleBipartition = function(n, dislikes) {\n    const color = new Array(n + 1).fill(0);\n    const g = new Array(n + 1).fill(0);\n    for (let i = 0; i <= n; ++i) {\n        g[i] = [];\n    }\n    for (const p of dislikes) {\n        g[p[0]].push(p[1]);\n        g[p[1]].push(p[0]);\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (color[i] === 0) {\n            const queue = [i];\n            color[i] = 1;\n            while (queue.length !== 0) {\n                const t = queue.shift();\n                for (const next of g[t]) {\n                    if (color[next] > 0 && color[next] === color[t]) {\n                        return false;\n                    }\n                    if (color[next] === 0) {\n                        color[next] = 3 ^ color[t];\n                        queue.push(next);\n                    }\n                }\n            }\n        }\n    }\n    return true;\n};\n```\n\n```go [sol2-Golang]\nfunc possibleBipartition(n int, dislikes [][]int) bool {\n    g := make([][]int, n)\n    for _, d := range dislikes {\n        x, y := d[0]-1, d[1]-1\n        g[x] = append(g[x], y)\n        g[y] = append(g[y], x)\n    }\n    color := make([]int, n) // 0 表示未访问该节点\n    for i, c := range color {\n        if c == 0 {\n            q := []int{i}\n            color[i] = 1\n            for len(q) > 0 {\n                x := q[0]\n                q = q[1:]\n                for _, y := range g[x] {\n                    if color[y] == color[x] {\n                        return false\n                    }\n                    if color[y] == 0 {\n                        color[y] = -color[x]\n                        q = append(q, y)\n                    }\n                }\n            }\n        }\n    }\n    return true\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + m)$，其中 $n$ 题目给定的人数，$m$ 为给定的 $\\textit{dislike}$ 数组的大小。\n- 空间复杂度：$O(n + m)$，其中 $n$ 题目给定的人数，$m$ 为给定的 $\\textit{dislike}$ 数组的大小。\n\n#### 方法三：并查集\n\n**思路与算法**\n\n同样我们也可以用「并查集」来进行分组判断：由于最后只有两组，所以某一个人全部不喜欢人一定会在同一个组中，我们可以用「并查集」进行连接，并判断这个人是否与他不喜欢的人相连，如果相连则表示存在冲突，否则说明此人和他不喜欢的人在当前可以进行合法分组。\n\n**代码**\n\n```Python [sol3-Python3]\nclass UnionFind:\n    def __init__(self, n: int):\n        self.fa = list(range(n))\n        self.rank = [1] * n\n\n    def find(self, x: int) -> int:\n        if self.fa[x] != x:\n            self.fa[x] = self.find(self.fa[x])\n        return self.fa[x]\n\n    def union(self, x: int, y: int) -> None:\n        fx, fy = self.find(x), self.find(y)\n        if fx == fy:\n            return\n        if self.rank[fx] < self.rank[fy]:\n            fx, fy = fy, fx\n        self.rank[fx] += self.rank[fy]\n        self.fa[fy] = fx\n\n    def is_connected(self, x: int, y: int) -> bool:\n        return self.find(x) == self.find(y)\n\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        g = [[] for _ in range(n)]\n        for x, y in dislikes:\n            g[x - 1].append(y - 1)\n            g[y - 1].append(x - 1)\n        uf = UnionFind(n)\n        for x, nodes in enumerate(g):\n            for y in nodes:\n                uf.union(nodes[0], y)\n                if uf.is_connected(x, y):\n                    return False\n        return True\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int findFa(int x, vector<int>& fa) {\n        return fa[x] < 0 ? x : fa[x] = findFa(fa[x], fa);\n    }\n\n    void unit(int x, int y, vector<int>& fa) {\n        x = findFa(x, fa);\n        y = findFa(y, fa);\n        if (x == y) {\n            return ;\n        }\n        if (fa[x] < fa[y]) {\n            swap(x, y);\n        }\n        fa[x] += fa[y];\n        fa[y] = x;\n    }\n\n    bool isconnect(int x, int y, vector<int>& fa) {\n        x = findFa(x, fa);\n        y = findFa(y, fa);\n        return x == y;\n    }\n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> fa(n + 1, -1);\n        vector<vector<int>> g(n + 1);\n        for (auto& p : dislikes) {\n            g[p[0]].push_back(p[1]);\n            g[p[1]].push_back(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < g[i].size(); ++j) {\n                unit(g[i][0], g[i][j], fa);\n                if (isconnect(i, g[i][j], fa)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] fa = new int[n + 1];\n        Arrays.fill(fa, -1);\n        List<Integer>[] g = new List[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < g[i].size(); ++j) {\n                unit(g[i].get(0), g[i].get(j), fa);\n                if (isconnect(i, g[i].get(j), fa)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void unit(int x, int y, int[] fa) {\n        x = findFa(x, fa);\n        y = findFa(y, fa);\n        if (x == y) {\n            return ;\n        }\n        if (fa[x] < fa[y]) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n        fa[x] += fa[y];\n        fa[y] = x;\n    }\n\n    public boolean isconnect(int x, int y, int[] fa) {\n        x = findFa(x, fa);\n        y = findFa(y, fa);\n        return x == y;\n    }\n\n    public int findFa(int x, int[] fa) {\n        return fa[x] < 0 ? x : (fa[x] = findFa(fa[x], fa));\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public bool PossibleBipartition(int n, int[][] dislikes) {\n        int[] fa = new int[n + 1];\n        Array.Fill(fa, -1);\n        IList<int>[] g = new IList<int>[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new List<int>();\n        }\n        foreach (int[] p in dislikes) {\n            g[p[0]].Add(p[1]);\n            g[p[1]].Add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < g[i].Count; ++j) {\n                Unit(g[i][0], g[i][j], fa);\n                if (Isconnect(i, g[i][j], fa)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void Unit(int x, int y, int[] fa) {\n        x = FindFa(x, fa);\n        y = FindFa(y, fa);\n        if (x == y) {\n            return ;\n        }\n        if (fa[x] < fa[y]) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n        fa[x] += fa[y];\n        fa[y] = x;\n    }\n\n    public bool Isconnect(int x, int y, int[] fa) {\n        x = FindFa(x, fa);\n        y = FindFa(y, fa);\n        return x == y;\n    }\n\n    public int FindFa(int x, int[] fa) {\n        return fa[x] < 0 ? x : (fa[x] = FindFa(fa[x], fa));\n    }\n}\n```\n\n```C [sol3-C]\nint findFa(int x, int* fa) {\n    return fa[x] < 0 ? x : (fa[x] = findFa(fa[x], fa));\n}\n\nvoid swap(int *a, int *b) {\n    int c = *a;\n    *a = *b;\n    *b = c;\n}\n\nvoid unit(int x, int y, int* fa) {\n    x = findFa(x, fa);\n    y = findFa(y, fa);\n    if (x == y) {\n        return ;\n    }\n    if (fa[x] < fa[y]) {\n        swap(&x, &y);\n    }\n    fa[x] += fa[y];\n    fa[y] = x;\n}\n\nbool isconnect(int x, int y, int* fa) {\n    x = findFa(x, fa);\n    y = findFa(y, fa);\n    return x == y;\n}\n\nbool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize) {\n    int color[n + 1], fa[n + 1];\n    struct ListNode *g[n + 1];\n    for (int i = 0; i <= n; i++) {\n        color[i] = 0, fa[i] = -1;\n        g[i] = NULL;\n    }\n    for (int i = 0; i < dislikesSize; i++) {\n        int a = dislikes[i][0], b = dislikes[i][1];\n        struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = a;\n        node->next = g[b];\n        g[b] = node;\n        node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = b;\n        node->next = g[a];\n        g[a] = node;\n    }\n    for (int i = 1; i <= n; ++i) {\n        for (struct ListNode *node = g[i]; node; node = node->next) {\n            unit(g[i]->val, node->val, fa);\n            if (isconnect(i, node->val, fa)) {\n                for (int j = 0; j <= n; j++) {\n                    struct ListNode * node = g[j];\n                    while (node) {\n                        struct ListNode * prev = node;\n                        node = node->next;\n                        free(prev);\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    for (int j = 0; j <= n; j++) {\n        struct ListNode * node = g[j];\n        while (node) {\n            struct ListNode * prev = node;\n            node = node->next;\n            free(prev);\n        }\n    }\n    return true;\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar possibleBipartition = function(n, dislikes) {\n    const fa = new Array(n + 1).fill(-1);\n    const g = new Array(n + 1).fill(0);\n    for (let i = 0; i <= n; ++i) {\n        g[i] = [];\n    }\n    for (const p of dislikes) {\n        g[p[0]].push(p[1]);\n        g[p[1]].push(p[0]);\n    }\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 0; j < g[i].length; ++j) {\n            unit(g[i][0], g[i][j], fa);\n            if (isconnect(i, g[i][j], fa)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nconst unit = (x, y, fa) => {\n    x = findFa(x, fa);\n    y = findFa(y, fa);\n    if (x === y) {\n        return ;\n    }\n    if (fa[x] < fa[y]) {\n        const temp = x;\n        x = y;\n        y = temp;\n    }\n    fa[x] += fa[y];\n    fa[y] = x;\n}\n\nconst isconnect = (x, y, fa) => {\n    x = findFa(x, fa);\n    y = findFa(y, fa);\n    return x === y;\n}\n\nconst findFa = (x, fa) => {\n    return fa[x] < 0 ? x : (fa[x] = findFa(fa[x], fa));\n}\n```\n\n```go [sol3-Golang]\ntype unionFind struct {\n    parent, rank []int\n}\n\nfunc newUnionFind(n int) unionFind {\n    parent := make([]int, n)\n    for i := range parent {\n        parent[i] = i\n    }\n    return unionFind{parent, make([]int, n)}\n}\n\nfunc (uf unionFind) find(x int) int {\n    if uf.parent[x] != x {\n        uf.parent[x] = uf.find(uf.parent[x])\n    }\n    return uf.parent[x]\n}\n\nfunc (uf unionFind) union(x, y int) {\n    x, y = uf.find(x), uf.find(y)\n    if x == y {\n        return\n    }\n    if uf.rank[x] > uf.rank[y] {\n        uf.parent[y] = x\n    } else if uf.rank[x] < uf.rank[y] {\n        uf.parent[x] = y\n    } else {\n        uf.parent[y] = x\n        uf.rank[x]++\n    }\n}\n\nfunc (uf unionFind) isConnected(x, y int) bool {\n    return uf.find(x) == uf.find(y)\n}\n\nfunc possibleBipartition(n int, dislikes [][]int) bool {\n    g := make([][]int, n)\n    for _, d := range dislikes {\n        x, y := d[0]-1, d[1]-1\n        g[x] = append(g[x], y)\n        g[y] = append(g[y], x)\n    }\n    uf := newUnionFind(n)\n    for x, nodes := range g {\n        for _, y := range nodes {\n            uf.union(nodes[0], y)\n            if uf.isConnected(x, y) {\n                return false\n            }\n        }\n    }\n    return true\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + m\\alpha(n))$，其中 $n$ 题目给定的人数，$m$ 为给定的 $\\textit{dislike}$ 数组的大小，$\\alpha$ 是反 $\\text{Ackerman}$ 函数。\n- 空间复杂度：$O(n + m)$，其中 $n$ 题目给定的人数，$m$ 为给定的 $\\textit{dislike}$ 数组的大小。"
}