{
	"titleSlug": "design-linked-list",
	"slug": "she-ji-lian-biao-by-leetcode-solution-abix",
	"url": "https://leetcode-cn.com/problems/design-linked-list/solution/she-ji-lian-biao-by-leetcode-solution-abix/",
	"content": "#### 方法一：单向链表\n\n**思路**\n\n实现单向链表，即每个节点仅存储本身的值和后继节点。除此之外，我们还需要一个哨兵（sentinel）节点作为头节点，和一个 $\\textit{size}$ 参数保存有效节点数。如下图所示。\n![img](https://assets.leetcode-cn.com/solution-static/707/1_1.png)\n\n初始化时，只需创建头节点 $\\textit{head}$ 和 $\\textit{size}$ 即可。\n\n实现 $\\textit{get}(\\textit{index})$ 时，先判断有效性，再通过循环来找到对应的节点的值。如下图所示。\n![img](https://assets.leetcode-cn.com/solution-static/707/1_4.png)\n\n实现 $\\textit{addAtIndex}(\\textit{index, val})$ 时，如果 $\\textit{index}$ 是有效值，则需要找到原来下标为 $\\textit{index}$ 的节点的前驱节点 $\\textit{pred}$，并创建新节点 $\\textit{to\\_add}$，将$\\textit{to\\_add}$ 的后继节点设为 $\\textit{pred}$ 的后继节点，将 $\\textit{pred}$ 的后继节点更新为 $\\textit{to\\_add}$，这样就将 $\\textit{to\\_add}$ 插入到了链表中。最后需要更新 $\\textit{size}$。这样的操作对于 $\\textit{index} = 0$ 也成立，如以下两张图所示。\n![img](https://assets.leetcode-cn.com/solution-static/707/1_2.png)\n![img](https://assets.leetcode-cn.com/solution-static/707/1_3.png)\n\n实现 $\\textit{addAtHead}(\\textit{val})$ 和 $\\textit{addAtTail}(\\textit{val})$ 时，可以借助 $\\textit{addAtIndex}(\\textit{index, val})$ 来实现。\n\n实现 $\\textit{deleteAtIndex}(\\textit{index})$，先判断参数有效性。然后找到下标为 $\\textit{index}$ 的节点的前驱节点 $\\textit{pred}$，通过将 $\\textit{pred}$ 的后继节点更新为 $\\textit{pred}$ 的后继节点的后继节点，来达到删除节点的效果。同时也要更新 $\\textit{size}$。如下图所示。\n![img](https://assets.leetcode-cn.com/solution-static/707/1_5.png)\n\n**代码**\n\n```Python [sol1-Python3]\nclass ListNode:\n\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.size = 0\n        self.head = ListNode(0)\n\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n        cur = self.head\n        for _ in range(index + 1):\n            cur = cur.next\n        return cur.val\n\n\n    def addAtHead(self, val: int) -> None:\n        self.addAtIndex(0, val)\n\n\n    def addAtTail(self, val: int) -> None:\n        self.addAtIndex(self.size, val)\n\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index > self.size:\n            return\n        index = max(0, index)\n        self.size += 1\n        pred = self.head\n        for _ in range(index):\n            pred = pred.next\n        to_add = ListNode(val)\n        to_add.next = pred.next\n        pred.next = to_add\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n        self.size -= 1\n        pred = self.head\n        for _ in range(index):\n            pred = pred.next\n        pred.next = pred.next.next\n```\n\n```Java [sol1-Java]\nclass MyLinkedList {\n    int size;\n    ListNode head;\n\n    public MyLinkedList() {\n        size = 0;\n        head = new ListNode(0);\n    }\n\n    public int get(int index) {\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode cur = head;\n        for (int i = 0; i <= index; i++) {\n            cur = cur.next;\n        }\n        return cur.val;\n    }\n\n    public void addAtHead(int val) {\n        addAtIndex(0, val);\n    }\n\n    public void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n\n    public void addAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        index = Math.max(0, index);\n        size++;\n        ListNode pred = head;\n        for (int i = 0; i < index; i++) {\n            pred = pred.next;\n        }\n        ListNode toAdd = new ListNode(val);\n        toAdd.next = pred.next;\n        pred.next = toAdd;\n    }\n\n    public void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        size--;\n        ListNode pred = head;\n        for (int i = 0; i < index; i++) {\n            pred = pred.next;\n        }\n        pred.next = pred.next.next;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int val) {\n        this.val = val;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class MyLinkedList {\n    int size;\n    ListNode head;\n\n    public MyLinkedList() {\n        size = 0;\n        head = new ListNode(0);\n    }\n\n    public int Get(int index) {\n         if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode cur = head;\n        for (int i = 0; i <= index; i++) {\n            cur = cur.next;\n        }\n        return cur.val;\n    }\n\n    public void AddAtHead(int val) {\n        AddAtIndex(0, val);\n    }\n\n    public void AddAtTail(int val) {\n        AddAtIndex(size, val);\n    }\n\n    public void AddAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        index = Math.Max(0, index);\n        size++;\n        ListNode pred = head;\n        for (int i = 0; i < index; i++) {\n            pred = pred.next;\n        }\n        ListNode toAdd = new ListNode(val);\n        toAdd.next = pred.next;\n        pred.next = toAdd;\n    }\n\n    public void DeleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        size--;\n        ListNode pred = head;\n        for (int i = 0; i < index; i++) {\n            pred = pred.next;\n        }\n        pred.next = pred.next.next;\n    }\n}\n\nclass ListNode {\n    public int val;\n    public ListNode next;\n\n    public ListNode(int val) {\n        this.val = val;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass MyLinkedList {\npublic:\n    MyLinkedList() {\n        this->size = 0;\n        this->head = new ListNode(0);\n    }\n    \n    int get(int index) {\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode *cur = head;\n        for (int i = 0; i <= index; i++) {\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n    \n    void addAtHead(int val) {\n        addAtIndex(0, val);\n    }\n    \n    void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n    \n    void addAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        index = max(0, index);\n        size++;\n        ListNode *pred = head;\n        for (int i = 0; i < index; i++) {\n            pred = pred->next;\n        }\n        ListNode *toAdd = new ListNode(val);\n        toAdd->next = pred->next;\n        pred->next = toAdd;\n    }\n    \n    void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        size--;\n        ListNode *pred = head;\n        for (int i = 0; i < index; i++) {\n            pred = pred->next;\n        }\n        ListNode *p = pred->next;\n        pred->next = pred->next->next;\n        delete p;\n    }\nprivate:\n    int size;\n    ListNode *head;\n};\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\ntypedef struct {\n    struct ListNode *head;\n    int size;\n} MyLinkedList;\n\nstruct ListNode *ListNodeCreat(int val) {\n    struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode));\n    node->val = val;\n    node->next = NULL;\n    return node;\n}\n\nMyLinkedList* myLinkedListCreate() {\n    MyLinkedList * obj = (MyLinkedList *)malloc(sizeof(MyLinkedList));\n    obj->head = ListNodeCreat(0);\n    obj->size = 0;\n    return obj;\n}\n\nint myLinkedListGet(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) {\n        return -1;\n    }\n    struct ListNode *cur = obj->head;\n    for (int i = 0; i <= index; i++) {\n        cur = cur->next;\n    }\n    return cur->val;\n}\n\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n    if (index > obj->size) {\n        return;\n    }\n    index = MAX(0, index);\n    obj->size++;\n    struct ListNode *pred = obj->head;\n    for (int i = 0; i < index; i++) {\n        pred = pred->next;\n    }\n    struct ListNode *toAdd = ListNodeCreat(val);\n    toAdd->next = pred->next;\n    pred->next = toAdd;\n}\n\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n    myLinkedListAddAtIndex(obj, 0, val);\n}\n\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n    myLinkedListAddAtIndex(obj, obj->size, val);\n}\n\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) {\n        return;\n    }\n    obj->size--;\n    struct ListNode *pred = obj->head;\n    for (int i = 0; i < index; i++) {\n        pred = pred->next;\n    }\n    struct ListNode *p = pred->next;\n    pred->next = pred->next->next;\n    free(p);\n}\n\nvoid myLinkedListFree(MyLinkedList* obj) {\n    struct ListNode *cur = NULL, *tmp = NULL;\n    for (cur = obj->head; cur;) {\n        tmp = cur;\n        cur = cur->next;\n        free(tmp);\n    }\n    free(obj);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar MyLinkedList = function() {\n    this.size = 0;\n    this.head = new ListNode(0);\n};\n\nMyLinkedList.prototype.get = function(index) {\n    if (index < 0 || index >= this.size) {\n        return -1;\n    }\n    let cur = this.head;\n    for (let i = 0; i <= index; i++) {\n        cur = cur.next;\n    }\n    return cur.val;\n};\n\nMyLinkedList.prototype.addAtHead = function(val) {\n    this.addAtIndex(0, val);\n};\n\nMyLinkedList.prototype.addAtTail = function(val) {\n    this.addAtIndex(this.size, val);\n};\n\nMyLinkedList.prototype.addAtIndex = function(index, val) {\n    if (index > this.size) {\n        return;\n    }\n    index = Math.max(0, index);\n    this.size++;\n    let pred = this.head;\n    for (let i = 0; i < index; i++) {\n        pred = pred.next;\n    }\n    let toAdd = new ListNode(val);\n    toAdd.next = pred.next;\n    pred.next = toAdd;\n};\n\nMyLinkedList.prototype.deleteAtIndex = function(index) {\n    if (index < 0 || index >= this.size) {\n        return;\n    }\n    this.size--;\n    let pred = this.head;\n    for (let i = 0; i < index; i++) {\n        pred = pred.next;\n    }\n    pred.next = pred.next.next;\n};\n\nfunction ListNode(val, next) {\n    this.val = (val===undefined ? 0 : val)\n    this.next = (next===undefined ? null : next)\n}\n```\n\n```go [sol1-Golang]\ntype MyLinkedList struct {\n    head *ListNode\n    size int\n}\n\nfunc Constructor() MyLinkedList {\n    return MyLinkedList{&ListNode{}, 0}\n}\n\nfunc (l *MyLinkedList) Get(index int) int {\n    if index < 0 || index >= l.size {\n        return -1\n    }\n    cur := l.head\n    for i := 0; i <= index; i++ {\n        cur = cur.Next\n    }\n    return cur.Val\n}\n\nfunc (l *MyLinkedList) AddAtHead(val int) {\n    l.AddAtIndex(0, val)\n}\n\nfunc (l *MyLinkedList) AddAtTail(val int) {\n    l.AddAtIndex(l.size, val)\n}\n\nfunc (l *MyLinkedList) AddAtIndex(index, val int) {\n    if index > l.size {\n        return\n    }\n    index = max(index, 0)\n    l.size++\n    pred := l.head\n    for i := 0; i < index; i++ {\n        pred = pred.Next\n    }\n    toAdd := &ListNode{val, pred.Next}\n    pred.Next = toAdd\n}\n\nfunc (l *MyLinkedList) DeleteAtIndex(index int) {\n    if index < 0 || index >= l.size {\n        return\n    }\n    l.size--\n    pred := l.head\n    for i := 0; i < index; i++ {\n        pred = pred.Next\n    }\n    pred.Next = pred.Next.Next\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化消耗 $O(1)$，$\\textit{get}$ 消耗 $O(\\textit{index})$，$\\textit{addAtHead}$ 消耗 $O(1)$，$\\textit{addAtTail}$ 消耗 $O(n)$，其中 $n$ 为链表当前长度，即 $\\textit{addAtHead}$，$\\textit{addAtTail}$ 和 $\\textit{addAtIndex}$ 已调用次数之和，$\\textit{addAtIndex}$ 消耗 $O(\\textit{index})$。\n\n- 空间复杂度：所有函数的单次调用空间复杂度均为 $O(1)$，总体空间复杂度为 $O(n)$，其中 $n$ 为 $\\textit{addAtHead}$，$\\textit{addAtTail}$ 和 $\\textit{addAtIndex}$ 调用次数之和。\n\n#### 方法二：双向链表\n\n**思路**\n\n实现双向链表，即每个节点要存储本身的值，后继节点和前驱节点。除此之外，需要一个哨兵节点作为头节点 $\\textit{head}$ 和一个哨兵节点作为尾节点 $\\textit{tail}$。仍需要一个 $\\textit{size}$ 参数保存有效节点数。如下图所示。\n![img](https://assets.leetcode-cn.com/solution-static/707/1_6.png)\n\n初始化时，只需创建头节点 $\\textit{head}$ 和 $\\textit{size}$ 即可。\n\n实现 $\\textit{get}(\\textit{index})$ 时，先判断有效性，然后再比较从 $\\textit{head}$ 还是 $\\textit{tail}$ 来遍历会比较快找到目标，然后进行遍历。如下图所示。\n![img](https://assets.leetcode-cn.com/solution-static/707/1_7.png)\n\n实现 $\\textit{addAtIndex}(\\textit{index, val})$ 时，如果 $\\textit{index}$ 是有效值，则需要找到原来下标为 $\\textit{index}$ 的节点 $\\textit{succ}$ 和前驱节点 $\\textit{pred}$，并创建新节点 $\\textit{to\\_add}$，再通过各自 $\\textit{prev}$ 和 $\\textit{next}$ 变量的更新来增加 $\\textit{to\\_add}$。最后需要更新 $\\textit{size}$。如以下两张图所示。\n![img](https://assets.leetcode-cn.com/solution-static/707/1_8.png)\n\n实现 $\\textit{addAtHead}(\\textit{val})$ 和 $\\textit{addAtTail}(\\textit{val})$ 时，可以借助 $\\textit{addAtIndex}(\\textit{index, val})$ 来实现。\n\n实现 $\\textit{deleteAtIndex}(\\textit{index})$，先判断参数有效性。然后找到下标为 $\\textit{index}$ 的节点的前驱节点 $\\textit{pred}$ 和后继节点 $\\textit{succ}$，再通过各自 $\\textit{prev}$ 和 $\\textit{next}$ 变量的更新来删除节点，来达到删除节点的效果。同时也要更新 $\\textit{size}$。如下图所示。\n![img](https://assets.leetcode-cn.com/solution-static/707/1_9.png)\n\n**代码**\n\n```Python [sol2-Python3]\nclass ListNode:\n\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        self.prev = None\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.size = 0\n        self.head, self.tail = ListNode(0), ListNode(0) \n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n        if index + 1 < self.size - index:\n            curr = self.head\n            for _ in range(index + 1):\n                curr = curr.next\n        else:\n            curr = self.tail\n            for _ in range(self.size - index):\n                curr = curr.prev\n        return curr.val\n\n\n    def addAtHead(self, val: int) -> None:\n        self.addAtIndex(0, val)\n\n\n    def addAtTail(self, val: int) -> None:\n        self.addAtIndex(self.size, val)\n\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index > self.size:\n            return\n        index = max(0, index)\n        if index < self.size - index:\n            pred = self.head\n            for _ in range(index):\n                pred = pred.next\n            succ = pred.next\n        else:\n            succ = self.tail\n            for _ in range(self.size - index):\n                succ = succ.prev\n            pred = succ.prev\n        self.size += 1\n        to_add = ListNode(val)\n        to_add.prev = pred\n        to_add.next = succ\n        pred.next = to_add\n        succ.prev = to_add\n\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n        if index < self.size - index:\n            pred = self.head\n            for _ in range(index):\n                pred = pred.next\n            succ = pred.next.next\n        else:\n            succ = self.tail\n            for _ in range(self.size - index - 1):\n                succ = succ.prev\n            pred = succ.prev.prev\n        self.size -= 1\n        pred.next = succ\n        succ.prev = pred\n```\n\n```Java [sol2-Java]\nclass MyLinkedList {\n    int size;\n    ListNode head;\n    ListNode tail;\n\n    public MyLinkedList() {\n        size = 0;\n        head = new ListNode(0);\n        tail = new ListNode(0);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int index) {\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode curr;\n        if (index + 1 < size - index) {\n            curr = head;\n            for (int i = 0; i <= index; i++) {\n                curr = curr.next;\n            }\n        } else {\n            curr = tail;\n            for (int i = 0; i < size - index; i++) {\n                curr = curr.prev;\n            }\n        }\n        return curr.val;\n    }\n\n    public void addAtHead(int val) {\n        addAtIndex(0, val);\n    }\n\n    public void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n\n    public void addAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        index = Math.max(0, index);\n        ListNode pred, succ;\n        if (index < size - index) {\n            pred = head;\n            for (int i = 0; i < index; i++) {\n                pred = pred.next;\n            }\n            succ = pred.next;\n        } else {\n            succ = tail;\n            for (int i = 0; i < size - index; i++) {\n                succ = succ.prev;\n            }\n            pred = succ.prev;\n        }\n        size++;\n        ListNode toAdd = new ListNode(val);\n        toAdd.prev = pred;\n        toAdd.next = succ;\n        pred.next = toAdd;\n        succ.prev = toAdd;\n    }\n\n    public void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        ListNode pred, succ;\n        if (index < size - index) {\n            pred = head;\n            for (int i = 0; i < index; i++) {\n                pred = pred.next;\n            }\n            succ = pred.next.next;\n        } else {\n            succ = tail;\n            for (int i = 0; i < size - index - 1; i++) {\n                succ = succ.prev;\n            }\n            pred = succ.prev.prev;\n        }\n        size--;\n        pred.next = succ;\n        succ.prev = pred;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode prev;\n\n    public ListNode(int val) {\n        this.val = val;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class MyLinkedList {\n    int size;\n    ListNode head;\n    ListNode tail;\n\n    public MyLinkedList() {\n        size = 0;\n        head = new ListNode(0);\n        tail = new ListNode(0);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int Get(int index) {\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode curr;\n        if (index + 1 < size - index) {\n            curr = head;\n            for (int i = 0; i <= index; i++) {\n                curr = curr.next;\n            }\n        } else {\n            curr = tail;\n            for (int i = 0; i < size - index; i++) {\n                curr = curr.prev;\n            }\n        }\n        return curr.val;\n    }\n\n    public void AddAtHead(int val) {\n        AddAtIndex(0, val);\n    }\n\n    public void AddAtTail(int val) {\n        AddAtIndex(size, val);\n    }\n\n    public void AddAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        index = Math.Max(0, index);\n        ListNode pred, succ;\n        if (index < size - index) {\n            pred = head;\n            for (int i = 0; i < index; i++) {\n                pred = pred.next;\n            }\n            succ = pred.next;\n        } else {\n            succ = tail;\n            for (int i = 0; i < size - index; i++) {\n                succ = succ.prev;\n            }\n            pred = succ.prev;\n        }\n        size++;\n        ListNode toAdd = new ListNode(val);\n        toAdd.prev = pred;\n        toAdd.next = succ;\n        pred.next = toAdd;\n        succ.prev = toAdd;\n    }\n\n    public void DeleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        ListNode pred, succ;\n        if (index < size - index) {\n            pred = head;\n            for (int i = 0; i < index; i++) {\n                pred = pred.next;\n            }\n            succ = pred.next.next;\n        } else {\n            succ = tail;\n            for (int i = 0; i < size - index - 1; i++) {\n                succ = succ.prev;\n            }\n            pred = succ.prev.prev;\n        }\n        size--;\n        pred.next = succ;\n        succ.prev = pred;\n    }\n}\n\nclass ListNode {\n    public int val;\n    public ListNode next;\n    public ListNode prev;\n\n    public ListNode(int val) {\n        this.val = val;\n    }\n}\n```\n\n```C++ [sol2-C++]\nstruct DLinkListNode {\n    int val;\n    DLinkListNode *prev, *next;\n    DLinkListNode(int _val) : val(_val), prev(nullptr), next(nullptr) {}\n};\n\nclass MyLinkedList {\npublic:\n    MyLinkedList() {\n        this->size = 0;\n        this->head = new DLinkListNode(0);\n        this->tail = new DLinkListNode(0);\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int index) {\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        DLinkListNode *curr;\n        if (index + 1 < size - index) {\n            curr = head;\n            for (int i = 0; i <= index; i++) {\n                curr = curr->next;\n            }\n        } else {\n            curr = tail;\n            for (int i = 0; i < size - index; i++) {\n                curr = curr->prev;\n            }\n        }\n        return curr->val;\n    }\n    \n    void addAtHead(int val) {\n        addAtIndex(0, val);\n    }\n    \n    void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n    \n    void addAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        index = max(0, index);\n        DLinkListNode *pred, *succ;\n        if (index < size - index) {\n            pred = head;\n            for (int i = 0; i < index; i++) {\n                pred = pred->next;\n            }\n            succ = pred->next;\n        } else {\n            succ = tail;\n            for (int i = 0; i < size - index; i++) {\n                succ = succ->prev;\n            }\n            pred = succ->prev;\n        }\n        size++;\n        DLinkListNode *toAdd = new DLinkListNode(val);\n        toAdd->prev = pred;\n        toAdd->next = succ;\n        pred->next = toAdd;\n        succ->prev = toAdd;\n    }\n    \n    void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        DLinkListNode *pred, *succ;\n        if (index < size - index) {\n            pred = head;\n            for (int i = 0; i < index; i++) {\n                pred = pred->next;\n            }\n            succ = pred->next->next;\n        } else {\n            succ = tail;\n            for (int i = 0; i < size - index - 1; i++) {\n                succ = succ->prev;\n            }\n            pred = succ->prev->prev;\n        }\n        size--;\n        DLinkListNode *p = pred->next;\n        pred->next = succ;\n        succ->prev = pred;\n        delete p;\n    }\nprivate:\n    int size;\n    DLinkListNode *head;\n    DLinkListNode *tail;\n};\n```\n\n```C [sol2-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\ntypedef struct DLinkListNode {\n    int val;\n    struct DLinkListNode *prev, *next;\n} DLinkListNode;\n\ntypedef struct {\n    struct DLinkListNode *head, *tail;\n    int size;\n} MyLinkedList;\n\nDLinkListNode *dLinkListNodeCreat(int val) {\n    DLinkListNode * node = (DLinkListNode *)malloc(sizeof(struct DLinkListNode));\n    node->val = val;\n    node->prev = NULL;\n    node->next = NULL;\n    return node;\n}\n\nMyLinkedList* myLinkedListCreate() {\n    MyLinkedList * obj = (MyLinkedList *)malloc(sizeof(MyLinkedList));\n    obj->size = 0;\n    obj->head = dLinkListNodeCreat(0);\n    obj->tail = dLinkListNodeCreat(0);\n    obj->head->next = obj->tail;\n    obj->tail->prev = obj->head; \n    return obj;\n}\n\nint myLinkedListGet(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) {\n        return -1;\n    }\n    DLinkListNode *curr;\n    if (index + 1 < obj->size - index) {\n        curr = obj->head;\n        for (int i = 0; i <= index; i++) {\n            curr = curr->next;\n        }\n    } else {\n        curr = obj->tail;\n        for (int i = 0; i < obj->size - index; i++) {\n            curr = curr->prev;\n        }\n    }\n    return curr->val;\n}\n\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n    if (index > obj->size) {\n        return;\n    }\n    index = MAX(0, index);\n    DLinkListNode *pred, *succ;\n    if (index < obj->size - index) {\n        pred = obj->head;\n        for (int i = 0; i < index; i++) {\n            pred = pred->next;\n        }\n        succ = pred->next;\n    } else {\n        succ = obj->tail;\n        for (int i = 0; i < obj->size - index; i++) {\n            succ = succ->prev;\n        }\n        pred = succ->prev;\n    }\n    obj->size++;\n    DLinkListNode *toAdd = dLinkListNodeCreat(val);\n    toAdd->prev = pred;\n    toAdd->next = succ;\n    pred->next = toAdd;\n    succ->prev = toAdd;\n}\n\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n    myLinkedListAddAtIndex(obj, 0, val);\n}\n\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n    myLinkedListAddAtIndex(obj, obj->size, val);\n}\n\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) {\n        return;\n    }\n    DLinkListNode *pred, *succ;\n    if (index < obj->size - index) {\n        pred = obj->head;\n        for (int i = 0; i < index; i++) {\n            pred = pred->next;\n        }\n        succ = pred->next->next;\n    } else {\n        succ = obj->tail;\n        for (int i = 0; i < obj->size - index - 1; i++) {\n            succ = succ->prev;\n        }\n        pred = succ->prev->prev;\n    }\n    obj->size--;\n    DLinkListNode *p = pred->next;\n    pred->next = succ;\n    succ->prev = pred;\n    free(p);\n}\n\nvoid myLinkedListFree(MyLinkedList* obj) {\n    struct DLinkListNode *cur = NULL, *tmp = NULL;\n    for (cur = obj->head; cur;) {\n        tmp = cur;\n        cur = cur->next;\n        free(tmp);\n    }\n    free(obj);\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar MyLinkedList = function() {\n    this.size = 0;\n    this.head = new ListNode(0);\n    this.tail = new ListNode(0);\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n};\n\nMyLinkedList.prototype.get = function(index) {\n    if (index < 0 || index >= this.size) {\n        return -1;\n    }\n    let curr;\n    if (index + 1 < this.size - index) {\n        curr = this.head;\n        for (let i = 0; i <= index; i++) {\n            curr = curr.next;\n        }\n    } else {\n        curr = this.tail;\n        for (let i = 0; i < this.size - index; i++) {\n            curr = curr.prev;\n        }\n    }\n    return curr.val;\n};\n\nMyLinkedList.prototype.addAtHead = function(val) {\n    this.addAtIndex(0, val);\n};\n\nMyLinkedList.prototype.addAtTail = function(val) {\n    this.addAtIndex(this.size, val);\n};\n\nMyLinkedList.prototype.addAtIndex = function(index, val) {\n    if (index > this.size) {\n        return;\n    }\n    index = Math.max(0, index);\n    let pred, succ;\n    if (index < this.size - index) {\n        pred = this.head;\n        for (let i = 0; i < index; i++) {\n            pred = pred.next;\n        }\n        succ = pred.next;\n    } else {\n        succ = this.tail;\n        for (let i = 0; i < this.size - index; i++) {\n            succ = succ.prev;\n        }\n        pred = succ.prev;\n    }\n    this.size++;\n    const toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n};\n\nMyLinkedList.prototype.deleteAtIndex = function(index) {\n    if (index < 0 || index >= this.size) {\n        return;\n    }\n    let pred, succ;\n    if (index < this.size - index) {\n        pred = this.head;\n        for (let i = 0; i < index; i++) {\n            pred = pred.next;\n        }\n        succ = pred.next.next;\n    } else {\n        succ = this.tail;\n        for (let i = 0; i < this.size - index - 1; i++) {\n            succ = succ.prev;\n        }\n        pred = succ.prev.prev;\n    }\n    this.size--;\n    pred.next = succ;\n    succ.prev = pred;\n};\n\nfunction ListNode(val, next, prev) {\n    this.val = (val===undefined ? 0 : val)\n    this.next = (next===undefined ? null : next)\n    this.prev = (prev===undefined ? null : next)\n}\n```\n\n```go [sol2-Golang]\ntype node struct {\n    val        int\n    next, prev *node\n}\n\ntype MyLinkedList struct {\n    head, tail *node\n    size       int\n}\n\nfunc Constructor() MyLinkedList {\n    head := &node{}\n    tail := &node{}\n    head.next = tail\n    tail.prev = head\n    return MyLinkedList{head, tail, 0}\n}\n\nfunc (l *MyLinkedList) Get(index int) int {\n    if index < 0 || index >= l.size {\n        return -1\n    }\n    var curr *node\n    if index+1 < l.size-index {\n        curr = l.head\n        for i := 0; i <= index; i++ {\n            curr = curr.next\n        }\n    } else {\n        curr = l.tail\n        for i := 0; i < l.size-index; i++ {\n            curr = curr.prev\n        }\n    }\n    return curr.val\n}\n\nfunc (l *MyLinkedList) AddAtHead(val int) {\n    l.AddAtIndex(0, val)\n}\n\nfunc (l *MyLinkedList) AddAtTail(val int) {\n    l.AddAtIndex(l.size, val)\n}\n\nfunc (l *MyLinkedList) AddAtIndex(index, val int) {\n    if index > l.size {\n        return\n    }\n    index = max(0, index)\n    var pred, succ *node\n    if index < l.size-index {\n        pred = l.head\n        for i := 0; i < index; i++ {\n            pred = pred.next\n        }\n        succ = pred.next\n    } else {\n        succ = l.tail\n        for i := 0; i < l.size-index; i++ {\n            succ = succ.prev\n        }\n        pred = succ.prev\n    }\n    l.size++\n    toAdd := &node{val, succ, pred}\n    pred.next = toAdd\n    succ.prev = toAdd\n}\n\nfunc (l *MyLinkedList) DeleteAtIndex(index int) {\n    if index < 0 || index >= l.size {\n        return\n    }\n    var pred, succ *node\n    if index < l.size-index {\n        pred = l.head\n        for i := 0; i < index; i++ {\n            pred = pred.next\n        }\n        succ = pred.next.next\n    } else {\n        succ = l.tail\n        for i := 0; i < l.size-index-1; i++ {\n            succ = succ.prev\n        }\n        pred = succ.prev.prev\n    }\n    l.size--\n    pred.next = succ\n    succ.prev = pred\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化消耗 $O(1)$，$\\textit{get}$ 消耗 $O(\\textit{index})$，$\\textit{addAtHead}$ 消耗 $O(1)$，$\\textit{addAtTail}$ 消耗 $O(1)$，$\\textit{addAtIndex}$ 消耗 $O(\\textit{index})$。\n\n- 空间复杂度：所有函数单次调用的空间复杂度均为 $O(1)$，总体空间复杂度为 $O(n)$，其中 $n$ 为 $\\textit{addAtHead}$，$\\textit{addAtTail}$ 和 $\\textit{addAtIndex}$ 调用次数之和。"
}