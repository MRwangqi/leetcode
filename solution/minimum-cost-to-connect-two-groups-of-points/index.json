{
	"titleSlug": "minimum-cost-to-connect-two-groups-of-points",
	"slug": "java-zhuang-tai-ya-suo-dp-by-aerysn",
	"url": "https://leetcode-cn.com/problems/minimum-cost-to-connect-two-groups-of-points/solution/java-zhuang-tai-ya-suo-dp-by-aerysn/",
	"content": "## 动态规划\r\n\r\n问题等价于: **在一个矩阵中选取一些值, 满足矩阵的每一行和每一列都至少有一个元素被选中, 同时选中元素的总和最小** (此矩阵就是 `cost` 矩阵).\r\n\r\n由于矩阵的列数较少, 我们可以用状压 DP 来表示每一行的选取情况, 假设矩阵有 $m$ 行 $n$ 列, 那么我们维护一个 DP 矩阵 `dp[m][1 << n]`, `dp[i][j]`表示当前选取到第 $i$ 行, 每列的选取状况为 $j$ 时总的最小开销, 其中 $j$ 的第 $k$ 位为 $1$ 即表示第 $k$ 列已经被选取过了. 那么状态转移方程为\r\n\r\n$$dp[i][j~|~k] = Math.min(dp[i][j~|~k], dp[i - 1][k] + costMatrix[i][j])$$\r\n\r\n其中 `costMatrix[i][j]` 表示第 $i$ 行选取状况为 $j$ 时该行被选取得元素总和.\r\n\r\n```java\r\nclass Solution {\r\n  public int connectTwoGroups(List<List<Integer>> cost) {\r\n    int m = cost.size(), n = cost.get(0).size();\r\n    int[][] costMatrix = new int[m][1 << n];\r\n    for (int k = 0; k < m; k++) {\r\n      for (int i = 0; i < (1 << n); i++) {\r\n        int sum = 0;\r\n        for (int j = 0; j < n; j++) {\r\n          if ((i & (1 << j)) > 0)\r\n            sum += cost.get(k).get(j);\r\n        }\r\n        costMatrix[k][i] = sum;\r\n      }\r\n    }\r\n    int[][] dp = new int[m][1 << n];\r\n    for (int i = 1; i < m; i++)\r\n      Arrays.fill(dp[i], Integer.MAX_VALUE);\r\n    dp[0] = costMatrix[0];\r\n    for (int i = 1; i < m; i++)\r\n      for (int j = 1; j < (1 << n); j++)\r\n        for (int k = 1; k < (1 << n); k++)\r\n          dp[i][j | k] = Math.min(dp[i][j | k], dp[i - 1][k] + costMatrix[i][j]);\r\n    return dp[m - 1][(1 << n) - 1];\r\n  }\r\n}\r\n```\r\n最终结果为 `dp[m - 1][(1 << n) - 1]`, 表示选取到 `m - 1` 行 (即最后一行), 并且每一列都有元素被选取到条件下得元素最小和. **每行都有元素要被选取的约束是由三重循环中 `j` 和 `k` 都由 `1` 开始满足的.**\r\n\r\n## 优化\r\n\r\n感谢 [@Freezer](/u/freezer/) 在评论区里提出用 C++ 会超时的问题, 说明上面的解法效率还没有达到最高. 实际上面解法中的三重循环可以进行优化. 考虑到当我们已知截至上一行时的各列选取情况, 其实并没有必要重复地选取上面已经选取过的列, 据此可以对三重循环做如下修改:\r\n\r\n```java\r\nfor (int i = 1; i < m; i++) {\r\n  for (int k = 1; k < (1 << n); k++) {\r\n    // 首先将第 i 行只选取一个元素的情况都考虑一遍\r\n    // 这样做的目的是保证第 i 行至少选取了一个元素\r\n    for (int j = 0; j < n; j++)\r\n      dp[i][k | (1 << j)] = Math.min(dp[i][k | (1 << j)], dp[i - 1][k] + cost.get(i).get(j));\r\n    // rest 表示截至第 i 行还没被选过的列\r\n    int rest = (1 << n) - 1 - k;\r\n    // 只遍历没选过的列的所有组合\r\n    for (int j = rest; j  >= 1; j = rest & (j - 1)) {\r\n      dp[i][j | k] = Math.min(dp[i][j | k], dp[i - 1][k] + costMatrix[i][j]);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n另外注意 `dp` 中的每一行只依赖上一行的值, 可以将 `dp` 变为一维数组以优化空间复杂度 (不写了)."
}