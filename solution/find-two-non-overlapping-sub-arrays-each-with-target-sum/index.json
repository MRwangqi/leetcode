{
	"titleSlug": "find-two-non-overlapping-sub-arrays-each-with-target-sum",
	"slug": "java-1477-zhao-liang-ge-he-wei-mu-biao-z-571j",
	"url": "https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/solution/java-1477-zhao-liang-ge-he-wei-mu-biao-z-571j/",
	"content": "### 解题思路\n\n1. 滑动窗口找**可能的范围**，分别记录以l开头的长度，以r结尾的长度，形成两组记录1。\n2. 在两组记录1的基础上，左一次，右一次，形成以当前位置为结尾的满足条件的最小长度，和不包含当前位置后续满足条件的最小值，形成两组记录2。\n3. 在两组记录2的基础上，对每一个位置收集答案。\n\n\n--- \n类似左一次右一次的\n[中等] 845. 数组中的最长山脉【动态规划】[[动态规划](https://leetcode.cn/problems/longest-mountain-in-array/solution/java-845-shu-zu-zhong-de-zui-chang-shan-muwnr/)] [[845. 数组中的最长山脉](https://leetcode.cn/problems/longest-mountain-in-array/)]\n\n[简单] 1422. 分割字符串的最大得分【动态规划】[[动态规划](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/solution/by-wa-pian-d-b4nj/)] [[1422. 分割字符串的最大得分](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/)]\n\n\n\n### 代码\n\n```java\nclass Solution {\n\tpublic int minSumOfLengths(int[] arr, int target) {\n\t\tint sum = 0, l = 0, r = -1;\n\t\tint len = arr.length;\n\t\tint[] start = new int[len];\n\t\tint[] end = new int[len];\n\t\twhile (r < len && l < len) {\n\t\t\twhile (r < len - 1 && sum < target) {\n\t\t\t\tsum += arr[++r];\n\t\t\t}\n\t\t\tif (sum == target) {\n\t\t\t\tint size = r - l + 1;\n\t\t\t\tstart[l] = size;\n\t\t\t\tend[r] = size;\n\t\t\t}\n\t\t\tsum -= arr[l++];\n\t\t}\n\t\tint starts[] = new int[len];\n\t\tint ends[] = new int[len];\n\t\tint mine = Integer.MAX_VALUE;\n\t\tint mins = Integer.MAX_VALUE;\n\t\tfor (int i = 0, j = len - 1; i < len; i++, j--) {\n\t\t\tif (mins != Integer.MAX_VALUE) {\n\t\t\t\tstarts[j] = mins;\n\t\t\t}\n\t\t\tint e = end[i];\n\t\t\tint s = start[j];\n\t\t\tif (e != 0) {\n\t\t\t\tmine = Math.min(mine, e);\n\t\t\t}\n\t\t\tif (s != 0) {\n\t\t\t\tmins = Math.min(mins, s);\n\t\t\t}\n\t\t\tif (mine != Integer.MAX_VALUE) {\n\t\t\t\tends[i] = mine;\n\t\t\t}\n\t\t}\n\t\tint ans = Integer.MAX_VALUE, cur = 0;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (ends[i] != 0 && starts[i] != 0 && (cur = ends[i] + starts[i]) < ans) {\n\t\t\t\tans = cur;\n\t\t\t}\n\t\t}\n\t\treturn ans == Integer.MAX_VALUE ? -1 : ans;\n\t}\n}\n```"
}