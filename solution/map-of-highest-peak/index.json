{
	"titleSlug": "map-of-highest-peak",
	"slug": "di-tu-zhong-de-zui-gao-dian-by-leetcode-jdkzr",
	"url": "https://leetcode-cn.com/problems/map-of-highest-peak/solution/di-tu-zhong-de-zui-gao-dian-by-leetcode-jdkzr/",
	"content": "#### 方法一：多源广度优先搜索\n\n题目要求让矩阵中的最高高度最大，我们可以通过最大化每个格子的高度来做到这一点。由于任意相邻的格子高度差至多为 $1$，这意味着对于每个格子，其高度至多比其相邻格子中的最小高度多 $1$。\n\n题目要求水域的高度必须为 $0$，因此水域的高度是已经确定的值，我们可以从水域出发，推导出其余格子的高度：\n\n- 首先，计算与水域相邻的格子的高度。对于这些格子来说，其相邻格子中的最小高度即为水域的高度 $0$，因此这些格子的高度为 $1$。\n- 然后，计算与高度为 $1$ 的格子相邻的、尚未被计算过的格子的高度。对于这些格子来说，其相邻格子中的最小高度为 $1$，因此这些格子的高度为 $2$。\n- 以此类推，计算出所有格子的高度。\n\n上述过程中，对于每一轮，我们考虑的是与上一轮格子相邻的、未被计算过的格子 $x$，其高度必然比上一轮的格子高度多 $1$。反证之：如果格子 $x$ 的高度小于或等于上一轮的格子高度，那么 $x$ 必然会在更早的轮数被计算出来，矛盾。因此 $x$ 的高度必然比上一轮的格子高度高，同时由于题目要求任意相邻的格子高度差至多为 $1$，因此 $x$ 的高度必然比上一轮格子的高度多 $1$。\n\n可以发现，上述过程就是从水域出发，执行广度优先搜索的过程。因此，记录下所有水域的位置，然后执行广度优先搜索，计算出所有陆地格子的高度，即为答案。\n\n```Python [sol1-Python3]\nclass Solution:\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n        m, n = len(isWater), len(isWater[0])\n        ans = [[water - 1 for water in row] for row in isWater]\n        q = deque((i, j) for i, row in enumerate(isWater) for j, water in enumerate(row) if water)  # 将所有水域入队\n        while q:\n            i, j = q.popleft()\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if 0 <= x < m and 0 <= y < n and ans[x][y] == -1:\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n        return ans\n```\n\n```C++ [sol1-C++]\nint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nclass Solution {\npublic:\n    vector<vector<int>> highestPeak(vector<vector<int>> &isWater) {\n        int m = isWater.size(), n = isWater[0].size();\n        vector<vector<int>> ans(m, vector<int>(n, -1)); // -1 表示该格子尚未被访问过\n        queue<pair<int, int>> q;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (isWater[i][j]) {\n                    ans[i][j] = 0;\n                    q.emplace(i, j); // 将所有水域入队\n                }\n            }\n        }\n        while (!q.empty()) {\n            auto &p = q.front();\n            for (auto &dir : dirs) {\n                int x = p.first + dir[0], y = p.second + dir[1];\n                if (0 <= x && x < m && 0 <= y && y < n && ans[x][y] == -1) {\n                    ans[x][y] = ans[p.first][p.second] + 1;\n                    q.emplace(x, y);\n                }\n            }\n            q.pop();\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public int[][] highestPeak(int[][] isWater) {\n        int m = isWater.length, n = isWater[0].length;\n        int[][] ans = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            Arrays.fill(ans[i], -1); // -1 表示该格子尚未被访问过\n        }\n        Queue<int[]> queue = new ArrayDeque<int[]>();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (isWater[i][j] == 1) {\n                    ans[i][j] = 0;\n                    queue.offer(new int[]{i, j}); // 将所有水域入队\n                }\n            }\n        }\n        while (!queue.isEmpty()) {\n            int[] p = queue.poll();\n            for (int[] dir : dirs) {\n                int x = p[0] + dir[0], y = p[1] + dir[1];\n                if (0 <= x && x < m && 0 <= y && y < n && ans[x][y] == -1) {\n                    ans[x][y] = ans[p[0]][p[1]] + 1;\n                    queue.offer(new int[]{x, y});\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    int[][] dirs = {new int[]{-1, 0}, new int[]{1, 0}, new int[]{0, -1}, new int[]{0, 1}};\n\n    public int[][] HighestPeak(int[][] isWater) {\n        int m = isWater.Length, n = isWater[0].Length;\n        int[][] ans = new int[m][];\n        for (int i = 0; i < m; ++i) {\n            ans[i] = new int[n];\n            Array.Fill(ans[i], -1); // -1 表示该格子尚未被访问过\n        }\n        Queue<Tuple<int, int>> queue = new Queue<Tuple<int, int>>();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (isWater[i][j] == 1) {\n                    ans[i][j] = 0;\n                    queue.Enqueue(new Tuple<int, int>(i, j)); // 将所有水域入队\n                }\n            }\n        }\n        while (queue.Count > 0) {\n            Tuple<int, int> p = queue.Dequeue();\n            foreach (int[] dir in dirs) {\n                int x = p.Item1 + dir[0], y = p.Item2 + dir[1];\n                if (0 <= x && x < m && 0 <= y && y < n && ans[x][y] == -1) {\n                    ans[x][y] = ans[p.Item1][p.Item2] + 1;\n                    queue.Enqueue(new Tuple<int, int>(x, y));\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol1-Golang]\ntype pair struct{ x, y int }\nvar dirs = []pair{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\nfunc highestPeak(isWater [][]int) [][]int {\n    m, n := len(isWater), len(isWater[0])\n    ans := make([][]int, m)\n    for i := range ans {\n        ans[i] = make([]int, n)\n        for j := range ans[i] {\n            ans[i][j] = -1 // -1 表示该格子尚未被访问过\n        }\n    }\n    q := []pair{}\n    for i, row := range isWater {\n        for j, water := range row {\n            if water == 1 { // 将所有水域入队\n                ans[i][j] = 0\n                q = append(q, pair{i, j})\n            }\n        }\n    }\n    for len(q) > 0 {\n        p := q[0]\n        q = q[1:]\n        for _, d := range dirs {\n            if x, y := p.x+d.x, p.y+d.y; 0 <= x && x < m && 0 <= y && y < n && ans[x][y] == -1 {\n                ans[x][y] = ans[p.x][p.y] + 1\n                q = append(q, pair{x, y})\n            }\n        }\n    }\n    return ans\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int x;\n    int y;\n} Pair; \n\nint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nint** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes){\n    int m = isWaterSize, n = isWaterColSize[0];\n    int ** ans = (int **)malloc(sizeof(int *) * m);\n    for (int i = 0; i < m; ++i) {\n        ans[i] = (int *)malloc(sizeof(int) * n);\n        memset(ans[i], -1, sizeof(int) * n);\n    }\n    Pair * queue = (Pair *)malloc(sizeof(Pair) * m * n);\n    int head = 0;\n    int tail = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (isWater[i][j]) {\n                ans[i][j] = 0;\n                queue[tail].x = i; // 将所有水域入队\n                queue[tail].y = j;\n                ++tail; \n            }\n        }\n    }\n    while (head != tail) {\n        int px = queue[head].x, py = queue[head].y;\n        for (int i = 0; i < 4; ++i) {\n            int x = px + dirs[i][0], y = py + dirs[i][1];\n            if (0 <= x && x < m && 0 <= y && y < n && ans[x][y] == -1) {\n                ans[x][y] = ans[px][py] + 1;\n                queue[tail].x = x;\n                queue[tail].y = y;\n                ++tail;\n            }\n        }\n        ++head;\n    }\n    free(queue);\n    *returnSize = m;\n    *returnColumnSizes = (int *)malloc(sizeof(int) * m);\n    memcpy(*returnColumnSizes, isWaterColSize, sizeof(int) * m);\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn)$。$m$ 和 $n$ 的含义同题目中的定义。\n\n- 空间复杂度：$O(mn)$。最坏情况下整个矩阵都是水域，我们需要将所有水域入队。"
}