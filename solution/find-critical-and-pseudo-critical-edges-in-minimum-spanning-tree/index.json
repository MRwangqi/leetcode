{
	"titleSlug": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
	"slug": "zhao-dao-zui-xiao-sheng-cheng-shu-li-de-gu57q",
	"url": "https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solution/zhao-dao-zui-xiao-sheng-cheng-shu-li-de-gu57q/",
	"content": "#### 前言\n\n要想解决本题，需要用到「[最小生成树](https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)」以及对应求解最小生成树的「[$\\texttt{Kruskal}$ 算法](https://baike.baidu.com/item/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95)」。\n\n对上述算法和数据结构的讲解不是本篇题解的重点，因此这里希望读者在对掌握了这些知识点之后，再来尝试解决本题。\n\n本篇题解中会给出两种算法，并且每种算法都默认读者已经掌握了对应的知识点：\n\n- 方法一只需要枚举每一条边，并用略微修改的 $\\texttt{Kruskal}$ 算法判断其是否是关键边或伪关键边；\n\n- 方法二利用了 $\\texttt{Kruskal}$ 算法的连通性性质，以及无向图找桥边的 $\\texttt{Tarjan}$ 算法，即使在竞赛中也不算容易，仅供读者挑战自我。\n\n#### 方法一：枚举 + 最小生成树判定\n\n**思路与算法**\n\n我们首先需要理解题目描述中对于「关键边」和「伪关键边」的定义：\n\n- 关键边：如果最小生成树中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。也就是说，如果设原图最小生成树的权值为 $\\textit{value}$，那么去掉这条边后：\n\n    - 要么整个图不连通，不存在最小生成树；\n\n    - 要么整个图联通，对应的最小生成树的权值为 $v$，其严格大于 $\\textit{value}$。\n\n- 伪关键边：可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。也就是说，我们可以在计算最小生成树的过程中，**最先考虑**这条边，即最先将这条边的两个端点在并查集中合并。设最终得到的最小生成树权值为 $v$，如果 $v = \\textit{value}$，那么这条边就是伪关键边。\n\n需要注意的是，关键边也满足伪关键边对应的性质。因此，我们首先对原图执行 $\\texttt{Kruskal}$ 算法，得到最小生成树的权值 $\\textit{value}$，随后我们枚举每一条边，首先根据上面的方法判断其是否是关键边，如果不是关键边，再判断其是否是伪关键边。\n\n**代码**\n\n```C++ [sol1-C++]\n// 并查集模板\nclass UnionFind {\npublic:\n    vector<int> parent;\n    vector<int> size;\n    int n;\n    // 当前连通分量数目\n    int setCount;\n    \npublic:\n    UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n    \n    int findset(int x) {\n        return parent[x] == x ? x : parent[x] = findset(parent[x]);\n    }\n    \n    bool unite(int x, int y) {\n        x = findset(x);\n        y = findset(y);\n        if (x == y) {\n            return false;\n        }\n        if (size[x] < size[y]) {\n            swap(x, y);\n        }\n        parent[y] = x;\n        size[x] += size[y];\n        --setCount;\n        return true;\n    }\n    \n    bool connected(int x, int y) {\n        x = findset(x);\n        y = findset(y);\n        return x == y;\n    }\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\n        int m = edges.size();\n        for (int i = 0; i < m; ++i) {\n            edges[i].push_back(i);\n        }\n        sort(edges.begin(), edges.end(), [](const auto& u, const auto& v) {\n            return u[2] < v[2];\n        });\n\n        // 计算 value\n        UnionFind uf_std(n);\n        int value = 0;\n        for (int i = 0; i < m; ++i) {\n            if (uf_std.unite(edges[i][0], edges[i][1])) {\n                value += edges[i][2];\n            }\n        }\n\n        vector<vector<int>> ans(2);\n        \n        for (int i = 0; i < m; ++i) {\n            // 判断是否是关键边\n            UnionFind uf(n);\n            int v = 0;\n            for (int j = 0; j < m; ++j) {\n                if (i != j && uf.unite(edges[j][0], edges[j][1])) {\n                    v += edges[j][2];\n                }\n            }\n            if (uf.setCount != 1 || (uf.setCount == 1 && v > value)) {\n                ans[0].push_back(edges[i][3]);\n                continue;\n            }\n\n            // 判断是否是伪关键边\n            uf = UnionFind(n);\n            uf.unite(edges[i][0], edges[i][1]);\n            v = edges[i][2];\n            for (int j = 0; j < m; ++j) {\n                if (i != j && uf.unite(edges[j][0], edges[j][1])) {\n                    v += edges[j][2];\n                }\n            }\n            if (v == value) {\n                ans[1].push_back(edges[i][3]);\n            }\n        }\n      \n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\n        int m = edges.length;\n        int[][] newEdges = new int[m][4];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                newEdges[i][j] = edges[i][j];\n            }\n            newEdges[i][3] = i;\n        }\n        Arrays.sort(newEdges, new Comparator<int[]>() {\n            public int compare(int[] u, int[] v) {\n                return u[2] - v[2];\n            }\n        });\n\n        // 计算 value\n        UnionFind ufStd = new UnionFind(n);\n        int value = 0;\n        for (int i = 0; i < m; ++i) {\n            if (ufStd.unite(newEdges[i][0], newEdges[i][1])) {\n                value += newEdges[i][2];\n            }\n        }\n\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        for (int i = 0; i < 2; ++i) {\n            ans.add(new ArrayList<Integer>());\n        }\n        \n        for (int i = 0; i < m; ++i) {\n            // 判断是否是关键边\n            UnionFind uf = new UnionFind(n);\n            int v = 0;\n            for (int j = 0; j < m; ++j) {\n                if (i != j && uf.unite(newEdges[j][0], newEdges[j][1])) {\n                    v += newEdges[j][2];\n                }\n            }\n            if (uf.setCount != 1 || (uf.setCount == 1 && v > value)) {\n                ans.get(0).add(newEdges[i][3]);\n                continue;\n            }\n\n            // 判断是否是伪关键边\n            uf = new UnionFind(n);\n            uf.unite(newEdges[i][0], newEdges[i][1]);\n            v = newEdges[i][2];\n            for (int j = 0; j < m; ++j) {\n                if (i != j && uf.unite(newEdges[j][0], newEdges[j][1])) {\n                    v += newEdges[j][2];\n                }\n            }\n            if (v == value) {\n                ans.get(1).add(newEdges[i][3]);\n            }\n        }\n      \n        return ans;\n    }\n}\n\n// 并查集模板\nclass UnionFind {\n    int[] parent;\n    int[] size;\n    int n;\n    // 当前连通分量数目\n    int setCount;\n\n    public UnionFind(int n) {\n        this.n = n;\n        this.setCount = n;\n        this.parent = new int[n];\n        this.size = new int[n];\n        Arrays.fill(size, 1);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n    \n    public int findset(int x) {\n        return parent[x] == x ? x : (parent[x] = findset(parent[x]));\n    }\n    \n    public boolean unite(int x, int y) {\n        x = findset(x);\n        y = findset(y);\n        if (x == y) {\n            return false;\n        }\n        if (size[x] < size[y]) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n        parent[y] = x;\n        size[x] += size[y];\n        --setCount;\n        return true;\n    }\n    \n    public boolean connected(int x, int y) {\n        x = findset(x);\n        y = findset(y);\n        return x == y;\n    }\n}\n```\n\n```Python [sol1-Python3]\n# 并查集模板\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.n = n\n        # 当前连通分量数目\n        self.setCount = n\n    \n    def findset(self, x: int) -> int:\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.findset(self.parent[x])\n        return self.parent[x]\n    \n    def unite(self, x: int, y: int) -> bool:\n        x, y = self.findset(x), self.findset(y)\n        if x == y:\n            return False\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.parent[y] = x\n        self.size[x] += self.size[y]\n        self.setCount -= 1\n        return True\n    \n    def connected(self, x: int, y: int) -> bool:\n        x, y = self.findset(x), self.findset(y)\n        return x == y\n\nclass Solution:\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        m = len(edges)\n        for i, edge in enumerate(edges):\n            edge.append(i)\n        edges.sort(key=lambda x: x[2])\n\n        # 计算 value\n        uf_std = UnionFind(n)\n        value = 0\n        for i in range(m):\n            if uf_std.unite(edges[i][0], edges[i][1]):\n                value += edges[i][2]\n\n        ans = [list(), list()]\n        \n        for i in range(m):\n            # 判断是否是关键边\n            uf = UnionFind(n)\n            v = 0\n            for j in range(m):\n                if i != j and uf.unite(edges[j][0], edges[j][1]):\n                    v += edges[j][2]\n            if uf.setCount != 1 or (uf.setCount == 1 and v > value):\n                ans[0].append(edges[i][3])\n                continue\n\n            # 判断是否是伪关键边\n            uf = UnionFind(n)\n            uf.unite(edges[i][0], edges[i][1])\n            v = edges[i][2]\n            for j in range(m):\n                if i != j and uf.unite(edges[j][0], edges[j][1]):\n                    v += edges[j][2]\n            if v == value:\n                ans[1].append(edges[i][3])\n      \n        return ans\n```\n\n```go [sol1-Golang]\ntype unionFind struct {\n    parent, size []int\n    setCount     int // 当前连通分量数目\n}\n\nfunc newUnionFind(n int) *unionFind {\n    parent := make([]int, n)\n    size := make([]int, n)\n    for i := range parent {\n        parent[i] = i\n        size[i] = 1\n    }\n    return &unionFind{parent, size, n}\n}\n\nfunc (uf *unionFind) find(x int) int {\n    if uf.parent[x] != x {\n        uf.parent[x] = uf.find(uf.parent[x])\n    }\n    return uf.parent[x]\n}\n\nfunc (uf *unionFind) union(x, y int) bool {\n    fx, fy := uf.find(x), uf.find(y)\n    if fx == fy {\n        return false\n    }\n    if uf.size[fx] < uf.size[fy] {\n        fx, fy = fy, fx\n    }\n    uf.size[fx] += uf.size[fy]\n    uf.parent[fy] = fx\n    uf.setCount--\n    return true\n}\n\nfunc findCriticalAndPseudoCriticalEdges(n int, edges [][]int) [][]int {\n    for i, e := range edges {\n        edges[i] = append(e, i)\n    }\n    sort.Slice(edges, func(i, j int) bool { return edges[i][2] < edges[j][2] })\n\n    calcMST := func(uf *unionFind, ignoreID int) (mstValue int) {\n        for i, e := range edges {\n            if i != ignoreID && uf.union(e[0], e[1]) {\n                mstValue += e[2]\n            }\n        }\n        if uf.setCount > 1 {\n            return math.MaxInt64\n        }\n        return\n    }\n\n    mstValue := calcMST(newUnionFind(n), -1)\n\n    var keyEdges, pseudokeyEdges []int\n    for i, e := range edges {\n        // 是否为关键边\n        if calcMST(newUnionFind(n), i) > mstValue {\n            keyEdges = append(keyEdges, e[3])\n            continue\n        }\n\n        // 是否为伪关键边\n        uf := newUnionFind(n)\n        uf.union(e[0], e[1])\n        if e[2]+calcMST(uf, i) == mstValue {\n            pseudokeyEdges = append(pseudokeyEdges, e[3])\n        }\n    }\n\n    return [][]int{keyEdges, pseudokeyEdges}\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\n    const m = edges.length;\n    for (const [i, edge] of edges.entries()) {\n        edge.push(i);\n    }\n    edges.sort((a, b) => a[2] - b[2]);\n\n    // 计算 value\n    const uf_std = new UnionFind(n);\n    let value = 0;\n    for (let i = 0; i < m; i++) {\n        if (uf_std.unite(edges[i][0], edges[i][1])) {\n            value += edges[i][2];\n        }\n    }\n\n    const ans = [[], []];\n\n    for (let i = 0; i < m; i++) {\n        // 判断是否是关键边\n        let uf = new UnionFind(n);\n        let v = 0;\n        for (let j = 0; j < m; j++) {\n            if (i !== j && uf.unite(edges[j][0], edges[j][1])) {\n                v += edges[j][2];\n            }\n        }\n        if (uf.setCount !== 1 || (uf.setCount === 1 && v > value)) {\n            ans[0].push(edges[i][3]);\n            continue;\n        }\n\n        // 判断是否是伪关键边\n        uf = new UnionFind(n);\n        uf.unite(edges[i][0], edges[i][1]);\n        v = edges[i][2];\n        for (let j = 0; j < m; j++) {\n            if (i !== j && uf.unite(edges[j][0], edges[j][1])) {\n                v += edges[j][2];\n            }\n        }\n        if (v === value) {\n            ans[1].push(edges[i][3]);\n        }\n    }\n    return ans;\n};\n\n// 并查集模板\nclass UnionFind {\n    constructor (n) {\n        this.parent = new Array(n).fill(0).map((element, index) => index);\n        this.size = new Array(n).fill(1);\n        // 当前连通分量数目\n        this.setCount = n;\n    }\n\n    findset (x) {\n        if (this.parent[x] === x) {\n            return x;\n        }\n        this.parent[x] = this.findset(this.parent[x]);\n        return this.parent[x];\n    }\n\n    unite (a, b) {\n        let x = this.findset(a), y = this.findset(b);\n        if (x === y) {\n            return false;\n        }\n        if (this.size[x] < this.size[y]) {\n            [x, y] = [y, x];\n        }\n        this.parent[y] = x;\n        this.size[x] += this.size[y];\n        this.setCount -= 1;\n        return true;\n    }\n\n    connected (a, b) {\n        const x = this.findset(a), y = this.findset(b);\n        return x === y;\n    }\n}\n```\n\n```C [sol1-C]\nvoid swap(int* a, int* b) {\n    int tmp = *a;\n    *a = *b, *b = tmp;\n}\n\nstruct Edge {\n    int x, y, w, id;\n};\n\nint cmp(const void* a, const void* b) {\n    return ((struct Edge*)a)->w - ((struct Edge*)b)->w;\n}\n\nstruct DisjointSetUnion {\n    int *f, *size;\n    int n, setCount;\n};\n\nvoid initDSU(struct DisjointSetUnion* obj, int n) {\n    obj->f = malloc(sizeof(int) * n);\n    obj->size = malloc(sizeof(int) * n);\n    obj->n = n;\n    obj->setCount = n;\n    for (int i = 0; i < n; i++) {\n        obj->f[i] = i;\n        obj->size[i] = 1;\n    }\n}\n\nvoid freeDSU(struct DisjointSetUnion* obj) {\n    free(obj->f);\n    free(obj->size);\n    free(obj);\n}\n\nint find(struct DisjointSetUnion* obj, int x) {\n    return obj->f[x] == x ? x : (obj->f[x] = find(obj, obj->f[x]));\n}\n\nint unionSet(struct DisjointSetUnion* obj, int x, int y) {\n    int fx = find(obj, x), fy = find(obj, y);\n    if (fx == fy) {\n        return false;\n    }\n    if (obj->size[fx] < obj->size[fy]) {\n        swap(&fx, &fy);\n    }\n    obj->size[fx] += obj->size[fy];\n    obj->f[fy] = fx;\n    obj->setCount--;\n    return true;\n}\n\nint** findCriticalAndPseudoCriticalEdges(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes) {\n    int m = edgesSize;\n    struct Edge edgesTmp[m];\n    for (int i = 0; i < m; i++) {\n        edgesTmp[i].x = edges[i][0];\n        edgesTmp[i].y = edges[i][1];\n        edgesTmp[i].w = edges[i][2];\n        edgesTmp[i].id = i;\n    }\n    qsort(edgesTmp, m, sizeof(struct Edge), cmp);\n\n    struct DisjointSetUnion* ufStd = malloc(sizeof(struct DisjointSetUnion));\n    initDSU(ufStd, n);\n\n    int value = 0;\n    for (int i = 0; i < m; ++i) {\n        if (unionSet(ufStd, edgesTmp[i].x, edgesTmp[i].y)) {\n            value += edgesTmp[i].w;\n        }\n    }\n    freeDSU(ufStd);\n\n    *returnSize = 2;\n    int** ans = malloc(sizeof(int*) * 2);\n    for (int i = 0; i < 2; i++) {\n        ans[i] = malloc(sizeof(int) * m);\n    }\n    *returnColumnSizes = malloc(sizeof(int) * 2);\n    memset(*returnColumnSizes, 0, sizeof(int) * 2);\n\n    for (int i = 0; i < m; ++i) {\n        // 判断是否是关键边\n        struct DisjointSetUnion* uf1 = malloc(sizeof(struct DisjointSetUnion));\n        initDSU(uf1, n);\n\n        int v = 0;\n        for (int j = 0; j < m; ++j) {\n            if (i != j && unionSet(uf1, edgesTmp[j].x, edgesTmp[j].y)) {\n                v += edgesTmp[j].w;\n            }\n        }\n        if (uf1->setCount != 1 || (uf1->setCount == 1 && v > value)) {\n            ans[0][(*returnColumnSizes)[0]++] = edgesTmp[i].id;\n            continue;\n        }\n        freeDSU(uf1);\n\n        // 判断是否是伪关键边\n        struct DisjointSetUnion* uf2 = malloc(sizeof(struct DisjointSetUnion));\n        initDSU(uf2, n);\n        unionSet(uf2, edgesTmp[i].x, edgesTmp[i].y);\n        v = edgesTmp[i].w;\n        for (int j = 0; j < m; ++j) {\n            if (i != j && unionSet(uf2, edgesTmp[j].x, edgesTmp[j].y)) {\n                v += edgesTmp[j].w;\n            }\n        }\n        if (v == value) {\n            ans[1][(*returnColumnSizes)[1]++] = edgesTmp[i].id;\n        }\n    }\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m^2 \\cdot \\alpha(n))$，其中 $n$ 和 $m$ 分别是图中的节点数和边数。我们首先需要对所有的边进行排序，时间复杂度为 $O(m \\log m)$。一次 $\\texttt{Kruskal}$ 算法的时间复杂度为 $O(m \\cdot \\alpha(n))$，其中 $\\alpha$ 是阿克曼函数的反函数。我们最多需要执行 $2m + 1$ 次 $\\texttt{Kruskal}$ 算法，时间复杂度为 $O(m^2 \\alpha(n))$，在渐进意义下大于排序的时间复杂度，因此前者可以忽略不计，总时间复杂度为 $O(m^2 \\cdot \\alpha(n))$。\n\n- 空间复杂度：$O(m + n)$。在进行排序时，我们必须要额外存储每条边原始的编号，用来返回答案，空间复杂度为 $O(m)$。$\\texttt{Kruskal}$ 算法中的并查集需要使用 $O(n)$ 的空间，因此总空间复杂度为 $O(m+n)$。\n\n#### 方法二：连通性 + 最小生成树性质\n\n**前言**\n\n要理解方法二，读者必须要知道最小生成树的一个性质：\n\n- 在 $\\texttt{Kruskal}$ 算法中，对于任意的实数 $w$，只要我们将给定的边按照权值从小到大进行排序，那么当我们按照顺序处理完所有权值小于等于 $w$ 的边之后，对应的并查集的连通性是唯一确定的，无论我们在排序时如何规定权值相同的边的顺序。\n\n并且读者需要掌握：\n\n- 给定一个无向图，使用 $\\texttt{Tarjan}$ 算法求出所有的桥边。\n\n**思路与算法**\n\n假设我们已经处理完了所有权值小于 $w$ 的边，并查集的状态记为 $U$，该状态是唯一确定的。此时，我们同时处理所有权值等于 $w$ 的边，记这些边的集合为 $\\{e_w\\}$。我们将 $U$ 中的每一个连通分量看成一个节点，对于 $\\{e_w\\}$ 中的每一条无向边的两个端点，将它们在 $U$ 中属于的连通分量对应的节点之间连接一条无向边，以此得到图 $G$。图 $G$ 中会有三种类型的边：\n\n- 自环边：即从一个节点指向本身的一条边。如果 $\\{e_w\\}$ 中的一条边的两个端点属于同一个连通分量，那么它在图 $G$ 中表现为一条自环边。根据 $\\texttt{Kruskal}$ 算法，这样的边不会被添加进最小生成树中。\n\n对于剩余的边，它们的两个端点属于不同的联通分量。如果我们将其作为 $\\texttt{Kruskal}$ 算法中第一条权值为 $w$ 的边进行处理，那么这条边一定会被添加进最小生成树中。因此剩余的边要么是关键边，要么是伪关键边，它们在图 $G$ 中的表现形式不同：\n\n- 桥边。如果 $\\{e_w\\}$ 中的一条边对应了图 $G$ 中的一条桥边，那么当这条边被删去时，图 $G$ 的连通性就会发生改变。\n\n    > 这样的例子可能会帮助理解：如果我们将这条边作为 $\\texttt{Kruskal}$ 算法中最后一条权值为 $w$ 的边进行处理，那么这条边还是会被添加进最小生成树中。\n\n  也就是说，这条边对于最小生成树而言是必须的，那么它就是关键边；\n\n- 非桥边。如果 $\\{e_w\\}$ 中的一条边对应了图 $G$ 中的一条非桥边，那么当这条边被删去时，图 $G$ 的连通性不会发生改变。\n\n    > 这样的例子可能会帮助理解：如果我们将这条边作为 $\\texttt{Kruskal}$ 算法中最后一条权值为 $w$ 的边进行处理，那么在此之前，并查集的连通性已经和（任意顺序）处理完所有权值为 $w$ 的边之后的连通性一致，这条边就不会被添加进最小生成树中。\n  \n  也就是说，这条边对于最小生成树而言不是必须的，那么它就是伪关键边。\n\n因此图 $G$ 中的桥边与 $\\{e_w\\}$ 中的关键边一一对应，非桥边（且非自环边）与 $\\{e_w\\}$ 中的非关键边一一对应。\n\n我们可以使用 $\\texttt{Tarjan}$ 算法求出图 $G$ 中的所有桥边，那么算法的时间复杂度是多少呢？如果图 $G$ 中有 $n_0$ 个节点和 $m_0$ 条边，那么 $\\texttt{Tarjan}$ 算法的时间复杂度为 $O(n_0 + m_0)$。对于每一个 $w$ 值对应的 $\\{e_w\\}$，我们并不需要将并查集中的每一个连通分量都作为一个节点放入图 $G$ 中：即如果 $\\{e_w\\}$ 中包含 $m_0$ 条边，那么它们最多会只连接了 $2m_0$ 个连通分量，因此图 $G$ 中最多有 $2m_0$ 个节点和 $m_0$ 条边（如果一条边是自环边，那么也不需要将其放入图 $G$ 中），时间复杂度为 $O(2m_0 + m_0) = O(m_0)$，与 $\\{e_w\\}$ 中包含的边数成正比。我们对所有的 $w$ 值都需要进行一次 $\\texttt{Tarjan}$ 算法，这部分的总时间复杂度是 $O(m)$。对于排序的部分，时间复杂度是 $O(m \\log m)$，对于并查集的部分，时间复杂度是 $O(m \\cdot \\alpha(n))$，其中 $\\alpha$ 是阿克曼函数的反函数。三者中排序的时间复杂度在渐进意义下最大，因此总时间复杂度为 $O(m \\log m)$。\n\n**代码**\n\n```C++ [sol2-C++]\n// 并查集模板\nclass UnionFind {\npublic:\n    vector<int> parent;\n    vector<int> size;\n    int n;\n    // 当前连通分量数目\n    int setCount;\n    \npublic:\n    UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n    \n    int findset(int x) {\n        return parent[x] == x ? x : parent[x] = findset(parent[x]);\n    }\n    \n    bool unite(int x, int y) {\n        x = findset(x);\n        y = findset(y);\n        if (x == y) {\n            return false;\n        }\n        if (size[x] < size[y]) {\n            swap(x, y);\n        }\n        parent[y] = x;\n        size[x] += size[y];\n        --setCount;\n        return true;\n    }\n    \n    bool connected(int x, int y) {\n        x = findset(x);\n        y = findset(y);\n        return x == y;\n    }\n};\n\n// Tarjan 算法求桥边模版\nclass TarjanSCC {\nprivate:\n    const vector<vector<int>>& edges;\n    const vector<vector<int>>& edgesId;\n    vector<int> low;\n    vector<int> dfn;\n    vector<int> ans;\n    int n;\n    int ts;\n\nprivate:\n    void getCuttingEdge_(int u, int parentEdgeId) {\n        low[u] = dfn[u] = ++ts;\n        for (int i = 0; i < edges[u].size(); ++i) {\n            int v = edges[u][i];\n            int id = edgesId[u][i];\n            if (dfn[v] == -1) {\n                getCuttingEdge_(v, id);\n                low[u] = min(low[u], low[v]);\n                if (low[v] > dfn[u]) {\n                    ans.push_back(id);\n                }\n            }\n            else if (id != parentEdgeId) {\n                low[u] = min(low[u], dfn[v]);\n            }\n        }\n    }\n\npublic:\n    TarjanSCC(int n_, const vector<vector<int>>& edges_, const vector<vector<int>>& edgesId_): \\\n        edges(edges_), edgesId(edgesId_), low(n_, -1), dfn(n_, -1), n(n_), ts(-1) {}\n    \n    vector<int> getCuttingEdge() {\n        for (int i = 0; i < n; ++i) {\n            if (dfn[i] == -1) {\n                getCuttingEdge_(i, -1);\n            }\n        }\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\n        int m = edges.size();\n        for (int i = 0; i < m; ++i) {\n            edges[i].push_back(i);\n        }\n        sort(edges.begin(), edges.end(), [](const auto& u, const auto& v) {\n            return u[2] < v[2];\n        });\n\n        UnionFind uf(n);\n        vector<vector<int>> ans(2);\n        vector<int> label(m);\n        for (int i = 0; i < m;) {\n            // 找出所有权值为 w 的边，下标范围为 [i, j)\n            int w = edges[i][2];\n            int j = i;\n            while (j < m && edges[j][2] == edges[i][2]) {\n                ++j;\n            }\n\n            // 存储每个连通分量在图 G 中的编号\n            unordered_map<int, int> compToId;\n            // 图 G 的节点数\n            int gn = 0;\n            \n            for (int k = i; k < j; ++k) {\n                int x = uf.findset(edges[k][0]);\n                int y = uf.findset(edges[k][1]);\n                if (x != y) {\n                    if (!compToId.count(x)) {\n                        compToId[x] = gn++;\n                    }\n                    if (!compToId.count(y)) {\n                        compToId[y] = gn++;\n                    }\n                }\n                else {\n                    // 将自环边标记为 -1\n                    label[edges[k][3]] = -1;\n                }\n            }\n            \n            // 图 G 的边\n            vector<vector<int>> gm(gn), gmid(gn);\n            \n            for (int k = i; k < j; ++k) {\n                int x = uf.findset(edges[k][0]);\n                int y = uf.findset(edges[k][1]);\n                if (x != y) {\n                    int idx = compToId[x], idy = compToId[y];\n                    gm[idx].push_back(idy);\n                    gmid[idx].push_back(edges[k][3]);\n                    gm[idy].push_back(idx);\n                    gmid[idy].push_back(edges[k][3]);\n                }\n            }\n\n            vector<int> bridges = TarjanSCC(gn, gm, gmid).getCuttingEdge();\n            // 将桥边（关键边）标记为 1\n            for (int id: bridges) {\n                ans[0].push_back(id);\n                label[id] = 1;\n            }\n\n            for (int k = i; k < j; ++k) {\n                uf.unite(edges[k][0], edges[k][1]);\n            }\n\n            i = j;\n        }\n\n        // 未标记的边即为非桥边（伪关键边）\n        for (int i = 0; i < m; ++i) {\n            if (!label[i]) {\n                ans[1].push_back(i);\n            }\n        }\n\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\n        int m = edges.length;\n        int[][] newEdges = new int[m][4];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                newEdges[i][j] = edges[i][j];\n            }\n            newEdges[i][3] = i;\n        }\n        Arrays.sort(newEdges, new Comparator<int[]>() {\n            public int compare(int[] u, int[] v) {\n                return u[2] - v[2];\n            }\n        });\n\n        UnionFind uf = new UnionFind(n);\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        for (int i = 0; i < 2; ++i) {\n            ans.add(new ArrayList<Integer>());\n        }\n        int[] label = new int[m];\n        for (int i = 0; i < m;) {\n            // 找出所有权值为 w 的边，下标范围为 [i, j)\n            int w = newEdges[i][2];\n            int j = i;\n            while (j < m && newEdges[j][2] == newEdges[i][2]) {\n                ++j;\n            }\n\n            // 存储每个连通分量在图 G 中的编号\n            Map<Integer, Integer> compToId = new HashMap<Integer, Integer>();\n            // 图 G 的节点数\n            int gn = 0;\n            \n            for (int k = i; k < j; ++k) {\n                int x = uf.findset(newEdges[k][0]);\n                int y = uf.findset(newEdges[k][1]);\n                if (x != y) {\n                    if (!compToId.containsKey(x)) {\n                        compToId.put(x, gn++);\n                    }\n                    if (!compToId.containsKey(y)) {\n                        compToId.put(y, gn++);\n                    }\n                } else {\n                    // 将自环边标记为 -1\n                    label[newEdges[k][3]] = -1;\n                }\n            }\n            \n            // 图 G 的边\n            List<Integer>[] gm = new List[gn];\n            List<Integer>[] gmid = new List[gn];\n            for (int k = 0; k < gn; ++k) {\n                gm[k] = new ArrayList<Integer>();\n                gmid[k] = new ArrayList<Integer>();\n            }\n            \n            for (int k = i; k < j; ++k) {\n                int x = uf.findset(newEdges[k][0]);\n                int y = uf.findset(newEdges[k][1]);\n                if (x != y) {\n                    int idx = compToId.get(x), idy = compToId.get(y);\n                    gm[idx].add(idy);\n                    gmid[idx].add(newEdges[k][3]);\n                    gm[idy].add(idx);\n                    gmid[idy].add(newEdges[k][3]);\n                }\n            }\n\n            List<Integer> bridges = new TarjanSCC(gn, gm, gmid).getCuttingEdge();\n            // 将桥边（关键边）标记为 1\n            for (int id : bridges) {\n                ans.get(0).add(id);\n                label[id] = 1;\n            }\n\n            for (int k = i; k < j; ++k) {\n                uf.unite(newEdges[k][0], newEdges[k][1]);\n            }\n\n            i = j;\n        }\n\n        // 未标记的边即为非桥边（伪关键边）\n        for (int i = 0; i < m; ++i) {\n            if (label[i] == 0) {\n                ans.get(1).add(i);\n            }\n        }\n\n        return ans;\n    }\n}\n\n// 并查集模板\nclass UnionFind {\n    int[] parent;\n    int[] size;\n    int n;\n    // 当前连通分量数目\n    int setCount;\n\n    public UnionFind(int n) {\n        this.n = n;\n        this.setCount = n;\n        this.parent = new int[n];\n        this.size = new int[n];\n        Arrays.fill(size, 1);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n    \n    public int findset(int x) {\n        return parent[x] == x ? x : (parent[x] = findset(parent[x]));\n    }\n    \n    public boolean unite(int x, int y) {\n        x = findset(x);\n        y = findset(y);\n        if (x == y) {\n            return false;\n        }\n        if (size[x] < size[y]) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n        parent[y] = x;\n        size[x] += size[y];\n        --setCount;\n        return true;\n    }\n    \n    public boolean connected(int x, int y) {\n        x = findset(x);\n        y = findset(y);\n        return x == y;\n    }\n}\n\nclass TarjanSCC {\n    List<Integer>[] edges;\n    List<Integer>[] edgesId;\n    int[] low;\n    int[] dfn;\n    List<Integer> ans;\n    int n;\n    int ts;\n\n    public TarjanSCC(int n, List<Integer>[] edges, List<Integer>[] edgesId) {\n        this.edges = edges;\n        this.edgesId = edgesId;\n        this.low = new int[n];\n        Arrays.fill(low, -1);\n        this.dfn = new int[n];\n        Arrays.fill(dfn, -1);\n        this.n = n;\n        this.ts = -1;\n        this.ans = new ArrayList<Integer>();\n    }\n    \n    public List<Integer> getCuttingEdge() {\n        for (int i = 0; i < n; ++i) {\n            if (dfn[i] == -1) {\n                getCuttingEdge(i, -1);\n            }\n        }\n        return ans;\n    }\n\n    private void getCuttingEdge(int u, int parentEdgeId) {\n        low[u] = dfn[u] = ++ts;\n        for (int i = 0; i < edges[u].size(); ++i) {\n            int v = edges[u].get(i);\n            int id = edgesId[u].get(i);\n            if (dfn[v] == -1) {\n                getCuttingEdge(v, id);\n                low[u] = Math.min(low[u], low[v]);\n                if (low[v] > dfn[u]) {\n                    ans.add(id);\n                }\n            } else if (id != parentEdgeId) {\n                low[u] = Math.min(low[u], dfn[v]);\n            }\n        }\n    }\n}\n```\n\n```Python [sol2-Python3]\n# 并查集模板\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.n = n\n        # 当前连通分量数目\n        self.setCount = n\n    \n    def findset(self, x: int) -> int:\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.findset(self.parent[x])\n        return self.parent[x]\n    \n    def unite(self, x: int, y: int) -> bool:\n        x, y = self.findset(x), self.findset(y)\n        if x == y:\n            return False\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.parent[y] = x\n        self.size[x] += self.size[y]\n        self.setCount -= 1\n        return True\n    \n    def connected(self, x: int, y: int) -> bool:\n        x, y = self.findset(x), self.findset(y)\n        return x == y\n\n# Tarjan 算法求桥边模版\nclass TarjanSCC:\n    def __init__(self, n: int, edges: List[List[int]], edgesId: List[List[int]]):\n        self.n = n\n        self.edges = edges\n        self.edgesId = edgesId\n        self.low = [-1] * n\n        self.dfn = [-1] * n\n        self.ans = list()\n        self.ts = -1\n    \n    def getCuttingEdge(self) -> List[int]:\n        for i in range(self.n):\n            if self.dfn[i] == -1:\n                self.pGetCuttingEdge(i, -1)\n        return self.ans\n    \n    def pGetCuttingEdge(self, u: int, parentEdgeId: int):\n        self.ts += 1\n        self.low[u] = self.dfn[u] = self.ts\n        for v, iden in zip(self.edges[u], self.edgesId[u]):\n            if self.dfn[v] == -1:\n                self.pGetCuttingEdge(v, iden)\n                self.low[u] = min(self.low[u], self.low[v])\n                if self.low[v] > self.dfn[u]:\n                    self.ans.append(iden)\n            elif iden != parentEdgeId:\n                self.low[u] = min(self.low[u], self.dfn[v])\n\nclass Solution:\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        m = len(edges)\n        for i, edge in enumerate(edges):\n            edge.append(i)\n        edges.sort(key=lambda x: x[2])\n\n        uf = UnionFind(n)\n        ans0 = list()\n        label = [0] * m\n\n        i = 0\n        while i < m:\n            # 找出所有权值为 w 的边，下标范围为 [i, j)\n            w = edges[i][2]\n            j = i\n            while j < m and edges[j][2] == edges[i][2]:\n                j += 1\n\n            # 存储每个连通分量在图 G 中的编号\n            compToId = dict()\n            # 图 G 的节点数\n            gn = 0\n            \n            for k in range(i, j):\n                x = uf.findset(edges[k][0])\n                y = uf.findset(edges[k][1])\n                if x != y:\n                    if x not in compToId:\n                        compToId[x] = gn\n                        gn += 1\n                    if y not in compToId:\n                        compToId[y] = gn\n                        gn += 1\n                else:\n                    # 将自环边标记为 -1\n                    label[edges[k][3]] = -1\n            \n            # 图 G 的边\n            gm = collections.defaultdict(list)\n            gmid = collections.defaultdict(list)\n            \n            for k in range(i, j):\n                x = uf.findset(edges[k][0])\n                y = uf.findset(edges[k][1])\n                if x != y:\n                    idx, idy = compToId[x], compToId[y]\n                    gm[idx].append(idy)\n                    gmid[idx].append(edges[k][3])\n                    gm[idy].append(idx)\n                    gmid[idy].append(edges[k][3])\n\n            bridges = TarjanSCC(gn, gm, gmid).getCuttingEdge()\n            # 将桥边（关键边）标记为 1\n            ans0.extend(bridges)\n            for iden in bridges:\n                label[iden] = 1\n\n            for k in range(i, j):\n                uf.unite(edges[k][0], edges[k][1])\n            \n            i = j\n\n        # 未标记的边即为非桥边（伪关键边）\n        ans1 = [i for i in range(m) if label[i] == 0]\n\n        return [ans0, ans1]\n```\n\n```go [sol2-Golang]\ntype unionFind struct {\n    parent, size []int\n}\n\nfunc newUnionFind(n int) *unionFind {\n    parent := make([]int, n)\n    size := make([]int, n)\n    for i := range parent {\n        parent[i] = i\n        size[i] = 1\n    }\n    return &unionFind{parent, size}\n}\n\nfunc (uf *unionFind) find(x int) int {\n    if uf.parent[x] != x {\n        uf.parent[x] = uf.find(uf.parent[x])\n    }\n    return uf.parent[x]\n}\n\nfunc (uf *unionFind) union(x, y int) bool {\n    fx, fy := uf.find(x), uf.find(y)\n    if fx == fy {\n        return false\n    }\n    if uf.size[fx] < uf.size[fy] {\n        fx, fy = fy, fx\n    }\n    uf.size[fx] += uf.size[fy]\n    uf.parent[fy] = fx\n    return true\n}\n\nfunc findCriticalAndPseudoCriticalEdges(n int, edges [][]int) [][]int {\n    m := len(edges)\n    edgeType := make([]int, m) // -1：不在最小生成树中；0：伪关键边；1：关键边\n\n    for i, e := range edges {\n        edges[i] = append(e, i)\n    }\n    sort.Slice(edges, func(i, j int) bool { return edges[i][2] < edges[j][2] })\n\n    type neighbor struct{ to, edgeID int }\n    graph := make([][]neighbor, n)\n    dfn := make([]int, n) // 遍历到该顶点时的时间戳\n    timestamp := 0\n    var tarjan func(int, int) int\n    tarjan = func(v, pid int) int {\n        timestamp++\n        dfn[v] = timestamp\n        lowV := timestamp\n        for _, e := range graph[v] {\n            if w := e.to; dfn[w] == 0 {\n                lowW := tarjan(w, e.edgeID)\n                if lowW > dfn[v] {\n                    edgeType[e.edgeID] = 1\n                }\n                lowV = min(lowV, lowW)\n            } else if e.edgeID != pid {\n                lowV = min(lowV, dfn[w])\n            }\n        }\n        return lowV\n    }\n\n    uf := newUnionFind(n)\n    for i := 0; i < m; {\n        vs := []int{}\n        // 将权值相同的边分为一组，建图，然后用 Tarjan 算法找桥边\n        for weight := edges[i][2]; i < m && edges[i][2] == weight; i++ {\n            e := edges[i]\n            v, w, edgeID := uf.find(e[0]), uf.find(e[1]), e[3]\n            if v != w {\n                graph[v] = append(graph[v], neighbor{w, edgeID})\n                graph[w] = append(graph[w], neighbor{v, edgeID})\n                vs = append(vs, v, w) // 记录图中顶点\n            } else {\n                edgeType[edgeID] = -1\n            }\n        }\n        for _, v := range vs {\n            if dfn[v] == 0 {\n                tarjan(v, -1)\n            }\n        }\n        // 合并顶点、重置数据\n        for j := 0; j < len(vs); j += 2 {\n            v, w := vs[j], vs[j+1]\n            uf.union(v, w)\n            graph[v] = nil\n            graph[w] = nil\n            dfn[v] = 0\n            dfn[w] = 0\n        }\n    }\n\n    var keyEdges, pseudokeyEdges []int\n    for i, tp := range edgeType {\n        if tp == 0 {\n            pseudokeyEdges = append(pseudokeyEdges, i)\n        } else if tp == 1 {\n            keyEdges = append(keyEdges, i)\n        }\n    }\n    return [][]int{keyEdges, pseudokeyEdges}\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m \\log m)$，其中 $m$ 是图中的边数。\n\n- 空间复杂度：$O(m + n)$。排序时存储每条边原始编号的空间为 $O(m)$，并查集使用的空间为 $O(n)$，$\\texttt{Tarjan}$ 算法使用的总空间为 $O(m)$。"
}