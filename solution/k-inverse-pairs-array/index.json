{
	"titleSlug": "k-inverse-pairs-array",
	"slug": "kge-ni-xu-dui-shu-zu-by-leetcode-solutio-0hkr",
	"url": "https://leetcode-cn.com/problems/k-inverse-pairs-array/solution/kge-ni-xu-dui-shu-zu-by-leetcode-solutio-0hkr/",
	"content": "#### 方法一：动态规划\n\n**思路与算法**\n\n我们可以用动态规划的方法来解决本题。\n\n设 $f[i][j]$ 表示我们使用数字 $1, 2, \\cdots, i$ 的排列构成长度为 $i$ 的数组，并且恰好包含 $j$ 个逆序对的方案数。在进行状态转移时，我们可以考虑第 $i$ 个元素选取了 $1, 2, \\cdots, i$ 中的哪个数字。\n\n假设我们选取了数字 $k$，那么数组的前 $i-1$ 个元素由 $1, \\cdots, k-1$ 以及 $k+1, \\cdots, i$ 的某个排列构成。数组中的逆序对的个数可以看成如下的两部分之和：\n\n- 数字 $k$ 与前 $i-1$ 个元素产生的逆序对的个数；\n\n- 前 $i-1$ 个元素「内部」产生的逆序对个数。\n\n对于第一部分而言，我们可以求出：数字 $k$ 会贡献 $i-k$ 个逆序对，即 $k+1, \\cdots, i$ 与 $k$ 分别产生一个逆序对。\n\n对于第二部分而言，我们希望它能够有 $j - (i-k)$ 个逆序对，这样才能一共有 $j$ 个逆序对。由于我们关心的是前 $i-1$ 个元素「内部」产生的逆序对个数，而逆序对只和元素的「相对大小」有关，因此我们可以：\n\n- $1, \\cdots, k-1$ 这些元素保持不变；\n\n- $k+1, \\cdots, i$ 这些元素均减少 $1$，变成 $k, \\cdots, i-1$。\n\n使得前 $i-1$ 个元素中，任意两个元素的相对大小都不发生变化。此时，我们的目标变成了「对于 $1, 2, \\cdots, i-1$，希望它能够有 $j-(i-k)$ 个逆序对」，这就是动态规划中的子任务 $f[i-1][j-(i-k)]$。\n\n因此，我们就可以通过枚举 $k$ 得到状态转移方程：\n\n$$\nf[i][j] = \\sum_{k=1}^i f[i-1][j-(i-k)] = \\sum_{k=0}^{i-1} f[i-1][j-k]\n$$\n\n边界条件为：\n\n- $f[0][0] = 1$，即不用任何数字可以构成一个空数组，它包含 $0$ 个逆序对；\n\n- $f[i][j < 0] = 0$，由于逆序对的数量一定是非负整数，因此所有 $j < 0$ 的状态的值都为 $0$。我们不需要显式地存储这些状态，只需要在进行状态转移遇到这样的项时，注意特殊判断即可。\n\n最终的答案即为 $f[n][k]$。\n\n**优化**\n\n上述动态规划的状态数量为 $O(nk)$，而求出每一个 $f[i][j]$ 需要 $O(n)$ 的时间复杂度，因此总时间复杂度为 $O(n^2k)$，会超出时间限制，我们必须要进行优化。\n\n我们考虑 $f[i][j-1]$ 和 $f[i][j]$ 的状态转移方程：\n\n$$\n\\left\\{\n\\begin{aligned}\n    & f[i][j-1] && = && \\sum_{k=0}^{i-1} f[i-1][j-1-k] \\\\\n    & f[i][j] && = && \\sum_{k=0}^{i-1} f[i-1][j-k]\n\\end{aligned}\n\\right.\n$$\n\n可以得到从 $f[i][j-1]$ 到 $f[i][j]$ 的递推式：\n\n$$\nf[i][j] = f[i][j-1] - f[i-1][j-i] + f[i-1][j]\n$$\n\n这样我们就可以在 $O(1)$ 的时间计算出每个 $f[i][j]$，总时间复杂度降低为 $O(nk)$。\n\n此外，由于 $f[i][j]$ 只会从第 $f[i-1][..]$ 和 $f[i][..]$ 转移而来，因此我们可以对动态规划使用的空间进行优化，即使用两个一维数组交替地进行状态转移，空间复杂度从 $O(nk)$ 降低为 $O(k)$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    static constexpr int mod = 1000000007;\n\npublic:\n    int kInversePairs(int n, int k) {\n        vector<vector<int>> f(2, vector<int>(k + 1));\n        f[0][0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int cur = i & 1, prev = cur ^ 1;\n                f[cur][j] = (j - 1 >= 0 ? f[cur][j - 1] : 0) - (j - i >= 0 ? f[prev][j - i] : 0) + f[prev][j];\n                if (f[cur][j] >= mod) {\n                    f[cur][j] -= mod;\n                }\n                else if (f[cur][j] < 0) {\n                    f[cur][j] += mod;\n                }\n            }\n        }\n        return f[n & 1][k];\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int kInversePairs(int n, int k) {\n        final int MOD = 1000000007;\n        int[][] f = new int[2][k + 1];\n        f[0][0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int cur = i & 1, prev = cur ^ 1;\n                f[cur][j] = (j - 1 >= 0 ? f[cur][j - 1] : 0) - (j - i >= 0 ? f[prev][j - i] : 0) + f[prev][j];\n                if (f[cur][j] >= MOD) {\n                    f[cur][j] -= MOD;\n                } else if (f[cur][j] < 0) {\n                    f[cur][j] += MOD;\n                }\n            }\n        }\n        return f[n & 1][k];\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int KInversePairs(int n, int k) {\n        const int MOD = 1000000007;\n        int[,] f = new int[2, k + 1];\n        f[0, 0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int cur = i & 1, prev = cur ^ 1;\n                f[cur, j] = (j - 1 >= 0 ? f[cur, j - 1] : 0) - (j - i >= 0 ? f[prev, j - i] : 0) + f[prev, j];\n                if (f[cur, j] >= MOD) {\n                    f[cur, j] -= MOD;\n                } else if (f[cur, j] < 0) {\n                    f[cur, j] += MOD;\n                }\n            }\n        }\n        return f[n & 1, k];\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def kInversePairs(self, n: int, k: int) -> int:\n        mod = 10**9 + 7\n        \n        f = [1] + [0] * k\n        for i in range(1, n + 1):\n            g = [0] * (k + 1)\n            for j in range(k + 1):\n                g[j] = (g[j - 1] if j - 1 >= 0 else 0) - (f[j - i] if j - i >= 0 else 0) + f[j]\n                g[j] %= mod\n            f = g\n        \n        return f[k]\n```\n\n```go [sol1-Golang]\nfunc kInversePairs(n, k int) int {\n    const mod int = 1e9 + 7\n    f := [2][]int{make([]int, k+1), make([]int, k+1)}\n    f[0][0] = 1\n    for i := 1; i <= n; i++ {\n        for j := 0; j <= k; j++ {\n            cur := i & 1\n            prev := cur ^ 1\n            f[cur][j] = 0\n            if j > 0 {\n                f[cur][j] = f[cur][j-1]\n            }\n            if j >= i {\n                f[cur][j] -= f[prev][j-i]\n            }\n            f[cur][j] += f[prev][j]\n            if f[cur][j] >= mod {\n                f[cur][j] -= mod\n            } else if f[cur][j] < 0 {\n                f[cur][j] += mod\n            }\n        }\n    }\n    return f[n&1][k]\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar kInversePairs = function(n, k) {\n    const MOD = 1000000007;\n    const f = new Array(2).fill(0).map(() => new Array(k + 1).fill(0));\n    f[0][0] = 1;\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 0; j <= k; ++j) {\n            const cur = i & 1, prev = cur ^ 1;\n            f[cur][j] = (j - 1 >= 0 ? f[cur][j - 1] : 0) - (j - i >= 0 ? f[prev][j - i] : 0) + f[prev][j];\n            if (f[cur][j] >= MOD) {\n                f[cur][j] -= MOD;\n            } else if (f[cur][j] < 0) {\n                f[cur][j] += MOD;\n            }\n        }\n    }\n    return f[n & 1][k];\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(nk)$。\n\n- 空间复杂度：$O(k)$。"
}