{
	"titleSlug": "evaluate-reverse-polish-notation",
	"slug": "ni-bo-lan-biao-da-shi-qiu-zhi-by-leetcod-wue9",
	"url": "https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/ni-bo-lan-biao-da-shi-qiu-zhi-by-leetcod-wue9/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![150. é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼.mp4](cd99d82f-7a23-4359-baad-1252bdfe7b82)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### å‰è¨€\n\né€†æ³¢å…°è¡¨è¾¾å¼ç”±æ³¢å…°çš„é€»è¾‘å­¦å®¶å¢å¡è¥¿ç»´å…¹æå‡ºã€‚é€†æ³¢å…°è¡¨è¾¾å¼çš„ç‰¹ç‚¹æ˜¯ï¼šæ²¡æœ‰æ‹¬å·ï¼Œè¿ç®—ç¬¦æ€»æ˜¯æ”¾åœ¨å’Œå®ƒç›¸å…³çš„æ“ä½œæ•°ä¹‹åã€‚å› æ­¤ï¼Œé€†æ³¢å…°è¡¨è¾¾å¼ä¹Ÿç§°åç¼€è¡¨è¾¾å¼ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šæ ˆ\n\né€†æ³¢å…°è¡¨è¾¾å¼ä¸¥æ ¼éµå¾ªã€Œä»å·¦åˆ°å³ã€çš„è¿ç®—ã€‚è®¡ç®—é€†æ³¢å…°è¡¨è¾¾å¼çš„å€¼æ—¶ï¼Œä½¿ç”¨ä¸€ä¸ªæ ˆå­˜å‚¨æ“ä½œæ•°ï¼Œä»å·¦åˆ°å³éå†é€†æ³¢å…°è¡¨è¾¾å¼ï¼Œè¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š\n\n- å¦‚æœé‡åˆ°æ“ä½œæ•°ï¼Œåˆ™å°†æ“ä½œæ•°å…¥æ ˆï¼›\n\n- å¦‚æœé‡åˆ°è¿ç®—ç¬¦ï¼Œåˆ™å°†ä¸¤ä¸ªæ“ä½œæ•°å‡ºæ ˆï¼Œå…¶ä¸­å…ˆå‡ºæ ˆçš„æ˜¯å³æ“ä½œæ•°ï¼Œåå‡ºæ ˆçš„æ˜¯å·¦æ“ä½œæ•°ï¼Œä½¿ç”¨è¿ç®—ç¬¦å¯¹ä¸¤ä¸ªæ“ä½œæ•°è¿›è¡Œè¿ç®—ï¼Œå°†è¿ç®—å¾—åˆ°çš„æ–°æ“ä½œæ•°å…¥æ ˆã€‚\n\næ•´ä¸ªé€†æ³¢å…°è¡¨è¾¾å¼éå†å®Œæ¯•ä¹‹åï¼Œæ ˆå†…åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œè¯¥å…ƒç´ å³ä¸ºé€†æ³¢å…°è¡¨è¾¾å¼çš„å€¼ã€‚\n\n<![ppt1](https://assets.leetcode-cn.com/solution-static/150/p1.png),![ppt2](https://assets.leetcode-cn.com/solution-static/150/p2.png),![ppt3](https://assets.leetcode-cn.com/solution-static/150/p3.png),![ppt4](https://assets.leetcode-cn.com/solution-static/150/p4.png),![ppt5](https://assets.leetcode-cn.com/solution-static/150/p5.png),![ppt6](https://assets.leetcode-cn.com/solution-static/150/p6.png),![ppt7](https://assets.leetcode-cn.com/solution-static/150/p7.png),![ppt8](https://assets.leetcode-cn.com/solution-static/150/p8.png),![ppt9](https://assets.leetcode-cn.com/solution-static/150/p9.png),![ppt10](https://assets.leetcode-cn.com/solution-static/150/p10.png),![ppt11](https://assets.leetcode-cn.com/solution-static/150/p11.png),![ppt12](https://assets.leetcode-cn.com/solution-static/150/p12.png),![ppt13](https://assets.leetcode-cn.com/solution-static/150/p13.png),![ppt14](https://assets.leetcode-cn.com/solution-static/150/p14.png),![ppt15](https://assets.leetcode-cn.com/solution-static/150/p15.png)>\n\n```Java [sol1-Java]\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Deque<Integer> stack = new LinkedList<Integer>();\n        int n = tokens.length;\n        for (int i = 0; i < n; i++) {\n            String token = tokens[i];\n            if (isNumber(token)) {\n                stack.push(Integer.parseInt(token));\n            } else {\n                int num2 = stack.pop();\n                int num1 = stack.pop();\n                switch (token) {\n                    case \"+\":\n                        stack.push(num1 + num2);\n                        break;\n                    case \"-\":\n                        stack.push(num1 - num2);\n                        break;\n                    case \"*\":\n                        stack.push(num1 * num2);\n                        break;\n                    case \"/\":\n                        stack.push(num1 / num2);\n                        break;\n                    default:\n                }\n            }\n        }\n        return stack.pop();\n    }\n\n    public boolean isNumber(String token) {\n        return !(\"+\".equals(token) || \"-\".equals(token) || \"*\".equals(token) || \"/\".equals(token));\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar evalRPN = function(tokens) {\n    const stack = [];\n    const n = tokens.length;\n    for (let i = 0; i < n; i++) {\n        const token = tokens[i];\n        if (isNumber(token)) {\n            stack.push(parseInt(token));\n        } else {\n            const num2 = stack.pop();\n            const num1 = stack.pop();\n            if (token === '+') {\n                stack.push(num1 + num2);\n            } else if (token === '-') {\n                stack.push(num1 - num2);\n            } else if (token === '*') {\n                stack.push(num1 * num2);\n            } else if (token === '/') {\n                stack.push(num1 / num2 > 0 ? Math.floor(num1 / num2) : Math.ceil(num1 / num2));\n            }\n        }\n    }\n    return stack.pop();\n};\n\nconst isNumber = (token) => {\n    return !('+' === token || '-' === token || '*' === token || '/' === token );\n}\n```\n\n```go [sol1-Golang]\nfunc evalRPN(tokens []string) int {\n    stack := []int{}\n    for _, token := range tokens {\n        val, err := strconv.Atoi(token)\n        if err == nil {\n            stack = append(stack, val)\n        } else {\n            num1, num2 := stack[len(stack)-2], stack[len(stack)-1]\n            stack = stack[:len(stack)-2]\n            switch token {\n            case \"+\":\n                stack = append(stack, num1+num2)\n            case \"-\":\n                stack = append(stack, num1-num2)\n            case \"*\":\n                stack = append(stack, num1*num2)\n            default:\n                stack = append(stack, num1/num2)\n            }\n        }\n    }\n    return stack[0]\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        op_to_binary_fn = {\n            \"+\": add,\n            \"-\": sub,\n            \"*\": mul,\n            \"/\": lambda x, y: int(x / y),   # éœ€è¦æ³¨æ„ python ä¸­è´Ÿæ•°é™¤æ³•çš„è¡¨ç°ä¸é¢˜ç›®ä¸ä¸€è‡´\n        }\n\n        stack = list()\n        for token in tokens:\n            try:\n                num = int(token)\n            except ValueError:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                num = op_to_binary_fn[token](num1, num2)\n            finally:\n                stack.append(num)\n            \n        return stack[0]\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        stack<int> stk;\n        int n = tokens.size();\n        for (int i = 0; i < n; i++) {\n            string& token = tokens[i];\n            if (isNumber(token)) {\n                stk.push(atoi(token.c_str()));\n            } else {\n                int num2 = stk.top();\n                stk.pop();\n                int num1 = stk.top();\n                stk.pop();\n                switch (token[0]) {\n                    case '+':\n                        stk.push(num1 + num2);\n                        break;\n                    case '-':\n                        stk.push(num1 - num2);\n                        break;\n                    case '*':\n                        stk.push(num1 * num2);\n                        break;\n                    case '/':\n                        stk.push(num1 / num2);\n                        break;\n                }\n            }\n        }\n        return stk.top();\n    }\n\n    bool isNumber(string& token) {\n        return !(token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\");\n    }\n};\n```\n\n```C [sol1-C]\nbool isNumber(char* token) {\n    return strlen(token) > 1 || ('0' <= token[0] && token[0] <= '9');\n}\n\nint evalRPN(char** tokens, int tokensSize) {\n    int n = tokensSize;\n    int stk[n], top = 0;\n    for (int i = 0; i < n; i++) {\n        char* token = tokens[i];\n        if (isNumber(token)) {\n            stk[top++] = atoi(token);\n        } else {\n            int num2 = stk[--top];\n            int num1 = stk[--top];\n            switch (token[0]) {\n                case '+':\n                    stk[top++] = num1 + num2;\n                    break;\n                case '-':\n                    stk[top++] = num1 - num2;\n                    break;\n                case '*':\n                    stk[top++] = num1 * num2;\n                    break;\n                case '/':\n                    stk[top++] = num1 / num2;\n                    break;\n            }\n        }\n    }\n    return stk[top - 1];\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\\textit{tokens}$ çš„é•¿åº¦ã€‚éœ€è¦éå†æ•°ç»„ $\\textit{tokens}$ ä¸€æ¬¡ï¼Œè®¡ç®—é€†æ³¢å…°è¡¨è¾¾å¼çš„å€¼ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\\textit{tokens}$ çš„é•¿åº¦ã€‚ä½¿ç”¨æ ˆå­˜å‚¨è®¡ç®—è¿‡ç¨‹ä¸­çš„æ•°ï¼Œæ ˆå†…å…ƒç´ ä¸ªæ•°ä¸ä¼šè¶…è¿‡é€†æ³¢å…°è¡¨è¾¾å¼çš„é•¿åº¦ã€‚\n\n#### æ–¹æ³•äºŒï¼šæ•°ç»„æ¨¡æ‹Ÿæ ˆ\n\næ–¹æ³•ä¸€ä½¿ç”¨æ ˆå­˜å‚¨æ“ä½œæ•°ã€‚ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ¨¡æ‹Ÿæ ˆæ“ä½œã€‚\n\nå¦‚æœä½¿ç”¨æ•°ç»„ä»£æ›¿æ ˆï¼Œåˆ™éœ€è¦é¢„å…ˆå®šä¹‰æ•°ç»„çš„é•¿åº¦ã€‚å¯¹äºé•¿åº¦ä¸º $n$ çš„é€†æ³¢å…°è¡¨è¾¾å¼ï¼Œæ˜¾ç„¶æ ˆå†…å…ƒç´ ä¸ªæ•°ä¸ä¼šè¶…è¿‡ $n$ï¼Œä½†æ˜¯å°†æ•°ç»„çš„é•¿åº¦å®šä¹‰ä¸º $n$ ä»ç„¶è¶…è¿‡äº†æ ˆå†…å…ƒç´ ä¸ªæ•°çš„ä¸Šç•Œã€‚é‚£ä¹ˆï¼Œæ ˆå†…å…ƒç´ æœ€å¤šå¯èƒ½æœ‰å¤šå°‘ä¸ªï¼Ÿ\n\nå¯¹äºä¸€ä¸ªæœ‰æ•ˆçš„é€†æ³¢å…°è¡¨è¾¾å¼ï¼Œå…¶é•¿åº¦ $n$ ä¸€å®šæ˜¯å¥‡æ•°ï¼Œä¸”æ“ä½œæ•°çš„ä¸ªæ•°ä¸€å®šæ¯”è¿ç®—ç¬¦çš„ä¸ªæ•°å¤š $1$ ä¸ªï¼Œå³åŒ…å« $\\frac{n+1}{2}$ ä¸ªæ“ä½œæ•°å’Œ $\\frac{n-1}{2}$ ä¸ªè¿ç®—ç¬¦ã€‚è€ƒè™‘é‡åˆ°æ“ä½œæ•°å’Œè¿ç®—ç¬¦æ—¶ï¼Œæ ˆå†…å…ƒç´ ä¸ªæ•°åˆ†åˆ«ä¼šå¦‚ä½•å˜åŒ–ï¼š\n\n- å¦‚æœé‡åˆ°æ“ä½œæ•°ï¼Œåˆ™å°†æ“ä½œæ•°å…¥æ ˆï¼Œå› æ­¤æ ˆå†…å…ƒç´ å¢åŠ  $1$ ä¸ªï¼›\n\n- å¦‚æœé‡åˆ°è¿ç®—ç¬¦ï¼Œåˆ™å°†ä¸¤ä¸ªæ“ä½œæ•°å‡ºæ ˆï¼Œç„¶åå°†ä¸€ä¸ªæ–°æ“ä½œæ•°å…¥æ ˆï¼Œå› æ­¤æ ˆå†…å…ƒç´ å…ˆå‡å°‘ $2$ ä¸ªå†å¢åŠ  $1$ ä¸ªï¼Œç»“æœæ˜¯æ ˆå†…å…ƒç´ å‡å°‘ $1$ ä¸ªã€‚\n\nç”±æ­¤å¯ä»¥å¾—åˆ°æ“ä½œæ•°å’Œè¿ç®—ç¬¦ä¸æ ˆå†…å…ƒç´ ä¸ªæ•°å˜åŒ–çš„å…³ç³»ï¼šé‡åˆ°æ“ä½œæ•°æ—¶ï¼Œæ ˆå†…å…ƒç´ å¢åŠ  $1$ ä¸ªï¼›é‡åˆ°è¿ç®—ç¬¦æ—¶ï¼Œæ ˆå†…å…ƒç´ å‡å°‘ $1$ ä¸ªã€‚\n\næœ€åæƒ…å†µä¸‹ï¼Œ$\\frac{n+1}{2}$ ä¸ªæ“ä½œæ•°éƒ½åœ¨è¡¨è¾¾å¼çš„å‰é¢ï¼Œ$\\frac{n-1}{2}$ ä¸ªè¿ç®—ç¬¦éƒ½åœ¨è¡¨è¾¾å¼çš„åé¢ï¼Œæ­¤æ—¶æ ˆå†…å…ƒç´ æœ€å¤šä¸º $\\frac{n+1}{2}$ ä¸ªã€‚åœ¨å…¶ä½™æƒ…å†µä¸‹ï¼Œæ ˆå†…å…ƒç´ æ€»æ˜¯å°‘äº $\\frac{n+1}{2}$ ä¸ªã€‚å› æ­¤ï¼Œåœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œæ ˆå†…å…ƒç´ æœ€å¤šå¯èƒ½æœ‰ $\\frac{n+1}{2}$ ä¸ªï¼Œå°†æ•°ç»„çš„é•¿åº¦å®šä¹‰ä¸º $\\frac{n+1}{2}$ å³å¯ã€‚\n\nå…·ä½“å®ç°æ–¹é¢ï¼Œåˆ›å»ºæ•°ç»„ $\\textit{stack}$ æ¨¡æ‹Ÿæ ˆï¼Œæ•°ç»„ä¸‹æ ‡ $0$ çš„ä½ç½®å¯¹åº”æ ˆåº•ï¼Œå®šä¹‰ $\\textit{index}$ è¡¨ç¤ºæ ˆé¡¶å…ƒç´ çš„ä¸‹æ ‡ä½ç½®ï¼Œåˆå§‹æ—¶æ ˆä¸ºç©ºï¼Œ$\\textit{index}=-1$ã€‚å½“é‡åˆ°æ“ä½œæ•°å’Œè¿ç®—ç¬¦æ—¶ï¼Œè¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š\n\n- å¦‚æœé‡åˆ°æ“ä½œæ•°ï¼Œåˆ™å°† $\\textit{index}$ çš„å€¼åŠ  $1$ï¼Œç„¶åå°†æ“ä½œæ•°èµ‹ç»™ $\\textit{stack}[\\textit{index}]$ï¼›\n\n- å¦‚æœé‡åˆ°è¿ç®—ç¬¦ï¼Œåˆ™å°† $\\textit{index}$ çš„å€¼å‡ $1$ï¼Œæ­¤æ—¶ $\\textit{stack}[\\textit{index}]$ å’Œ $\\textit{stack}[\\textit{index}+1]$ çš„å…ƒç´ åˆ†åˆ«æ˜¯å·¦æ“ä½œæ•°å’Œå³æ“ä½œæ•°ï¼Œä½¿ç”¨è¿ç®—ç¬¦å¯¹ä¸¤ä¸ªæ“ä½œæ•°è¿›è¡Œè¿ç®—ï¼Œå°†è¿ç®—å¾—åˆ°çš„æ–°æ“ä½œæ•°èµ‹ç»™ $\\textit{stack}[\\textit{index}]$ã€‚\n\næ•´ä¸ªé€†æ³¢å…°è¡¨è¾¾å¼éå†å®Œæ¯•ä¹‹åï¼Œæ ˆå†…åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œå› æ­¤ $\\textit{index}=0$ï¼Œæ­¤æ—¶ $\\textit{stack}[\\textit{index}]$ å³ä¸ºé€†æ³¢å…°è¡¨è¾¾å¼çš„å€¼ã€‚\n\n<![ppt1](https://assets.leetcode-cn.com/solution-static/150/1.png),![ppt2](https://assets.leetcode-cn.com/solution-static/150/2.png),![ppt3](https://assets.leetcode-cn.com/solution-static/150/3.png),![ppt4](https://assets.leetcode-cn.com/solution-static/150/4.png),![ppt5](https://assets.leetcode-cn.com/solution-static/150/5.png),![ppt6](https://assets.leetcode-cn.com/solution-static/150/6.png),![ppt7](https://assets.leetcode-cn.com/solution-static/150/7.png),![ppt8](https://assets.leetcode-cn.com/solution-static/150/8.png),![ppt9](https://assets.leetcode-cn.com/solution-static/150/9.png),![ppt10](https://assets.leetcode-cn.com/solution-static/150/10.png),![ppt11](https://assets.leetcode-cn.com/solution-static/150/11.png),![ppt12](https://assets.leetcode-cn.com/solution-static/150/12.png),![ppt13](https://assets.leetcode-cn.com/solution-static/150/13.png),![ppt14](https://assets.leetcode-cn.com/solution-static/150/14.png),![ppt15](https://assets.leetcode-cn.com/solution-static/150/15.png)>\n\n```Java [sol2-Java]\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        int n = tokens.length;\n        int[] stack = new int[(n + 1) / 2];\n        int index = -1;\n        for (int i = 0; i < n; i++) {\n            String token = tokens[i];\n            switch (token) {\n                case \"+\":\n                    index--;\n                    stack[index] += stack[index + 1];\n                    break;\n                case \"-\":\n                    index--;\n                    stack[index] -= stack[index + 1];\n                    break;\n                case \"*\":\n                    index--;\n                    stack[index] *= stack[index + 1];\n                    break;\n                case \"/\":\n                    index--;\n                    stack[index] /= stack[index + 1];\n                    break;\n                default:\n                    index++;\n                    stack[index] = Integer.parseInt(token);\n            }\n        }\n        return stack[index];\n    }\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar evalRPN = function(tokens) {\n    const n = tokens.length;\n    const stack = new Array(Math.floor((n + 1) / 2)).fill(0);\n    let index = -1;\n    for (let i = 0; i < n; i++) {\n        const token = tokens[i];\n        if (token === '+') {\n            index--;\n            stack[index] += stack[index + 1];\n        } else if (token === '-') {\n            index--;\n            stack[index] -= stack[index + 1];\n        } else if (token === '*') {\n            index--;\n            stack[index] *= stack[index + 1];\n        } else if (token === '/') {\n            index--;\n            stack[index] = stack[index] / stack[index + 1] > 0 ? Math.floor(stack[index] / stack[index + 1]) : Math.ceil(stack[index] / stack[index + 1]);\n        } else {\n            index++;\n            stack[index] = parseInt(token);\n        }\n    }\n    return stack[index];\n}; \n```\n\n```go [sol2-Golang]\nfunc evalRPN(tokens []string) int {\n    stack := make([]int, (len(tokens)+1)/2)\n    index := -1\n    for _, token := range tokens {\n        val, err := strconv.Atoi(token)\n        if err == nil {\n            index++\n            stack[index] = val\n        } else {\n            index--\n            switch token {\n            case \"+\":\n                stack[index] += stack[index+1]\n            case \"-\":\n                stack[index] -= stack[index+1]\n            case \"*\":\n                stack[index] *= stack[index+1]\n            default:\n                stack[index] /= stack[index+1]\n            }\n        }\n    }\n    return stack[0]\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        op_to_binary_fn = {\n            \"+\": add,\n            \"-\": sub,\n            \"*\": mul,\n            \"/\": lambda x, y: int(x / y),   # éœ€è¦æ³¨æ„ python ä¸­è´Ÿæ•°é™¤æ³•çš„è¡¨ç°ä¸é¢˜ç›®ä¸ä¸€è‡´\n        }\n\n        n = len(tokens)\n        stack = [0] * ((n + 1) // 2)\n        index = -1\n        for token in tokens:\n            try:\n                num = int(token)\n                index += 1\n                stack[index] = num\n            except ValueError:\n                index -= 1\n                stack[index] = op_to_binary_fn[token](stack[index], stack[index + 1])\n            \n        return stack[0]\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        int n = tokens.size();\n        vector<int> stk((n + 1) / 2);\n        int index = -1;\n        for (int i = 0; i < n; i++) {\n            string& token = tokens[i];\n            if (token.length() > 1 || isdigit(token[0])) {\n                index++;\n                stk[index] = atoi(token.c_str());\n            } else {\n                switch (token[0]) {\n                    case '+':\n                        index--;\n                        stk[index] += stk[index + 1];\n                        break;\n                    case '-':\n                        index--;\n                        stk[index] -= stk[index + 1];\n                        break;\n                    case '*':\n                        index--;\n                        stk[index] *= stk[index + 1];\n                        break;\n                    case '/':\n                        index--;\n                        stk[index] /= stk[index + 1];\n                        break;\n                }\n            }\n        }\n        return stk[index];\n    }\n};\n```\n\n```C [sol2-C]\nint evalRPN(char** tokens, int tokensSize) {\n    int n = tokensSize;\n    int stk[(n + 1) / 2];\n    memset(stk, 0, sizeof(stk));\n    int index = -1;\n    for (int i = 0; i < n; i++) {\n        char* token = tokens[i];\n        if (strlen(token) > 1 || isdigit(token[0])) {\n            index++;\n            stk[index] = atoi(token);\n        } else {\n            switch (token[0]) {\n                case '+':\n                    index--;\n                    stk[index] += stk[index + 1];\n                    break;\n                case '-':\n                    index--;\n                    stk[index] -= stk[index + 1];\n                    break;\n                case '*':\n                    index--;\n                    stk[index] *= stk[index + 1];\n                    break;\n                case '/':\n                    index--;\n                    stk[index] /= stk[index + 1];\n                    break;\n            }\n        }\n    }\n    return stk[index];\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\\textit{tokens}$ çš„é•¿åº¦ã€‚éœ€è¦éå†æ•°ç»„ $\\textit{tokens}$ ä¸€æ¬¡ï¼Œè®¡ç®—é€†æ³¢å…°è¡¨è¾¾å¼çš„å€¼ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\\textit{tokens}$ çš„é•¿åº¦ã€‚éœ€è¦åˆ›å»ºé•¿åº¦ä¸º $\\frac{n+1}{2}$ çš„æ•°ç»„æ¨¡æ‹Ÿæ ˆæ“ä½œã€‚"
}