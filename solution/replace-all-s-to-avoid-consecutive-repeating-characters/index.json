{
	"titleSlug": "replace-all-s-to-avoid-consecutive-repeating-characters",
	"slug": "ti-huan-suo-you-de-wen-hao-by-leetcode-s-f7mp",
	"url": "https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/solution/ti-huan-suo-you-de-wen-hao-by-leetcode-s-f7mp/",
	"content": "#### 方法一：遍历扫描\n\n题目要求将字符串 $s$ 中的 $\\texttt{`?'}$ 转换为若干小写字母，转换后的字母与该字母的前后字母均不相同。遍历字符串 $s$，如果遇到第 $i$ 个字符 $s[i]$ 为 $\\texttt{`?'}$ 时，此时直接在英文字母 $\\texttt{`a'-`z'}$ 中找到一个与 $s[i-1]$ 和 $s[i+1]$ 均不相同的字母进行替换即可。\n\n在替换时，实际不需要遍历所有的小写字母，只需要遍历三个互不相同的字母，就能保证一定找到一个与前后字符均不相同的字母，在此我们可以限定三个不同的字母为 $\\texttt{(`a',`b',`c')}$。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public String modifyString(String s) {\n        int n = s.length();\n        char[] arr = s.toCharArray();\n        for (int i = 0; i < n; ++i) {\n            if (arr[i] == '?') {\n                for (char ch = 'a'; ch <= 'c'; ++ch) {\n                    if ((i > 0 && arr[i - 1] == ch) || (i < n - 1 && arr[i + 1] == ch)) {\n                        continue;\n                    }\n                    arr[i] = ch;\n                    break;\n                }\n            }\n        }\n        return new String(arr);\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string modifyString(string s) {\n        int n = s.size();\n        for (int i = 0; i < n; ++i) {\n            if (s[i] == '?') {\n                for (char ch = 'a'; ch <= 'c'; ++ch) {\n                    if ((i > 0 && s[i - 1] == ch) || (i < n - 1 && s[i + 1] == ch)) {\n                        continue;\n                    }\n                    s[i] = ch;\n                    break;\n                }\n            }\n        }\n        return s;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string ModifyString(string s) {\n        int n = s.Length;\n        char[] arr = s.ToCharArray();\n        for (int i = 0; i < n; ++i) {\n            if (arr[i] == '?') {\n                for (char ch = 'a'; ch <= 'c'; ++ch) {\n                    if ((i > 0 && arr[i - 1] == ch) || (i < n - 1 && arr[i + 1] == ch)) {\n                        continue;\n                    }\n                    arr[i] = ch;\n                    break;\n                }\n            }\n        }\n        return new String(arr);\n    }\n}\n```\n\n```C [sol1-C]\nchar * modifyString(char * s) {\n    int n = strlen(s);\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '?') {\n            for (char ch = 'a'; ch <= 'c'; ++ch) {\n                if ((i > 0 && s[i - 1] == ch) || (i < n - 1 && s[i + 1] == ch)) {\n                    continue;\n                }\n                s[i] = ch;\n                break;\n            }\n        }\n    }\n    return s;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar modifyString = function(s) {\n    const n = s.length;\n    const arr = [...s];\n    for (let i = 0; i < n; ++i) {\n        if (arr[i] === '?') {\n            for (let j = 0; j < 3; ++j) {\n                if ((i > 0 && arr[i - 1] === String.fromCharCode('a'.charCodeAt() + j)) || (i < n - 1 && arr[i + 1] === String.fromCharCode('a'.charCodeAt() + j))) {\n                    continue;\n                }\n                arr[i] = String.fromCharCode('a'.charCodeAt() + j);\n                break;\n            }\n        }\n    }\n    return arr.join('');\n};\n```\n\n```go [sol1-Golang]\nfunc modifyString(s string) string {\n    res := []byte(s)\n    n := len(res)\n    for i, ch := range res {\n        if ch == '?' {\n            for b := byte('a'); b <= 'c'; b++ {\n                if !(i > 0 && res[i-1] == b || i < n-1 && res[i+1] == b) {\n                    res[i] = b\n                    break\n                }\n            }\n        }\n    }\n    return string(res)\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def modifyString(self, s: str) -> str:\n        res = list(s)\n        n = len(res)\n        for i in range(n):\n            if res[i] == '?':\n                for b in \"abc\":\n                    if not (i > 0 and res[i - 1] == b or i < n - 1 and res[i + 1] == b):\n                        res[i] = b\n                        break\n        return ''.join(res)\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(C \\times n)$，其中 $n$ 是字符串的长度，我们需要遍历一遍字符串，$C$ 表示可替代字符的数量，在本题中 $C=3$。\n\n- 空间复杂度：$O(1)$。除了函数返回值以外我们不需要再申请额外的空间。"
}