{
	"titleSlug": "shortest-distance-to-a-character",
	"slug": "zi-fu-de-zui-duan-ju-chi-by-leetcode-sol-2t49",
	"url": "https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode-sol-2t49/",
	"content": "#### 方法一：两次遍历\n\n问题可以转换成，对 $s$ 的每个下标 $i$，求\n\n- $s[i]$ 到其左侧最近的字符 $c$ 的距离\n- $s[i]$ 到其右侧最近的字符 $c$ 的距离\n\n这两者的最小值。\n\n对于前者，我们可以从左往右遍历 $s$，若 $s[i]=c$ 则记录下此时字符 $c$ 的的下标 $\\textit{idx}$。遍历的同时更新 $\\textit{answer}[i]=i-\\textit{idx}$。\n\n对于后者，我们可以从右往左遍历 $s$，若 $s[i]=c$ 则记录下此时字符 $c$ 的的下标 $\\textit{idx}$。遍历的同时更新 $\\textit{answer}[i]=\\min(\\textit{answer}[i],\\textit{idx}-i)$。\n\n代码实现时，在开始遍历的时候 $\\textit{idx}$ 可能不存在，为了简化逻辑，我们可以用 $-n$ 或 $2n$ 表示，这里 $n$ 是 $s$ 的长度。\n\n```Python [sol1-Python3]\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx - i)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> ans(n);\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = min(ans[i], idx - i);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = Math.min(ans[i], idx - i);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] ShortestToChar(string s, char c) {\n        int n = s.Length;\n        int[] ans = new int[n];\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = Math.Min(ans[i], idx - i);\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc shortestToChar(s string, c byte) []int {\n    n := len(s)\n    ans := make([]int, n)\n\n    idx := -n\n    for i, ch := range s {\n        if byte(ch) == c {\n            idx = i\n        }\n        ans[i] = i - idx\n    }\n\n    idx = n * 2\n    for i := n - 1; i >= 0; i-- {\n        if s[i] == c {\n            idx = i\n        }\n        ans[i] = min(ans[i], idx-i)\n    }\n    return ans\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar shortestToChar = function(s, c) {\n    const n = s.length;\n    const ans = new Array(n).fill(0);\n\n    for (let i = 0, idx = -n; i < n; ++i) {\n        if (s[i] === c) {\n            idx = i;\n        }\n        ans[i] = i - idx;\n    }\n\n    for (let i = n - 1, idx = 2 * n; i >= 0; --i) {\n        if (s[i] == c) {\n            idx = i;\n        }\n        ans[i] = Math.min(ans[i], idx - i);\n    }\n    return ans;\n};\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint* shortestToChar(char * s, char c, int* returnSize){\n    int n = strlen(s);\n    int *ans = (int *)malloc(sizeof(int) * n);\n\n    for (int i = 0, idx = -n; i < n; ++i) {\n        if (s[i] == c) {\n            idx = i;\n        }\n        ans[i] = i - idx;\n    }\n\n    for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n        if (s[i] == c) {\n            idx = i;\n        }\n        ans[i] = MIN(ans[i], idx - i);\n    }\n    *returnSize = n;\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。\n\n- 空间复杂度：$O(1)$。返回值不计入空间复杂度。"
}