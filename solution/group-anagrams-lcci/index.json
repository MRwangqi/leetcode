{
	"titleSlug": "group-anagrams-lcci",
	"slug": "bian-wei-ci-zu-by-leetcode-solution-g2a8",
	"url": "https://leetcode-cn.com/problems/group-anagrams-lcci/solution/bian-wei-ci-zu-by-leetcode-solution-g2a8/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![...å‘˜é¢è¯•é‡‘å…¸ 10-02-å˜ä½è¯ç»„.mp4](5606bdd7-7c90-407d-9129-15a9241872a2)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### å‰è¨€\n\nä¸¤ä¸ªå­—ç¬¦ä¸²äº’ä¸ºå˜ä½è¯ï¼Œå½“ä¸”ä»…å½“ä¸¤ä¸ªå­—ç¬¦ä¸²åŒ…å«çš„å­—æ¯ç›¸åŒã€‚åŒä¸€ç»„å˜ä½è¯ä¸­çš„å­—ç¬¦ä¸²å…·å¤‡ç›¸åŒç‚¹ï¼Œå¯ä»¥ä½¿ç”¨ç›¸åŒç‚¹ä½œä¸ºä¸€ç»„å˜ä½è¯çš„æ ‡å¿—ï¼Œä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ¯ä¸€ç»„å˜ä½è¯ï¼Œå“ˆå¸Œè¡¨çš„é”®ä¸ºä¸€ç»„å˜ä½è¯çš„æ ‡å¿—ï¼Œå“ˆå¸Œè¡¨çš„å€¼ä¸ºä¸€ç»„å˜ä½è¯åˆ—è¡¨ã€‚\n\néå†æ¯ä¸ªå­—ç¬¦ä¸²ï¼Œå¯¹äºæ¯ä¸ªå­—ç¬¦ä¸²ï¼Œå¾—åˆ°è¯¥å­—ç¬¦ä¸²æ‰€åœ¨çš„ä¸€ç»„å˜ä½è¯çš„æ ‡å¿—ï¼Œå°†å½“å‰å­—ç¬¦ä¸²åŠ å…¥è¯¥ç»„å˜ä½è¯çš„åˆ—è¡¨ä¸­ã€‚éå†å…¨éƒ¨å­—ç¬¦ä¸²ä¹‹åï¼Œå“ˆå¸Œè¡¨ä¸­çš„æ¯ä¸ªé”®å€¼å¯¹å³ä¸ºä¸€ç»„å˜ä½è¯ã€‚\n\nä»¥ä¸‹çš„ä¸¤ç§æ–¹æ³•åˆ†åˆ«ä½¿ç”¨æ’åºå’Œè®¡æ•°ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šæ’åº\n\nç”±äºäº’ä¸ºå˜ä½è¯çš„ä¸¤ä¸ªå­—ç¬¦ä¸²åŒ…å«çš„å­—æ¯ç›¸åŒï¼Œå› æ­¤å¯¹ä¸¤ä¸ªå­—ç¬¦ä¸²åˆ†åˆ«è¿›è¡Œæ’åºä¹‹åå¾—åˆ°çš„å­—ç¬¦ä¸²ä¸€å®šæ˜¯ç›¸åŒçš„ï¼Œæ•…å¯ä»¥å°†æ’åºä¹‹åçš„å­—ç¬¦ä¸²ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®ã€‚\n\n```Java [sol1-Java]\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\n        for (String str : strs) {\n            char[] array = str.toCharArray();\n            Arrays.sort(array);\n            String key = new String(array);\n            List<String> list = map.getOrDefault(key, new ArrayList<String>());\n            list.add(str);\n            map.put(key, list);\n        }\n        return new ArrayList<List<String>>(map.values());\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\n        Dictionary<string, IList<string>> dictionary = new Dictionary<string, IList<string>>();\n        foreach (string str in strs) {\n            char[] array = str.ToCharArray();\n            Array.Sort(array);\n            string key = new string(array);\n            if (dictionary.ContainsKey(key)) {\n                dictionary[key].Add(str);\n            } else {\n                IList<string> list = new List<string>{str};\n                dictionary.Add(key, list);\n            }\n        }\n        return new List<IList<string>>(dictionary.Values);\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar groupAnagrams = function(strs) {\n    const map = new Map();\n    for (let str of strs) {\n        let array = Array.from(str);\n        array.sort();\n        let key = array.toString();\n        let list = map.get(key) ? map.get(key) : new Array();\n        list.push(str);\n        map.set(key, list);\n    }\n    return Array.from(map.values());\n};\n```\n\n```Golang [sol1-Golang]\nfunc groupAnagrams(strs []string) [][]string {\n    mp := map[string][]string{}\n    for _, str := range strs {\n        s := []byte(str)\n        sort.Slice(s, func(i, j int) bool { return s[i] < s[j] })\n        sortedStr := string(s)\n        mp[sortedStr] = append(mp[sortedStr], str)\n    }\n    ans := make([][]string, 0, len(mp))\n    for _, v := range mp {\n        ans = append(ans, v)\n    }\n    return ans\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> mp;\n        for (string& str: strs) {\n            string key = str;\n            sort(key.begin(), key.end());\n            mp[key].emplace_back(str);\n        }\n        vector<vector<string>> ans;\n        for (auto it = mp.begin(); it != mp.end(); ++it) {\n            ans.emplace_back(it->second);\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        mp = collections.defaultdict(list)\n\n        for st in strs:\n            key = \"\".join(sorted(st))\n            mp[key].append(st)\n        \n        return list(mp.values())\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(nk \\log k)$ï¼Œå…¶ä¸­ $n$ æ˜¯ $\\textit{strs}$ ä¸­çš„å­—ç¬¦ä¸²çš„æ•°é‡ï¼Œ$k$ æ˜¯ $\\textit{strs}$ ä¸­çš„å­—ç¬¦ä¸²çš„çš„æœ€å¤§é•¿åº¦ã€‚éœ€è¦éå† $n$ ä¸ªå­—ç¬¦ä¸²ï¼Œå¯¹äºæ¯ä¸ªå­—ç¬¦ä¸²ï¼Œéœ€è¦ $O(k \\log k)$ çš„æ—¶é—´è¿›è¡Œæ’åºä»¥åŠ $O(1)$ çš„æ—¶é—´æ›´æ–°å“ˆå¸Œè¡¨ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nk \\log k)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(nk)$ï¼Œå…¶ä¸­ $n$ æ˜¯ $\\textit{strs}$ ä¸­çš„å­—ç¬¦ä¸²çš„æ•°é‡ï¼Œ$k$ æ˜¯ $\\textit{strs}$ ä¸­çš„å­—ç¬¦ä¸²çš„çš„æœ€å¤§é•¿åº¦ã€‚éœ€è¦ç”¨å“ˆå¸Œè¡¨å­˜å‚¨å…¨éƒ¨å­—ç¬¦ä¸²ã€‚\n\n#### æ–¹æ³•äºŒï¼šè®¡æ•°\n\nç”±äºäº’ä¸ºå˜ä½è¯çš„ä¸¤ä¸ªå­—ç¬¦ä¸²åŒ…å«çš„å­—æ¯ç›¸åŒï¼Œå› æ­¤ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­çš„ç›¸åŒå­—æ¯å‡ºç°çš„æ¬¡æ•°ä¸€å®šæ˜¯ç›¸åŒçš„ï¼Œæ•…å¯ä»¥å°†æ¯ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°ä½¿ç”¨å­—ç¬¦ä¸²è¡¨ç¤ºï¼Œä½œä¸ºå“ˆå¸Œè¡¨çš„é”®ã€‚\n\nç”±äºå­—ç¬¦ä¸²åªåŒ…å«å°å†™å­—æ¯ï¼Œå› æ­¤å¯¹äºæ¯ä¸ªå­—ç¬¦ä¸²ï¼Œå¯ä»¥ä½¿ç”¨é•¿åº¦ä¸º $26$ çš„æ•°ç»„è®°å½•æ¯ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ä½¿ç”¨æ•°ç»„ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®æ—¶ï¼Œä¸åŒè¯­è¨€çš„æ”¯æŒç¨‹åº¦ä¸åŒï¼Œå› æ­¤ä¸åŒè¯­è¨€çš„å®ç°æ–¹å¼ä¹Ÿä¸åŒã€‚\n\n```Java [sol2-Java]\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\n        for (String str : strs) {\n            int[] counts = new int[26];\n            int length = str.length();\n            for (int i = 0; i < length; i++) {\n                counts[str.charAt(i) - 'a']++;\n            }\n            // å°†æ¯ä¸ªå‡ºç°æ¬¡æ•°å¤§äº 0 çš„å­—æ¯å’Œå‡ºç°æ¬¡æ•°æŒ‰é¡ºåºæ‹¼æ¥æˆå­—ç¬¦ä¸²ï¼Œä½œä¸ºå“ˆå¸Œè¡¨çš„é”®\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < 26; i++) {\n                if (counts[i] != 0) {\n                    sb.append((char) ('a' + i));\n                    sb.append(counts[i]);\n                }\n            }\n            String key = sb.toString();\n            List<String> list = map.getOrDefault(key, new ArrayList<String>());\n            list.add(str);\n            map.put(key, list);\n        }\n        return new ArrayList<List<String>>(map.values());\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\n        Dictionary<string, IList<string>> dictionary = new Dictionary<string, IList<string>>();\n        foreach (string str in strs) {\n            int[] counts = new int[26];\n            int length = str.Length;\n            for (int i = 0; i < length; i++) {\n                counts[str[i] - 'a']++;\n            }\n            // å°†æ¯ä¸ªå‡ºç°æ¬¡æ•°å¤§äº 0 çš„å­—æ¯å’Œå‡ºç°æ¬¡æ•°æŒ‰é¡ºåºæ‹¼æ¥æˆå­—ç¬¦ä¸²ï¼Œä½œä¸ºå“ˆå¸Œè¡¨çš„é”®\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 26; i++) {\n                if (counts[i] != 0) {\n                    sb.Append((char) ('a' + i));\n                    sb.Append(counts[i]);\n                }\n            }\n            string key = sb.ToString();\n            if (dictionary.ContainsKey(key)) {\n                dictionary[key].Add(str);\n            } else {\n                IList<string> list = new List<string>{str};\n                dictionary.Add(key, list);\n            }\n        }\n        return new List<IList<string>>(dictionary.Values);\n    }\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar groupAnagrams = function(strs) {\n    const map = new Object();\n    for (let s of strs) {\n        const count = new Array(26).fill(0);\n        for (let c of s) {\n            count[c.charCodeAt() - 'a'.charCodeAt()]++;\n        }\n        map[count] ? map[count].push(s) : map[count] = [s];\n    }\n    return Object.values(map);\n};\n```\n\n```Golang [sol2-Golang]\nfunc groupAnagrams(strs []string) [][]string {\n    mp := map[[26]int][]string{}\n    for _, str := range strs {\n        cnt := [26]int{}\n        for _, b := range str {\n            cnt[b-'a']++\n        }\n        mp[cnt] = append(mp[cnt], str)\n    }\n    ans := make([][]string, 0, len(mp))\n    for _, v := range mp {\n        ans = append(ans, v)\n    }\n    return ans\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        // è‡ªå®šä¹‰å¯¹ array<int, 26> ç±»å‹çš„å“ˆå¸Œå‡½æ•°\n        auto arrayHash = [fn = hash<int>{}] (const array<int, 26>& arr) -> size_t {\n            return accumulate(arr.begin(), arr.end(), 0u, [&](size_t acc, int num) {\n                return (acc << 1) ^ fn(num);\n            });\n        };\n\n        unordered_map<array<int, 26>, vector<string>, decltype(arrayHash)> mp(0, arrayHash);\n        for (string& str: strs) {\n            array<int, 26> counts{};\n            int length = str.length();\n            for (int i = 0; i < length; ++i) {\n                counts[str[i] - 'a'] ++;\n            }\n            mp[counts].emplace_back(str);\n        }\n        vector<vector<string>> ans;\n        for (auto it = mp.begin(); it != mp.end(); ++it) {\n            ans.emplace_back(it->second);\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        mp = collections.defaultdict(list)\n\n        for st in strs:\n            counts = [0] * 26\n            for ch in st:\n                counts[ord(ch) - ord(\"a\")] += 1\n            # éœ€è¦å°† list è½¬æ¢æˆ tuple æ‰èƒ½è¿›è¡Œå“ˆå¸Œ\n            mp[tuple(counts)].append(st)\n        \n        return list(mp.values())\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n(k+|\\Sigma|))$ï¼Œå…¶ä¸­ $n$ æ˜¯ $\\textit{strs}$ ä¸­çš„å­—ç¬¦ä¸²çš„æ•°é‡ï¼Œ$k$ æ˜¯ $\\textit{strs}$ ä¸­çš„å­—ç¬¦ä¸²çš„çš„æœ€å¤§é•¿åº¦ï¼Œ$\\Sigma$ æ˜¯å­—ç¬¦é›†ï¼Œåœ¨æœ¬é¢˜ä¸­å­—ç¬¦é›†ä¸ºæ‰€æœ‰å°å†™å­—æ¯ï¼Œ$|\\Sigma|=26$ã€‚éœ€è¦éå† $n$ ä¸ªå­—ç¬¦ä¸²ï¼Œå¯¹äºæ¯ä¸ªå­—ç¬¦ä¸²ï¼Œéœ€è¦ $O(k)$ çš„æ—¶é—´è®¡ç®—æ¯ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°ï¼Œ$O(|\\Sigma|)$ çš„æ—¶é—´ç”Ÿæˆå“ˆå¸Œè¡¨çš„é”®ï¼Œä»¥åŠ $O(1)$ çš„æ—¶é—´æ›´æ–°å“ˆå¸Œè¡¨ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n(k+|\\Sigma|))$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n(k+|\\Sigma|))$ï¼Œå…¶ä¸­ $n$ æ˜¯ $\\textit{strs}$ ä¸­çš„å­—ç¬¦ä¸²çš„æ•°é‡ï¼Œ$k$ æ˜¯ $\\textit{strs}$ ä¸­çš„å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ï¼Œ$\\Sigma$ æ˜¯å­—ç¬¦é›†ï¼Œåœ¨æœ¬é¢˜ä¸­å­—ç¬¦é›†ä¸ºæ‰€æœ‰å°å†™å­—æ¯ï¼Œ$|\\Sigma|=26$ã€‚éœ€è¦ç”¨å“ˆå¸Œè¡¨å­˜å‚¨å…¨éƒ¨å­—ç¬¦ä¸²ï¼Œè€Œè®°å½•æ¯ä¸ªå­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—æ¯å‡ºç°æ¬¡æ•°çš„æ•°ç»„éœ€è¦çš„ç©ºé—´ä¸º $O(|\\Sigma|)$ï¼Œåœ¨æ¸è¿›æ„ä¹‰ä¸‹å°äº $O(n(k+|\\Sigma|))$ï¼Œå¯ä»¥å¿½ç•¥ä¸è®¡ã€‚"
}