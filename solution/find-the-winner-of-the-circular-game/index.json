{
	"titleSlug": "find-the-winner-of-the-circular-game",
	"slug": "zhao-chu-you-xi-de-huo-sheng-zhe-by-leet-w2jd",
	"url": "https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/solution/zhao-chu-you-xi-de-huo-sheng-zhe-by-leet-w2jd/",
	"content": "#### 方法一：模拟 + 队列\n\n最直观的方法是模拟游戏过程。使用队列存储圈子中的小伙伴编号，初始时将 $1$ 到 $n$ 的所有编号依次加入队列，队首元素即为第 $1$ 名小伙伴的编号。\n\n每一轮游戏中，从当前小伙伴开始数 $k$ 名小伙伴，数到的第 $k$ 名小伙伴离开圈子。模拟游戏过程的做法是，将队首元素取出并将该元素在队尾处重新加入队列，重复该操作 $k - 1$ 次，则在 $k - 1$ 次操作之后，队首元素即为这一轮中数到的第 $k$ 名小伙伴的编号，将队首元素取出，即为数到的第 $k$ 名小伙伴离开圈子。上述操作之后，新的队首元素即为下一轮游戏的起始小伙伴的编号。\n\n每一轮游戏之后，圈子中减少一名小伙伴，队列中减少一个元素。重复上述过程，直到队列中只剩下 $1$ 个元素，该元素即为获胜的小伙伴的编号。\n\n```Python [sol1-Python3]\nclass Solution:\n    def findTheWinner(self, n: int, k: int) -> int:\n        q = deque(range(1, n + 1))\n        while len(q) > 1:\n            for _ in range(k - 1):\n                q.append(q.popleft())\n            q.popleft()\n        return q[0]\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findTheWinner(int n, int k) {\n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        for (int i = 1; i <= n; i++) {\n            queue.offer(i);\n        }\n        while (queue.size() > 1) {\n            for (int i = 1; i < k; i++) {\n                queue.offer(queue.poll());\n            }\n            queue.poll();\n        }\n        return queue.peek();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindTheWinner(int n, int k) {\n        Queue<int> queue = new Queue<int>();\n        for (int i = 1; i <= n; i++) {\n            queue.Enqueue(i);\n        }\n        while (queue.Count > 1) {\n            for (int i = 1; i < k; i++) {\n                queue.Enqueue(queue.Dequeue());\n            }\n            queue.Dequeue();\n        }\n        return queue.Peek();\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        queue<int> qu;\n        for (int i = 1; i <= n; i++) {\n            qu.emplace(i);\n        }\n        while (qu.size() > 1) {\n            for (int i = 1; i < k; i++) {\n                qu.emplace(qu.front());\n                qu.pop();\n            }\n            qu.pop();\n        }\n        return qu.front();\n    }\n};\n```\n\n```C [sol1-C]\nint findTheWinner(int n, int k){\n    struct ListNode * head = NULL;\n    struct ListNode * tail = NULL;\n    for (int i = 1; i <= n; i++) {\n        struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = i;\n        node->next = NULL;\n        if (!head) {\n            head = node;\n            tail = node;\n        } else {\n            tail->next = node;\n            tail = tail->next;\n        }\n    }\n    while (head != tail) {\n        for (int i = 1; i < k; i++) {\n            struct ListNode * node = head;\n            head = head->next;\n            tail->next = node;\n            tail = tail->next;\n            tail->next = NULL;\n        }\n        struct ListNode * node = head;\n        head = head->next;\n        free(node);\n    }\n    int res = head->val;\n    free(head);\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findTheWinner = function(n, k) {\n    const queue = [];\n    for (let i = 1; i <= n; i++) {\n        queue.push(i);\n    }\n    while (queue.length > 1) {\n        for (let i = 1; i < k; i++) {\n            queue.push(queue.shift());\n        }\n        queue.shift();\n    }\n    return queue[0];\n};\n```\n\n```go [sol1-Golang]\nfunc findTheWinner(n, k int) int {\n    q := make([]int, n)\n    for i := range q {\n        q[i] = i + 1\n    }\n    for len(q) > 1 {\n        for i := 1; i < k; i++ {\n            q = append(q, q[0])[1:]\n        }\n        q = q[1:]\n    }\n    return q[0]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(nk)$，其中 $n$ 是做游戏的小伙伴数量，$k$ 是每一轮离开圈子的小伙伴的计数。初始时需要将 $n$ 个元素加入队列，每一轮需要将 $k$ 个元素从队列中取出，将 $k - 1$ 个元素加入队列，一共有 $n - 1$ 轮，因此时间复杂度是 $O(nk)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是做游戏的小伙伴数量。空间复杂度主要取决于队列，队列中最多有 $n$ 个元素。\n\n#### 方法二：数学 + 递归\n\n以下用 $f(n, k)$ 表示 $n$ 名小伙伴做游戏，每一轮离开圈子的小伙伴的计数为 $k$ 时的获胜者编号。\n\n当 $n = 1$ 时，圈子中只有一名小伙伴，该小伙伴即为获胜者，因此 $f(1, k) = 1$。\n\n当 $n > 1$ 时，将有一名小伙伴离开圈子，圈子中剩下 $n - 1$ 名小伙伴。圈子中的第 $k'$ 名小伙伴离开圈子，$k'$ 满足 $1 \\le k' \\le n$ 且 $k - k'$ 是 $n$ 的倍数。\n\n由于 $1 \\le k' \\le n$，因此 $0 \\le k' - 1 \\le n - 1$。又由于 $k - k'$ 是 $n$ 的倍数等价于 $(k - 1) - (k' - 1)$ 是 $n$ 的倍数，因此 $k' - 1 = (k - 1) \\bmod n$，$k' = (k - 1) \\bmod n + 1$。\n\n当圈子中剩下 $n - 1$ 名小伙伴时，可以递归地计算 $f(n - 1, k)$，得到剩下的 $n - 1$ 名小伙伴中的获胜者。令 $x = f(n - 1, k)$。\n\n由于在第 $k'$ 名小伙伴离开圈子之后，圈子中剩下的 $n - 1$ 名小伙伴从第 $k' + 1$ 名小伙伴开始计数，获胜者编号是从第 $k' + 1$ 名小伙伴开始的第 $x$ 名小伙伴，因此当圈子中有 $n$ 名小伙伴时，获胜者编号是 $f(n, k) = (k' \\bmod n + x - 1) \\bmod n + 1 = (k + x - 1) \\bmod n + 1$。\n\n将 $x = f(n - 1, k)$ 代入上述关系，可得：$f(n, k) = (k + f(n - 1, k) - 1) \\bmod n + 1$。\n\n```Python [sol2-Python3]\nclass Solution:\n    def findTheWinner(self, n: int, k: int) -> int:\n        return 1 if n == 1 else (k + self.findTheWinner(n - 1, k) - 1) % n + 1\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int findTheWinner(int n, int k) {\n        if (n == 1) {\n            return 1;\n        }\n        return (k + findTheWinner(n - 1, k) - 1) % n + 1;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int FindTheWinner(int n, int k) {\n        if (n == 1) {\n            return 1;\n        }\n        return (k + FindTheWinner(n - 1, k) - 1) % n + 1;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        if (n == 1) {\n            return 1;\n        }\n        return (k + findTheWinner(n - 1, k) - 1) % n + 1;\n    }\n};\n```\n\n```C [sol2-C]\nint findTheWinner(int n, int k){\n    if (n == 1) {\n        return 1;\n    }\n    return (k + findTheWinner(n - 1, k) - 1) % n + 1;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar findTheWinner = function(n, k) {\n    if (n === 1) {\n        return 1;\n    }\n    return (k + findTheWinner(n - 1, k) - 1) % n + 1;\n};\n```\n\n```go [sol2-Golang]\nfunc findTheWinner(n, k int) int {\n    if n == 1 {\n        return 1\n    }\n    return (k+findTheWinner(n-1, k)-1)%n + 1\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是做游戏的小伙伴数量。需要计算的值有 $n$ 个，每个值的计算时间都是 $O(1)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是做游戏的小伙伴数量。空间复杂度主要取决于递归调用栈的深度，为 $O(n)$ 层。\n\n#### 方法三：数学 + 迭代\n\n方法二的递归实现可以改成迭代实现，省略递归调用栈空间。\n\n```Python [sol3-Python3]\nclass Solution:\n    def findTheWinner(self, n: int, k: int) -> int:\n        winner = 1\n        for i in range(2, n + 1):\n            winner = (k + winner - 1) % i + 1\n        return winner\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int findTheWinner(int n, int k) {\n        int winner = 1;\n        for (int i = 2; i <= n; i++) {\n            winner = (k + winner - 1) % i + 1;\n        }\n        return winner;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int FindTheWinner(int n, int k) {\n        int winner = 1;\n        for (int i = 2; i <= n; i++) {\n            winner = (k + winner - 1) % i + 1;\n        }\n        return winner;\n    }\n}\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        int winner = 1;\n        for (int i = 2; i <= n; i++) {\n            winner = (k + winner - 1) % i + 1;\n        }\n        return winner;\n    }\n};\n```\n\n```C [sol3-C]\nint findTheWinner(int n, int k){\n    int winner = 1;\n    for (int i = 2; i <= n; i++) {\n        winner = (k + winner - 1) % i + 1;\n    }\n    return winner;\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar findTheWinner = function(n, k) {\n    let winner = 1;\n    for (let i = 2; i <= n; i++) {\n        winner = (k + winner - 1) % i + 1;\n    }\n    return winner;\n};\n```\n\n```go [sol3-Golang]\nfunc findTheWinner(n, k int) int {\n    winner := 1\n    for i := 2; i <= n; i++ {\n        winner = (k+winner-1)%i + 1\n    }\n    return winner\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是做游戏的小伙伴数量。需要 $O(n)$ 的时间遍历并计算结果。\n\n- 空间复杂度：$O(1)$。"
}