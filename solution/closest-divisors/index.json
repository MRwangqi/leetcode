{
	"titleSlug": "closest-divisors",
	"slug": "zui-jie-jin-de-yin-shu-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/closest-divisors/solution/zui-jie-jin-de-yin-shu-by-leetcode-solution/",
	"content": "#### 方法一：暴力遍历因数[超出时间限制]\n\n对于想要分解的数字，暴力遍历所有比它小的数字，尝试分解。\n\n```python []\nclass Solution:\n    def divide(self, n):\n        ans = [0, int(1e9)]\n        for i in range(1, n + 1):\n            if n % i == 0:\n                if abs(n // i - i) < abs(ans[0] - ans[1]):\n                    ans = [n // i, i]\n        return ans\n\n    def closestDivisors(self, num: int) -> List[int]:\n        ans = [0, int(1e9)]\n        for i in range(num + 1, num + 3):\n            cur = self.divide(i)\n            if abs(cur[0] - cur[1]) < abs(ans[0] - ans[1]):\n                ans = cur\n        return ans\n```\n\n```C++ []\nclass Solution {\n    vector<int> ans{};\npublic:\n    void divide(int n) {\n        for (int i = 1; i != n + 1; ++i)\n            if (n % i == 0)\n                if (abs(n / i - i) < abs(ans[0] - ans[1])) {\n                    ans[0] = n / i;\n                    ans[1] = i;\n                }\n    }\n    vector<int> closestDivisors(int num) {\n        ans.push_back(0);\n        ans.push_back(1e9);\n        divide(num + 1);\n        divide(num + 2);\n        return ans;\n    }\n};\n```\n\n##### 复杂度分析\n\n  * 时间复杂度：$O(n)$\n  * 空间复杂度：$O(1)$\n\n#### 方法二：以平方根为起点遍历因数\n\n观察问题性质可知，对任意一个在 $[\\sqrt n, n]$ 范围内的因数，一定有一个与其对称的在 $[1, \\sqrt n]$ 范围内的因数。因此，遍历因数只需要遍历 $[1, \\sqrt n]$ 范围即可。\n另外，当 $[1, \\sqrt n]$ 范围内的因数最大时，与其对称的 $[\\sqrt n, n]$ 范围内的因数也最小，此时这两个数字之间的差值一定是所有可能性中最小的。因此，我们只需要找到 $[1, \\sqrt n]$ 中的最大因数即可停止。\n\n```python []\nclass Solution:\n    def divide(self, n):\n        for i in range(int(math.sqrt(n)), 0, -1):\n            if n % i == 0:\n                return [i, n // i]\n\n    def closestDivisors(self, num: int) -> List[int]:\n        ans = [0, int(1e9)]\n        for i in range(num + 1, num + 3):\n            cur = self.divide(i)\n            if abs(cur[0] - cur[1]) < abs(ans[0] - ans[1]):\n                ans = cur\n        return ans\n```\n\n```C++ []\nclass Solution {\n    vector<int> ans{};\npublic:\n    void divide(int n) {\n        for (int i = int(sqrt(n)); i != 0; --i)\n            if (n % i == 0)\n                if (abs(n / i - i) < abs(ans[0] - ans[1])) {\n                    ans[0] = n / i;\n                    ans[1] = i;\n                }\n    }\n    vector<int> closestDivisors(int num) {\n        ans.push_back(0);\n        ans.push_back(1e9);\n        divide(num + 1);\n        divide(num + 2);\n        return ans;\n    }\n};\n```\n\n##### 复杂度分析\n\n  * 时间复杂度：$O(\\sqrt n)$\n  * 空间复杂度：$O(1)$"
}