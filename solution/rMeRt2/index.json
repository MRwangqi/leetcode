{
	"titleSlug": "rMeRt2",
	"slug": "z-by-endlesscheng-6ver",
	"url": "https://leetcode-cn.com/problems/rMeRt2/solution/z-by-endlesscheng-6ver/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1rT411P7NA) 已出炉，欢迎点赞三连，在评论区分享你对这场力扣杯的看法~\r\n\r\n记录关键思路，详细的说明见视频讲解。\r\n\r\n1. 用位运算表示字母选择情况，由于一个字母可以选多个，因此要对二进制「分区」，每个区域表示对应字母的个数。\r\n2. 写一个记忆化搜索，$f(i,\\textit{mask})$ 表示从第 $i$ 个单词开始选，已经选择的单词为 $\\textit{mask}$ 时，后续消耗代币的最小值。枚举 $\\textit{words}[i]$ 的所有合法选择方案转移到 $f(i+1,\\textit{mask}')$。\r\n3. 因此需要预处理每个 $\\textit{words}[i]$ 的每种选择字母的方案所消耗的代币的最小值，由于字符串很短，直接写个爆搜即可。\r\n\r\n```py [sol1-Python3]\r\n# (字母在二进制上的起始位置, 这个字母能选择的上限, 位掩码)\r\nRULES = {\r\n    'e': (0, 4, 7),\r\n    'l': (3, 3, 3),\r\n    'o': (5, 2, 3),\r\n    'h': (7, 1, 1),\r\n    't': (8, 1, 1),\r\n    'c': (9, 1, 1),\r\n    'd': (10, 1, 1),\r\n}\r\nFULL = 2012  # 0b11111011100，每个字母都选到了对应的上限\r\n\r\n# 合并两种选择字母的方案\r\ndef merge(cur: int, add: int) -> int:\r\n    for pos, limit, m in RULES.values():\r\n        c1 = (cur >> pos) & m\r\n        c2 = (add >> pos) & m\r\n        if c1 + c2 > limit: return -1\r\n        cur += c2 << pos\r\n    return cur\r\n\r\nclass Solution:\r\n    def Leetcode(self, words: List[str]) -> int:\r\n        # 预处理每个单词的每种选择字母的方案所消耗的代币的最小值\r\n        costs = []\r\n        for word in words:\r\n            cost = {}\r\n            def dfs(s: str, mask: int, tot: int) -> None:\r\n                if mask not in cost or tot < cost[mask]:\r\n                    cost[mask] = tot\r\n                for i, c in enumerate(s):  # 枚举选择字母的位置\r\n                    if c not in RULES: continue\r\n                    pos, limit, m = RULES[c]\r\n                    if (mask >> pos) & m < limit:  # 可以选字母 c\r\n                        dfs(s[:i] + s[i + 1:], mask + (1 << pos), tot + i * (len(s) - 1 - i))\r\n            dfs(word, 0, 0)\r\n            costs.append(cost)\r\n\r\n        @cache\r\n        def dfs(i: int, mask: int) -> int:\r\n            if i == len(words):\r\n                return 0 if mask == FULL else inf  # inf 表示不合法，没有选完要求的字母\r\n            res = inf\r\n            for add, tot in costs[i].items():\r\n                if tot >= res: continue  # 剪枝\r\n                m = merge(mask, add)\r\n                if m >= 0:\r\n                    res = min(res, tot + dfs(i + 1, m))\r\n            return res\r\n        ans = dfs(0, 0)\r\n        return ans if ans < inf else -1\r\n```\r\n\r\n```go [sol1-Go]\r\nconst keys = \"elohtcd\"\r\nconst full = 2012 // 0b11111011100，每个字母都选到了对应的上限\r\n\r\n// pos：字母在二进制上的起始位置\r\n// limit：这个字母能选择的上限\r\n// mask：位掩码\r\nvar rules = ['z' + 1]struct{ pos, limit, mask int }{\r\n\t'e': {0, 4, 7},\r\n\t'l': {3, 3, 3},\r\n\t'o': {5, 2, 3},\r\n\t'h': {7, 1, 1},\r\n\t't': {8, 1, 1},\r\n\t'c': {9, 1, 1},\r\n\t'd': {10, 1, 1},\r\n}\r\n\r\n// 合并两种选择字母的方案\r\nfunc merge(cur, add int) int {\r\n\tfor _, c := range keys {\r\n\t\tr := rules[c]\r\n\t\tc1 := cur >> r.pos & r.mask\r\n\t\tc2 := add >> r.pos & r.mask\r\n\t\tif c1+c2 > r.limit {\r\n\t\t\treturn -1\r\n\t\t}\r\n\t\tcur += c2 << r.pos\r\n\t}\r\n\treturn cur\r\n}\r\n\r\nfunc Leetcode(words []string) int {\r\n\tconst inf = math.MaxInt32 / 2\r\n\tn := len(words)\r\n\t// 预处理每个单词的每种选择字母的方案所消耗的代币的最小值\r\n\tcosts := make([][1 << 11]int, n)\r\n\tfor i, word := range words {\r\n\t\tfor j := range costs[i] {\r\n\t\t\tcosts[i][j] = inf\r\n\t\t}\r\n\t\tvar f func(string, int, int)\r\n\t\tf = func(s string, mask, tot int) {\r\n\t\t\tcosts[i][mask] = min(costs[i][mask], tot)\r\n\t\t\tfor j, c := range s { // 枚举选择字母的位置\r\n\t\t\t\tr := rules[c]\r\n\t\t\t\tif mask>>r.pos&r.mask < r.limit { // 可以选字母 c\r\n\t\t\t\t\tf(s[:j]+s[j+1:], mask+1<<r.pos, tot+j*(len(s)-1-j))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tf(word, 0, 0)\r\n\t}\r\n\r\n\tdp := make([][1 << 11]int, n)\r\n\tfor i := range dp {\r\n\t\tfor j := range dp[i] {\r\n\t\t\tdp[i][j] = -1\r\n\t\t}\r\n\t}\r\n\tvar f func(int, int) int\r\n\tf = func(i, mask int) int {\r\n\t\tif i == n {\r\n\t\t\tif mask == full {\r\n\t\t\t\treturn 0\r\n\t\t\t}\r\n\t\t\treturn inf // inf 表示不合法，没有选完要求的字母\r\n\t\t}\r\n\t\tptr := &dp[i][mask]\r\n\t\tif *ptr != -1 {\r\n\t\t\treturn *ptr\r\n\t\t}\r\n\t\tres := inf\r\n\t\tfor add, tot := range costs[i][:] {\r\n\t\t\tif tot >= res { // 剪枝\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tm2 := merge(mask, add)\r\n\t\t\tif m2 >= 0 {\r\n\t\t\t\tres = min(res, f(i+1, m2)+tot)\r\n\t\t\t}\r\n\t\t}\r\n\t\t*ptr = res\r\n\t\treturn res\r\n\t}\r\n\tans := f(0, 0)\r\n\tif ans == inf {\r\n\t\treturn -1\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc min(a, b int) int { if b < a { return b }; return a }\r\n```\r\n"
}