{
	"titleSlug": "minimum-genetic-mutation",
	"slug": "zui-xiao-ji-yin-bian-hua-by-leetcode-sol-lhwy",
	"url": "https://leetcode-cn.com/problems/minimum-genetic-mutation/solution/zui-xiao-ji-yin-bian-hua-by-leetcode-sol-lhwy/",
	"content": "#### 方法一：广度优先搜索\n\n**思路与算法**\n\n经过分析可知，题目要求将一个基因序列 $A$ 变化至另一个基因序列 $B$，需要满足一下条件：\n\n+ 序列 $A$ 与 序列 $B$ 之间只有一个字符不同；\n+ 变化字符只能从 $\\texttt{`A', `C', `G', `T'}$ 中进行选择；\n+ 变换后的序列 $B$ 一定要在字符串数组 $\\textit{bank}$ 中。\n\n根据以上变换规则，我们可以进行尝试所有合法的基因变化，并找到最小的变换次数即可。步骤如下：\n\n+ 如果 $\\textit{start}$ 与 $\\textit{end}$ 相等，此时直接返回 $0$；如果最终的基因序列不在 $\\textit{bank}$ 中，则此时按照题意要求，无法生成，直接返回 $-1$；\n\n+ 首先我们将可能变换的基因 $s$ 从队列中取出，按照上述的变换规则，尝试所有可能的变化后的基因，比如一个 $\\texttt{AACCGGTA}$，我们依次尝试改变基因 $s$ 的一个字符，并尝试所有可能的基因变化序列 $s_0, s_1, s_2, \\cdots, s_i, \\cdots, s_{23}$，变化一次最多可能会生成 $3 \\times 8 = 24$ 种不同的基因序列。\n\n+ 我们需要检测当前生成的基因序列的合法性 $s_i$，首先利用哈希表检测 $s_i$ 是否在数组 $\\textit{bank}$ 中，如果是则认为该基因合法，否则改变化非法直接丢弃；其次我们还需要用哈希表记录已经遍历过的基因序列，如果该基因序列已经遍历过，则此时直接跳过；如果合法且未遍历过的基因序列，则我们将其加入到队列中。\n\n+ 如果当前变换后的基因序列与 $\\textit{end}$ 相等，则此时我们直接返回最小的变化次数即可；如果队列中所有的元素都已经遍历完成还无法变成 $\\textit{end}$，则此时无法实现目标变化，返回 $-1$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: List[str]) -> int:\n        if start == end:\n            return 0\n        bank = set(bank)\n        if end not in bank:\n            return -1\n        q = deque([(start, 0)])\n        while q:\n            cur, step = q.popleft()\n            for i, x in enumerate(cur):\n                for y in \"ACGT\":\n                    if y != x:\n                        nxt = cur[:i] + y + cur[i + 1:]\n                        if nxt in bank:\n                            if nxt == end:\n                                return step + 1\n                            bank.remove(nxt)\n                            q.append((nxt, step + 1))\n        return -1\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:    \n    int minMutation(string start, string end, vector<string>& bank) {\n        unordered_set<string> cnt;\n        unordered_set<string> visited;\n        char keys[4] = {'A', 'C', 'G', 'T'};        \n        for (auto & w : bank) {\n            cnt.emplace(w);\n        }\n        if (start == end) {\n            return 0;\n        }\n        if (!cnt.count(end)) {\n            return -1;\n        }\n        queue<string> qu;\n        qu.emplace(start);\n        visited.emplace(start);\n        int step = 1;\n        while (!qu.empty()) {\n            int sz = qu.size();\n            for (int i = 0; i < sz; i++) {\n                string curr = qu.front();\n                qu.pop();\n                for (int j = 0; j < 8; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        if (keys[k] != curr[j]) {\n                            string next = curr;\n                            next[j] = keys[k];\n                            if (!visited.count(next) && cnt.count(next)) {\n                                if (next == end) {\n                                    return step;\n                                }\n                                qu.emplace(next);\n                                visited.emplace(next);\n                            }\n                        }\n                    }\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minMutation(String start, String end, String[] bank) {\n        Set<String> cnt = new HashSet<String>();\n        Set<String> visited = new HashSet<String>();\n        char[] keys = {'A', 'C', 'G', 'T'};        \n        for (String w : bank) {\n            cnt.add(w);\n        }\n        if (start.equals(end)) {\n            return 0;\n        }\n        if (!cnt.contains(end)) {\n            return -1;\n        }\n        Queue<String> queue = new ArrayDeque<String>();\n        queue.offer(start);\n        visited.add(start);\n        int step = 1;\n        while (!queue.isEmpty()) {\n            int sz = queue.size();\n            for (int i = 0; i < sz; i++) {\n                String curr = queue.poll();\n                for (int j = 0; j < 8; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        if (keys[k] != curr.charAt(j)) {\n                            StringBuffer sb = new StringBuffer(curr);\n                            sb.setCharAt(j, keys[k]);\n                            String next = sb.toString();\n                            if (!visited.contains(next) && cnt.contains(next)) {\n                                if (next.equals(end)) {\n                                    return step;\n                                }\n                                queue.offer(next);\n                                visited.add(next);\n                            }\n                        }\n                    }\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinMutation(string start, string end, string[] bank) {\n        ISet<string> cnt = new HashSet<string>();\n        ISet<string> visited = new HashSet<string>();\n        char[] keys = {'A', 'C', 'G', 'T'};        \n        foreach (string w in bank) {\n            cnt.Add(w);\n        }\n        if (start.Equals(end)) {\n            return 0;\n        }\n        if (!cnt.Contains(end)) {\n            return -1;\n        }\n        Queue<string> queue = new Queue<string>();\n        queue.Enqueue(start);\n        visited.Add(start);\n        int step = 1;\n        while (queue.Count > 0) {\n            int sz = queue.Count;\n            for (int i = 0; i < sz; i++) {\n                string curr = queue.Dequeue();\n                for (int j = 0; j < 8; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        if (keys[k] != curr[j]) {\n                            StringBuilder sb = new StringBuilder(curr);\n                            sb.Replace(curr[j], keys[k], j, 1);\n                            string next = sb.ToString();\n                            if (!visited.Contains(next) && cnt.Contains(next)) {\n                                if (next.Equals(end)) {\n                                    return step;\n                                }\n                                queue.Enqueue(next);\n                                visited.Add(next);\n                            }\n                        }\n                    }\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    char key[16];\n    UT_hash_handle hh;\n} HashItem;\n\nbool hashInsert(HashItem ** obj, const char * str) {\n    HashItem * pEntry = (HashItem *)malloc(sizeof(HashItem));\n    strcpy(pEntry->key, str);\n    HASH_ADD_STR(*obj, key, pEntry);\n    return true;\n}\n\nbool hashFind(HashItem ** obj, const char * str) {\n    HashItem * pEntry = NULL;\n    HASH_FIND_STR(*obj, str, pEntry);\n    if (NULL == pEntry) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nvoid hashFree(HashItem ** obj) {\n    HashItem *curr, *tmp;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);\n        free(curr);\n    } \n}\n\nint minMutation(char * start, char * end, char ** bank, int bankSize) {\n    HashItem *cnt = NULL;\n    HashItem *visited = NULL;\n    char keys[4] = {'A', 'C', 'G', 'T'}; \n    if (strcmp(start, end) == 0) {\n        return 0;\n    }       \n    for (int i = 0; i < bankSize; i++) {\n        hashInsert(&cnt, bank[i]);\n    }\n    if (!hashFind(&cnt, end)) {\n        return -1;\n    }\n    char ** queue = (char **)malloc(sizeof(char *) * bankSize);\n    int head = 0;\n    int tail = 0;\n    queue[tail] = (char *)malloc(sizeof(char) * 16);\n    strcpy(queue[tail], start);\n    hashInsert(&visited, start);\n    tail++;\n    int step = 1;\n    while (head != tail) {\n        int sz = tail - head;\n        for (int i = 0; i < sz; i++) {\n            char * curr = queue[head++];\n            for (int j = 0; j < 8; j++) {\n                for (int k = 0; k < 4; k++) {\n                    if (keys[k] != curr[j]) {\n                        char *next = (char *)malloc(sizeof(char) * 16);\n                        strcpy(next, curr);\n                        next[j] = keys[k];\n                        if (!hashFind(&visited, next) && hashFind(&cnt, next)) {\n                            if (strcmp(next, end) == 0) {\n                                while (head != tail) {\n                                    free(queue[head++]);\n                                }\n                                hashFree(&cnt);\n                                hashFree(&visited);\n                                free(queue);\n                                return step;\n                            }\n                            queue[tail++] = next;\n                            hashInsert(&visited, next);\n                        } else {\n                            free(next);\n                        }\n                    }\n                }\n            }\n            free(curr);\n        }\n        step++;\n    }\n    hashFree(&cnt);\n    hashFree(&visited);\n    free(queue);\n    return -1;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minMutation = function(start, end, bank) {\n    const cnt = new Set();\n    const visited = new Set();\n    const keys = ['A', 'C', 'G', 'T'];\n    for (const w of bank) {\n        cnt.add(w);\n    }\n    if (start === end) {\n        return 0;\n    }\n    if (!cnt.has(end)) {\n        return -1;\n    }\n    const queue = [start];\n    visited.add(start);\n    let step = 1;\n    while (queue.length) {\n        const sz = queue.length;\n        for (let i = 0; i < sz; i++) {\n            const curr = queue.shift();\n            for (let j = 0; j < 8; j++) {\n                for (let k = 0; k < 4; k++) {\n                    if (keys[k] !== curr[j]) {\n                        const sb = [...curr];\n                        sb[j] = keys[k];\n                        const next = sb.join('');\n                        if (!visited.has(next) && cnt.has(next)) {\n                            if (next === end) {\n                                return step;\n                            }\n                            queue.push(next);\n                            visited.add(next);\n                        }\n                    }\n                }\n            }\n        }\n        step++;\n    }\n    return -1;\n};\n```\n\n```go [sol1-Golang]\nfunc minMutation(start, end string, bank []string) int {\n    if start == end {\n        return 0\n    }\n    bankSet := map[string]struct{}{}\n    for _, s := range bank {\n        bankSet[s] = struct{}{}\n    }\n    if _, ok := bankSet[end]; !ok {\n        return -1\n    }\n\n    q := []string{start}\n    for step := 0; q != nil; step++ {\n        tmp := q\n        q = nil\n        for _, cur := range tmp {\n            for i, x := range cur {\n                for _, y := range \"ACGT\" {\n                    if y != x {\n                        nxt := cur[:i] + string(y) + cur[i+1:]\n                        if _, ok := bankSet[nxt]; ok {\n                            if nxt == end {\n                                return step + 1\n                            }\n                            delete(bankSet, nxt)\n                            q = append(q, nxt)\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return -1\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(C \\times n \\times m)$，其中 $n$ 为基因序列的长度，$m$ 为数组 $\\textit{bank}$ 的长度。对于队列中的每个合法的基因序列每次都需要计算 $C \\times n$ 种变化，在这里 $C = 4$；队列中最多有 $m$ 个元素，因此时间复杂度为 $O(C \\times n \\times m)$。\n\n- 空间复杂度：$O(n \\times m)$，其中 $n$ 为基因序列的长度，$m$ 为数组 $\\textit{bank}$ 的长度。合法性的哈希表中一共存有 $m$ 个元素，队列中最多有 $m$ 个元素，每个元素的空间为 $O(n)$；队列中最多有 $m$ 个元素，每个元素的空间为 $O(n)$，因此空间复杂度为 $O(n \\times m)$。\n\n#### 方法二：预处理优化\n\n**思路与算法**\n\n经过分析可知，题目要求将一个基因序列 $A$ 变化至另一个基因序列 $B$，需要满足一下条件：\n\n+ 序列 $A$ 与 序列 $B$ 之间只有一个字符不同；\n+ 变化字符只能从 $\\texttt{`A', `C', `G', `T'}$ 中进行选择；\n+ 变换后的序列 $B$ 一定要在字符串数组 $\\textit{bank}$ 中。\n\n已知方法一中广度优先搜索方法，我们可以对 $\\textit{bank}$ 进行预处理，只在合法的基因变化进行搜索即可。由于题目中给定的 $\\textit{bank}$ 基因库的长度较小，因此可以直接在对 $\\textit{bank}$ 进行预处理，找到基因库中的每个基因的合法变换，而不需要像方法一中每次都需要去计算基因的变化序列，我们将每个基因的合法变化关系存储在邻接表 $\\textit{adj}$ 中，每次基因变化搜索只在 $\\textit{adj}$ 中进行即可。\n\n```Python [sol2-Python3]\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: List[str]) -> int:\n        if start == end:\n            return 0\n\n        def diffOne(s: str, t: str) -> bool:\n            return sum(x != y for x, y in zip(s, t)) == 1\n\n        m = len(bank)\n        adj = [[] for _ in range(m)]\n        endIndex = -1\n        for i, s in enumerate(bank):\n            if s == end:\n                endIndex = i\n            for j in range(i + 1, m):\n                if diffOne(s, bank[j]):\n                    adj[i].append(j)\n                    adj[j].append(i)\n        if endIndex == -1:\n            return -1\n\n        q = [i for i, s in enumerate(bank) if diffOne(start, s)]\n        vis = set(q)\n        step = 1\n        while q:\n            tmp = q\n            q = []\n            for cur in tmp:\n                if cur == endIndex:\n                    return step\n                for nxt in adj[cur]:\n                    if nxt not in vis:\n                        vis.add(nxt)\n                        q.append(nxt)\n            step += 1\n        return -1\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int minMutation(string start, string end, vector<string>& bank) {\n        int m = start.size();\n        int n = bank.size();\n        vector<vector<int>> adj(n);\n        int endIndex = -1;\n        for (int i = 0; i < n; i++) {\n            if (end == bank[i]) {\n                endIndex = i;\n            }\n            for (int j = i + 1; j < n; j++) {\n                int mutations = 0;\n                for (int k = 0; k < m; k++) {\n                    if (bank[i][k] != bank[j][k]) {\n                        mutations++;\n                    }\n                    if (mutations > 1) {\n                        break;\n                    }\n                }\n                if (mutations == 1) {\n                    adj[i].emplace_back(j);\n                    adj[j].emplace_back(i);\n                }\n            }\n        }\n        if (endIndex == -1) {\n            return -1;\n        }\n\n        queue<int> qu;\n        vector<bool> visited(n, false);\n        int step = 1;\n        for (int i = 0; i < n; i++) {\n            int mutations = 0;\n            for (int k = 0; k < m; k++) {\n                if (start[k] != bank[i][k]) {\n                    mutations++;\n                }\n                if (mutations > 1) {\n                    break;\n                }\n            }\n            if (mutations == 1) {\n                qu.emplace(i);\n                visited[i] = true;\n            }\n        }        \n        while (!qu.empty()) {\n            int sz = qu.size();\n            for (int i = 0; i < sz; i++) {\n                int curr = qu.front();\n                qu.pop();\n                if (curr == endIndex) {\n                    return step;\n                }\n                for (auto & next : adj[curr]) {\n                    if (visited[next]) {\n                        continue;\n                    }\n                    visited[next] = true;\n                    qu.emplace(next);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int minMutation(String start, String end, String[] bank) {\n        int m = start.length();\n        int n = bank.length;\n        List<Integer>[] adj = new List[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new ArrayList<Integer>();\n        }\n        int endIndex = -1;\n        for (int i = 0; i < n; i++) {\n            if (end.equals(bank[i])) {\n                endIndex = i;\n            }\n            for (int j = i + 1; j < n; j++) {\n                int mutations = 0;\n                for (int k = 0; k < m; k++) {\n                    if (bank[i].charAt(k) != bank[j].charAt(k)) {\n                        mutations++;\n                    }\n                    if (mutations > 1) {\n                        break;\n                    }\n                }\n                if (mutations == 1) {\n                    adj[i].add(j);\n                    adj[j].add(i);\n                }\n            }\n        }\n        if (endIndex == -1) {\n            return -1;\n        }\n\n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        boolean[] visited = new boolean[n];\n        int step = 1;\n        for (int i = 0; i < n; i++) {\n            int mutations = 0;\n            for (int k = 0; k < m; k++) {\n                if (start.charAt(k) != bank[i].charAt(k)) {\n                    mutations++;\n                }\n                if (mutations > 1) {\n                    break;\n                }\n            }\n            if (mutations == 1) {\n                queue.offer(i);\n                visited[i] = true;\n            }\n        }        \n        while (!queue.isEmpty()) {\n            int sz = queue.size();\n            for (int i = 0; i < sz; i++) {\n                int curr = queue.poll();\n                if (curr == endIndex) {\n                    return step;\n                }\n                for (int next : adj[curr]) {\n                    if (visited[next]) {\n                        continue;\n                    }\n                    visited[next] = true;\n                    queue.offer(next);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int MinMutation(string start, string end, string[] bank) {\n        int m = start.Length;\n        int n = bank.Length;\n        IList<int>[] adj = new IList<int>[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new List<int>();\n        }\n        int endIndex = -1;\n        for (int i = 0; i < n; i++) {\n            if (end.Equals(bank[i])) {\n                endIndex = i;\n            }\n            for (int j = i + 1; j < n; j++) {\n                int mutations = 0;\n                for (int k = 0; k < m; k++) {\n                    if (bank[i][k] != bank[j][k]) {\n                        mutations++;\n                    }\n                    if (mutations > 1) {\n                        break;\n                    }\n                }\n                if (mutations == 1) {\n                    adj[i].Add(j);\n                    adj[j].Add(i);\n                }\n            }\n        }\n        if (endIndex == -1) {\n            return -1;\n        }\n\n        Queue<int> queue = new Queue<int>();\n        bool[] visited = new bool[n];\n        int step = 1;\n        for (int i = 0; i < n; i++) {\n            int mutations = 0;\n            for (int k = 0; k < m; k++) {\n                if (start[k] != bank[i][k]) {\n                    mutations++;\n                }\n                if (mutations > 1) {\n                    break;\n                }\n            }\n            if (mutations == 1) {\n                queue.Enqueue(i);\n                visited[i] = true;\n            }\n        }        \n        while (queue.Count > 0) {\n            int sz = queue.Count;\n            for (int i = 0; i < sz; i++) {\n                int curr = queue.Dequeue();\n                if (curr == endIndex) {\n                    return step;\n                }\n                foreach (int next in adj[curr]) {\n                    if (visited[next]) {\n                        continue;\n                    }\n                    visited[next] = true;\n                    queue.Enqueue(next);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n}\n```\n\n```C [sol2-C]\nint minMutation(char * start, char * end, char ** bank, int bankSize) {\n    int m = strlen(start);\n    int **adj = (int **)malloc(sizeof(int *) * bankSize);\n    int endIndex = -1;\n    for (int i = 0; i < bankSize; i++) {\n        adj[i] = (int *)malloc(sizeof(int) * bankSize);\n        memset(adj[i], 0, sizeof(int) * bankSize);\n    }\n    for (int i = 0; i < bankSize; i++) {\n        if (!strcmp(end, bank[i])) {\n            endIndex = i;\n        }\n        for (int j = i + 1; j < bankSize; j++) {\n            int mutations = 0;\n            for (int k = 0; k < m; k++) {\n                if (bank[i][k] != bank[j][k]) {\n                    mutations++;\n                }\n                if (mutations > 1) {\n                    break;\n                }\n            }\n            if (mutations == 1) {\n                adj[i][j] = 1;\n                adj[j][i] = 1;\n            }\n        }\n    }\n    if (endIndex == -1) {\n        return -1;\n    }\n\n    int *queue = (int *)malloc(sizeof(int) * bankSize);\n    bool *visited = (bool *)malloc(sizeof(bool) * bankSize);\n    memset(visited, 0, sizeof(bool) * bankSize);\n    int head = 0;\n    int tail = 0;\n    int step = 1;\n    for (int i = 0; i < bankSize; i++) {\n        int mutations = 0;\n        for (int k = 0; k < m; k++) {\n            if (start[k] != bank[i][k]) {\n                mutations++;\n            }\n            if (mutations > 1) {\n                break;\n            }\n        }\n        if (mutations == 1) {\n            queue[tail++] = i;\n            visited[i] = true;\n        }\n    }        \n    while (head != tail) {\n        int sz = tail - head;\n        for (int i = 0; i < sz; i++) {\n            int curr = queue[head++];\n            if (curr == endIndex) {\n                for (int i = 0; i < bankSize; i++) {\n                    free(adj[i]);\n                }\n                free(adj);\n                free(queue);\n                free(visited);\n                return step;\n            }\n            for (int j = 0; j < bankSize; j++) {\n                if (visited[j] || !adj[curr][j]) {\n                    continue;\n                }\n                visited[j] = true;\n                queue[tail++] = j;\n            }\n        }\n        step++;\n    }\n    for (int i = 0; i < bankSize; i++) {\n        free(adj[i]);\n    }\n    free(adj);\n    free(queue);\n    free(visited);\n    return -1; \n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar minMutation = function(start, end, bank) {\n    const m = start.length;\n    const n = bank.length;\n    const adj = new Array(n).fill(0).map(() => new Array());\n    let endIndex = -1;\n    for (let i = 0; i < n; i++) {\n        if (end === bank[i]) {\n            endIndex = i;\n        }\n        for (let j = i + 1; j < n; j++) {\n            let mutations = 0;\n            for (let k = 0; k < m; k++) {\n                if (bank[i][k] !== bank[j][k]) {\n                    mutations++;\n                }\n                if (mutations > 1) {\n                    break;\n                }\n            }\n            if (mutations === 1) {\n                adj[i].push(j);\n                adj[j].push(i);\n            }\n        }\n    }\n    if (endIndex === -1) {\n        return -1;\n    }\n\n    const queue = [];\n    const visited = new Array(n).fill(0);\n    let step = 1;\n    for (let i = 0; i < n; i++) {\n        let mutations = 0;\n        for (let k = 0; k < m; k++) {\n            if (start[k] != bank[i][k]) {\n                mutations++;\n            }\n            if (mutations > 1) {\n                break;\n            }\n        }\n        if (mutations == 1) {\n            queue.push(i);\n            visited[i] = true;\n        }\n    }        \n    while (queue.length) {\n        const sz = queue.length;\n        for (let i = 0; i < sz; i++) {\n            const curr = queue.shift();\n            if (curr === endIndex) {\n                return step;\n            }\n            for (const next of adj[curr]) {\n                if (visited[next]) {\n                    continue;\n                }\n                visited[next] = true;\n                queue.push(next);\n            }\n        }\n        step++;\n    }\n    return -1;\n};\n```\n\n```go [sol2-Golang]\nfunc diffOne(s, t string) (diff bool) {\n    for i := range s {\n        if s[i] != t[i] {\n            if diff {\n                return false\n            }\n            diff = true\n        }\n    }\n    return\n}\n\nfunc minMutation(start, end string, bank []string) int {\n    if start == end {\n        return 0\n    }\n\n    m := len(bank)\n    adj := make([][]int, m)\n    endIndex := -1\n    for i, s := range bank {\n        if s == end {\n            endIndex = i\n        }\n        for j := i + 1; j < m; j++ {\n            if diffOne(s, bank[j]) {\n                adj[i] = append(adj[i], j)\n                adj[j] = append(adj[j], i)\n            }\n        }\n    }\n    if endIndex == -1 {\n        return -1\n    }\n\n    var q []int\n    vis := make([]bool, m)\n    for i, s := range bank {\n        if diffOne(start, s) {\n            q = append(q, i)\n            vis[i] = true\n        }\n    }\n    for step := 1; q != nil; step++ {\n        tmp := q\n        q = nil\n        for _, cur := range tmp {\n            if cur == endIndex {\n                return step\n            }\n            for _, nxt := range adj[cur] {\n                if !vis[nxt] {\n                    vis[nxt] = true\n                    q = append(q, nxt)\n                }\n            }\n        }\n    }\n    return -1\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m \\times n^2)$，其中 $m$ 为基因序列的长度，$n$ 为数组 $\\textit{bank}$ 的长度。计算合法的基因变化 $\\textit{adj}$ 需要的时间为 $O(m \\times n^2)$，广度优先搜索时，队列中最多有 $n$ 个元素，需要的时间为 $O(n)$，因此时间复杂度为 $O(m \\times n^2)$。\n\n- 空间复杂度：$O(n^2)$，其中 $n$ 为数组 $\\textit{bank}$ 的长度。计算合法的基因变化 $\\textit{adj}$ 需要的空间为 $O(n^2)$，队列中最多有 $n$ 个元素，因此空间复杂度为 $O(n^2)$。"
}