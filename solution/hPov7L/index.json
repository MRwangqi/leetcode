{
	"titleSlug": "hPov7L",
	"slug": "er-cha-shu-mei-ceng-de-zui-da-zhi-by-lee-q4y2",
	"url": "https://leetcode-cn.com/problems/hPov7L/solution/er-cha-shu-mei-ceng-de-zui-da-zhi-by-lee-q4y2/",
	"content": "#### 方法一：深度优先搜索\n\n**思路与算法**\n\n我们用树的「先序遍历」来进行「深度优先搜索」处理，并用 $\\textit{curHeight}$ 来标记遍历到的当前节点的高度。当遍历到 $\\textit{curHeight}$ 高度的节点就判断是否更新该层节点的最大值。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        def dfs(node: TreeNode, curHeight: int) -> None:\n            if node is None:\n                return\n            if curHeight == len(ans):\n                ans.append(node.val)\n            else:\n                ans[curHeight] = max(ans[curHeight], node.val)\n            dfs(node.left, curHeight + 1)\n            dfs(node.right, curHeight + 1)\n        dfs(root, 0)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    void dfs(vector<int>& res, TreeNode* root, int curHeight) {\n        if (curHeight == res.size()) {\n            res.push_back(root->val);\n        } else {\n            res[curHeight] = max(res[curHeight], root->val);\n        }\n        if (root->left) {\n            dfs(res, root->left, curHeight + 1);\n        }\n        if (root->right) {\n            dfs(res, root->right, curHeight + 1);\n        }\n    }\n\n    vector<int> largestValues(TreeNode* root) {\n        if (!root) {\n            return {};\n        }\n        vector<int> res;\n        dfs(res, root, 0);\n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n        if (root == null) {\n            return new ArrayList<Integer>();\n        }\n        List<Integer> res = new ArrayList<Integer>();\n        dfs(res, root, 0);\n        return res;\n    }\n\n    public void dfs(List<Integer> res, TreeNode root, int curHeight) {\n        if (curHeight == res.size()) {\n            res.add(root.val);\n        } else {\n            res.set(curHeight, Math.max(res.get(curHeight), root.val));\n        }\n        if (root.left != null) {\n            dfs(res, root.left, curHeight + 1);\n        }\n        if (root.right != null) {\n            dfs(res, root.right, curHeight + 1);\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> LargestValues(TreeNode root) {\n        if (root == null) {\n            return new List<int>();\n        }\n        IList<int> res = new List<int>();\n        DFS(res, root, 0);\n        return res;\n    }\n\n    public void DFS(IList<int> res, TreeNode root, int curHeight) {\n        if (curHeight == res.Count) {\n            res.Add(root.val);\n        } else {\n            res[curHeight] = Math.Max(res[curHeight], root.val);\n        }\n        if (root.left != null) {\n            DFS(res, root.left, curHeight + 1);\n        }\n        if (root.right != null) {\n            DFS(res, root.right, curHeight + 1);\n        }\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX_NODE_SIZE 10001\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nvoid dfs(int *res, int *pos, struct TreeNode* root, int curHeight) {\n    if (curHeight == *pos) {\n        res[(*pos)++] = root->val;\n    } else {\n        res[curHeight] = MAX(res[curHeight], root->val);\n    }\n    if (root->left) {\n        dfs(res, pos, root->left, curHeight + 1);\n    }\n    if (root->right) {\n        dfs(res, pos, root->right, curHeight + 1);\n    }\n} \n\nint* largestValues(struct TreeNode* root, int* returnSize) {\n    if (!root) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int *res = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    *returnSize = 0;\n    dfs(res, returnSize, root, 0);\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar largestValues = function(root) {\n    if (!root) {\n        return [];\n    }\n    const res = [];\n    const dfs = (res, root, curHeight) => {\n        if (curHeight === res.length) {\n            res.push(root.val);\n        } else {\n            res.splice(curHeight, 1, Math.max(res[curHeight], root.val));\n        }\n        if (root.left) {\n            dfs(res, root.left, curHeight + 1);\n        }\n        if (root.right) {\n            dfs(res, root.right, curHeight + 1);\n        }\n    }\n    dfs(res, root, 0);\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc largestValues(root *TreeNode) (ans []int) {\n    var dfs func(*TreeNode, int)\n    dfs = func(node *TreeNode, curHeight int) {\n        if node == nil {\n            return\n        }\n        if curHeight == len(ans) {\n            ans = append(ans, node.Val)\n        } else {\n            ans[curHeight] = max(ans[curHeight], node.Val)\n        }\n        dfs(node.Left, curHeight+1)\n        dfs(node.Right, curHeight+1)\n    }\n    dfs(root, 0)\n    return\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为二叉树节点个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\n\n- 空间复杂度：$O(\\textit{height})$。其中 $\\textit{height}$ 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n\n#### 方法二：广度优先搜索\n\n**思路与算法**\n\n我们也可以用「广度优先搜索」的方法来解决这道题目。「广度优先搜索」中的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于「广度优先搜索」的每次只从队列里拿出一个节点，我们把当前队列中的全部节点拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是下一层的所有节点，即我们是一层一层地进行拓展，然后每一层我们用 $\\textit{maxVal}$ 来标记该层节点的最大值。当该层全部节点都处理完后，$\\textit{maxVal}$ 就是该层全部节点中的最大值。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\n        if root is None:\n            return []\n        ans = []\n        q = [root]\n        while q:\n            maxVal = -inf\n            tmp = q\n            q = []\n            for node in tmp:\n                maxVal = max(maxVal, node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            ans.append(maxVal)\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> largestValues(TreeNode* root) {\n        if (!root) {\n            return {};\n        }\n        vector<int> res;\n        queue<TreeNode*> q;\n        q.push(root);\n        while (!q.empty()) {\n            int len = q.size();\n            int maxVal = INT_MIN;\n            while (len > 0) {\n                len--;\n                auto t = q.front();\n                q.pop();\n                maxVal = max(maxVal, t->val);\n                if (t->left) {\n                    q.push(t->left);\n                }\n                if (t->right) {\n                    q.push(t->right);\n                }\n            }\n            res.push_back(maxVal);\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n        if (root == null) {\n            return new ArrayList<Integer>();\n        }\n        List<Integer> res = new ArrayList<Integer>();\n        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int len = queue.size();\n            int maxVal = Integer.MIN_VALUE;\n            while (len > 0) {\n                len--;\n                TreeNode t = queue.poll();\n                maxVal = Math.max(maxVal, t.val);\n                if (t.left != null) {\n                    queue.offer(t.left);\n                }\n                if (t.right != null) {\n                    queue.offer(t.right);\n                }\n            }\n            res.add(maxVal);\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public IList<int> LargestValues(TreeNode root) {\n        if (root == null) {\n            return new List<int>();\n        }\n        IList<int> res = new List<int>();\n        Queue<TreeNode> queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n        while (queue.Count > 0) {\n            int len = queue.Count;\n            int maxVal = int.MinValue;\n            while (len > 0) {\n                len--;\n                TreeNode t = queue.Dequeue();\n                maxVal = Math.Max(maxVal, t.val);\n                if (t.left != null) {\n                    queue.Enqueue(t.left);\n                }\n                if (t.right != null) {\n                    queue.Enqueue(t.right);\n                }\n            }\n            res.Add(maxVal);\n        }\n        return res;\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX_NODE_SIZE 10001\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint* largestValues(struct TreeNode* root, int* returnSize) {\n    if (!root) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int *res = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    int pos = 0;\n    struct TreeNode **queue = (struct TreeNode *)malloc(sizeof(struct TreeNode *) * MAX_NODE_SIZE);\n    int head = 0, tail = 0;\n    queue[tail++] = root;\n    while (head != tail) {\n        int len = tail - head;\n        int maxVal = INT_MIN;\n        while (len > 0) {\n            len--;\n            struct TreeNode *node = queue[head++];\n            maxVal = MAX(maxVal, node->val);\n            if (node->left) {\n                queue[tail++] = node->left;\n            }\n            if (node->right) {\n                queue[tail++] = node->right;\n            }\n        }\n        res[pos++] = maxVal;\n    }\n    *returnSize = pos;\n    free(queue);\n    return res;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar largestValues = function(root) {\n    if (!root) {\n        return [];\n    }\n    const res = [];\n    const queue = [root];\n    while (queue.length) {\n        let len = queue.length;\n        let maxVal = -Number.MAX_VALUE;\n        while (len > 0) {\n            len--;\n            const t = queue.shift();\n            maxVal = Math.max(maxVal, t.val);\n            if (t.left) {\n                queue.push(t.left);\n            }\n            if (t.right) {\n                queue.push(t.right);\n            }\n        }\n        res.push(maxVal);\n    }\n    return res;\n};\n```\n\n```go [sol2-Golang]\nfunc largestValues(root *TreeNode) (ans []int) {\n    if root == nil {\n        return\n    }\n    q := []*TreeNode{root}\n    for len(q) > 0 {\n        maxVal := math.MinInt32\n        tmp := q\n        q = nil\n        for _, node := range tmp {\n            maxVal = max(maxVal, node.Val)\n            if node.Left != nil {\n                q = append(q, node.Left)\n            }\n            if node.Right != nil {\n                q = append(q, node.Right)\n            }\n        }\n        ans = append(ans, maxVal)\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为二叉树节点个数，每一个节点仅会进出队列一次。\n\n- 空间复杂度：$O(n)$，存储二叉树节点的空间开销。"
}