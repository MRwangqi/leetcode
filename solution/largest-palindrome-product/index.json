{
	"titleSlug": "largest-palindrome-product",
	"slug": "zui-da-hui-wen-shu-cheng-ji-by-leetcode-rcihq",
	"url": "https://leetcode-cn.com/problems/largest-palindrome-product/solution/zui-da-hui-wen-shu-cheng-ji-by-leetcode-rcihq/",
	"content": "#### 方法一：枚举\n\n我们可以从大到小枚举回文数，由于确定了回文数的左半部分，其右半部分也就确定了，因此我们只需要枚举左半部分，同时由于两个 $n$ 位整数的乘积至多是个 $2n$ 位数，我们可以从 $10^n-1$ 开始枚举回文数的左半部分。\n\n得到回文数 $p$ 后，需要判断其能否分解成两个 $n$ 位整数。我们可以从 $10^n-1$ 开始从大到小枚举 $x$，若 $x$ 能整除 $p$ 且 $x$ 和 $\\dfrac{p}{x}$ 均为 $n$ 位整数，则 $p$ 就是我们要找的答案。\n\n代码实现时，在枚举 $x$ 时枚举到 $\\lceil\\sqrt{p}\\rceil$ 即可，因为继续枚举的话有 $x<\\dfrac{p}{x}$，若 $x$ 为 $p$ 的因子则说明更大的 $\\dfrac{p}{x}$ 也是 $p$ 的因子，但是前面枚举 $x$ 的过程中并没有找到 $p$ 的因子，矛盾。\n\n实际结果表明，上述算法在 $n>1$ 时总能找到答案，而 $n=1$ 时的答案为 $9$，是个 $1$ 位数，需要特判这种情况。\n\n```Python [sol1-Python3]\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1:\n            return 9\n        upper = 10 ** n - 1\n        for left in range(upper, upper // 10, -1):  # 枚举回文数的左半部分\n            p, x = left, left\n            while x:\n                p = p * 10 + x % 10  # 翻转左半部分到其自身末尾，构造回文数 p\n                x //= 10\n            x = upper\n            while x * x >= p:\n                if p % x == 0:  # x 是 p 的因子\n                    return p % 1337\n                x -= 1\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int largestPalindrome(int n) {\n        if (n == 1) {\n            return 9;\n        }\n        int upper = pow(10, n) - 1;\n        for (int left = upper;; --left) { // 枚举回文数的左半部分\n            long p = left;\n            for (int x = left; x > 0; x /= 10) {\n                p = p * 10 + x % 10; // 翻转左半部分到其自身末尾，构造回文数 p\n            }\n            for (long x = upper; x * x >= p; --x) {\n                if (p % x == 0) { // x 是 p 的因子\n                    return p % 1337;\n                }\n            }\n        }\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int largestPalindrome(int n) {\n        if (n == 1) {\n            return 9;\n        }\n        int upper = (int) Math.pow(10, n) - 1;\n        int ans = 0;\n        for (int left = upper; ans == 0; --left) { // 枚举回文数的左半部分\n            long p = left;\n            for (int x = left; x > 0; x /= 10) {\n                p = p * 10 + x % 10; // 翻转左半部分到其自身末尾，构造回文数 p\n            }\n            for (long x = upper; x * x >= p; --x) {\n                if (p % x == 0) { // x 是 p 的因子\n                    ans = (int) (p % 1337);\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int LargestPalindrome(int n) {\n        if (n == 1) {\n            return 9;\n        }\n        int upper = (int) Math.Pow(10, n) - 1;\n        int ans = 0;\n        for (int left = upper; ans == 0; --left) { // 枚举回文数的左半部分\n            long p = left;\n            for (int x = left; x > 0; x /= 10) {\n                p = p * 10 + x % 10; // 翻转左半部分到其自身末尾，构造回文数 p\n            }\n            for (long x = upper; x * x >= p; --x) {\n                if (p % x == 0) { // x 是 p 的因子\n                    ans = (int) (p % 1337);\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc largestPalindrome(n int) int {\n    if n == 1 {\n        return 9\n    }\n    upper := int(math.Pow10(n)) - 1\n    for left := upper; ; left-- { // 枚举回文数的左半部分\n        p := left\n        for x := left; x > 0; x /= 10 {\n            p = p*10 + x%10 // 翻转左半部分到其自身末尾，构造回文数 p\n        }\n        for x := upper; x*x >= p; x-- {\n            if p%x == 0 { // x 是 p 的因子\n                return p % 1337\n            }\n        }\n    }\n}\n```\n\n```C [sol1-C]\nint largestPalindrome(int n){\n    if (n == 1) {\n        return 9;\n    }\n    int upper = pow(10, n) - 1;\n    for (int left = upper;; --left) { // 枚举回文数的左半部分\n        long p = left;\n        for (int x = left; x > 0; x /= 10) {\n            p = p * 10 + x % 10; // 翻转左半部分到其自身末尾，构造回文数 p\n        }\n        for (long x = upper; x * x >= p; --x) {\n            if (p % x == 0) { // x 是 p 的因子\n                return p % 1337;\n            }\n        }\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar largestPalindrome = function(n) {\n    if (n === 1) {\n        return 9;\n    }\n    const upper = 10 ** n - 1;\n    for (let left = upper; left > upper / 10; left--) {\n        let right = String(left).split('').reverse().join('');\n        let p = BigInt(String(left) + right)    //得到回文数\n        let x = BigInt(upper);\n        while (x * x >= p) {\n            if (p % x === BigInt(0)) { // x 是 p 的因子\n                return p % BigInt(1337);\n            }\n            x--;\n        }\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(10^{2n})$。枚举 $\\textit{left}$ 和 $x$ 的时间复杂度均为 $O(10^n)$。实际上我们只需要枚举远小于 $10^n$ 个的 $\\textit{left}$ 就能找到答案，实际的时间复杂度远低于 $O(10^{2n})$。\n\n- 空间复杂度：$O(1)$，我们只需要常数的空间保存若干变量。"
}