{
	"titleSlug": "second-minimum-node-in-a-binary-tree",
	"slug": "er-cha-shu-zhong-di-er-xiao-de-jie-dian-bhxiw",
	"url": "https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/solution/er-cha-shu-zhong-di-er-xiao-de-jie-dian-bhxiw/",
	"content": "#### 方法一：深度优先搜索\n\n**思路**\n\n根据题目中的描述「如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个」，我们可以知道，对于二叉树中的任意节点 $x$，$x$ 的值不大于其所有子节点的值，因此：\n\n> 对于二叉树中的任意节点 $x$，$x$ 的值不大于以 $x$ 为根的子树中所有节点的值。\n\n令 $x$ 为二叉树的根节点，此时我们可以得出结论：\n\n> 二叉树根节点的值即为所有节点中的最小值。\n\n因此，我们可以对整棵二叉树进行一次遍历。设根节点的值为 $\\textit{rootvalue}$，我们只需要通过遍历，找出严格大于 $\\textit{rootvalue}$ 的最小值，即为「所有节点中的第二小的值」。\n\n**算法**\n\n我们可以使用深度优先搜索的方法对二叉树进行遍历。\n\n假设当前遍历到的节点为 $\\textit{node}$，如果 $\\textit{node}$ 的值严格大于 $\\textit{rootvalue}$，那么我们就可以用 $\\textit{node}$ 的值来更新答案 $\\textit{ans}$。\n\n当我们遍历完整棵二叉树后，即可返回 $\\textit{ans}$。\n\n**细节**\n\n根据题目要求，如果第二小的值不存在的话，输出 $-1$，那么我们可以将 $\\textit{ans}$ 的初始值置为 $-1$。在遍历的过程中，如果当前节点的值严格大于 $\\textit{rootvalue}$ 的节点时，那么只要 $\\textit{ans}$ 的值为 $-1$ 或者当前节点的值严格小于 $\\textit{ans}$，我们就需要对 $\\textit{ans}$ 进行更新。\n\n此外，如果当前节点的值大于等于 $\\textit{ans}$，那么根据「思路」部分，以当前节点为根的子树中所有节点的值都大于等于 $\\textit{ans}$，我们就直接回溯，无需对该子树进行遍历。这样做可以省去不必要的遍历过程。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findSecondMinimumValue(TreeNode* root) {\n        int ans = -1;\n        int rootvalue = root->val;\n\n        function<void(TreeNode*)> dfs = [&](TreeNode* node) {\n            if (!node) {\n                return;\n            }\n            if (ans != -1 && node->val >= ans) {\n                return;\n            }\n            if (node->val > rootvalue) {\n                ans = node->val;\n            }\n            dfs(node->left);\n            dfs(node->right);\n        };\n\n        dfs(root);\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    int ans;\n    int rootvalue;\n\n    public int findSecondMinimumValue(TreeNode root) {\n        ans = -1;\n        rootvalue = root.val;\n        dfs(root);\n        return ans;\n    }\n\n    public void dfs(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        if (ans != -1 && node.val >= ans) {\n            return;\n        }\n        if (node.val > rootvalue) {\n            ans = node.val;\n        }\n        dfs(node.left);\n        dfs(node.right);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    int ans;\n    int rootvalue;\n\n    public int FindSecondMinimumValue(TreeNode root) {\n        ans = -1;\n        rootvalue = root.val;\n        DFS(root);\n        return ans;\n    }\n\n    public void DFS(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        if (ans != -1 && node.val >= ans) {\n            return;\n        }\n        if (node.val > rootvalue) {\n            ans = node.val;\n        }\n        DFS(node.left);\n        DFS(node.right);\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\n        ans, rootvalue = -1, root.val\n\n        def dfs(node: TreeNode) -> None:\n            nonlocal ans\n            if not node:\n                return\n            if ans != -1 and node.val >= ans:\n                return\n            if node.val > rootvalue:\n                ans = node.val\n            \n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return ans\n```\n\n```JavaScript [sol1-JavaScript]\nvar findSecondMinimumValue = function(root) {\n    let ans = -1;\n    const rootvalue = root.val;\n\n    const dfs = (node) => {\n        if (node === null) {\n            return;\n        }\n        if (ans !== -1 && node.val >= ans) {\n            return;\n        }\n        if (node.val > rootvalue) {\n            ans = node.val;\n        }\n        dfs(node.left);\n        dfs(node.right);\n    }\n\n    dfs(root);\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc findSecondMinimumValue(root *TreeNode) int {\n    ans := -1\n    rootVal := root.Val\n    var dfs func(*TreeNode)\n    dfs = func(node *TreeNode) {\n        if node == nil || ans != -1 && node.Val >= ans {\n            return\n        }\n        if node.Val > rootVal {\n            ans = node.Val\n        }\n        dfs(node.Left)\n        dfs(node.Right)\n    }\n    dfs(root)\n    return ans\n}\n```\n\n```C [sol1-C]\nint ans;\nint rootvalue;\n\nstruct TreeNode *dfs(struct TreeNode *node) {\n    if (!node) {\n        return;\n    }\n    if (ans != -1 && node->val >= ans) {\n        return;\n    }\n    if (node->val > rootvalue) {\n        ans = node->val;\n    }\n    dfs(node->left);\n    dfs(node->right);\n};\n\nint findSecondMinimumValue(struct TreeNode *root) {\n    ans = -1;\n    rootvalue = root->val;\n    dfs(root);\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉树中的节点个数。我们最多需要对整棵二叉树进行一次遍历。\n\n- 空间复杂度：$O(n)$。我们使用深度优先搜索的方法进行遍历，需要使用的栈空间为 $O(n)$。"
}