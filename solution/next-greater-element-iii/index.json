{
	"titleSlug": "next-greater-element-iii",
	"slug": "xia-yi-ge-geng-da-yuan-su-iii-by-leetcod-mqf1",
	"url": "https://leetcode-cn.com/problems/next-greater-element-iii/solution/xia-yi-ge-geng-da-yuan-su-iii-by-leetcod-mqf1/",
	"content": "#### 方法一：下一个排列\n\n把 $n$ 转换成字符串（字符数组），那么本题实际上是在求字符数组的 [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)，当不存在下一个排列时返回 $-1$。\n\n参考 [31. 下一个排列的官方题解](https://leetcode.cn/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/)，可以得到如下做法：\n\n```Python [sol1-Python3]\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        nums = list(str(n))\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i < 0:\n            return -1\n\n        j = len(nums) - 1\n        while j >= 0 and nums[i] >= nums[j]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1:] = nums[i + 1:][::-1]\n        ans = int(''.join(nums))\n        return ans if ans < 2 ** 31 else -1\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int nextGreaterElement(int n) {\n        auto nums = to_string(n);\n        int i = (int) nums.length() - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        if (i < 0) {\n            return -1;\n        }\n\n        int j = nums.size() - 1;\n        while (j >= 0 && nums[i] >= nums[j]) {\n            j--;\n        }\n        swap(nums[i], nums[j]);\n        reverse(nums.begin() + i + 1, nums.end());\n        long ans = stol(nums);\n        return ans > INT_MAX ? -1 : ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int nextGreaterElement(int n) {\n        char[] nums = Integer.toString(n).toCharArray();\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        if (i < 0) {\n            return -1;\n        }\n\n        int j = nums.length - 1;\n        while (j >= 0 && nums[i] >= nums[j]) {\n            j--;\n        }\n        swap(nums, i, j);\n        reverse(nums, i + 1);\n        long ans = Long.parseLong(new String(nums));\n        return ans > Integer.MAX_VALUE ? -1 : (int) ans;\n    }\n\n    public void reverse(char[] nums, int begin) {\n        int i = begin, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    public void swap(char[] nums, int i, int j) {\n        char temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int NextGreaterElement(int n) {\n        char[] nums = n.ToString().ToCharArray();\n        int i = nums.Length - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        if (i < 0) {\n            return -1;\n        }\n\n        int j = nums.Length - 1;\n        while (j >= 0 && nums[i] >= nums[j]) {\n            j--;\n        }\n        Swap(nums, i, j);\n        Reverse(nums, i + 1);\n        long ans = long.Parse(new string(nums));\n        return ans > int.MaxValue ? -1 : (int) ans;\n    }\n\n    public void Reverse(char[] nums, int begin) {\n        int i = begin, j = nums.Length - 1;\n        while (i < j) {\n            Swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    public void Swap(char[] nums, int i, int j) {\n        char temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc nextGreaterElement(n int) int {\n    nums := []byte(strconv.Itoa(n))\n    i := len(nums) - 2\n    for i >= 0 && nums[i] >= nums[i+1] {\n        i--\n    }\n    if i < 0 {\n        return -1\n    }\n\n    j := len(nums) - 1\n    for j >= 0 && nums[i] >= nums[j] {\n        j--\n    }\n    nums[i], nums[j] = nums[j], nums[i]\n    reverse(nums[i+1:])\n    ans, _ := strconv.Atoi(string(nums))\n    if ans > math.MaxInt32 {\n        return -1\n    }\n    return ans\n}\n\nfunc reverse(a []byte) {\n    for i, n := 0, len(a); i < n/2; i++ {\n        a[i], a[n-1-i] = a[n-1-i], a[i]\n    }\n}\n```\n\n```C [sol1-C]\nint nextGreaterElement(int n){\n    char nums[32];\n    sprintf(nums, \"%d\", n);\n    int i = (int) strlen(nums) - 2;\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n    if (i < 0) {\n        return -1;\n    }\n\n    int j = strlen(nums) - 1;\n    while (j >= 0 && nums[i] >= nums[j]) {\n        j--;\n    }\n    int num = nums[i];\n    nums[i] = nums[j];\n    nums[j] = num;\n    int left = i + 1;\n    int right = strlen(nums) - 1;\n    while (left < right) {\n        int num = nums[left];\n        nums[left] = nums[right];\n        nums[right] = num;\n        left++;\n        right--;\n    }\n    long ans = atol(nums);\n    return ans > INT_MAX ? -1 : ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst MAX = 2147483647;\nvar nextGreaterElement = function(n) {\n    const nums = [...('' + n)];\n    let i = nums.length - 2;\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n    if (i < 0) {\n        return -1;\n    }\n\n    let j = nums.length - 1;\n    while (j >= 0 && nums[i] >= nums[j]) {\n        j--;\n    }\n    [nums[i], nums[j]] = [nums[j], nums[i]];\n    reverse(nums, i + 1);\n    const ans = 0 + nums.join('');\n    return ans > MAX ? -1 : ans;\n};\n\nconst reverse = (nums, begin) => {\n    let i = begin, j = nums.length - 1;\n    while (i < j) {\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n        i++;\n        j--;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$。\n\n- 空间复杂度：$O(\\log n)$。\n\n#### 方法二：数学\n\n不转换成字符数组，如何用 $O(1)$ 空间复杂度解决此题？\n\n如果还要求不使用 $64$ 位整数呢？\n\n类似方法一，我们从 $n$ 开始，不断比较其最低位数字和次低位数字的大小，如果次低位数字不低于最低位数字，则移除最低位数字，继续循环。循环结束后的 $n$ 就对应着方法一的下标 $i$，即 $\\textit{nums}$ 的前 $i+1$ 个字符。\n\n对于方法一中下标 $j$ 的计算也是同理。\n\n最后，我们参考 [7. 整数反转的官方题解](https://leetcode.cn/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode-solution-bccn/) 的做法，将 $i+1$ 之后的部分反转，即得到下一个整数。如果中途计算会溢出，则返回 $-1$。\n\n```Python [sol2-Python3]\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        x, cnt = n, 1\n        while x >= 10 and x // 10 % 10 >= x % 10:\n            cnt += 1\n            x //= 10\n        x //= 10\n        if x == 0:\n            return -1\n\n        targetDigit = x % 10\n        x2, cnt2 = n, 0\n        while x2 % 10 <= targetDigit:\n            cnt2 += 1\n            x2 //= 10\n        x += x2 % 10 - targetDigit  # 把 x2 % 10 换到 targetDigit 上\n\n        MAX_INT = 2 ** 31 - 1\n        for i in range(cnt):  # 反转 n 末尾的 cnt 个数字拼到 x 后\n            d = n % 10 if i != cnt2 else targetDigit\n            # 为了演示算法，请读者把 x 视作一个 32 位有符号整数\n            if x > MAX_INT // 10 or x == MAX_INT // 10 and d > 7:\n                return -1\n            x = x * 10 + d\n            n //= 10\n        return x\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int nextGreaterElement(int n) {\n        int x = n, cnt = 1;\n        for (; x >= 10 && x / 10 % 10 >= x % 10; x /= 10) {\n            ++cnt;\n        }\n        x /= 10;\n        if (x == 0) {\n            return -1;\n        }\n\n        int targetDigit = x % 10;\n        int x2 = n, cnt2 = 0;\n        for (; x2 % 10 <= targetDigit; x2 /= 10) {\n            ++cnt2;\n        }\n        x += x2 % 10 - targetDigit; // 把 x2 % 10 换到 targetDigit 上\n\n        for (int i = 0; i < cnt; ++i, n /= 10) { // 反转 n 末尾的 cnt 个数字拼到 x 后\n            int d = i != cnt2 ? n % 10 : targetDigit;\n            if (x > INT_MAX / 10 || x == INT_MAX / 10 && d > 7) {\n                return -1;\n            }\n            x = x * 10 + d;\n        }\n        return x;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int nextGreaterElement(int n) {\n        int x = n, cnt = 1;\n        for (; x >= 10 && x / 10 % 10 >= x % 10; x /= 10) {\n            ++cnt;\n        }\n        x /= 10;\n        if (x == 0) {\n            return -1;\n        }\n\n        int targetDigit = x % 10;\n        int x2 = n, cnt2 = 0;\n        for (; x2 % 10 <= targetDigit; x2 /= 10) {\n            ++cnt2;\n        }\n        x += x2 % 10 - targetDigit; // 把 x2 % 10 换到 targetDigit 上\n\n        for (int i = 0; i < cnt; ++i, n /= 10) { // 反转 n 末尾的 cnt 个数字拼到 x 后\n            int d = i != cnt2 ? n % 10 : targetDigit;\n            if (x > Integer.MAX_VALUE / 10 || x == Integer.MAX_VALUE / 10 && d > 7) {\n                return -1;\n            }\n            x = x * 10 + d;\n        }\n        return x;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int NextGreaterElement(int n) {\n        int x = n, cnt = 1;\n        for (; x >= 10 && x / 10 % 10 >= x % 10; x /= 10) {\n            ++cnt;\n        }\n        x /= 10;\n        if (x == 0) {\n            return -1;\n        }\n\n        int targetDigit = x % 10;\n        int x2 = n, cnt2 = 0;\n        for (; x2 % 10 <= targetDigit; x2 /= 10) {\n            ++cnt2;\n        }\n        x += x2 % 10 - targetDigit; // 把 x2 % 10 换到 targetDigit 上\n\n        for (int i = 0; i < cnt; ++i, n /= 10) { // 反转 n 末尾的 cnt 个数字拼到 x 后\n            int d = i != cnt2 ? n % 10 : targetDigit;\n            if (x > int.MaxValue / 10 || x == int.MaxValue / 10 && d > 7) {\n                return -1;\n            }\n            x = x * 10 + d;\n        }\n        return x;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc nextGreaterElement(n int) int {\n    x, cnt := n, 1\n    for ; x >= 10 && x/10%10 >= x%10; x /= 10 {\n        cnt++\n    }\n    x /= 10\n    if x == 0 {\n        return -1\n    }\n\n    targetDigit := x % 10\n    x2, cnt2 := n, 0\n    for ; x2%10 <= targetDigit; x2 /= 10 {\n        cnt2++\n    }\n    x += x2%10 - targetDigit // 把 x2%10 换到 targetDigit 上\n\n    for i := 0; i < cnt; i++ { // 反转 n 末尾的 cnt 个数字拼到 x 后\n        d := targetDigit\n        if i != cnt2 {\n            d = n % 10\n        }\n        if x > math.MaxInt32/10 || x == math.MaxInt32/10 && d > 7 {\n            return -1\n        }\n        x = x*10 + d\n        n /= 10\n    }\n    return x\n}\n```\n\n```C [sol2-C]\nint nextGreaterElement(int n){\n    int x = n, cnt = 1;\n    for (; x >= 10 && x / 10 % 10 >= x % 10; x /= 10) {\n        ++cnt;\n    }\n    x /= 10;\n    if (x == 0) {\n        return -1;\n    }\n\n    int targetDigit = x % 10;\n    int x2 = n, cnt2 = 0;\n    for (; x2 % 10 <= targetDigit; x2 /= 10) {\n        ++cnt2;\n    }\n    x += x2 % 10 - targetDigit; // 把 x2 % 10 换到 targetDigit 上\n\n    for (int i = 0; i < cnt; ++i, n /= 10) { // 反转 n 末尾的 cnt 个数字拼到 x 后\n        int d = i != cnt2 ? n % 10 : targetDigit;\n        if (x > INT_MAX / 10 || x == INT_MAX / 10 && d > 7) {\n            return -1;\n        }\n        x = x * 10 + d;\n    }\n    return x;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$。\n\n- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。"
}