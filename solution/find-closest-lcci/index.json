{
	"titleSlug": "find-closest-lcci",
	"slug": "dan-ci-ju-chi-by-leetcode-solution-u96o",
	"url": "https://leetcode-cn.com/problems/find-closest-lcci/solution/dan-ci-ju-chi-by-leetcode-solution-u96o/",
	"content": "#### 方法一：一次遍历\n\n最直观的做法是遍历数组 $\\textit{words}$，对于数组中的每个 $\\textit{word}_1$，遍历数组 $\\textit{words}$ 找到每个 $\\textit{word}_2$ 并计算距离。该做法在最坏情况下的时间复杂度是 $O(n^2)$，需要优化。\n\n为了降低时间复杂度，需要考虑其他的做法。从左到右遍历数组 $\\textit{words}$，当遍历到 $\\textit{word}_1$ 时，如果已经遍历的单词中存在 $\\textit{word}_2$，为了计算最短距离，应该取最后一个已经遍历到的 $\\textit{word}_2$ 所在的下标，计算和当前下标的距离。同理，当遍历到 $\\textit{word}_2$ 时，应该取最后一个已经遍历到的 $\\textit{word}_1$ 所在的下标，计算和当前下标的距离。\n\n基于上述分析，可以遍历数组一次得到最短距离，将时间复杂度降低到 $O(n)$。\n\n用 $\\textit{index}_1$ 和 $\\textit{index}_2$ 分别表示数组 $\\textit{words}$ 已经遍历的单词中的最后一个 $\\textit{word}_1$ 的下标和最后一个 $\\textit{word}_2$ 的下标，初始时 $\\textit{index}_1 = \\textit{index}_2 = -1$。遍历数组 $\\textit{words}$，当遇到 $\\textit{word}_1$ 或 $\\textit{word}_2$ 时，执行如下操作：\n\n1. 如果遇到 $\\textit{word}_1$，则将 $\\textit{index}_1$ 更新为当前下标；如果遇到 $\\textit{word}_2$，则将 $\\textit{index}_2$ 更新为当前下标。\n\n2. 如果 $\\textit{index}_1$ 和 $\\textit{index}_2$ 都非负，则计算两个下标的距离 $|\\textit{index}_1 - \\textit{index}_2|$，并用该距离更新最短距离。\n\n遍历结束之后即可得到 $\\textit{word}_1$ 和 $\\textit{word}_2$ 的最短距离。\n\n```Python [sol1-Python3]\nclass Solution:\n    def findClosest(self, words: List[str], word1: str, word2: str) -> int:\n        ans = len(words)\n        index1, index2 = -1, -1\n        for i, word in enumerate(words):\n            if word == word1:\n                index1 = i\n            elif word == word2:\n                index2 = i\n            if index1 >= 0 and index2 >= 0:\n                ans = min(ans, abs(index1 - index2))\n        return ans\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findClosest(String[] words, String word1, String word2) {\n        int length = words.length;\n        int ans = length;\n        int index1 = -1, index2 = -1;\n        for (int i = 0; i < length; i++) {\n            String word = words[i];\n            if (word.equals(word1)) {\n                index1 = i;\n            } else if (word.equals(word2)) {\n                index2 = i;\n            }\n            if (index1 >= 0 && index2 >= 0) {\n                ans = Math.min(ans, Math.abs(index1 - index2));\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindClosest(string[] words, string word1, string word2) {\n        int length = words.Length;\n        int ans = length;\n        int index1 = -1, index2 = -1;\n        for (int i = 0; i < length; i++) {\n            string word = words[i];\n            if (word.Equals(word1)) {\n                index1 = i;\n            } else if (word.Equals(word2)) {\n                index2 = i;\n            }\n            if (index1 >= 0 && index2 >= 0) {\n                ans = Math.Min(ans, Math.Abs(index1 - index2));\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findClosest(vector<string>& words, string word1, string word2) {\n        int length = words.size();\n        int ans = length;\n        int index1 = -1, index2 = -1;\n        for (int i = 0; i < length; i++) {\n            string word = words[i];\n            if (words[i] == word1) {\n                index1 = i;\n            } else if (words[i] == word2) {\n                index2 = i;\n            }\n            if (index1 >= 0 && index2 >= 0) {\n                ans = min(ans, abs(index1 - index2));\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint shortestDistance(char ** wordsDict, int wordsDictSize, char * word1, char * word2){\n    int ans = wordsDictSize;\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < wordsDictSize; i++) {\n        if (strcmp(wordsDict[i], word1) == 0) {\n            index1 = i;\n        } else if (strcmp(wordsDict[i], word2) == 0) {\n            index2 = i;\n        }\n        if (index1 >= 0 && index2 >= 0) {\n            ans = MIN(ans, abs(index1 - index2));\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findClosest = function(words, word1, word2) {\n    const length = words.length;\n    let ans = length;\n    let index1 = -1, index2 = -1;\n    for (let i = 0; i < length; i++) {\n        const word = words[i];\n        if (word === word1) {\n            index1 = i;\n        } else if (word === word2) {\n            index2 = i;\n        }\n        if (index1 >= 0 && index2 >= 0) {\n            ans = Math.min(ans, Math.abs(index1 - index2));\n        }\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc findClosest(words []string, word1, word2 string) int {\n    ans := len(words)\n    index1, index2 := -1, -1\n    for i, word := range words {\n        if word == word1 {\n            index1 = i\n        } else if word == word2 {\n            index2 = i\n        }\n        if index1 >= 0 && index2 >= 0 {\n            ans = min(ans, abs(index1-index2))\n        }\n    }\n    return ans\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{words}$ 的长度。需要遍历数组一次计算 $\\textit{word}_1$ 和 $\\textit{word}_2$ 的最短距离，每次更新下标和更新最短距离的时间都是 $O(1)$。这里将字符串的长度视为常数。\n\n- 空间复杂度：$O(1)$。\n\n#### 进阶问题\n\n如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，则可以维护一个哈希表记录每个单词的下标列表。遍历一次文件，按照下标递增顺序得到每个单词在文件中出现的所有下标。在寻找单词时，只要得到两个单词的下标列表，使用双指针遍历两个下标链表，即可得到两个单词的最短距离。"
}