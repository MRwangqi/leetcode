{
	"titleSlug": "maximum-level-sum-of-a-binary-tree",
	"slug": "zui-da-ceng-nei-yuan-su-he-by-leetcode-s-2tm4",
	"url": "https://leetcode-cn.com/problems/maximum-level-sum-of-a-binary-tree/solution/zui-da-ceng-nei-yuan-su-he-by-leetcode-s-2tm4/",
	"content": "#### 方法一：深度优先搜索\n\n我们可以采用深度优先搜索来遍历这棵二叉树，递归的同时记录当前的层号。\n\n相比哈希表，这里我们采用效率更高的动态数组来维护每一层的元素之和，如果当前层号达到了数组的长度，则将节点元素添加到数组末尾，否则更新对应层号的元素之和。\n\n然后遍历数组，找到元素之和最大，且层号最小的元素。\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxLevelSum(self, root: Optional[TreeNode]) -> int:\n        sum = []\n        def dfs(node: TreeNode, level: int) -> None:\n            if level == len(sum):\n                sum.append(node.val)\n            else:\n                sum[level] += node.val\n            if node.left:\n                dfs(node.left, level + 1)\n            if node.right:\n                dfs(node.right, level + 1)\n        dfs(root, 0)\n        return sum.index(max(sum)) + 1  # 层号从 1 开始\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    vector<int> sum;\n\n    void dfs(TreeNode *node, int level) {\n        if (level == sum.size()) {\n            sum.push_back(node->val);\n        } else {\n            sum[level] += node->val;\n        }\n        if (node->left) {\n            dfs(node->left, level + 1);\n        }\n        if (node->right) {\n            dfs(node->right, level + 1);\n        }\n    }\n\npublic:\n    int maxLevelSum(TreeNode *root) {\n        dfs(root, 0);\n        int ans = 0;\n        for (int i = 0; i < sum.size(); ++i) {\n            if (sum[i] > sum[ans]) {\n                ans = i;\n            }\n        }\n        return ans + 1; // 层号从 1 开始\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    private List<Integer> sum = new ArrayList<Integer>();\n\n    public int maxLevelSum(TreeNode root) {\n        dfs(root, 0);\n        int ans = 0;\n        for (int i = 0; i < sum.size(); ++i) {\n            if (sum.get(i) > sum.get(ans)) {\n                ans = i;\n            }\n        }\n        return ans + 1; // 层号从 1 开始\n    }\n\n    private void dfs(TreeNode node, int level) {\n        if (level == sum.size()) {\n            sum.add(node.val);\n        } else {\n            sum.set(level, sum.get(level) + node.val);\n        }\n        if (node.left != null) {\n            dfs(node.left, level + 1);\n        }\n        if (node.right != null) {\n            dfs(node.right, level + 1);\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    private IList<int> sum = new List<int>();\n\n    public int MaxLevelSum(TreeNode root) {\n        DFS(root, 0);\n        int ans = 0;\n        for (int i = 0; i < sum.Count; ++i) {\n            if (sum[i] > sum[ans]) {\n                ans = i;\n            }\n        }\n        return ans + 1; // 层号从 1 开始\n    }\n\n    private void DFS(TreeNode node, int level) {\n        if (level == sum.Count) {\n            sum.Add(node.val);\n        } else {\n            sum[level] += node.val;\n        }\n        if (node.left != null) {\n            DFS(node.left, level + 1);\n        }\n        if (node.right != null) {\n            DFS(node.right, level + 1);\n        }\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc maxLevelSum(root *TreeNode) (ans int) {\n    sum := []int{}\n    var dfs func(*TreeNode, int)\n    dfs = func(node *TreeNode, level int) {\n        if level == len(sum) {\n            sum = append(sum, node.Val)\n        } else {\n            sum[level] += node.Val\n        }\n        if node.Left != nil {\n            dfs(node.Left, level+1)\n        }\n        if node.Right != nil {\n            dfs(node.Right, level+1)\n        }\n    }\n    dfs(root, 0)\n    for i, s := range sum {\n        if s > sum[ans] {\n            ans = i\n        }\n    }\n    return ans + 1 // 层号从 1 开始\n}\n```\n\n```C [sol1-C]\n#define MAX_NODE_SIZE 10000\n\nvoid dfs(struct TreeNode *node, int level, int *sum, int *sumSize) {\n    if (level == *sumSize) {\n        sum[*sumSize] = node->val;\n        (*sumSize)++;\n    } else {\n        sum[level] += node->val;\n    }\n    if (node->left) {\n        dfs(node->left, level + 1, sum, sumSize);\n    }\n    if (node->right) {\n        dfs(node->right, level + 1, sum, sumSize);\n    }\n}\n\nint maxLevelSum(struct TreeNode* root) {\n    int *sum = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    int sumSize = 0;\n    dfs(root, 0, sum, &sumSize);\n    int ans = 0;\n    for (int i = 0; i < sumSize; ++i) {\n        if (sum[i] > sum[ans]) {\n            ans = i;\n        }\n    }\n    return ans + 1; // 层号从 1 开始\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maxLevelSum = function(root) {\n    const sum = [];\n    const dfs = (node, level) => {\n        if (level === sum.length) {\n            sum.push(node.val);\n        } else {\n            sum.splice(level, 1, sum[level] + node.val);\n        }\n        if (node.left) {\n            dfs(node.left, level + 1);\n        }\n        if (node.right) {\n            dfs(node.right, level + 1);\n        }\n    }\n    dfs(root, 0);\n    let ans = 0;\n    for (let i = 0; i < sum.length; ++i) {\n        if (sum[i] > sum[ans]) {\n            ans = i;\n        }\n    }\n    return ans + 1; // 层号从 1 开始\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点个数。\n\n- 空间复杂度：$O(n)$。最坏情况下二叉树是一条链，需要 $O(n)$ 的数组空间以及 $O(n)$ 的递归栈空间。\n\n#### 方法二：广度优先搜索\n\n由于计算的是每层的元素之和，用广度优先搜索来遍历这棵树会更加自然。\n\n对于广度优先搜索，我们可以用队列来实现。初始时，队列只包含根节点；然后不断出队，将子节点入队，直到队列为空。\n\n如果直接套用方法一的思路，我们需要在队列中存储节点和节点的层号。另一种做法是一次遍历完一整层的节点，遍历的同时，累加该层的节点的元素之和，同时用这层的节点得到下一层的节点，这种做法不需要记录层号。\n\n为了代码实现的方便，我们可以使用两个动态数组，第一个数组 $q$ 为当前层的节点，第二个数组 $\\textit{nq}$ 为下一层的节点。遍历 $q$ 中节点的同时，把子节点加到 $\\textit{nq}$ 中。遍历完当前层后，将 $q$ 置为 $\\textit{nq}$。\n\n```Python [sol2-Python3]\nclass Solution:\n    def maxLevelSum(self, root: Optional[TreeNode]) -> int:\n        ans, maxSum = 1, root.val\n        level, q = 1, [root]\n        while q:\n            sum, nq = 0, []\n            for node in q:\n                sum += node.val\n                if node.left:\n                    nq.append(node.left)\n                if node.right:\n                    nq.append(node.right)\n            if sum > maxSum:\n                ans, maxSum = level, sum\n            q = nq\n            level += 1\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int maxLevelSum(TreeNode *root) {\n        int ans = 1, maxSum = root->val;\n        vector<TreeNode*> q = {root};\n        for (int level = 1; !q.empty(); ++level) {\n            vector<TreeNode*> nq;\n            int sum = 0;\n            for (auto node : q) {\n                sum += node->val;\n                if (node->left) {\n                    nq.emplace_back(node->left);\n                }\n                if (node->right) {\n                    nq.emplace_back(node->right);\n                }\n            }\n            if (sum > maxSum) {\n                maxSum = sum;\n                ans = level;\n            }\n            q = move(nq);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int maxLevelSum(TreeNode root) {\n        int ans = 1, maxSum = root.val;\n        List<TreeNode> q = new ArrayList<TreeNode>();\n        q.add(root);\n        for (int level = 1; !q.isEmpty(); ++level) {\n            List<TreeNode> nq = new ArrayList<TreeNode>();\n            int sum = 0;\n            for (TreeNode node : q) {\n                sum += node.val;\n                if (node.left != null) {\n                    nq.add(node.left);\n                }\n                if (node.right != null) {\n                    nq.add(node.right);\n                }\n            }\n            if (sum > maxSum) {\n                maxSum = sum;\n                ans = level;\n            }\n            q = nq;\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int MaxLevelSum(TreeNode root) {\n        int ans = 1, maxSum = root.val;\n        IList<TreeNode> q = new List<TreeNode>();\n        q.Add(root);\n        for (int level = 1; q.Count > 0; ++level) {\n            IList<TreeNode> nq = new List<TreeNode>();\n            int sum = 0;\n            foreach (TreeNode node in q) {\n                sum += node.val;\n                if (node.left != null) {\n                    nq.Add(node.left);\n                }\n                if (node.right != null) {\n                    nq.Add(node.right);\n                }\n            }\n            if (sum > maxSum) {\n                maxSum = sum;\n                ans = level;\n            }\n            q = nq;\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc maxLevelSum(root *TreeNode) int {\n    ans, maxSum := 1, root.Val\n    q := []*TreeNode{root}\n    for level := 1; len(q) > 0; level++ {\n        tmp := q\n        q = nil\n        sum := 0\n        for _, node := range tmp {\n            sum += node.Val\n            if node.Left != nil {\n                q = append(q, node.Left)\n            }\n            if node.Right != nil {\n                q = append(q, node.Right)\n            }\n        }\n        if sum > maxSum {\n            ans, maxSum = level, sum\n        }\n    }\n    return ans\n}\n```\n\n```C [sol2-C]\n#define MAX_NODE_SIZE 10000\n\nint maxLevelSum(struct TreeNode* root){\n    int ans = 1, maxSum = root->val;\n    struct TreeNode **q = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * MAX_NODE_SIZE);\n    struct TreeNode **nq = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * MAX_NODE_SIZE);\n    int qSize = 0;\n    q[qSize++] = root;\n    for (int level = 1; qSize > 0; ++level) {\n        int sum = 0, nqSize = 0;\n        for (int i = 0; i < qSize; i++) {\n            sum += q[i]->val;\n            if (q[i]->left) {\n                nq[nqSize++] = q[i]->left;\n            }\n            if (q[i]->right) {\n                nq[nqSize++] = q[i]->right;\n            }\n        }\n        if (sum > maxSum) {\n            maxSum = sum;\n            ans = level;\n        }\n        struct TreeNode *tmp = q;\n        q = nq;\n        nq = tmp;\n        qSize = nqSize;\n    }\n    free(q);\n    free(nq);\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar maxLevelSum = function(root) {\n    let ans = 1, maxSum = root.val;\n    let q = [];\n    q.push(root);\n    for (let level = 1; q.length > 0; ++level) {\n        const nq = [];\n        let sum = 0;\n        for (const node of q) {\n            sum += node.val;\n            if (node.left) {\n                nq.push(node.left);\n            }\n            if (node.right) {\n                nq.push(node.right);\n            }\n        }\n        if (sum > maxSum) {\n            maxSum = sum;\n            ans = level;\n        }\n        q = nq;\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点个数。\n\n- 空间复杂度：$O(n)$。最坏情况下，数组中有 $O(n)$ 个节点。"
}