{
	"titleSlug": "strange-printer-ii",
	"slug": "by-jushuai_lfx-ww7z",
	"url": "https://leetcode-cn.com/problems/strange-printer-ii/solution/by-jushuai_lfx-ww7z/",
	"content": "### 解题思路\n对于某个颜色c,对于颜色为c的点(xi,yi)的最小值和最大值组成的矩形内的其他颜色a，相当于c依赖于a，要先打印a颜色，再打印c颜色。相对于建一条边a->c。拓扑排序的思路由此得出。\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool isPrintable(vector<vector<int>>& targetGrid) {\n        int log[61][2][2];\n        for (int i = 0; i <= 60; ++i) {\n            for (int j = 0; j < 2; ++j) {\n                log[i][0][j] = INT_MAX;\n            }\n            for (int j = 0; j < 2; ++j) {\n                log[i][1][j] = 0;\n            }\n        }\n        int row = targetGrid.size();\n        int col = targetGrid[0].size();\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                log[targetGrid[i][j]][0][0] = min(log[targetGrid[i][j]][0][0], i);\n                log[targetGrid[i][j]][0][1] = min(log[targetGrid[i][j]][0][1], j);\n                log[targetGrid[i][j]][1][0] = max(log[targetGrid[i][j]][1][0], i);\n                log[targetGrid[i][j]][1][1] = max(log[targetGrid[i][j]][1][1], j);\n            }\n        }\n        vector<set<int>> adj(61);\n        vector<int> degree(61, 0);\n        for (int i = 0; i < 61; ++i) {\n            if (log[i][0][0] == INT_MAX) {\n                continue;\n            }\n            for (int m = log[i][0][0]; m <= log[i][1][0]; ++m) {\n                for (int n = log[i][0][1]; n <= log[i][1][1]; ++n) {\n                    if (targetGrid[m][n] != i) {\n                        if (adj[targetGrid[m][n]].count(i)) {\n                            continue;\n                        }\n                        adj[targetGrid[m][n]].insert(i);\n                        degree[i]++;\n                    }\n                }\n            }\n        }\n        queue<int> q;\n        for (int i = 0; i < 61; ++i) {\n            if (degree[i] == 0) {\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            int front = q.front();\n            q.pop();\n            for (int next : adj[front]) {\n                degree[next]--;\n                if (degree[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n        for (int i = 0; i < 61; ++i) {\n            if (degree[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```"
}