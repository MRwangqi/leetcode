{
	"titleSlug": "check-permutation-lcci",
	"slug": "pan-ding-shi-fou-hu-wei-zi-fu-zhong-pai-dmkmc",
	"url": "https://leetcode-cn.com/problems/check-permutation-lcci/solution/pan-ding-shi-fou-hu-wei-zi-fu-zhong-pai-dmkmc/",
	"content": "#### 方法一：排序\n\n字符串 $s_1$ 和 $s_2$ 互为字符重排等价于「两个字符串排序后相等」。因此我们可以对字符串 $s_1$ 和 $s_2$ 分别排序，看排序后的字符串是否相等即可判断。此外，如果 $s_1$ 和 $s_2$ 的长度不同，$s_2$ 必然不是 $s_1$ 的异位词。\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean CheckPermutation(String s1, String s2) {\n        if (s1.length() != s2.length()) {\n            return false;\n        }\n        char[] str1 = s1.toCharArray();\n        char[] str2 = s2.toCharArray();\n        Arrays.sort(str1);\n        Arrays.sort(str2);\n        return Arrays.equals(str1, str2);\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar CheckPermutation = function(s1, s2) {\n    return s1.length == s2.length && [...s1].sort().join('') === [...s2].sort().join('')\n};\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool CheckPermutation(string s1, string s2) {\n        if (s1.length() != s2.length()) {\n            return false;\n        }\n        sort(s1.begin(), s1.end());\n        sort(s2.begin(), s2.end());\n        return s1 == s2;\n    }\n};\n```\n\n```Golang [sol1-Golang]\nfunc CheckPermutation(s1 string, s2 string) bool {\n    b1, b2 := []byte(s1), []byte(s2)\n    sort.Slice(b1, func(i, j int) bool { return b1[i] < b1[j] })\n    sort.Slice(b2, func(i, j int) bool { return b2[i] < b2[j] })\n    return string(b1) == string(b2)\n}\n```\n\n```C [sol1-C]\nint cmp(const void* _a, const void* _b) {\n    char a = *(char*)_a, b = *(char*)_b;\n    return a - b;\n}\n\nbool CheckPermutation(char* s1, char* s2) {\n    int len_s1 = strlen(s1), len_s2 = strlen(s2);\n    if (len_s1 != len_s2) {\n        return false;\n    }\n    qsort(s1, len_s1, sizeof(char), cmp);\n    qsort(s2, len_s2, sizeof(char), cmp);\n    return strcmp(s1, s2) == 0;\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(n \\log n)$，其中 $n$ 为 $s_1$ 的长度。排序的时间复杂度为 $O(n\\log n)$，比较两个字符串是否相等时间复杂度为 $O(n)$，因此总体时间复杂度为 $O(n \\log n+n)=O(n\\log n)$。\n\n* 空间复杂度：$O(\\log n)$。排序需要 $O(\\log n)$ 的空间复杂度。注意，在某些语言（比如 Java & JavaScript）中字符串是不可变的，因此我们需要额外的 $O(n)$ 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：\n   * 这依赖于语言的细节；\n   * 这取决于函数的设计方式，例如，可以将函数参数类型更改为 `char[]`。\n\n#### 方法二：哈希表\n\n从另一个角度考虑，字符串 $s_1$ 和 $s_2$ 互为字符重排等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含 $128$ 种不同的字符，因此我们可以维护一个长度为 $128$ 的频次数组 $\\textit{table}$，先遍历记录字符串 $s_1$ 中字符出现的频次，然后遍历字符串 $s_2$，减去 $\\textit{table}$ 中对应的频次，如果出现 $\\textit{table}[i]<0$，则说明 $s_2$ 包含一个不在 $s_1$ 中的额外字符，返回 $\\text{false}$ 即可。\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean CheckPermutation(String s1, String s2) {\n        if (s1.length() != s2.length()) {\n            return false;\n        }\n        int[] table = new int[128];\n        for (int i = 0; i < s1.length(); i++) {\n            table[s1.charAt(i)]++;\n        }\n        for (int i = 0; i < s2.length(); i++) {\n            table[s2.charAt(i)]--;\n            if (table[s2.charAt(i)] < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar CheckPermutation = function(s1, s2) {\n    if (s1.length !== s2.length) {\n        return false;\n    }\n    const table = new Array(128).fill(0);\n    for (let i = 0; i < s1.length; ++i) {\n        table[s1.codePointAt(i)]++;\n    }\n    for (let i = 0; i < s2.length; ++i) {\n        table[s2.codePointAt(i)]--;\n        if (table[s2.codePointAt(i)] < 0) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool CheckPermutation(string s1, string s2) {\n        if (s1.length() != s2.length()) {\n            return false;\n        }\n        vector<int> table(128, 0);\n        for (auto& ch: s1) {\n            table[ch]++;\n        }\n        for (auto& ch: s2) {\n            table[ch]--;\n            if (table[ch] < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n```Golang [sol2-Golang]\nfunc CheckPermutation(s1 string, s2 string) bool {\n    var c1, c2 [128]int\n    for _, ch := range s1 {\n        c1[ch]++\n    }\n    for _, ch := range s2 {\n        c2[ch]++\n    }\n    return c1 == c2\n}\n```\n\n```C [sol2-C]\nbool CheckPermutation(char* s1, char* s2) {\n    int len_s1 = strlen(s1), len_s2 = strlen(s2);\n    if (len_s1 != len_s2) {\n        return false;\n    }\n    int table[128];\n    memset(table, 0, sizeof(table));\n    for (int i = 0; i < len_s1; ++i) {\n        table[s1[i]]++;\n    }\n    for (int i = 0; i < len_s2; ++i) {\n        table[s2[i]]--;\n        if (table[s2[i]] < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(n)$，其中 $n$ 为 $s_1$ 的长度。\n\n* 空间复杂度：$O(S)$，其中 $S$ 为字符集大小，此处 $S=128$。"
}