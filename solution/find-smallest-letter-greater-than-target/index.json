{
	"titleSlug": "find-smallest-letter-greater-than-target",
	"slug": "xun-zhao-bi-mu-biao-zi-mu-da-de-zui-xiao-lhm7",
	"url": "https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/solution/xun-zhao-bi-mu-biao-zi-mu-da-de-zui-xiao-lhm7/",
	"content": "#### 方法一：线性查找\n\n由于给定的列表已经按照递增顺序排序，因此可以从左到右遍历列表，找到第一个比目标字母大的字母，即为比目标字母大的最小字母。\n\n如果目标字母小于列表中的最后一个字母，则一定可以在列表中找到比目标字母大的最小字母。如果目标字母大于或等于列表中的最后一个字母，则列表中不存在比目标字母大的字母，根据循环出现的顺序，列表的首个字母是比目标字母大的最小字母。\n\n```Python [sol1-Python3]\nclass Solution:\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\n        return next((letter for letter in letters if letter > target), letters[0])\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public char nextGreatestLetter(char[] letters, char target) {\n        int length = letters.length;\n        char nextGreater = letters[0];\n        for (int i = 0; i < length; i++) {\n            if (letters[i] > target) {\n                nextGreater = letters[i];\n                break;\n            }\n        }\n        return nextGreater;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public char NextGreatestLetter(char[] letters, char target) {\n        int length = letters.Length;\n        char nextGreater = letters[0];\n        for (int i = 0; i < length; i++) {\n            if (letters[i] > target) {\n                nextGreater = letters[i];\n                break;\n            }\n        }\n        return nextGreater;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    char nextGreatestLetter(vector<char>& letters, char target) {\n        for (char letter : letters) {\n            if (letter > target) {\n                return letter;\n            }\n        }\n        return letters[0];\n    }\n};\n```\n\n```C [sol1-C]\nchar nextGreatestLetter(char* letters, int lettersSize, char target){\n    for (int i = 0; i < lettersSize; i++) {\n        if (letters[i] > target) {\n            return letters[i];\n        }\n    }\n    return letters[0];\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar nextGreatestLetter = function(letters, target) {\n    const length = letters.length;\n    let nextGreater = letters[0];\n    for (let i = 0; i < length; i++) {\n        if (letters[i] > target) {\n            nextGreater = letters[i];\n            break;\n        }\n    }\n    return nextGreater;\n};\n```\n\n```go [sol1-Golang]\nfunc nextGreatestLetter(letters []byte, target byte) byte {\n    for _, letter := range letters {\n        if letter > target {\n            return letter\n        }\n    }\n    return letters[0]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是列表 $\\textit{letters}$ 的长度。需要遍历列表一次寻找比目标字母大的最小字母。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：二分查找\n\n利用列表有序的特点，可以使用二分查找降低时间复杂度。\n\n首先比较目标字母和列表中的最后一个字母，当目标字母大于或等于列表中的最后一个字母时，答案是列表的首个字母。当目标字母小于列表中的最后一个字母时，列表中一定存在比目标字母大的字母，可以使用二分查找得到比目标字母大的最小字母。\n\n初始时，二分查找的范围是整个列表的下标范围。每次比较当前下标处的字母和目标字母，如果当前下标处的字母大于目标字母，则在当前下标以及当前下标的左侧继续查找，否则在当前下标的右侧继续查找。\n\n```Python [sol2-Python3]\nclass Solution:\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\n        return letters[bisect_right(letters, target)] if target < letters[-1] else letters[0]\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public char nextGreatestLetter(char[] letters, char target) {\n        int length = letters.length;\n        if (target >= letters[length - 1]) {\n            return letters[0];\n        }\n        int low = 0, high = length - 1;\n        while (low < high) {\n            int mid = (high - low) / 2 + low;\n            if (letters[mid] > target) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return letters[low];\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public char NextGreatestLetter(char[] letters, char target) {\n        int length = letters.Length;\n        if (target >= letters[length - 1]) {\n            return letters[0];\n        }\n        int low = 0, high = length - 1;\n        while (low < high) {\n            int mid = (high - low) / 2 + low;\n            if (letters[mid] > target) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return letters[low];\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    char nextGreatestLetter(vector<char> &letters, char target) {\n        return target < letters.back() ? *upper_bound(letters.begin(), letters.end() - 1, target) : letters[0];\n    }\n};\n```\n\n```C [sol2-C]\nchar nextGreatestLetter(char* letters, int lettersSize, char target){\n    if (target >= letters[lettersSize - 1]) {\n        return letters[0];\n    }\n    int low = 0, high = lettersSize - 1;\n    while (low < high) {\n        int mid = (high - low) / 2 + low;\n        if (letters[mid] > target) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return letters[low];\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar nextGreatestLetter = function(letters, target) {\n    const length = letters.length;\n    if (target >= letters[length - 1]) {\n        return letters[0];\n    }\n    let low = 0, high = length - 1;\n    while (low < high) {\n        const mid = Math.floor((high - low) / 2) + low;\n        if (letters[mid] > target) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return letters[low];\n};\n```\n\n```go [sol2-Golang]\nfunc nextGreatestLetter(letters []byte, target byte) byte {\n    if target >= letters[len(letters)-1] {\n        return letters[0]\n    }\n    i := sort.Search(len(letters)-1, func(i int) bool { return letters[i] > target })\n    return letters[i]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$，其中 $n$ 是列表 $\\textit{letters}$ 的长度。二分查找的时间复杂度是 $O(\\log n)$。\n\n- 空间复杂度：$O(1)$。"
}