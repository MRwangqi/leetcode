{
	"titleSlug": "longest-word-in-dictionary-through-deleting",
	"slug": "tong-guo-shan-chu-zi-mu-pi-pei-dao-zi-di-at66",
	"url": "https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/solution/tong-guo-shan-chu-zi-mu-pi-pei-dao-zi-di-at66/",
	"content": "#### 方法一：双指针\n\n**思路和算法**\n\n根据题意，我们需要解决两个问题：\n\n- 如何判断 $\\textit{dictionary}$ 中的字符串 $t$ 是否可以通过删除 $s$ 中的某些字符得到；\n\n- 如何找到长度最长且字典序最小的字符串。\n\n第 $1$ 个问题实际上就是判断 $t$ 是否是 $s$ 的子序列。因此只要能找到任意一种 $t$ 在 $s$ 中出现的方式，即可认为 $t$ 是 $s$ 的子序列。而当我们从前往后匹配时，可以发现每次贪心地匹配最靠前的字符是最优决策。\n\n> 假定当前需要匹配字符 $c$，而字符 $c$ 在 $s$ 中的位置 $x_1$ 和 $x_2$ 出现（$x_1 < x_2$），那么贪心取 $x_1$ 是最优解，因为 $x_2$ 后面能取到的字符，$x_1$ 也都能取到，并且通过 $x_1$ 与 $x_2$ 之间的可选字符，更有希望能匹配成功。\n\n这样，我们初始化两个指针 $i$ 和 $j$，分别指向 $t$ 和 $s$ 的初始位置。每次贪心地匹配，匹配成功则 $i$ 和 $j$ 同时右移，匹配 $t$ 的下一个位置，匹配失败则 $j$ 右移，$i$ 不变，尝试用 $s$ 的下一个字符匹配 $t$。\n\n最终如果 $i$ 移动到 $t$ 的末尾，则说明 $t$ 是 $s$ 的子序列。\n\n第 $2$ 个问题可以通过遍历 $\\textit{dictionary}$ 中的字符串，并维护当前长度最长且字典序最小的字符串来找到。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findLongestWord(self, s: str, dictionary: List[str]) -> str:\n        res = \"\"\n        for t in dictionary:\n            i = j = 0\n            while i < len(t) and j < len(s):\n                if t[i] == s[j]:\n                    i += 1\n                j += 1\n            if i == len(t):\n                if len(t) > len(res) or (len(t) == len(res) and t < res):\n                    res = t\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String findLongestWord(String s, List<String> dictionary) {\n        String res = \"\";\n        for (String t : dictionary) {\n            int i = 0, j = 0;\n            while (i < t.length() && j < s.length()) {\n                if (t.charAt(i) == s.charAt(j)) {\n                    ++i;\n                }\n                ++j;\n            }\n            if (i == t.length()) {\n                if (t.length() > res.length() || (t.length() == res.length() && t.compareTo(res) < 0)) {\n                    res = t;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string FindLongestWord(string s, IList<string> dictionary) {\n        string res = \"\";\n        foreach (string t in dictionary) {\n            int i = 0, j = 0;\n            while (i < t.Length && j < s.Length) {\n                if (t[i] == s[j]) {\n                    ++i;\n                }\n                ++j;\n            }\n            if (i == t.Length) {\n                if (t.Length > res.Length || (t.Length == res.Length && t.CompareTo(res) < 0)) {\n                    res = t;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc findLongestWord(s string, dictionary []string) (ans string) {\n    for _, t := range dictionary {\n        i := 0\n        for j := range s {\n            if s[j] == t[i] {\n                i++\n                if i == len(t) {\n                    if len(t) > len(ans) || len(t) == len(ans) && t < ans {\n                        ans = t\n                    }\n                    break\n                }\n            }\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findLongestWord = function(s, dictionary) {\n    let res = \"\";\n    for (const t of dictionary) {\n        let i = 0, j = 0;\n        while (i < t.length && j < s.length) {\n            if (t[i] === s[j]) {\n                ++i;\n            }\n            ++j;\n        }\n        if (i === t.length) {\n            if (t.length > res.length || (t.length === res.length && t < res)) {\n                res = t;\n            }\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(d \\times (m+n))$，其中 $d$ 表示 $\\textit{dictionary}$ 的长度，$m$ 表示 $s$ 的长度，$n$ 表示 $\\textit{dictionary}$ 中字符串的平均长度。我们需要遍历 $\\textit{dictionary}$ 中的 $d$ 个字符串，每个字符串需要 $O(n+m)$ 的时间复杂度来判断该字符串是否为 $s$ 的子序列。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：排序\n\n**思路和算法**\n\n在方法一的基础上，我们尝试通过对 $\\textit{dictionary}$ 的预处理，来优化第 $2$ 个问题的处理。\n\n我们可以先将 $\\textit{dictionary}$ 依据字符串长度的降序和字典序的升序进行排序，然后从前向后找到第一个符合条件的字符串直接返回即可。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def findLongestWord(self, s: str, dictionary: List[str]) -> str:\n        dictionary.sort(key=lambda x: (-len(x), x))\n        for t in dictionary:\n            i = j = 0\n            while i < len(t) and j < len(s):\n                if t[i] == s[j]:\n                    i += 1\n                j += 1\n            if i == len(t):\n                return t\n        return \"\"\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public String findLongestWord(String s, List<String> dictionary) {\n        Collections.sort(dictionary, new Comparator<String>() {\n            public int compare(String word1, String word2) {\n                if (word1.length() != word2.length()) {\n                    return word2.length() - word1.length();\n                } else {\n                    return word1.compareTo(word2);\n                }\n            }\n        });\n        for (String t : dictionary) {\n            int i = 0, j = 0;\n            while (i < t.length() && j < s.length()) {\n                if (t.charAt(i) == s.charAt(j)) {\n                    ++i;\n                }\n                ++j;\n            }\n            if (i == t.length()) {\n                return t;\n            }\n        }\n        return \"\";\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc findLongestWord(s string, dictionary []string) string {\n    sort.Slice(dictionary, func(i, j int) bool {\n        a, b := dictionary[i], dictionary[j]\n        return len(a) > len(b) || len(a) == len(b) && a < b\n    })\n    for _, t := range dictionary {\n        i := 0\n        for j := range s {\n            if s[j] == t[i] {\n                i++\n                if i == len(t) {\n                    return t\n                }\n            }\n        }\n    }\n    return \"\"\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar findLongestWord = function(s, dictionary) {\n    dictionary.sort((word1, word2) => {\n        if (word1.length !== word2.length) {\n            return word2.length - word1.length;\n        } else {\n            return word1.localeCompare(word2);\n        }\n    });\n    console.log(dictionary)\n\n    for (const t of dictionary) {\n        let i = 0, j = 0;\n        while (i < t.length && j < s.length) {\n            if (t[i] === s[j]) {\n                ++i;\n            }\n            ++j;\n        }\n        if (i === t.length) {\n            return t;\n        }\n    }\n    return \"\";\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(d \\times m \\times \\log d + d \\times (m+n))$，其中 $d$ 表示 $\\textit{dictionary}$ 的长度，$m$ 表示 $s$ 的长度，$n$ 表示 $\\textit{dictionary}$ 中字符串的平均长度。我们需要 $O(d \\times m \\times \\log d)$ 的时间来排序 $\\textit{dictionary}$；在最坏的情况下，我们需要 $O(d \\times (m+n))$ 来找到第一个符合条件的字符串。\n\n- 空间复杂度：$O(d \\times m)$，为排序的开销。\n\n#### 方法三：动态规划\n\n**思路和算法**\n\n在方法一的基础上，我们考虑通过对字符串 $s$ 的预处理，来优化第 $1$ 个问题的处理。\n\n考虑前面的双指针的做法，我们注意到我们有大量的时间用于在 $s$ 中找到下一个匹配字符。\n\n这样我们通过预处理，得到：对于 $s$ 的每一个位置，从该位置开始往后每一个字符第一次出现的位置。\n\n我们可以使用动态规划的方法实现预处理，令 $f[i][j]$ 表示字符串 $s$ 中从位置 $i$ 开始往后字符 $j$ 第一次出现的位置。在进行状态转移时，如果 $s$ 中位置 $i$ 的字符就是 $j$，那么 $f[i][j]=i$，否则 $j$ 出现在位置 $i+1$ 开始往后，即 $f[i][j]=f[i+1][j]$；因此我们要倒过来进行动态规划，从后往前枚举 $i$。\n\n这样我们可以写出状态转移方程：\n$$\nf[i][j]=\n\\begin{cases}\ni, & s[i]=j \\\\\nf[i+1][j], & s[i] \\ne j\n\\end{cases}\n$$\n假定下标从 $0$ 开始，那么 $f[i][j]$ 中有 $0 \\leq i \\leq m-1$ ，对于边界状态 $f[m-1][..]$，我们置 $f[m][..]$ 为 $m$，让 $f[m-1][..]$ 正常进行转移。这样如果 $f[i][j]=m$，则表示从位置 $i$ 开始往后不存在字符 $j$。\n\n这样，我们可以利用 $f$ 数组，每次 $O(1)$ 地跳转到下一个位置，直到位置变为 $m$ 或 $t$ 中的每一个字符都匹配成功。\n\n**代码**\n\n```Python [sol3-Python3]\nclass Solution:\n    def findLongestWord(self, s: str, dictionary: List[str]) -> str:\n        m = len(s)\n        f = [[0] * 26 for _ in range(m)]\n        f.append([m] * 26)\n\n        for i in range(m - 1, -1, -1):\n            for j in range(26):\n                if ord(s[i]) == j + 97:\n                    f[i][j] = i\n                else:\n                    f[i][j] = f[i + 1][j]\n\n        res = \"\"\n        for t in dictionary:\n            match = True\n            j = 0\n            for i in range(len(t)):\n                if f[j][ord(t[i]) - 97] == m:\n                    match = False\n                    break\n                j = f[j][ord(t[i]) - 97] + 1\n            if match:\n                if len(t) > len(res) or (len(t) == len(res) and t < res):\n                    res = t\n        return res\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public String findLongestWord(String s, List<String> dictionary) {\n        int m = s.length();\n        int[][] f = new int[m + 1][26];\n        Arrays.fill(f[m], m);\n\n        for (int i = m - 1; i >= 0; --i) {\n            for (int j = 0; j < 26; ++j) {\n                if (s.charAt(i) == (char) ('a' + j)) {\n                    f[i][j] = i;\n                } else {\n                    f[i][j] = f[i + 1][j];\n                }\n            }\n        }\n        String res = \"\";\n        for (String t : dictionary) {\n            boolean match = true;\n            int j = 0;\n            for (int i = 0; i < t.length(); ++i) {\n                if (f[j][t.charAt(i) - 'a'] == m) {\n                    match = false;\n                    break;\n                }\n                j = f[j][t.charAt(i) - 'a'] + 1;\n            }\n            if (match) {\n                if (t.length() > res.length() ||  (t.length() == res.length() && t.compareTo(res) < 0)) {\n                    res = t;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public string FindLongestWord(string s, IList<string> dictionary) {\n        int m = s.Length;\n        int[,] f = new int[m + 1, 26];\n        for (int j = 0; j < 26; ++j) {\n            f[m, j] = m;\n        }\n\n        for (int i = m - 1; i >= 0; --i) {\n            for (int j = 0; j < 26; j++) {\n                if (s[i] == (char) ('a' + j)) {\n                    f[i, j] = i;\n                } else {\n                    f[i, j] = f[i + 1, j];\n                }\n            }\n        }\n        string res = \"\";\n        foreach (string t in dictionary) {\n            bool match = true;\n            int j = 0;\n            for (int i = 0; i < t.Length; ++i) {\n                if (f[j, t[i] - 'a'] == m) {\n                    match = false;\n                    break;\n                }\n                j = f[j, t[i] - 'a'] + 1;\n            }\n            if (match) {\n                if (t.Length > res.Length ||  (t.Length == res.Length && t.CompareTo(res) < 0)) {\n                    res = t;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```go [sol3-Golang]\nfunc findLongestWord(s string, dictionary []string) (ans string) {\n    m := len(s)\n    f := make([][26]int, m+1)\n    for i := range f[m] {\n        f[m][i] = m\n    }\n    for i := m - 1; i >= 0; i-- {\n        f[i] = f[i+1]\n        f[i][s[i]-'a'] = i\n    }\n\nouter:\n    for _, t := range dictionary {\n        j := 0\n        for _, ch := range t {\n            if f[j][ch-'a'] == m {\n                continue outer\n            }\n            j = f[j][ch-'a'] + 1\n        }\n        if len(t) > len(ans) || len(t) == len(ans) && t < ans {\n            ans = t\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar findLongestWord = function(s, dictionary) {\n    const m = s.length;\n    const f = new Array(m + 1).fill(0).map(() => new Array(26).fill(m));\n\n    for (let i = m - 1; i >= 0; --i) {\n        for (let j = 0; j < 26; ++j) {\n            if (s[i] === String.fromCharCode('a'.charCodeAt() + j)) {\n                f[i][j] = i;\n            } else {\n                f[i][j] = f[i + 1][j];\n            }\n        }\n    }\n    let res = \"\";\n    for (const t of dictionary) {\n        let match = true;\n        let j = 0;\n        for (let i = 0; i < t.length; ++i) {\n            if (f[j][t[i].charCodeAt() - 'a'.charCodeAt()] === m) {\n                match = false;\n                break;\n            }\n            j = f[j][t[i].charCodeAt() - 'a'.charCodeAt()] + 1;\n        }\n        if (match) {\n            if (t.length > res.length ||  (t.length === res.length && t.localeCompare(res) < 0)) {\n                res = t;\n            }\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m \\times |\\Sigma|+d \\times n)$，其中 $d$ 表示 $\\textit{dictionary}$ 的长度，$\\Sigma$ 为字符集，在本题中字符串只包含英文小写字母，故 $|\\Sigma|=26$；$m$ 表示字符串 $s$ 的长度，$n$ 表示 $\\textit{dictionary}$ 中字符串的平均长度。预处理的时间复杂度为 $O(m \\times |\\Sigma|)$；判断 $d$ 个字符串是否为 $s$ 的子序列的事件复杂度为 $O(d \\times n)$。\n\n- 空间复杂度：$O(m \\times |\\Sigma|)$，为动态规划数组的开销。"
}