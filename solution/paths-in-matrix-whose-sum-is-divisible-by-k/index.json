{
	"titleSlug": "paths-in-matrix-whose-sum-is-divisible-by-k",
	"slug": "dong-tai-gui-hua-pythonjavacgo-by-endles-94wq",
	"url": "https://leetcode-cn.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/solution/dong-tai-gui-hua-pythonjavacgo-by-endles-94wq/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV11d4y1i7Gs) 已出炉，**包括记忆化搜索和文末思考题的讲解**，欢迎点赞，在评论区分享你对这场周赛的看法~\r\n\r\n---\r\n\r\n套路：把路径和模 $k$ 的结果当成一个扩展维度。\r\n\r\n具体地，定义 $f[i][j][v]$ 表示从左上走到 $(i,j)$，且路径和模 $k$ 的结果为 $v$ 时的路径数。\r\n\r\n初始值 $f[0][0][\\textit{grid}[0][0]\\bmod k] = 1$，答案为 $f[m-1][n-1][0]$。\r\n\r\n考虑从左边和上边转移过来，则有\r\n\r\n$$\r\nf[i][j][(v+\\textit{grid}[i][j])\\bmod k] = f[i][j-1][v] + f[i-1][j][v]\r\n$$\r\n\r\n代码实现时，为了避免判断是否越界，可以把下标都加一。此时可以设初始值 $f[0][1][0] = 1$（或者 $f[1][0][0] = 1$）简化一点点代码。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\r\n        MOD = 10 ** 9 + 7\r\n        m, n = len(grid), len(grid[0])\r\n        f = [[[0] * k for _ in range(n + 1)] for _ in range(m + 1)]\r\n        f[0][1][0] = 1\r\n        for i, row in enumerate(grid):\r\n            for j, x in enumerate(row):\r\n                for v in range(k):\r\n                    f[i + 1][j + 1][(v + x) % k] = (f[i + 1][j][v] + f[i][j + 1][v]) % MOD\r\n        return f[m][n][0]\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int numberOfPaths(int[][] grid, int k) {\r\n        final var mod = (int) 1e9 + 7;\r\n        int m = grid.length, n = grid[0].length;\r\n        var f = new int[m + 1][n + 1][k];\r\n        f[0][1][0] = 1;\r\n        for (var i = 0; i < m; ++i)\r\n            for (var j = 0; j < n; ++j)\r\n                for (var v = 0; v < k; ++v)\r\n                    f[i + 1][j + 1][(v + grid[i][j]) % k] = (f[i + 1][j][v] + f[i][j + 1][v]) % mod;\r\n        return f[m][n][0];\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int numberOfPaths(vector<vector<int>> &grid, int k) {\r\n        const int mod = 1e9 + 7;\r\n        int m = grid.size(), n = grid[0].size(), f[m + 1][n + 1][k];\r\n        memset(f, 0, sizeof(f));\r\n        f[0][1][0] = 1;\r\n        for (int i = 0; i < m; ++i)\r\n            for (int j = 0; j < n; ++j)\r\n                for (int v = 0; v < k; ++v)\r\n                    f[i + 1][j + 1][(v + grid[i][j]) % k] = (f[i + 1][j][v] + f[i][j + 1][v]) % mod;\r\n        return f[m][n][0];\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc numberOfPaths(grid [][]int, k int) int {\r\n\tconst mod int = 1e9 + 7\r\n\tm, n := len(grid), len(grid[0])\r\n\tf := make([][][]int, m+1)\r\n\tfor i := range f {\r\n\t\tf[i] = make([][]int, n+1)\r\n\t\tfor j := range f[i] {\r\n\t\t\tf[i][j] = make([]int, k)\r\n\t\t}\r\n\t}\r\n\tf[0][1][0] = 1\r\n\tfor i, row := range grid {\r\n\t\tfor j, x := range row {\r\n\t\t\tfor v := 0; v < k; v++ {\r\n\t\t\t\tf[i+1][j+1][(v+x)%k] = (f[i+1][j][v] + f[i][j+1][v]) % mod\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn f[m][n][0]\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(mnk)$，其中 $m$ 和 $n$ 分别为 $\\textit{grid}$ 的行数和列数。\r\n- 空间复杂度：$O(mnk)$。\r\n\r\n#### 思考题\r\n\r\n如果 $n=m=20$ 但是 $k=10^{18}$，要怎么做？\r\n\r\n折半枚举。具体见视频讲解，题目见 CF1006F。\r\n\r\n力扣上的折半枚举题目：\r\n\r\n- [805. 数组的均值分割](https://leetcode.cn/problems/split-array-with-same-average/)\r\n- [2035. 将数组分成两个数组并最小化数组和的差](https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/)\r\n"
}