{
	"titleSlug": "sum-of-subarray-minimums",
	"slug": "zi-shu-zu-de-zui-xiao-zhi-zhi-he-by-leetcode",
	"url": "https://leetcode-cn.com/problems/sum-of-subarray-minimums/solution/zi-shu-zu-de-zui-xiao-zhi-zhi-he-by-leetcode/",
	"content": "#### 方法 1：前驱 / 后继数组\n\n**想法**\n\n考虑所有满足 `A[j]` 为最右且最小的元素的子序列个数 `#(j)`，那么结果就是 `sum #(j) * A[j]`。（我们必须考虑*最右*这样才可以构造互不相交的子序列，否则会出现多次计算，因为一个数组的最小值可能不唯一。）\n\n这就变成考虑最小的下标 `i <= j` 满足 `A[i], A[i+1], ..., A[j]` 都 `>= A[j]` 以及最大的下标 `k >= j` 满足 `A[j+1], A[j+2], ..., A[k]` 都 `> A[j]`。\n\n**算法**\n\n例如，`A = [10, 3, 4, 5, _3_, 2, 3, 10]` 我们需要计算 `#(j = 4)`，也就是第二个数字 `3` ，被标记的那个，我们会发现 `i = 1` 和 `k = 5`。\n\n由此，实际的总数为 `#(j) = (j - i + 1) * (k - j + 1)` 其中 `j - i + 1` 选择子序列的左端点 `i, i+1, ..., j`，而 `k - j + 1` 选择子序列的右端点 `j, j+1, ..., k`。\n\n对于每个询问（也就是根据 `j` 计算出 `(i, k)`）是一个经典问题，可以用一个栈来解决。我们会重点解答如何找到 `i`，而找到 `k` 的做法与之类似。\n\n**构造前序数组**\n\n做法是维护一个`栈`，`A` 的单调下降子序列（事实上是维护一个 `A` 的下标索引）。对于下一个询问，候选界限为 `i* - 1`，其中 `A[i*]` 以递增顺序存储。\n\n现在考虑升序下标 `j` ，我们可以按照 `i*` 递减顺序移走所有 `A[i*] <= A[j]`。\n\n例如，假设 `A = [10, 5, 3, 7, 0, 4, 5, 2, 1, _8_]` 那么当考虑 `j = 9` `(A[j] = 8)`，我们有一个存储边界的栈类似于 `[-1, 0, 3, 6]`（代表 `A[i*] = -inf, 10, 7, 5`）。我们从栈中弹出 `6` 和 `3` 因为 `5 <= 8` 且 `7 <= 8`，因此得到询问的边界为 `i* - 1 = 0`。\n\n注意这个过程线性的，因为只进行了线性次的入栈和出栈。\n\n这种办法很难想到，但在很多地方都有用到，所以很值得学习其细节。\n\n\n```Java []\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class Solution {\n\n    public int sumSubarrayMins(int[] A) {\n        int MOD = 1_000_000_007;\n        int N = A.length;\n\n        // 第 1 步：计算当前下标 i 的左边第 1 个比 A[i] 小的元素的下标\n        Deque<Integer> stack1 = new ArrayDeque<>();\n        int[] prev = new int[N];\n        for (int i = 0; i < N; i++) {\n            while (!stack1.isEmpty() && A[i] <= A[stack1.peekLast()]) {\n                stack1.removeLast();\n            }\n            prev[i] = stack1.isEmpty() ? -1 : stack1.peekLast();\n            stack1.addLast(i);\n        }\n\n        // 第 2 步：计算当前下标 i 的右边第 1 个比 A[i] 小的元素的下标\n        Deque<Integer> stack2 = new ArrayDeque<>();\n        int[] next = new int[N];\n        for (int i = N - 1; i >= 0; i--) {\n            while (!stack2.isEmpty() && A[i] < A[stack2.peekLast()]) {\n                stack2.removeLast();\n            }\n            next[i] = stack2.isEmpty() ? N : stack2.peekLast();\n            stack2.addLast(i);\n        }\n\n        // 第 3 步：计算结果\n        long ans = 0;\n        for (int i = 0; i < N; ++i) {\n            // 注意：乘法可能越界，须要先转成 long 类型\n            ans += (long) (i - prev[i]) * (next[i] - i) % MOD * A[i] % MOD;\n            ans %= MOD;\n        }\n        return (int) ans;\n    }\n}\n```\n\n```Python []\nclass Solution(object):\n    def sumSubarrayMins(self, A):\n        MOD = 10**9 + 7\n        N = len(A)\n\n        # prev has i* - 1 in increasing order of A[i* - 1]\n        # where i* is the answer to query j\n        stack = []\n        prev = [None] * N\n        for i in xrange(N):\n            while stack and A[i] <= A[stack[-1]]:\n                stack.pop()\n            prev[i] = stack[-1] if stack else -1\n            stack.append(i)\n\n        # next has k* + 1 in increasing order of A[k* + 1]\n        # where k* is the answer to query j\n        stack = []\n        next_ = [None] * N\n        for k in xrange(N-1, -1, -1):\n            while stack and A[k] < A[stack[-1]]:\n                stack.pop()\n            next_[k] = stack[-1] if stack else N\n            stack.append(k)\n\n        # Use prev/next array to count answer\n        return sum((i - prev[i]) * (next_[i] - i) * A[i]\n                   for i in xrange(N)) % MOD\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(N)$，其中 $N$ 是 `A` 的长度。\n* 空间复杂度：$O(N)$。\n\n#### 方法 2：维护最小值栈\n\n**想法**\n\n对于每个 `j`，考虑所有子序列 `[i, j]` 的最小值。想法是每当我们增加 `j`，这些最小值可能会有关联，事实上，`min(A[i:j+1]) = min(A[i:j], A[j+1])`。\n\n模拟数组 `A = [1,7,5,2,4,3,9]`，当 `j = 6` 事所有子序列 `[i, j]` 的最小值为 `B = [1,2,2,2,3,3,9]`，可以发现重要点是 `i = 0, i = 3, i = 5, i = 6` ，分别是从 `j` 开始向左移动遇到的最小值的位置。\n\n**算法**\n\n维护关于重要点的编码 `B`，对于上面提到的 `(A, j)` 维护 `stack = [(val=1, count=1), (val=2, count=3), (val=3, count=2), (val=9, count=1)]`，这表示最小值的编码为 `B = [1,2,2,2,3,3,9]`。对于每个 `j` 我们需要计算 `sum(B)`。\n\n当我们增加 `j`，我们用最新的元素 `(val=x, count=1)` 更新栈。弹出所有值 `>= x` 的元素，因为当前子序列 `[i, j]` 的最小值将是 `A[j]` 而不是之前的值。\n\n最后，结果是栈元素的点积 $\\sum\\limits_{e\\text{ } \\in \\text{ stack}} e\\text{.val} * e\\text{.count}$，我们同时会用变量 `dot` 来维护。\n\n```Java []\nclass Solution {\n    public int sumSubarrayMins(int[] A) {\n        int MOD = 1_000_000_007;\n\n        Stack<RepInteger> stack = new Stack();\n        int ans = 0, dot = 0;\n        for (int j = 0; j < A.length; ++j) {\n            // Add all answers for subarrays [i, j], i <= j\n            int count = 1;\n            while (!stack.isEmpty() && stack.peek().val >= A[j]) {\n                RepInteger node = stack.pop();\n                count += node.count;\n                dot -= node.val * node.count;\n            }\n            stack.push(new RepInteger(A[j], count));\n            dot += A[j] * count;\n            ans += dot;\n            ans %= MOD;\n        }\n\n        return ans;\n    }\n}\n\nclass RepInteger {\n    int val, count;\n    RepInteger(int v, int c) {\n        val = v;\n        count = c;\n    }\n}\n```\n\n```Python []\nclass Solution(object):\n    def sumSubarrayMins(self, A):\n        MOD = 10**9 + 7\n\n        stack = []\n        ans = dot = 0\n        for j, y in enumerate(A):\n            # Add all answers for subarrays [i, j], i <= j\n            count = 1\n            while stack and stack[-1][0] >= y:\n                x, c = stack.pop()\n                count += c\n                dot -= x * c\n\n            stack.append((y, count))\n            dot += y * count\n            ans += dot\n        return ans % MOD\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(N)$，其中 $N$ 是 `A` 的长度。\n* 空间复杂度：$O(N)$。\n"
}