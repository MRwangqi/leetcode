{
	"titleSlug": "push-dominoes",
	"slug": "tui-duo-mi-nuo-by-leetcode-solution-dwgm",
	"url": "https://leetcode-cn.com/problems/push-dominoes/solution/tui-duo-mi-nuo-by-leetcode-solution-dwgm/",
	"content": "#### 方法一：广度优先搜索\n\n**思路**\n\n当时间为 $0$ 时，部分骨牌会受到一个初始的向左或向右的力而翻倒。过了 $1$ 秒后，这些翻倒的骨牌会对其周围的骨牌施加一个力。具体表现为：\n\n- 向左翻倒的骨牌，如果它有直立的左边紧邻的骨牌，则会对该直立的骨牌施加一个向左的力。\n\n- 向右翻倒的骨牌，如果它有直立的右边紧邻的骨牌，则会对该直立的骨牌施加一个向右的力。\n\n接下去需要分析这些 $1$ 秒时受力的骨牌的状态。如果仅受到单侧的力，它们会倒向单侧；如果受到两个力，则会保持平衡。再过 $1$ 秒后，这些新翻倒的骨牌又会对其他直立的骨牌施加力，而不会对正在翻倒或已经翻倒的骨牌施加力。\n\n这样的思路类似于广度优先搜索。我们用一个队列 $q$ 模拟搜索的顺序；数组 $\\textit{time}$ 记录骨牌翻倒或者确定不翻倒的时间，翻倒的骨牌不会对正在翻倒或者已经翻倒的骨牌施加力；数组 $\\textit{force}$ 记录骨牌受到的力，骨牌仅在受到单侧的力时会翻倒。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def pushDominoes(self, dominoes: str) -> str:\n        n = len(dominoes)\n        q = deque()\n        time = [-1] * n\n        force = [[] for _ in range(n)]\n        for i, f in enumerate(dominoes):\n            if f != '.':\n                q.append(i)\n                time[i] = 0\n                force[i].append(f)\n\n        res = ['.'] * n\n        while q:\n            i = q.popleft()\n            if len(force[i]) == 1:\n                res[i] = f = force[i][0]\n                ni = i - 1 if f == 'L' else i + 1\n                if 0 <= ni < n:\n                    t = time[i]\n                    if time[ni] == -1:\n                        q.append(ni)\n                        time[ni] = t + 1\n                        force[ni].append(f)\n                    elif time[ni] == t + 1:\n                        force[ni].append(f)\n        return ''.join(res)\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String pushDominoes(String dominoes) {\n        int n = dominoes.length();\n        Deque<Integer> queue = new ArrayDeque<Integer>();\n        int[] time = new int[n];\n        Arrays.fill(time, -1);\n        List<Character>[] force = new List[n];\n        for (int i = 0; i < n; i++) {\n            force[i] = new ArrayList<Character>();\n        }\n        for (int i = 0; i < n; i++) {\n            char f = dominoes.charAt(i);\n            if (f != '.') {\n                queue.offer(i);\n                time[i] = 0;\n                force[i].add(f);\n            }\n        }\n\n        char[] res = new char[n];\n        Arrays.fill(res, '.');\n        while (!queue.isEmpty()) {\n            int i = queue.poll();\n            if (force[i].size() == 1) {\n                char f = force[i].get(0);\n                res[i] = f;\n                int ni = f == 'L' ? i - 1 : i + 1;\n                if (ni >= 0 && ni < n) {\n                    int t = time[i];\n                    if (time[ni] == -1) {\n                        queue.offer(ni);\n                        time[ni] = t + 1;\n                        force[ni].add(f);\n                    } else if (time[ni] == t + 1) {\n                        force[ni].add(f);\n                    }\n                }\n            }\n        }\n        return new String(res);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string PushDominoes(string dominoes) {\n        int n = dominoes.Length;\n        Queue<int> queue = new Queue<int>();\n        int[] time = new int[n];\n        Array.Fill(time, -1);\n        IList<char>[] force = new IList<char>[n];\n        for (int i = 0; i < n; i++) {\n            force[i] = new List<char>();\n        }\n        for (int i = 0; i < n; i++) {\n            char f = dominoes[i];\n            if (f != '.') {\n                queue.Enqueue(i);\n                time[i] = 0;\n                force[i].Add(f);\n            }\n        }\n\n        char[] res = new char[n];\n        Array.Fill(res, '.');\n        while (queue.Count > 0) {\n            int i = queue.Dequeue();\n            if (force[i].Count == 1) {\n                char f = force[i][0];\n                res[i] = f;\n                int ni = f == 'L' ? i - 1 : i + 1;\n                if (ni >= 0 && ni < n) {\n                    int t = time[i];\n                    if (time[ni] == -1) {\n                        queue.Enqueue(ni);\n                        time[ni] = t + 1;\n                        force[ni].Add(f);\n                    } else if (time[ni] == t + 1) {\n                        force[ni].Add(f);\n                    }\n                }\n            }\n        }\n        return new string(res);\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int n = dominoes.size();\n        queue<int> q;\n        vector<int> time(n, - 1);\n        vector<string> force(n);\n        for (int i = 0; i < n; i++) {\n            if (dominoes[i] != '.') {\n                q.emplace(i);\n                time[i] = 0;\n                force[i].push_back(dominoes[i]);\n            }\n        }\n\n        string res(n, '.');\n        while (!q.empty()) {\n            int i = q.front();\n            q.pop();\n            if (force[i].size() == 1) {\n                char f = force[i][0];\n                res[i] = f;\n                int ni = (f == 'L') ? (i - 1) : (i + 1);\n                if (ni >= 0 and ni < n) {\n                    int t = time[i];\n                    if (time[ni] == -1) {\n                        q.emplace(ni);\n                        time[ni] = t + 1;\n                        force[ni].push_back(f);\n                    } else if(time[ni] == t + 1) {\n                        force[ni].push_back(f);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct StListNode {\n    int val;\n    struct StListNode * next;\n} StListNode;\n\ntypedef struct Queue{\n    struct StListNode * head;\n    struct StListNode * tail;\n    int length;\n} Queue;\n\nbool isEmpty(const Queue * obj) {\n    return obj->length == 0;\n}\n\nint length(const Queue * obj) {\n    return obj->length;\n}\n\nbool initQueue(Queue * obj) {\n    obj->head = NULL;\n    obj->tail = NULL;\n    obj->length = 0;\n    return true;\n}\n\nbool pushQueue(Queue * obj, int val) {\n    StListNode * node = (StListNode *)malloc(sizeof(StListNode));\n    node->val = val;\n    node->next = NULL;\n    if (NULL == obj->head) {\n        obj->head = node;\n        obj->tail = node;\n    } else {\n        obj->tail->next = node;\n        obj->tail = obj->tail->next;\n    }\n    obj->length++;\n    return true;\n}\n\nint front(const Queue * obj) {\n    if (obj->length == 0) {\n        return -1;\n    }\n    return obj->head->val;\n}\n\nint popQueue(Queue * obj) {\n    if (obj->length == 0) {\n        return -1;\n    }\n    int res = obj->head->val;\n    StListNode * node = obj->head;\n    obj->head = obj->head->next;\n    obj->length--;\n    free(node);\n    return res;\n}\n\nchar * pushDominoes(char * dominoes){\n    int n = strlen(dominoes);\n    int * time = (int *)malloc(sizeof(int) * n);\n    char * res = (char *)malloc(sizeof(char) * (n + 1));\n    Queue ** force = (Queue **)malloc(sizeof(Queue *) * n);\n\n    for (int i = 0; i < n; i++) {\n        time[i] = -1;\n        force[i] = (Queue *)malloc(sizeof(Queue));\n        initQueue(force[i]);\n        res[i] = '.';\n    }\n    res[n] = '\\0';\n    Queue qu; \n    initQueue(&qu);\n    for (int i = 0; i < n; i++) {\n        if (dominoes[i] != '.') {\n            pushQueue(&qu, i);\n            time[i] = 0;\n            pushQueue(force[i], dominoes[i]);\n        }\n    }\n\n    while (!isEmpty(&qu)) {\n        int i = popQueue(&qu);\n        if (length(force[i]) == 1) {\n            char f = front(force[i]);\n            res[i] = f;\n            int ni = (f == 'L') ? (i - 1) : (i + 1);\n            if (ni >= 0 && ni < n) {\n                int t = time[i];\n                if (time[ni] == -1) {\n                    pushQueue(&qu, ni);\n                    time[ni] = t + 1;\n                    pushQueue(force[ni], f);\n                } else if(time[ni] == t + 1) {\n                    pushQueue(force[ni], f);\n                }\n            }\n        }\n    }\n    /* free resource */\n    for (int i = 0; i < n; i++) {\n        while (!isEmpty(force[i])) {\n            popQueue(force[i]);\n        }\n    }\n    return res;\n}\n```\n\n```go [sol1-Golang]\nfunc pushDominoes(dominoes string) string {\n    n := len(dominoes)\n    q := []int{}\n    time := make([]int, n)\n    for i := range time {\n        time[i] = -1\n    }\n    force := make([][]byte, n)\n    for i, ch := range dominoes {\n        if ch != '.' {\n            q = append(q, i)\n            time[i] = 0\n            force[i] = append(force[i], byte(ch))\n        }\n    }\n\n    ans := bytes.Repeat([]byte{'.'}, n)\n    for len(q) > 0 {\n        i := q[0]\n        q = q[1:]\n        if len(force[i]) > 1 {\n            continue\n        }\n        f := force[i][0]\n        ans[i] = f\n        ni := i - 1\n        if f == 'R' {\n            ni = i + 1\n        }\n        if 0 <= ni && ni < n {\n            t := time[i]\n            if time[ni] == -1 {\n                q = append(q, ni)\n                time[ni] = t + 1\n                force[ni] = append(force[ni], f)\n            } else if time[ni] == t+1 {\n                force[ni] = append(force[ni], f)\n            }\n        }\n    }\n    return string(ans)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是 $\\textit{dominoes}$ 的长度。每个下标会最多被判断一次状态。\n\n- 空间复杂度：$O(n)$。队列和数组最多各包含 $n$ 个元素。\n\n#### 方法二：模拟\n\n**思路**\n\n我们可以枚举所有连续的没有被推动的骨牌，根据这段骨牌的两边骨牌（如果有的话）的推倒方向决定这段骨牌的最终状态：\n\n- 如果两边的骨牌同向，那么这段连续的竖立骨牌会倒向同一方向。\n- 如果两边的骨牌相对，那么这段骨牌会向中间倒。\n- 如果两边的骨牌相反，那么这段骨牌会保持竖立。\n\n特别地，如果左侧没有被推倒的骨牌，则假设存在一块向左倒的骨牌；如果右侧没有被推倒的骨牌，则假设存在一块向右倒的骨牌。这样的假设不会破坏骨牌的最终状态，并且边界情况也可以落入到上述三种情况中。\n\n我们可以使用两个指针 $i$ 和 $j$ 来枚举所有连续的没有被推动的骨牌，$\\textit{left}$ 和 $\\textit{right}$ 表示两边骨牌的推倒方向。根据上述三种情况来计算骨牌的最终状态。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def pushDominoes(self, dominoes: str) -> str:\n        s = list(dominoes)\n        n, i, left = len(s), 0, 'L'\n        while i < n:\n            j = i\n            while j < n and s[j] == '.':  # 找到一段连续的没有被推动的骨牌\n                j += 1\n            right = s[j] if j < n else 'R'\n            if left == right:  # 方向相同，那么这些竖立骨牌也会倒向同一方向\n                while i < j:\n                    s[i] = right\n                    i += 1\n            elif left == 'R' and right == 'L':  # 方向相对，那么就从两侧向中间倒\n                k = j - 1\n                while i < k:\n                    s[i] = 'R'\n                    s[k] = 'L'\n                    i += 1\n                    k -= 1\n            left = right\n            i = j + 1\n        return ''.join(s)\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public String pushDominoes(String dominoes) {\n        char[] s = dominoes.toCharArray();\n        int n = s.length, i = 0;\n        char left = 'L';\n        while (i < n) {\n            int j = i;\n            while (j < n && s[j] == '.') { // 找到一段连续的没有被推动的骨牌\n                j++;\n            }\n            char right = j < n ? s[j] : 'R';\n            if (left == right) { // 方向相同，那么这些竖立骨牌也会倒向同一方向\n                while (i < j) {\n                    s[i++] = right;\n                }\n            } else if (left == 'R' && right == 'L') { // 方向相对，那么就从两侧向中间倒\n                int k = j - 1;\n                while (i < k) {\n                    s[i++] = 'R';\n                    s[k--] = 'L';\n                }\n            }\n            left = right;\n            i = j + 1;\n        }\n        return new String(s);\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public string PushDominoes(string dominoes) {\n        char[] s = dominoes.ToCharArray();\n        int n = s.Length, i = 0;\n        char left = 'L';\n        while (i < n) {\n            int j = i;\n            while (j < n && s[j] == '.') { // 找到一段连续的没有被推动的骨牌\n                j++;\n            }\n            char right = j < n ? s[j] : 'R';\n            if (left == right) { // 方向相同，那么这些竖立骨牌也会倒向同一方向\n                while (i < j) {\n                    s[i++] = right;\n                }\n            } else if (left == 'R' && right == 'L') { // 方向相对，那么就从两侧向中间倒\n                int k = j - 1;\n                while (i < k) {\n                    s[i++] = 'R';\n                    s[k--] = 'L';\n                }\n            }\n            left = right;\n            i = j + 1;\n        }\n        return new string(s);\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int n = dominoes.size(), i = 0;\n        char left = 'L';\n        while (i < n) {\n            int j = i;\n            while (j < n && dominoes[j] == '.') { // 找到一段连续的没有被推动的骨牌\n                j++;\n            }\n            char right = j < n ? dominoes[j] : 'R';\n            if (left == right) { // 方向相同，那么这些竖立骨牌也会倒向同一方向\n                while (i < j) {\n                    dominoes[i++] = right;\n                }\n            } else if (left == 'R' && right == 'L') { // 方向相对，那么就从两侧向中间倒\n                int k = j - 1;\n                while (i < k) {\n                    dominoes[i++] = 'R';\n                    dominoes[k--] = 'L';\n                }\n            }\n            left = right;\n            i = j + 1;\n        }\n        return dominoes;\n    }\n};\n```\n\n```C [sol2-C]\nchar * pushDominoes(char * dominoes) {\n    int n = strlen(dominoes), i = 0;\n    char left = 'L';\n    while (i < n) {\n        int j = i;\n        while (j < n && dominoes[j] == '.') { // 找到一段连续的没有被推动的骨牌\n            j++;\n        }\n        char right = j < n ? dominoes[j] : 'R';\n        if (left == right) { // 方向相同，那么这些竖立骨牌也会倒向同一方向\n            while (i < j) {\n                dominoes[i++] = right;\n            }\n        } else if (left == 'R' && right == 'L') { // 方向相对，那么就从两侧向中间倒\n            int k = j - 1;\n            while (i < k) {\n                dominoes[i++] = 'R';\n                dominoes[k--] = 'L';\n            }\n        }\n        left = right;\n        i = j + 1;\n    }\n    return dominoes;\n}\n```\n\n```go [sol2-Golang]\nfunc pushDominoes(dominoes string) string {\n    s := []byte(dominoes)\n    i, n, left := 0, len(s), byte('L')\n    for i < n {\n        j := i\n        for j < n && s[j] == '.' { // 找到一段连续的没有被推动的骨牌\n            j++\n        }\n        right := byte('R')\n        if j < n {\n            right = s[j]\n        }\n        if left == right { // 方向相同，那么这些竖立骨牌也会倒向同一方向\n            for i < j {\n                s[i] = right\n                i++\n            }\n        } else if left == 'R' && right == 'L' { // 方向相对，那么就从两侧向中间倒\n            k := j - 1\n            for i < k {\n                s[i] = 'R'\n                s[k] = 'L'\n                i++\n                k--\n            }\n        }\n        left = right\n        i = j + 1\n    }\n    return string(s)\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar pushDominoes = function(dominoes) {\n    const s = [...dominoes];\n    let n = s.length, i = 0;\n    let left = 'L';\n    while (i < n) {\n        let j = i;\n        while (j < n && s[j] == '.') { // 找到一段连续的没有被推动的骨牌\n            j++;\n        }\n        const right = j < n ? s[j] : 'R';\n        if (left === right) { // 方向相同，那么这些竖立骨牌也会倒向同一方向\n            while (i < j) {\n                s[i++] = right;\n            }\n        } else if (left === 'R' && right === 'L') { // 方向相对，那么就从两侧向中间倒\n            let k = j - 1;\n            while (i < k) {\n                s[i++] = 'R';\n                s[k--] = 'L';\n            }\n        }\n        left = right;\n        i = j + 1;\n    }\n    return s.join('');\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是 $\\textit{dominoes}$ 的长度。每个下标会最多会被访问和赋值各一次。\n\n- 空间复杂度：$O(1)$ 或 $O(n)$。某些语言字符串不可变，需要 $O(n)$ 的额外空间。"
}