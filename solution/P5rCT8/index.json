{
	"titleSlug": "P5rCT8",
	"slug": "er-cha-sou-suo-shu-zhong-de-zhong-xu-hou-5nrz",
	"url": "https://leetcode-cn.com/problems/P5rCT8/solution/er-cha-sou-suo-shu-zhong-de-zhong-xu-hou-5nrz/",
	"content": "#### 方法一：中序遍历\n\n为了找到二叉搜索树中的节点 $p$ 的中序后继，最直观的方法是中序遍历。由于只需要找到节点 $p$ 的中序后继，因此不需要维护完整的中序遍历序列，只需要在中序遍历的过程中维护上一个访问的节点和当前访问的节点。如果上一个访问的节点是节点 $p$，则当前访问的节点即为节点 $p$ 的中序后继。\n\n如果节点 $p$ 是最后被访问的节点，则不存在节点 $p$ 的中序后继，返回 $\\text{null}$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':\n        st, pre, cur = [], None, root\n        while st or cur:\n            while cur:\n                st.append(cur)\n                cur = cur.left\n            cur = st.pop()\n            if pre == p:\n                return cur\n            pre = cur\n            cur = cur.right\n        return None\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();\n        TreeNode prev = null, curr = root;\n        while (!stack.isEmpty() || curr != null) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            if (prev == p) {\n                return curr;\n            }\n            prev = curr;\n            curr = curr.right;\n        }\n        return null;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public TreeNode InorderSuccessor(TreeNode root, TreeNode p) {\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        TreeNode prev = null, curr = root;\n        while (stack.Count > 0 || curr != null) {\n            while (curr != null) {\n                stack.Push(curr);\n                curr = curr.left;\n            }\n            curr = stack.Pop();\n            if (prev == p) {\n                return curr;\n            }\n            prev = curr;\n            curr = curr.right;\n        }\n        return null;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        stack<TreeNode*> st;\n        TreeNode *prev = nullptr, *curr = root;\n        while (!st.empty() || curr != nullptr) {\n            while (curr != nullptr) {\n                st.emplace(curr);\n                curr = curr->left;\n            }\n            curr = st.top();\n            st.pop();\n            if (prev == p) {\n                return curr;\n            }\n            prev = curr;\n            curr = curr->right;\n        }\n        return nullptr;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct ElementNode {\n    struct TreeNode * val;\n    struct ElementNode * next; \n} ElementNode;\n\nstruct TreeNode* inorderSuccessor(struct TreeNode* root, struct TreeNode* p) {\n    ElementNode * st = NULL;\n    struct TreeNode *prev = NULL, *curr = root;\n    while (st || curr != NULL) {\n        while (curr != NULL) {\n            ElementNode * node = (ElementNode *)malloc(sizeof(ElementNode));\n            node->val = curr;\n            node->next = st;\n            st = node;\n            curr = curr->left;\n        }\n        ElementNode * node = st;\n        curr = node->val;\n        st = st->next;\n        free(node);\n        if (prev == p) {\n            return curr;\n        }\n        prev = curr;\n        curr = curr->right;\n    }\n    return NULL;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar inorderSuccessor = function(root, p) {\n    const stack = [];\n    let prev = null, curr = root;\n    while (stack.length || curr) {\n        while (curr) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n        if (prev === p) {\n            return curr;\n        }\n        prev = curr;\n        curr = curr.right;\n    }\n    return null;\n};\n```\n\n```go [sol1-Golang]\nfunc inorderSuccessor(root *TreeNode, p *TreeNode) *TreeNode {\n    st := []*TreeNode{}\n    var pre, cur *TreeNode = nil, root\n    for len(st) > 0 || cur != nil {\n        for cur != nil {\n            st = append(st, cur)\n            cur = cur.Left\n        }\n        cur = st[len(st)-1]\n        st = st[:len(st)-1]\n        if pre == p {\n            return cur\n        }\n        pre = cur\n        cur = cur.Right\n    }\n    return nil\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉搜索树的节点数。中序遍历最多需要访问二叉搜索树中的每个节点一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是二叉搜索树的节点数。空间复杂度取决于栈深度，平均情况是 $O(\\log n)$，最坏情况是 $O(n)$。\n\n#### 方法二：利用二叉搜索树的性质\n\n二叉搜索树的一个性质是中序遍历序列单调递增，因此二叉搜索树中的节点 $p$ 的中序后继满足以下条件：\n\n- 中序后继的节点值大于 $p$ 的节点值；\n\n- 中序后继是节点值大于 $p$ 的节点值的所有节点中节点值最小的一个节点。\n\n利用二叉搜索树的性质，可以在不做中序遍历的情况下找到节点 $p$ 的中序后继。\n\n如果节点 $p$ 的右子树不为空，则节点 $p$ 的中序后继在其右子树中，在其右子树中定位到最左边的节点，即为节点 $p$ 的中序后继。\n\n如果节点 $p$ 的右子树为空，则需要从根节点开始遍历寻找节点 $p$ 的祖先节点。\n\n将答案初始化为 $\\text{null}$。用 $\\textit{node}$ 表示遍历到的节点，初始时 $\\textit{node} = \\textit{root}$。每次比较 $\\textit{node}$ 的节点值和 $p$ 的节点值，执行相应操作：\n\n- 如果 $\\textit{node}$ 的节点值大于 $p$ 的节点值，则 $p$ 的中序后继可能是 $\\textit{node}$ 或者在 $\\textit{node}$ 的左子树中，因此用 $\\textit{node}$ 更新答案，并将 $\\textit{node}$ 移动到其左子节点继续遍历；\n\n- 如果 $\\textit{node}$ 的节点值小于或等于 $p$ 的节点值，则 $p$ 的中序后继可能在 $\\textit{node}$ 的右子树中，因此将 $\\textit{node}$ 移动到其右子节点继续遍历。\n\n由于在遍历过程中，当且仅当 $\\textit{node}$ 的节点值大于 $p$ 的节点值的情况下，才会用 $\\textit{node}$ 更新答案，因此当节点 $p$ 有中序后继时一定可以找到中序后继，当节点 $p$ 没有中序后继时答案一定为 $\\text{null}$。\n\n```Python [sol2-Python3]\nclass Solution:\n    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':\n        successor = None\n        if p.right:\n            successor = p.right\n            while successor.left:\n                successor = successor.left\n            return successor\n        node = root\n        while node:\n            if node.val > p.val:\n                successor = node\n                node = node.left\n            else:\n                node = node.right\n        return successor\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n        TreeNode successor = null;\n        if (p.right != null) {\n            successor = p.right;\n            while (successor.left != null) {\n                successor = successor.left;\n            }\n            return successor;\n        }\n        TreeNode node = root;\n        while (node != null) {\n            if (node.val > p.val) {\n                successor = node;\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        }\n        return successor;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public TreeNode InorderSuccessor(TreeNode root, TreeNode p) {\n        TreeNode successor = null;\n        if (p.right != null) {\n            successor = p.right;\n            while (successor.left != null) {\n                successor = successor.left;\n            }\n            return successor;\n        }\n        TreeNode node = root;\n        while (node != null) {\n            if (node.val > p.val) {\n                successor = node;\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        }\n        return successor;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        TreeNode *successor = nullptr;\n        if (p->right != nullptr) {\n            successor = p->right;\n            while (successor->left != nullptr) {\n                successor = successor->left;\n            }\n            return successor;\n        }\n        TreeNode *node = root;\n        while (node != nullptr) {\n            if (node->val > p->val) {\n                successor = node;\n                node = node->left;\n            } else {\n                node = node->right;\n            }\n        }\n        return successor;\n    }\n};\n```\n\n```C [sol2-C]\nstruct TreeNode* inorderSuccessor(struct TreeNode* root, struct TreeNode* p) {\n    struct TreeNode *successor = NULL;\n    if (p->right != NULL) {\n        successor = p->right;\n        while (successor->left != NULL) {\n            successor = successor->left;\n        }\n        return successor;\n    }\n    struct TreeNode *node = root;\n    while (node != NULL) {\n        if (node->val > p->val) {\n            successor = node;\n            node = node->left;\n        } else {\n            node = node->right;\n        }\n    }\n    return successor;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar inorderSuccessor = function(root, p) {\n    let successor = null;\n    if (p.right) {\n        successor = p.right;\n        while (successor.left) {\n            successor = successor.left;\n        }\n        return successor;\n    }\n    let node = root;\n    while (node) {\n        if (node.val > p.val) {\n            successor = node;\n            node = node.left;\n        } else {\n            node = node.right;\n        }\n    }\n    return successor;\n};\n```\n\n```go [sol2-Golang]\nfunc inorderSuccessor(root *TreeNode, p *TreeNode) *TreeNode {\n    var successor *TreeNode\n    if p.Right != nil {\n        successor = p.Right\n        for successor.Left != nil {\n            successor = successor.Left\n        }\n        return successor\n    }\n    node := root\n    for node != nil {\n        if node.Val > p.Val {\n            successor = node\n            node = node.Left\n        } else {\n            node = node.Right\n        }\n    }\n    return successor\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉搜索树的节点数。遍历的节点数不超过二叉搜索树的高度，平均情况是 $O(\\log n)$，最坏情况是 $O(n)$。\n\n- 空间复杂度：$O(1)$。"
}