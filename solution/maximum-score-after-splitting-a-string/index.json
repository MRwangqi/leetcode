{
	"titleSlug": "maximum-score-after-splitting-a-string",
	"slug": "fen-ge-zi-fu-chuan-de-zui-da-de-fen-by-l-7u5p",
	"url": "https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string/solution/fen-ge-zi-fu-chuan-de-zui-da-de-fen-by-l-7u5p/",
	"content": "#### 方法一：枚举每个分割点\n\n用 $n$ 表示字符串 $s$ 的长度。对于每个 $1 \\le i < n$，下标 $i$ 是一个分割点，将字符串 $s$ 分割成两个非空子字符串，左子字符串的下标范围是 $[0, i - 1]$，右子字符串的下标范围是 $[i, n - 1]$，分别计算左子字符串中的 $0$ 的个数和右子字符串中的 $1$ 的个数即可得到分割字符串的得分。遍历所有的分割点，即可得到分割字符串的最大得分。\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        return max(s[:i].count('0') + s[i:].count('1') for i in range(1, len(s)))\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maxScore(String s) {\n        int ans = 0;\n        int n = s.length();\n        for (int i = 1; i < n; i++) {\n            int score = 0;\n            for (int j = 0; j < i; j++) {\n                if (s.charAt(j) == '0') {\n                    score++;\n                }\n            }\n            for (int j = i; j < n; j++) {\n                if (s.charAt(j) == '1') {\n                    score++;\n                }\n            }\n            ans = Math.max(ans, score);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MaxScore(string s) {\n        int ans = 0;\n        int n = s.Length;\n        for (int i = 1; i < n; i++) {\n            int score = 0;\n            for (int j = 0; j < i; j++) {\n                if (s[j] == '0') {\n                    score++;\n                }\n            }\n            for (int j = i; j < n; j++) {\n                if (s[j] == '1') {\n                    score++;\n                }\n            }\n            ans = Math.Max(ans, score);\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxScore(string s) {\n        int ans = 0;\n        int n = s.size();\n        for (int i = 1; i < n; i++) {\n            int score = 0;\n            for (int j = 0; j < i; j++) {\n                if (s[j] == '0') {\n                    score++;\n                }\n            }\n            for (int j = i; j < n; j++) {\n                if (s[j] == '1') {\n                    score++;\n                }\n            }\n            ans = max(ans, score);\n        }\n        return ans;\n    }\n};\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint maxScore(char * s){\n    int ans = 0;\n    int n = strlen(s);\n    for (int i = 1; i < n; i++) {\n        int score = 0;\n        for (int j = 0; j < i; j++) {\n            if (s[j] == '0') {\n                score++;\n            }\n        }\n        for (int j = i; j < n; j++) {\n            if (s[j] == '1') {\n                score++;\n            }\n        }\n        ans = MAX(ans, score);\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maxScore = function(s) {\n    let ans = 0;\n    const n = s.length;\n    for (let i = 1; i < n; i++) {\n        let score = 0;\n        for (let j = 0; j < i; j++) {\n            if (s[j] === '0') {\n                score++;\n            }\n        }\n        for (let j = i; j < n; j++) {\n            if (s[j] === '1') {\n                score++;\n            }\n        }\n        ans = Math.max(ans, score);\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc maxScore(s string) (ans int) {\n    for i := 1; i < len(s); i++ {\n        ans = max(ans, strings.Count(s[:i], \"0\")+strings.Count(s[i:], \"1\"))\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 是字符串 $s$ 的长度。需要遍历 $n - 1$ 个分割点，对于每个分割点需要 $O(n)$ 的时间遍历整个字符串计算分割字符串的得分，因此时间复杂度是 $O(n^2)$。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：两次遍历\n\n方法一中，对于每个分割点遍历整个字符串计算分割字符串的得分。可以换一个角度思考，如果分割点从左到右移动一位，则位于原分割点处的字符从右子字符串中移除并添加到左子字符串中，根据该字符的值更新分割字符串的得分。\n\n当 $1 \\le i < n$ 时，分割点 $i$ 将字符串 $s$ 分割成两个非空子字符串，左子字符串的下标范围是 $[0, i - 1]$，右子字符串的下标范围是 $[i, n - 1]$。对于 $1 \\le i < n - 1$，当分割点从 $i$ 移动到 $i + 1$ 时，位于下标 $i$ 处的字符 $s[i]$ 从右子字符串中移除并添加到左子字符串中，分割字符串的得分变化如下：\n\n- 如果 $s[i] = 0$，则左子字符串的得分加 $1$，右子字符串的得分不变，因此分割字符串的得分加 $1$；\n\n- 如果 $s[i] = 1$，则左子字符串的得分不变，右子字符串的得分减 $1$，因此分割字符串的得分减 $1$。\n\n由于最左侧的分割点是 $i = 1$，因此首先计算 $i = 1$ 处的分割字符串的得分，然后从左到右依次遍历每个分割点，遍历过程中更新分割字符串的得分，遍历结束之后即可得到分割字符串的最大得分。\n\n```Python [sol2-Python3]\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        ans = score = (s[0] == '0') + s[1:].count('1')\n        for c in s[1:-1]:\n            score += 1 if c == '0' else -1\n            ans = max(ans, score)\n        return ans\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int maxScore(String s) {\n        int score = 0;\n        int n = s.length();\n        if (s.charAt(0) == '0') {\n            score++;\n        }\n        for (int i = 1; i < n; i++) {\n            if (s.charAt(i) == '1') {\n                score++;\n            }\n        }\n        int ans = score;\n        for (int i = 1; i < n - 1; i++) {\n            if (s.charAt(i) == '0') {\n                score++;\n            } else {\n                score--;\n            }\n            ans = Math.max(ans, score);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int MaxScore(string s) {\n        int score = 0;\n        int n = s.Length;\n        if (s[0] == '0') {\n            score++;\n        }\n        for (int i = 1; i < n; i++) {\n            if (s[i] == '1') {\n                score++;\n            }\n        }\n        int ans = score;\n        for (int i = 1; i < n - 1; i++) {\n            if (s[i] == '0') {\n                score++;\n            } else {\n                score--;\n            }\n            ans = Math.Max(ans, score);\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int maxScore(string s) {\n        int score = 0;\n        int n = s.size();\n        if (s[0] == '0') {\n            score++;\n        }\n        for (int i = 1; i < n; i++) {\n            if (s[i] == '1') {\n                score++;\n            }\n        }\n        int ans = score;\n        for (int i = 1; i < n - 1; i++) {\n            if (s[i] == '0') {\n                score++;\n            } else {\n                score--;\n            }\n            ans = max(ans, score);\n        }\n        return ans;\n    }\n};\n```\n\n```C [sol2-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint maxScore(char * s){\n    int score = 0;\n    int n = strlen(s);\n    if (s[0] == '0') {\n        score++;\n    }\n    for (int i = 1; i < n; i++) {\n        if (s[i] == '1') {\n            score++;\n        }\n    }\n    int ans = score;\n    for (int i = 1; i < n - 1; i++) {\n        if (s[i] == '0') {\n            score++;\n        } else {\n            score--;\n        }\n        ans = MAX(ans, score);\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar maxScore = function(s) {\n    let score = 0;\n    const n = s.length;\n    if (s[0] === '0') {\n        score++;\n    }\n    for (let i = 1; i < n; i++) {\n        if (s[i] === '1') {\n            score++;\n        }\n    }\n    let ans = score;\n    for (let i = 1; i < n - 1; i++) {\n        if (s[i] == '0') {\n            score++;\n        } else {\n            score--;\n        }\n        ans = Math.max(ans, score);\n    }\n    return ans;\n};\n```\n\n```go [sol2-Golang]\nfunc maxScore(s string) int {\n    score := int('1'-s[0]) + strings.Count(s[1:], \"1\")\n    ans := score\n    for _, c := range s[1 : len(s)-1] {\n        if c == '0' {\n            score++\n        } else {\n            score--\n        }\n        ans = max(ans, score)\n    }\n    return ans\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。需要遍历字符串两次。\n\n- 空间复杂度：$O(1)$。"
}