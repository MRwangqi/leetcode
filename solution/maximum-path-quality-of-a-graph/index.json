{
	"titleSlug": "maximum-path-quality-of-a-graph",
	"slug": "zui-da-hua-yi-zhang-tu-zhong-de-lu-jing-yim5i",
	"url": "https://leetcode-cn.com/problems/maximum-path-quality-of-a-graph/solution/zui-da-hua-yi-zhang-tu-zhong-de-lu-jing-yim5i/",
	"content": "#### 方法一：枚举所有可能的路径\n\n**思路与算法**\n\n仔细阅读题目描述我们可以发现，$\\textit{time}_j$ 的最小值为 $10$，而 $\\textit{maxTime}$ 的最大值为 $100$。这说明我们**至多**只会经过图上的 $10$ 条边。由于图中每个节点的度数都不超过 $4$，因此我们可以枚举所有从节点 $0$ 开始的路径。\n\n我们可以使用递归 + 回溯的方法进行枚举。递归函数记录当前所在的节点编号，已经过的路径的总时间以及节点的价值之和。如果当前在节点 $u$，我们可以枚举与 $u$ 直接相连的节点 $v$ 进行递归搜索。在搜索的过程中，如果我们回到了节点 $0$，就可以对答案进行更新；如果总时间超过了 $\\textit{maxTime}$，我们需要停止搜索，进行回溯。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\n        int n = values.size();\n        vector<vector<pair<int, int>>> g(n);\n        for (const auto& edge: edges) {\n            g[edge[0]].emplace_back(edge[1], edge[2]);\n            g[edge[1]].emplace_back(edge[0], edge[2]);\n        }\n        \n        vector<int> visited(n);\n        visited[0] = true;\n        int ans = 0;\n        \n        function<void(int, int, int)> dfs = [&](int u, int time, int value) {\n            if (u == 0) {\n                ans = max(ans, value);\n            }\n            for (const auto& [v, dist]: g[u]) {\n                if (time + dist <= maxTime) {\n                    if (!visited[v]) {\n                        visited[v] = true;\n                        dfs(v, time + dist, value + values[v]);\n                        visited[v] = false;\n                    }\n                    else {\n                        dfs(v, time + dist, value);\n                    }\n                }\n            }\n        };\n        \n        dfs(0, 0, values[0]);\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\n        g = defaultdict(list)\n        for x, y, z in edges:\n            g[x].append((y, z))\n            g[y].append((x, z))\n        \n        visited = {0}\n        ans = 0\n        \n        def dfs(u: int, time: int, value: int) -> None:\n            if u == 0:\n                nonlocal ans\n                ans = max(ans, value)\n            for v, dist in g[u]:\n                if time + dist <= maxTime:\n                    if v not in visited:\n                        visited.add(v)\n                        dfs(v, time + dist, value + values[v])\n                        visited.discard(v)\n                    else:\n                        dfs(v, time + dist, value)\n        \n        dfs(0, 0, values[0])\n        return ans\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + m + d^k)$，其中 $m$ 是数组 $\\textit{edges}$ 的长度，$d$ 是图中每个点度数的最大值，$k$ 是最多经过的边的数量，在本题中 $d = 4, k = 10$。\n    \n    - 将 $\\textit{edges}$ 存储成邻接表的形式需要的时间为 $O(n + m)$。\n\n    - 搜索需要的时间为 $O(d^k)$。\n\n- 空间复杂度：$O(n + m + k)$。\n\n    - 邻接表需要的空间为 $O(n + m)$。\n\n    - 记录每个节点是否访问过的数组需要的空间为 $O(n)$。\n\n    - 搜索中栈需要的空间为 $O(k)$。"
}