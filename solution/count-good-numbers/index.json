{
	"titleSlug": "count-good-numbers",
	"slug": "tong-ji-hao-shu-zi-de-shu-mu-by-leetcode-53jj",
	"url": "https://leetcode-cn.com/problems/count-good-numbers/solution/tong-ji-hao-shu-zi-de-shu-mu-by-leetcode-53jj/",
	"content": "#### 方法一：快速幂\n\n**思路与算法**\n\n对于偶数下标处的数字，它可以为 $0, 2, 4, 6, 8$ 共计 $5$ 种，而长度为 $n$ 的数字字符串有 $\\lfloor \\dfrac{n+1}{2} \\rfloor$ 个偶数下标，其中 $\\lfloor x \\rfloor$ 表示对 $x$ 向下取整。\n\n对于奇数下标处的数字，它可以为 $2, 3, 5, 7$ 共计 $4$ 种，而长度为 $n$ 的数字字符串有 $\\lfloor \\dfrac{n}{2} \\rfloor$ 个奇数下标。\n\n因此长度为 $n$ 的数字字符串中，好数字的总数即为：\n\n$$\n5^{\\lfloor \\frac{n+1}{2} \\rfloor} \\cdot 4^{\\lfloor \\frac{n}{2} \\rfloor}\n$$\n\n在本题中，由于 $n$ 的取值最大可以到 $10^{15}$，如果通过普通的乘法运算直接求出上式中的幂，会超出时间限制，因此我们需要使用快速幂算法对幂的求值进行优化。\n\n快速幂算法可以参考[「50. Pow(x, n)」的官方题解](https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/)。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    static constexpr int mod = 1000000007;\n    \npublic:\n    int countGoodNumbers(long long n) {\n        // 快速幂求出 x^y % mod\n        auto quickmul = [](int x, long long y) -> int {\n            int ret = 1, mul = x;\n            while (y > 0) {\n                if (y % 2 == 1) {\n                    ret = (long long)ret * mul % mod;\n                }\n                mul = (long long)mul * mul % mod;\n                y /= 2;\n            }\n            return ret;\n        };\n        \n        return (long long)quickmul(5, (n + 1) / 2) * quickmul(4, n / 2) % mod;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def countGoodNumbers(self, n: int) -> int:\n        mod = 10**9 + 7\n        \n        # 快速幂求出 x^y % mod\n        def quickmul(x: int, y: int) -> int:\n            ret, mul = 1, x\n            while y > 0:\n                if y % 2 == 1:\n                    ret = ret * mul % mod\n                mul = mul * mul % mod\n                y //= 2\n            return ret\n            \n        return quickmul(5, (n + 1) // 2) * quickmul(4, n // 2) % mod\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$。\n\n- 空间复杂度：$O(1)$。"
}