{
	"titleSlug": "EXvqDp",
	"slug": "mei-ju-by-endlesscheng-5wzf",
	"url": "https://leetcode-cn.com/problems/EXvqDp/solution/mei-ju-by-endlesscheng-5wzf/",
	"content": "个人赛五道题目的 [视频讲解](https://www.bilibili.com/video/BV1zN4y1K762) 已出炉，欢迎点赞三连，在评论区分享你对这场比赛的看法~\r\n\r\n---\r\n\r\n由于路径是唯一的，一个入口只会对应一个唯一的出口；一个出口+进入出口的方向，可以找到唯一的入口。\r\n\r\n因此，从不同入口出发的弹珠，走过的路径在同一个格子上是不会重叠的（方向相反不算重叠），且路径不存在环（可以画图理解）。\r\n\r\n枚举所有入口，模拟即可。不需要 DFS，写个循环就行。\r\n\r\n```py [sol1-Python3]\r\nDIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))  # 右下左上（顺时针）\r\n\r\nclass Solution:\r\n    def ballGame(self, num: int, plate: List[str]) -> List[List[int]]:\r\n        m, n = len(plate), len(plate[0])\r\n\r\n        def check(x: int, y: int, d: int) -> bool:\r\n            left = num\r\n            while plate[x][y] != 'O':\r\n                if left == 0: return False  # 无剩余步数\r\n                if plate[x][y] == 'W':   d = (d + 3) % 4  # 逆时针\r\n                elif plate[x][y] == 'E': d = (d + 1) % 4  # 顺时针\r\n                x += DIRS[d][0]\r\n                y += DIRS[d][1]\r\n                if not (0 <= x < m and 0 <= y < n): return False  # 出界\r\n                left -= 1\r\n            return True\r\n\r\n        ans = []\r\n        for j in range(1, n - 1):\r\n            if plate[0][j] == '.' and check(0, j, 1): ans.append([0, j])  # 上边\r\n            if plate[-1][j] == '.' and check(m - 1, j, 3): ans.append([m - 1, j])  # 下边\r\n        for i in range(1, m - 1):\r\n            if plate[i][0] == '.' and check(i, 0, 0): ans.append([i, 0])  # 左边\r\n            if plate[i][-1] == '.' and check(i, n - 1, 2): ans.append([i, n - 1])  # 右边\r\n        return ans\r\n```\r\n\r\n```go [sol1-Go]\r\nvar dirs = []struct{ x, y int }{{0, 1}, {1, 0}, {0, -1}, {-1, 0}} // 右下左上（顺时针）\r\n\r\nfunc ballGame(num int, plate []string) (ans [][]int) {\r\n\tm, n := len(plate), len(plate[0])\r\n\tcheck := func(x, y, d int) bool {\r\n\t\tfor left := num; plate[x][y] != 'O'; left-- {\r\n\t\t\tif left == 0 { // 无剩余步数\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\tif plate[x][y] == 'W' { // 逆时针\r\n\t\t\t\td = (d + 3) % 4\r\n\t\t\t} else if plate[x][y] == 'E' { // 顺时针\r\n\t\t\t\td = (d + 1) % 4\r\n\t\t\t}\r\n\t\t\tx += dirs[d].x\r\n\t\t\ty += dirs[d].y\r\n\t\t\tif x < 0 || x >= m || y < 0 || y >= n { // 从另一边出去了\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\tfor j := 1; j < n-1; j++ {\r\n\t\tif plate[0][j] == '.' && check(0, j, 1) {\r\n\t\t\tans = append(ans, []int{0, j})\r\n\t\t}\r\n\t\tif plate[m-1][j] == '.' && check(m-1, j, 3) {\r\n\t\t\tans = append(ans, []int{m - 1, j})\r\n\t\t}\r\n\t}\r\n\tfor i := 1; i < m-1; i++ {\r\n\t\tif plate[i][0] == '.' && check(i, 0, 0) {\r\n\t\t\tans = append(ans, []int{i, 0})\r\n\t\t}\r\n\t\tif plate[i][n-1] == '.' && check(i, n-1, 2) {\r\n\t\t\tans = append(ans, []int{i, n - 1})\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别为 $\\textit{plate}$ 的行数和列数。每个状态（横坐标，纵坐标，方向）至多被访问一次，总共有 $4mn$ 个状态。\r\n- 空间复杂度：$O(1)$。返回值不计入。\r\n"
}