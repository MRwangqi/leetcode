{
	"titleSlug": "reorder-data-in-log-files",
	"slug": "zhong-xin-pai-lie-ri-zhi-wen-jian-by-lee-egtm",
	"url": "https://leetcode-cn.com/problems/reorder-data-in-log-files/solution/zhong-xin-pai-lie-ri-zhi-wen-jian-by-lee-egtm/",
	"content": "#### 方法一：自定义排序\n\n**思路**\n\n根据题意自定义排序的比较方式。比较时，先将数组日志按照第一个空格分成两部分字符串，其中第一部分为标识符。第二部分的首字符可以用来判断该日志的类型。两条日志进行比较时，需要先确定待比较的日志的类型，然后按照以下规则进行比较：\n- 字母日志始终小于数字日志。\n- 数字日志保留原来的相对顺序。当使用稳定的排序算法时，可以认为所有数字日志大小一样。当使用不稳定的排序算法时，可以用日志在原数组中的下标进行比较。\n- 字母日志进行相互比较时，先比较第二部分的大小；如果相等，则比较标识符大小。比较时都使用字符串的比较方式进行比较。\n\n定义比较函数 $\\textit{logCompare}$ 时，有两个输入 $\\textit{log}_1$ 和 $\\textit{log}_2$ 。当相等时，返回 $0$；当 $\\textit{log}_1$ 大时，返回正数；当 $\\textit{log}_2$ 大时，返回负数。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def reorderLogFiles(self, logs: List[str]) -> List[str]:\n        def trans(log: str) -> tuple:\n            a, b = log.split(' ', 1)\n            return (0, b, a) if b[0].isalpha() else (1,)\n\n        logs.sort(key=trans)  # sort 是稳定排序\n        return logs\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String[] reorderLogFiles(String[] logs) {\n        int length = logs.length;\n        Pair[] arr = new Pair[length];\n        for (int i = 0; i < length; i++) {\n            arr[i] = new Pair(logs[i], i);\n        }\n        Arrays.sort(arr, (a, b) -> logCompare(a, b));\n        String[] reordered = new String[length];\n        for (int i = 0; i < length; i++) {\n            reordered[i] = arr[i].log;\n        }\n        return reordered;\n    }\n\n    public int logCompare(Pair pair1, Pair pair2) {\n        String log1 = pair1.log, log2 = pair2.log;\n        int index1 = pair1.index, index2 = pair2.index;\n        String[] split1 = log1.split(\" \", 2);\n        String[] split2 = log2.split(\" \", 2);\n        boolean isDigit1 = Character.isDigit(split1[1].charAt(0));\n        boolean isDigit2 = Character.isDigit(split2[1].charAt(0));\n        if (isDigit1 && isDigit2) {\n            return index1 - index2;\n        }\n        if (!isDigit1 && !isDigit2) {\n            int sc = split1[1].compareTo(split2[1]);\n            if (sc != 0) {\n                return sc;\n            }\n            return split1[0].compareTo(split2[0]);\n        }\n        return isDigit1 ? 1 : -1;\n    }\n}\n\nclass Pair {\n    String log;\n    int index;\n\n    public Pair(String log, int index) {\n        this.log = log;\n        this.index = index;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string[] ReorderLogFiles(string[] logs) {\n        int length = logs.Length;\n        Pair[] arr = new Pair[length];\n        for (int i = 0; i < length; i++) {\n            arr[i] = new Pair(logs[i], i);\n        }\n        Array.Sort(arr, (a, b) => LogCompare(a, b));\n        string[] reordered = new string[length];\n        for (int i = 0; i < length; i++) {\n            reordered[i] = arr[i].log;\n        }\n        return reordered;\n    }\n\n    public int LogCompare(Pair pair1, Pair pair2) {\n        string log1 = pair1.log, log2 = pair2.log;\n        int index1 = pair1.index, index2 = pair2.index;\n        string[] split1 = log1.Split(\" \", 2);\n        string[] split2 = log2.Split(\" \", 2);\n        bool isDigit1 = char.IsDigit(split1[1][0]);\n        bool isDigit2 = char.IsDigit(split2[1][0]);\n        if (isDigit1 && isDigit2) {\n            return index1 - index2;\n        }\n        if (!isDigit1 && !isDigit2) {\n            int sc = split1[1].CompareTo(split2[1]);\n            if (sc != 0) {\n                return sc;\n            }\n            return split1[0].CompareTo(split2[0]);\n        }\n        return isDigit1 ? 1 : -1;\n    }\n}\n\npublic class Pair {\n    public string log;\n    public int index;\n\n    public Pair(string log, int index) {\n        this.log = log;\n        this.index = index;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> reorderLogFiles(vector<string>& logs) {\n        stable_sort(logs.begin(), logs.end(), [&](const string & log1, const string & log2) {\n            int pos1 = log1.find_first_of(\" \");\n            int pos2 = log2.find_first_of(\" \");\n            bool isDigit1 = isdigit(log1[pos1 + 1]);\n            bool isDigit2 = isdigit(log2[pos2 + 1]);\n            if (isDigit1 && isDigit2) {\n                return false;\n            }\n            if (!isDigit1 && !isDigit2) {\n                string s1 = log1.substr(pos1);\n                string s2 = log2.substr(pos2);\n                if (s1 != s2) {\n                    return s1 < s2;\n                }\n                return log1 < log2;\n            }\n            return isDigit1 ? false : true;\n        });\n        return logs;\n    }\n};\n```\n\n```C [sol1-C]\nstruct Pair {\n    char * log;\n    int idx;\n};\n\nint logCompare(const void *log1, const void *log2) {\n    char *s1 = ((struct Pair *)log1)->log;\n    char *s2 = ((struct Pair *)log2)->log;\n    char *split1 = strstr(s1, \" \");\n    char *split2 = strstr(s2, \" \");\n    bool isDigit1 = isdigit(split1[1]);\n    bool isDigit2 = isdigit(split2[1]);\n    if (isDigit1 && isDigit2) {\n        return ((struct Pair *)log1)->idx - ((struct Pair *)log2)->idx;\n    }\n    if (!isDigit1 && !isDigit2) {\n        int sc = strcmp(split1, split2);\n        if (sc != 0) {\n            return sc;\n        }\n        return strcmp(s1, s2);\n    }\n    return isDigit1 ? 1 : -1;\n}\n\nchar ** reorderLogFiles(char ** logs, int logsSize, int* returnSize){\n    struct Pair * arr = (struct Pair *)malloc(sizeof(struct Pair) * logsSize);\n    for (int i = 0; i < logsSize; i++) {\n        arr[i].log = logs[i];\n        arr[i].idx = i;\n    }\n    qsort(arr, logsSize, sizeof(struct Pair), logCompare);\n    char ** ans = (char **)malloc(sizeof(char *) * logsSize);\n    for (int i = 0; i < logsSize; i++) {\n        ans[i] = arr[i].log;\n    }\n    *returnSize = logsSize;\n    free(arr);\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar reorderLogFiles = function(logs) {\n    const length = logs.length;\n    const arr = new Array(length).fill(0);\n    for (let i = 0; i < length; i++) {\n        arr[i] = [logs[i], i];\n    }\n    arr.sort((a, b) => logCompare(a, b));\n    const reordered = new Array(length).fill(0);\n    for (let i = 0; i < length; i++) {\n        reordered[i] = arr[i][0];\n    }\n    return reordered;\n}\n\nconst logCompare = (log1, log2) => {\n    const split1 = split(log1[0], \" \");\n    const split2 = split(log2[0], \" \");\n    const isDigit1 = isDigit(split1[1][0]);\n    const isDigit2 = isDigit(split2[1][0]);\n    if (isDigit1 && isDigit2) {\n        return log1[1] - log2[1];\n    }\n    if (!isDigit1 && !isDigit2) {\n        const sc = compareTo(split1[1], split2[1]);\n        if (sc !== 0) {\n            return sc;\n        }\n        return compareTo(split1[0], split2[0]);\n    }\n    return isDigit1 ? 1 : -1;\n};\n\nconst isDigit = (ch) => {\n    return parseFloat(ch).toString() === \"NaN\" ? false : true;\n}\n\nconst compareTo = (left, right) => {\n    for (let i = 0; i < Math.min(left.length, right.length); i++) {\n        if (left[i].charCodeAt() < right[i].charCodeAt()) {\n            return -1;\n        }\n        if (left[i].charCodeAt() > right[i].charCodeAt()) {\n            return 1;\n        }\n    }\n    if (left.length === right.length) {\n        return 0;\n    }\n    if (left.length > right.length) {\n        return 1;\n    }\n    return -1;\n}\n\nconst split = (str, separator) => {\n    const firstItem = str.split(separator)[0];\n    const ret = [firstItem];\n    const index = str.indexOf(\" \");\n    ret.push(str.slice(index + 1, str.length));\n    return ret;\n}\n```\n\n```go [sol1-Golang]\nfunc reorderLogFiles(logs []string) []string {\n    sort.SliceStable(logs, func(i, j int) bool {\n        s, t := logs[i], logs[j]\n        s1 := strings.SplitN(s, \" \", 2)[1]\n        s2 := strings.SplitN(t, \" \", 2)[1]\n        isDigit1 := unicode.IsDigit(rune(s1[0]))\n        isDigit2 := unicode.IsDigit(rune(s2[0]))\n        if isDigit1 && isDigit2 {\n            return false\n        }\n        if !isDigit1 && !isDigit2 {\n            return s1 < s2 || s1 == s2 && s < t\n        }\n        return !isDigit1\n    })\n    return logs\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是 $\\textit{logs}$ 的字符数，是平均情况下内置排序的时间复杂度。\n\n- 空间复杂度：$O(n)$ 或 $O(1)$（取决于语言实现）。需要新建数组保存 $\\textit{log}$ 和下标，需要将每条 $\\textit{log}$ 进行拆分。"
}