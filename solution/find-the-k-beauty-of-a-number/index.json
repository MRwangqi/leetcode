{
	"titleSlug": "find-the-k-beauty-of-a-number",
	"slug": "zhao-dao-yi-ge-shu-zi-de-k-mei-li-zhi-by-jn5i",
	"url": "https://leetcode-cn.com/problems/find-the-k-beauty-of-a-number/solution/zhao-dao-yi-ge-shu-zi-de-k-mei-li-zhi-by-jn5i/",
	"content": "#### 方法一：枚举\n\n**思路与算法**\n\n为了方便起见，我们用 $s$ 表示 $\\textit{num}$ 对应十进制表示的字符串。我们可以从左至右枚举 $s$ 中长度为 $k$ 的字符串，并判断该子串对应的整数能否被 $\\textit{num}$ 整除。与此同时，我们用 $\\textit{res}$ 统计能被 $\\textit{num}$ 整除的子串数量，如果某个子串能被 $\\textit{num}$ 整除，则我们将 $\\textit{res}$ 加上 $1$。最终，$\\textit{res}$ 即为 $\\textit{num}$ 的 $k$ 美丽值，我们返回 $\\textit{res}$ 作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int divisorSubstrings(int num, int k) {\n        string s = to_string(num);   // num 十进制表示字符串\n        int n = s.size();\n        int res = 0;\n        for (int i = 0; i <= n - k; ++i) {\n            // 枚举所有长度为 k 的子串\n            int tmp = stoi(s.substr(i, k));\n            if (tmp && num % tmp == 0) {\n                ++res;\n            }\n        }\n        return res;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        s = str(num)   # num 十进制表示字符串\n        n = len(s)\n        res = 0\n        for i in range(n - k + 1):\n            # 枚举所有长度为 k 的子串\n            tmp = int(s[i:i+k])\n            if tmp != 0 and num % tmp == 0:\n                res += 1\n        return res\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(nk)$，其中 $n$ 为 $\\textit{num}$ 的位数, $k$ 为子串的长度。我们总共需要枚举 $O(n)$ 个子串，其中判断每个子串都需要 $O(k)$ 的时间复杂度。\n\n- 空间复杂度：$O(n)$，即为辅助字符串的空间开销。"
}