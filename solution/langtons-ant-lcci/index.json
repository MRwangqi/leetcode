{
	"titleSlug": "langtons-ant-lcci",
	"slug": "28miao-shuang-100nei-bu-lei-san-lie-ji-he-by-1ujin",
	"url": "https://leetcode-cn.com/problems/langtons-ant-lcci/solution/28miao-shuang-100nei-bu-lei-san-lie-ji-he-by-1ujin/",
	"content": "![langtonsant.png](https://pic.leetcode-cn.com/70ffcb33f6ed1ec63f9d4fe05043bf462b2f613bbb94acf5cea5f70468e15406-langtonsant.png)\n\n### 解题思路\n目前比执行用时分布图表里最快的还快。\n多看题目下方的提示，“并不真的需要一个网格”，蚂蚁的下一步坐标可以由当前状态计算出，所以保存并时刻更新蚂蚁的状态，用集合保存块的位置，最后再通过集合生成字符串列表。详细思路全在注释中了。\n![LangtonsAntAnimated.gif](https://pic.leetcode-cn.com/3cf257af4f609125a0af9ab99581b41edd5da2ce15591db5560c7cef7320be8f-LangtonsAntAnimated.gif)\n盗了一张维基的动图\n\n### 代码\n\n```java\nclass Solution {\n    private class Position {\n        \n        // 横坐标 x 纵坐标 y\n        int x, y;\n        \n        public Position(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) return true;\n            if (!(obj instanceof Position)) return false;\n            Position o = (Position) obj;\n            return x == o.x && y == o.y;\n        }\n        \n        // 改写哈希算法，使两个 Position 对象可以比较坐标而不是内存地址\n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            return result;\n        }\n    }\n    \n    public List<String> printKMoves(int K) {\n        char[] direction = {'L', 'U', 'R', 'D'};\n        // 用“向量”记录方向，顺序与上一行方向的字符顺序保持一致，每个元素的后一个元素都是可以90°向右变换得到的\n        int[][] offset = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\n        // 蚂蚁的位置\n        Position antPos = new Position(0, 0);\n        // 蚂蚁方向的向量序号\n        int antDir = 2;\n        // 用集合存储所有黑块的坐标，一开始想再定义一个路径的坐标集合，发现可以直接用黑块+蚂蚁位置也能过\n        Set<Position> blackSet = new HashSet<>();\n        while (K > 0) {\n            // 新的坐标对象用于放入集合\n            Position t = new Position(antPos.x, antPos.y);\n            // 如果黑块集合能存入，说明脚下的块不在集合中，也就意味着是白色，方向序号循环自增1\n            if (blackSet.add(t)) antDir = (antDir + 1) % 4;\n            else {\n                // 否则说明脚下的块已经在集合中，也就意味着是黑色，方向序号循环自增3，相当于自减1，但是Math.floorMod取模可能消耗大？用+3替代\n                antDir = (antDir + 3) % 4;\n                // 别忘了删除，即将黑块变白\n                blackSet.remove(t);\n            }\n            // 蚂蚁移动位置\n            antPos.x += offset[antDir][0];\n            antPos.y += offset[antDir][1];\n            K--;\n        }\n        // 计算边界，即输出网格的行数和列数\n        int left = antPos.x, top = antPos.y, right = antPos.x, bottom = antPos.y;\n        for (Position pos : blackSet) {\n            left = pos.x < left ? pos.x : left;\n            top = pos.y < top ? pos.y : top;\n            right = pos.x > right ? pos.x : right;\n            bottom = pos.y > bottom ? pos.y : bottom;\n        }\n        char[][] grid = new char[bottom - top + 1][right - left + 1];\n        // 填充白块\n        for (char[] row : grid)\n            Arrays.fill(row, '_');\n        // 替换黑块\n        for (Position pos : blackSet)\n            grid[pos.y - top][pos.x - left] = 'X';\n        // 替换蚂蚁\n        grid[antPos.y - top][antPos.x - left] = direction[antDir];\n        // 利用网格生成字符串列表\n        List<String> result = new ArrayList<>();\n        for (char[] row : grid)\n            result.add(String.valueOf(row));\n        return result;\n    }\n}\n```"
}