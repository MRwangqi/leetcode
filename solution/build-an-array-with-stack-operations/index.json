{
	"titleSlug": "build-an-array-with-stack-operations",
	"slug": "yong-zhan-cao-zuo-gou-jian-shu-zu-by-lee-omde",
	"url": "https://leetcode-cn.com/problems/build-an-array-with-stack-operations/solution/yong-zhan-cao-zuo-gou-jian-shu-zu-by-lee-omde/",
	"content": "#### 方法一：模拟\n\n**思路**\n\n操作的对象是 $1$ 到 $n$ 按顺序排列的数字，每次操作一个数字时，如果它在 $\\textit{target}$ 中，则只需要将它 $\\texttt{Push}$ 入栈即可。如果不在 $\\textit{target}$ 中，可以先将其 $\\texttt{Push}$ 入栈，紧接着 $\\texttt{Pop}$ 出栈。因为 $\\textit{target}$ 中数字是严格递增的，因此只要遍历 $\\textit{target}$，在 $\\textit{target}$ 中每两个连续的数字 $\\textit{prev}$ 和 $\\textit{number}$ 中插入 $\\textit{number} - \\textit{prev} - 1$ 个 $\\texttt{Push}$ 和 $\\texttt{Pop}$，再多加一个 $\\texttt{Push}$ 来插入当前数字即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def buildArray(self, target: List[int], n: int) -> List[str]:\n        res = []\n        prev = 0\n        for number in target:\n            for _ in range(number - prev - 1):\n                res.append('Push')\n                res.append('Pop')\n            res.append('Push')\n            prev = number\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<String> buildArray(int[] target, int n) {\n        List<String> res = new ArrayList<String>();\n        int prev = 0;\n        for (int number : target) {\n            for (int i = 0; i < number - prev - 1; i++) {\n                res.add(\"Push\");\n                res.add(\"Pop\");\n            }\n            res.add(\"Push\");\n            prev = number;\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<string> BuildArray(int[] target, int n) {\n        IList<string> res = new List<string>();\n        int prev = 0;\n        foreach (int number in target) {\n            for (int i = 0; i < number - prev - 1; i++) {\n                res.Add(\"Push\");\n                res.Add(\"Pop\");\n            }\n            res.Add(\"Push\");\n            prev = number;\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> buildArray(vector<int>& target, int n) {\n        vector<string> res;\n        int prev = 0;\n        for (int number : target) {\n            for (int i = 0; i < number - prev - 1; i++) {\n                res.emplace_back(\"Push\");\n                res.emplace_back(\"Pop\");\n            }\n            res.emplace_back(\"Push\");\n            prev = number;\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\nchar ** buildArray(int* target, int targetSize, int n, int* returnSize) {\n    char **res = (char **)malloc(sizeof(char *) * n * 2);\n    int prev = 0, pos = 0;\n    for (int j = 0; j < targetSize; j++) {\n        for (int i = 0; i < target[j] - prev - 1; i++) {\n            res[pos] = (char *)malloc(sizeof(char) * 8);\n            strcpy(res[pos++], \"Push\");\n            res[pos] = (char *)malloc(sizeof(char) * 8);\n            strcpy(res[pos++], \"Pop\");\n        }\n        res[pos] = (char *)malloc(sizeof(char) * 8);\n        strcpy(res[pos++], \"Push\");\n        prev = target[j];\n    }\n    *returnSize = pos;\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar buildArray = function(target, n) {\n    const res = [];\n    let prev = 0;\n    for (const number of target) {\n        for (let i = 0; i < number - prev - 1; i++) {\n            res.push(\"Push\");\n            res.push(\"Pop\");\n        }\n        res.push(\"Push\");\n        prev = number;\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc buildArray(target []int, n int) (ans []string) {\n    prev := 0\n    for _, number := range target {\n        for i := 0; i < number-prev-1; i++ {\n            ans = append(ans, \"Push\", \"Pop\")\n        }\n        ans = append(ans, \"Push\")\n        prev = number\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。$\\texttt{Push}$ 需要添加 $O(n)$ 次。\n\n- 空间复杂度：$O(1)$。除了保存结果的数组，其他只消耗常数空间。"
}