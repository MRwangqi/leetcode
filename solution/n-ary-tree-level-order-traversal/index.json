{
	"titleSlug": "n-ary-tree-level-order-traversal",
	"slug": "n-cha-shu-de-ceng-xu-bian-li-by-leetcode-lxdr",
	"url": "https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/n-cha-shu-de-ceng-xu-bian-li-by-leetcode-lxdr/",
	"content": "#### 方法一：广度优先搜索\n\n**思路与算法**\n\n对于「层序遍历」的题目，我们一般使用广度优先搜索。在广度优先搜索的每一轮中，我们会遍历同一层的所有节点。\n\n具体地，我们首先把根节点 $\\textit{root}$ 放入队列中，随后在广度优先搜索的每一轮中，我们首先记录下当前队列中包含的节点个数（记为 $\\textit{cnt}$），即表示上一层的节点个数。在这之后，我们从队列中依次取出节点，直到取出了上一层的全部 $\\textit{cnt}$ 个节点为止。当取出节点 $\\textit{cur}$ 时，我们将 $\\textit{cur}$ 的值放入一个临时列表，再将 $\\textit{cur}$ 的所有子节点全部放入队列中。\n\n当这一轮遍历完成后，临时列表中就存放了当前层所有节点的值。这样一来，当整个广度优先搜索完成后，我们就可以得到层序遍历的结果。\n\n**细节**\n\n需要特殊判断树为空的情况。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(Node* root) {\n        if (!root) {\n            return {};\n        }\n\n        vector<vector<int>> ans;\n        queue<Node*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            int cnt = q.size();\n            vector<int> level;\n            for (int i = 0; i < cnt; ++i) {\n                Node* cur = q.front();\n                q.pop();\n                level.push_back(cur->val);\n                for (Node* child: cur->children) {\n                    q.push(child);\n                }\n            }\n            ans.push_back(move(level));\n        }\n\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        if (root == null) {\n            return new ArrayList<List<Integer>>();\n        }\n\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        Queue<Node> queue = new ArrayDeque<Node>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int cnt = queue.size();\n            List<Integer> level = new ArrayList<Integer>();\n            for (int i = 0; i < cnt; ++i) {\n                Node cur = queue.poll();\n                level.add(cur.val);\n                for (Node child : cur.children) {\n                    queue.offer(child);\n                }\n            }\n            ans.add(level);\n        }\n\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<IList<int>> LevelOrder(Node root) {\n        if (root == null) {\n            return new List<IList<int>>();\n        }\n\n        IList<IList<int>> ans = new List<IList<int>>();\n        Queue<Node> queue = new Queue<Node>();\n        queue.Enqueue(root);\n\n        while (queue.Count > 0) {\n            int cnt = queue.Count;\n            IList<int> level = new List<int>();\n            for (int i = 0; i < cnt; ++i) {\n                Node cur = queue.Dequeue();\n                level.Add(cur.val);\n                foreach (Node child in cur.children) {\n                    queue.Enqueue(child);\n                }\n            }\n            ans.Add(level);\n        }\n\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def levelOrder(self, root: 'Node') -> List[List[int]]:\n        if not root:\n            return []\n\n        ans = list()\n        q = deque([root])\n\n        while q:\n            cnt = len(q)\n            level = list()\n            for _ in range(cnt):\n                cur = q.popleft()\n                level.append(cur.val)\n                for child in cur.children:\n                    q.append(child)\n            ans.append(level)\n\n        return ans\n```\n\n```go [sol1-Golang]\nfunc levelOrder(root *Node) (ans [][]int) {\n    if root == nil {\n        return\n    }\n    q := []*Node{root}\n    for q != nil {\n        level := []int{}\n        tmp := q\n        q = nil\n        for _, node := range tmp {\n            level = append(level, node.Val)\n            q = append(q, node.Children...)\n        }\n        ans = append(ans, level)\n    }\n    return\n}\n```\n\n```C [sol1-C]\n#define MAX_LEVE_SIZE 1000\n#define MAX_NODE_SIZE 10000\n\nint** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) {\n    int ** ans = (int **)malloc(sizeof(int *) * MAX_LEVE_SIZE);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * MAX_LEVE_SIZE);\n    if (!root) {\n        *returnSize = 0;\n        return ans;\n    }\n    struct Node ** queue = (struct Node **)malloc(sizeof(struct Node *) * MAX_NODE_SIZE);\n    int head = 0, tail = 0;\n    int level = 0;\n    queue[tail++] = root;\n\n    while (head != tail) {\n        int cnt = tail - head;\n        ans[level] = (int *)malloc(sizeof(int) * cnt);\n        for (int i = 0; i < cnt; ++i) {\n            struct Node * cur = queue[head++];\n            ans[level][i] = cur->val;\n            for (int j = 0; j < cur->numChildren; j++) {\n                queue[tail++] = cur->children[j];\n            }\n        }\n        (*returnColumnSizes)[level++] = cnt;\n    }\n    *returnSize = level;\n    free(queue);\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar levelOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const ans = [];\n    const queue = [root];\n\n    while (queue.length) {\n        const cnt = queue.length;\n        const level = [];\n        for (let i = 0; i < cnt; ++i) {\n            const cur = queue.shift();\n            level.push(cur.val);\n            for (const child of cur.children) {\n                queue.push(child);\n            }\n        }\n        ans.push(level);\n    }\n\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是树中包含的节点个数。在广度优先搜索的过程中，我们需要遍历每一个节点恰好一次。\n\n- 空间复杂度：$O(n)$，即为队列需要使用的空间。在最坏的情况下，树只有两层，且最后一层有 $n-1$ 个节点，此时就需要 $O(n)$ 的空间。"
}