{
	"titleSlug": "equal-sum-arrays-with-minimum-number-of-operations",
	"slug": "you-xian-dui-lie-by-amjieker-47as",
	"url": "https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations/solution/you-xian-dui-lie-by-amjieker-47as/",
	"content": "两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）\r\n\r\n题目要求我们让两个数组的和相等\r\n\r\n抛开其他的不谈，对于两个值，要想让他们相等，那么就是一个**双向奔赴**的过程啦！\r\n\r\n那么，对于**双向奔赴**来说，我们要找出最小的步数\r\n\r\n那么，我们原数组中增加或者减小对应着什么呢？\r\n\r\n对应着我们比较**大的数组的减小**和比较**小的数组的增大**\r\n\r\n大的数组减小最少为1，所以对于每一个位置可以减小的值为 v - 1\r\n\r\n小的数组增大最大为6，所以对于每一个位置可以增大的值为 6 - v\r\n\r\n然后，我们将其存入优先队列中去，**优先考虑减去大的差值**\r\n\r\n这样，我们就可以实现最优化操作了\r\n\r\n\r\n```rust\r\nuse std::collections::{BinaryHeap};\r\nuse std::mem::swap;\r\nimpl Solution {\r\n    pub fn min_operations(a: Vec<i32>, b: Vec<i32>) -> i32 {\r\n        if a.len() * 6 < b.len() || b.len() * 6 < a.len() {\r\n            return -1;\r\n        }\r\n        let (mut a, mut b) = (a, b);\r\n        let (mut n, mut m) = (a.len(), b.len());\r\n        let (mut s1, mut s2): (i32, i32) = (a.iter().sum(), b.iter().sum());\r\n        let mut pq = BinaryHeap::new();\r\n        if s1 < s2 {\r\n            swap(&mut s1, &mut s2);\r\n            swap(&mut a, &mut b);\r\n        }\r\n        a.iter().for_each(|&v| pq.push(v - 1));\r\n        b.iter().for_each(|&v| pq.push(6 - v));\r\n        let (mut ans, mut k) = (0, s1 - s2);\r\n        while k > 0 {\r\n            ans += 1;\r\n            k -= pq.pop().unwrap();\r\n        }\r\n        ans\r\n    }\r\n}\r\n```"
}