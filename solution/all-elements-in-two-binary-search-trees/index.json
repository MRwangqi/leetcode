{
	"titleSlug": "all-elements-in-two-binary-search-trees",
	"slug": "liang-ke-er-cha-sou-suo-shu-zhong-de-suo-you-yua-3",
	"url": "https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/solution/liang-ke-er-cha-sou-suo-shu-zhong-de-suo-you-yua-3/",
	"content": "#### 方法一：中序遍历 + 归并\n\n回顾二叉搜索树的定义：\n\n- 当前节点的左子树中的数均**小于**当前节点的数；\n- 当前节点的右子树中的数均**大于**当前节点的数；\n- 所有左子树和右子树自身也是二叉搜索树。\n\n根据上述定义，我们可以用中序遍历访问二叉搜索树，即按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候也按照同样的方式遍历，直到遍历完整棵树。遍历结束后，就得到了一个有序数组。\n\n由于整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。具体描述见 [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) 的 [官方题解](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/)。\n\n中序遍历这两棵二叉搜索树，可以得到两个有序数组。然后可以使用双指针方法来合并这两个有序数组，这一方法将两个数组看作两个队列，每次从队列头部取出比较小的数字放到结果中（头部相同时可任取一个）。如下面的动画所示：\n\n![gif1](https://assets.leetcode-cn.com/solution-static/88/1.gif){:width=540}\n\n```Python [sol1-Python3]\nclass Solution:\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\n        def inorder(node: TreeNode, res: List[int]):\n            if node:\n                inorder(node.left, res)\n                res.append(node.val)\n                inorder(node.right, res)\n\n        nums1, nums2 = [], []\n        inorder(root1, nums1)\n        inorder(root2, nums2)\n\n        merged = []\n        p1, n1 = 0, len(nums1)\n        p2, n2 = 0, len(nums2)\n        while True:\n            if p1 == n1:\n                merged.extend(nums2[p2:])\n                break\n            if p2 == n2:\n                merged.extend(nums1[p1:])\n                break\n            if nums1[p1] < nums2[p2]:\n                merged.append(nums1[p1])\n                p1 += 1\n            else:\n                merged.append(nums2[p2])\n                p2 += 1\n        return merged\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    void inorder(TreeNode *node, vector<int> &res) {\n        if (node) {\n            inorder(node->left, res);\n            res.push_back(node->val);\n            inorder(node->right, res);\n        }\n    }\n\npublic:\n    vector<int> getAllElements(TreeNode *root1, TreeNode *root2) {\n        vector<int> nums1, nums2;\n        inorder(root1, nums1);\n        inorder(root2, nums2);\n\n        vector<int> merged;\n        auto p1 = nums1.begin(), p2 = nums2.begin();\n        while (true) {\n            if (p1 == nums1.end()) {\n                merged.insert(merged.end(), p2, nums2.end());\n                break;\n            }\n            if (p2 == nums2.end()) {\n                merged.insert(merged.end(), p1, nums1.end());\n                break;\n            }\n            if (*p1 < *p2) {\n                merged.push_back(*p1++);\n            } else {\n                merged.push_back(*p2++);\n            }\n        }\n        return merged;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n        List<Integer> nums1 = new ArrayList<Integer>();\n        List<Integer> nums2 = new ArrayList<Integer>();\n        inorder(root1, nums1);\n        inorder(root2, nums2);\n\n        List<Integer> merged = new ArrayList<Integer>();\n        int p1 = 0, p2 = 0;\n        while (true) {\n            if (p1 == nums1.size()) {\n                merged.addAll(nums2.subList(p2, nums2.size()));\n                break;\n            }\n            if (p2 == nums2.size()) {\n                merged.addAll(nums1.subList(p1, nums1.size()));\n                break;\n            }\n            if (nums1.get(p1) < nums2.get(p2)) {\n                merged.add(nums1.get(p1++));\n            } else {\n                merged.add(nums2.get(p2++));\n            }\n        }\n        return merged;\n    }\n\n    public void inorder(TreeNode node, List<Integer> res) {\n        if (node != null) {\n            inorder(node.left, res);\n            res.add(node.val);\n            inorder(node.right, res);\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> GetAllElements(TreeNode root1, TreeNode root2) {\n        IList<int> nums1 = new List<int>();\n        IList<int> nums2 = new List<int>();\n        Inorder(root1, nums1);\n        Inorder(root2, nums2);\n\n        IList<int> merged = new List<int>();\n        int p1 = 0, p2 = 0;\n        while (true) {\n            if (p1 == nums1.Count) {\n                while (p2 < nums2.Count) {\n                    merged.Add(nums2[p2++]);\n                }\n                break;\n            }\n            if (p2 == nums2.Count) {\n                while (p1 < nums1.Count) {\n                    merged.Add(nums1[p1++]);\n                }\n                break;\n            }\n            if (nums1[p1] < nums2[p2]) {\n                merged.Add(nums1[p1++]);\n            } else {\n                merged.Add(nums2[p2++]);\n            }\n        }\n        return merged;\n    }\n\n    public void Inorder(TreeNode node, IList<int> res) {\n        if (node != null) {\n            Inorder(node.left, res);\n            res.Add(node.val);\n            Inorder(node.right, res);\n        }\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc inorder(root *TreeNode) (res []int) {\n    var dfs func(*TreeNode)\n    dfs = func(node *TreeNode) {\n        if node == nil {\n            return\n        }\n        dfs(node.Left)\n        res = append(res, node.Val)\n        dfs(node.Right)\n    }\n    dfs(root)\n    return\n}\n\nfunc getAllElements(root1, root2 *TreeNode) []int {\n    nums1 := inorder(root1)\n    nums2 := inorder(root2)\n\n    p1, n1 := 0, len(nums1)\n    p2, n2 := 0, len(nums2)\n    merged := make([]int, 0, n1+n2)\n    for {\n        if p1 == n1 {\n            return append(merged, nums2[p2:]...)\n        }\n        if p2 == n2 {\n            return append(merged, nums1[p1:]...)\n        }\n        if nums1[p1] < nums2[p2] {\n            merged = append(merged, nums1[p1])\n            p1++\n        } else {\n            merged = append(merged, nums2[p2])\n            p2++\n        }\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX_NODE_SIZE 5001\n\nvoid inorder(struct TreeNode *node, int *res, int *pos) {\n    if (node) {\n        inorder(node->left, res, pos);\n        res[(*pos)++] = node->val;\n        inorder(node->right, res, pos);\n    }\n}\n\nint* getAllElements(struct TreeNode* root1, struct TreeNode* root2, int* returnSize) {\n    int *nums1 = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    int *nums2 = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    int pos1 = 0, pos2 = 0;\n    inorder(root1, nums1, &pos1);\n    inorder(root2, nums2, &pos2);\n\n    int *merged = (int *)malloc(sizeof(int) * (pos1 + pos2));\n    int p1 = 0, p2 = 0;\n    int pos = 0;\n    while (true) {\n        if (p1 == pos1) {\n            memcpy(merged + pos, nums2 + p2, sizeof(int) * (pos2 - p2));\n            break;\n        }\n        if (p2 == pos2) {\n            memcpy(merged + pos, nums1 + p1, sizeof(int) * (pos1 - p1));\n            break;\n        }\n        if (nums1[p1] < nums2[p2]) {\n            merged[pos++] = nums1[p1++];\n        } else {\n            merged[pos++] = nums2[p2++];\n        }\n    }\n    *returnSize = pos1 + pos2;\n    return merged;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar getAllElements = function(root1, root2) {\n    const nums1 = [];\n    const nums2 = [];\n\n    const inorder = (node, res) => {\n    if (node) {\n            inorder(node.left, res);\n            res.push(node.val);\n            inorder(node.right, res);\n        }\n    };\n\n    inorder(root1, nums1);\n    inorder(root2, nums2);\n\n    const merged = [];\n    let p1 = 0, p2 = 0;\n    while (true) {\n        if (p1 === nums1.length) {\n            for (let i = p2; i < nums2.length; i++) {\n                merged.push(nums2[i]);\n            }\n            break;\n        }\n        if (p2 === nums2.length) {\n            for (let i = p1; i < nums1.length;i++) {\n                merged.push(nums1[i]);\n            }\n            break;\n        }\n        if (nums1[p1] < nums2[p2]) {\n            merged.push(nums1[p1++]);\n        } else {\n            merged.push(nums2[p2++]);\n        }\n    }\n    return merged;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n+m)$，其中 $n$ 和 $m$ 分别为两棵二叉搜索树的节点个数。\n\n- 空间复杂度：$O(n+m)$。存储数组以及递归时的栈空间均为 $O(n+m)$。"
}