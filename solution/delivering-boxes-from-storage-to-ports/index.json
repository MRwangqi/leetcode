{
	"titleSlug": "delivering-boxes-from-storage-to-ports",
	"slug": "cong-cang-ku-dao-ma-tou-yun-shu-xiang-zi-dqnq",
	"url": "https://leetcode-cn.com/problems/delivering-boxes-from-storage-to-ports/solution/cong-cang-ku-dao-ma-tou-yun-shu-xiang-zi-dqnq/",
	"content": "#### 方法一：动态规划 + 单调队列优化\n\n**前言**\n\n为了叙述方便，设箱子的数量为 $n$，它们的目的地分别为 $p_1, \\cdots, p_n$，重量分别为 $w_1, \\cdots, w_n$。\n\n令 $W_i$ 表示 $w$ 的前缀和，即\n\n$$\nW_i = \\sum_{k=1}^i w_i\n$$\n\n运送时箱子数量的限制为 $\\textit{bound}_\\textit{num}$，重量的限制为 $\\textit{bound}_w$。\n\n令示性函数 $\\mathbb{I}(i)$ 表示 $p_i$ 和 $p_{i+1}$ 是否不等，即\n\n$$\n\\mathbb{I}(i) = \\begin{cases}\n0, \\quad p_i = p_{i+1} \\\\\n1, \\quad p_i \\neq p_{i+1}\n\\end{cases}\n$$\n\n令 $\\text{neg}(i, j)$ 表示 $p_i, \\cdots, p_j$ 相邻两项不等的次数，即\n\n$$\n\\text{neg}(i, j) = \\sum_{k=i}^{j-1} \\mathbb{I}(i)\n$$\n\n特别地，令 $\\text{neg}(i) = \\text{neg}(1, i)$ 表示前缀和。\n\n**思路与算法**\n\n令 $f_i$ 表示**运送前 $i$ 个箱子需要的最少行程次数**，我们可以很容易写出状态转移方程：\n\n$$\n\\begin{aligned}\n& f_i = \\min \\big\\{  f_j + \\text{neg}(j+1,i) + 2 \\big\\} \\\\\\\\\n\\text{subject to} \\quad & i-j \\leq \\textit{bound}_\\textit{num} \\\\\n& W_i-W_j \\leq \\textit{bound}_w\n\\end{aligned}\n$$\n\n即枚举上一次运送的最后一个箱子为 $j$，这一次运送的箱子为 $[j+1, i]$，要求箱子的数量不超过 $\\textit{bound}_\\textit{num}$，重量只和不超过 $\\textit{bound}_w$。运送的行程次数即为 $p_{j+1}, \\cdots, p_i$ 相邻两项不等的次数 $\\text{neg}(j+1, i)$ 加上来回的 $2$ 次。\n\n边界条件为 $f_0 = 0$，最终答案即为 $f_n$。\n\n**优化**\n\n然而这样动态规划的时间复杂度为 $O(n^2)$，我们考虑进行优化。\n\n注意到 $\\text{neg}(j+1, i)$ 可以拆分成两个前缀和的差，即\n\n$$\n\\text{neg}(j+1, i) = \\text{neg}(i) - \\text{neg}(j+1)\n$$\n\n带入原状态转移方程\n\n$$\n\\begin{aligned}\nf_i &= \\min \\big\\{  f_j + \\text{neg}(j+1,i) + 2 \\big\\} \\\\\n&= \\min \\big\\{  f_j + \\text{neg}(i) - \\text{neg}(j+1) + 2 \\big\\} \\\\\n&= \\min \\big\\{  f_j - \\text{neg}(j+1) \\big\\} + \\text{neg}(i) + 2\n\\end{aligned}\n$$\n\n令 $g_j = f_j - \\text{neg}(j+1)$，状态转移方程即为\n\n$$\nf_i = \\min \\{ g_j \\} + \\text{neg}(i) + 2\n$$\n\n如果没有限制条件，那么我们实时维护 $g_j$ 的最小值进行 $O(1)$ 的转移即可，但在有 $i-j \\leq \\textit{bound}_\\textit{num}$ 以及 $W_i-W_j \\leq \\textit{bound}_w$ 的限制时，$g_j$ 不一定是合法的。\n\n然而我们可以发现 $j$ 和 $W_j$ 都是「随着 $j$」单调递增的，即如果 $i=i_0$ 时，某个 $j_0$ 不满足限制条件，那么当 $i>i_0$ 时，$i-j_0$ 以及 $W_i-W_{j_0}$ 的值不会减小，$j_0$ 将永远不可能重新满足条件。因此我们可以使用单调队列按照 $g_j$ 从小到大的顺序维护所有的 $j$，这样就可以 $O(1)$ 转移了。\n\n不会单调队列怎么办？学习一下吧～\n\n**代码**\n\n代码中很多变量都是为了和文字部分保持一致而添加的，如果熟练了掌握了本题使用的方法，可以优化掉一些变量。\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int boxDelivering(vector<vector<int>>& boxes, int _, int bound_num, int bound_w) {\n        int n = boxes.size();\n        vector<int> p(n + 1), w(n + 1), neg(n + 1);\n        vector<long long> W(n + 1);\n        for (int i = 1; i <= n; ++i) {\n            p[i] = boxes[i - 1][0];\n            w[i] = boxes[i - 1][1];\n            if (i > 1) {\n                neg[i] = neg[i - 1] + (p[i - 1] != p[i]);\n            }\n            W[i] = W[i - 1] + w[i];\n        }\n        \n        deque<int> opt = {0};\n        vector<int> f(n + 1), g(n + 1);\n        \n        for (int i = 1; i <= n; ++i) {\n            while (!opt.empty() && (i - opt.front() > bound_num || W[i] - W[opt.front()] > bound_w)) {\n                opt.pop_front();\n            }\n            \n            f[i] = g[opt.front()] + neg[i] + 2;\n            \n            if (i != n) {\n                g[i] = f[i] - neg[i + 1];\n                while (!opt.empty() && g[i] <= g[opt.back()]) {\n                    opt.pop_back();\n                }\n                opt.push_back(i);\n            }\n        }\n        \n        return f[n];\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。\n\n- 空间复杂度：$O(n)$。"
}