{
	"titleSlug": "minimum-limit-of-balls-in-a-bag",
	"slug": "by-philco_z-47hh",
	"url": "https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/solution/by-philco_z-47hh/",
	"content": "# 解题思路\r\n\r\n- 重点：理解题意，将题目转化为可以实现的问题\r\n\r\n## 1. 题目转化\r\n\r\n> 参考提示1：Let's change the question if we know the maximum size of a bag what is the minimum number of bags you can make\r\n\r\n题目为：给定拆分次数，寻找单个袋子球数的最大值\r\n\r\n将题目转化为：给定单个袋子球数的最大值，计算拆分次数（如果一个袋子最多只能装`x`个球，需要拆分多少次？）\r\n\r\n注意到，**每个袋子能装的球越多，则需要拆分的次数就越少**，例如如果每个袋子都能装`max(nums)`个球，则需要拆分的次数为0。因此拆分次数y关于x单调递减，具有**单调性**。\r\n\r\n当`y>maxOperations`时，说明`x`不合题意，开销应该大于`x`，则`x+=1`；随着`x`的增加，当`y`首次等于`maxOperations`时的`x`即为符合题意的答案。由单调性，此过程可以用**二分查找**。\r\n\r\n对每个`x`，得到的拆分次数`y`可以看作一个**降序排列**的数组，从左到右**第一个等于**`maxOperations`的`y`对应的“索引”`x`即为要找的最小化开销（满足题意条件的最小的`x`值）。\r\n\r\n## 2. 拆分次数计算\r\n\r\n这个降序排列的数组不像常规的二分查找数组，我们事先并不知道数组中每个索引对应的值，不能直接通过`arr[x]`调用，因此每次需要对索引`x=mid`进行拆分次数`y`的计算。我写了一个函数`oper_time(x)`来进行拆分次数的计算。\r\n\r\n拆分过程如下：\r\n\r\n对于第`i`个袋子，有`nums[i]`个球，如果`nums[i]>x`，则需要进行拆分：首先拆分为`x`和`nums[i]-x`，如果`nums[i]-x>x`，则这一个新袋子又要进行拆分……\r\n\r\n**整个过程可以简化为：**\r\n1. 如果`nums[i]`能被`x`整除，则拆分次数为`nums[i]//x-1`（可以少拆分一次，减去最后不必要的一次拆分x和0）；\r\n2. 如果`nums[i]`不能被`x`整除，则拆分次数为`nums[i]//x`（最后一次拆分为x和余数（余数大于0））。\r\n\r\n**将两种情况综合起来，则拆分次数可以合并为**`(nums[i]-1)//x`，因为：对第一种情况来说，不存在不必要的一次拆分了，最后一次拆分为x和x-1；对第二种情况来说，最后一次拆分不会消失，只是余数可能等于0。\r\n\r\n最后，将每个袋子的拆分次数加起来，返回一个袋子最多能装`x`个球的情况下需要进行的拆分次数。\r\n\r\n## 3. 二分查找\r\n\r\n二分查找很简单，就注意两点：\r\n1. `x`的取值范围：可以取作`[1, max(nums)]`。\r\n2. 指针移动的方式：\r\n如果`oper_time(mid) == maxOperations`，不能直接跳出循环，因为`mid`左边还有可能有更小的`x`值对应同样的拆分次数`maxOperations`，但也不能将右指针左移到`mid-1`，因为`mid`左边也可能对应的所有拆分次数都已经大于`maxOperations`了。故当`oper_time(mid) <= maxOperations`时，`r = mid`；否则，`l = mid + 1`。\r\n\r\n\r\n# 代码\r\n\r\n```python \r\nclass Solution:\r\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\r\n        # 【参考提示】【重点：理解题意，将题目转化为可以实现的问题】如果一个袋子最多只能装x个，需要拆分y次；每个袋子能能装的球数越多，则需要拆分的次数越少（具有单调性）\r\n        # 当y>maxOperations时，说明x不合题意，则x+=1，第一次当y=maxOperations时的x即为符合题意的答案（此过程可以用二分查找）\r\n\r\n        def oper_time(x):\r\n            # x是每个袋子最多装的球个数，返回拆分次数\r\n            oper = 0\r\n            for bag in nums:\r\n                if bag > x:\r\n                    oper += (bag-1)//x\r\n            return oper\r\n\r\n        # 进行二分查找 因为oper_time是随着x的增加单调递减的\r\n        l, r = 1, max(nums)\r\n        if oper_time(l) == maxOperations:\r\n            return l\r\n        while l < r:\r\n            mid = (l+r)//2\r\n            if oper_time(mid) <= maxOperations:\r\n                r = mid\r\n            else:\r\n                l = mid + 1\r\n        return l\r\n\r\n```\r\n\r\n"
}