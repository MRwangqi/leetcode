{
	"titleSlug": "jump-game-vi",
	"slug": "tiao-yue-you-xi-vi-by-zerotrac2-r1kq",
	"url": "https://leetcode-cn.com/problems/jump-game-vi/solution/tiao-yue-you-xi-vi-by-zerotrac2-r1kq/",
	"content": "#### 方法一：动态规划 + 优先队列优化\n\n**思路与算法**\n\n我们用 $f[i]$ 表示从下标 $0$ 跳到下标 $i$ 的**最大得分**，显然有如下的状态转移方程：\n\n$$\nf[i] = \\max_{\\max(0, i-k) \\leq j < i} \\{ f[j] \\} + \\textit{nums}[i]\n$$\n\n即我们考虑是从下标 $j$ 跳到下标 $i$ 的，那么 $j$ 与 $i$ 的间隔不能超过 $k$，即 $i-k \\leq j$；并且 $j$ 不能超过边界，即 $j \\geq 0$。\n\n边界条件为 $f[0] = \\textit{nums}[0]$，最终答案即为 $f[n-1]$。\n\n然而使用上面的状态转移方程进行动态规划，时间复杂度为 $O(nk)$，会超出时间限制，因此我们需要进行优化。\n\n由于我们要最大化 $f[j]$，因此我们可以使用优先队列（堆）维护所有的 $(f[j], j)$ 二元组，这样优先队列的堆顶元素就是我们的最优转移。同时需要注意的是，对于当前的 $i$，优先队列中的最大值的 $j$ 可能已经不满足 $\\max(0, i-k) \\leq j < i$ 的限制，并且**随着 $i$ 的增加**，原本不满足限制的 $j$ 仍然是不满足限制的。因此一旦堆顶元素不满足限制了，我们就可以把它「永久」从堆中移除。\n\n这里我们同样可以使用平衡树代替优先队列，时间复杂度不变。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxResult(vector<int>& nums, int k) {\n        int n = nums.size();\n        \n        // 优先队列中的二元组即为 (f[j], j)\n        priority_queue<pair<int, int>> q;\n        q.emplace(nums[0], 0);\n        int ans = nums[0];\n        \n        for (int i = 1; i < n; ++i) {\n            // 堆顶的 j 不满足限制\n            while (i - q.top().second > k) {\n                q.pop();\n            }\n            \n            ans = q.top().first + nums[i];\n            q.emplace(ans, i);\n        }\n        \n        return ans;\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$。\n\n- 空间复杂度：$O(n)$。\n\n#### 方法二：动态规划 + 单调队列优化\n\n**思路与算法**\n\n我们也可以使用单调队列对状态转移方程进行优化。\n\n对于 $j_1 < j_2$，如果 $f[j_1] \\leq f[j_2]$，那么在 $i > j_2$ 之后，**$j_1$ 将永远不可能作为状态转移方程中最优的 $j$**。这是因为 $f[j_2]$ 不劣于 $f[j_1]$，并且 $j_2$ 的下标更大，满足限制的最远位置也大于 $j_1$，因此无论什么时候从 $j_1$ 转移都不会比从 $j_2$ 转移要优，因此我们可以将 $j_1$ 从候选的 $j$ 值集合中永远的移除。\n\n基于这个思路，我们可以使用一个**严格单调递减**的队列存储所有的候选 $j$ 值集合，这里**严格单调递减**的意思是：从队首到队尾的所有 $j$ 值，它们的下标严格单调递增，而对应的 $f[j]$ 值严格单调递减。这样一来，当我们枚举到 $i$ 时，队首的 $j$ 就是我们的最优转移。与优先队列类似，此时队首的 $j$ 可能已经不满足限制，因此我们需要不断弹出队首元素，直到其满足限制为止。在转移完成之后，$i$ 就是我们未来的一个候选 $j$ 值，因此我们将 $i$ 加入队尾，并且不断弹出队尾元素，直到队列为空或者队尾的 $j$ 值满足 $f[j] > f[i]$。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int maxResult(vector<int>& nums, int k) {\n        int n = nums.size();\n        \n        // 单调队列中的二元组即为 (f[j], j)\n        deque<pair<int, int>> q;\n        q.emplace_back(nums[0], 0);\n        int ans = nums[0];\n        \n        for (int i = 1; i < n; ++i) {\n            // 队首的 j 不满足限制\n            while (i - q.front().second > k) {\n                q.pop_front();\n            }\n            \n            ans = q.front().first + nums[i];\n            \n            // 队尾的 j 不满足单调性\n            while (!q.empty() && ans >= q.back().first) {\n                q.pop_back();\n            }\n            \n            q.emplace_back(ans, i);\n        }\n        \n        return ans;\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。\n\n- 空间复杂度：$O(k)$。"
}