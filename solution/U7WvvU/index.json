{
	"titleSlug": "U7WvvU",
	"slug": "shu-xing-dp-by-endlesscheng-isuo",
	"url": "https://leetcode-cn.com/problems/U7WvvU/solution/shu-xing-dp-by-endlesscheng-isuo/",
	"content": "个人赛五道题目的 [视频讲解](https://www.bilibili.com/video/BV1zN4y1K762) 已出炉，欢迎点赞三连，在评论区分享你对这场比赛的看法~\r\n\r\n---\r\n\r\n定义状态 (当前节点，祖先节点开关 2 的切换次数的奇偶性，父节点是否切换了开关 3)，每个状态表示从当前状态出发，最少需要操作多少次开关，可以关闭子树所有节点的灯。\r\n\r\n跑一个树形 DP。如果当前受到祖先节点的开关影响后，变成开灯状态，那么可以操作一个或三个开关：\r\n\r\n- 操作开关 1；\r\n- 操作开关 2；\r\n- 操作开关 3；\r\n- 操作开关 123；\r\n- 这四种操作取最小值。\r\n\r\n如果变成关灯状态，那么可以操作零个或两个开关：\r\n\r\n- 不操作任何一个开关；\r\n- 操作开关 12；\r\n- 操作开关 13；\r\n- 操作开关 23；\r\n- 这四种操作取最小值。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def closeLampInTree(self, root: TreeNode) -> int:\r\n        @cache  # 记忆化搜索\r\n        def f(node: TreeNode, switch2: bool, switch3: bool) -> int:\r\n            if node is None:\r\n                return 0\r\n            if (node.val == 1) == (switch2 == switch3):  # 当前节点为开灯\r\n                res1 = f(node.left, switch2, False) + f(node.right, switch2, False) + 1\r\n                res2 = f(node.left, not switch2, False) + f(node.right, not switch2, False) + 1\r\n                res3 = f(node.left, switch2, True) + f(node.right, switch2, True) + 1\r\n                res123 = f(node.left, not switch2, True) + f(node.right, not switch2, True) + 3\r\n                return min(res1, res2, res3, res123)\r\n            else:  # 当前节点为关灯\r\n                res0 = f(node.left, switch2, False) + f(node.right, switch2, False)\r\n                res12 = f(node.left, not switch2, False) + f(node.right, not switch2, False) + 2\r\n                res13 = f(node.left, switch2, True) + f(node.right, switch2, True) + 2\r\n                res23 = f(node.left, not switch2, True) + f(node.right, not switch2, True) + 2\r\n                return min(res0, res12, res13, res23)\r\n        return f(root, False, False)\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc closeLampInTree(root *TreeNode) (ans int) {\r\n\ttype tuple struct {\r\n\t\tnode             *TreeNode\r\n\t\tswitch2, switch3 bool\r\n\t}\r\n\tdp := map[tuple]int{} // 记忆化搜索\r\n\tvar f func(*TreeNode, bool, bool) int\r\n\tf = func(node *TreeNode, switch2, switch3 bool) int {\r\n\t\tif node == nil {\r\n\t\t\treturn 0\r\n\t\t}\r\n\t\tp := tuple{node, switch2, switch3}\r\n\t\tif res, ok := dp[p]; ok {\r\n\t\t\treturn res\r\n\t\t}\r\n\t\tif node.Val == 1 == (switch2 == switch3) { // 当前节点为开灯\r\n\t\t\tres1 := f(node.Left, switch2, false) + f(node.Right, switch2, false) + 1\r\n\t\t\tres2 := f(node.Left, !switch2, false) + f(node.Right, !switch2, false) + 1\r\n\t\t\tres3 := f(node.Left, switch2, true) + f(node.Right, switch2, true) + 1\r\n\t\t\tr123 := f(node.Left, !switch2, true) + f(node.Right, !switch2, true) + 3\r\n\t\t\tdp[p] = min(res1, res2, res3, r123)\r\n\t\t} else { // 当前节点为关灯\r\n\t\t\tres0 := f(node.Left, switch2, false) + f(node.Right, switch2, false)\r\n\t\t\tres12 := f(node.Left, !switch2, false) + f(node.Right, !switch2, false) + 2\r\n\t\t\tres13 := f(node.Left, switch2, true) + f(node.Right, switch2, true) + 2\r\n\t\t\tres23 := f(node.Left, !switch2, true) + f(node.Right, !switch2, true) + 2\r\n\t\t\tdp[p] = min(res0, res12, res13, res23)\r\n\t\t}\r\n\t\treturn dp[p]\r\n\t}\r\n\treturn f(root, false, false)\r\n}\r\n\r\nfunc min(a, b, c, d int) int {\r\n\tif b < a {\r\n\t\ta = b\r\n\t}\r\n\tif c < a {\r\n\t\ta = c\r\n\t}\r\n\tif d < a {\r\n\t\ta = d\r\n\t}\r\n\treturn a\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为二叉树的节点个数。\r\n- 空间复杂度：$O(n)$。\r\n"
}