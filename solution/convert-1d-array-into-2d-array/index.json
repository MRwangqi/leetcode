{
	"titleSlug": "convert-1d-array-into-2d-array",
	"slug": "jiang-yi-wei-shu-zu-zhuan-bian-cheng-er-zt47o",
	"url": "https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/solution/jiang-yi-wei-shu-zu-zhuan-bian-cheng-er-zt47o/",
	"content": "#### 方法一：模拟\n\n设 $\\textit{original}$ 的长度为 $k$，根据题意，如果 $k\\ne mn$ 则无法构成二维数组，此时返回空数组。否则我们可以遍历 $\\textit{original}$，每 $n$ 个元素创建一个一维数组，放入二维数组中。\n\n```Python [sol1-Python3]\nclass Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:\n        return [original[i: i + n] for i in range(0, len(original), n)] if len(original) == m * n else []\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> construct2DArray(vector<int> &original, int m, int n) {\n        vector<vector<int>> ans;\n        if (original.size() != m * n) {\n            return ans;\n        }\n        for (auto it = original.begin(); it != original.end(); it += n) {\n            ans.emplace_back(it, it + n);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[][] construct2DArray(int[] original, int m, int n) {\n        if (original.length != m * n) {\n            return new int[0][];\n        }\n        int[][] ans = new int[m][n];\n        for (int i = 0; i < original.length; i += n) {\n            System.arraycopy(original, i, ans[i / n], 0, n);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[][] Construct2DArray(int[] original, int m, int n) {\n        if (original.Length != m * n) {\n            return new int[0][];\n        }\n        int[][] ans = new int[m][];\n        for (int i = 0; i < m; ++i) {\n            ans[i] = new int[n];\n        }\n        for (int i = 0; i < original.Length; i += n) {\n            Array.Copy(original, i, ans[i / n], 0, n);\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc construct2DArray(original []int, m, n int) [][]int {\n    k := len(original)\n    if k != m*n {\n        return nil\n    }\n    ans := make([][]int, 0, m)\n    for i := 0; i < k; i += n {\n        ans = append(ans, original[i:i+n])\n    }\n    return ans\n}\n```\n\n```C [sol1-C]\nint** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes){    \n    if (originalSize != m * n) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int ** ans = (int **)malloc(sizeof(int *) * m);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * m);\n    for (int i = 0; i < m; ++i) {\n        ans[i] = (int *)malloc(sizeof(int) * n);\n        (*returnColumnSizes)[i] = n;\n    }\n    for (int i = 0; i < originalSize; i += n) {\n        memcpy(ans[i / n], original + i, sizeof(int) * n);\n    }\n    *returnSize = m;\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar construct2DArray = function(original, m, n) {\n    if (original.length !== m * n) {\n        return [];\n    }\n    const ans = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    for (let i = 0; i < original.length; i += n) {\n        ans[Math.floor(i / n)].splice(0, n, ...original.slice(i, i + n)) \n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn)$ 或 $O(m)$（取决于语言实现）。\n\n- 空间复杂度：$O(1)$。不考虑返回值的空间占用。"
}