{
	"titleSlug": "reverse-bits-lcci",
	"slug": "zhang-jian-qi-shi-c-by-zhang-jian-qi-shi-n5ge",
	"url": "https://leetcode-cn.com/problems/reverse-bits-lcci/solution/zhang-jian-qi-shi-c-by-zhang-jian-qi-shi-n5ge/",
	"content": "### 解题思路\n首先将num转化成由bit0和1组成的string, 然后使用双指针遍历字符串.\n右指针一直向前移动,\n左指针移动的条件:, 右指针遇到0的次数>=2时,更新左指针为上一个0所在的位置的下一个元素.\n结果更新: 右指针遇到0的次数>=2时, 更新结果.\n### 具体步骤:\n1. 将num转化为由bit0和1组成的string, s\n2. 将'0'字符加入到s的尾部\n3. 定义双指针,l,r同时指向0, zero_i代表0的下标,初始值为-1.\n4. 右指针向前移动一格, 当s[r]等于0时, 如果右指针是第一次遇到0, 更新zero_i=r,\n5. 如果此时右指针遇到0的次数不止一次,更新结果为ans=max(ans, r-l),\n6. 同时更新l让l指向上一个0所在位置的下一个元素, 更新zero_i为当前0的位置\n7. 重复2~6步, 直到s遍历完成,\n8. 最后,由于最后一个字符串子段没有计算结果, 需要再更新一次结果ans=max(ans, r-l)\n\n### 注意:\n-1,0要单独考虑\n当num-=0时,不再字符串前面添加0,因为\"00\", 没有意义.\n当num=-1时, 不再字符串前面添加0, 因为s的长度等于32, 再添加0, 没有意义.\n### 运行结果\n![image.png](https://pic.leetcode-cn.com/1658034609-AaQBEF-image.png)\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int reverseBits(int num) {\n        int ans=1;\n        int count=0;\n        string s;\n        int tmp=num;\n        while(num&&s.size()<=31){\n            int v=num&1;\n            s+=(v+'0');\n            num>>=1;\n        }\n        if(s!=\"0\"&&tmp!=-1){\n            s+='0';\n        }\n        \n        int l=0,r=0, zero_i=-1;\n        for(;r<s.size();r++){\n            if(s[r]=='1'){\n                continue;\n            }\n            if(zero_i==-1){\n                zero_i=r;\n            }\n            else{\n                ans=max(ans,r-l);\n                l=zero_i+1;\n                zero_i=r;\n            }\n        } \n        ans=max(ans,r-l);\n        return ans;\n    }\n};\n```"
}