{
	"titleSlug": "random-pick-index",
	"slug": "sui-ji-shu-suo-yin-by-leetcode-solution-ofsq",
	"url": "https://leetcode-cn.com/problems/random-pick-index/solution/sui-ji-shu-suo-yin-by-leetcode-solution-ofsq/",
	"content": "#### 方法一：哈希表\n\n如果不考虑数组的大小，我们可以在构造函数中，用一个哈希表 $\\textit{pos}$ 记录 $\\textit{nums}$ 中相同元素的下标。\n\n对于 $\\text{pick}$ 操作，我们可以从 $\\textit{pos}$ 中取出 $\\textit{target}$ 对应的下标列表，然后随机选择其中一个下标并返回。\n\n```Python [sol1-Python3]\nclass Solution:\n    def __init__(self, nums: List[int]):\n        self.pos = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.pos[num].append(i)\n\n    def pick(self, target: int) -> int:\n        return choice(self.pos[target])\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    unordered_map<int, vector<int>> pos;\npublic:\n    Solution(vector<int> &nums) {\n        for (int i = 0; i < nums.size(); ++i) {\n            pos[nums[i]].push_back(i);\n        }\n    }\n\n    int pick(int target) {\n        auto &indices = pos[target];\n        return indices[rand() % indices.size()];\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    Map<Integer, List<Integer>> pos;\n    Random random;\n\n    public Solution(int[] nums) {\n        pos = new HashMap<Integer, List<Integer>>();\n        random = new Random();\n        for (int i = 0; i < nums.length; ++i) {\n            pos.putIfAbsent(nums[i], new ArrayList<Integer>());\n            pos.get(nums[i]).add(i);\n        }\n    }\n\n    public int pick(int target) {\n        List<Integer> indices = pos.get(target);\n        return indices.get(random.nextInt(indices.size()));\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    Dictionary<int, IList<int>> pos;\n    Random random;\n\n    public Solution(int[] nums) {\n        pos = new Dictionary<int, IList<int>>();\n        random = new Random();\n        for (int i = 0; i < nums.Length; ++i) {\n            if (!pos.ContainsKey(nums[i])) {\n                pos.Add(nums[i], new List<int>());\n            }\n            pos[nums[i]].Add(i);\n        }\n    }\n\n    public int Pick(int target) {\n        IList<int> indices = pos[target];\n        return indices[random.Next(indices.Count)];\n    }\n}\n```\n\n```go [sol1-Golang]\ntype Solution map[int][]int\n\nfunc Constructor(nums []int) Solution {\n    pos := map[int][]int{}\n    for i, v := range nums {\n        pos[v] = append(pos[v], i)\n    }\n    return pos\n}\n\nfunc (pos Solution) Pick(target int) int {\n    indices := pos[target]\n    return indices[rand.Intn(len(indices))]\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    int *array;\n    int capacity;\n    int size;\n    UT_hash_handle hh;\n} HashItem;\n\ntypedef struct {\n    HashItem *pos;\n} Solution;\n\nvoid hashInsert(HashItem **obj, int key, int idx) {\n    HashItem * pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    if (!pEntry) {\n        pEntry = malloc(sizeof(HashItem));\n        pEntry->key = key;\n        pEntry->capacity = 64;\n        pEntry->size = 0;\n        pEntry->array = calloc(pEntry->capacity, sizeof(int));\n        HASH_ADD_INT(*obj, key, pEntry);\n    }\n    if (pEntry->size == pEntry->capacity) {\n        pEntry->capacity *= 2; \n        pEntry->array = realloc(pEntry->array, pEntry->capacity * sizeof(int));\n    }\n    pEntry->array[(pEntry->size)++] = idx;\n}\n\nSolution* solutionCreate(int* nums, int numsSize) {\n    Solution *obj = malloc(sizeof(Solution));\n    obj->pos = NULL;\n    for (int i = 0; i < numsSize; ++i) {\n        hashInsert(&obj->pos, nums[i], i);\n    }\n    return obj;\n}\n\nint solutionPick(Solution* obj, int target) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(obj->pos, &target, pEntry);\n    if (!pEntry) {\n        return -1;\n    }\n    return pEntry->array[rand() % pEntry->size];\n}\n\nvoid solutionFree(Solution* obj) {\n    HashItem *curr, *tmp;\n    HASH_ITER(hh, obj->pos, curr, tmp) {\n        HASH_DEL(obj->pos, curr);\n        free(curr->array);\n        free(curr);\n    }\n    free(obj);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar Solution = function(nums) {\n    this.pos = new Map();\n    for (let i = 0; i < nums.length; ++i) {\n        if (!this.pos.has(nums[i])) {\n            this.pos.set(nums[i], []);\n        }\n        \n        this.pos.get(nums[i]).push(i);\n    }\n};\n\nSolution.prototype.pick = function(target) {\n    const indices = this.pos.get(target);\n    return indices[Math.floor(Math.random() * indices.length)];\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化为 $O(n)$，$\\text{pick}$ 为 $O(1)$，其中 $n$ 是 $\\textit{nums}$ 的长度。\n        \n- 空间复杂度：$O(n)$。我们需要 $O(n)$ 的空间存储 $n$ 个下标。\n\n#### 方法二：水塘抽样\n\n如果数组以文件形式存储（读者可假设构造函数传入的是个文件路径），且文件大小远超内存大小，我们是无法通过读文件的方式，将所有下标保存在内存中的，因此需要找到一种空间复杂度更低的算法。\n\n我们可以设计如下算法实现 $\\text{pick}$ 操作：\n\n遍历 $\\textit{nums}$，当我们第 $i$ 次遇到值为 $\\textit{target}$ 的元素时，随机选择区间 $[0,i)$ 内的一个整数，如果其等于 $0$，则将返回值置为该元素的下标，否则返回值不变。\n\n设 $\\textit{nums}$ 中有 $k$ 个值为 $\\textit{target}$ 的元素，该算法会保证这 $k$ 个元素的下标成为最终返回值的概率均为 $\\dfrac{1}{k}$，证明如下：\n\n$$\n\\begin{aligned} \n&P(第\\ i\\ 次遇到值为\\ \\textit{target}\\ \\ 的元素的下标成为最终返回值)\\\\\n=&P(第\\ i\\ 次随机选择的值= 0) \\times P(第\\ i+1\\ 次随机选择的值\\ne 0) \\times \\cdots \\times P(第\\ k\\ 次随机选择的值\\ne 0)\\\\\n=&\\dfrac{1}{i} \\times (1-\\dfrac{1}{i+1}) \\times \\cdots \\times (1-\\dfrac{1}{k})\\\\\n=&\\dfrac{1}{i} \\times \\dfrac{i}{i+1} \\times \\cdots \\times \\dfrac{k-1}{k}\\\\\n=&\\dfrac{1}{k}\n\\end{aligned}\n$$\n\n```Python [sol2-Python3]\nclass Solution:\n    def __init__(self, nums: List[int]):\n        self.nums = nums\n\n    def pick(self, target: int) -> int:\n        ans = cnt = 0\n        for i, num in enumerate(self.nums):\n            if num == target:\n                cnt += 1  # 第 cnt 次遇到 target\n                if randrange(cnt) == 0:\n                    ans = i\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\n    vector<int> &nums;\npublic:\n    Solution(vector<int> &nums) : nums(nums) {}\n\n    int pick(int target) {\n        int ans;\n        for (int i = 0, cnt = 0; i < nums.size(); ++i) {\n            if (nums[i] == target) {\n                ++cnt; // 第 cnt 次遇到 target\n                if (rand() % cnt == 0) {\n                    ans = i;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    int[] nums;\n    Random random;\n\n    public Solution(int[] nums) {\n        this.nums = nums;\n        random = new Random();\n    }\n\n    public int pick(int target) {\n        int ans = 0;\n        for (int i = 0, cnt = 0; i < nums.length; ++i) {\n            if (nums[i] == target) {\n                ++cnt; // 第 cnt 次遇到 target\n                if (random.nextInt(cnt) == 0) {\n                    ans = i;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    int[] nums;\n    Random random;\n\n    public Solution(int[] nums) {\n        this.nums = nums;\n        random = new Random();\n    }\n\n    public int Pick(int target) {\n        int ans = 0;\n        for (int i = 0, cnt = 0; i < nums.Length; ++i) {\n            if (nums[i] == target) {\n                ++cnt; // 第 cnt 次遇到 target\n                if (random.Next(cnt) == 0) {\n                    ans = i;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol2-Golang]\ntype Solution []int\n\nfunc Constructor(nums []int) Solution {\n    return nums\n}\n\nfunc (nums Solution) Pick(target int) (ans int) {\n    cnt := 0\n    for i, num := range nums {\n        if num == target {\n            cnt++ // 第 cnt 次遇到 target\n            if rand.Intn(cnt) == 0 {\n                ans = i\n            }\n        }\n    }\n    return\n}\n```\n\n```C [sol2-C]\ntypedef struct {\n    int *nums;\n    int numsSize;\n} Solution;\n\n\nSolution* solutionCreate(int* nums, int numsSize) {\n    Solution *obj = (Solution *)malloc(sizeof(Solution));\n    obj->nums = nums;\n    obj->numsSize = numsSize;\n    return obj;\n}\n\nint solutionPick(Solution* obj, int target) {\n    int ans;\n    for (int i = 0, cnt = 0; i < obj->numsSize; ++i) {\n        if (obj->nums[i] == target) {\n            ++cnt; \n            if (rand() % cnt == 0) {\n                ans = i;\n            }\n        }\n    }\n    return ans;\n}\n\nvoid solutionFree(Solution* obj) {\n    free(obj);\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar Solution = function(nums) {\n    this.nums = nums;\n};\n\nSolution.prototype.pick = function(target) {\n    let ans = 0;\n    for (let i = 0, cnt = 0; i < this.nums.length; ++i) {\n        if (this.nums[i] == target) {\n            ++cnt; // 第 cnt 次遇到 target\n            if (Math.floor(Math.random() * cnt) === 0) {\n                ans = i;\n            }\n        }\n    }\n    return ans;\n};\n```\n\n- 时间复杂度：初始化为 $O(1)$，$\\text{pick}$ 为 $O(n)$，其中 $n$ 是 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。"
}