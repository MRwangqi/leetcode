{
	"titleSlug": "course-schedule-ii",
	"slug": "ke-cheng-biao-ii-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![210. è¯¾ç¨‹è¡¨ IIçš„.mp4](def715df-7ba6-462e-b957-ebaf4120b1ce)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### å‰è¨€\n\næœ¬é¢˜æ˜¯ä¸€é“ç»å…¸çš„ã€Œæ‹“æ‰‘æ’åºã€é—®é¢˜ã€‚\n\nç»™å®šä¸€ä¸ªåŒ…å« $n$ ä¸ªèŠ‚ç‚¹çš„æœ‰å‘å›¾ $G$ï¼Œæˆ‘ä»¬ç»™å‡ºå®ƒçš„èŠ‚ç‚¹ç¼–å·çš„ä¸€ç§æ’åˆ—ï¼Œå¦‚æœæ»¡è¶³ï¼š\n\n> å¯¹äºå›¾ $G$ ä¸­çš„ä»»æ„ä¸€æ¡æœ‰å‘è¾¹ $(u, v)$ï¼Œ$u$ åœ¨æ’åˆ—ä¸­éƒ½å‡ºç°åœ¨ $v$ çš„å‰é¢ã€‚\n\né‚£ä¹ˆç§°è¯¥æ’åˆ—æ˜¯å›¾ $G$ çš„ã€Œæ‹“æ‰‘æ’åºã€ã€‚æ ¹æ®ä¸Šè¿°çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºä¸¤ä¸ªç»“è®ºï¼š\n\n- å¦‚æœå›¾ $G$ ä¸­å­˜åœ¨ç¯ï¼ˆå³å›¾ $G$ ä¸æ˜¯ã€Œæœ‰å‘æ— ç¯å›¾ã€ï¼‰ï¼Œé‚£ä¹ˆå›¾ $G$ ä¸å­˜åœ¨æ‹“æ‰‘æ’åºã€‚è¿™æ˜¯å› ä¸ºå‡è®¾å›¾ä¸­å­˜åœ¨ç¯ $x_1, x_2, \\cdots, x_n, x_1$ï¼Œé‚£ä¹ˆ $x_1$ åœ¨æ’åˆ—ä¸­å¿…é¡»å‡ºç°åœ¨ $x_n$ çš„å‰é¢ï¼Œä½† $x_n$ åŒæ—¶ä¹Ÿå¿…é¡»å‡ºç°åœ¨ $x_1$ çš„å‰é¢ï¼Œå› æ­¤ä¸å­˜åœ¨ä¸€ä¸ªæ»¡è¶³è¦æ±‚çš„æ’åˆ—ï¼Œä¹Ÿå°±ä¸å­˜åœ¨æ‹“æ‰‘æ’åºï¼›\n\n- å¦‚æœå›¾ $G$ æ˜¯æœ‰å‘æ— ç¯å›¾ï¼Œé‚£ä¹ˆå®ƒçš„æ‹“æ‰‘æ’åºå¯èƒ½ä¸æ­¢ä¸€ç§ã€‚ä¸¾ä¸€ä¸ªæœ€æç«¯çš„ä¾‹å­ï¼Œå¦‚æœå›¾ $G$ å€¼åŒ…å« $n$ ä¸ªèŠ‚ç‚¹å´æ²¡æœ‰ä»»ä½•è¾¹ï¼Œé‚£ä¹ˆä»»æ„ä¸€ç§ç¼–å·çš„æ’åˆ—éƒ½å¯ä»¥ä½œä¸ºæ‹“æ‰‘æ’åºã€‚\n\næœ‰äº†ä¸Šè¿°çš„ç®€å•åˆ†æï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†æœ¬é¢˜å»ºæ¨¡æˆä¸€ä¸ªæ±‚æ‹“æ‰‘æ’åºçš„é—®é¢˜äº†ï¼š\n\n- æˆ‘ä»¬å°†æ¯ä¸€é—¨è¯¾çœ‹æˆä¸€ä¸ªèŠ‚ç‚¹ï¼›\n\n- å¦‚æœæƒ³è¦å­¦ä¹ è¯¾ç¨‹ $A$ ä¹‹å‰å¿…é¡»å®Œæˆè¯¾ç¨‹ $B$ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä» $B$ åˆ° $A$ è¿æ¥ä¸€æ¡æœ‰å‘è¾¹ã€‚è¿™æ ·ä»¥æ¥ï¼Œåœ¨æ‹“æ‰‘æ’åºä¸­ï¼Œ$B$ ä¸€å®šå‡ºç°åœ¨ $A$ çš„å‰é¢ã€‚\n\næ±‚å‡ºè¯¥å›¾çš„æ‹“æ‰‘æ’åºï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ç§ç¬¦åˆè¦æ±‚çš„è¯¾ç¨‹å­¦ä¹ é¡ºåºã€‚ä¸‹é¢ä»‹ç»ä¸¤ç§æ±‚è§£æ‹“æ‰‘æ’åºçš„æ–¹æ³•ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢\n\n**æ€è·¯**\n\næˆ‘ä»¬å¯ä»¥å°†æ·±åº¦ä¼˜å…ˆæœç´¢çš„æµç¨‹ä¸æ‹“æ‰‘æ’åºçš„æ±‚è§£è”ç³»èµ·æ¥ï¼Œç”¨ä¸€ä¸ªæ ˆæ¥å­˜å‚¨æ‰€æœ‰**å·²ç»æœç´¢å®Œæˆçš„èŠ‚ç‚¹**ã€‚\n\n> å¯¹äºä¸€ä¸ªèŠ‚ç‚¹ $u$ï¼Œå¦‚æœå®ƒçš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹éƒ½å·²ç»æœç´¢å®Œæˆï¼Œé‚£ä¹ˆåœ¨æœç´¢å›æº¯åˆ° $u$ çš„æ—¶å€™ï¼Œ$u$ æœ¬èº«ä¹Ÿä¼šå˜æˆä¸€ä¸ªå·²ç»æœç´¢å®Œæˆçš„èŠ‚ç‚¹ã€‚è¿™é‡Œçš„ã€Œç›¸é‚»èŠ‚ç‚¹ã€æŒ‡çš„æ˜¯ä» $u$ å‡ºå‘é€šè¿‡ä¸€æ¡æœ‰å‘è¾¹å¯ä»¥åˆ°è¾¾çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚\n\nå‡è®¾æˆ‘ä»¬å½“å‰æœç´¢åˆ°äº†èŠ‚ç‚¹ $u$ï¼Œå¦‚æœå®ƒçš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹éƒ½å·²ç»æœç´¢å®Œæˆï¼Œé‚£ä¹ˆè¿™äº›èŠ‚ç‚¹éƒ½å·²ç»åœ¨æ ˆä¸­äº†ï¼Œæ­¤æ—¶æˆ‘ä»¬å°±å¯ä»¥æŠŠ $u$ å…¥æ ˆã€‚å¯ä»¥å‘ç°ï¼Œå¦‚æœæˆ‘ä»¬ä»æ ˆé¡¶å¾€æ ˆåº•çš„é¡ºåºçœ‹ï¼Œç”±äº $u$ å¤„äºæ ˆé¡¶çš„ä½ç½®ï¼Œé‚£ä¹ˆ $u$ å‡ºç°åœ¨æ‰€æœ‰ $u$ çš„ç›¸é‚»èŠ‚ç‚¹çš„å‰é¢ã€‚å› æ­¤å¯¹äº $u$ è¿™ä¸ªèŠ‚ç‚¹è€Œè¨€ï¼Œå®ƒæ˜¯æ»¡è¶³æ‹“æ‰‘æ’åºçš„è¦æ±‚çš„ã€‚\n\nè¿™æ ·ä»¥æ¥ï¼Œæˆ‘ä»¬å¯¹å›¾è¿›è¡Œä¸€éæ·±åº¦ä¼˜å…ˆæœç´¢ã€‚å½“æ¯ä¸ªèŠ‚ç‚¹è¿›è¡Œå›æº¯çš„æ—¶å€™ï¼Œæˆ‘ä»¬æŠŠè¯¥èŠ‚ç‚¹æ”¾å…¥æ ˆä¸­ã€‚æœ€ç»ˆä»æ ˆé¡¶åˆ°æ ˆåº•çš„åºåˆ—å°±æ˜¯ä¸€ç§æ‹“æ‰‘æ’åºã€‚\n\n**ç®—æ³•**\n\nå¯¹äºå›¾ä¸­çš„ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå®ƒåœ¨æœç´¢çš„è¿‡ç¨‹ä¸­æœ‰ä¸‰ç§çŠ¶æ€ï¼Œå³ï¼š\n\n- ã€Œæœªæœç´¢ã€ï¼šæˆ‘ä»¬è¿˜æ²¡æœ‰æœç´¢åˆ°è¿™ä¸ªèŠ‚ç‚¹ï¼›\n\n- ã€Œæœç´¢ä¸­ã€ï¼šæˆ‘ä»¬æœç´¢è¿‡è¿™ä¸ªèŠ‚ç‚¹ï¼Œä½†è¿˜æ²¡æœ‰å›æº¯åˆ°è¯¥èŠ‚ç‚¹ï¼Œå³è¯¥èŠ‚ç‚¹è¿˜æ²¡æœ‰å…¥æ ˆï¼Œè¿˜æœ‰ç›¸é‚»çš„èŠ‚ç‚¹æ²¡æœ‰æœç´¢å®Œæˆï¼‰ï¼›\n\n- ã€Œå·²å®Œæˆã€ï¼šæˆ‘ä»¬æœç´¢è¿‡å¹¶ä¸”å›æº¯è¿‡è¿™ä¸ªèŠ‚ç‚¹ï¼Œå³è¯¥èŠ‚ç‚¹å·²ç»å…¥æ ˆï¼Œå¹¶ä¸”æ‰€æœ‰è¯¥èŠ‚ç‚¹çš„ç›¸é‚»èŠ‚ç‚¹éƒ½å‡ºç°åœ¨æ ˆçš„æ›´åº•éƒ¨çš„ä½ç½®ï¼Œæ»¡è¶³æ‹“æ‰‘æ’åºçš„è¦æ±‚ã€‚\n\né€šè¿‡ä¸Šè¿°çš„ä¸‰ç§çŠ¶æ€ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç»™å‡ºä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢å¾—åˆ°æ‹“æ‰‘æ’åºçš„ç®—æ³•æµç¨‹ï¼Œåœ¨æ¯ä¸€è½®çš„æœç´¢æœç´¢å¼€å§‹æ—¶ï¼Œæˆ‘ä»¬ä»»å–ä¸€ä¸ªã€Œæœªæœç´¢ã€çš„èŠ‚ç‚¹å¼€å§‹è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ã€‚\n\n- æˆ‘ä»¬å°†å½“å‰æœç´¢çš„èŠ‚ç‚¹ $u$ æ ‡è®°ä¸ºã€Œæœç´¢ä¸­ã€ï¼Œéå†è¯¥èŠ‚ç‚¹çš„æ¯ä¸€ä¸ªç›¸é‚»èŠ‚ç‚¹ $v$ï¼š\n\n    - å¦‚æœ $v$ ä¸ºã€Œæœªæœç´¢ã€ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¼€å§‹æœç´¢ $v$ï¼Œå¾…æœç´¢å®Œæˆå›æº¯åˆ° $u$ï¼›\n\n    - å¦‚æœ $v$ ä¸ºã€Œæœç´¢ä¸­ã€ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ‰¾åˆ°äº†å›¾ä¸­çš„ä¸€ä¸ªç¯ï¼Œå› æ­¤æ˜¯ä¸å­˜åœ¨æ‹“æ‰‘æ’åºçš„ï¼›\n\n    - å¦‚æœ $v$ ä¸ºã€Œå·²å®Œæˆã€ï¼Œé‚£ä¹ˆè¯´æ˜ $v$ å·²ç»åœ¨æ ˆä¸­äº†ï¼Œè€Œ $u$ è¿˜ä¸åœ¨æ ˆä¸­ï¼Œå› æ­¤ $u$ æ— è®ºä½•æ—¶å…¥æ ˆéƒ½ä¸ä¼šå½±å“åˆ° $(u, v)$ ä¹‹å‰çš„æ‹“æ‰‘å…³ç³»ï¼Œä»¥åŠä¸ç”¨è¿›è¡Œä»»ä½•æ“ä½œã€‚\n\n- å½“ $u$ çš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹éƒ½ä¸ºã€Œå·²å®Œæˆã€æ—¶ï¼Œæˆ‘ä»¬å°† $u$ æ”¾å…¥æ ˆä¸­ï¼Œå¹¶å°†å…¶æ ‡è®°ä¸ºã€Œå·²å®Œæˆã€ã€‚\n\nåœ¨æ•´ä¸ªæ·±åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ç»“æŸåï¼Œå¦‚æœæˆ‘ä»¬æ²¡æœ‰æ‰¾åˆ°å›¾ä¸­çš„ç¯ï¼Œé‚£ä¹ˆæ ˆä¸­å­˜å‚¨è¿™æ‰€æœ‰çš„ $n$ ä¸ªèŠ‚ç‚¹ï¼Œä»æ ˆé¡¶åˆ°æ ˆåº•çš„é¡ºåºå³ä¸ºä¸€ç§æ‹“æ‰‘æ’åºã€‚\n\nä¸‹é¢çš„å¹»ç¯ç‰‡ç»™å‡ºäº†æ·±åº¦ä¼˜å…ˆæœç´¢çš„å¯è§†åŒ–æµç¨‹ã€‚å›¾ä¸­çš„ã€Œç™½è‰²ã€ã€Œé»„è‰²ã€ã€Œç»¿è‰²ã€èŠ‚ç‚¹åˆ†åˆ«è¡¨ç¤ºã€Œæœªæœç´¢ã€ã€Œæœç´¢ä¸­ã€ã€Œå·²å®Œæˆã€çš„çŠ¶æ€ã€‚\n\n<![DFS1](https://assets.leetcode-cn.com/solution-static/207/1.png),![DFS2](https://assets.leetcode-cn.com/solution-static/207/2.png),![DFS3](https://assets.leetcode-cn.com/solution-static/207/3.png),![DFS4](https://assets.leetcode-cn.com/solution-static/207/4.png),![DFS5](https://assets.leetcode-cn.com/solution-static/207/5.png),![DFS6](https://assets.leetcode-cn.com/solution-static/207/6.png),![DFS7](https://assets.leetcode-cn.com/solution-static/207/7.png),![DFS8](https://assets.leetcode-cn.com/solution-static/207/8.png),![DFS9](https://assets.leetcode-cn.com/solution-static/207/9.png),![DFS10](https://assets.leetcode-cn.com/solution-static/207/10.png),![DFS11](https://assets.leetcode-cn.com/solution-static/207/11.png),![DFS12](https://assets.leetcode-cn.com/solution-static/207/12.png),![DFS13](https://assets.leetcode-cn.com/solution-static/207/13.png),![DFS14](https://assets.leetcode-cn.com/solution-static/207/14.png),![DFS15](https://assets.leetcode-cn.com/solution-static/207/15.png),![DFS16](https://assets.leetcode-cn.com/solution-static/207/16.png),![DFS17](https://assets.leetcode-cn.com/solution-static/207/17.png),![DFS18](https://assets.leetcode-cn.com/solution-static/207/18.png),![DFS19](https://assets.leetcode-cn.com/solution-static/207/19.png),![DFS20](https://assets.leetcode-cn.com/solution-static/207/20.png)>\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    // å­˜å‚¨æœ‰å‘å›¾\n    vector<vector<int>> edges;\n    // æ ‡è®°æ¯ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€ï¼š0=æœªæœç´¢ï¼Œ1=æœç´¢ä¸­ï¼Œ2=å·²å®Œæˆ\n    vector<int> visited;\n    // ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿæ ˆï¼Œä¸‹æ ‡ 0 ä¸ºæ ˆåº•ï¼Œn-1 ä¸ºæ ˆé¡¶\n    vector<int> result;\n    // åˆ¤æ–­æœ‰å‘å›¾ä¸­æ˜¯å¦æœ‰ç¯\n    bool valid = true;\n\npublic:\n    void dfs(int u) {\n        // å°†èŠ‚ç‚¹æ ‡è®°ä¸ºã€Œæœç´¢ä¸­ã€\n        visited[u] = 1;\n        // æœç´¢å…¶ç›¸é‚»èŠ‚ç‚¹\n        // åªè¦å‘ç°æœ‰ç¯ï¼Œç«‹åˆ»åœæ­¢æœç´¢\n        for (int v: edges[u]) {\n            // å¦‚æœã€Œæœªæœç´¢ã€é‚£ä¹ˆæœç´¢ç›¸é‚»èŠ‚ç‚¹\n            if (visited[v] == 0) {\n                dfs(v);\n                if (!valid) {\n                    return;\n                }\n            }\n            // å¦‚æœã€Œæœç´¢ä¸­ã€è¯´æ˜æ‰¾åˆ°äº†ç¯\n            else if (visited[v] == 1) {\n                valid = false;\n                return;\n            }\n        }\n        // å°†èŠ‚ç‚¹æ ‡è®°ä¸ºã€Œå·²å®Œæˆã€\n        visited[u] = 2;\n        // å°†èŠ‚ç‚¹å…¥æ ˆ\n        result.push_back(u);\n    }\n\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        edges.resize(numCourses);\n        visited.resize(numCourses);\n        for (const auto& info: prerequisites) {\n            edges[info[1]].push_back(info[0]);\n        }\n        // æ¯æ¬¡æŒ‘é€‰ä¸€ä¸ªã€Œæœªæœç´¢ã€çš„èŠ‚ç‚¹ï¼Œå¼€å§‹è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢\n        for (int i = 0; i < numCourses && valid; ++i) {\n            if (!visited[i]) {\n                dfs(i);\n            }\n        }\n        if (!valid) {\n            return {};\n        }\n        // å¦‚æœæ²¡æœ‰ç¯ï¼Œé‚£ä¹ˆå°±æœ‰æ‹“æ‰‘æ’åº\n        // æ³¨æ„ä¸‹æ ‡ 0 ä¸ºæ ˆåº•ï¼Œå› æ­¤éœ€è¦å°†æ•°ç»„ååºè¾“å‡º\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    // å­˜å‚¨æœ‰å‘å›¾\n    List<List<Integer>> edges;\n    // æ ‡è®°æ¯ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€ï¼š0=æœªæœç´¢ï¼Œ1=æœç´¢ä¸­ï¼Œ2=å·²å®Œæˆ\n    int[] visited;\n    // ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿæ ˆï¼Œä¸‹æ ‡ n-1 ä¸ºæ ˆåº•ï¼Œ0 ä¸ºæ ˆé¡¶\n    int[] result;\n    // åˆ¤æ–­æœ‰å‘å›¾ä¸­æ˜¯å¦æœ‰ç¯\n    boolean valid = true;\n    // æ ˆä¸‹æ ‡\n    int index;\n\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        edges = new ArrayList<List<Integer>>();\n        for (int i = 0; i < numCourses; ++i) {\n            edges.add(new ArrayList<Integer>());\n        }\n        visited = new int[numCourses];\n        result = new int[numCourses];\n        index = numCourses - 1;\n        for (int[] info : prerequisites) {\n            edges.get(info[1]).add(info[0]);\n        }\n        // æ¯æ¬¡æŒ‘é€‰ä¸€ä¸ªã€Œæœªæœç´¢ã€çš„èŠ‚ç‚¹ï¼Œå¼€å§‹è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢\n        for (int i = 0; i < numCourses && valid; ++i) {\n            if (visited[i] == 0) {\n                dfs(i);\n            }\n        }\n        if (!valid) {\n            return new int[0];\n        }\n        // å¦‚æœæ²¡æœ‰ç¯ï¼Œé‚£ä¹ˆå°±æœ‰æ‹“æ‰‘æ’åº\n        return result;\n    }\n\n    public void dfs(int u) {\n        // å°†èŠ‚ç‚¹æ ‡è®°ä¸ºã€Œæœç´¢ä¸­ã€\n        visited[u] = 1;\n        // æœç´¢å…¶ç›¸é‚»èŠ‚ç‚¹\n        // åªè¦å‘ç°æœ‰ç¯ï¼Œç«‹åˆ»åœæ­¢æœç´¢\n        for (int v: edges.get(u)) {\n            // å¦‚æœã€Œæœªæœç´¢ã€é‚£ä¹ˆæœç´¢ç›¸é‚»èŠ‚ç‚¹\n            if (visited[v] == 0) {\n                dfs(v);\n                if (!valid) {\n                    return;\n                }\n            }\n            // å¦‚æœã€Œæœç´¢ä¸­ã€è¯´æ˜æ‰¾åˆ°äº†ç¯\n            else if (visited[v] == 1) {\n                valid = false;\n                return;\n            }\n        }\n        // å°†èŠ‚ç‚¹æ ‡è®°ä¸ºã€Œå·²å®Œæˆã€\n        visited[u] = 2;\n        // å°†èŠ‚ç‚¹å…¥æ ˆ\n        result[index--] = u;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        # å­˜å‚¨æœ‰å‘å›¾\n        edges = collections.defaultdict(list)\n        # æ ‡è®°æ¯ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€ï¼š0=æœªæœç´¢ï¼Œ1=æœç´¢ä¸­ï¼Œ2=å·²å®Œæˆ\n        visited = [0] * numCourses\n        # ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿæ ˆï¼Œä¸‹æ ‡ 0 ä¸ºæ ˆåº•ï¼Œn-1 ä¸ºæ ˆé¡¶\n        result = list()\n        # åˆ¤æ–­æœ‰å‘å›¾ä¸­æ˜¯å¦æœ‰ç¯\n        valid = True\n\n        for info in prerequisites:\n            edges[info[1]].append(info[0])\n        \n        def dfs(u: int):\n            nonlocal valid\n            # å°†èŠ‚ç‚¹æ ‡è®°ä¸ºã€Œæœç´¢ä¸­ã€\n            visited[u] = 1\n            # æœç´¢å…¶ç›¸é‚»èŠ‚ç‚¹\n            # åªè¦å‘ç°æœ‰ç¯ï¼Œç«‹åˆ»åœæ­¢æœç´¢\n            for v in edges[u]:\n                # å¦‚æœã€Œæœªæœç´¢ã€é‚£ä¹ˆæœç´¢ç›¸é‚»èŠ‚ç‚¹\n                if visited[v] == 0:\n                    dfs(v)\n                    if not valid:\n                        return\n                # å¦‚æœã€Œæœç´¢ä¸­ã€è¯´æ˜æ‰¾åˆ°äº†ç¯\n                elif visited[v] == 1:\n                    valid = False\n                    return\n            # å°†èŠ‚ç‚¹æ ‡è®°ä¸ºã€Œå·²å®Œæˆã€\n            visited[u] = 2\n            # å°†èŠ‚ç‚¹å…¥æ ˆ\n            result.append(u)\n        \n        # æ¯æ¬¡æŒ‘é€‰ä¸€ä¸ªã€Œæœªæœç´¢ã€çš„èŠ‚ç‚¹ï¼Œå¼€å§‹è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢\n        for i in range(numCourses):\n            if valid and not visited[i]:\n                dfs(i)\n        \n        if not valid:\n            return list()\n        \n        # å¦‚æœæ²¡æœ‰ç¯ï¼Œé‚£ä¹ˆå°±æœ‰æ‹“æ‰‘æ’åº\n        # æ³¨æ„ä¸‹æ ‡ 0 ä¸ºæ ˆåº•ï¼Œå› æ­¤éœ€è¦å°†æ•°ç»„ååºè¾“å‡º\n        return result[::-1]\n```\n\n```golang [sol1-Golang]\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\n    var (\n        edges = make([][]int, numCourses)\n        visited = make([]int, numCourses)\n        result []int\n        valid bool = true\n        dfs func(u int)\n    )\n\n    dfs = func(u int) {\n        visited[u] = 1\n        for _, v := range edges[u] {\n            if visited[v] == 0 {\n                dfs(v)\n                if !valid {\n                    return\n                }\n            } else if visited[v] == 1 {\n                valid = false\n                return\n            }\n        }\n        visited[u] = 2\n        result = append(result, u)\n    }\n\n    for _, info := range prerequisites {\n        edges[info[1]] = append(edges[info[1]], info[0])\n    }\n\n    for i := 0; i < numCourses && valid; i++ {\n        if visited[i] == 0 {\n            dfs(i)\n        }\n    }\n    if !valid {\n        return []int{}\n    }\n    for i := 0; i < len(result)/2; i ++ {\n        result[i], result[numCourses-i-1] = result[numCourses-i-1], result[i]\n    }\n    return result\n}\n```\n\n```C [sol1-C]\nint** edges;\nint* edgeColSize;\nint* visited;\nint* result;\nint resultSize;\nbool valid;\n\nvoid dfs(int u) {\n    visited[u] = 1;\n    for (int i = 0; i < edgeColSize[u]; ++i) {\n        if (visited[edges[u][i]] == 0) {\n            dfs(edges[u][i]);\n            if (!valid) {\n                return;\n            }\n        } else if (visited[edges[u][i]] == 1) {\n            valid = false;\n            return;\n        }\n    }\n    visited[u] = 2;\n    result[resultSize++] = u;\n}\n\nint* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize) {\n    valid = true;\n    edges = (int**)malloc(sizeof(int*) * numCourses);\n    for (int i = 0; i < numCourses; i++) {\n        edges[i] = (int*)malloc(0);\n    }\n    edgeColSize = (int*)malloc(sizeof(int) * numCourses);\n    memset(edgeColSize, 0, sizeof(int) * numCourses);\n    visited = (int*)malloc(sizeof(int) * numCourses);\n    memset(visited, 0, sizeof(int) * numCourses);\n    for (int i = 0; i < prerequisitesSize; ++i) {\n        int a = prerequisites[i][1], b = prerequisites[i][0];\n        edgeColSize[a]++;\n        edges[a] = (int*)realloc(edges[a], sizeof(int) * edgeColSize[a]);\n        edges[a][edgeColSize[a] - 1] = b;\n    }\n    result = (int*)malloc(sizeof(int) * numCourses);\n    resultSize = 0;\n    for (int i = 0; i < numCourses && valid; ++i) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n    for (int i = 0; i < numCourses; i++) {\n        free(edges[i]);\n    }\n    free(edges);\n    free(edgeColSize);\n    free(visited);\n    if (!valid) {\n        *returnSize = 0;\n    } else\n        *returnSize = numCourses;\n    for (int i = 0; i < numCourses / 2; i++) {\n        int t = result[i];\n        result[i] = result[numCourses - i - 1], result[numCourses - i - 1] = t;\n    }\n    return result;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦: $O(n+m)$ï¼Œå…¶ä¸­ $n$ ä¸ºè¯¾ç¨‹æ•°ï¼Œ$m$ ä¸ºå…ˆä¿®è¯¾ç¨‹çš„è¦æ±‚æ•°ã€‚è¿™å…¶å®å°±æ˜¯å¯¹å›¾è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢çš„æ—¶é—´å¤æ‚åº¦ã€‚\n\n- ç©ºé—´å¤æ‚åº¦: $O(n+m)$ã€‚é¢˜ç›®ä¸­æ˜¯ä»¥åˆ—è¡¨å½¢å¼ç»™å‡ºçš„å…ˆä¿®è¯¾ç¨‹å…³ç³»ï¼Œä¸ºäº†å¯¹å›¾è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œæˆ‘ä»¬éœ€è¦å­˜å‚¨æˆé‚»æ¥è¡¨çš„å½¢å¼ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(n+m)$ã€‚åœ¨æ·±åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æœ€å¤š $O(n)$ çš„æ ˆç©ºé—´ï¼ˆé€’å½’ï¼‰è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œå¹¶ä¸”è¿˜éœ€è¦è‹¥å¹²ä¸ª $O(n)$ çš„ç©ºé—´å­˜å‚¨èŠ‚ç‚¹çŠ¶æ€ã€æœ€ç»ˆç­”æ¡ˆç­‰ã€‚\n\n#### æ–¹æ³•äºŒï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢\n\n**æ€è·¯**\n\næ–¹æ³•ä¸€çš„æ·±åº¦ä¼˜å…ˆæœç´¢æ˜¯ä¸€ç§ã€Œé€†å‘æ€ç»´ã€ï¼šæœ€å…ˆè¢«æ”¾å…¥æ ˆä¸­çš„èŠ‚ç‚¹æ˜¯åœ¨æ‹“æ‰‘æ’åºä¸­æœ€åé¢çš„èŠ‚ç‚¹ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨æ­£å‘æ€ç»´ï¼Œé¡ºåºåœ°ç”Ÿæˆæ‹“æ‰‘æ’åºï¼Œè¿™ç§æ–¹æ³•ä¹Ÿæ›´åŠ ç›´è§‚ã€‚\n\næˆ‘ä»¬è€ƒè™‘æ‹“æ‰‘æ’åºä¸­æœ€å‰é¢çš„èŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹ä¸€å®šä¸ä¼šæœ‰ä»»ä½•å…¥è¾¹ï¼Œä¹Ÿå°±æ˜¯å®ƒæ²¡æœ‰ä»»ä½•çš„å…ˆä¿®è¯¾ç¨‹è¦æ±‚ã€‚å½“æˆ‘ä»¬å°†ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ç­”æ¡ˆä¸­åï¼Œæˆ‘ä»¬å°±å¯ä»¥ç§»é™¤å®ƒçš„æ‰€æœ‰å‡ºè¾¹ï¼Œä»£è¡¨ç€å®ƒçš„ç›¸é‚»èŠ‚ç‚¹**å°‘äº†ä¸€é—¨å…ˆä¿®è¯¾ç¨‹çš„è¦æ±‚**ã€‚å¦‚æœæŸä¸ªç›¸é‚»èŠ‚ç‚¹å˜æˆäº†ã€Œæ²¡æœ‰ä»»ä½•å…¥è¾¹çš„èŠ‚ç‚¹ã€ï¼Œé‚£ä¹ˆå°±ä»£è¡¨ç€è¿™é—¨è¯¾å¯ä»¥å¼€å§‹å­¦ä¹ äº†ã€‚æŒ‰ç…§è¿™æ ·çš„æµç¨‹ï¼Œæˆ‘ä»¬ä¸æ–­åœ°å°†æ²¡æœ‰å…¥è¾¹çš„èŠ‚ç‚¹åŠ å…¥ç­”æ¡ˆï¼Œç›´åˆ°ç­”æ¡ˆä¸­åŒ…å«æ‰€æœ‰çš„èŠ‚ç‚¹ï¼ˆå¾—åˆ°äº†ä¸€ç§æ‹“æ‰‘æ’åºï¼‰æˆ–è€…ä¸å­˜åœ¨æ²¡æœ‰å…¥è¾¹çš„èŠ‚ç‚¹ï¼ˆå›¾ä¸­åŒ…å«ç¯ï¼‰ã€‚\n\nä¸Šé¢çš„æƒ³æ³•ç±»ä¼¼äºå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†å¹¿åº¦ä¼˜å…ˆæœç´¢çš„æµç¨‹ä¸æ‹“æ‰‘æ’åºçš„æ±‚è§£è”ç³»èµ·æ¥ã€‚\n\n**ç®—æ³•**\n\næˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚å¼€å§‹æ—¶ï¼Œæ‰€æœ‰å…¥åº¦ä¸º $0$ çš„èŠ‚ç‚¹éƒ½è¢«æ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œå®ƒä»¬å°±æ˜¯å¯ä»¥ä½œä¸ºæ‹“æ‰‘æ’åºæœ€å‰é¢çš„èŠ‚ç‚¹ï¼Œå¹¶ä¸”å®ƒä»¬ä¹‹é—´çš„ç›¸å¯¹é¡ºåºæ˜¯æ— å…³ç´§è¦çš„ã€‚\n\nåœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢çš„æ¯ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬å–å‡ºé˜Ÿé¦–çš„èŠ‚ç‚¹ $u$ï¼š\n\n- æˆ‘ä»¬å°† $u$ æ”¾å…¥ç­”æ¡ˆä¸­ï¼›\n\n- æˆ‘ä»¬ç§»é™¤ $u$ çš„æ‰€æœ‰å‡ºè¾¹ï¼Œä¹Ÿå°±æ˜¯å°† $u$ çš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹çš„å…¥åº¦å‡å°‘ $1$ã€‚å¦‚æœæŸä¸ªç›¸é‚»èŠ‚ç‚¹ $v$ çš„å…¥åº¦å˜ä¸º $0$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å°† $v$ æ”¾å…¥é˜Ÿåˆ—ä¸­ã€‚\n\nåœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ç»“æŸåã€‚å¦‚æœç­”æ¡ˆä¸­åŒ…å«äº†è¿™ $n$ ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ‰¾åˆ°äº†ä¸€ç§æ‹“æ‰‘æ’åºï¼Œå¦åˆ™è¯´æ˜å›¾ä¸­å­˜åœ¨ç¯ï¼Œä¹Ÿå°±ä¸å­˜åœ¨æ‹“æ‰‘æ’åºäº†ã€‚\n\nä¸‹é¢çš„å¹»ç¯ç‰‡ç»™å‡ºäº†å¹¿åº¦ä¼˜å…ˆæœç´¢çš„å¯è§†åŒ–æµç¨‹ã€‚\n\n<![BFS1](https://assets.leetcode-cn.com/solution-static/207/fig1.png),![BFS2](https://assets.leetcode-cn.com/solution-static/207/fig2.png),![BFS3](https://assets.leetcode-cn.com/solution-static/207/fig3.png),![BFS4](https://assets.leetcode-cn.com/solution-static/207/fig4.png),![BFS5](https://assets.leetcode-cn.com/solution-static/207/fig5.png),![BFS6](https://assets.leetcode-cn.com/solution-static/207/fig6.png),![BFS7](https://assets.leetcode-cn.com/solution-static/207/fig7.png),![BFS8](https://assets.leetcode-cn.com/solution-static/207/fig8.png),![BFS9](https://assets.leetcode-cn.com/solution-static/207/fig9.png),![BFS10](https://assets.leetcode-cn.com/solution-static/207/fig10.png),![BFS11](https://assets.leetcode-cn.com/solution-static/207/fig11.png),![BFS12](https://assets.leetcode-cn.com/solution-static/207/fig12.png),![BFS13](https://assets.leetcode-cn.com/solution-static/207/fig13.png),![BFS14](https://assets.leetcode-cn.com/solution-static/207/fig14.png)>\n\n```C++ [sol2-C++]\nclass Solution {\nprivate:\n    // å­˜å‚¨æœ‰å‘å›¾\n    vector<vector<int>> edges;\n    // å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦\n    vector<int> indeg;\n    // å­˜å‚¨ç­”æ¡ˆ\n    vector<int> result;\n\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        edges.resize(numCourses);\n        indeg.resize(numCourses);\n        for (const auto& info: prerequisites) {\n            edges[info[1]].push_back(info[0]);\n            ++indeg[info[0]];\n        }\n\n        queue<int> q;\n        // å°†æ‰€æœ‰å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­\n        for (int i = 0; i < numCourses; ++i) {\n            if (indeg[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        while (!q.empty()) {\n            // ä»é˜Ÿé¦–å–å‡ºä¸€ä¸ªèŠ‚ç‚¹\n            int u = q.front();\n            q.pop();\n            // æ”¾å…¥ç­”æ¡ˆä¸­\n            result.push_back(u);\n            for (int v: edges[u]) {\n                --indeg[v];\n                // å¦‚æœç›¸é‚»èŠ‚ç‚¹ v çš„å…¥åº¦ä¸º 0ï¼Œå°±å¯ä»¥é€‰ v å¯¹åº”çš„è¯¾ç¨‹äº†\n                if (indeg[v] == 0) {\n                    q.push(v);\n                }\n            }\n        }\n\n        if (result.size() != numCourses) {\n            return {};\n        }\n        return result;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    // å­˜å‚¨æœ‰å‘å›¾\n    List<List<Integer>> edges;\n    // å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦\n    int[] indeg;\n    // å­˜å‚¨ç­”æ¡ˆ\n    int[] result;\n    // ç­”æ¡ˆä¸‹æ ‡\n    int index;\n\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        edges = new ArrayList<List<Integer>>();\n        for (int i = 0; i < numCourses; ++i) {\n            edges.add(new ArrayList<Integer>());\n        }\n        indeg = new int[numCourses];\n        result = new int[numCourses];\n        index = 0;\n        for (int[] info : prerequisites) {\n            edges.get(info[1]).add(info[0]);\n            ++indeg[info[0]];\n        }\n\n        Queue<Integer> queue = new LinkedList<Integer>();\n        // å°†æ‰€æœ‰å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­\n        for (int i = 0; i < numCourses; ++i) {\n            if (indeg[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            // ä»é˜Ÿé¦–å–å‡ºä¸€ä¸ªèŠ‚ç‚¹\n            int u = queue.poll();\n            // æ”¾å…¥ç­”æ¡ˆä¸­\n            result[index++] = u;\n            for (int v: edges.get(u)) {\n                --indeg[v];\n                // å¦‚æœç›¸é‚»èŠ‚ç‚¹ v çš„å…¥åº¦ä¸º 0ï¼Œå°±å¯ä»¥é€‰ v å¯¹åº”çš„è¯¾ç¨‹äº†\n                if (indeg[v] == 0) {\n                    queue.offer(v);\n                }\n            }\n        }\n\n        if (index != numCourses) {\n            return new int[0];\n        }\n        return result;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        # å­˜å‚¨æœ‰å‘å›¾\n        edges = collections.defaultdict(list)\n        # å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦\n        indeg = [0] * numCourses\n        # å­˜å‚¨ç­”æ¡ˆ\n        result = list()\n\n        for info in prerequisites:\n            edges[info[1]].append(info[0])\n            indeg[info[0]] += 1\n        \n        # å°†æ‰€æœ‰å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­\n        q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])\n\n        while q:\n            # ä»é˜Ÿé¦–å–å‡ºä¸€ä¸ªèŠ‚ç‚¹\n            u = q.popleft()\n            # æ”¾å…¥ç­”æ¡ˆä¸­\n            result.append(u)\n            for v in edges[u]:\n                indeg[v] -= 1\n                # å¦‚æœç›¸é‚»èŠ‚ç‚¹ v çš„å…¥åº¦ä¸º 0ï¼Œå°±å¯ä»¥é€‰ v å¯¹åº”çš„è¯¾ç¨‹äº†\n                if indeg[v] == 0:\n                    q.append(v)\n\n        if len(result) != numCourses:\n            result = list()\n        return result\n```\n\n```golang [sol2-Golang]\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\n    var (\n        edges = make([][]int, numCourses)\n        indeg = make([]int, numCourses)\n        result []int\n    )\n\n    for _, info := range prerequisites {\n        edges[info[1]] = append(edges[info[1]], info[0])\n        indeg[info[0]]++\n    }\n\n    q := []int{}\n    for i := 0; i < numCourses; i++ {\n        if indeg[i] == 0 {\n            q = append(q, i)\n        }\n    }\n\n    for len(q) > 0 {\n        u := q[0]\n        q = q[1:]\n        result = append(result, u)\n        for _, v := range edges[u] {\n            indeg[v]--\n            if indeg[v] == 0 {\n                q = append(q, v)\n            }\n        }\n    }\n    if len(result) != numCourses {\n        return []int{}\n    }\n    return result\n}\n```\n\n```C [sol2-C]\nint* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize) {\n    int** edges = (int**)malloc(sizeof(int*) * numCourses);\n    for (int i = 0; i < numCourses; i++) {\n        edges[i] = (int*)malloc(0);\n    }\n    int edgeColSize[numCourses];\n    memset(edgeColSize, 0, sizeof(edgeColSize));\n    int indeg[numCourses];\n    memset(indeg, 0, sizeof(indeg));\n    for (int i = 0; i < prerequisitesSize; ++i) {\n        int a = prerequisites[i][1], b = prerequisites[i][0];\n        edgeColSize[a]++;\n        edges[a] = (int*)realloc(edges[a], sizeof(int) * edgeColSize[a]);\n        edges[a][edgeColSize[a] - 1] = b;\n        ++indeg[b];\n    }\n\n    int q[numCourses];\n    int l = 0, r = -1;\n    for (int i = 0; i < numCourses; ++i) {\n        if (indeg[i] == 0) {\n            q[++r] = i;\n        }\n    }\n\n    int* result = (int*)malloc(sizeof(int) * numCourses);\n    int resultSize = 0;\n\n    int visited = 0;\n    while (l <= r) {\n        ++visited;\n        int u = q[l++];\n        result[resultSize++] = u;\n        for (int i = 0; i < edgeColSize[u]; ++i) {\n            --indeg[edges[u][i]];\n            if (indeg[edges[u][i]] == 0) {\n                q[++r] = edges[u][i];\n            }\n        }\n    }\n    for (int i = 0; i < numCourses; i++) {\n        free(edges[i]);\n    }\n    free(edges);\n    if (visited == numCourses) {\n        *returnSize = numCourses;\n    } else {\n        *returnSize = 0;\n    }\n    return result;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦: $O(n+m)$ï¼Œå…¶ä¸­ $n$ ä¸ºè¯¾ç¨‹æ•°ï¼Œ$m$ ä¸ºå…ˆä¿®è¯¾ç¨‹çš„è¦æ±‚æ•°ã€‚è¿™å…¶å®å°±æ˜¯å¯¹å›¾è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢çš„æ—¶é—´å¤æ‚åº¦ã€‚\n\n- ç©ºé—´å¤æ‚åº¦: $O(n+m)$ã€‚é¢˜ç›®ä¸­æ˜¯ä»¥åˆ—è¡¨å½¢å¼ç»™å‡ºçš„å…ˆä¿®è¯¾ç¨‹å…³ç³»ï¼Œä¸ºäº†å¯¹å›¾è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œæˆ‘ä»¬éœ€è¦å­˜å‚¨æˆé‚»æ¥è¡¨çš„å½¢å¼ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(n+m)$ã€‚åœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æœ€å¤š $O(n)$ çš„é˜Ÿåˆ—ç©ºé—´ï¼ˆè¿­ä»£ï¼‰è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œå¹¶ä¸”è¿˜éœ€è¦è‹¥å¹²ä¸ª $O(n)$ çš„ç©ºé—´å­˜å‚¨èŠ‚ç‚¹å…¥åº¦ã€æœ€ç»ˆç­”æ¡ˆç­‰ã€‚"
}