{
	"titleSlug": "partition-equal-subset-sum",
	"slug": "fen-ge-deng-he-zi-ji-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![416.åˆ†å‰²ç­‰å’Œå­é›†.mp4](1712d35b-f0ab-48aa-b964-fe22bf0a5931)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### å‰è¨€\n\n**ä½œè€…åœ¨è¿™é‡Œå¸Œæœ›è¯»è€…è®¤çœŸé˜…è¯»å‰è¨€éƒ¨åˆ†ã€‚**\n\næœ¬é¢˜æ˜¯ç»å…¸çš„ã€Œ[NP å®Œå…¨é—®é¢˜](https://baike.baidu.com/item/NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98)ã€ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä½ å‘ç°äº†è¯¥é—®é¢˜çš„ä¸€ä¸ª[å¤šé¡¹å¼ç®—æ³•](https://baike.baidu.com/item/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AE%97%E6%B3%95)ï¼Œé‚£ä¹ˆæ­å–œä½ è¯æ˜å‡ºäº† P=NPï¼Œå¯ä»¥æœŸå¾…ä¸€ä¸‹å›¾çµå¥–äº†ã€‚\n\næ­£å› å¦‚æ­¤ï¼Œæˆ‘ä»¬ä¸åº”æœŸæœ›è¯¥é—®é¢˜æœ‰å¤šé¡¹å¼æ—¶é—´å¤æ‚åº¦çš„è§£æ³•ã€‚æˆ‘ä»¬èƒ½æƒ³åˆ°çš„ï¼Œä¾‹å¦‚åŸºäºè´ªå¿ƒç®—æ³•çš„ã€Œå°†æ•°ç»„é™åºæ’åºåï¼Œä¾æ¬¡å°†æ¯ä¸ªå…ƒç´ æ·»åŠ è‡³å½“å‰å…ƒç´ å’Œè¾ƒå°çš„å­é›†ä¸­ã€ä¹‹ç±»çš„æ–¹æ³•éƒ½æ˜¯é”™è¯¯çš„ï¼Œå¯ä»¥è½»æ¾åœ°ä¸¾å‡ºåä¾‹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»å°è¯•éå¤šé¡¹å¼æ—¶é—´å¤æ‚åº¦çš„ç®—æ³•ï¼Œä¾‹å¦‚æ—¶é—´å¤æ‚åº¦ä¸å…ƒç´ å¤§å°ç›¸å…³çš„**åŠ¨æ€è§„åˆ’**ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’\n\n**æ€è·¯ä¸ç®—æ³•**\n\nè¿™é“é¢˜å¯ä»¥æ¢ä¸€ç§è¡¨è¿°ï¼šç»™å®šä¸€ä¸ªåªåŒ…å«æ­£æ•´æ•°çš„éç©ºæ•°ç»„ $\\textit{nums}[0]$ï¼Œåˆ¤æ–­æ˜¯å¦å¯ä»¥ä»æ•°ç»„ä¸­é€‰å‡ºä¸€äº›æ•°å­—ï¼Œä½¿å¾—è¿™äº›æ•°å­—çš„å’Œç­‰äºæ•´ä¸ªæ•°ç»„çš„å…ƒç´ å’Œçš„ä¸€åŠã€‚å› æ­¤è¿™ä¸ªé—®é¢˜å¯ä»¥è½¬æ¢æˆã€Œ$0-1$ èƒŒåŒ…é—®é¢˜ã€ã€‚è¿™é“é¢˜ä¸ä¼ ç»Ÿçš„ã€Œ$0-1$ èƒŒåŒ…é—®é¢˜ã€çš„åŒºåˆ«åœ¨äºï¼Œä¼ ç»Ÿçš„ã€Œ$0-1$ èƒŒåŒ…é—®é¢˜ã€è¦æ±‚é€‰å–çš„ç‰©å“çš„é‡é‡ä¹‹å’Œ**ä¸èƒ½è¶…è¿‡**èƒŒåŒ…çš„æ€»å®¹é‡ï¼Œè¿™é“é¢˜åˆ™è¦æ±‚é€‰å–çš„æ•°å­—çš„å’Œ**æ°å¥½ç­‰äº**æ•´ä¸ªæ•°ç»„çš„å…ƒç´ å’Œçš„ä¸€åŠã€‚ç±»ä¼¼äºä¼ ç»Ÿçš„ã€Œ$0-1$ èƒŒåŒ…é—®é¢˜ã€ï¼Œå¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ã€‚\n\nåœ¨ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ä¹‹å‰ï¼Œé¦–å…ˆéœ€è¦è¿›è¡Œä»¥ä¸‹åˆ¤æ–­ã€‚\n\n- æ ¹æ®æ•°ç»„çš„é•¿åº¦ $n$ åˆ¤æ–­æ•°ç»„æ˜¯å¦å¯ä»¥è¢«åˆ’åˆ†ã€‚å¦‚æœ $n<2$ï¼Œåˆ™ä¸å¯èƒ½å°†æ•°ç»„åˆ†å‰²æˆå…ƒç´ å’Œç›¸ç­‰çš„ä¸¤ä¸ªå­é›†ï¼Œå› æ­¤ç›´æ¥è¿”å› $\\text{false}$ã€‚\n\n- è®¡ç®—æ•´ä¸ªæ•°ç»„çš„å…ƒç´ å’Œ $\\textit{sum}$ ä»¥åŠæœ€å¤§å…ƒç´  $\\textit{maxNum}$ã€‚å¦‚æœ $\\textit{sum}$ æ˜¯å¥‡æ•°ï¼Œåˆ™ä¸å¯èƒ½å°†æ•°ç»„åˆ†å‰²æˆå…ƒç´ å’Œç›¸ç­‰çš„ä¸¤ä¸ªå­é›†ï¼Œå› æ­¤ç›´æ¥è¿”å› $\\text{false}$ã€‚å¦‚æœ $\\textit{sum}$ æ˜¯å¶æ•°ï¼Œåˆ™ä»¤ $\\textit{target}=\\frac{\\textit{sum}}{2}$ï¼Œéœ€è¦åˆ¤æ–­æ˜¯å¦å¯ä»¥ä»æ•°ç»„ä¸­é€‰å‡ºä¸€äº›æ•°å­—ï¼Œä½¿å¾—è¿™äº›æ•°å­—çš„å’Œç­‰äº $\\textit{target}$ã€‚å¦‚æœ $\\textit{maxNum}>\\textit{target}$ï¼Œåˆ™é™¤äº† $\\textit{maxNum}$ ä»¥å¤–çš„æ‰€æœ‰å…ƒç´ ä¹‹å’Œä¸€å®šå°äº $\\textit{target}$ï¼Œå› æ­¤ä¸å¯èƒ½å°†æ•°ç»„åˆ†å‰²æˆå…ƒç´ å’Œç›¸ç­‰çš„ä¸¤ä¸ªå­é›†ï¼Œç›´æ¥è¿”å› $\\text{false}$ã€‚\n\nåˆ›å»ºäºŒç»´æ•°ç»„ $\\textit{dp}$ï¼ŒåŒ…å« $n$ è¡Œ $\\textit{target}+1$ åˆ—ï¼Œå…¶ä¸­ $\\textit{dp}[i][j]$ è¡¨ç¤ºä»æ•°ç»„çš„ $[0,i]$ ä¸‹æ ‡èŒƒå›´å†…é€‰å–è‹¥å¹²ä¸ªæ­£æ•´æ•°ï¼ˆå¯ä»¥æ˜¯ $0$ ä¸ªï¼‰ï¼Œæ˜¯å¦å­˜åœ¨ä¸€ç§é€‰å–æ–¹æ¡ˆä½¿å¾—è¢«é€‰å–çš„æ­£æ•´æ•°çš„å’Œç­‰äº $j$ã€‚åˆå§‹æ—¶ï¼Œ$\\textit{dp}$ ä¸­çš„å…¨éƒ¨å…ƒç´ éƒ½æ˜¯ $\\text{false}$ã€‚\n\nåœ¨å®šä¹‰çŠ¶æ€ä¹‹åï¼Œéœ€è¦è€ƒè™‘è¾¹ç•Œæƒ…å†µã€‚ä»¥ä¸‹ä¸¤ç§æƒ…å†µéƒ½å±äºè¾¹ç•Œæƒ…å†µã€‚\n\n- å¦‚æœä¸é€‰å–ä»»ä½•æ­£æ•´æ•°ï¼Œåˆ™è¢«é€‰å–çš„æ­£æ•´æ•°ç­‰äº $0$ã€‚å› æ­¤å¯¹äºæ‰€æœ‰ $0 \\le i < n$ï¼Œéƒ½æœ‰ $\\textit{dp}[i][0]=\\text{true}$ã€‚\n\n- å½“ $i==0$ æ—¶ï¼Œåªæœ‰ä¸€ä¸ªæ­£æ•´æ•° $\\textit{nums}[0]$ å¯ä»¥è¢«é€‰å–ï¼Œå› æ­¤ $\\textit{dp}[0][\\textit{nums}[0]]=\\text{true}$ã€‚\n\nå¯¹äº $i>0$ ä¸” $j>0$ çš„æƒ…å†µï¼Œå¦‚ä½•ç¡®å®š $\\textit{dp}[i][j]$ çš„å€¼ï¼Ÿéœ€è¦åˆ†åˆ«è€ƒè™‘ä»¥ä¸‹ä¸¤ç§æƒ…å†µã€‚\n\n- å¦‚æœ $j \\ge \\textit{nums}[i]$ï¼Œåˆ™å¯¹äºå½“å‰çš„æ•°å­— $\\textit{nums}[i]$ï¼Œå¯ä»¥é€‰å–ä¹Ÿå¯ä»¥ä¸é€‰å–ï¼Œä¸¤ç§æƒ…å†µåªè¦æœ‰ä¸€ä¸ªä¸º $\\text{true}$ï¼Œå°±æœ‰ $\\textit{dp}[i][j]=\\text{true}$ã€‚\n   - å¦‚æœä¸é€‰å– $\\textit{nums}[i]$ï¼Œåˆ™ $\\textit{dp}[i][j]=\\textit{dp}[i-1][j]$ï¼›\n   - å¦‚æœé€‰å– $\\textit{nums}[i]$ï¼Œåˆ™ $\\textit{dp}[i][j]=\\textit{dp}[i-1][j-\\textit{nums}[i]]$ã€‚\n\n- å¦‚æœ $j < \\textit{nums}[i]$ï¼Œåˆ™åœ¨é€‰å–çš„æ•°å­—çš„å’Œç­‰äº $j$ çš„æƒ…å†µä¸‹æ— æ³•é€‰å–å½“å‰çš„æ•°å­— $\\textit{nums}[i]$ï¼Œå› æ­¤æœ‰ $\\textit{dp}[i][j]=\\textit{dp}[i-1][j]$ã€‚\n\nçŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š\n\n$$\n\\textit{dp}[i][j]=\\begin{cases}\n\\textit{dp}[i-1][j]~|~\\textit{dp}[i-1][j-\\textit{nums}[i]], & j \\ge \\textit{nums}[i] \\\\\n\\textit{dp}[i-1][j], & j < \\textit{nums}[i]\n\\end{cases}\n$$\n\næœ€ç»ˆå¾—åˆ° $\\textit{dp}[n-1][\\textit{target}]$ å³ä¸ºç­”æ¡ˆã€‚\n\n<![ppt1](https://assets.leetcode-cn.com/solution-static/416/1.png),![ppt2](https://assets.leetcode-cn.com/solution-static/416/2.png),![ppt3](https://assets.leetcode-cn.com/solution-static/416/3.png),![ppt4](https://assets.leetcode-cn.com/solution-static/416/4.png),![ppt5](https://assets.leetcode-cn.com/solution-static/416/5.png),![ppt6](https://assets.leetcode-cn.com/solution-static/416/6.png),![ppt7](https://assets.leetcode-cn.com/solution-static/416/7.png),![ppt8](https://assets.leetcode-cn.com/solution-static/416/8.png),![ppt9](https://assets.leetcode-cn.com/solution-static/416/9.png),![ppt10](https://assets.leetcode-cn.com/solution-static/416/10.png),![ppt11](https://assets.leetcode-cn.com/solution-static/416/11.png),![ppt12](https://assets.leetcode-cn.com/solution-static/416/12.png)>\n\n```Java [sol0-Java]\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int n = nums.length;\n        if (n < 2) {\n            return false;\n        }\n        int sum = 0, maxNum = 0;\n        for (int num : nums) {\n            sum += num;\n            maxNum = Math.max(maxNum, num);\n        }\n        if (sum % 2 != 0) {\n            return false;\n        }\n        int target = sum / 2;\n        if (maxNum > target) {\n            return false;\n        }\n        boolean[][] dp = new boolean[n][target + 1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n        dp[0][nums[0]] = true;\n        for (int i = 1; i < n; i++) {\n            int num = nums[i];\n            for (int j = 1; j <= target; j++) {\n                if (j >= num) {\n                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[n - 1][target];\n    }\n}\n```\n\n```C++ [sol0-C++]\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int n = nums.size();\n        if (n < 2) {\n            return false;\n        }\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        int maxNum = *max_element(nums.begin(), nums.end());\n        if (sum & 1) {\n            return false;\n        }\n        int target = sum / 2;\n        if (maxNum > target) {\n            return false;\n        }\n        vector<vector<int>> dp(n, vector<int>(target + 1, 0));\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n        dp[0][nums[0]] = true;\n        for (int i = 1; i < n; i++) {\n            int num = nums[i];\n            for (int j = 1; j <= target; j++) {\n                if (j >= num) {\n                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[n - 1][target];\n    }\n};\n```\n\n```JavaScript [sol0-JavaScript]\nvar canPartition = function(nums) {\n    const n = nums.length;\n    if (n < 2) {\n        return false;\n    }\n    let sum = 0, maxNum = 0;\n    for (const num of nums) {\n        sum += num;\n        maxNum = maxNum > num ? maxNum : num;\n    }\n    if (sum & 1) {\n        return false;\n    }\n    const target = Math.floor(sum / 2);\n    if (maxNum > target) {\n        return false;\n    }\n    const dp = new Array(n).fill(0).map(() => new Array(target + 1, false));\n    for (let i = 0; i < n; i++) {\n        dp[i][0] = true;\n    }\n    dp[0][nums[0]] = true;\n    for (let i = 1; i < n; i++) {\n        const num = nums[i];\n        for (let j = 1; j <= target; j++) {\n            if (j >= num) {\n                dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[n - 1][target];\n};\n```\n\n```Golang [sol0-Golang]\nfunc canPartition(nums []int) bool {\n    n := len(nums)\n    if n < 2 {\n        return false\n    }\n\n    sum, max := 0, 0\n    for _, v := range nums {\n        sum += v\n        if v > max {\n            max = v\n        }\n    }\n    if sum%2 != 0 {\n        return false\n    }\n\n    target := sum / 2\n    if max > target {\n        return false\n    }\n\n    dp := make([][]bool, n)\n    for i := range dp {\n        dp[i] = make([]bool, target+1)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][0] = true\n    }\n    dp[0][nums[0]] = true\n    for i := 1; i < n; i++ {\n        v := nums[i]\n        for j := 1; j <= target; j++ {\n            if j >= v {\n                dp[i][j] = dp[i-1][j] || dp[i-1][j-v]\n            } else {\n                dp[i][j] = dp[i-1][j]\n            }\n        }\n    }\n    return dp[n-1][target]\n}\n```\n\n```C [sol0-C]\nbool canPartition(int* nums, int numsSize) {\n    if (numsSize < 2) {\n        return false;\n    }\n    int sum = 0, maxNum = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        sum += nums[i];\n        maxNum = fmax(maxNum, nums[i]);\n    }\n    if (sum & 1) {\n        return false;\n    }\n    int target = sum / 2;\n    if (maxNum > target) {\n        return false;\n    }\n    int dp[numsSize][target + 1];\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < numsSize; i++) {\n        dp[i][0] = true;\n    }\n    dp[0][nums[0]] = true;\n    for (int i = 1; i < numsSize; i++) {\n        int num = nums[i];\n        for (int j = 1; j <= target; j++) {\n            if (j >= num) {\n                dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[numsSize - 1][target];\n}\n```\n\n```Python [sol0-Python3]\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n < 2:\n            return False\n        \n        total = sum(nums)\n        maxNum = max(nums)\n        if total & 1:\n            return False\n        \n        target = total // 2\n        if maxNum > target:\n            return False\n        \n        dp = [[False] * (target + 1) for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = True\n        \n        dp[0][nums[0]] = True\n        for i in range(1, n):\n            num = nums[i]\n            for j in range(1, target + 1):\n                if j >= num:\n                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[n - 1][target]\n```\n\nä¸Šè¿°ä»£ç çš„ç©ºé—´å¤æ‚åº¦æ˜¯ $O(n \\times \\textit{target})$ã€‚ä½†æ˜¯å¯ä»¥å‘ç°åœ¨è®¡ç®— $\\textit{dp}$ çš„è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸€è¡Œçš„ $dp$ å€¼éƒ½åªä¸ä¸Šä¸€è¡Œçš„ $dp$ å€¼æœ‰å…³ï¼Œå› æ­¤åªéœ€è¦ä¸€ä¸ªä¸€ç»´æ•°ç»„å³å¯å°†ç©ºé—´å¤æ‚åº¦é™åˆ° $O(\\textit{target})$ã€‚æ­¤æ—¶çš„è½¬ç§»æ–¹ç¨‹ä¸ºï¼š\n$$\n\\textit{dp}[j]=\\textit{dp}[j]\\ |\\ dp[j-\\textit{nums}[i]]\n$$\nä¸”éœ€è¦æ³¨æ„çš„æ˜¯ç¬¬äºŒå±‚çš„å¾ªç¯æˆ‘ä»¬éœ€è¦**ä»å¤§åˆ°å°è®¡ç®—**ï¼Œå› ä¸ºå¦‚æœæˆ‘ä»¬ä»å°åˆ°å¤§æ›´æ–° $\\textit{dp}$ å€¼ï¼Œé‚£ä¹ˆåœ¨è®¡ç®— $\\textit{dp}[j]$ å€¼çš„æ—¶å€™ï¼Œ$\\textit{dp}[j-\\textit{nums}[i]]$ å·²ç»æ˜¯è¢«æ›´æ–°è¿‡çš„çŠ¶æ€ï¼Œä¸å†æ˜¯ä¸Šä¸€è¡Œçš„ $\\textit{dp}$ å€¼ã€‚\n\n**ä»£ç **\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int n = nums.length;\n        if (n < 2) {\n            return false;\n        }\n        int sum = 0, maxNum = 0;\n        for (int num : nums) {\n            sum += num;\n            maxNum = Math.max(maxNum, num);\n        }\n        if (sum % 2 != 0) {\n            return false;\n        }\n        int target = sum / 2;\n        if (maxNum > target) {\n            return false;\n        }\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            for (int j = target; j >= num; --j) {\n                dp[j] |= dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int n = nums.size();\n        if (n < 2) {\n            return false;\n        }\n        int sum = 0, maxNum = 0;\n        for (auto& num : nums) {\n            sum += num;\n            maxNum = max(maxNum, num);\n        }\n        if (sum & 1) {\n            return false;\n        }\n        int target = sum / 2;\n        if (maxNum > target) {\n            return false;\n        }\n        vector<int> dp(target + 1, 0);\n        dp[0] = true;\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            for (int j = target; j >= num; --j) {\n                dp[j] |= dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n};\n```\n\n```JavaScript [sol1-JavaScript]\nvar canPartition = function(nums) {\n    const n = nums.length;\n    if (n < 2) {\n        return false;\n    }\n    let sum = 0, maxNum = 0;\n    for (const num of nums) {\n        sum += num;\n        maxNum = maxNum > num ? maxNum : num;\n    }\n    if (sum & 1) {\n        return false;\n    }\n    const target = Math.floor(sum / 2);\n    if (maxNum > target) {\n        return false;\n    }\n    const dp = new Array(target + 1).fill(false);\n    dp[0] = true;\n    for (const num of nums) {\n        for (let j = target; j >= num; --j) {\n            dp[j] |= dp[j - num];\n        }\n    }\n    return dp[target];\n};\n```\n\n```Golang [sol1-Golang]\nfunc canPartition(nums []int) bool {\n    n := len(nums)\n    if n < 2 {\n        return false\n    }\n\n    sum, max := 0, 0\n    for _, v := range nums {\n        sum += v\n        if v > max {\n            max = v\n        }\n    }\n    if sum%2 != 0 {\n        return false\n    }\n\n    target := sum / 2\n    if max > target {\n        return false\n    }\n\n    dp := make([]bool, target+1)\n    dp[0] = true\n    for i := 0; i < n; i++ {\n        v := nums[i]\n        for j := target; j >= v; j-- {\n            dp[j] = dp[j] || dp[j-v]\n        }\n    }\n    return dp[target]\n}\n```\n\n```C [sol1-C]\nbool canPartition(int* nums, int numsSize) {\n    if (numsSize < 2) {\n        return false;\n    }\n    int sum = 0, maxNum = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        sum += nums[i];\n        maxNum = fmax(maxNum, nums[i]);\n    }\n    if (sum & 1) {\n        return false;\n    }\n    int target = sum / 2;\n    if (maxNum > target) {\n        return false;\n    }\n    int dp[target + 1];\n    memset(dp, 0, sizeof(dp));\n    dp[0] = true;\n    for (int i = 0; i < numsSize; i++) {\n        int num = nums[i];\n        for (int j = target; j >= num; --j) {\n            dp[j] |= dp[j - num];\n        }\n    }\n    return dp[target];\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n < 2:\n            return False\n        \n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        \n        target = total // 2\n        dp = [True] + [False] * target\n        for i, num in enumerate(nums):\n            for j in range(target, num - 1, -1):\n                dp[j] |= dp[j - num]\n        \n        return dp[target]\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \\times \\textit{target})$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„çš„é•¿åº¦ï¼Œ$\\textit{target}$ æ˜¯æ•´ä¸ªæ•°ç»„çš„å…ƒç´ å’Œçš„ä¸€åŠã€‚éœ€è¦è®¡ç®—å‡ºæ‰€æœ‰çš„çŠ¶æ€ï¼Œæ¯ä¸ªçŠ¶æ€åœ¨è¿›è¡Œè½¬ç§»æ—¶çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(1)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(\\textit{target})$ï¼Œå…¶ä¸­ $\\textit{target}$ æ˜¯æ•´ä¸ªæ•°ç»„çš„å…ƒç´ å’Œçš„ä¸€åŠã€‚ç©ºé—´å¤æ‚åº¦å–å†³äº $\\textit{dp}$ æ•°ç»„ï¼Œåœ¨ä¸è¿›è¡Œç©ºé—´ä¼˜åŒ–çš„æƒ…å†µä¸‹ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ $O(n \\times \\textit{target})$ï¼Œåœ¨è¿›è¡Œç©ºé—´ä¼˜åŒ–çš„æƒ…å†µä¸‹ï¼Œç©ºé—´å¤æ‚åº¦å¯ä»¥é™åˆ° $O(\\textit{target})$ã€‚"
}