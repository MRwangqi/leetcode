{
	"titleSlug": "find-winner-on-a-tic-tac-toe-game",
	"slug": "zhao-chu-jing-zi-qi-de-huo-sheng-zhe-by-leetcode-s",
	"url": "https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/solution/zhao-chu-jing-zi-qi-de-huo-sheng-zhe-by-leetcode-s/",
	"content": "### 方法一：模拟\n\n我们可以模拟数组 `move` 中的每一步落子。我们使用两个集合 `A` 和 `B` 存放每位玩家当前已经落子的位置，并用集合 `wins` 存放棋子排成一条直线的所有情况（排成一行或一列各有 `3` 种，排成对角线有 `2` 种，总计 `8` 种）。当某位玩家落子时，我们枚举 `wins` 中的每一种情况，并判断该玩家是否将棋子落在了这些位置。如果满足了其中一种情况，则该玩家获胜。\n\n如果直到落子完毕仍然没有玩家获胜，那么根据数组 `move` 的长度返回平局 `Draw` 或游戏未结束 `Pending`。\n\n```C++ [sol1]\nclass Solution {\npublic:\n    bool checkwin(unordered_set<int>& S, vector<vector<int>>& wins) {\n        for (auto win: wins) {\n            bool flag = true;\n            for (auto pos: win) {\n                if (!S.count(pos)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    string tictactoe(vector<vector<int>>& moves) {\n        vector<vector<int>> wins = {\n            {0, 1, 2},\n            {3, 4, 5},\n            {6, 7, 8},\n            {0, 3, 6},\n            {1, 4, 7},\n            {2, 5, 8},\n            {0, 4, 8},\n            {2, 4, 6}\n        };\n\n        unordered_set<int> A, B;\n        for (int i = 0; i < moves.size(); ++i) {\n            int pos = moves[i][0] * 3 + moves[i][1];\n            if (i % 2 == 0) {\n                A.insert(pos);\n                if (checkwin(A, wins)) {\n                    return \"A\";\n                }\n            }\n            else {\n                B.insert(pos);\n                if (checkwin(B, wins)) {\n                    return \"B\";\n                }\n            }\n        }\n\n        return (moves.size() == 9 ? \"Draw\" : \"Pending\");\n    }\n};\n```\n\n```Python [sol1]\nclass Solution:\n    def tictactoe(self, moves: List[List[int]]) -> str:\n        wins = [\n            [(0, 0), (0, 1), (0, 2)],\n            [(1, 0), (1, 1), (1, 2)],\n            [(2, 0), (2, 1), (2, 2)],\n            [(0, 0), (1, 0), (2, 0)],\n            [(0, 1), (1, 1), (2, 1)],\n            [(0, 2), (1, 2), (2, 2)],\n            [(0, 0), (1, 1), (2, 2)],\n            [(0, 2), (1, 1), (2, 0)],\n        ]\n\n        def checkwin(S):\n            for win in wins:\n                flag = True\n                for pos in win:\n                    if pos not in S:\n                        flag = False\n                        break\n                if flag:\n                    return True\n            return False\n\n        A, B = set(), set()\n        for i, (x, y) in enumerate(moves):\n            if i % 2 == 0:\n                A.add((x, y))\n                if checkwin(A):\n                    return \"A\"\n            else:\n                B.add((x, y))\n                if checkwin(B):\n                    return \"B\"\n        \n        return \"Draw\" if len(moves) == 9 else \"Pending\"\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N^4)$，其中 $N$ 是棋盘的边长，在本题中 $N = 3$。集合 `wins` 中存放的排成一条直线的所有情况的数量为 $O(2N+2)=O(N)$，对于每一步落子我们需要遍历所有的情况，而每一种情况有 $N$ 个位置，因此时间复杂度为 $O(N^2)$。在最坏情况下，落子的数量为 $O(N^2)$，因此总时间复杂度为 $O(N^4)$。\n\n- 空间复杂度：$O(N^2)$。集合 `wins` 占用的空间为 $O(N^2)$，而集合 `A` 和 `B` 在最坏情况下占用的空间也为 $O(N^2)$。"
}