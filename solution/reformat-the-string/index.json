{
	"titleSlug": "reformat-the-string",
	"slug": "zhong-xin-ge-shi-hua-zi-fu-chuan-by-leet-lgqx",
	"url": "https://leetcode-cn.com/problems/reformat-the-string/solution/zhong-xin-ge-shi-hua-zi-fu-chuan-by-leet-lgqx/",
	"content": "#### 方法一：双指针\n\n**思路与算法**\n\n题目给定字符串 $s$，我们记 $\\textit{sum\\_digit}$ 为字符串中数字的个数，$\\textit{sum\\_alpha}$ 为字符串中字母的个数。那么能按照题目要求格式化字符串的充要条件为：\n\n$$|\\textit{sum\\_digit} - \\textit{sum\\_alpha}| \\le 1$$\n\n那么当给定字符串 $s$ 满足上述条件时，我们把数字和字母中个数多的放在偶数位上（字符串下标从 $0$ 开始），个数少的放在奇数位上，此时可以构造出满足题目条件的字符串。那么我们用 $i$ 和 $j$ 来分别表示个数多的和个数少的字符放置的下标，初始为 $i = 0, j = 1$，然后从左到右移动 $i$，当 $s[i]$ 为个数少的字符类型时，那么向右移动 $j$ 找到往后的第一个 $s[j]$ 为个数多的字符类型，然后交换两个字符即可，不断重复该过程直至 $i$ 移动到字符串结尾即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def reformat(self, s: str) -> str:\n        sumDigit = sum(c.isdigit() for c in s)\n        sumAlpha = len(s) - sumDigit\n        if abs(sumDigit - sumAlpha) > 1:\n            return \"\"\n        flag = sumDigit > sumAlpha\n        t = list(s)\n        j = 1\n        for i in range(0, len(t), 2):\n            if t[i].isdigit() != flag:\n                while t[j].isdigit() != flag:\n                    j += 2\n                t[i], t[j] = t[j], t[i]\n        return ''.join(t)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string reformat(string s) {\n        int sum_digit = 0;\n        for (auto& c : s) {\n            if (isdigit(c)) {\n                sum_digit++;\n            }\n        }\n        int sum_alpha = s.size() - sum_digit;\n        if (abs(sum_digit - sum_alpha) > 1) {\n            return \"\";\n        }\n        bool flag = sum_digit > sum_alpha;\n        for (int i = 0, j = 1; i < s.size(); i += 2) {\n            if (isdigit(s[i]) != flag) {\n                while (isdigit(s[j]) != flag) {\n                    j += 2;\n                }\n                swap(s[i], s[j]);\n            }\n        }\n        return s;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String reformat(String s) {\n        int sumDigit = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (Character.isDigit(c)) {\n                sumDigit++;\n            }\n        }\n        int sumAlpha = s.length() - sumDigit;\n        if (Math.abs(sumDigit - sumAlpha) > 1) {\n            return \"\";\n        }\n        boolean flag = sumDigit > sumAlpha;\n        char[] arr = s.toCharArray();\n        for (int i = 0, j = 1; i < s.length(); i += 2) {\n            if (Character.isDigit(arr[i]) != flag) {\n                while (Character.isDigit(arr[j]) != flag) {\n                    j += 2;\n                }\n                swap(arr, i, j);\n            }\n        }\n        return new String(arr);\n    }\n\n    public void swap(char[] arr, int i, int j) {\n        char c = arr[i];\n        arr[i] = arr[j];\n        arr[j] = c;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string Reformat(string s) {\n        int sumDigit = 0;\n        foreach (char c in s) {\n            if (char.IsDigit(c)) {\n                sumDigit++;\n            }\n        }\n        int sumAlpha = s.Length - sumDigit;\n        if (Math.Abs(sumDigit - sumAlpha) > 1) {\n            return \"\";\n        }\n        bool flag = sumDigit > sumAlpha;\n        char[] arr = s.ToCharArray();\n        for (int i = 0, j = 1; i < s.Length; i += 2) {\n            if (char.IsDigit(arr[i]) != flag) {\n                while (char.IsDigit(arr[j]) != flag) {\n                    j += 2;\n                }\n                Swap(arr, i, j);\n            }\n        }\n        return new String(arr);\n    }\n\n    public void Swap(char[] arr, int i, int j) {\n        char c = arr[i];\n        arr[i] = arr[j];\n        arr[j] = c;\n    }\n}\n```\n\n```C [sol1-C]\nchar * reformat(char * s){\n    int sum_digit = 0;\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) {\n        char c = s[i];\n        if (isdigit(c)) {\n            sum_digit++;\n        }\n    }\n    int sum_alpha = len - sum_digit;\n    if (abs(sum_digit - sum_alpha) > 1) {\n        return \"\";\n    }\n    bool flag = sum_digit > sum_alpha;\n    for (int i = 0, j = 1; i < len; i += 2) {\n        if ((isdigit(s[i]) != 0) != flag) {\n            while ((isdigit(s[j]) != 0) != flag) {\n                j += 2;\n            }\n            char c = s[i];\n            s[i] = s[j];\n            s[j] = c;\n        }\n    }\n    return s;\n}\n```\n\n```go [sol1-Golang]\nfunc reformat(s string) string {\n    sumDigit := 0\n    for _, c := range s {\n        if unicode.IsDigit(c) {\n            sumDigit++\n        }\n    }\n    sumAlpha := len(s) - sumDigit\n    if abs(sumDigit-sumAlpha) > 1 {\n        return \"\"\n    }\n    flag := sumDigit > sumAlpha\n    t := []byte(s)\n    for i, j := 0, 1; i < len(t); i += 2 {\n        if unicode.IsDigit(rune(t[i])) != flag {\n            for unicode.IsDigit(rune(t[j])) != flag {\n                j += 2\n            }\n            t[i], t[j] = t[j], t[i]\n        }\n    }\n    return string(t)\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar reformat = function(s) {\n    let sumDigit = 0;\n    for (let i = 0; i < s.length; i++) {\n        const c = s[i];\n        if (isDigit(c)) {\n            sumDigit++;\n        }\n    }\n    let sumAlpha = s.length - sumDigit;\n    if (Math.abs(sumDigit - sumAlpha) > 1) {\n        return \"\";\n    }\n    let flag = sumDigit > sumAlpha;\n    const arr = [...s];\n    for (let i = 0, j = 1; i < s.length; i += 2) {\n        if (isDigit(arr[i]) !== flag) {\n            while (isDigit(arr[j]) !== flag) {\n                j += 2;\n            }\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n        }\n    }\n    return arr.join('');\n}\n\nconst isDigit = (ch) => {\n    return parseFloat(ch).toString() === \"NaN\" ? false : true;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为字符串 $s$ 的长度，需要遍历两遍字符串。\n- 空间复杂度：对于字符串可变的语言为 $O(1)$，仅使用常量空间。而对于字符串不可变的语言需要新建一个和 $s$ 等长的字符串，所以空间复杂度是 $O(n)$。"
}