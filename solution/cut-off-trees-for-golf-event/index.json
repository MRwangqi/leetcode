{
	"titleSlug": "cut-off-trees-for-golf-event",
	"slug": "wei-gao-er-fu-bi-sai-kan-shu-by-leetcode-rlrc",
	"url": "https://leetcode-cn.com/problems/cut-off-trees-for-golf-event/solution/wei-gao-er-fu-bi-sai-kan-shu-by-leetcode-rlrc/",
	"content": "#### 前言\n\n题目要求从 $(0, 0)$ 开始并按照树的高度大小进行砍树并求出最小步数，假设所有树按照从高度从小到大的排序顺序为 $t_1, t_2, t_3, t_4, \\cdots, t_n$，设 $d(x, y)$ 表示从 $x$ 到 $y$ 之间的步数，设 $t_0 = (0, 0)$ ，则可推出砍树的总的步数为 $\\textit{total} = \\sum_{i=0}^{n-1} d(t_i, t_i+1)$，若使得 $\\textit{total}$ 最小，只需满足所有的 $d(i, i+1)$ 都为最小，即可使得 $\\textit{total}$ 最小，该题即转为求相邻树的两点之间的最短距离。\n\n#### 方法一：广度优先搜索\n\n**思路与算法**\n\n首先对矩阵中的树按照树的高度进行排序，我们依次求出相邻的树之间的最短距离。利用广度优先搜索，按照层次遍历，处理队列中的节点（网格位置）。$\\textit{visited}$ 记录在某个时间点已经添加到队列中的节点，这些节点已被处理或在等待处理的队列中。对于下一个要处理的每个节点，查看他们的四个方向上相邻的点，如果相邻的点没有被遍历过且不是障碍，将其加入到队列中，直到找到终点为止，返回当前的步数即可。最终返回所有的步数之和即为最终结果。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def cutOffTree(self, forest: List[List[int]]) -> int:\n        def bfs(sx: int, sy: int, tx: int, ty: int) -> int:\n            m, n = len(forest), len(forest[0])\n            q = deque([(0, sx, sy)])\n            vis = {(sx, sy)}\n            while q:\n                d, x, y = q.popleft()\n                if x == tx and y == ty:\n                    return d\n                for nx, ny in ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)):\n                    if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] and (nx, ny) not in vis:\n                        vis.add((nx, ny))\n                        q.append((d + 1, nx, ny))\n            return -1\n\n        trees = sorted((h, i, j) for i, row in enumerate(forest) for j, h in enumerate(row) if h > 1)\n        ans = preI = preJ = 0\n        for _, i, j in trees:\n            d = bfs(preI, preJ, i, j)\n            if d < 0:\n                return -1\n            ans += d\n            preI, preJ = i, j\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    int bfs(vector<vector<int>>& forest, int sx, int sy, int tx, int ty) {\n        if (sx == tx && sy == ty) {\n            return 0;\n        }\n\n        int row = forest.size();\n        int col = forest[0].size();\n        int step = 0;\n        queue<pair<int, int>> qu;\n        vector<vector<bool>> visited(row, vector<bool>(col, false));         \n        qu.emplace(sx, sy);\n        visited[sx][sy] = true;\n        while (!qu.empty()) {\n            step++;\n            int sz = qu.size();\n            for (int i = 0; i < sz; ++i) {\n                auto [cx, cy] = qu.front();\n                qu.pop();\n                for (int j = 0; j < 4; ++j) {\n                    int nx = cx + dirs[j][0];\n                    int ny = cy + dirs[j][1];\n                    if (nx >= 0 && nx < row && ny >= 0 && ny < col) {\n                        if (!visited[nx][ny] && forest[nx][ny] > 0) {\n                            if (nx == tx && ny == ty) {\n                                return step;\n                            }\n                            qu.emplace(nx, ny);\n                            visited[nx][ny] = true;\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    int cutOffTree(vector<vector<int>>& forest) {\n        vector<pair<int, int>> trees;\n        int row = forest.size();\n        int col = forest[0].size();\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (forest[i][j] > 1) {\n                    trees.emplace_back(i, j);\n                }\n            }\n        }\n        sort(trees.begin(), trees.end(), [&](const pair<int, int> & a, const pair<int, int> & b) {\n            return forest[a.first][a.second] < forest[b.first][b.second];\n        });\n\n        int cx = 0;\n        int cy = 0;\n        int ans = 0;\n        for (int i = 0; i < trees.size(); ++i) {\n            int steps = bfs(forest, cx, cy, trees[i].first, trees[i].second);\n            if (steps == -1) {\n                return -1;\n            }\n            ans += steps;\n            cx = trees[i].first;\n            cy = trees[i].second;\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public int cutOffTree(List<List<Integer>> forest) {\n        List<int[]> trees = new ArrayList<int[]>();\n        int row = forest.size();\n        int col = forest.get(0).size();\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (forest.get(i).get(j) > 1) {\n                    trees.add(new int[]{i, j});\n                }\n            }\n        }\n        Collections.sort(trees, (a, b) -> forest.get(a[0]).get(a[1]) - forest.get(b[0]).get(b[1]));\n\n        int cx = 0;\n        int cy = 0;\n        int ans = 0;\n        for (int i = 0; i < trees.size(); ++i) {\n            int steps = bfs(forest, cx, cy, trees.get(i)[0], trees.get(i)[1]);\n            if (steps == -1) {\n                return -1;\n            }\n            ans += steps;\n            cx = trees.get(i)[0];\n            cy = trees.get(i)[1];\n        }\n        return ans;\n    }\n\n    public int bfs(List<List<Integer>> forest, int sx, int sy, int tx, int ty) {\n        if (sx == tx && sy == ty) {\n            return 0;\n        }\n\n        int row = forest.size();\n        int col = forest.get(0).size();\n        int step = 0;\n        Queue<int[]> queue = new ArrayDeque<int[]>();\n        boolean[][] visited = new boolean[row][col];\n        queue.offer(new int[]{sx, sy});\n        visited[sx][sy] = true;\n        while (!queue.isEmpty()) {\n            step++;\n            int sz = queue.size();\n            for (int i = 0; i < sz; ++i) {\n                int[] cell = queue.poll();\n                int cx = cell[0], cy = cell[1];\n                for (int j = 0; j < 4; ++j) {\n                    int nx = cx + dirs[j][0];\n                    int ny = cy + dirs[j][1];\n                    if (nx >= 0 && nx < row && ny >= 0 && ny < col) {\n                        if (!visited[nx][ny] && forest.get(nx).get(ny) > 0) {\n                            if (nx == tx && ny == ty) {\n                                return step;\n                            }\n                            queue.offer(new int[]{nx, ny});\n                            visited[nx][ny] = true;\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    int[][] dirs = {new int[]{-1, 0}, new int[]{1, 0}, new int[]{0, -1}, new int[]{0, 1}};\n\n    public int CutOffTree(IList<IList<int>> forest) {\n        List<Tuple<int, int>> trees = new List<Tuple<int, int>>();\n        int row = forest.Count;\n        int col = forest[0].Count;\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (forest[i][j] > 1) {\n                    trees.Add(new Tuple<int, int>(i, j));\n                }\n            }\n        }\n        trees.Sort((a, b) => forest[a.Item1][a.Item2] - forest[b.Item1][b.Item2]);\n\n        int cx = 0;\n        int cy = 0;\n        int ans = 0;\n        for (int i = 0; i < trees.Count; ++i) {\n            int steps = BFS(forest, cx, cy, trees[i].Item1, trees[i].Item2);\n            if (steps == -1) {\n                return -1;\n            }\n            ans += steps;\n            cx = trees[i].Item1;\n            cy = trees[i].Item2;\n        }\n        return ans;\n    }\n\n    public int BFS(IList<IList<int>> forest, int sx, int sy, int tx, int ty) {\n        if (sx == tx && sy == ty) {\n            return 0;\n        }\n\n        int row = forest.Count;\n        int col = forest[0].Count;\n        int step = 0;\n        Queue<Tuple<int, int>> queue = new Queue<Tuple<int, int>>();\n        bool[,] visited = new bool[row, col];\n        queue.Enqueue(new Tuple<int, int>(sx, sy));\n        visited[sx, sy] = true;\n        while (queue.Count > 0) {\n            step++;\n            int sz = queue.Count;\n            for (int i = 0; i < sz; ++i) {\n                Tuple<int, int> cell = queue.Dequeue();\n                int cx = cell.Item1, cy = cell.Item2;\n                for (int j = 0; j < 4; ++j) {\n                    int nx = cx + dirs[j][0];\n                    int ny = cy + dirs[j][1];\n                    if (nx >= 0 && nx < row && ny >= 0 && ny < col) {\n                        if (!visited[nx, ny] && forest[nx][ny] > 0) {\n                            if (nx == tx && ny == ty) {\n                                return step;\n                            }\n                            queue.Enqueue(new Tuple<int, int>(nx, ny));\n                            visited[nx, ny] = true;\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int x;\n    int y;\n    int height;\n} Tree;\n\nstatic int cmp(const void *pa, const void *pb) {\n    return ((Tree *)pa)->height - ((Tree *)pb)->height;\n}\n\nstatic int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nint bfs(const int **forest, int row, int col, int sx, int sy, int tx, int ty) {\n    if (sx == tx && sy == ty) {\n        return 0;\n    }\n\n    int step = 0;\n    int *queue = (int *)malloc(sizeof(int) * row * col);\n    int *visited = (int *)malloc(sizeof(int) * row * col);\n    int head = 0, tail = 0;\n    memset(visited, 0, sizeof(int) * row * col);\n    queue[tail++] = sx * col + sy;\n    visited[sx * col + sy] = true;\n    while (head != tail) {\n        step++;\n        int sz = tail - head;\n        for (int i = 0; i < sz; ++i) {\n            int cx = queue[head] / col;\n            int cy = queue[head] % col;\n            head++;\n            for (int j = 0; j < 4; ++j) {\n                int nx = cx + dirs[j][0];\n                int ny = cy + dirs[j][1];\n                if ( nx >= 0 && nx < row && ny >= 0 && ny < col) {\n                    if (!visited[nx * col + ny] && forest[nx][ny] > 0) {\n                        if (nx == tx && ny == ty) {\n                            free(queue);\n                            free(visited);\n                            return step;\n                        }\n                        queue[tail++] = nx * col + ny;\n                        visited[nx * col + ny] = true;\n                    }\n                }\n            }\n        }\n    }\n    free(queue);\n    free(visited);\n    return -1;\n}\n\nint cutOffTree(int** forest, int forestSize, int* forestColSize) {\n    int row = forestSize;\n    int col = forestColSize[0];\n    int treeSize = 0;\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < col; ++j) {\n            if (forest[i][j] > 1) {\n                treeSize++;\n            }\n        }\n    }\n    Tree * trees = (Tree *)malloc(sizeof(Tree) * treeSize);\n    int pos = 0;\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < col; ++j) {\n            if (forest[i][j] > 1) {\n                trees[pos].x = i;\n                trees[pos].y = j;\n                trees[pos].height = forest[i][j];\n                pos++;\n            }\n        }\n    }\n    qsort(trees, treeSize, sizeof(Tree), cmp);\n    int cx = 0;\n    int cy = 0;\n    int ans = 0;\n    for (int i = 0; i < treeSize; ++i) {\n        int steps = bfs(forest, row, col, cx, cy, trees[i].x, trees[i].y);\n        if (steps == -1) {\n            return -1;\n        }\n        ans += steps;\n        cx = trees[i].x;\n        cy = trees[i].y;\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\nvar cutOffTree = function(forest) {\n    const trees = [];\n    const row = forest.length;\n    const col = forest[0].length;\n    for (let i = 0; i < row; ++i) {\n        for (let j = 0; j < col; ++j) {\n            if (forest[i][j] > 1) {\n                trees.push([i, j]);\n            }\n        }\n    }\n    trees.sort((a, b) => forest[a[0]][a[1]] - forest[b[0]][b[1]]);\n\n    let cx = 0;\n    let cy = 0;\n    let ans = 0;\n    for (let i = 0; i < trees.length; ++i) {\n        let steps = bfs(forest, cx, cy, trees[i][0], trees[i][1]);\n        if (steps === -1) {\n            return -1;\n        }\n        ans += steps;\n        cx = trees[i][0];\n        cy = trees[i][1];\n    }\n    return ans;\n};\n\nconst bfs = (forest, sx, sy, tx, ty) => {\n    if (sx === tx && sy === ty) {\n        return 0;\n    }\n\n    const row = forest.length;\n    const col = forest[0].length;\n    let step = 0;\n    const queue = [];\n    const visited = new Array(row).fill(0).map(() => new Array(col).fill(0));\n    queue.push([sx, sy]);\n    visited[sx][sy] = true;\n    while (queue.length) {\n        step++;\n        const sz = queue.length;\n        for (let i = 0; i < sz; ++i) {\n            const cell = queue.shift();\n            const cx = cell[0], cy = cell[1];\n            for (let j = 0; j < 4; ++j) {\n                const nx = cx + dirs[j][0];\n                const ny = cy + dirs[j][1];\n                if (nx >= 0 && nx < row && ny >= 0 && ny < col) {\n                    if (!visited[nx][ny] && forest[nx][ny] > 0) {\n                        if (nx === tx && ny === ty) {\n                            return step;\n                        }\n                        queue.push([nx, ny]);\n                        visited[nx][ny] = true;\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n```\n\n```go [sol1-Golang]\nvar dir4 = []struct{ x, y int }{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\nfunc cutOffTree(forest [][]int) (ans int) {\n    type pair struct{ dis, x, y int }\n    trees := []pair{}\n    for i, row := range forest {\n        for j, h := range row {\n            if h > 1 {\n                trees = append(trees, pair{h, i, j})\n            }\n        }\n    }\n    sort.Slice(trees, func(i, j int) bool { return trees[i].dis < trees[j].dis })\n\n    bfs := func(sx, sy, tx, ty int) int {\n        m, n := len(forest), len(forest[0])\n        vis := make([][]bool, m)\n        for i := range vis {\n            vis[i] = make([]bool, n)\n        }\n        vis[sx][sy] = true\n        q := []pair{{0, sx, sy}}\n        for len(q) > 0 {\n            p := q[0]\n            q = q[1:]\n            if p.x == tx && p.y == ty {\n                return p.dis\n            }\n            for _, d := range dir4 {\n                if x, y := p.x+d.x, p.y+d.y; 0 <= x && x < m && 0 <= y && y < n && !vis[x][y] && forest[x][y] > 0 {\n                    vis[x][y] = true\n                    q = append(q, pair{p.dis + 1, x, y})\n                }\n            }\n        }\n        return -1\n    }\n\n    preX, preY := 0, 0\n    for _, t := range trees {\n        d := bfs(preX, preY, t.x, t.y)\n        if d < 0 {\n            return -1\n        }\n        ans += d\n        preX, preY = t.x, t.y\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(m^2 \\times n^2)$，其中 $m$ 为矩阵的行数，$n$ 为矩阵的列数。矩阵中最多有 $m \\times n$ 颗树，对树的高度进行排序，时间复杂度为 $O(m \\times n \\times \\log (m \\times n))$，利用广度优先搜索两颗树之间的最短距离需要的时间为 $O(m \\times n)$，因此总的时间复杂为 $O(m \\times n \\times \\log (m \\times n) + m^2 \\times n^2) = O(m^2 \\times n^2)$ 。\n\n+ 空间复杂度：$O(m \\times n)$，其中 $m$ 为矩阵的行数，$n$ 为矩阵的列数。矩阵中最多有 $m \\times n$ 颗树，对树的高度进行排序，所需要的栈空间为 $O(\\log (m \\times n))$，利用广度优先搜索队列中最多有 $O(m \\times n)$ 个元素，标记已遍历过的元素需要的空间为 $O(m \\times n)$，因此总的空间复杂度为 $O(m \\times n)$。\n\n#### 方法二：Dijkstra 算法\n\n**思路与算法**\n\n我们还可以利用 $\\texttt{Dijkstra}$ 算法求矩阵中两点的最短距离，$\\texttt{Dijkstra}$ 算法也是利用的广度优先搜索，不同的是，每次对队列中优先选择最短路径的元素。$\\textit{visited}$ 记录在某个时间点已经添加到队列中的节点，这些节点已被处理或在等待处理的队列中。每次从队列中取出当前从起点开始的最少步数的点，对于下一个要处理的每个节点，查看他们的四个方向上相邻的点，如果相邻的点没有被遍历过且不是障碍，将其加入到队列中，直到找到终点为止，返回当前的步数即可。最终返回所有的步数之和即为最终结果。\n使用该算法需要考虑的问题：由于题目中遇到障碍物无法通行的，因此当前选择的最短路径的节点并不是最优的，所以该解法在此题中性能不太好。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    int bfs(vector<vector<int>>& forest, int sx, int sy, int tx, int ty) {\n        if (sx == tx && sy == ty) {\n            return 0;\n        }\n\n        int row = forest.size();\n        int col = forest[0].size();\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        vector<vector<bool>> visited(row, vector<bool>(col, false));\n        pq.emplace(0, sx * col + sy);\n        visited[sx][sy] = true;\n        while (!pq.empty()) {\n            auto [dist, loc] = pq.top();\n            pq.pop();\n            for (int j = 0; j < 4; ++j) {\n                int nx = loc / col + dirs[j][0];\n                int ny = loc % col + dirs[j][1];\n                if (nx >= 0 && nx < row && ny >= 0 && ny < col) {\n                    if (!visited[nx][ny] && forest[nx][ny] > 0) {\n                        if (nx == tx && ny == ty) {\n                            return dist + 1;\n                        }\n                        pq.emplace(dist + 1, nx * col + ny);\n                        visited[nx][ny] = true;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    int cutOffTree(vector<vector<int>>& forest) {\n        vector<pair<int, int>> trees;\n        int row = forest.size();\n        int col = forest[0].size();\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (forest[i][j] > 1) {\n                    trees.emplace_back(i, j);\n                }\n            }\n        }\n        sort(trees.begin(), trees.end(), [&](const pair<int, int> & a, const pair<int, int> & b) {\n            return forest[a.first][a.second] < forest[b.first][b.second];\n        });\n        \n        int cx = 0;\n        int cy = 0;\n        int ans = 0;\n        for (int i = 0; i < trees.size(); ++i) {\n            int steps = bfs(forest, cx, cy, trees[i].first, trees[i].second);\n            if (steps == -1) {\n                return -1;\n            }\n            ans += steps;\n            cx = trees[i].first;\n            cy = trees[i].second;\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public int cutOffTree(List<List<Integer>> forest) {\n        List<int[]> trees = new ArrayList<int[]>();\n        int row = forest.size();\n        int col = forest.get(0).size();\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (forest.get(i).get(j) > 1) {\n                    trees.add(new int[]{i, j});\n                }\n            }\n        }\n        Collections.sort(trees, (a, b) -> forest.get(a[0]).get(a[1]) - forest.get(b[0]).get(b[1]));\n\n        int cx = 0;\n        int cy = 0;\n        int ans = 0;\n        for (int i = 0; i < trees.size(); ++i) {\n            int steps = bfs(forest, cx, cy, trees.get(i)[0], trees.get(i)[1]);\n            if (steps == -1) {\n                return -1;\n            }\n            ans += steps;\n            cx = trees.get(i)[0];\n            cy = trees.get(i)[1];\n        }\n        return ans;\n    }\n\n    public int bfs(List<List<Integer>> forest, int sx, int sy, int tx, int ty) {\n        if (sx == tx && sy == ty) {\n            return 0;\n        }\n\n        int row = forest.size();\n        int col = forest.get(0).size();\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\n        boolean[][] visited = new boolean[row][col];\n        pq.offer(new int[]{0, sx * col + sy});\n        visited[sx][sy] = true;\n        while (!pq.isEmpty()) {\n            int[] arr = pq.poll();\n            int dist = arr[0], loc = arr[1];\n            for (int j = 0; j < 4; ++j) {\n                int nx = loc / col + dirs[j][0];\n                int ny = loc % col + dirs[j][1];\n                if (nx >= 0 && nx < row && ny >= 0 && ny < col) {\n                    if (!visited[nx][ny] && forest.get(nx).get(ny) > 0) {\n                        if (nx == tx && ny == ty) {\n                            return dist + 1;\n                        }\n                        pq.offer(new int[]{dist + 1, nx * col + ny});\n                        visited[nx][ny] = true;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(m^2 \\times n^2 \\times \\log (m \\times n))$，其中 $m$ 为矩阵的行数，$n$ 为矩阵的列数。矩阵中最多有 $m \\times n$ 颗树，对树的高度进行排序，时间复杂度为 $O(m \\times n \\times \\log (m \\times n))$，利用 $\\texttt{Dijkstra}$ 求最短距离需要的时间为 $O(m \\times n \\times \\log (m \\times n))$，因此总的时间复杂为 $O(m \\times n \\times \\log (m \\times n) + m^2 \\times n^2 \\times \\log (m \\times n)) = O(m^2 \\times n^2 \\times \\log (m \\times n))$ 。\n\n+ 空间复杂度：$O(m \\times n)$，其中 $m$ 为矩阵的行数，$n$ 为矩阵的列数。矩阵中最多有 $m \\times n$ 颗树，对树的高度进行排序，所需要的栈空间为 $O(\\log (m \\times n))$，利用 $\\texttt{Dijkstra}$ 算法队列中最多有 $O(m \\times n)$ 个元素，标记已遍历过的元素需要的空间为 $O(m \\times n)$，因此总的空间复杂度为 $O(m \\times n)$。\n\n#### 方法三：A* 启发式搜索算法\n\n**思路与算法**\n\n「[$\\texttt{A*}$ 算法](https://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95)」算法是另一种路径查找算法。设当前搜索的起点为 $(\\textit{sx}, \\textit{sy})$，终点为 $(\\textit{tx}, \\textit{ty})$， 对于位置 $(x, y)$ 的每个节点，设 $\\texttt{A*}$ 的估算函数为 $f(x, y) = g(x, y) + h(x, y)$，其中 $g(x, y)$ 表示从起点 $(\\textit{sx}, \\textit{sy})$ 到 $(x, y)$ 的实际距离，评估函数 $h(x, y)$ 在此选择 $(x, y)$ 到 $(\\textit{tx}, \\textit{ty})$ 的曼哈顿距离。\n\n我们利用优先队列优先选择估算函数值最小的节点，实际上 $\\texttt{A*}$ 搜索是 $\\texttt{Dijkstra}$ 的一个特例，当评估函数的 $h(x, y) = 0$ 时，此时该算法即为 $\\texttt{Dijkstra}$ 搜索。\n\n**代码**\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    int bfs(vector<vector<int>>& forest, int sx, int sy, int tx, int ty) {\n        if (sx == tx && sy == ty) {\n            return 0;\n        }\n\n        int row = forest.size();\n        int col = forest[0].size();\n        vector<vector<int>> costed(row, vector<int>(col, INT_MAX));\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n        costed[sx][sy] = abs(sx - tx) + abs(sy - ty);\n        pq.emplace(costed[sx][sy], 0, sx * col + sy);\n        while (!pq.empty()) {\n            auto [cost, dist, loc] = pq.top();\n            pq.pop();\n            int cx = loc / col;\n            int cy = loc % col;\n            if (cx == tx && cy == ty) {\n                return dist;\n            }\n            for (int i = 0; i < 4; ++i) {\n                int nx = cx + dirs[i][0];\n                int ny = cy + dirs[i][1];\n                if (nx >= 0 && nx < row && ny >= 0 && ny < col && forest[nx][ny] > 0) {\n                    int ncost = dist + 1 + abs(nx - tx) + abs(ny - ty);\n                    if (ncost < costed[nx][ny]) {\n                        pq.emplace(ncost, dist + 1, nx * col + ny);\n                        costed[nx][ny] = ncost;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    int cutOffTree(vector<vector<int>>& forest) {\n        vector<pair<int, int>> trees;\n        int row = forest.size();\n        int col = forest[0].size();\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (forest[i][j] > 1) {\n                    trees.emplace_back(i, j);\n                }\n            }\n        }\n        sort(trees.begin(), trees.end(), [&](const pair<int, int> & a, const pair<int, int> & b) {\n            return forest[a.first][a.second] < forest[b.first][b.second];\n        });\n        \n        int cx = 0;\n        int cy = 0;\n        int ans = 0;\n        for (int i = 0; i < trees.size(); ++i) {\n            int steps = bfs(forest, cx, cy, trees[i].first, trees[i].second);\n            if (steps == -1) {\n                return -1;\n            }\n            ans += steps;\n            cx = trees[i].first;\n            cy = trees[i].second;\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public int cutOffTree(List<List<Integer>> forest) {\n        List<int[]> trees = new ArrayList<int[]>();\n        int row = forest.size();\n        int col = forest.get(0).size();\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                if (forest.get(i).get(j) > 1) {\n                    trees.add(new int[]{i, j});\n                }\n            }\n        }\n        Collections.sort(trees, (a, b) -> forest.get(a[0]).get(a[1]) - forest.get(b[0]).get(b[1]));\n\n        int cx = 0;\n        int cy = 0;\n        int ans = 0;\n        for (int i = 0; i < trees.size(); ++i) {\n            int steps = bfs(forest, cx, cy, trees.get(i)[0], trees.get(i)[1]);\n            if (steps == -1) {\n                return -1;\n            }\n            ans += steps;\n            cx = trees.get(i)[0];\n            cy = trees.get(i)[1];\n        }\n        return ans;\n    }\n\n    public int bfs(List<List<Integer>> forest, int sx, int sy, int tx, int ty) {\n        if (sx == tx && sy == ty) {\n            return 0;\n        }\n\n        int row = forest.size();\n        int col = forest.get(0).size();\n        int[][] costed = new int[row][col];\n        for (int i = 0; i < row; ++i) {\n            Arrays.fill(costed[i], Integer.MAX_VALUE);\n        }\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\n        costed[sx][sy] = Math.abs(sx - tx) + Math.abs(sy - ty);\n        pq.offer(new int[]{costed[sx][sy], 0, sx * col + sy});\n        while (!pq.isEmpty()) {\n            int[] arr = pq.poll();\n            int cost = arr[0], dist = arr[1], loc = arr[2];\n            int cx = loc / col;\n            int cy = loc % col;\n            if (cx == tx && cy == ty) {\n                return dist;\n            }\n            for (int i = 0; i < 4; ++i) {\n                int nx = cx + dirs[i][0];\n                int ny = cy + dirs[i][1];\n                if (nx >= 0 && nx < row && ny >= 0 && ny < col && forest.get(nx).get(ny) > 0) {\n                    int ncost = dist + 1 + Math.abs(nx - tx) + Math.abs(ny - ty);\n                    if (ncost < costed[nx][ny]) {\n                        pq.offer(new int[]{ncost, dist + 1, nx * col + ny});\n                        costed[nx][ny] = ncost;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n```\n\n**复杂度分析**\n\n启发式搜索不讨论时空复杂度。"
}