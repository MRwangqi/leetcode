{
	"titleSlug": "stone-game-vii",
	"slug": "cbo-yi-si-lu-xiang-jie-by-jiang-xian-sen-j2tj",
	"url": "https://leetcode-cn.com/problems/stone-game-vii/solution/cbo-yi-si-lu-xiang-jie-by-jiang-xian-sen-j2tj/",
	"content": "### 解题思路：\r\n1. 首先明确——谁是先手谁的得分就最大.\r\n2.  对于 `dp[i][j]` 定义为区间 `[i,j]` 我们要的结果，在区间 `[i, j]`，`dp[i][j]` = 先手的总分 - 后手的总分。\r\n3. 如果 `dp[i][j]`这个区间当前是鲍勃操作，那么鲍勃的得分一定最大。\r\n选择去掉 `stones[i]` 后当前的分数为 `sum(stones[i + 1], stones[j])`.\r\n那么区间 `[i + 1, j]`鲍勃的得分是多少呢？不用管它，`dp[i + 1][j]` 一定为对手爱丽丝作为先手得到的结果，因为谁先手谁的得分最大，则 `dp[i + 1][j]` = 爱丽丝得分 - 鲍勃的得分。\r\n`sum(stones[i + 1], stones[j]) - dp[i + 1][j] `\r\n= 鲍勃当前操作得分 - （爱丽丝的总分 - 鲍勃的总分）\r\n= 鲍勃当前操作得分 + 鲍勃的总分 - 爱丽丝的总分\r\n= 鲍勃新的总分 - 爱丽丝的总分  > 0（谁先手谁最大）。\r\n如果去掉 `stones[j]` 则原理同上.\r\n4. 如果当前 `dp[i][j]` 是爱丽丝，则将上面的叙述中爱丽丝和鲍勃名字互换。\r\n5. 对于爱丽丝我们很好理解为什么要最大化\r\n`dp[i][j] = max(sum(stones[i + 1], stones[j])  - dp[i + 1][j],   sum(stones[i], stones[j - 1]) - dp[i][j - 1])`;\r\n那么鲍勃为什么也要最大化 `dp[i][j]` 呢，因为爱丽丝先手，鲍勃必输，题目给出了。所以只有当鲍勃操作时 `dp[i][j]` 最大，才能让爱丽丝操作时得到的结果最小,满足鲍勃的野心\r\n爱丽丝当前操作得分 - (鲍勃的总分 - 爱丽丝的总分)(鲍勃操作时的最大化差值)\r\n6. 基础情况为只有 2 堆石子，值最大的那堆为答案，所以从只有2堆石子开始往上进行状态转移。\r\n### 代码：\r\n```C++ []\r\nclass Solution {\r\npublic:\r\n    int stoneGameVII(vector<int>& stones) {\r\n        vector<vector<int>>dp(stones.size(), vector<int>(stones.size(),0));\r\n        vector<int>sums(stones.size() + 1, 0);\r\n        for(int i = 0;i < stones.size();++i)\r\n            sums[i + 1] = sums[i] + stones[i];\r\n        for(int i = dp.size() - 2;i >= 0;--i){\r\n            for(int j = i + 1;j < dp[i].size();++j)\r\n                dp[i][j] = max(sums[j + 1] - sums[i + 1] - dp[i + 1][j], sums[j] - sums[i] - dp[i][j - 1]);\r\n        }\r\n        return dp.front().back();\r\n    }\r\n};\r\n```\r\n"
}