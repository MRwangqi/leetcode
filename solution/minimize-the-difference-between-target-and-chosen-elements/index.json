{
	"titleSlug": "minimize-the-difference-between-target-and-chosen-elements",
	"slug": "by-np_prob-kin1",
	"url": "https://leetcode-cn.com/problems/minimize-the-difference-between-target-and-chosen-elements/solution/by-np_prob-kin1/",
	"content": "截至发题解时这种方案是Python解法中最快的了。\r\n\r\n```\r\n执行用时：76 ms, 在所有 Python3 提交中击败了100.00%的用户\r\n内存消耗：17.8 MB, 在所有 Python3 提交中击败了16.67%的用户\r\n```\r\n\r\n随便翻了一下，好像没有看到用这种方法的。\r\n我的思路是，先计算最小前缀和以及最大前缀和，也就是前i行每行取一个数最小可能总和以及最大可能总和分别是多少。\r\n接下来我们按行倒序查找，先在cur行选一个数num，用target减去num之后得到的是就是前面cur-1行的目标和。\r\n每次如果当前的target已经比前cur行的最小前缀和都要小了，则继续向更小的行数查找已无必要，同理，如果当前的target已经比前cur行最大前缀和都要大了，则继续向更小的行数查找也无必要了。\r\n用一个visited集合记录已经查找过的(cur, target)对，重复的即可不再搜索。\r\n另一方面，一旦中途发现最小绝对差已经达到0，则无法再优化了，直接return。\r\n\r\n\r\n```python []\r\nclass Solution:\r\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\r\n        m, n = len(mat), len(mat[0])\r\n        pre_sum = [[0, 0] for _ in range(m + 1)]\r\n        for i in range(m):\r\n            pre_sum[i + 1][0] = pre_sum[i][0] + min(mat[i])\r\n            pre_sum[i + 1][1] = pre_sum[i][1] + max(mat[i])\r\n\r\n        if pre_sum[-1][0] >= target:\r\n            return pre_sum[-1][0] - target\r\n        if pre_sum[-1][1] <= target:\r\n            return target - pre_sum[-1][1]\r\n\r\n        ans = pre_sum[-1][1]\r\n        visited = set()\r\n\r\n        def dfs(cur, tar):\r\n            nonlocal ans\r\n            if pre_sum[cur][0] >= tar:\r\n                ans = min(ans, pre_sum[cur][0] - tar)\r\n                return\r\n            if pre_sum[cur][1] <= tar:\r\n                ans = min(ans, tar - pre_sum[cur][1])\r\n                return\r\n            if cur == 0:\r\n                ans = min(ans, tar)\r\n                return\r\n            for num in set(mat[cur - 1]):\r\n                pair = (cur - 1, tar - num)\r\n                if pair not in visited:\r\n                    visited.add(pair)\r\n                    dfs(pair[0], pair[1])\r\n                    if ans == 0:\r\n                        return\r\n\r\n        dfs(m, target)\r\n        return ans\r\n\r\n```\r\n\r\n嘛，用@cache也可以嘛\r\n\r\n\r\n```python []\r\nclass Solution:\r\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\r\n        m, n = len(mat), len(mat[0])\r\n        pre_sum = [[0, 0] for _ in range(m + 1)]\r\n        for i in range(m):\r\n            pre_sum[i + 1][0] = pre_sum[i][0] + min(mat[i])\r\n            pre_sum[i + 1][1] = pre_sum[i][1] + max(mat[i])\r\n\r\n        if pre_sum[-1][0] >= target:\r\n            return pre_sum[-1][0] - target\r\n        if pre_sum[-1][1] <= target:\r\n            return target - pre_sum[-1][1]\r\n\r\n        ans = pre_sum[-1][1]\r\n\r\n        @lru_cache(None)\r\n        def dfs(cur, tar):\r\n            nonlocal ans\r\n            if pre_sum[cur][0] >= tar:\r\n                ans = min(ans, pre_sum[cur][0] - tar)\r\n                return\r\n            if pre_sum[cur][1] <= tar:\r\n                ans = min(ans, tar - pre_sum[cur][1])\r\n                return\r\n            if cur == 0:\r\n                ans = min(ans, tar)\r\n                return\r\n            for num in set(mat[cur - 1]):\r\n                pair = (cur - 1, tar - num)\r\n                dfs(pair[0], pair[1])\r\n                if ans == 0:\r\n                    return\r\n\r\n        dfs(m, target)\r\n        return ans\r\n\r\n```\r\n\r\n\r\n"
}