{
	"titleSlug": "sum-of-number-and-its-reverse",
	"slug": "ji-yi-hua-sou-suo-geng-da-shu-ju-fan-wei-xyer",
	"url": "https://leetcode-cn.com/problems/sum-of-number-and-its-reverse/solution/ji-yi-hua-sou-suo-geng-da-shu-ju-fan-wei-xyer/",
	"content": "**问题定义**\r\n\r\n定义 $f(i, j, pre, suf)$ 为在满足下列条件的情况下，数字 $N$ 中的子数字序列 $N[i..j]$ （下标从 $0$ 开始）是否可以由两个互为逆序的数字 $K$，$reverse(K)$ 相加而来，其中：\r\n\r\n- 如果 $pre = 1$，表示相加的结果需要向左侧进一位，进位完成之后剩下的结果和 $N[i...j]$ 相同；\r\n\r\n- 如果 $suf = 1$，表示在两数相加之前，已经有从低位传来的进位，相加结果需要把这个进位考虑进去。\r\n\r\n举例说明：对于数字 $12345$，$f(1,3,1,1)$ 表示，是否能找到三位数 $k$ ，使得 $k + erverse(k) +$ 进位的 $1$ = $1234$（去掉向高位进位的 $1$，剩下的结果和 $num[1...3] = 234$ 相同）。（注意下标从 $0$ 开始）\r\n\r\n**求解代码**\r\n先上代码，解释附后。\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool sumOfNumberAndReverse(int num) {\r\n        string s = to_string(num);\r\n        int n = s.size();\r\n\r\n        auto f = [&](int i, int j, int pre, int suf) -> bool {\r\n            while(i < j) {\r\n                // 这时首位的实际需求值，如果需要进位，就是首位数字+10，否则不加10\r\n                int head = pre * 10 + (s[i] - '0');\r\n\r\n                // K_i + K_j == head\r\n                if(head <= 18 && (head + suf) % 10 == s[j] - '0')\r\n                    i++, j--, pre = 0, suf = (head + suf) / 10;\r\n\r\n                // K_i + K_j == head - 1\r\n                else if(head > (i == 0? 1 : 0) && (head - 1 + suf) % 10 == s[j] - '0')\r\n                    i++, j--, pre = 1, suf = (head - 1 + suf) / 10;\r\n\r\n                else\r\n                    return false;\r\n            }\r\n            return (i == j && (s[i] & 1) == suf) || (i > j && pre == suf);\r\n        };\r\n\r\n        return f(0, n-1, 0, 0) || (s[0] == '1' && f(1, n-1, 1, 0));\r\n    }\r\n};\r\n```\r\n\r\n**求解过程解释**\r\n我们把目标数字序列 $N[i...j]$ 记作 $N_iN_{i+1}...N_{j}$，把 $K$ 记作 $K_iK_{i+1}...K_{j}$。\r\n\r\n当 $i < j$ 时：\r\n\r\n- 首先求出 $K + reverse(K)$ 的首位目标值 $head$。如果需要进位，那么 $head = 10 + N_i$；否则 $head = N_i$。\r\n- 在不考虑进位的情况下，$K + reverse(K)$ 的首位、末位均为 $K_i + K_j$。此时不妨把 $K_i + K_j$ 当作一个整体来看待。\r\n- 为了让 $K + reverse(K)$ 的首位（加上从中间部分而来的进位）和目标值 $head$ 相同，$K_i + K_j$ 只有两个可能取到的值：$head$ 和 $head - 1$，分别对应着中间部分进位为 $0$ 和 $1$ 的情况。\r\n- $K_i + K_j$ 能取到 $head$ 的条件是：\r\n  - $head \\le 18$，因为  $K_i + K_j$ 最大可以取到 $18$；\r\n  - $(head + suf) \\mod 10 = N_j$，也就是当 $K_i + K_j$ 取到 $head$ 时，$K + reverse(K)$ 的末位数字和 $N$ 的末位相同；\r\n  - 此时，只要 $f(i + 1, j-1, 0, (head + suf) / 10)$ 成立，也就是中间的数字可以在不向左进位的情况下，能表示成两个镜像数字的和，那么就找到了一个合法的解。（注意中间部分仍有可能接收右侧进位，$(head + suf) / 10$ 求的就是右侧进位的值）。\r\n- $K_i + K_j$ 能取到 $head - 1$ 的条件是： \r\n  - $\\displaystyle{head > \\left \\{ \\begin{aligned} 1, i = 0 \\\\ 0, i > 0 \\end{aligned} \\right. }$，因为当 $i > 0$ 时， $K_i + K_j$ 最小可以取到 $0$；当 $i=0$ 时，$K_i + K_j$ 不能取到 $0$，否则会导致 $K$ 和 $reverse(K)$ 的首、末位均为 $0$，不合题意（比如 $100=050+050$ 不是对整数 $100$ 的一个合法分解）。\r\n  - $(head - 1 + suf) \\mod 10 = N_j$，也就是当 $K_i + K_j$ 取到 $head - 1$ 时，$K + reverse(K)$ 的末位数字和 $N$ 的末位相同；\r\n  - 此时，只要 $f(i + 1, j - 1, 1, (head - 1 + suf) / 10)$ 成立，也就是中间的数字可以在需要向左进位的情况下，能表示成两个镜像数字的和，那么就找到了一个合法的解。（注意中间部分仍有可能接收右侧进位）\r\n- 可以发现，条件 $(head + suf) \\mod 10 = N_j$ 和 $(head - 1 + suf) \\mod 10 = N_j$ 无法同时满足，因此实际上对于一个具体的问题 $f(i, j, pre, suf)$，其转化为子问题的合法路径条数最多只有 $1$ 条，可以用双指针收缩代替真正的递归函数。\r\n- 如果 $f(i, j, pre, suf)$ 无法转化为子问题，返回 $false$。\r\n\r\n当 $i = j$ 时：\r\n\r\n- 由于一位数字取反后仍然加到自身，故每次只能 $+2$，无法改变奇偶性，因此目标数字的对应位的奇偶性需要和 $down$，也就是从低位进位的奇偶性相同。\r\n\r\n当 $i > j$ 时：\r\n\r\n- 为空字符串，需要 $pre$ 和 $suf$ 相同（进位需求和进位供给平衡）。\r\n\r\n**特殊情况**\r\n\r\n- 如果数字的 $N$ 的首位是 $1$，那么它还可能由 $n-1$ 位数字与逆序数相加、进位而来，此时可以调用 $f(1,n-1,1,0)$ 再判一次。\r\n\r\n**时间复杂度**\r\n\r\n$O(m)$，$m = log(N)$ 为数字的位数。\r\n\r\n"
}