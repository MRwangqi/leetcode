{
	"titleSlug": "word-rectangle-lcci",
	"slug": "-by-lucian-6-azl3",
	"url": "https://leetcode-cn.com/problems/word-rectangle-lcci/solution/-by-lucian-6-azl3/",
	"content": "刚开始看到这个题目，觉得字典树+暴力DFS过不了，看着时间复杂度会超时。思路还是很好理解的\n**思路：**\n1.如何判断字符串是否能够组成矩形\n2.如何保存能够组成矩形的字符串，并进行是否最大的判断\n**方法：**\n1.用字典树判断当前字符串的字符结点是否为字典树的结点\n2.判断当前字符串所有结点是否都为字典树的叶子结点，如果是，则能组成矩形，并进行是否最大的判断\n\n```\nclass Solution {\n    class Trie{\n        boolean isEnd = false;\n        Trie[] child = new Trie[26];\n    }\n    void add(String s){\n        Trie cur = root;\n        for(char c : s.toCharArray()){\n            int n = c - 'a';\n            if(cur.child[n] == null) cur.child[n] = new Trie();\n            cur = cur.child[n];\n        }\n        cur.isEnd = true;\n    }\n    Trie root;\n    //用max保存当前最大矩形面积\n    int max = -1;\n    //用哈希表保存各个长度字符串的集合\n    Map<Integer, List<String>> map = new HashMap<>();\n    List<String> ans = new ArrayList<>();\n    public String[] maxRectangle(String[] words) {\n        this.root = new Trie();\n        int n = words.length;\n        for(String w : words){\n            add(w);\n            map.computeIfAbsent(w.length(), k -> new ArrayList<>()).add(w);\n        }\n        //按照字符串长度从大到小排序\n        Arrays.sort(words, (a, b) -> b.length() - a.length());\n        for(int i = 0; i < n; i++){\n            Trie cur = root;\n            String w = words[i];\n            //用curList保存矩形的每个字符串\n            List<String> curList = new ArrayList<>();\n            curList.add(w);\n            //用list保存当前可能形成矩形的字符串在字典树中的当前结点\n            List<Trie> list = new ArrayList<>();\n            int len = w.length();\n            //如果当前长度的积不大于最大矩形面积，则退出\n            //因为从最大到最小排序，其中4 * 3的字符串矩阵和3 * 4的矩阵是相同的，可以进行去重\n            if(len * len <= max) break;\n            //check检测是否能组成矩形，flag检测是否可能组成更大的矩形\n            boolean check = true, flag = true;\n            for(int j = 0; j < len; j++){\n                int c = w.charAt(j) - 'a';\n                if(cur.child[c] != null){\n                    //判断当前字符串是否所有结点都为叶结点，即能组成字符串\n                    if(!cur.child[c].isEnd) check = false;\n                    list.add(cur.child[c]);\n                }else{\n                    //如果字符串没有对应子结点，则无法组成矩形\n                    check = false;\n                    flag = false;\n                    break;\n                }\n            }\n            //如果当前字符串可以组成矩形，则进入dfs\n            if(flag){\n                dfs(1, len, curList, list);\n            }\n            //如果当前字符串所有结点都可以为叶结点，则判断当前矩形是否最大\n            if(check && max == -1){\n                max = len;\n                ans = curList;\n            }\n        }\n        int size = ans.size();\n        String[] strs = new String[size];\n        for(int i = 0; i < size; i++) strs[i] = ans.get(i);\n        // System.out.println(max);\n        return strs;\n    }\n    void dfs(int cur, int len, List<String> curList, List<Trie> list){\n        if(cur == len){\n            return;\n        }\n        //各种结点判断同上\n        for(String w : map.get(len)){\n            boolean check = true, flag = true;\n            //其中next保存下一个可能形成矩形的字典树结点集合\n            List<Trie> next = new ArrayList<>();\n            //nextList保存下一个可能形成矩形的字符串集合\n            List<String> nextList = new ArrayList<>();\n            for(int i = 0; i < len; i++){\n                int c = w.charAt(i) - 'a';\n                Trie ct = list.get(i);\n                if(ct.child[c] != null){\n                    if(!ct.child[c].isEnd) check = false;\n                    next.add(ct.child[c]);\n                }else{\n                    check = false;\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                // System.out.println(w);\n                nextList.addAll(curList);\n                nextList.add(w);\n                dfs(cur + 1, len, nextList, next);\n            }\n            if(check && len * (cur + 1) > max){\n                max = len * (cur + 1);\n                ans = nextList;\n            }\n        }\n    }\n}\n```\n"
}