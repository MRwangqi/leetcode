{
	"titleSlug": "delete-the-middle-node-of-a-linked-list",
	"slug": "shan-chu-lian-biao-de-zhong-jian-jie-dia-yvv7",
	"url": "https://leetcode-cn.com/problems/delete-the-middle-node-of-a-linked-list/solution/shan-chu-lian-biao-de-zhong-jian-jie-dia-yvv7/",
	"content": "#### 方法一：快慢指针\n\n**思路与算法**\n\n由于链表不支持随机访问，因此常见的找出链表中间节点的方法是使用快慢指针：即我们使用两个指针 $\\textit{fast}$ 和 $\\textit{slow}$ 对链表进行遍历，其中快指针 $\\textit{fast}$ 每次遍历两个元素，慢指针 $\\textit{slow}$ 每次遍历一个元素。这样在快指针遍历完链表时，慢指针就恰好在链表的中间位置。\n\n在本题中，我们还需要删除链表的中间节点，因此除了慢指针 $\\textit{slow}$ 外，我们再使用一个指针 $\\textit{pre}$ 时刻指向 $\\textit{slow}$ 的前一个节点。这样我们就可以在遍历结束后，通过 $\\textit{pre}$ 将 $\\textit{slow}$ 删除了。\n\n**细节**\n\n当链表中只有一个节点时，我们会删除这个节点并返回空链表。但这个节点不存在前一个节点，即 $\\textit{pre}$ 是没有意义的，因此对于这种情况，我们可以在遍历前进行特殊判断，直接返回空指针作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    ListNode* deleteMiddle(ListNode* head) {\n        if (head->next == nullptr) {\n            return nullptr;\n        }\n        \n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* pre = nullptr;\n        while (fast && fast->next) {\n            fast = fast->next->next;\n            pre = slow;\n            slow = slow->next;\n        }\n        pre->next = pre->next->next;\n        return head;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.next is None:\n            return None\n        \n        slow, fast, pre = head, head, None\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        \n        pre.next = pre.next.next\n        return head\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。\n\n- 空间复杂度：$O(1)$。"
}