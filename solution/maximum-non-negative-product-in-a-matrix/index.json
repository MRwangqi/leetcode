{
	"titleSlug": "maximum-non-negative-product-in-a-matrix",
	"slug": "ju-zhen-de-zui-da-fei-fu-ji-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix/solution/ju-zhen-de-zui-da-fei-fu-ji-by-leetcode-solution/",
	"content": "#### 方法一：动态规划\n\n**思路与算法**\n\n由于矩阵中的元素有正有负，要想得到最大积，我们只存储移动过程中的最大积是不够的，例如当前的最大积为正数时，乘上一个负数后，反而不如一个负数乘上相同的负数得到的积大。\n\n因此，我们需要存储的是移动过程中的积的**范围**，也就是积的**最小值**以及**最大值**。由于只能向下或者向右走，我们可以考虑使用动态规划的方法解决本题。\n\n设 $\\textit{maxgt}[i][j], \\textit{minlt}[i][j]$ 分别为从坐标 $(0, 0)$ 出发，到达位置 $(i, j)$ 时乘积的最大值与最小值。由于我们只能向下或者向右走，因此乘积的取值必然只与 $(i, j-1)$ 和 $(i-1, j)$ 两个位置有关。\n\n对于乘积的最大值而言：若 $\\textit{grid}[i][j] \\ge 0$，则 $\\textit{maxgt}[i][j]$ 的取值取决于这两个位置的最大值，此时\n\n$$\n\\textit{maxgt}[i][j] = \\max(\\textit{maxgt}[i][j-1], \\textit{maxgt}[i-1][j]) \\times \\textit{grid}[i][j]\n$$\n\n相反地，若 $\\textit{grid}[i][j] \\le 0$，则 $\\textit{maxgt}[i][j]$ 的取值取决于这两个位置的最小值，此时\n\n$$\n\\textit{maxgt}[i][j] = \\min(\\textit{minlt}[i][j-1], \\textit{minlt}[i-1][j]) \\times \\textit{grid}[i][j]\n$$\n\n计算乘积的最小值也是类似的思路。若 $\\textit{grid}[i][j] \\ge 0$，此时\n\n$$\n\\textit{mingt}[i][j] = \\min(\\textit{mingt}[i][j-1], \\textit{mingt}[i-1][j]) \\times \\textit{grid}[i][j]\n$$\n\n若 $\\textit{grid}[i][j] \\le 0$，此时\n\n$$\n\\textit{mingt}[i][j] = \\max(\\textit{maxgt}[i][j-1], \\textit{maxgt}[i-1][j]) \\times \\textit{grid}[i][j]\n$$\n\n特别地，当 $i=0$ 时，只需要从 $(i, j-1)$ 进行转移；$j=0$ 时，只需要从 $(i-1, j)$ 进行转移；$i=0$ 且 $j=0$ 时，$\\textit{maxgt}[i][j]$ 与 $\\textit{mingt}[i][j]$ 的值均为左上角的元素值 $\\textit{grid}[i][j]$。\n\n最终的答案即为 $\\textit{maxgt}[m-1][n-1]$，其中 $m$ 和 $n$ 分别是矩阵的行数与列数。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxProductPath(vector<vector<int>>& grid) {\n        const int mod = 1000000000 + 7;\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<long long>> maxgt(m, vector<long long>(n));\n        vector<vector<long long>> minlt(m, vector<long long>(n));\n\n        maxgt[0][0] = minlt[0][0] = grid[0][0];\n        for (int i = 1; i < n; i++) {\n            maxgt[0][i] = minlt[0][i] = maxgt[0][i - 1] * grid[0][i];\n        }\n        for (int i = 1; i < m; i++) {\n            maxgt[i][0] = minlt[i][0] = maxgt[i - 1][0] * grid[i][0];\n        }\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (grid[i][j] >= 0) {\n                    maxgt[i][j] = max(maxgt[i][j - 1], maxgt[i - 1][j]) * grid[i][j];\n                    minlt[i][j] = min(minlt[i][j - 1], minlt[i - 1][j]) * grid[i][j];\n                } else {\n                    maxgt[i][j] = min(minlt[i][j - 1], minlt[i - 1][j]) * grid[i][j];\n                    minlt[i][j] = max(maxgt[i][j - 1], maxgt[i - 1][j]) * grid[i][j];\n                }\n            }\n        }\n        if (maxgt[m - 1][n - 1] < 0) {\n            return -1;\n        } else {\n            return maxgt[m - 1][n - 1] % mod;\n        }\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maxProductPath(int[][] grid) {\n        final int MOD = 1000000000 + 7;\n        int m = grid.length, n = grid[0].length;\n        long[][] maxgt = new long[m][n];\n        long[][] minlt = new long[m][n];\n\n        maxgt[0][0] = minlt[0][0] = grid[0][0];\n        for (int i = 1; i < n; i++) {\n            maxgt[0][i] = minlt[0][i] = maxgt[0][i - 1] * grid[0][i];\n        }\n        for (int i = 1; i < m; i++) {\n            maxgt[i][0] = minlt[i][0] = maxgt[i - 1][0] * grid[i][0];\n        }\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (grid[i][j] >= 0) {\n                    maxgt[i][j] = Math.max(maxgt[i][j - 1], maxgt[i - 1][j]) * grid[i][j];\n                    minlt[i][j] = Math.min(minlt[i][j - 1], minlt[i - 1][j]) * grid[i][j];\n                } else {\n                    maxgt[i][j] = Math.min(minlt[i][j - 1], minlt[i - 1][j]) * grid[i][j];\n                    minlt[i][j] = Math.max(maxgt[i][j - 1], maxgt[i - 1][j]) * grid[i][j];\n                }\n            }\n        }\n        if (maxgt[m - 1][n - 1] < 0) {\n            return -1;\n        } else {\n            return (int) (maxgt[m - 1][n - 1] % MOD);\n        }\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxProductPath(self, grid: List[List[int]]) -> int:\n        mod = 10**9 + 7\n        m, n = len(grid), len(grid[0])\n        maxgt = [[0] * n for _ in range(m)]\n        minlt = [[0] * n for _ in range(m)]\n\n        maxgt[0][0] = minlt[0][0] = grid[0][0]\n        for i in range(1, n):\n            maxgt[0][i] = minlt[0][i] = maxgt[0][i - 1] * grid[0][i]\n        for i in range(1, m):\n            maxgt[i][0] = minlt[i][0] = maxgt[i - 1][0] * grid[i][0]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if grid[i][j] >= 0:\n                    maxgt[i][j] = max(maxgt[i][j - 1], maxgt[i - 1][j]) * grid[i][j]\n                    minlt[i][j] = min(minlt[i][j - 1], minlt[i - 1][j]) * grid[i][j]\n                else:\n                    maxgt[i][j] = min(minlt[i][j - 1], minlt[i - 1][j]) * grid[i][j]\n                    minlt[i][j] = max(maxgt[i][j - 1], maxgt[i - 1][j]) * grid[i][j]\n        \n        if maxgt[m - 1][n - 1] < 0:\n            return -1\n        return maxgt[m - 1][n - 1] % mod\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 为矩阵的行数与列数。我们需要遍历矩阵的每一个元素，而处理每个元素时只需要常数时间。\n\n- 空间复杂度：$O(mn)$。我们开辟了两个与原矩阵等大的数组。"
}