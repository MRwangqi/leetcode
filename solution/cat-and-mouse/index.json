{
	"titleSlug": "cat-and-mouse",
	"slug": "mao-he-lao-shu-by-leetcode-solution-444x",
	"url": "https://leetcode-cn.com/problems/cat-and-mouse/solution/mao-he-lao-shu-by-leetcode-solution-444x/",
	"content": "#### 前言\n\n**博弈知识介绍**\n\n这道题是博弈问题，猫和老鼠都按照最优策略参与游戏。\n\n在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。\n\n1. 对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。\n\n   - 如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。\n\n   - 如果是平局，则该特定状态对于双方都为必和状态。\n\n2. 从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。\n\n3. 从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。\n\n4. 从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。\n\n对于每个玩家，最优策略如下：\n\n1. 争取将必胜状态留给自己，将必败状态留给对方玩家。\n\n2. 在自己无法到达必胜状态的情况下，争取将必和状态留给自己。\n\n**自顶向下动态规划解法介绍**\n\n博弈问题通常可以使用动态规划求解。这道题由于数据规模的原因，动态规划方法不适用，因此只是介绍。\n\n使用三维数组 $\\textit{dp}$ 表示状态，$\\textit{dp}[\\textit{mouse}][\\textit{cat}][\\textit{turns}]$ 表示从老鼠位于节点 $\\textit{mouse}$、猫位于节点 $\\textit{cat}$、游戏已经进行了 $\\textit{turns}$ 轮的状态开始，猫和老鼠都按照最优策略的情况下的游戏结果。假设图中的节点数是 $n$，则有 $0 \\le \\textit{mouse}, \\textit{cat} < n$。\n\n由于游戏的初始状态是老鼠位于节点 $1$，猫位于节点 $2$，因此 $\\textit{dp}[1][2][0]$ 为从初始状态开始的游戏结果。\n\n动态规划的边界条件为可以直接得到游戏结果的状态，包括以下三种状态：\n\n- 如果 $\\textit{mouse} = 0$，老鼠躲入洞里，则老鼠获胜，因此对于任意 $\\textit{cat}$ 和 $\\textit{turns}$ 都有 $\\textit{dp}[0][\\textit{cat}][\\textit{turns}] = 1$，该状态为老鼠的必胜状态，猫的必败状态。\n\n- 如果 $\\textit{cat} = \\textit{mouse}$，猫和老鼠占据相同的节点，则猫获胜，因此当 $\\textit{cat} = \\textit{mouse}$ 时，对于任意 $\\textit{mouse}$、$\\textit{cat}$ 和 $\\textit{turns}$ 都有 $\\textit{dp}[\\textit{mouse}][\\textit{cat}][\\textit{turns}] = 2$，该状态为老鼠的必败状态，猫的必胜状态。注意猫不能移动到节点 $0$，因此当 $\\textit{mouse} = 0$ 时，一定有 $\\textit{cat} \\ne \\textit{mouse}$。\n\n- 如果 $\\textit{turns} \\ge 2n(n - 1)$，则是平局，该状态为双方的必和状态。\n\n   > 由于游戏中的每个局面由老鼠的位置、猫的位置和轮到移动的一方三个因素确定，老鼠可能的位置数是 $n$，因此猫可能的位置数是 $n - 1$（由于猫不能移动到节点 $0$），轮到移动的一方有 $2$ 种可能，因此游戏中所有可能的局面数是 $2n(n - 1)$。\n   >\n   > 根据抽屉原理可知，当游戏进行了 $2n(n - 1)$ 轮时，一定存在至少一个猫和老鼠重复经过的局面。由于猫和老鼠都按照最优策略参与游戏，对于同一个局面，游戏结果是相同的。\n   >\n   > 考虑该重复经过的局面。从该局面开始，双方按照最优策略移动，结果只能回到该局面，任何一方都无法让己方到达必胜状态，让对方到达必败状态，因此该状态对于双方都不是必胜状态，只能是必和状态。\n   >\n   > 如果该重复经过的局面和初始局面相同，则初始局面即为双方的必和状态。如果该重复经过的局面和初始局面不同，则从初始局面开始，双方按照最优策略移动，结果只能到达双方的必和状态，任何一方都无法让己方到达必胜状态，让对方到达必败状态，因此初始局面对于双方都不是必胜状态，只能是必和状态。\n   >\n   > 综上所述，如果游戏进行了 $2n(n - 1)$ 轮还没有任何一方获胜，则是平局。\n\n动态规划的状态转移需要考虑当前玩家所有可能的移动，选择最优策略的移动。\n\n由于老鼠先开始移动，猫后开始移动，因此可以根据游戏已经进行的轮数 $\\textit{turns}$ 的奇偶性决定当前轮到的玩家，当 $\\textit{turns}$ 是偶数时轮到老鼠移动，当 $\\textit{turns}$ 是奇数时轮到猫移动。\n\n如果轮到老鼠移动，则对于老鼠从当前节点移动一次之后可能到达的每个节点，进行如下操作：\n\n1. 如果存在一个节点，老鼠到达该节点之后，老鼠可以获胜，则老鼠到达该节点之后的状态为老鼠的必胜状态，猫的必败状态，因此在老鼠移动之前的当前状态为老鼠的必胜状态。\n\n2. 如果老鼠到达任何节点之后的状态都不是老鼠的必胜状态，但是存在一个节点，老鼠到达该节点之后，结果是平局，则老鼠到达该节点之后的状态为双方的必和状态，因此在老鼠移动之前的当前状态为双方的必和状态。\n\n3. 如果老鼠到达任何节点之后的状态都不是老鼠的必胜状态或必和状态，则老鼠到达任何节点之后的状态都为老鼠的必败状态，猫的必胜状态，因此在老鼠移动之前的当前状态为老鼠的必败状态。\n\n如果轮到猫移动，则对于猫从当前节点移动一次之后可能到达的每个节点，进行如下操作：\n\n1. 如果存在一个节点，猫到达该节点之后，猫可以获胜，则猫到达该节点之后的状态为猫的必胜状态，老鼠的必败状态，因此在猫移动之前的当前状态为猫的必胜状态。\n\n2. 如果猫到达任何节点之后的状态都不是猫的必胜状态，但是存在一个节点，猫到达该节点之后，结果是平局，则猫到达该节点之后的状态为双方的必和状态，因此在猫移动之前的当前状态为双方的必和状态。\n\n3. 如果猫到达任何节点之后的状态都不是猫的必胜状态或必和状态，则猫到达任何节点之后的状态都为猫的必败状态，老鼠的必胜状态，因此在猫移动之前的当前状态为猫的必败状态。\n\n实现方面，由于双方移动的策略相似，因此可以使用一个函数实现移动策略，根据游戏已经进行的轮数的奇偶性决定当前轮到的玩家。对于特定玩家的移动，实现方法如下：\n\n1. 如果当前玩家存在一种移动方法到达非必败状态，则用该状态更新游戏结果。\n\n   - 如果该移动方法到达必胜状态，则将当前状态（移动前的状态）设为必胜状态，结束遍历其他可能的移动。\n\n   - 如果该移动方法到达必和状态，则将当前状态（移动前的状态）设为必和状态，继续遍历其他可能的移动，因为可能存在到达必胜状态的移动方法。\n\n2. 如果当前玩家的任何移动方法都到达必败状态，则将当前状态（移动前的状态）设为必败状态。\n\n由于老鼠可能的位置有 $n$ 个，猫可能的位置有 $n - 1$ 个，游戏轮数最大为 $2n(n - 1)$，因此动态规划的状态数是 $O(n^4)$，对于每个状态需要 $O(n)$ 的时间计算状态值，因此总时间复杂度是 $O(n^5)$，该时间复杂度会超出时间限制，因此自顶向下的动态规划不适用于这道题。以下代码为自顶向下的动态规划的实现，仅供读者参考。\n\n```Java [sol0-Java]\nclass Solution {\n    static final int MOUSE_WIN = 1;\n    static final int CAT_WIN = 2;\n    static final int DRAW = 0;\n    int n;\n    int[][] graph;\n    int[][][] dp;\n\n    public int catMouseGame(int[][] graph) {\n        this.n = graph.length;\n        this.graph = graph;\n        this.dp = new int[n][n][2 * n * (n - 1)];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                Arrays.fill(dp[i][j], -1);\n            }\n        }\n        return getResult(1, 2, 0);\n    }\n\n    public int getResult(int mouse, int cat, int turns) {\n        if (turns == 2 * n * (n - 1)) {\n            return DRAW;\n        }\n        if (dp[mouse][cat][turns] < 0) {\n            if (mouse == 0) {\n                dp[mouse][cat][turns] = MOUSE_WIN;\n            } else if (cat == mouse) {\n                dp[mouse][cat][turns] = CAT_WIN;\n            } else {\n                getNextResult(mouse, cat, turns);\n            }\n        }\n        return dp[mouse][cat][turns];\n    }\n\n    public void getNextResult(int mouse, int cat, int turns) {\n        int curMove = turns % 2 == 0 ? mouse : cat;\n        int defaultResult = curMove == mouse ? CAT_WIN : MOUSE_WIN;\n        int result = defaultResult;\n        int[] nextNodes = graph[curMove];\n        for (int next : nextNodes) {\n            if (curMove == cat && next == 0) {\n                continue;\n            }\n            int nextMouse = curMove == mouse ? next : mouse;\n            int nextCat = curMove == cat ? next : cat;\n            int nextResult = getResult(nextMouse, nextCat, turns + 1);\n            if (nextResult != defaultResult) {\n                result = nextResult;\n                if (result != DRAW) {\n                    break;\n                }\n            }\n        }\n        dp[mouse][cat][turns] = result;\n    }\n}\n```\n\n```C# [sol0-C#]\npublic class Solution {\n    const int MOUSE_WIN = 1;\n    const int CAT_WIN = 2;\n    const int DRAW = 0;\n    int n;\n    int[][] graph;\n    int[,,] dp;\n\n    public int CatMouseGame(int[][] graph) {\n        this.n = graph.Length;\n        this.graph = graph;\n        this.dp = new int[n, n, 2 * n * (n - 1)];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < 2 * n * (n - 1); k++) {\n                    dp[i, j, k] = -1;\n                }\n            }\n        }\n        return GetResult(1, 2, 0);\n    }\n\n    public int GetResult(int mouse, int cat, int turns) {\n        if (turns == 2 * n * (n - 1)) {\n            return DRAW;\n        }\n        if (dp[mouse, cat, turns] < 0) {\n            if (mouse == 0) {\n                dp[mouse, cat, turns] = MOUSE_WIN;\n            } else if (cat == mouse) {\n                dp[mouse, cat, turns] = CAT_WIN;\n            } else {\n                GetNextResult(mouse, cat, turns);\n            }\n        }\n        return dp[mouse, cat, turns];\n    }\n\n    public void GetNextResult(int mouse, int cat, int turns) {\n        int curMove = turns % 2 == 0 ? mouse : cat;\n        int defaultResult = curMove == mouse ? CAT_WIN : MOUSE_WIN;\n        int result = defaultResult;\n        int[] nextNodes = graph[curMove];\n        foreach (int next in nextNodes) {\n            if (curMove == cat && next == 0) {\n                continue;\n            }\n            int nextMouse = curMove == mouse ? next : mouse;\n            int nextCat = curMove == cat ? next : cat;\n            int nextResult = GetResult(nextMouse, nextCat, turns + 1);\n            if (nextResult != defaultResult) {\n                result = nextResult;\n                if (result != DRAW) {\n                    break;\n                }\n            }\n        }\n        dp[mouse, cat, turns] = result;\n    }\n}\n```\n\n```C++ [sol0-C++]\nconst int MOUSE_WIN = 1;\nconst int CAT_WIN = 2;\nconst int DRAW = 0;\nconst int MAXN = 51;\n\nclass Solution {\npublic:\n    int n;\n    int dp[MAXN][MAXN][MAXN*(MAXN-1)*2];\n    vector<vector<int>> graph;\n    \n    int catMouseGame(vector<vector<int>>& graph) {\n        this->n = graph.size();\n        this->graph = graph;\n        memset(dp, -1, sizeof(dp));\n        return getResult(1, 2, 0);\n    }\n\n    int getResult(int mouse, int cat, int turns) {\n        if (turns == 2 * n * (n - 1)) {\n            return DRAW;\n        }\n        if (dp[mouse][cat][turns] < 0) {\n            if (mouse == 0) {\n                dp[mouse][cat][turns] = MOUSE_WIN;\n            } else if (cat == mouse) {\n                dp[mouse][cat][turns] = CAT_WIN;\n            } else {\n                getNextResult(mouse, cat, turns);\n            }\n        }\n        return dp[mouse][cat][turns];\n    }\n\n    void getNextResult(int mouse, int cat, int turns) {\n        int curMove = turns % 2 == 0 ? mouse : cat;\n        int defaultResult = curMove == mouse ? CAT_WIN : MOUSE_WIN;\n        int result = defaultResult;\n        for (int next : graph[curMove]) {\n            if (curMove == cat && next == 0) {\n                continue;\n            }\n            int nextMouse = curMove == mouse ? next : mouse;\n            int nextCat = curMove == cat ? next : cat;\n            int nextResult = getResult(nextMouse, nextCat, turns + 1);\n            if (nextResult != defaultResult) {\n                result = nextResult;\n                if (result != DRAW) {\n                    break;\n                }\n            }\n        }\n        dp[mouse][cat][turns] = result;\n    }\n};\n```\n\n```Python [sol0-Python3]\nDRAW = 0\nMOUSE_WIN = 1\nCAT_WIN = 2\n\nclass Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        dp = [[[-1] * (2 * n * (n - 1)) for _ in range(n)] for _ in range(n)]\n\n        def getResult(mouse: int, cat: int, turns: int) -> int:\n            if turns == 2 * n * (n - 1):\n                return DRAW\n            res = dp[mouse][cat][turns]\n            if res != -1:\n                return res\n            if mouse == 0:\n                res = MOUSE_WIN\n            elif cat == mouse:\n                res = CAT_WIN\n            else:\n                res = getNextResult(mouse, cat, turns)\n            dp[mouse][cat][turns] = res\n            return res\n\n        def getNextResult(mouse: int, cat: int, turns: int) -> int:\n            curMove = mouse if turns % 2 == 0 else cat\n            defaultRes = MOUSE_WIN if curMove != mouse else CAT_WIN\n            res = defaultRes\n            for next in graph[curMove]:\n                if curMove == cat and next == 0:\n                    continue\n                nextMouse = next if curMove == mouse else mouse\n                nextCat = next if curMove == cat else cat\n                nextRes = getResult(nextMouse, nextCat, turns + 1)\n                if nextRes != defaultRes:\n                    res = nextRes\n                    if res != DRAW:\n                        break\n            return res\n\n        return getResult(1, 2, 0)\n```\n\n```JavaScript [sol0-JavaScript]\nconst MOUSE_WIN = 1;\nconst CAT_WIN = 2;\nconst DRAW = 0;\nvar catMouseGame = function(graph) {\n    const n = graph.length;\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0).map(() => new Array(2 * n * (n - 1)).fill(-1)));\n    \n    const getResult = (mouse, cat, turns) => {\n        if (turns === 2 * n * (n - 1)) {\n            return DRAW;\n        }\n        let res = dp[mouse][cat][turns];\n        if (res !== -1) {\n            return res;\n        }\n        if (mouse === 0) {\n            res = MOUSE_WIN;\n        } else if (cat === mouse) {\n            res = CAT_WIN;\n        } else {\n            res = getNextResult(mouse, cat, turns);\n        }\n        dp[mouse][cat][turns] = res;\n        return res;\n    }\n\n    const getNextResult = (mouse, cat, turns) => {\n        const curMove = turns % 2 == 0 ? mouse : cat;\n        const defaultRes = curMove != mouse ? MOUSE_WIN : CAT_WIN;\n        let res = defaultRes;\n        for (const next of graph[curMove]) {\n            if (curMove === cat && next === 0) {\n                continue;\n            }\n            const nextMouse = curMove === mouse ? next : mouse;\n            const nextCat = curMove == cat ? next : cat;\n            const nextRes = getResult(nextMouse, nextCat, turns + 1)\n            if (nextRes !== defaultRes) {\n                res = nextRes;\n                if (res !== DRAW) {\n                    break;\n                }\n            } \n        }\n        return res;\n    }\n\n    return getResult(1, 2, 0);\n};\n```\n\n```go [sol0-Golang]\nconst (\n    draw     = 0\n    mouseWin = 1\n    catWin   = 2\n)\n\nfunc catMouseGame(graph [][]int) int {\n    n := len(graph)\n    dp := make([][][]int, n)\n    for i := range dp {\n        dp[i] = make([][]int, n)\n        for j := range dp[i] {\n            dp[i][j] = make([]int, n*(n-1)*2)\n            for k := range dp[i][j] {\n                dp[i][j][k] = -1\n            }\n        }\n    }\n\n    var getResult, getNextResult func(int, int, int) int\n    getResult = func(mouse, cat, turns int) int {\n        if turns == n*(n-1)*2 {\n            return draw\n        }\n        res := dp[mouse][cat][turns]\n        if res != -1 {\n            return res\n        }\n        if mouse == 0 {\n            res = mouseWin\n        } else if cat == mouse {\n            res = catWin\n        } else {\n            res = getNextResult(mouse, cat, turns)\n        }\n        dp[mouse][cat][turns] = res\n        return res\n    }\n    getNextResult = func(mouse, cat, turns int) int {\n        curMove := mouse\n        if turns%2 == 1 {\n            curMove = cat\n        }\n        defaultRes := mouseWin\n        if curMove == mouse {\n            defaultRes = catWin\n        }\n        res := defaultRes\n        for _, next := range graph[curMove] {\n            if curMove == cat && next == 0 {\n                continue\n            }\n            nextMouse, nextCat := mouse, cat\n            if curMove == mouse {\n                nextMouse = next\n            } else if curMove == cat {\n                nextCat = next\n            }\n            nextRes := getResult(nextMouse, nextCat, turns+1)\n            if nextRes != defaultRes {\n                res = nextRes\n                if res != draw {\n                    break\n                }\n            }\n        }\n        return res\n    }\n    return getResult(1, 2, 0)\n}\n```\n\n```C [sol0-C]\n#define MOUSE_WIN 1\n#define CAT_WIN 2\n#define DRAW 0\n#define MAXN 51\n\nint dp[MAXN][MAXN][MAXN*(MAXN-1)*2];\n\nint getResult(int mouse, int cat, int turns, const int** graph, const int graphSize, const int* graphColSize) {\n    if (turns == graphSize * (graphSize - 1) * 2) {\n        return DRAW;\n    }\n    if (dp[mouse][cat][turns] < 0) {\n        if (mouse == 0) {\n            dp[mouse][cat][turns] = MOUSE_WIN;\n        } else if (cat == mouse) {\n            dp[mouse][cat][turns] = CAT_WIN;\n        } else {\n            getNextResult(mouse, cat, turns, graph, graphSize, graphColSize);\n        }\n    }\n    return dp[mouse][cat][turns];\n}\n\nvoid getNextResult(int mouse, int cat, int turns, const int** graph, const int graphSize, const int* graphColSize) {\n    int curMove = turns % 2 == 0 ? mouse : cat;\n    int defaultResult = curMove == mouse ? CAT_WIN : MOUSE_WIN;\n    int result = defaultResult;\n    int * nextNodes = graph[curMove];\n    for (int i = 0; i < graphColSize[curMove]; i++) {\n        if (curMove == cat && nextNodes[i] == 0) {\n            continue;\n        }\n        int nextMouse = curMove == mouse ? nextNodes[i] : mouse;\n        int nextCat = curMove == cat ? nextNodes[i] : cat;\n        int nextResult = getResult(nextMouse, nextCat, turns + 1, graph, graphSize, graphColSize);\n        if (nextResult != defaultResult) {\n            result = nextResult;\n            if (result != DRAW) {\n                break;\n            }\n        }\n    }\n    dp[mouse][cat][turns] = result;\n}\n\nint catMouseGame(int** graph, int graphSize, int* graphColSize){\n    memset(dp, -1, sizeof(dp));\n    return getResult(1, 2, 0, graph, graphSize, graphColSize);\n}\n```\n\n#### 方法一：拓扑排序\n\n**思路和算法**\n\n自顶向下的动态规划由于判定平局的标准和轮数有关，因此时间复杂度较高。为了降低时间复杂度，需要使用自底向上的方法实现，消除结果和轮数之间的关系。\n\n使用自底向上的方法实现时，游戏中的状态由老鼠的位置、猫的位置和轮到移动的一方三个因素确定。初始时，只有边界情况的胜负结果已知，其余所有状态的结果都初始化为平局。边界情况为直接确定胜负的情况，包括两类情况：老鼠躲入洞里，无论猫位于哪个节点，都是老鼠获胜；猫和老鼠占据相同的节点，无论占据哪个节点，都是猫获胜。\n\n从边界情况出发遍历其他情况。对于当前状态，可以得到老鼠的位置、猫的位置和轮到移动的一方，根据当前状态可知上一轮的所有可能状态，其中上一轮的移动方和当前的移动方相反，上一轮的移动方在上一轮状态和当前状态所在的节点不同。假设当前状态是老鼠所在节点是 $\\textit{mouse}$，猫所在节点是 $\\textit{cat}$，则根据当前的移动方，可以得到上一轮的所有可能状态：\n\n- 如果当前的移动方是老鼠，则上一轮的移动方是猫，上一轮状态中老鼠所在节点是 $\\textit{mouse}$，猫所在节点可能是 $\\textit{graph}[\\textit{cat}]$ 中的任意一个节点（除了节点 $0$）；\n\n- 如果当前的移动方是猫，则上一轮的移动方是老鼠，上一轮状态中老鼠所在节点可能是 $\\textit{graph}[\\textit{mouse}]$ 中的任意一个节点，猫所在节点是 $\\textit{cat}$。\n\n对于上一轮的每一种可能的状态，如果该状态的结果已知不是平局，则不需要重复计算该状态的结果，只有对结果是平局的状态，才需要计算该状态的结果。对于上一轮的移动方，只有当可以确定上一轮状态是必胜状态或者必败状态时，才更新上一轮状态的结果。\n\n- 如果上一轮的移动方和当前状态的结果的获胜方相同，由于当前状态为上一轮的移动方的必胜状态，因此上一轮的移动方一定可以移动到当前状态而获胜，上一轮状态为上一轮的移动方的必胜状态。\n\n- 如果上一轮的移动方和当前状态的结果的获胜方不同，则上一轮的移动方需要尝试其他可能的移动，可能有以下三种情况：\n\n   - 如果存在一种移动可以到达上一轮的移动方的必胜状态，则上一轮状态为上一轮的移动方的必胜状态；\n\n   - 如果所有的移动都到达上一轮的移动方的必败状态，则上一轮状态为上一轮的移动方的必败状态；\n\n   - 如果所有的移动都不能到达上一轮的移动方的必胜状态，但是存在一种移动可以到达上一轮的移动方的必和状态，则上一轮状态为上一轮的移动方的必和状态。\n\n其中，对于必败状态与必和状态的判断依据为上一轮的移动方可能的移动是都到达必败状态还是可以到达必和状态。为了实现必败状态与必和状态的判断，需要记录每个状态的度，初始时每个状态的度为当前玩家在当前位置可以移动到的节点数。对于老鼠而言，初始的度为老鼠所在的节点的相邻节点数；对于猫而言，初始的度为猫所在的节点的相邻且非节点 $0$ 的节点数。\n\n遍历过程中，从当前状态出发遍历上一轮的所有可能状态，如果上一轮状态的结果是平局且上一轮的移动方和当前状态的结果的获胜方不同，则将上一轮状态的度减 $1$。如果上一轮状态的度减少到 $0$，则从上一轮状态出发到达的所有状态都是上一轮的移动方的必败状态，因此上一轮状态也是上一轮的移动方的必败状态。\n\n在确定上一轮状态的结果（必胜或必败）之后，即可从上一轮状态出发，遍历其他结果是平局的状态。当没有更多的状态可以确定胜负结果时，遍历结束，此时即可得到初始状态的结果。\n\n细心的读者可以发现，上述遍历的过程其实是拓扑排序。\n\n**证明**\n\n必胜状态和必败状态都符合博弈中的最优策略，需要证明的是必和状态的正确性。\n\n遍历结束之后，如果一个状态的结果是平局，则该状态满足以下两个条件：\n\n- 从该状态出发，任何移动都无法到达该状态的移动方的必胜状态；\n\n- 从该状态出发，存在一种移动可以到达必和状态。\n\n对于标记结果是平局的状态，如果其实际结果是该状态的移动方必胜，则一定存在一个下一轮状态，为当前状态的移动方的必胜状态，在根据下一轮状态的结果标记当前状态的结果时会将当前状态标记为当前状态的移动方的必胜状态，和标记结果是平局矛盾。\n\n对于标记结果是平局的状态，如果其实际结果是该状态的移动方必败，则所有的下一轮状态都为当前状态的移动方的必败状态，在根据下一轮状态的结果标记当前状态的结果时会将当前状态标记为当前状态的移动方的必败状态，和标记结果是平局矛盾。\n\n因此，如果标记的状态是必和状态，则实际结果一定是必和状态。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    static final int MOUSE_TURN = 0, CAT_TURN = 1;\n    static final int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2;\n    int[][] graph;\n    int[][][] degrees;\n    int[][][] results;\n\n    public int catMouseGame(int[][] graph) {\n        int n = graph.length;\n        this.graph = graph;\n        this.degrees = new int[n][n][2];\n        this.results = new int[n][n][2];\n        Queue<int[]> queue = new ArrayDeque<int[]>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                degrees[i][j][MOUSE_TURN] = graph[i].length;\n                degrees[i][j][CAT_TURN] = graph[j].length;\n            }\n        }\n        for (int node : graph[0]) {\n            for (int i = 0; i < n; i++) {\n                degrees[i][node][CAT_TURN]--;\n            }\n        }\n        for (int j = 1; j < n; j++) {\n            results[0][j][MOUSE_TURN] = MOUSE_WIN;\n            results[0][j][CAT_TURN] = MOUSE_WIN;\n            queue.offer(new int[]{0, j, MOUSE_TURN});\n            queue.offer(new int[]{0, j, CAT_TURN});\n        }\n        for (int i = 1; i < n; i++) {\n            results[i][i][MOUSE_TURN] = CAT_WIN;\n            results[i][i][CAT_TURN] = CAT_WIN;\n            queue.offer(new int[]{i, i, MOUSE_TURN});\n            queue.offer(new int[]{i, i, CAT_TURN});\n        }\n        while (!queue.isEmpty()) {\n            int[] state = queue.poll();\n            int mouse = state[0], cat = state[1], turn = state[2];\n            int result = results[mouse][cat][turn];\n            List<int[]> prevStates = getPrevStates(mouse, cat, turn);\n            for (int[] prevState : prevStates) {\n                int prevMouse = prevState[0], prevCat = prevState[1], prevTurn = prevState[2];\n                if (results[prevMouse][prevCat][prevTurn] == DRAW) {\n                    boolean canWin = (result == MOUSE_WIN && prevTurn == MOUSE_TURN) || (result == CAT_WIN && prevTurn == CAT_TURN);\n                    if (canWin) {\n                        results[prevMouse][prevCat][prevTurn] = result;\n                        queue.offer(new int[]{prevMouse, prevCat, prevTurn});\n                    } else {\n                        degrees[prevMouse][prevCat][prevTurn]--;\n                        if (degrees[prevMouse][prevCat][prevTurn] == 0) {\n                            int loseResult = prevTurn == MOUSE_TURN ? CAT_WIN : MOUSE_WIN;\n                            results[prevMouse][prevCat][prevTurn] = loseResult;\n                            queue.offer(new int[]{prevMouse, prevCat, prevTurn});\n                        }\n                    }\n                }\n            }\n        }\n        return results[1][2][MOUSE_TURN];\n    }\n\n    public List<int[]> getPrevStates(int mouse, int cat, int turn) {\n        List<int[]> prevStates = new ArrayList<int[]>();\n        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;\n        if (prevTurn == MOUSE_TURN) {\n            for (int prev : graph[mouse]) {\n                prevStates.add(new int[]{prev, cat, prevTurn});\n            }\n        } else {\n            for (int prev : graph[cat]) {\n                if (prev != 0) {\n                    prevStates.add(new int[]{mouse, prev, prevTurn});\n                }\n            }\n        }\n        return prevStates;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    const int MOUSE_TURN = 0, CAT_TURN = 1;\n    const int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2;\n    int[][] graph;\n    int[,,] degrees;\n    int[,,] results;\n\n    public int CatMouseGame(int[][] graph) {\n        int n = graph.Length;\n        this.graph = graph;\n        this.degrees = new int[n, n, 2];\n        this.results = new int[n, n, 2];\n        Queue<Tuple<int, int, int>> queue = new Queue<Tuple<int, int, int>>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                degrees[i, j, MOUSE_TURN] = graph[i].Length;\n                degrees[i, j, CAT_TURN] = graph[j].Length;\n            }\n        }\n        foreach (int node in graph[0]) {\n            for (int i = 0; i < n; i++) {\n                degrees[i, node, CAT_TURN]--;\n            }\n        }\n        for (int j = 1; j < n; j++) {\n            results[0, j, MOUSE_TURN] = MOUSE_WIN;\n            results[0, j, CAT_TURN] = MOUSE_WIN;\n            queue.Enqueue(new Tuple<int, int, int>(0, j, MOUSE_TURN));\n            queue.Enqueue(new Tuple<int, int, int>(0, j, CAT_TURN));\n        }\n        for (int i = 1; i < n; i++) {\n            results[i, i, MOUSE_TURN] = CAT_WIN;\n            results[i, i, CAT_TURN] = CAT_WIN;\n            queue.Enqueue(new Tuple<int, int, int>(i, i, MOUSE_TURN));\n            queue.Enqueue(new Tuple<int, int, int>(i, i, CAT_TURN));\n        }\n        while (queue.Count > 0) {\n            Tuple<int, int, int> state = queue.Dequeue();\n            int mouse = state.Item1, cat = state.Item2, turn = state.Item3;\n            int result = results[mouse, cat, turn];\n            IList<Tuple<int, int, int>> prevStates = GetPrevStates(mouse, cat, turn);\n            foreach (Tuple<int, int, int> prevState in prevStates) {\n                int prevMouse = prevState.Item1, prevCat = prevState.Item2, prevTurn = prevState.Item3;\n                if (results[prevMouse, prevCat, prevTurn] == DRAW) {\n                    bool canWin = (result == MOUSE_WIN && prevTurn == MOUSE_TURN) || (result == CAT_WIN && prevTurn == CAT_TURN);\n                    if (canWin) {\n                        results[prevMouse, prevCat, prevTurn] = result;\n                        queue.Enqueue(new Tuple<int, int, int>(prevMouse, prevCat, prevTurn));\n                    } else {\n                        degrees[prevMouse, prevCat, prevTurn]--;\n                        if (degrees[prevMouse, prevCat, prevTurn] == 0) {\n                            int loseResult = prevTurn == MOUSE_TURN ? CAT_WIN : MOUSE_WIN;\n                            results[prevMouse, prevCat, prevTurn] = loseResult;\n                            queue.Enqueue(new Tuple<int, int, int>(prevMouse, prevCat, prevTurn));\n                        }\n                    }\n                }\n            }\n        }\n        return results[1, 2, MOUSE_TURN];\n    }\n\n    public IList<Tuple<int, int, int>> GetPrevStates(int mouse, int cat, int turn) {\n        IList<Tuple<int, int, int>> prevStates = new List<Tuple<int, int, int>>();\n        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;\n        if (prevTurn == MOUSE_TURN) {\n            foreach (int prev in graph[mouse]) {\n                prevStates.Add(new Tuple<int, int, int>(prev, cat, prevTurn));\n            }\n        } else {\n            foreach (int prev in graph[cat]) {\n                if (prev != 0) {\n                    prevStates.Add(new Tuple<int, int, int>(mouse, prev, prevTurn));\n                }\n            }\n        }\n        return prevStates;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    const int MOUSE_TURN = 0, CAT_TURN = 1;\n    const int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2;\n    vector<vector<int>> graph;\n    vector<vector<vector<int>>> degrees;\n    vector<vector<vector<int>>> results;\n\n    int catMouseGame(vector<vector<int>>& graph) {\n        int n = graph.size();\n        this->graph = graph;\n        this->degrees = vector<vector<vector<int>>>(n, vector<vector<int>>(n, vector<int>(2)));\n        this->results = vector<vector<vector<int>>>(n, vector<vector<int>>(n, vector<int>(2)));\n        queue<tuple<int, int, int>> qu;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                degrees[i][j][MOUSE_TURN] = graph[i].size();\n                degrees[i][j][CAT_TURN] = graph[j].size();\n            }\n        }\n        for (int node : graph[0]) {\n            for (int i = 0; i < n; i++) {\n                degrees[i][node][CAT_TURN]--;\n            }\n        }\n        for (int j = 1; j < n; j++) {\n            results[0][j][MOUSE_TURN] = MOUSE_WIN;\n            results[0][j][CAT_TURN] = MOUSE_WIN;\n            qu.emplace(0, j, MOUSE_TURN);\n            qu.emplace(0, j, CAT_TURN);\n        }\n        for (int i = 1; i < n; i++) {\n            results[i][i][MOUSE_TURN] = CAT_WIN;\n            results[i][i][CAT_TURN] = CAT_WIN;\n            qu.emplace(i, i, MOUSE_TURN);\n            qu.emplace(i, i, CAT_TURN);\n        }\n        while (!qu.empty()) {\n            auto [mouse, cat, turn] = qu.front();\n            qu.pop();\n            int result = results[mouse][cat][turn];\n            vector<tuple<int, int, int>> prevStates = GetPrevStates(mouse, cat, turn);\n            for (auto & [prevMouse, prevCat, prevTurn] : prevStates) {\n                if (results[prevMouse][prevCat][prevTurn] == DRAW) {\n                    bool canWin = (result == MOUSE_WIN && prevTurn == MOUSE_TURN) || (result == CAT_WIN && prevTurn == CAT_TURN);\n                    if (canWin) {\n                        results[prevMouse][prevCat][prevTurn] = result;\n                        qu.emplace(prevMouse, prevCat, prevTurn);\n                    } else if (--degrees[prevMouse][prevCat][prevTurn] == 0) {\n                        int loseResult = prevTurn == MOUSE_TURN ? CAT_WIN : MOUSE_WIN;\n                        results[prevMouse][prevCat][prevTurn] = loseResult;\n                        qu.emplace(prevMouse, prevCat, prevTurn);\n                    }\n                }\n            }\n        }\n        return results[1][2][MOUSE_TURN];\n    }\n\n    vector<tuple<int, int, int>> GetPrevStates(int mouse, int cat, int turn) {\n        vector<tuple<int, int, int>> prevStates;\n        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;\n        if (prevTurn == MOUSE_TURN) {\n            for (int & prev : graph[mouse]) {\n                prevStates.emplace_back(prev, cat, prevTurn);\n            }\n        } else {\n            for (int & prev : graph[cat]) {\n                if (prev != 0) {\n                    prevStates.emplace_back(mouse, prev, prevTurn);\n                }\n            }\n        }\n        return prevStates;\n    }\n};\n```\n\n```Python [sol1-Python3]\nMOUSE_TURN = 0\nCAT_TURN = 1\n\nDRAW = 0\nMOUSE_WIN = 1\nCAT_WIN = 2\n\nclass Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        degrees = [[[0, 0] for _ in range(n)] for _ in range(n)]\n        results = [[[0, 0] for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(1, n):\n                degrees[i][j][MOUSE_TURN] = len(graph[i])\n                degrees[i][j][CAT_TURN] = len(graph[j])\n        for y in graph[0]:\n            for i in range(n):\n                degrees[i][y][CAT_TURN] -= 1\n\n        q = deque()\n        for j in range(1, n):\n            results[0][j][MOUSE_TURN] = MOUSE_WIN\n            results[0][j][CAT_TURN] = MOUSE_WIN\n            q.append((0, j, MOUSE_TURN))\n            q.append((0, j, CAT_TURN))\n        for i in range(1, n):\n            results[i][i][MOUSE_TURN] = CAT_WIN\n            results[i][i][CAT_TURN] = CAT_WIN\n            q.append((i, i, MOUSE_TURN))\n            q.append((i, i, CAT_TURN))\n\n        while q:\n            mouse, cat, turn = q.popleft()\n            result = results[mouse][cat][turn]\n            if turn == MOUSE_TURN:\n                prevStates = [(mouse, prev, CAT_TURN) for prev in graph[cat]]\n            else:\n                prevStates = [(prev, cat, MOUSE_TURN) for prev in graph[mouse]]\n            for prevMouse, prevCat, prevTurn in prevStates:\n                if prevCat == 0:\n                    continue\n                if results[prevMouse][prevCat][prevTurn] == DRAW:\n                    canWin = result == MOUSE_WIN and prevTurn == MOUSE_TURN or result == CAT_WIN and prevTurn == CAT_TURN\n                    if canWin:\n                        results[prevMouse][prevCat][prevTurn] = result\n                        q.append((prevMouse, prevCat, prevTurn))\n                    else:\n                        degrees[prevMouse][prevCat][prevTurn] -= 1\n                        if degrees[prevMouse][prevCat][prevTurn] == 0:\n                            results[prevMouse][prevCat][prevTurn] = CAT_WIN if prevTurn == MOUSE_TURN else MOUSE_WIN\n                            q.append((prevMouse, prevCat, prevTurn))\n        return results[1][2][MOUSE_TURN]\n```\n\n```JavaScript [sol1-JavaScript]\nconst MOUSE_TURN = 0, CAT_TURN = 1;\nconst DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2;\nvar catMouseGame = function(graph) {\n    const n = graph.length;\n    degrees = new Array(n).fill(0).map(() => new Array(n).fill(0).map(() => new Array(2).fill(0)));\n    results = new Array(n).fill(0).map(() => new Array(n).fill(0).map(() => new Array(2).fill(0)));\n    const queue = [];\n    for (let i = 0; i < n; i++) {\n        for (let j = 1; j < n; j++) {\n            degrees[i][j][MOUSE_TURN] = graph[i].length;\n            degrees[i][j][CAT_TURN] = graph[j].length;\n        }\n    }\n    for (const node of graph[0]) {\n        for (let i = 0; i < n; i++) {\n            degrees[i][node][CAT_TURN]--;\n        }\n    }\n    for (let j = 1; j < n; j++) {\n        results[0][j][MOUSE_TURN] = MOUSE_WIN;\n        results[0][j][CAT_TURN] = MOUSE_WIN;\n        queue.push([0, j, MOUSE_TURN]);\n        queue.push([0, j, CAT_TURN]);\n    }\n    for (let i = 1; i < n; i++) {\n        results[i][i][MOUSE_TURN] = CAT_WIN;\n        results[i][i][CAT_TURN] = CAT_WIN;\n        queue.push([i, i, MOUSE_TURN]);\n        queue.push([i, i, CAT_TURN]);\n    }\n    while (queue.length) {\n        const state = queue.shift();\n        const mouse = state[0], cat = state[1], turn = state[2];\n        const result = results[mouse][cat][turn];\n        const prevStates = getPrevStates(mouse, cat, turn, graph);\n        for (const prevState of prevStates) {\n            let prevMouse = prevState[0], prevCat = prevState[1], prevTurn = prevState[2];\n            if (results[prevMouse][prevCat][prevTurn] === DRAW) {\n                const canWin = (result === MOUSE_WIN && prevTurn === MOUSE_TURN) || (result === CAT_WIN && prevTurn === CAT_TURN);\n                if (canWin) {\n                    results[prevMouse][prevCat][prevTurn] = result;\n                    queue.push([prevMouse, prevCat, prevTurn]);\n                } else {\n                    degrees[prevMouse][prevCat][prevTurn]--;\n                    if (degrees[prevMouse][prevCat][prevTurn] == 0) {\n                        const loseResult = prevTurn === MOUSE_TURN ? CAT_WIN : MOUSE_WIN;\n                        results[prevMouse][prevCat][prevTurn] = loseResult;\n                        queue.push([prevMouse, prevCat, prevTurn]);\n                    }\n                }\n            }\n        }\n    }\n    return results[1][2][MOUSE_TURN];\n};\n\nconst getPrevStates = (mouse, cat, turn, graph) => {\n    const prevStates = [];\n    const prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;\n    if (prevTurn === MOUSE_TURN) {\n        for (const prev of graph[mouse]) {\n            prevStates.push([prev, cat, prevTurn]);\n        }\n    } else {\n        for (const prev of graph[cat]) {\n            if (prev != 0) {\n                prevStates.push([mouse, prev, prevTurn]);\n            }\n        }\n    }\n    return prevStates;\n}\n```\n\n```go [sol1-Golang]\nconst (\n    mouseTurn = 0\n    catTurn   = 1\n\n    draw     = 0\n    mouseWin = 1\n    catWin   = 2\n)\n\nfunc catMouseGame(graph [][]int) int {\n    n := len(graph)\n    degrees := make([][][2]int, n)\n    results := make([][][2]int, n)\n    for i := range degrees {\n        degrees[i] = make([][2]int, n)\n        results[i] = make([][2]int, n)\n    }\n    for i, to := range graph {\n        for j := 1; j < n; j++ {\n            degrees[i][j][mouseTurn] = len(to)\n            degrees[i][j][catTurn] = len(graph[j])\n        }\n    }\n    for _, y := range graph[0] {\n        for i := range degrees {\n            degrees[i][y][catTurn]--\n        }\n    }\n\n    type state struct{ mouse, cat, turn int }\n    q := []state{}\n    for j := 1; j < n; j++ {\n        results[0][j][mouseTurn] = mouseWin\n        results[0][j][catTurn] = mouseWin\n        q = append(q, state{0, j, mouseTurn}, state{0, j, catTurn})\n    }\n    for i := 1; i < n; i++ {\n        results[i][i][mouseTurn] = catWin\n        results[i][i][catTurn] = catWin\n        q = append(q, state{i, i, mouseTurn}, state{i, i, catTurn})\n    }\n\n    getPrevStates := func(s state) (prevStates []state) {\n        if s.turn == mouseTurn {\n            for _, prev := range graph[s.cat] {\n                if prev != 0 {\n                    prevStates = append(prevStates, state{s.mouse, prev, catTurn})\n                }\n            }\n        } else {\n            for _, prev := range graph[s.mouse] {\n                prevStates = append(prevStates, state{prev, s.cat, mouseTurn})\n            }\n        }\n        return\n    }\n\n    for len(q) > 0 {\n        s := q[0]\n        q = q[1:]\n        result := results[s.mouse][s.cat][s.turn]\n        for _, p := range getPrevStates(s) {\n            prevMouse, prevCat, prevTurn := p.mouse, p.cat, p.turn\n            if results[prevMouse][prevCat][prevTurn] == draw {\n                canWin := result == mouseWin && prevTurn == mouseTurn || result == catWin && prevTurn == catTurn\n                if canWin {\n                    results[prevMouse][prevCat][prevTurn] = result\n                    q = append(q, p)\n                } else {\n                    degrees[prevMouse][prevCat][prevTurn]--\n                    if degrees[prevMouse][prevCat][prevTurn] == 0 {\n                        if prevTurn == mouseTurn {\n                            results[prevMouse][prevCat][prevTurn] = catWin\n                        } else {\n                            results[prevMouse][prevCat][prevTurn] = mouseWin\n                        }\n                        q = append(q, p)\n                    }\n                }\n            }\n        }\n    }\n    return results[1][2][mouseTurn]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^3)$，其中 $n$ 是图中的节点数。状态数是 $O(n^2)$，对于每个状态需要 $O(n)$ 的时间计算状态值，因此总时间复杂度是 $O(n^3)$。\n\n- 空间复杂度：$O(n^2)$，其中 $n$ 是图中的节点数。需要记录每个状态的度和结果，状态数是 $O(n^2)$。"
}