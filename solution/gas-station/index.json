{
	"titleSlug": "gas-station",
	"slug": "jia-you-zhan-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/gas-station/solution/jia-you-zhan-by-leetcode-solution/",
	"content": "#### 方法一：一次遍历\n\n**思路与算法**\n\n最容易想到的解法是：从头到尾遍历每个加油站，并检查以该加油站为起点，最终能否行驶一周。我们可以通过减小被检查的加油站数目，来降低总的时间复杂度。\n\n假设我们此前发现，从加油站 $x$ 出发，每经过一个加油站就加一次油（包括起始加油站），最后一个可以到达的加油站是 $y$（不妨设 $x<y$）。这就说明：\n$$\n\\sum_{i=x}^{y}\\textit{gas}[i] < \\sum_{i=x}^{y}\\textit{cost}[i] \\\\\n\\sum_{i=x}^{j}gas[i] \\ge \\sum_{i=x}^{j}cost[i] ~ \\text{(For all $j \\in [x, y)$) }\n$$\n\n第一个式子表明无法到达加油站 $y$ 的下一个加油站，第二个式子表明可以到达 $y$ 以及 $y$ 之前的所有加油站。\n\n现在，考虑任意一个位于 $x,y$ 之间的加油站 $z$（包括 $x$ 和 $y$），我们现在考察从该加油站出发，能否到达加油站 $y$ 的下一个加油站，也就是要判断 $\\sum_{i=z}^{y}\\textit{gas}[i]$ 与 $\\sum_{i=z}^{y}\\textit{cost}[i]$ 之间的大小关系。\n\n根据上面的式子，我们得到：\n$$\n\\begin{aligned}\n\\sum_{i=z}^{y}\\textit{gas}[i]&=\\sum_{i=x}^{y}\\textit{gas}[i]-\\sum_{i=x}^{z-1}\\textit{gas}[i] \\\\\n&< \\sum_{i=x}^{y}\\textit{cost}[i]-\\sum_{i=x}^{z-1}\\textit{gas}[i] \\\\\n&< \\sum_{i=x}^{y}\\textit{cost}[i]-\\sum_{i=x}^{z-1}cost[i] \\\\\n&= \\sum_{i=z}^{y}\\textit{cost}[i]\n\\end{aligned}\n$$\n\n其中不等式的第二步、第三步分别利用了上面的第一个、第二个不等式。\n\n从上面的推导中，能够得出结论：从 $x,y$ 之间的任何一个加油站出发，都无法到达加油站 $y$ 的下一个加油站。\n\n在发现了这一个性质后，算法就很清楚了：我们首先检查第 $0$ 个加油站，并试图判断能否环绕一周；如果不能，就从第一个无法到达的加油站开始继续检查。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n = gas.size();\n        int i = 0;\n        while (i < n) {\n            int sumOfGas = 0, sumOfCost = 0;\n            int cnt = 0;\n            while (cnt < n) {\n                int j = (i + cnt) % n;\n                sumOfGas += gas[j];\n                sumOfCost += cost[j];\n                if (sumOfCost > sumOfGas) {\n                    break;\n                }\n                cnt++;\n            }\n            if (cnt == n) {\n                return i;\n            } else {\n                i = i + cnt + 1;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int n = gas.length;\n        int i = 0;\n        while (i < n) {\n            int sumOfGas = 0, sumOfCost = 0;\n            int cnt = 0;\n            while (cnt < n) {\n                int j = (i + cnt) % n;\n                sumOfGas += gas[j];\n                sumOfCost += cost[j];\n                if (sumOfCost > sumOfGas) {\n                    break;\n                }\n                cnt++;\n            }\n            if (cnt == n) {\n                return i;\n            } else {\n                i = i + cnt + 1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```Golang [sol1-Golang]\nfunc canCompleteCircuit(gas []int, cost []int) int {\n    for i, n := 0, len(gas); i < n; {\n        sumOfGas, sumOfCost, cnt := 0, 0, 0\n        for cnt < n {\n            j := (i + cnt) % n\n            sumOfGas += gas[j]\n            sumOfCost += cost[j]\n            if sumOfCost > sumOfGas {\n                break\n            }\n            cnt++\n        }\n        if cnt == n {\n            return i\n        } else {\n            i += cnt + 1\n        }\n    }\n    return -1\n}\n```\n\n```C [sol1-C]\nint canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize) {\n    int i = 0;\n    while (i < gasSize) {\n        int sumOfGas = 0, sumOfCost = 0;\n        int cnt = 0;\n        while (cnt < gasSize) {\n            int j = (i + cnt) % gasSize;\n            sumOfGas += gas[j];\n            sumOfCost += cost[j];\n            if (sumOfCost > sumOfGas) {\n                break;\n            }\n            cnt++;\n        }\n        if (cnt == gasSize) {\n            return i;\n        } else {\n            i = i + cnt + 1;\n        }\n    }\n    return -1;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar canCompleteCircuit = function(gas, cost) {\n    const n = gas.length;\n    let i = 0;\n    while (i < n) {\n        let sumOfGas = 0, sumOfCost = 0;\n        let cnt = 0;\n        while (cnt < n) {\n            const j = (i + cnt) % n;\n            sumOfGas += gas[j];\n            sumOfCost += cost[j];\n            if (sumOfCost > sumOfGas) {\n                break;\n            }\n            cnt++;\n        }\n        if (cnt === n) {\n            return i;\n        } else {\n            i = i + cnt + 1;\n        }\n    }\n    return -1;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N)$，其中 $N$ 为数组的长度。我们对数组进行了单次遍历。\n\n- 空间复杂度：$O(1)$。"
}