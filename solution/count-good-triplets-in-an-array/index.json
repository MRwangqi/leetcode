{
	"titleSlug": "count-good-triplets-in-an-array",
	"slug": "deng-jie-zhuan-huan-shu-zhuang-shu-zu-by-xmyd",
	"url": "https://leetcode-cn.com/problems/count-good-triplets-in-an-array/solution/deng-jie-zhuan-huan-shu-zhuang-shu-zu-by-xmyd/",
	"content": "#### 提示 1\r\n\r\n$\\textit{nums}_1$ 要是变成 $[0,1,2,\\dots, n-1]$ 就会简单不少。\r\n\r\n#### 提示 2\r\n\r\n枚举 $y$。\r\n\r\n---\r\n\r\n#### 前置知识：置换\r\n\r\n**置换**是一个排列到另一个排列的双射。\r\n\r\n以示例 2 为例，定义下列置换 $P(x)$：\r\n\r\n$$\r\n\\left(\\begin{array}{cccc}\r\nx & 0 & 1 & 2 & 3 & 4\\\\\r\nP(x) & 1 & 2 & 4 & 3 & 0\r\n\\end{array}\\right)\r\n$$\r\n\r\n我们可以把 $[4,0,1,3,2]$ 中的每个元素 $x$ 替换为 $P(x)$，这样可以得到一个新的排列 $[0,1,2,3,4]$。同理可以将 $[4,1,0,2,3]$ 通过置换得到新的排列 $[0,2,1,4,3]$。\r\n\r\n---\r\n\r\n将 $\\textit{nums}_1$ 置换成 $[0,1,2,\\dots, n-1]$，设这一置换为 $P(x)$，将 $P(x)$ 也应用到 $\\textit{nums}_2$ 上。对于 $\\textit{nums}_1$ 和 $\\textit{nums}_2$ 中的相同元素，在置换后仍然是相同的，且元素的位置仍然是不变的，因此置换操作不会影响答案个数。\r\n\r\n由于 $\\textit{nums}_1$ 置换成了 $[0,1,2,\\dots, n-1]$，因此置换后的好三元组 $(x,y,z)$ 需满足 $x<y<z$。枚举置换后的 $\\textit{nums}_2$ 中的 $y$，问题就变成计算元素 $y$ 的左侧有多少个比 $y$ 小的数，以及右侧有多少个比 $y$ 大的数。这可以用树状数组/线段树/名次树来完成（Python 可以直接用 `SortedList`），下面代码用的是树状数组。\r\n\r\n设 $y$ 的下标为 $i$，且其左侧有 $\\textit{less}$ 个数比 $y$ 小，由于比 $y$ 大的数有 $n-1-y$ 个（注意 $y$ 的范围为 $[0,n-1]$），减去左侧比 $y$ 大的 $i-\\textit{less}$ 个数，因此 $y$ 右侧有 $n-1-y-(i-\\textit{less})$ 个数比它大。所以 $y$ 会有\r\n\r\n$$\r\n\\textit{less}\\cdot(n-1-y-(i-\\textit{less}))\r\n$$\r\n\r\n个好三元组。\r\n\r\n累加所有 $y$ 的好三元组个数，即为答案。\r\n\r\n注意下面代码使用的是值域在 $[1,n]$ 的树状数组，需要对插入和查询的数额外加一。\r\n\r\n- 时间复杂度：$O(n\\log n)$。\r\n- 空间复杂度：$O(n)$。\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public long goodTriplets(int[] nums1, int[] nums2) {\r\n        var n = nums1.length;\r\n        var p = new int[n];\r\n        for (var i = 0; i < n; ++i)\r\n            p[nums1[i]] = i;\r\n        var ans = 0L;\r\n        var tree = new int[n + 1];\r\n        for (var i = 1; i < n - 1; ++i) {\r\n            for (var j = p[nums2[i - 1]] + 1; j <= n; j += j & -j) // 将 p[nums2[i-1]]+1 加入树状数组\r\n                ++tree[j];\r\n            var y = p[nums2[i]];\r\n            var less = 0;\r\n            for (var j = y; j > 0; j &= j - 1) // 计算 less\r\n                less += tree[j];\r\n            ans += (long) less * (n - 1 - y - (i - less));\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\r\n        n = len(nums1)\r\n        p = [0] * n\r\n        for i, x in enumerate(nums1):\r\n            p[x] = i\r\n        ans = 0\r\n        tree = [0] * (n + 1)\r\n        for i in range(1, n - 1):\r\n            # 将 p[nums2[i - 1]] + 1 加入树状数组\r\n            j = p[nums2[i - 1]] + 1\r\n            while j <= n:\r\n                tree[j] += 1\r\n                j += j & -j\r\n            # 计算 less\r\n            y, less = p[nums2[i]], 0\r\n            j = y\r\n            while j:\r\n                less += tree[j]\r\n                j &= j - 1\r\n            ans += less * (n - 1 - y - (i - less))\r\n        return ans\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    long long goodTriplets(vector<int> &nums1, vector<int> &nums2) {\r\n        int n = nums1.size();\r\n        vector<int> p(n);\r\n        for (int i = 0; i < n; ++i)\r\n            p[nums1[i]] = i;\r\n        long long ans = 0;\r\n        vector<int> tree(n + 1);\r\n        for (int i = 1; i < n - 1; ++i) {\r\n            for (int j = p[nums2[i - 1]] + 1; j <= n; j += j & -j) // 将 p[nums2[i-1]]+1 加入树状数组\r\n                ++tree[j];\r\n            int y = p[nums2[i]], less = 0;\r\n            for (int j = y; j; j &= j - 1) // 计算 less\r\n                less += tree[j];\r\n            ans += (long) less * (n - 1 - y - (i - less));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc goodTriplets(nums1, nums2 []int) (ans int64) {\r\n\tn := len(nums1)\r\n\tp := make([]int, n)\r\n\tfor i, v := range nums1 {\r\n\t\tp[v] = i\r\n\t}\r\n\ttree := make([]int, n+1)\r\n\tfor i := 1; i < n-1; i++ {\r\n\t\tfor j := p[nums2[i-1]] + 1; j <= n; j += j & -j { // 将 p[nums2[i-1]]+1 加入树状数组\r\n\t\t\ttree[j]++\r\n\t\t}\r\n\t\ty, less := p[nums2[i]], 0\r\n\t\tfor j := y; j > 0; j &= j - 1 { // 计算 less\r\n\t\t\tless += tree[j]\r\n\t\t}\r\n\t\tans += int64(less) * int64(n-1-y-(i-less))\r\n\t}\r\n\treturn\r\n}\r\n```\r\n\r\n\r\n附 Python `SortedList` 做法：\r\n\r\n```Python\r\nfrom sortedcontainers import SortedList\r\n\r\nclass Solution:\r\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\r\n        n = len(nums1)\r\n        p = [0] * n\r\n        for i, x in enumerate(nums1):\r\n            p[x] = i\r\n        ans = 0\r\n        s = SortedList()\r\n        for i in range(1, n - 1):\r\n            s.add(p[nums2[i - 1]])\r\n            y = p[nums2[i]]\r\n            less = s.bisect_left(y)\r\n            ans += less * (n - 1 - y - (i - less))\r\n        return ans\r\n```\r\n\r\n有一道题也用到了这种置换思想：\r\n\r\n- [1713. 得到子序列的最少操作次数](https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/)\r\n"
}