{
	"titleSlug": "YesdPw",
	"slug": "xian-by-moon_qing-huan-ozhn",
	"url": "https://leetcode-cn.com/problems/YesdPw/solution/xian-by-moon_qing-huan-ozhn/",
	"content": "### 解题思路\n先忽略0和边界合并\n最后从0和边界剔除不满足要求的\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int find(vector<int>&parent,int index){\n        if(index<0){\n            return -1;\n        }\n        if(index!=parent[index]){\n            parent[index]=find(parent,parent[index]);\n        }\n        return parent[index];\n    }\n    void link(vector<int>&parent,int a,int b){\n        parent[find(parent,a)]=find(parent,b);\n    }\n    int largestArea(vector<string>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<int> parent(m*n);\n        for(int i=0;i<m*n;i++){\n            parent[i]=i;\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                int idx=i*m+j;\n                if(i>0){\n                    if(grid[i][j]==grid[i-1][j]){\n                        link(parent,idx,idx-m);\n                    }\n                }\n                if(j>0){\n                    if(grid[i][j]==grid[i][j-1]){\n                        link(parent,idx,idx-1);\n                    }\n                }\n                if(i<n-1){\n                    if(grid[i][j]==grid[i+1][j]){\n                        link(parent,idx,idx+m);\n                    }\n                }\n                if(j<m-1){\n                    if(grid[i][j]==grid[i][j+1]){\n                        link(parent,idx,idx+1);\n                    }\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                int idx=i*m+j;\n                if(grid[i][j]=='0'){\n                    if(i>0){\n                        int p_idx=find(parent,idx-m);\n                        if(p_idx>=0) parent[p_idx]=-1;\n                    }\n                    if(j>0){\n                        int p_idx=find(parent,idx-1);\n                        if(p_idx>=0) parent[p_idx]=-1;\n                    }\n                    if(i<n-1){\n                        int p_idx=find(parent,idx+m);\n                        if(p_idx>=0) parent[p_idx]=-1;\n                    }\n                    if(j<m-1){\n                        int p_idx=find(parent,idx+1);\n                        if(p_idx>=0) parent[p_idx]=-1;\n                    }\n                }\n            }\n        }\n        for(int i=0;i<m;i++){\n            int p_idx=find(parent,i);\n            if(p_idx>=0) parent[p_idx]=-1;\n            p_idx=find(parent,m*n-i-1);\n            if(p_idx>=0) parent[p_idx]=-1;\n        }\n        for(int i=0;i<n;i++){\n            int p_idx=find(parent,i*m);\n            if(p_idx>=0) parent[p_idx]=-1;\n            p_idx=find(parent,i*m+m-1);\n            if(p_idx>=0) parent[p_idx]=-1;\n        }\n        int res=0;\n        unordered_map<int,int> map;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                int idx=i*m+j;\n                int p=find(parent,idx);\n                if(p>0&&grid[i][j]!='0'){\n                    map[p]++;\n                    res=max(res,map[p]);\n                }\n            }\n        }\n        return res;\n    }\n};\n```"
}