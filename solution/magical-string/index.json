{
	"titleSlug": "magical-string",
	"slug": "by-stormsunshine-rp90",
	"url": "https://leetcode-cn.com/problems/magical-string/solution/by-stormsunshine-rp90/",
	"content": "# 解法\r\n\r\n## 思路和算法\r\n\r\n将神奇字符串按照相同连续字符分组，则满足每个组的长度都是 $1$ 或 $2$。在已知首个数字是 $1$ 的情况下，可以按从左到右的顺序生成神奇字符串。\r\n\r\n根据神奇字符串的生成规则，需要根据每个组的长度生成神奇字符串，因此可以使用双指针的做法生成神奇字符串。\r\n\r\n定义快指针 $\\textit{fast}$ 和慢指针 $\\textit{slow}$，快指针用于在神奇字符串末尾添加字符，慢指针用于遍历每个组的长度，初始时 $\\textit{fast} = \\textit{slow} = 0$。任意时刻都有 $\\textit{fast} \\ge \\textit{slow}$。\r\n\r\n神奇字符串的首个数字是 $1$，首个组的长度是 $1$，其余每个组的字符都和上个组的字符不同，长度由 $s[\\textit{slow}]$ 决定。用 $\\textit{digit}$ 表示当前组的数字，初始时 $\\textit{digit} = 1$。对于每个组，执行如下操作。\r\n\r\n1. 根据 $s[\\textit{slow}]$ 得到当前组的长度 $\\textit{groupSize}$。\r\n\r\n2. 从快指针指向的下标开始，连续填入 $\\textit{groupSize}$ 个数字 $\\textit{digit}$，同时确保神奇字符串 $s$ 的长度不超过 $n$。\r\n\r\n3. 将 $\\textit{digit}$ 更新为下一个组的数字，即如果 $\\textit{digit} = 1$ 则将 $\\textit{digit}$ 的值更新为 $2$，如果 $\\textit{digit} = 2$ 则将 $\\textit{digit}$ 的值更新为 $1$。\r\n\r\n4. 将 $\\textit{slow}$ 向右移动一位。\r\n\r\n重复上述操作，直到 $\\textit{fast} = n$ 时，得到神奇字符串 $s$ 的前 $n$ 个字符。遍历字符串 $s$ 的前 $n$ 个字符，即可得到其中 $1$ 的数目。\r\n\r\n也可以在生成的过程中计算神奇字符串 $s$ 的前 $n$ 个字符中 $1$ 的数目，做法是每次生成新的字符时，如果新生成的字符是数字 $1$ 则将计数加 $1$。\r\n\r\n上述过程中，如果 $\\textit{fast} = \\textit{slow}$，则当遍历到 $s[\\textit{fast}]$ 时，$s[\\textit{slow}]$ 尚未填入字符，此时无法根据 $s[\\textit{slow}]$ 得到当前组的长度。解决该问题有多种方法，一种方法是预先填入神奇字符串 $s$ 的前几个字符，另一种方法是将当前组的数字填入 $s[\\textit{fast}]$。\r\n\r\n由于当前组的数字 $\\textit{digit}$ 已知，因此可以首先将 $\\textit{digit}$ 填入 $s[\\textit{fast}]$。当 $\\textit{fast} = \\textit{slow}$ 时，将 $\\textit{digit}$ 填入 $s[\\textit{fast}]$ 等价于将 $\\textit{digit}$ 填入 $s[\\textit{slow}]$，此时即可根据 $s[\\textit{slow}]$ 得到当前组的长度。当 $\\textit{fast} > \\textit{slow}$ 时，$s[\\textit{slow}]$ 已经填入字符，因此可以根据 $s[\\textit{slow}]$ 得到当前组的长度。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public int magicalString(int n) {\r\n        int count = 0;\r\n        char[] array = new char[n];\r\n        int fast = 0, slow = 0;\r\n        int digit = 1;\r\n        while (fast < n) {\r\n            array[fast] = (char) ('0' + digit);\r\n            int groupSize = array[slow] - '0';\r\n            for (int i = 0; i < groupSize && fast < n; i++, fast++) {\r\n                array[fast] = (char) ('0' + digit);\r\n                count += digit & 0b1;\r\n            }\r\n            digit = digit ^ 0b11;\r\n            slow++;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public int MagicalString(int n) {\r\n        int count = 0;\r\n        char[] array = new char[n];\r\n        int fast = 0, slow = 0;\r\n        int digit = 1;\r\n        while (fast < n) {\r\n            array[fast] = (char) ('0' + digit);\r\n            int groupSize = array[slow] - '0';\r\n            for (int i = 0; i < groupSize && fast < n; i++, fast++) {\r\n                array[fast] = (char) ('0' + digit);\r\n                count += digit & 0b1;\r\n            }\r\n            digit = digit ^ 0b11;\r\n            slow++;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 是给定的参数。需要遍历神奇字符串的前 $n$ 个字符。\r\n\r\n- 空间复杂度：$O(n)$，其中 $n$ 是给定的参数。空间复杂度主要取决于生成神奇字符串的前 $n$ 个字符的空间。"
}