{
	"titleSlug": "shift-2d-grid",
	"slug": "er-wei-wang-ge-qian-yi-by-leetcode-solut-ploz",
	"url": "https://leetcode-cn.com/problems/shift-2d-grid/solution/er-wei-wang-ge-qian-yi-by-leetcode-solut-ploz/",
	"content": "#### 方法一：一维展开\n\n设 $m$ 和 $n$ 分别为网格的行列数，我们将网格 $\\textit{grid}$ 想象成由多个一维数组 $\\big \\{\\textit{grid}[i]; 0 \\le i \\lt n \\big \\}$ 按顺序拼接而成的一维数组，那么元素 $\\textit{grid}[i][j]$ 在该一维数组的下标为 $\\textit{index} = i \\times n + j$。\n\n每次迁移操作都相当于将该一维数组向右循环移动一次，那么 $k$ 次迁移操作之后，元素 $\\textit{grid}[i][j]$ 在该一维数组的下标变为 $\\textit{index}_1 = (\\textit{index} + k) \\bmod (m \\times n)$，在网格的位置变为 $\\textit{grid}[\\Big \\lfloor \\dfrac{\\textit{index}_1}{n} \\Big \\rfloor][\\textit{index}_1 \\bmod n]$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        ans = [[0] * n for _ in range(m)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                index1 = (i * n + j + k) % (m * n)\n                ans[index1 // n][index1 % n] = v\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> ret(m, vector<int>(n));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int index1 = (i * n + j + k) % (m * n);\n                ret[index1 / n][index1 % n] = grid[i][j];\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\n        int m = grid.length, n = grid[0].length;\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\n        for (int i = 0; i < m; i++) {\n            List<Integer> row = new ArrayList<Integer>();\n            for (int j = 0; j < n; j++) {\n                row.add(0);\n            }\n            ret.add(row);\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int index1 = (i * n + j + k) % (m * n);\n                ret.get(index1 / n).set(index1 % n, grid[i][j]);\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\n        int m = grid.Length, n = grid[0].Length;\n        IList<IList<int>> ret = new List<IList<int>>();\n        for (int i = 0; i < m; i++) {\n            IList<int> row = new List<int>();\n            for (int j = 0; j < n; j++) {\n                row.Add(0);\n            }\n            ret.Add(row);\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int index1 = (i * n + j + k) % (m * n);\n                ret[index1 / n][index1 % n] = grid[i][j];\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol1-C]\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\n    int m = gridSize, n = gridColSize[0];\n    int **ret = (int **)malloc(sizeof(int *) * m);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * m);\n    for (int i = 0; i < m; i++) {\n        ret[i] = (int *)malloc(sizeof(int) * n);\n        (*returnColumnSizes)[i] = n;\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int index1 = (i * n + j + k) % (m * n);\n            ret[index1 / n][index1 % n] = grid[i][j];\n        }\n    }\n    *returnSize = m;\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar shiftGrid = function(grid, k) {\n    const m = grid.length, n = grid[0].length;\n    const ret = [];\n    for (let i = 0; i < m; i++) {\n        const row = [];\n        for (let j = 0; j < n; j++) {\n            row.push(0);\n        }\n        ret.push(row);\n    }\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            const index1 = (i * n + j + k) % (m * n);\n            ret[Math.floor(index1 / n)].splice(index1 % n, 1, grid[i][j]);\n        }\n    }\n    return ret;\n};\n```\n\n```go [sol1-Golang]\nfunc shiftGrid(grid [][]int, k int) [][]int {\n    m, n := len(grid), len(grid[0])\n    ans := make([][]int, m)\n    for i := range ans {\n        ans[i] = make([]int, n)\n    }\n    for i, row := range grid {\n        for j, v := range row {\n            index1 := (i*n + j + k) % (m * n)\n            ans[index1/n][index1%n] = v\n        }\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别为网格的行列数。\n\n+ 空间复杂度：$O(1)$。返回值不计入空间复杂度。"
}