{
	"titleSlug": "string-matching-in-an-array",
	"slug": "shu-zu-zhong-de-zi-fu-chuan-pi-pei-by-le-rpmt",
	"url": "https://leetcode-cn.com/problems/string-matching-in-an-array/solution/shu-zu-zhong-de-zi-fu-chuan-pi-pei-by-le-rpmt/",
	"content": "#### 方法一：暴力枚举\n\n对于字符串数组中的某个字符串 $\\textit{words}[i]$，我们判断它是否是其他字符串的子字符串，只需要枚举 $\\textit{words}[j]$，其中 $j \\ne i$，如果 $\\textit{words}[i]$ 是 $\\textit{words}[j]$ 的子字符串，那么将 $\\textit{words}[i]$ 加入结果中。\n\n```Python [sol1-Python3]\nclass Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        ans = []\n        for i, x in enumerate(words):\n            for j, y in enumerate(words):\n                if j != i and x in y:\n                    ans.append(x)\n                    break\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> stringMatching(vector<string>& words) {\n        vector<string> ret;\n        for (int i = 0; i < words.size(); i++) {\n            for (int j = 0; j < words.size(); j++) {\n                if (i != j && words[j].find(words[i]) != string::npos) {\n                    ret.push_back(words[i]);\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<String> stringMatching(String[] words) {\n        List<String> ret = new ArrayList<String>();\n        for (int i = 0; i < words.length; i++) {\n            for (int j = 0; j < words.length; j++) {\n                if (i != j && words[j].contains(words[i])) {\n                    ret.add(words[i]);\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<string> StringMatching(string[] words) {\n        IList<string> ret = new List<string>();\n        for (int i = 0; i < words.Length; i++) {\n            for (int j = 0; j < words.Length; j++) {\n                if (i != j && words[j].Contains(words[i])) {\n                    ret.Add(words[i]);\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol1-C]\nchar ** stringMatching(char ** words, int wordsSize, int* returnSize){\n    char **ret = (char **)malloc(sizeof(char *) * wordsSize);\n    int pos = 0;\n    for (int i = 0; i < wordsSize; i++) {\n        for (int j = 0; j < wordsSize; j++) {\n            if (i != j && strstr(words[j], words[i])) {\n                ret[pos++] = words[i];\n                break;\n            }\n        }\n    }\n    *returnSize = pos;\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar stringMatching = function(words) {\n    const ret = [];\n    for (let i = 0; i < words.length; i++) {\n        for (let j = 0; j < words.length; j++) {\n            if (i !== j && words[j].search(words[i]) !== -1) {\n                ret.push(words[i]);\n                break;\n            }\n        }\n    }\n    return ret;\n};\n```\n\n```go [sol1-Golang]\nfunc stringMatching(words []string) (ans []string) {\n    for i, x := range words {\n        for j, y := range words {\n            if j != i && strings.Contains(y, x) {\n                ans = append(ans, x)\n                break\n            }\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n^2 \\times L^2)$，其中 $n$ 是字符串数组的长度，$L$ 是字符串数组中最长字符串的长度。使用 $\\text{KMP}$ 字符串匹配算法可以将时间复杂度优化到 $O(n^2 \\times T)$，其中 $T$ 是字符串数组中所有字符串的平均长度。\n\n+ 空间复杂度：$O(1)$。返回值不计入空间复杂度。如果使用 $\\text{KMP}$ 字符串匹配算法，那么对应的空间复杂度为 $O(T)$。"
}