{
	"titleSlug": "count-subarrays-with-fixed-bounds",
	"slug": "jian-ji-xie-fa-pythonjavacgo-by-endlessc-gag2",
	"url": "https://leetcode-cn.com/problems/count-subarrays-with-fixed-bounds/solution/jian-ji-xie-fa-pythonjavacgo-by-endlessc-gag2/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1Ae4y1i7PM) 已出炉，欢迎点赞三连，在评论区分享你对这场周赛的看法~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n首先考虑一个简单的情况，$\\textit{nums}$ 的所有元素都在 $[\\textit{minK},\\textit{maxK}]$ 范围内。\r\n\r\n在这种情况下，相当于要统计同时包含 $\\textit{minK}$ 和 $\\textit{maxK}$ 的子数组的个数。\r\n\r\n我们可以枚举子数组的右端点。遍历 $\\textit{nums}$，记录 $\\textit{minK}$ 上一次出现的位置 $\\textit{minI}$ 和 $\\textit{maxK}$ 上一次出现的位置 $\\textit{maxI}$，当遍历到 $\\textit{nums}[i]$ 时，如果 $\\textit{minK}$ 和 $\\textit{maxK}$ 之前出现过，则左端点 $\\le\\min(\\textit{minI},\\textit{maxI})$ 的子数组都是合法的，合法子数组的个数为 $\\min(\\textit{minI},\\textit{maxI})+1$。\r\n\r\n#### 提示 2\r\n\r\n回到原问题，由于子数组不能包含在 $[\\textit{minK},\\textit{maxK}]$ 范围之外的元素，因此我们还需要记录上一个在 $[\\textit{minK},\\textit{maxK}]$ 范围之外的 $\\textit{nums}[i]$ 的下标，记作 $i_0$。此时合法子数组的个数为 $\\min(\\textit{minI},\\textit{maxI})-i_0$。\r\n\r\n代码实现时：\r\n\r\n- 为方便计算，可以初始化 $\\textit{minI},\\ \\textit{maxI},\\ i_0$ 均为 $-1$。\r\n- 如果 $\\min(\\textit{minI},\\textit{maxI})-i_0 < 0$，则表示在 $i_0$ 右侧 $\\textit{minK}$ 和 $\\textit{maxK}$ 没有同时出现，此时合法子数组的个数为 $0$。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def countSubarrays(self, nums: List[int], min_k: int, max_k: int) -> int:\r\n        ans = 0\r\n        min_i = max_i = i0 = -1\r\n        for i, x in enumerate(nums):\r\n            if x == min_k: min_i = i\r\n            if x == max_k: max_i = i\r\n            if not min_k <= x <= max_k: i0 = i  # 子数组不能包含 nums[i0]\r\n            ans += max(min(min_i, max_i) - i0, 0)\r\n            # 注：上面这行代码，改为手动算 min max 会更快\r\n            # j = min_i if min_i < max_i else max_i\r\n            # if j > i0: ans += j - i0\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public long countSubarrays(int[] nums, int minK, int maxK) {\r\n        var ans = 0L;\r\n        int n = nums.length, minI = -1, maxI = -1, i0 = -1;\r\n        for (var i = 0; i < n; ++i) {\r\n            var x = nums[i];\r\n            if (x == minK) minI = i;\r\n            if (x == maxK) maxI = i;\r\n            if (x < minK || x > maxK) i0 = i; // 子数组不能包含 nums[i0]\r\n            ans += Math.max(Math.min(minI, maxI) - i0, 0);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    long long countSubarrays(vector<int> &nums, int min_k, int max_k) {\r\n        long long ans = 0L;\r\n        int n = nums.size(), min_i = -1, max_i = -1, i0 = -1;\r\n        for (int i = 0; i < n; ++i) {\r\n            int x = nums[i];\r\n            if (x == min_k) min_i = i;\r\n            if (x == max_k) max_i = i;\r\n            if (x < min_k || x > max_k) i0 = i; // 子数组不能包含 nums[i0]\r\n            ans += max(min(min_i, max_i) - i0, 0);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc countSubarrays(nums []int, minK, maxK int) (ans int64) {\r\n\tminI, maxI, i0 := -1, -1, -1\r\n\tfor i, x := range nums {\r\n\t\tif x == minK {\r\n\t\t\tminI = i\r\n\t\t}\r\n\t\tif x == maxK {\r\n\t\t\tmaxI = i\r\n\t\t}\r\n\t\tif x < minK || x > maxK {\r\n\t\t\ti0 = i // 子数组不能包含 nums[i0]\r\n\t\t}\r\n\t\tans += int64(max(min(minI, maxI)-i0, 0))\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc min(a, b int) int { if b < a { return b }; return a }\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{nums}$ 的长度。\r\n- 空间复杂度：$O(1)$，仅用到若干变量。\r\n"
}