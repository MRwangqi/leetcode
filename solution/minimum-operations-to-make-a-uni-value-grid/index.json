{
	"titleSlug": "minimum-operations-to-make-a-uni-value-grid",
	"slug": "zhong-wei-shu-by-endlesscheng-p0vj",
	"url": "https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid/solution/zhong-wei-shu-by-endlesscheng-p0vj/",
	"content": "要使任意两元素最终相等，这两元素的差必须是 $x$ 的倍数，否则无法通过加减 $x$ 来相等。我们可以以数组中的某一元素为基准，若所有元素与它的差均为 $x$ 的倍数，则任意两元素之差为 $x$ 的倍数。\r\n\r\n假设要让所有元素均为 $y$，设小于 $y$ 的元素有 $p$ 个，大于 $y$ 的元素有 $q$ 个，可以发现：\r\n\r\n- 若 $p<q$，$y$ 每增加 $x$，操作数就可以减小 $q-p$；\r\n- 若 $p>q$，$y$ 每减小 $x$，操作数就可以减小 $p-q$；\r\n\r\n因此 $p=q$ 时可以让总操作数最小，此时 $y$ 为所有元素的中位数。\r\n\r\n```go\r\nfunc minOperations(grid [][]int, x int) (ans int) {\r\n\tn := len(grid) * len(grid[0])\r\n\ta := make([]int, 0, n)\r\n\tfor _, row := range grid {\r\n\t\tfor _, v := range row {\r\n\t\t\tif (v-grid[0][0])%x != 0 { // 以其中一元素为基准，若所有元素与它的差均为 x 的倍数，则任意两元素之差为 x 的倍数\r\n\t\t\t\treturn -1\r\n\t\t\t}\r\n\t\t}\r\n\t\ta = append(a, row...)\r\n\t}\r\n\tsort.Ints(a) // 除了排序，也可以用求第 k 大算法来找中位数\r\n\tfor _, v := range a {\r\n\t\tans += abs(v-a[n/2]) / x\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc abs(x int) int {\r\n\tif x < 0 {\r\n\t\treturn -x\r\n\t}\r\n\treturn x\r\n}\r\n```"
}