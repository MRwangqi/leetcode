{
	"titleSlug": "substring-with-concatenation-of-all-words",
	"slug": "chuan-lian-suo-you-dan-ci-de-zi-chuan-by-244a",
	"url": "https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/chuan-lian-suo-you-dan-ci-de-zi-chuan-by-244a/",
	"content": "#### 方法一：滑动窗口\n\n**思路**\n\n此题是「[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)」的进阶版。不同的是第 438 题的元素是字母，而此题的元素是单词。可以用类似「[438. 找到字符串中所有字母异位词的官方题解](https://leetcode.cn/problems/find-all-anagrams-in-a-string/solution/zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-xzin/)」的方法二的滑动窗口来解这题。\n\n记 $\\textit{words}$ 的长度为 $m$，$\\textit{words}$ 中每个单词的长度为 $n$，$s$ 的长度为 $\\textit{ls}$。首先需要将 $s$ 划分为单词组，每个单词的大小均为 $n$ （首尾除外）。这样的划分方法有 $n$ 种，即先删去前 $i$ （$i = 0 \\sim n-1$）个字母后，将剩下的字母进行划分，如果末尾有不到 $n$ 个字母也删去。对这 $n$ 种划分得到的单词数组分别使用滑动窗口对 $\\textit{words}$ 进行类似于「字母异位词」的搜寻。\n\n划分成单词组后，一个窗口包含 $s$ 中前 $m$ 个单词，用一个哈希表 $\\textit{differ}$ 表示窗口中单词频次和 $\\textit{words}$ 中单词频次之差。初始化 $\\textit{differ}$ 时，出现在窗口中的单词，每出现一次，相应的值增加 $1$，出现在 $\\textit{words}$ 中的单词，每出现一次，相应的值减少 $1$。然后将窗口右移，右侧会加入一个单词，左侧会移出一个单词，并对 $\\textit{differ}$ 做相应的更新。窗口移动时，若出现 $\\textit{differ}$ 中值不为 $0$ 的键的数量为 $0$，则表示这个窗口中的单词频次和 $\\textit{words}$ 中单词频次相同，窗口的左端点是一个待求的起始位置。划分的方法有 $n$ 种，做 $n$ 次滑动窗口后，即可找到所有的起始位置。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m, n, ls = len(words), len(words[0]), len(s)\n        for i in range(n):\n            if i + m * n > ls:\n                break\n            differ = Counter()\n            for j in range(m):\n                word = s[i + j * n: i + (j + 1) * n]\n                differ[word] += 1\n            for word in words:\n                differ[word] -= 1\n                if differ[word] == 0:\n                    del differ[word]\n            for start in range(i, ls - m * n + 1, n):\n                if start != i:\n                    word = s[start + (m - 1) * n: start + m * n]\n                    differ[word] += 1\n                    if differ[word] == 0:\n                        del differ[word]\n                    word = s[start - n: start]\n                    differ[word] -= 1\n                    if differ[word] == 0:\n                        del differ[word]\n                if len(differ) == 0:\n                    res.append(start)\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<Integer>();\n        int m = words.length, n = words[0].length(), ls = s.length();\n        for (int i = 0; i < n; i++) {\n            if (i + m * n > ls) {\n                break;\n            }\n            Map<String, Integer> differ = new HashMap<String, Integer>();\n            for (int j = 0; j < m; j++) {\n                String word = s.substring(i + j * n, i + (j + 1) * n);\n                differ.put(word, differ.getOrDefault(word, 0) + 1);\n            }\n            for (String word : words) {\n                differ.put(word, differ.getOrDefault(word, 0) - 1);\n                if (differ.get(word) == 0) {\n                    differ.remove(word);\n                }\n            }\n            for (int start = i; start < ls - m * n + 1; start += n) {\n                if (start != i) {\n                    String word = s.substring(start + (m - 1) * n, start + m * n);\n                    differ.put(word, differ.getOrDefault(word, 0) + 1);\n                    if (differ.get(word) == 0) {\n                        differ.remove(word);\n                    }\n                    word = s.substring(start - n, start);\n                    differ.put(word, differ.getOrDefault(word, 0) - 1);\n                    if (differ.get(word) == 0) {\n                        differ.remove(word);\n                    }\n                }\n                if (differ.isEmpty()) {\n                    res.add(start);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> FindSubstring(string s, string[] words) {\n        IList<int> res = new List<int>();\n        int m = words.Length, n = words[0].Length, ls = s.Length;\n        for (int i = 0; i < n; i++) {\n            if (i + m * n > ls) {\n                break;\n            }\n            Dictionary<string, int> differ = new Dictionary<string, int>();\n            for (int j = 0; j < m; j++) {\n                string word = s.Substring(i + j * n, n);\n                if (!differ.ContainsKey(word)) {\n                    differ.Add(word, 0);\n                }\n                differ[word]++;\n            }\n            foreach (string word in words) {\n                if (!differ.ContainsKey(word)) {\n                    differ.Add(word, 0);\n                }\n                differ[word]--;\n                if (differ[word] == 0) {\n                    differ.Remove(word);\n                }\n            }\n            for (int start = i; start < ls - m * n + 1; start += n) {\n                if (start != i) {\n                    string word = s.Substring(start + (m - 1) * n, n);\n                    if (!differ.ContainsKey(word)) {\n                        differ.Add(word, 0);\n                    }\n                    differ[word]++;\n                    if (differ[word] == 0) {\n                        differ.Remove(word);\n                    }\n                    word = s.Substring(start - n, n);\n                    if (!differ.ContainsKey(word)) {\n                        differ.Add(word, 0);\n                    }\n                    differ[word]--;\n                    if (differ[word] == 0) {\n                        differ.Remove(word);\n                    }\n                }\n                if (differ.Count == 0) {\n                    res.Add(start);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> findSubstring(string &s, vector<string> &words) {\n        vector<int> res;\n        int m = words.size(), n = words[0].size(), ls = s.size();\n        for (int i = 0; i < n && i + m * n <= ls; ++i) {\n            unordered_map<string, int> differ;\n            for (int j = 0; j < m; ++j) {\n                ++differ[s.substr(i + j * n, n)];\n            }\n            for (string &word: words) {\n                if (--differ[word] == 0) {\n                    differ.erase(word);\n                }\n            }\n            for (int start = i; start < ls - m * n + 1; start += n) {\n                if (start != i) {\n                    string word = s.substr(start + (m - 1) * n, n);\n                    if (++differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                    word = s.substr(start - n, n);\n                    if (--differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                }\n                if (differ.empty()) {\n                    res.emplace_back(start);\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    char key[32];\n    int val;\n    UT_hash_handle hh;\n} HashItem;\n\nint* findSubstring(char * s, char ** words, int wordsSize, int* returnSize){    \n    int m = wordsSize, n = strlen(words[0]), ls = strlen(s);\n    int *res = (int *)malloc(sizeof(int) * ls);\n    int pos = 0;\n    for (int i = 0; i < n; i++) {\n        if (i + m * n > ls) {\n            break;\n        }\n        HashItem *diff = NULL;\n        char word[32] = {0};\n        for (int j = 0; j < m; j++) {\n            snprintf(word, n + 1, \"%s\", s + i + j * n);\n            HashItem * pEntry = NULL;\n            HASH_FIND_STR(diff, word, pEntry);\n            if (NULL == pEntry) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                strcpy(pEntry->key, word);\n                pEntry->val = 0;\n                HASH_ADD_STR(diff, key, pEntry);\n            } \n            pEntry->val++;            \n        }\n        for (int j = 0; j < m; j++) {\n            HashItem * pEntry = NULL;\n            HASH_FIND_STR(diff, words[j], pEntry);\n            if (NULL == pEntry) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                strcpy(pEntry->key, words[j]);\n                pEntry->val = 0;\n                HASH_ADD_STR(diff, key, pEntry);\n            } \n            pEntry->val--;\n            if (pEntry->val == 0) {\n                HASH_DEL(diff, pEntry);\n                free(pEntry);\n            }\n        }\n        for (int start = i; start < ls - m * n + 1; start += n) {\n            if (start != i) {\n                char word[32];\n                snprintf(word, n + 1, \"%s\", s + start + (m - 1) * n);\n                HashItem * pEntry = NULL;\n                HASH_FIND_STR(diff, word, pEntry);\n                if (NULL == pEntry) {\n                    pEntry = (HashItem *)malloc(sizeof(HashItem));\n                    strcpy(pEntry->key, word);\n                    pEntry->val = 0;\n                    HASH_ADD_STR(diff, key, pEntry);\n                } \n                pEntry->val++;\n                if (pEntry->val == 0) {\n                    HASH_DEL(diff, pEntry);\n                    free(pEntry);\n                }\n                snprintf(word, n + 1, \"%s\", s + start - n);\n                pEntry = NULL;\n                HASH_FIND_STR(diff, word, pEntry);\n                if (NULL == pEntry) {\n                    pEntry = (HashItem *)malloc(sizeof(HashItem));\n                    strcpy(pEntry->key, word);\n                    pEntry->val = 0;\n                    HASH_ADD_STR(diff, key, pEntry);\n                } \n                pEntry->val--;\n                if (pEntry->val == 0) {\n                    HASH_DEL(diff, pEntry);\n                    free(pEntry);\n                }\n            }\n            if (HASH_COUNT(diff) == 0) {\n                res[pos++] = start;\n            }\n        }\n        HashItem *curr, *tmp;\n        HASH_ITER(hh, diff, curr, tmp) {\n            HASH_DEL(diff, curr);  \n            free(curr);      \n        }\n    }\n    *returnSize = pos;\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findSubstring = function(s, words) {\n    const res = [];\n    const m = words.length, n = words[0].length, ls = s.length;\n    for (let i = 0; i < n; i++) {\n        if (i + m * n > ls) {\n            break;\n        }\n        const differ = new Map();\n        for (let j = 0; j < m; j++) {\n            const word = s.substring(i + j * n, i + (j + 1) * n);\n            differ.set(word, (differ.get(word) || 0) + 1);\n        }\n        for (const word of words) {\n            differ.set(word, (differ.get(word) || 0) - 1);\n            if (differ.get(word) === 0) {\n                differ.delete(word);\n            }\n        }\n        for (let start = i; start < ls - m * n + 1; start += n) {\n            if (start !== i) {\n                let word = s.substring(start + (m - 1) * n, start + m * n);\n                differ.set(word, (differ.get(word) || 0) + 1);\n                if (differ.get(word) === 0) {\n                    differ.delete(word);\n                }\n                word = s.substring(start - n, start);\n                differ.set(word, (differ.get(word) || 0) - 1);\n                if (differ.get(word) === 0) {\n                    differ.delete(word);\n                }\n            }\n            if (differ.size === 0) {\n                res.push(start);\n            }\n        }\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc findSubstring(s string, words []string) (ans []int) {\n    ls, m, n := len(s), len(words), len(words[0])\n    for i := 0; i < n && i+m*n <= ls; i++ {\n        differ := map[string]int{}\n        for j := 0; j < m; j++ {\n            differ[s[i+j*n:i+(j+1)*n]]++\n        }\n        for _, word := range words {\n            differ[word]--\n            if differ[word] == 0 {\n                delete(differ, word)\n            }\n        }\n        for start := i; start < ls-m*n+1; start += n {\n            if start != i {\n                word := s[start+(m-1)*n : start+m*n]\n                differ[word]++\n                if differ[word] == 0 {\n                    delete(differ, word)\n                }\n                word = s[start-n : start]\n                differ[word]--\n                if differ[word] == 0 {\n                    delete(differ, word)\n                }\n            }\n            if len(differ) == 0 {\n                ans = append(ans, start)\n            }\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\textit{ls} \\times n)$，其中 $\\textit{ls}$ 是输入 $s$ 的长度，$n$ 是 $\\textit{words}$ 中每个单词的长度。需要做 $n$ 次滑动窗口，每次需要遍历一次 $s$。\n\n- 空间复杂度：$O(m \\times n)$，其中 $m$ 是 $\\textit{words}$ 的单词数，$n$ 是 $\\textit{words}$ 中每个单词的长度。每次滑动窗口时，需要用一个哈希表保存单词频次。"
}