{
	"titleSlug": "distance-between-bus-stops",
	"slug": "gong-jiao-zhan-jian-de-ju-chi-by-leetcod-o737",
	"url": "https://leetcode-cn.com/problems/distance-between-bus-stops/solution/gong-jiao-zhan-jian-de-ju-chi-by-leetcod-o737/",
	"content": "#### 方法一：一次遍历\n\n记数组 $\\textit{distance}$ 的长度为 $n$。假设 $\\textit{start} \\le \\textit{destination}$，那么我们可以：\n\n- 从 $\\textit{start}$ 到 $\\textit{destination}$，距离为 $\\sum\\limits_{i=\\textit{start}}^{\\textit{destination}-1}\\textit{distance}[i]$；\n- 从 $\\textit{start}$ 到 $0$，再从 $0$ 到 $\\textit{destination}$，距离为 $\\sum\\limits_{i=0}^{\\textit{start}-1}\\textit{distance}[i]+\\sum\\limits_{i=\\textit{destination}}^{n-1}\\textit{distance}[i]$。\n\n答案为这两个距离的最小值。\n\n```Python [sol1-Python3]\nclass Solution:\n    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:\n        if start > destination:\n            start, destination = destination, start\n        return min(sum(distance[start:destination]), sum(distance[:start]) + sum(distance[destination:]))\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n        if (start > destination) {\n            swap(start, destination);\n        }\n        return min(accumulate(distance.begin() + start, distance.begin() + destination, 0),\n                   accumulate(distance.begin(), distance.begin() + start, 0) +\n                   accumulate(distance.begin() + destination, distance.end(), 0));\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int distanceBetweenBusStops(int[] distance, int start, int destination) {\n        if (start > destination) {\n            int temp = start;\n            start = destination;\n            destination = temp;\n        }\n        int sum1 = 0, sum2 = 0;\n        for (int i = 0; i < distance.length; i++) {\n            if (i >= start && i < destination) {\n                sum1 += distance[i];\n            } else {\n                sum2 += distance[i];\n            }\n        }\n        return Math.min(sum1, sum2);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int DistanceBetweenBusStops(int[] distance, int start, int destination) {\n        if (start > destination) {\n            int temp = start;\n            start = destination;\n            destination = temp;\n        }\n        int sum1 = 0, sum2 = 0;\n        for (int i = 0; i < distance.Length; i++) {\n            if (i >= start && i < destination) {\n                sum1 += distance[i];\n            } else {\n                sum2 += distance[i];\n            }\n        }\n        return Math.Min(sum1, sum2);\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc distanceBetweenBusStops(distance []int, start, destination int) int {\n    if start > destination {\n        start, destination = destination, start\n    }\n    sum1, sum2 := 0, 0\n    for i, d := range distance {\n        if start <= i && i < destination {\n            sum1 += d\n        } else {\n            sum2 += d\n        }\n    }\n    return min(sum1, sum2)\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination){\n    if (start > destination) {\n        int temp = start;\n        start = destination;\n        destination = temp;\n    }\n    int sum1 = 0, sum2 = 0;\n    for (int i = 0; i < distanceSize; i++) {\n        if (i >= start && i < destination) {\n            sum1 += distance[i];\n        } else {\n            sum2 += distance[i];\n        }\n    }\n    return MIN(sum1, sum2);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar distanceBetweenBusStops = function(distance, start, destination) {\n    if (start > destination) {\n        const temp = start;\n        start = destination;\n        destination = temp;\n    }\n    let sum1 = 0, sum2 = 0;\n    for (let i = 0; i < distance.length; i++) {\n        if (i >= start && i < destination) {\n            sum1 += distance[i];\n        } else {\n            sum2 += distance[i];\n        }\n    }\n    return Math.min(sum1, sum2);\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{distance}$ 的长度。\n\n- 空间复杂度：$O(1)$，只需要额外的常数级别的空间。"
}