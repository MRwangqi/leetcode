{
	"titleSlug": "minimum-sum-of-four-digit-number-after-splitting-digits",
	"slug": "chai-fen-shu-wei-hou-si-wei-shu-zi-de-zu-6awh",
	"url": "https://leetcode-cn.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/solution/chai-fen-shu-wei-hou-si-wei-shu-zi-de-zu-6awh/",
	"content": "#### 方法一：贪心\n\n**提示 $1$**\n\n如果两个整数位数**不相同**，那么将位数较高的整数的最高位添加至位数较低的整数的最高位之前，两个整数之和不会变大。\n\n**提示 $1$ 解释**\n\n假设两个整数的位数分别为 $n_1, n_2 (n_1 > n_2)$，该位数为 $d$，那么变化前，该位数对两数之和的贡献为 $d \\times 10^{n_1}$；变化后为 $d \\times 10^{n_2+1} \\le d \\times 10^{n_1}$。\n\n**提示 $2$**\n\n在不改变位数的情况下，我们应当把**较小的数值放在较高位**。\n\n**提示 $2$ 解释**\n\n我们用单个两位整数为例。假设 $\\textit{new}_1$ 的个位与十位分别为 $d_1, d_2 (d_1 < d_2)$。那么交换前，$\\textit{new}_1 = 10 \\times d_2 + d_1$；交换后则为 $10 \\times d_1 + d_2 < 10 \\times d_2 + d_1$。\n\n**思路与算法**\n\n根据提示，我们需要将 $\\textit{num}$ 中较小的两位作为 $\\textit{new}_1$ 和 $\\textit{new}_2$ 的十位，而将较大的两位作为个位，这样可以使得 $\\textit{new}_1 + \\textit{new}_2$ 最小。\n\n我们首先用数组 $\\textit{digits}$ 存储 $\\textit{num}$ 的每位数值，并升序排序，此时，最小的和即为 \n\n$$\n10 \\times (\\textit{digits}[0] + \\textit{digits}[1]) + \\textit{digits}[2] + \\textit{digits}[3].\n$$\n\n我们返回该值作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minimumSum(int num) {\n        vector<int> digits;\n        while (num) {\n            digits.push_back(num % 10);\n            num /= 10;\n        }\n        sort(digits.begin(), digits.end());\n        return 10 * (digits[0] + digits[1]) + digits[2] + digits[3];\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        digits = []\n        while num:\n            digits.append(num % 10)\n            num //= 10\n        digits.sort()\n        return 10 * (digits[0] + digits[1]) + digits[2] + digits[3]\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$。\n\n- 空间复杂度：$O(1)$。"
}