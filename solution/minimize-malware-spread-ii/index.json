{
	"titleSlug": "minimize-malware-spread-ii",
	"slug": "jin-liang-jian-shao-e-yi-ruan-jian-de-chuan-bo-ii-",
	"url": "https://leetcode-cn.com/problems/minimize-malware-spread-ii/solution/jin-liang-jian-shao-e-yi-ruan-jian-de-chuan-bo-ii-/",
	"content": "#### 方法一： 深度优先搜索\n\n**思路和算法**\n\n首先构建一个图 `G`，其节点为所有不在 `initial` 中的剩余节点。\n\n对于不在 `initial` 中的节点 `v`，检查会被 `initial` 中哪些节点 `u` 感染。 之后再看哪些节点 `v` 只会被一个节点 `u` 感染。具体的算法可以看代码中的注释。\n\n```java [solution1-Java]\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        int[] clean = new int[N];\n        Arrays.fill(clean, 1);\n        for (int x: initial)\n            clean[x] = 0;\n\n        // For each node u in initial, dfs to find\n        // 'seen': all nodes not in initial that it can reach.\n        ArrayList<Integer>[] infectedBy = new ArrayList[N];\n        for (int i = 0; i < N; ++i)\n            infectedBy[i] = new ArrayList();\n\n        for (int u: initial) {\n            Set<Integer> seen = new HashSet();\n            dfs(graph, clean, u, seen);\n            for (int v: seen)\n                infectedBy[v].add(u);\n        }\n\n        // For each node u in initial, for every v not in initial\n        // that is uniquely infected by u, add 1 to the contribution for u.\n        int[] contribution = new int[N];\n        for (int v = 0; v < N; ++v)\n            if (infectedBy[v].size() == 1)\n                contribution[infectedBy[v].get(0)]++;\n\n        // Take the best answer.\n        Arrays.sort(initial);\n        int ans = initial[0], ansSize = -1;\n        for (int u: initial) {\n            int score = contribution[u];\n            if (score > ansSize || score == ansSize && u < ans) {\n                ans = u;\n                ansSize = score;\n            }\n        }\n        return ans;\n    }\n\n    public void dfs(int[][] graph, int[] clean, int u, Set<Integer> seen) {\n        for (int v = 0; v < graph.length; ++v)\n            if (graph[u][v] == 1 && clean[v] == 1 && !seen.contains(v)) {\n                seen.add(v);\n                dfs(graph, clean, v, seen);\n            }\n    }\n}\n```\n\n```python [solution1-Python]\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        N = len(graph)\n        clean = set(range(N)) - set(initial)\n        def dfs(u, seen):\n            for v, adj in enumerate(graph[u]):\n                if adj and v in clean and v not in seen:\n                    seen.add(v)\n                    dfs(v, seen)\n\n        # For each node u in initial, dfs to find\n        # 'seen': all nodes not in initial that it can reach.\n        infected_by = {v: [] for v in clean}\n        for u in initial:\n            seen = set()\n            dfs(u, seen)\n\n            # For each node v that was seen, u infects v.\n            for v in seen:\n                infected_by[v].append(u)\n\n        # For each node u in initial, for every v not in initial\n        # that is uniquely infected by u, add 1 to the contribution for u.\n        contribution = collections.Counter()\n        for v, neighbors in infected_by.iteritems():\n            if len(neighbors) == 1:\n                contribution[neighbors[0]] += 1\n\n        # Take the best answer.\n        best = (-1, min(initial))\n        for u, score in contribution.iteritems():\n            if score > best[0] or score == best[0] and u < best[1]:\n                best = score, u\n        return best[1]\n```\n\n**复杂度分析**\n\n* 时间复杂度： $O(N^2)$，其中 $N$ 为 `graph` 的大小。\n\n* 空间复杂度： $O(N)$。\n\n\n#### 方法二： 并查集\n\n**思路**\n\n对于并查集中的一个集合，集合中会有一定数量的节点在 `initial` 里面，只需要关注那些只有一个 `initial` 节点的集合就可以了。 \n\n**算法**\n\n首先构建一个图 `G`，其节点为所有不在 `initial` 中的剩余节点。然后用并查集找出所有的连通分量。\n\n对于原始图中的每条边 `n => v`，`u` 为 `initial` 中的节点，`v` 为不在 `initial` 中的节点。对于 `initial` 中的每个节点 `u`，如果 `u` 所在的集合中只有它是唯一的 `initial` 节点，那么这个集合的大小就是移除 `u` 之后能得到的收益。\n\n之后遍历所有的可能找到最终答案。\n\n```java [solution2-Java]\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        DSU dsu = new DSU(N);\n\n        // clean[u] == 1 if its a node in the graph not in initial.\n        int[] clean = new int[N];\n        Arrays.fill(clean, 1);\n        for (int x: initial) clean[x] = 0;\n\n        for (int u = 0; u < N; ++u) if (clean[u] == 1)\n            for (int v = 0; v < N; ++v) if (clean[v] == 1)\n                if (graph[u][v] == 1)\n                    dsu.union(u, v);\n\n        // dsu now represents the components of the graph without\n        // any nodes from initial.  Let's call this graph G.\n        int[] count = new int[N];\n        Map<Integer, Set<Integer>> nodeToCompo = new HashMap();\n        for (int u: initial) {\n            Set<Integer> components = new HashSet();\n            for (int v = 0; v < N; ++v) if (clean[v] == 1) {\n                if (graph[u][v] == 1)\n                    components.add(dsu.find(v));\n            }\n\n            nodeToCompo.put(u, components);\n            for (int c: components)\n                count[c]++;\n        }\n\n        // For each node u in initial, nodeToCompo.get(u)\n        // now has every component from G that u neighbors.\n\n        int ans = -1, ansSize = -1;\n        for (int u: nodeToCompo.keySet()) {\n            Set<Integer> components = nodeToCompo.get(u);\n            int score = 0;\n            for (int c: components)\n                if (count[c] == 1) // uniquely infected\n                    score += dsu.size(c);\n\n            if (score > ansSize || score == ansSize && u < ans) {\n                ansSize = score;\n                ans = u;\n            }\n        }\n\n        return ans;\n    }\n}\n\n\nclass DSU {\n    int[] p, sz;\n\n    DSU(int N) {\n        p = new int[N];\n        for (int x = 0; x < N; ++x)\n            p[x] = x;\n\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n\n    public int find(int x) {\n        if (p[x] != x)\n            p[x] = find(p[x]);\n        return p[x];\n    }\n\n    public void union(int x, int y) {\n        int xr = find(x);\n        int yr = find(y);\n        p[xr] = yr;\n        sz[yr] += sz[xr];\n    }\n\n    public int size(int x) {\n        return sz[find(x)];\n    }\n}\n```\n\n```python [solutiion2-Python]\nclass DSU:\n    def __init__(self, N):\n        self.p = range(N)\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        self.p[xr] = yr\n        self.sz[yr] += self.sz[xr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\n\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        N = len(graph)\n        initial_set = set(initial)\n        clean = [x for x in range(N) if x not in initial_set]\n\n        # clean[u] == 1 if its a node in the graph not in initial.\n        dsu = DSU(N)\n        for u in clean:\n            for v in clean:\n                if graph[u][v]:\n                    dsu.union(u, v)\n\n        # dsu now represents the components of the graph without\n        # any nodes from initial.  Let's call this graph G.\n        count = collections.Counter()\n        node_to_compo = {}\n        for u in initial:\n            components = set()\n            for v in clean:\n                if graph[u][v]:\n                    components.add(dsu.find(v))\n            node_to_compo[u] = components\n\n            for c in components:\n                count[c] += 1\n\n        # For each node u in initial, nodeToCompo.get(u)\n        # now has every component from G that u neighbors.\n\n        best = (-1, None) # score, node\n        for u, components in node_to_compo.iteritems():\n            score = 0\n            for c in components:\n                if count[c] == 1: #uniquely infected\n                    score += dsu.size(c)\n            if score > best[0] or score == best[0] and u < best[1]:\n                best = (score, u)\n\n        return best[1]\n```\n\n**复杂度分析**\n\n* 时间复杂度： $O(N^2)$，其中 $N$ 为 `graph` 的大小。\n\n* 空间复杂度： $O(N)$。"
}