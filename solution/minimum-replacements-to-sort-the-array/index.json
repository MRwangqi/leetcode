{
	"titleSlug": "minimum-replacements-to-sort-the-array",
	"slug": "by-endlesscheng-d11y",
	"url": "https://leetcode-cn.com/problems/minimum-replacements-to-sort-the-array/solution/by-endlesscheng-d11y/",
	"content": "[视频讲解](https://www.bilibili.com/video/bv1gB4y1k7Jz) 已出炉，欢迎点赞三连，在评论区分享你对这场双周赛的看法~\r\n\r\n--- \r\n\r\n#### 提示 1\r\n\r\n每个数字要么不变，要么分成更小的数字。\r\n\r\n#### 提示 2\r\n\r\n最后一个数字需要操作吗？\r\n\r\n不需要，如果操作，前面的数字就需要变得更小，这会让操作次数增多。\r\n\r\n#### 提示 3\r\n\r\n倒着遍历 $\\textit{nums}$。设当前操作出的最小值为 $m$，如果 $\\textit{nums}[i]>m$，那么需要拆分 $\\textit{nums}[i]$，使得拆分出的数字的最大值不超过 $m$。\r\n\r\n设拆分出了 $x$ 个数字，由于这 $x$ 个数字都不超过 $m$，即\r\n\r\n$$\r\n\\textit{nums}[i] = v_1+v_2+\\cdots+v_x \\le m+m+\\cdots+m = mx\r\n$$ \r\n \r\n得 \r\n\r\n$$\r\nx\\ge\\left\\lceil\\dfrac{\\textit{nums}[i]}{m}\\right\\rceil\r\n$$\r\n\r\n为了使操作次数尽量小，应取等号，即\r\n\r\n$$\r\nx=\\left\\lceil\\dfrac{\\textit{nums}[i]}{m}\\right\\rceil\r\n$$\r\n\r\n操作次数为 $k=x-1$。\r\n\r\n为了使拆分出的数字的最小值尽可能地大，拆分出的最小数字应为 $\\left\\lfloor\\dfrac{\\textit{nums}[i]}{x}\\right\\rfloor$，证明如下：\r\n\r\n> 若这 $x$ 个数均为 $\\left\\lfloor\\dfrac{\\textit{nums}[i]}{x}\\right\\rfloor$，那么有\r\n> $$\r\n> x\\left\\lfloor\\dfrac{\\textit{nums}[i]}{x}\\right\\rfloor\\le \\textit{nums}[i]\r\n> $$\r\n> 若这 $x$ 个数均为 $\\left\\lfloor\\dfrac{\\textit{nums}[i]}{x}\\right\\rfloor+1$，那么有\r\n> $$\r\n> x\\left(\\left\\lfloor\\dfrac{\\textit{nums}[i]}{x}\\right\\rfloor+1\\right)\\ge x\\left\\lceil\\dfrac{\\textit{nums}[i]}{x}\\right\\rceil \\ge \\textit{nums}[i]\r\n> $$\r\n> 联合得到\r\n> $$\r\n> x\\left\\lfloor\\dfrac{\\textit{nums}[i]}{x}\\right\\rfloor\\le \\textit{nums}[i]\\le x\\left(\\left\\lfloor\\dfrac{\\textit{nums}[i]}{x}\\right\\rfloor+1\\right)\r\n> $$\r\n> 据此，我们可以给出一个拆分方案：将这 $x$ 个数均初始化为 $\\left\\lfloor\\dfrac{\\textit{nums}[i]}{x}\\right\\rfloor$，然后给其中的 $\\textit{nums}[i]-x\\left\\lfloor\\dfrac{\\textit{nums}[i]}{x}\\right\\rfloor$ 个数字加一，这样可以使这 $x$ 数的和恰好为 $\\textit{nums}[i]$。上面的不等式说明这样的方案是存在的。\r\n\r\n代码实现时，无需判断 $\\textit{nums}[i]$ 与 $m$ 的大小关系。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{nums}$ 的长度。\r\n- 空间复杂度：$O(1)$，仅用到若干额外变量。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def minimumReplacement(self, nums: List[int]) -> int:\r\n        ans, m = 0, nums[-1]\r\n        for num in reversed(nums):\r\n            k = (num - 1) // m\r\n            ans += k\r\n            m = num // (k + 1)\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public long minimumReplacement(int[] nums) {\r\n        var ans = 0L;\r\n        var m = nums[nums.length - 1];\r\n        for (var i = nums.length - 2; i >= 0; --i) {\r\n            var k = (nums[i] - 1) / m;\r\n            ans += k;\r\n            m = nums[i] / (k + 1);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    long long minimumReplacement(vector<int> &nums) {\r\n        long ans = 0L;\r\n        int m = nums.back();\r\n        for (int i = int(nums.size()) - 2; i >= 0; --i) {\r\n            int k = (nums[i] - 1) / m;\r\n            ans += k;\r\n            m = nums[i] / (k + 1);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc minimumReplacement(nums []int) (ans int64) {\r\n\tm := nums[len(nums)-1]\r\n\tfor i := len(nums) - 2; i >= 0; i-- {\r\n\t\tk := (nums[i] - 1) / m\r\n\t\tans += int64(k)\r\n\t\tm = nums[i] / (k + 1)\r\n\t}\r\n\treturn\r\n}\r\n```\r\n\r\n#### 思考题\r\n\r\n每个数字需要拆分成若干**整数**（目前题目没有说清楚这一点，读者可以通过测试 $[5,5,3]$ 这个输入来确认，预期结果为 $3$）。\r\n\r\n如果可以拆分成实数，答案会是多少呢？比如 $[5,5,3]$ 可以拆分成 $[2.5,2.5,2.5,2.5,3]$，答案为 $2$。\r\n\r\n如何在计算过程中避免使用浮点数？\r\n"
}