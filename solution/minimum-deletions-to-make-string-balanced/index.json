{
	"titleSlug": "minimum-deletions-to-make-string-balanced",
	"slug": "1653-by-exciting-tesladmw-wtz3",
	"url": "https://leetcode-cn.com/problems/minimum-deletions-to-make-string-balanced/solution/1653-by-exciting-tesladmw-wtz3/",
	"content": "# 解法1：前缀和\r\n\r\n思路：\r\n1. 分别记录$a,b$词频的前缀和；\r\n2. 遍历所有分割点$[0,n]$，取分割点前字符串中$b$的数量+分割点后字符串中$a$的数量的最小值\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    int minimumDeletions(string s) {\r\n        // 前缀和解法\r\n        int n = s.length();\r\n        vector<int> sumA(n+1);\r\n        vector<int> sumB(n+1);\r\n        for (int i = 0; i < n; ++i) {\r\n            sumA[i+1] = sumA[i] + (s[i] == 'a');\r\n            sumB[i+1] = sumB[i] + (s[i] == 'b');\r\n        }\r\n        int ans = sumB[0] + sumA[n];\r\n        for (int i = 1; i <= n; ++i) {\r\n            ans = min(ans, sumB[i] + sumA[n] - sumA[i]);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n时间复杂度：$O(N)$\r\n\r\n空间复杂度：$O(N)$\r\n\r\n# 解法2：动态规划\r\n\r\n思路：\r\n1. 如果$s_i == b$，则$dp_i = dp_{i-1}$，因为第$i$个元素不需要动\r\n2. 如果$s_i == a$，则有两种可能：把$i$之前的所有$b$都变成$a$，或者把$i$位置的$a$变成$b$，即$dp_i = \\min\\{b_count, dp_{i-1}+1\\}$\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    int minimumDeletions(string s) {\r\n        // dp解法\r\n        int n = s.length(), sumB = (s[0] == 'b');\r\n        vector<int> dp(n);\r\n        for (int i = 1; i < n; ++i) {\r\n            if (s[i] == 'b') {\r\n                dp[i] = dp[i-1];\r\n                sumB++;\r\n            } else {\r\n                dp[i] = min(dp[i-1]+1, sumB);\r\n            }\r\n        }\r\n        return dp[n-1];\r\n    }\r\n};\r\n```\r\n时间复杂度：$O(N)$\r\n\r\n空间复杂度：$O(N)$\r\n\r\n\r\n# 解法3：栈\r\n\r\n其实栈的解法和动态规划有联系\r\n\r\n思路：\r\n1. 其实就是统计可配对的$ba$对数，因为只要出现了$b$在$a$之前，那么就一定要变换。如果$ba$对之前有多余的$b$，那么变换一定是将$a$变成$b$；否则就是$b$变成$a$。例如：\r\n    $e.g.1$ $aababbbabbbba$共有3个$ba$对，第一对需要翻转$b$，第二、三对需要翻转$a$，因为它们之前都有多余的$b$\r\n2. 使用一个栈来存储$b$，遇到$a$时出栈(如果栈不为空)，且$ans++$\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    int minimumDeletions(string s) {\r\n        // 栈解法\r\n        int n = s.length(), ans = 0;\r\n        stack<char> st;\r\n        for (auto ch : s) {\r\n            if (ch == 'b') st.push(ch);\r\n            else if (!st.empty()) {\r\n                st.pop();\r\n                ans++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n时间复杂度：$O(N)$\r\n\r\n空间复杂度：$O(N)$\r\n\r\n解法2和3空间复杂度可以优化到$O(1)$\r\n\r\n菜鸡题解，仅供个人记录。\r\n\r\n\r\n"
}