{
	"titleSlug": "longest-nice-subarray",
	"slug": "bao-li-mei-ju-pythonjavacgo-by-endlessch-z6t6",
	"url": "https://leetcode-cn.com/problems/longest-nice-subarray/solution/bao-li-mei-ju-pythonjavacgo-by-endlessch-z6t6/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1Dt4y1j7qh) 已出炉，欢迎素质三连，在评论区分享你对这场周赛的看法~\r\n \r\n---\r\n\r\n由于所有元素对按位与均为 $0$，在优雅子数组中的从低到高的第 $i$ 个比特位上，至多有一个比特 $1$，其余均为比特 $0$。\r\n\r\n因此在本题数据范围下，优雅子数组的长度不会超过 30。\r\n\r\n暴力枚举即可。\r\n\r\n代码实现时可以把在优雅子数组中的元素**按位或**起来，这样可以 $O(1)$ 判断当前元素是否与前面的元素按位与的结果为 $0$。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\log\\max(\\textit{nums}))$，其中 $n$ 为 $\\textit{nums}$ 的长度。\r\n- 空间复杂度：$O(1)$，仅用到若干变量。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def longestNiceSubarray(self, nums: List[int]) -> int:\r\n        ans = 0\r\n        for i, or_ in enumerate(nums):\r\n            j = i - 1\r\n            while j >= 0 and (or_ & nums[j]) == 0:\r\n                or_ |= nums[j]\r\n                j -= 1\r\n            ans = max(ans, i - j)\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int longestNiceSubarray(int[] nums) {\r\n        int ans = 0;\r\n        for (int i = 0; i < nums.length; ++i) {\r\n            int or = 0, j = i;\r\n            while (j >= 0 && (or & nums[j]) == 0)\r\n                or |= nums[j--];\r\n            ans = Math.max(ans, i - j);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int longestNiceSubarray(vector<int> &nums) {\r\n        int ans = 0;\r\n        for (int i = 0; i < nums.size(); ++i) {\r\n            int or_ = 0, j = i;\r\n            while (j >= 0 && (or_ & nums[j]) == 0)\r\n                or_ |= nums[j--];\r\n            ans = max(ans, i - j);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc longestNiceSubarray(nums []int) (ans int) {\r\n\tfor i, or := range nums {\r\n\t\tj := i - 1\r\n\t\tfor ; j >= 0 && or&nums[j] == 0; j-- {\r\n\t\t\tor |= nums[j]\r\n\t\t}\r\n\t\tans = max(ans, i-j)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n进一步地，由于优雅子数组的所有元素按位与均为 $0$（可以理解成这些二进制数对应的集合没有交集），我们可以用双指针来优化上述过程，如果当前 $\\textit{or}$ 与 $\\textit{nums}[\\textit{right}]$ 按位与的结果不为 $0$，则从 $\\textit{or}$ 中去掉 $\\textit{nums}[\\textit{left}]$，并将 $\\textit{left}$ 右移。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{nums}$ 的长度。\r\n- 空间复杂度：$O(1)$，仅用到若干变量。\r\n\r\n```py [sol2-Python3]\r\nclass Solution:\r\n    def longestNiceSubarray(self, nums: List[int]) -> int:\r\n        ans = left = or_ = 0\r\n        for right, x in enumerate(nums):\r\n            while or_ & x:\r\n                or_ ^= nums[left]\r\n                left += 1\r\n            or_ |= x\r\n            ans = max(ans, right - left + 1)\r\n        return ans\r\n```\r\n\r\n```java [sol2-Java]\r\nclass Solution {\r\n    public int longestNiceSubarray(int[] nums) {\r\n        int ans = 0;\r\n        for (int left = 0, right = 0, or = 0; right < nums.length; right++) {\r\n            while ((or & nums[right]) > 0)\r\n                or ^= nums[left++];\r\n            or |= nums[right];\r\n            ans = Math.max(ans, right - left + 1);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol2-C++]\r\nclass Solution {\r\npublic:\r\n    int longestNiceSubarray(vector<int> &nums) {\r\n        int ans = 0;\r\n        for (int left = 0, right = 0, or_ = 0; right < nums.size(); right++) {\r\n            while (or_ & nums[right])\r\n                or_ ^= nums[left++];\r\n            or_ |= nums[right];\r\n            ans = max(ans, right - left + 1);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\nfunc longestNiceSubarray(nums []int) (ans int) {\r\n\tleft, or := 0, 0\r\n\tfor right, x := range nums {\r\n\t\tfor or&x > 0 {\r\n\t\t\tor ^= nums[left]\r\n\t\t\tleft += 1\r\n\t\t}\r\n\t\tor |= x\r\n\t\tans = max(ans, right-left+1)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n"
}