{
	"titleSlug": "first-unique-character-in-a-string",
	"slug": "zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok",
	"url": "https://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/",
	"content": "#### 方法一：使用哈希表存储频数\n\n**思路与算法**\n\n我们可以对字符串进行两次遍历。\n\n在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回 $-1$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        unordered_map<int, int> frequency;\n        for (char ch: s) {\n            ++frequency[ch];\n        }\n        for (int i = 0; i < s.size(); ++i) {\n            if (frequency[s[i]] == 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int firstUniqChar(String s) {\n        Map<Character, Integer> frequency = new HashMap<Character, Integer>();\n        for (int i = 0; i < s.length(); ++i) {\n            char ch = s.charAt(i);\n            frequency.put(ch, frequency.getOrDefault(ch, 0) + 1);\n        }\n        for (int i = 0; i < s.length(); ++i) {\n            if (frequency.get(s.charAt(i)) == 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        frequency = collections.Counter(s)\n        for i, ch in enumerate(s):\n            if frequency[ch] == 1:\n                return i\n        return -1\n```\n\n```JavaScript [sol1-JavaScript]\nvar firstUniqChar = function(s) {\n    const frequency = _.countBy(s);\n    for (const [i, ch] of Array.from(s).entries()) {\n        if (frequency[ch] === 1) {\n            return i;\n        }\n    }\n    return -1;\n};\n```\n\n```Go [sol1-Golang]\nfunc firstUniqChar(s string) int {\n    cnt := [26]int{}\n    for _, ch := range s {\n        cnt[ch-'a']++\n    }\n    for i, ch := range s {\n        if cnt[ch-'a'] == 1 {\n            return i\n        }\n    }\n    return -1\n}\n```\n\n```C [sol1-C]\nstruct hashTable {\n    int key;\n    int val;\n    UT_hash_handle hh;\n};\n\nint firstUniqChar(char* s) {\n    struct hashTable* frequency = NULL;\n    int n = strlen(s);\n    for (int i = 0; i < n; i++) {\n        int ikey = s[i];\n        struct hashTable* tmp;\n        HASH_FIND_INT(frequency, &ikey, tmp);\n        if (tmp == NULL) {\n            tmp = malloc(sizeof(struct hashTable));\n            tmp->key = ikey;\n            tmp->val = 1;\n            HASH_ADD_INT(frequency, key, tmp);\n        } else {\n            tmp->val++;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        int ikey = s[i];\n        struct hashTable* tmp;\n        HASH_FIND_INT(frequency, &ikey, tmp);\n        if (tmp != NULL && tmp->val == 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。我们需要进行两次遍历。\n\n- 空间复杂度：$O(|\\Sigma|)$，其中 $\\Sigma$ 是字符集，在本题中 $s$ 只包含小写字母，因此 $|\\Sigma| \\leq 26$。我们需要 $O(|\\Sigma|)$ 的空间存储哈希映射。\n\n#### 方法二：使用哈希表存储索引\n\n**思路与算法**\n\n我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。\n\n具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 $-1$（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 $c$，如果 $c$ 不在哈希映射中，我们就将 $c$ 与它的索引作为一个键值对加入哈希映射中，否则我们将 $c$ 在哈希映射中对应的值修改为 $-1$。\n\n在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 $-1$ 的最小值，即为第一个不重复字符的索引。如果哈希映射中的所有值均为 $-1$，我们就返回 $-1$。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        unordered_map<int, int> position;\n        int n = s.size();\n        for (int i = 0; i < n; ++i) {\n            if (position.count(s[i])) {\n                position[s[i]] = -1;\n            }\n            else {\n                position[s[i]] = i;\n            }\n        }\n        int first = n;\n        for (auto [_, pos]: position) {\n            if (pos != -1 && pos < first) {\n                first = pos;\n            }\n        }\n        if (first == n) {\n            first = -1;\n        }\n        return first;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int firstUniqChar(String s) {\n        Map<Character, Integer> position = new HashMap<Character, Integer>();\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            char ch = s.charAt(i);\n            if (position.containsKey(ch)) {\n                position.put(ch, -1);\n            } else {\n                position.put(ch, i);\n            }\n        }\n        int first = n;\n        for (Map.Entry<Character, Integer> entry : position.entrySet()) {\n            int pos = entry.getValue();\n            if (pos != -1 && pos < first) {\n                first = pos;\n            }\n        }\n        if (first == n) {\n            first = -1;\n        }\n        return first;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        position = dict()\n        n = len(s)\n        for i, ch in enumerate(s):\n            if ch in position:\n                position[ch] = -1\n            else:\n                position[ch] = i\n        first = n\n        for pos in position.values():\n            if pos != -1 and pos < first:\n                first = pos\n        if first == n:\n            first = -1\n        return first\n```\n\n\n```JavaScript [sol2-JavaScript]\nvar firstUniqChar = function(s) {\n    const position = new Map();\n    const n = s.length;\n    for (let [i, ch] of Array.from(s).entries()) {\n        if (position.has(ch)) {\n            position.set(ch, -1);\n        } else {\n            position.set(ch, i);\n        }\n    }\n    let first = n;\n    for (let pos of position.values()) {\n        if (pos !== -1 && pos < first) {\n            first = pos;\n        }\n    }\n    if (first === n) {\n        first = -1;\n    }\n    return first;\n};\n```\n\n```Go [sol2-Golang]\nfunc firstUniqChar(s string) int {\n    n := len(s)\n    pos := [26]int{}\n    for i := range pos[:] {\n        pos[i] = n\n    }\n    for i, ch := range s {\n        ch -= 'a'\n        if pos[ch] == n {\n            pos[ch] = i\n        } else {\n            pos[ch] = n + 1\n        }\n    }\n    ans := n\n    for _, p := range pos[:] {\n        if p < ans {\n            ans = p\n        }\n    }\n    if ans < n {\n        return ans\n    }\n    return -1\n}\n```\n\n```C [sol2-C]\nstruct hashTable {\n    int key;\n    int val;\n    UT_hash_handle hh;\n};\n\nint firstUniqChar(char* s) {\n    struct hashTable* position = NULL;\n    int n = strlen(s);\n    for (int i = 0; i < n; ++i) {\n        int ikey = s[i];\n        struct hashTable* tmp;\n        HASH_FIND_INT(position, &ikey, tmp);\n        if (tmp != NULL) {\n            tmp->val = -1;\n        } else {\n            tmp = malloc(sizeof(struct hashTable));\n            tmp->key = ikey;\n            tmp->val = i;\n            HASH_ADD_INT(position, key, tmp);\n        }\n    }\n\n    int first = n;\n    struct hashTable *iter, *tmp;\n    HASH_ITER(hh, position, iter, tmp) {\n        int pos = iter->val;\n        if (pos != -1 && pos < first) {\n            first = pos;\n        }\n    }\n    if (first == n) {\n        first = -1;\n    }\n    return first;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。第一次遍历字符串的时间复杂度为 $O(n)$，第二次遍历哈希映射的时间复杂度为 $O(|\\Sigma|)$，由于 $s$ 包含的字符种类数一定小于 $s$ 的长度，因此 $O(|\\Sigma|)$ 在渐进意义下小于 $O(n)$，可以忽略。\n\n- 空间复杂度：$O(|\\Sigma|)$，其中 $\\Sigma$ 是字符集，在本题中 $s$ 只包含小写字母，因此 $|\\Sigma| \\leq 26$。我们需要 $O(|\\Sigma|)$ 的空间存储哈希映射。\n\n#### 方法三：队列\n\n**思路与算法**\n\n我们也可以借助队列找到第一个不重复的字符。队列具有「先进先出」的性质，因此很适合用来找出第一个满足某个条件的元素。\n\n具体地，我们使用与方法二相同的哈希映射，并且使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。当我们对字符串进行遍历时，设当前遍历到的字符为 $c$，如果 $c$ 不在哈希映射中，我们就将 $c$ 与它的索引作为一个二元组放入队尾，否则我们就需要检查队列中的元素是否都满足「只出现一次」的要求，即我们不断地根据哈希映射中存储的值（是否为 $-1$）选择弹出队首的元素，直到队首元素「真的」只出现了一次或者队列为空。\n\n在遍历完成后，如果队列为空，说明没有不重复的字符，返回 $-1$，否则队首的元素即为第一个不重复的字符以及其索引的二元组。\n\n**小贴士**\n\n在维护队列时，我们使用了「延迟删除」这一技巧。也就是说，即使队列中有一些字符出现了超过一次，但它只要不位于队首，那么就不会对答案造成影响，我们也就可以不用去删除它。只有当它前面的所有字符被移出队列，它成为队首时，我们才需要将它移除。\n\n**代码**\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        unordered_map<char, int> position;\n        queue<pair<char, int>> q;\n        int n = s.size();\n        for (int i = 0; i < n; ++i) {\n            if (!position.count(s[i])) {\n                position[s[i]] = i;\n                q.emplace(s[i], i);\n            }\n            else {\n                position[s[i]] = -1;\n                while (!q.empty() && position[q.front().first] == -1) {\n                    q.pop();\n                }\n            }\n        }\n        return q.empty() ? -1 : q.front().second;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int firstUniqChar(String s) {\n        Map<Character, Integer> position = new HashMap<Character, Integer>();\n        Queue<Pair> queue = new LinkedList<Pair>();\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            char ch = s.charAt(i);\n            if (!position.containsKey(ch)) {\n                position.put(ch, i);\n                queue.offer(new Pair(ch, i));\n            } else {\n                position.put(ch, -1);\n                while (!queue.isEmpty() && position.get(queue.peek().ch) == -1) {\n                    queue.poll();\n                }\n            }\n        }\n        return queue.isEmpty() ? -1 : queue.poll().pos;\n    }\n\n    class Pair {\n        char ch;\n        int pos;\n\n        Pair(char ch, int pos) {\n            this.ch = ch;\n            this.pos = pos;\n        }\n    }\n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        position = dict()\n        q = collections.deque()\n        n = len(s)\n        for i, ch in enumerate(s):\n            if ch not in position:\n                position[ch] = i\n                q.append((s[i], i))\n            else:\n                position[ch] = -1\n                while q and position[q[0][0]] == -1:\n                    q.popleft()\n        return -1 if not q else q[0][1]\n```\n\n```JavaScript [sol3-JavaScript]\nvar firstUniqChar = function(s) {\n    const position = new Map();\n    const q = [];\n    const n = s.length;\n    for (let [i, ch] of Array.from(s).entries()) {\n        if (!position.has(ch)) {\n            position.set(ch, i);\n            q.push([s[i], i]);\n        } else {\n            position.set(ch, -1);\n            while (q.length && position.get(q[0][0]) === -1) {\n                q.shift();\n            }\n        }\n    }\n    return q.length ? q[0][1] : -1;\n};\n```\n\n```Go [sol3-Golang]\ntype pair struct {\n    ch  byte\n    pos int\n}\n\nfunc firstUniqChar(s string) int {\n    n := len(s)\n    pos := [26]int{}\n    for i := range pos[:] {\n        pos[i] = n\n    }\n    q := []pair{}\n    for i := range s {\n        ch := s[i] - 'a'\n        if pos[ch] == n {\n            pos[ch] = i\n            q = append(q, pair{ch, i})\n        } else {\n            pos[ch] = n + 1\n            for len(q) > 0 && pos[q[0].ch] == n+1 {\n                q = q[1:]\n            }\n        }\n    }\n    if len(q) > 0 {\n        return q[0].pos\n    }\n    return -1\n}\n```\n\n```C [sol3-C]\nstruct hashTable {\n    int key;\n    int val;\n    UT_hash_handle hh;\n};\n\nint firstUniqChar(char* s) {\n    struct hashTable* position = NULL;\n    int que[26][2], left = 0, right = 0;\n    int n = strlen(s);\n    for (int i = 0; i < n; ++i) {\n        int ikey = s[i];\n        struct hashTable* tmp;\n        HASH_FIND_INT(position, &ikey, tmp);\n        if (tmp == NULL) {\n            tmp = malloc(sizeof(struct hashTable));\n            tmp->key = ikey;\n            tmp->val = i;\n            HASH_ADD_INT(position, key, tmp);\n            que[right][0] = ikey;\n            que[right++][1] = i;\n        } else {\n            tmp->val = -1;\n            while (left < right) {\n                int ikey = que[left][0];\n                struct hashTable* tmp;\n                HASH_FIND_INT(position, &ikey, tmp);\n                if (tmp == NULL || tmp->val != -1) {\n                    break;\n                }\n                left++;\n            }\n        }\n    }\n    return left < right ? que[left][1] : -1;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。遍历字符串的时间复杂度为 $O(n)$，而在遍历的过程中我们还维护了一个队列，由于每一个字符最多只会被放入和弹出队列最多各一次，因此维护队列的总时间复杂度为 $O(|\\Sigma|)$，由于 $s$ 包含的字符种类数一定小于 $s$ 的长度，因此 $O(|\\Sigma|)$ 在渐进意义下小于 $O(n)$，可以忽略。\n\n- 空间复杂度：$O(|\\Sigma|)$，其中 $\\Sigma$ 是字符集，在本题中 $s$ 只包含小写字母，因此 $|\\Sigma| \\leq 26$。我们需要 $O(|\\Sigma|)$ 的空间存储哈希映射以及队列。"
}