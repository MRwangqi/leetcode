{
	"titleSlug": "longest-increasing-subsequence-ii",
	"slug": "zhi-yu-xian-duan-shu-pythonjavacgo-by-en-p1gz",
	"url": "https://leetcode-cn.com/problems/longest-increasing-subsequence-ii/solution/zhi-yu-xian-duan-shu-pythonjavacgo-by-en-p1gz/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1it4y1L7kL) 已出炉，欢迎点赞三连，在评论区分享你对这场周赛的看法~\r\n\r\n有关线段树的入门讲解可以看我的 [这个视频](https://www.bilibili.com/video/BV18t4y1p736?t=8m7s)。\r\n \r\n---\r\n\r\n#### 前言\r\n\r\n在求解「上升子序列」问题时，一般有两种优化方法：\r\n\r\n1. 单调栈 + 二分优化；\r\n2. 线段树、平衡树等数据结构优化。\r\n\r\n这两种做法都可以用 $O(n\\log n)$ 的时间解决 [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)。\r\n\r\n---\r\n\r\n对于本题，由于有一个差值不超过 $k$ 的约束，用线段树更好处理。\r\n\r\n具体来说，定义 $f[i][j]$ 表示 $\\textit{nums}$ 的前 $i$ 个元素中，以元素 $j$ 结尾的满足题目两个条件的子序列的最长长度。\r\n\r\n当 $j\\ne\\textit{nums}[i]$ 时，$f[i][j] = f[i-1][j]$。\r\n\r\n当 $j=\\textit{nums}[i]$ 时，我们可以从 $f[i-1][j']$ 转移过来，这里 $j-k\\le j'<j$，取最大值，得\r\n\r\n$$\r\nf[i][j] = 1 + \\max_{j'=j-k}^{j-1} f[i-1][j']\r\n$$\r\n\r\n上式有一个「区间求最大值」的过程，这非常适合用**线段树**计算，且由于 $f[i]$ 只会从 $f[i-1]$ 转移过来，我们可以把 $f$ 的第一个维度优化掉。这样我们可以**用线段树表示整个 $f$ 数组**，在上面查询和更新。\r\n\r\n最后答案为 $\\max(f[n-1])$，对应到线段树上就是根节点的值。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\r\n        u = max(nums)\r\n        mx = [0] * (4 * u)\r\n\r\n        def modify(o: int, l: int, r: int, i: int, val: int) -> None:\r\n            if l == r:\r\n                mx[o] = val\r\n                return\r\n            m = (l + r) // 2\r\n            if i <= m: modify(o * 2, l, m, i, val)\r\n            else: modify(o * 2 + 1, m + 1, r, i, val)\r\n            mx[o] = max(mx[o * 2], mx[o * 2 + 1])\r\n\r\n        # 返回区间 [L,R] 内的最大值\r\n        def query(o: int, l: int, r: int, L: int, R: int) -> int:  # L 和 R 在整个递归过程中均不变，将其大写，视作常量\r\n            if L <= l and r <= R: return mx[o]\r\n            res = 0\r\n            m = (l + r) // 2\r\n            if L <= m: res = query(o * 2, l, m, L, R)\r\n            if R > m: res = max(res, query(o * 2 + 1, m + 1, r, L, R))\r\n            return res\r\n\r\n        for x in nums:\r\n            if x == 1:\r\n                modify(1, 1, u, 1, 1)\r\n            else:\r\n                res = 1 + query(1, 1, u, max(x - k, 1), x - 1)\r\n                modify(1, 1, u, x, res)\r\n        return mx[1]\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    int[] max;\r\n\r\n    public int lengthOfLIS(int[] nums, int k) {\r\n        var u = 0;\r\n        for (var x : nums) u = Math.max(u, x);\r\n        max = new int[u * 4];\r\n        for (var x : nums) {\r\n            if (x == 1) modify(1, 1, u, 1, 1);\r\n            else {\r\n                var res = 1 + query(1, 1, u, Math.max(x - k, 1), x - 1);\r\n                modify(1, 1, u, x, res);\r\n            }\r\n        }\r\n        return max[1];\r\n    }\r\n\r\n    private void modify(int o, int l, int r, int idx, int val) {\r\n        if (l == r) {\r\n            max[o] = val;\r\n            return;\r\n        }\r\n        var m = (l + r) / 2;\r\n        if (idx <= m) modify(o * 2, l, m, idx, val);\r\n        else modify(o * 2 + 1, m + 1, r, idx, val);\r\n        max[o] = Math.max(max[o * 2], max[o * 2 + 1]);\r\n    }\r\n\r\n    // 返回区间 [L,R] 内的最大值\r\n    private int query(int o, int l, int r, int L, int R) { // L 和 R 在整个递归过程中均不变，将其大写，视作常量\r\n        if (L <= l && r <= R) return max[o];\r\n        var res = 0;\r\n        var m = (l + r) / 2;\r\n        if (L <= m) res = query(o * 2, l, m, L, R);\r\n        if (R > m) res = Math.max(res, query(o * 2 + 1, m + 1, r, L, R));\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\n    vector<int> max;\r\n\r\n    void modify(int o, int l, int r, int i, int val) {\r\n        if (l == r) {\r\n            max[o] = val;\r\n            return;\r\n        }\r\n        int m = (l + r) / 2;\r\n        if (i <= m) modify(o * 2, l, m, i, val);\r\n        else modify(o * 2 + 1, m + 1, r, i, val);\r\n        max[o] = std::max(max[o * 2], max[o * 2 + 1]);\r\n    }\r\n\r\n    // 返回区间 [L,R] 内的最大值\r\n    int query(int o, int l, int r, int L, int R) { // L 和 R 在整个递归过程中均不变，将其大写，视作常量\r\n        if (L <= l && r <= R) return max[o];\r\n        int res = 0;\r\n        int m = (l + r) / 2;\r\n        if (L <= m) res = query(o * 2, l, m, L, R);\r\n        if (R > m) res = std::max(res, query(o * 2 + 1, m + 1, r, L, R));\r\n        return res;\r\n    }\r\n\r\npublic:\r\n    int lengthOfLIS(vector<int> &nums, int k) {\r\n        int u = *max_element(nums.begin(), nums.end());\r\n        max.resize(u * 4);\r\n        for (int x: nums) {\r\n            if (x == 1) modify(1, 1, u, 1, 1);\r\n            else {\r\n                int res = 1 + query(1, 1, u, std::max(x - k, 1), x - 1);\r\n                modify(1, 1, u, x, res);\r\n            }\r\n        }\r\n        return max[1];\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\ntype seg []struct{ l, r, max int }\r\n\r\nfunc (t seg) build(o, l, r int) {\r\n\tt[o].l, t[o].r = l, r\r\n\tif l == r {\r\n\t\treturn\r\n\t}\r\n\tm := (l + r) >> 1\r\n\tt.build(o<<1, l, m)\r\n\tt.build(o<<1|1, m+1, r)\r\n}\r\n\r\nfunc (t seg) modify(o, i, val int) {\r\n\tif t[o].l == t[o].r {\r\n\t\tt[o].max = val\r\n\t\treturn\r\n\t}\r\n\tm := (t[o].l + t[o].r) >> 1\r\n\tif i <= m {\r\n\t\tt.modify(o<<1, i, val)\r\n\t} else {\r\n\t\tt.modify(o<<1|1, i, val)\r\n\t}\r\n\tt[o].max = max(t[o<<1].max, t[o<<1|1].max)\r\n}\r\n\r\n// 返回区间 [l,r] 内的最大值\r\nfunc (t seg) query(o, l, r int) int {\r\n\tif l <= t[o].l && t[o].r <= r {\r\n\t\treturn t[o].max\r\n\t}\r\n\tm := (t[o].l + t[o].r) >> 1\r\n\tif r <= m {\r\n\t\treturn t.query(o<<1, l, r)\r\n\t}\r\n\tif m < l {\r\n\t\treturn t.query(o<<1|1, l, r)\r\n\t}\r\n\treturn max(t.query(o<<1, l, r), t.query(o<<1|1, l, r))\r\n}\r\n\r\nfunc lengthOfLIS(nums []int, k int) int {\r\n\tmx := 0\r\n\tfor _, x := range nums {\r\n\t\tmx = max(mx, x)\r\n\t}\r\n\tt := make(seg, mx*4)\r\n\tt.build(1, 1, mx)\r\n\tfor _, x := range nums {\r\n\t\tif x == 1 {\r\n\t\t\tt.modify(1, 1, 1)\r\n\t\t} else {\r\n\t\t\tt.modify(1, x, 1+t.query(1, max(x-k, 1), x-1))\r\n\t\t}\r\n\t}\r\n\treturn t[1].max\r\n}\r\n\r\nfunc max(a, b int) int {\r\n\tif b > a {\r\n\t\treturn b\r\n\t}\r\n\treturn a\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\log U)$，其中 $n$ 为 $\\textit{nums}$ 的长度，$U=\\max(\\textit{nums})$。\r\n- 空间复杂度：$O(U)$。\r\n"
}