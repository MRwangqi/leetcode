{
	"titleSlug": "rotate-function",
	"slug": "xuan-zhuan-shu-zu-by-leetcode-solution-s0wd",
	"url": "https://leetcode-cn.com/problems/rotate-function/solution/xuan-zhuan-shu-zu-by-leetcode-solution-s0wd/",
	"content": "#### 方法一：迭代\n\n**思路**\n\n记数组 $\\textit{nums}$ 的元素之和为 $\\textit{numSum}$。根据公式，可以得到：\n\n- $F(0) = 0 \\times \\textit{nums}[0] + 1 \\times \\textit{nums}[1] + \\ldots + (n-1) \\times \\textit{nums}[n-1]$\n- $F(1) = 1 \\times \\textit{nums}[0] + 2 \\times \\textit{nums}[1] + \\ldots + 0 \\times \\textit{nums}[n-1] = F(0) + \\textit{numSum} - n \\times \\textit{nums}[n-1]$\n\n更一般地，当 $1 \\le k \\lt n$ 时，$F(k) = F(k-1) + \\textit{numSum} - n \\times \\textit{nums}[n-k]$。我们可以不停迭代计算出不同的 $F(k)$，并求出最大值。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxRotateFunction(self, nums: List[int]) -> int:\n        f, n, numSum = 0, len(nums), sum(nums)\n        for i, num in enumerate(nums):\n            f += i * num\n        res = f\n        for i in range(n - 1, 0, -1):\n            f = f + numSum - n * nums[i]\n            res = max(res, f)\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maxRotateFunction(int[] nums) {\n        int f = 0, n = nums.length, numSum = Arrays.stream(nums).sum();\n        for (int i = 0; i < n; i++) {\n            f += i * nums[i];\n        }\n        int res = f;\n        for (int i = n - 1; i > 0; i--) {\n            f += numSum - n * nums[i];\n            res = Math.max(res, f);\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MaxRotateFunction(int[] nums) {\n        int f = 0, n = nums.Length, numSum = nums.Sum();\n        for (int i = 0; i < n; i++) {\n            f += i * nums[i];\n        }\n        int res = f;\n        for (int i = n - 1; i > 0; i--) {\n            f += numSum - n * nums[i];\n            res = Math.Max(res, f);\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxRotateFunction(vector<int>& nums) {\n        int f = 0, n = nums.size();\n        int numSum = accumulate(nums.begin(), nums.end(), 0);\n        for (int i = 0; i < n; i++) {\n            f += i * nums[i];\n        }\n        int res = f;\n        for (int i = n - 1; i > 0; i--) {\n            f += numSum - n * nums[i];\n            res = max(res, f);\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint maxRotateFunction(int* nums, int numsSize){\n    int f = 0, numSum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        f += i * nums[i];\n        numSum += nums[i];\n    }\n    int res = f;\n    for (int i = numsSize - 1; i > 0; i--) {\n        f += numSum - numsSize * nums[i];\n        res = MAX(res, f);\n    }\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maxRotateFunction = function(nums) {\n    let f = 0, n = nums.length, numSum = _.sum(nums);\n    for (let i = 0; i < n; i++) {\n        f += i * nums[i];\n    }\n    let res = f;\n    for (let i = n - 1; i > 0; i--) {\n        f += numSum - n * nums[i];\n        res = Math.max(res, f);\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc maxRotateFunction(nums []int) int {\n    numSum := 0\n    for _, v := range nums {\n        numSum += v\n    }\n    f := 0\n    for i, num := range nums {\n        f += i * num\n    }\n    ans := f\n    for i := len(nums) - 1; i > 0; i-- {\n        f += numSum - len(nums)*nums[i]\n        ans = max(ans, f)\n    }\n    return ans\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。计算 $\\textit{numSum}$ 和第一个 $f$ 消耗 $O(n)$ 时间，后续迭代 $n-1$ 次 $f$ 消耗 $O(n)$ 时间。\n\n- 空间复杂度：$O(1)$。仅使用常数空间。"
}