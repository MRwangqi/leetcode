{
	"titleSlug": "1GxJYY",
	"slug": "by-shayn-a-0tie",
	"url": "https://leetcode-cn.com/problems/1GxJYY/solution/by-shayn-a-0tie/",
	"content": "菜鸡第一次写题解用来锻炼自己的语言能力，望看到的伙伴们见谅┭┮﹏┭┮\r\n\r\n# **题目理解：**\r\n\r\n·就是给你一个数组 *flowers* 和 一个正整数 *cnt* 。\r\n\r\n·数组 *flowers* 存在某些非空子数组，这些子数组里面的每个数字出现的次数不能超过 *cnt* 。\r\n\r\n·返回这些子数组的总数量。\r\n\r\n# **算法流程：**\r\n\r\n①一个滑动窗口，左指针 *left*，右指针 *right* 。\r\n\r\n②初始化整型变量 *ans* 作为满足条件的数组数量，哈希表 *count* 记录滑动窗口中数字的出现次数。\r\n\r\n③ *right* 一直往右遍历。\r\n\r\n④假如：滑动窗口右侧新加进的数字 *x* 符合要求(即 *count\\[x]<=cnt* )，则整个滑动窗口也*满足*题目条件要求的子数组。\r\n\r\n⑤ *ans* 增加，增加的数目为 *right-left+1*，原因如图片所示：包含右侧新数字的符合题目要求的区间个数 (倒着数)。\r\n\r\n⑥假如：滑动窗口右侧新加进的数字 *x* 不符合要求(即 *count\\[x]>cnt* )，则整个滑动窗口*不满足*题目条件要求的子数组。\r\n\r\n⑦ *left* 开始遍历，滑动数组逐个排出左侧数字 *y* ，滑动窗口数字 *y* 出现次数减少，则 *--count\\[y]* 。\r\n\r\n⑧直到遇到滑动窗口的左侧第一个数字 *x*，数字 *x* 的出现次数减少，*count\\[--x]<=cnt* 使得滑动窗口*再次满足*题目条件要求的子数组。\r\n\r\n⑨ *ans* 增加，增加的数目为 *right-left+1*，原因如图片所示：包含右侧新数字的符合题目要求的区间个数 (倒着数)。\r\n\r\n⑩ *right* 继续遍历，直到末尾停下。\r\n\r\n# **ans增加：**\r\n\r\n·既然滑动窗口的这个数组符合条件，那么它的子数组也符合条件\r\n\r\n·右侧元素是新来的，那 *ans* 新增加的数目就是包括右侧新元素的子数组\r\n\r\n![983df05098adad31c86c1e210fb023a.jpg](https://pic.leetcode-cn.com/1665159510-nmqpFK-983df05098adad31c86c1e210fb023a.jpg)\r\n\r\n# **代码：**\r\n```\r\nclass Solution {\r\npublic:\r\n    int beautifulBouquet(vector<int>& flowers, int cnt) {\r\n        int mod=1e9+7;\r\n        int ans=0;                                //计算结果\r\n        unordered_map<int,int> count;             //记录滑动窗口中数字的出现次数\r\n        for(int left=0,right=0;right<flowers.size();++right)     \r\n        {                                         //右指针一直往右遍历\r\n            ++count[flowers[right]];              //遍历数字的出现字数 +1\r\n            while(count[flowers[right]]>cnt)      //假如右指针新遍历的 数字x 不满足条件 (数字x的出现次数大于cnt)\r\n            {                                     //则移动左指针，直到遇到滑动窗口中 数字x 的第一次出现\r\n                --count[flowers[left]];           //左指针往右移动，那滑动窗口弹出数字的出现次数 -1\r\n                ++left;                           //左指针一直往右移动   \r\n            }                                     //原本count[x]>cnt, 当左指针遇到x，count[x]-1<=cnt，跳出循环\r\n            ans+=right-left+1;                           \r\n            ans%=mod;                             //ans增加，数目为 包含新的数字x的符合题目要求的区间个数(倒着数)\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n```\r\n"
}