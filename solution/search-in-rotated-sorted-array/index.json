{
	"titleSlug": "search-in-rotated-sorted-array",
	"slug": "ji-jian-solution-by-lukelee",
	"url": "https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-jian-solution-by-lukelee/",
	"content": "```C++ []\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int lo = 0, hi = nums.size() - 1;\n        while (lo < hi) {\n            int mid = (lo + hi) / 2;\n            if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))\n                lo = mid + 1;\n            else\n                hi = mid;\n        }\n        return lo == hi && nums[lo] == target ? lo : -1;\n    }\n};\n```\n以二分搜索为基本思路\n\n简要来说：\n\n- `nums[0] <= nums[mid]`（0 - mid不包含旋转）且`nums[0] <= target <= nums[mid]` 时 high 向前规约；\n\n- `nums[mid] < nums[0]`（0 - mid包含旋转），`target <= nums[mid] < nums[0]` 时向前规约（target 在旋转位置到 mid 之间）\n\n- `nums[mid] < nums[0]`，`nums[mid] < nums[0] <= target` 时向前规约（target 在 0 到旋转位置之间）\n\n- 其他情况向后规约\n\n也就是说`nums[mid] < nums[0]`，`nums[0] > target`，`target > nums[mid]` 三项均为真或者只有一项为真时向后规约。\n\n原文的分析是：\n\n注意到原数组为有限制的有序数组（除了在某个点会突然下降外均为升序数组）\n \n- `if nums[0] <= nums[I]` 那么 `nums[0]` 到 `nums[i]` 为有序数组,那么当 `nums[0] <= target <= nums[i]` 时我们应该在 $0-i$ 范围内查找；\n\n- `if nums[i] < nums[0]` 那么在 $0-i$ 区间的某个点处发生了下降（旋转），那么 $I+1$ 到最后一个数字的区间为有序数组，并且所有的数字都是小于 `nums[0]` 且大于 `nums[i]`，当target不属于 `nums[0]` 到 `nums[i]` 时（`target <= nums[i] < nums[0] or nums[i] < nums[0] <= target`），我们应该在 $0-i$ 区间内查找。\n上述三种情况可以总结如下：\n```\n    nums[0] <= target <= nums[i]\n               target <= nums[i] < nums[0]\n                         nums[i] < nums[0] <= target\n```\n所以我们进行三项判断：\n\n`(nums[0] <= target)`，` (target <= nums[i])` ，`(nums[i] < nums[0])`，现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真或均为假（因为这三项可能已经包含了所有情况））\n\n所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。\n\n使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真，可以画真值表进行验证）\n\n之后我们通过二分查找不断做小 `target` 可能位于的区间直到 `low==high`，此时如果 `nums[low]==target` 则找到了，如果不等则说明该数组里没有此项。\n"
}