{
	"titleSlug": "k-divisible-elements-subarrays",
	"slug": "han-zui-duo-k-ge-ke-zheng-chu-yuan-su-de-51ov",
	"url": "https://leetcode-cn.com/problems/k-divisible-elements-subarrays/solution/han-zui-duo-k-ge-ke-zheng-chu-yuan-su-de-51ov/",
	"content": "#### 方法一：枚举 + 哈希集合去重\n\n**思路与算法**\n\n为了方便起见，我们可以首先考虑子数组**不会重复出现**的情况。\n\n对于一个确定的整数数组 $\\textit{nums}$，它的子数组可以由左边界和右边界唯一决定。因此我们可以通过枚举左边界和右边界来遍历 $\\textit{nums}$ 的所有子数组，并检查它们是否至多含 $k$ 个可被 $p$ 整除的元素。\n\n具体地，我们用 $\\textit{res}$ 来维护符合要求子数组的个数。我们首先枚举左边界 $i$，对于某个左边界 $i$，我们在枚举右边界 $j$ 的同时用 $\\textit{cnt}$ 统计子数组 $\\textit{nums}[i..j]$ （闭区间）中可被 $p$ 整除的元素的个数。$\\textit{cnt}$ 的初值为 $0$，如果 $\\textit{nums}[j]$ 可以被 $p$ 整除，则我们将 $\\textit{cnt}$ 加上 $1$。此时根据 $\\textit{cnt}$ 和 $k$ 的大小关系，有两种情况：\n\n- 如果此时 $\\textit{cnt} \\le k$，则说明子数组 $\\textit{nums}[i..j]$ 符合要求，我们将 $\\textit{res}$ 加上 $1$，并继续枚举右边界；\n\n- 如果此时 $\\textit{cnt} > k$，则说明子数组 $\\textit{nums}[i..j]$ 不符合要求，同时后续即将遍历到的满足 $j_1 > j$ 的子数组 $\\textit{nums}[i..j_1]$ 由于包含 $\\textit{nums}[i..j]$ 显然也不符合要求，因此我们可以停止枚举右边界。\n\n最终我们返回 $\\textit{res}$ 作为答案即可。\n\n随后我们考虑子数组**会重复出现**的情况。此时我们不能直接按照上文的方法统计个数，而需要对符合要求的子数组进行去重后计算。\n\n我们可以用哈希集合来完成对应的去重操作。具体地，我们用哈希集合 $\\textit{arrs}$ 来维护符合要求的子数组，按照与上文一致的遍历方法进行遍历，每当遍历到符合要求的子数组，我们将该子数组**序列化**（即通过**一一映射**转化为可哈希的元素）并放入哈希集合中。最终，我们返回 $\\textit{arrs}$ 中的**元素个数**作为答案。\n\n对于序列化的具体方式，对于 $\\texttt{Python}$ 等语言，我们可以将子数组转化为可哈希的**元组**放入哈希表；而对于 $\\texttt{C++}$ 等语言，我们可以将子数组转化为**字符串**后放入哈希表。\n\n具体地，我们用 $s$ 表示序列化后的字符串。在每次开始遍历右边界前，我们初始化字符串。当遍历到对应下标时，我们将右边界对应的元素转化为字符串，并在末尾加上**分隔符** $\\texttt{`\\#'}$ 后添加进 $s$ 的尾部。可以证明，上述的序列化方式是一一映射。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int countDistinct(vector<int>& nums, int k, int p) {\n        unordered_set<string> arrs;   // 不同的（序列化后）子数组\n        int n = nums.size();\n        // 枚举左右边界\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;   // 当前被 p 整除的元素个数\n            string s;   // 当前子数组序列胡后的字符串\n            for (int j = i; j < n; ++j) {\n                if (nums[j] % p == 0) {\n                    ++cnt;\n                    if (cnt > k) {\n                        break;\n                    }\n                }\n                // 序列化后放入哈希集合\n                s.append(to_string(nums[j]));\n                s.push_back('#');\n                arrs.insert(s);\n            }\n        }\n        return arrs.size();\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def countDistinct(self, nums: List[int], k: int, p: int) -> int:\n        arrs = set()   # 不同的（序列化后）子数组\n        n = len(nums)\n        # 枚举左右边界\n        for i in range(n):\n            cnt = 0   # 当前被 p 整除的元素个数\n            arr = []   # 当前子数组\n            for j in range(i, n):\n                if nums[j] % p == 0:\n                    cnt += 1\n                    if cnt > k:\n                        break\n                arr.append(nums[j])\n                # 序列化后放入哈希集合\n                arrs.add(tuple(arr))\n        return len(arrs)\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^3)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度。我们共需遍历 $O(n^2)$ 个子数组，序列化每个子数组并放入哈希集合的时间复杂度为 $O(n)$。\n\n- 空间复杂度：$O(n^3)$，即为哈希集合的空间开销。"
}