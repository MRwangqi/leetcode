{
	"titleSlug": "reverse-bits",
	"slug": "fu-xue-ming-zhu-xun-huan-yu-fen-zhi-jie-hoakf",
	"url": "https://leetcode-cn.com/problems/reverse-bits/solution/fu-xue-ming-zhu-xun-huan-yu-fen-zhi-jie-hoakf/",
	"content": "各位题友大家好！ 今天是 **[@负雪明烛](/u/fuxuemingzhu/)** 坚持日更的第 **64** 天。今天力扣上的每日一题是「[190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)」。\n\n# 解题思路\n\n今天的题目是要求将一个数字，把其二进制翻转，求得到的另外一个二进制数。\n\n## 方法一：循环\n\n\n这是最容易想到的方法了，每次把 `res` 左移，把 $n$ 的二进制末尾数字，拼接到结果 `res` 的末尾。然后把 $n$ 右移。\n\n\n举一个 8 位的二进制进行说明：\n\n\n\n| i    | n         | res       |\n| ---- | --------- | --------- |\n| -    | 11001001 | -         |\n| 0    | 1100100  | 1         |\n| 1    | 110010   | 10        |\n| 2    | 11001    | 100       |\n| 3    | 1100     | 1001      |\n| 4    | 110      | 10010     |\n| 5    | 11       | 100100    |\n| 6    | 1        | 1001001   |\n| 8    | -        | 10010011 |\n\n代码如下：\n\n\n```Python []\nclass Solution:\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        res = 0\n        for i in range(32):\n            res = (res << 1) | (n & 1)\n            n >>= 1\n        return res\n```\n```C++ []\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t res = 0;\n        for (int i = 0; i < 32; ++i) {\n            res = (res << 1) | (n & 1);\n            n >>= 1;\n        }\n        return res;\n    }\n};\n```\n\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(1)$\n\n\n\n\n\n## 方法二：分而治之\n\n有另外一种不使用循环的做法，类似于**归并排序**。\n\n\n其思想是分而治之，把数字分为两半，然后交换这两半的顺序；然后把前后两个半段都再分成两半，交换内部顺序……直至最后交换顺序的时候，交换的数字只有 1 位。\n\n以一个 8 位的二进制数字为例：\n\n![190.001.jpeg](https://pic.leetcode-cn.com/1616982968-vXsJSf-190.001.jpeg)\n\n代码如下：\n\n```Python []\nclass Solution:\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        n = (n >> 16) | (n << 16);\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\n        return n;\n```\n```C++ []\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        n = (n >> 16) | (n << 16);\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\n        return n;\n    }\n};\n```\n\n\n\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(1)$\n\n\n\n\n# 刷题心得\n\n\n位运算还是很有意思的。\n\n\n-----\n\n参考资料：\n\n- [负雪明烛](https://blog.csdn.net/fuxuemingzhu/article/details/79254344)\n- [花花酱](https://www.youtube.com/watch?v=K0EHvvbUdEg)\n- [tworuler](https://leetcode.com/problems/reverse-bits/discuss/54741/O(1)-bit-operation-C%2B%2B-solution-(8ms))\n\n\n-----\n\n\nOK，以上就是 [@负雪明烛](https://leetcode-cn.com/u/fuxuemingzhu/) 写的今天题解的全部内容了，如果你觉得有帮助的话，**求赞、求关注、求收藏**。如果有疑问的话，请在下面评论，我会及时解答。\n\n\n**关注我**，你将不会错过我的精彩动画题解、面试题分享、组队刷题活动，进入主页 [@负雪明烛](https://leetcode-cn.com/u/fuxuemingzhu/) 右侧有刷题组织，从此刷题不再孤单。\n\n\n祝大家牛年大吉！AC 多多，Offer 多多！我们明天再见！"
}