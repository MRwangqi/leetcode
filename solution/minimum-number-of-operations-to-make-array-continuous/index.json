{
	"titleSlug": "minimum-number-of-operations-to-make-array-continuous",
	"slug": "c-by-liu-xiang-3-kugh",
	"url": "https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-array-continuous/solution/c-by-liu-xiang-3-kugh/",
	"content": "### 思路\r\n1. 对数组进行排序, 去重;\r\n2. 枚举每个元素, 以该值为起始, 连续n个值, 需要替换几个值;\r\n```\r\nclass Solution {\r\npublic:\r\n    int minOperations(vector<int>& nums) {\r\n        int n = nums.size();\r\n        sort(nums.begin(), nums.end());\r\n        int m = unique(nums.begin(), nums.end()) - nums.begin();\r\n        int ans = n;\r\n        /* 双指针求以nums[i]为起始, 连续n个值, 需要替换的个数 */\r\n        for (int i = 0, j = 0; i < m; i++) {\r\n            while (j < m && nums[j] - nums[i] <= n - 1) {\r\n                j++;\r\n            }\r\n            ans = min(ans, n - (j - i));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n二分实现上述思路\r\n```\r\nclass Solution {\r\npublic:\r\n    int minOperations(vector<int>& nums) {\r\n        int n = nums.size();\r\n        sort(nums.begin(), nums.end());\r\n        int m = unique(nums.begin(), nums.end()) - nums.begin();\r\n        int ans = n;\r\n        for (int i = 0; i < m; i++) {\r\n            /* 求大于nums[i]+n-1的左侧边界 */\r\n            int j = upper_bound(nums.begin(), nums.begin() + m, nums[i] + n - 1) - \r\n                    nums.begin();\r\n            ans = min(ans, n - (j - i));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n"
}