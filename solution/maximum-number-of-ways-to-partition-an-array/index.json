{
	"titleSlug": "maximum-number-of-ways-to-partition-an-array",
	"slug": "qian-zhui-he-ha-xi-biao-mei-ju-xiu-gai-y-l546",
	"url": "https://leetcode-cn.com/problems/maximum-number-of-ways-to-partition-an-array/solution/qian-zhui-he-ha-xi-biao-mei-ju-xiu-gai-y-l546/",
	"content": "计算出 $\\textit{nums}$ 的前缀和 $\\textit{sum}$，记所有元素的和为 $\\textit{tot}$。\r\n\r\n对于不修改的情况，合法分割相当于要满足 $\\textit{sum}[i] = \\textit{tot}-\\textit{sum}[i]$，即 $\\textit{sum}[i]=\\dfrac{\\textit{tot}}{2}$。\r\n\r\n对于修改的情况，枚举修改的元素，记变化量 $d=k-\\textit{nums}[i]$，这一修改操作对于 $i$ 左侧的前缀和是没有影响的，因此合法分割相当于要满足 $\\textit{sum}[i] = \\textit{tot}+d-\\textit{sum}[i]$，即 $\\textit{sum}[i]=\\dfrac{\\textit{tot}+d}{2}$；而对于 $i$ 右侧的前缀和，每个前缀和都增加了 $d$，因此合法分割相当于要满足 $\\textit{sum}[i]+d = \\textit{tot}+d-(\\textit{sum}[i]+d)$，即 $\\textit{sum}[i]=\\dfrac{\\textit{tot}-d}{2}$。\r\n\r\n我们可以在枚举 $\\textit{nums}[i]$ 的同时，用两个哈希表动态维护 $i$ 左右前缀和的个数，从而做到对每个 $\\textit{nums}[i]$ 在 $O(1)$ 的时间计算出合法分割数，因此总的时间复杂度为 $O(n)$。\r\n\r\n```go\r\nfunc waysToPartition(nums []int, k int) (ans int) {\r\n\tn := len(nums)\r\n\tsum := make([]int, n)\r\n\tsum[0] = nums[0]\r\n\tcntR := map[int]int{}\r\n\tfor i := 1; i < n; i++ {\r\n\t\tsum[i] = sum[i-1] + nums[i]\r\n\t\tcntR[sum[i-1]]++\r\n\t}\r\n\ttot := sum[n-1]\r\n\tif tot%2 == 0 {\r\n\t\tans = cntR[tot/2] // 不修改\r\n\t}\r\n\tcntL := map[int]int{}\r\n\tfor i, s := range sum {\r\n\t\tif d := k - nums[i]; (tot+d)%2 == 0 {\r\n\t\t\tans = max(ans, cntL[(tot+d)/2]+cntR[(tot-d)/2]) // 修改 nums[i]\r\n\t\t}\r\n\t\tcntL[s]++\r\n\t\tcntR[s]--\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```"
}