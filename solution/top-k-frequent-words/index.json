{
	"titleSlug": "top-k-frequent-words",
	"slug": "qian-kge-gao-pin-dan-ci-by-leetcode-solu-3qk0",
	"url": "https://leetcode-cn.com/problems/top-k-frequent-words/solution/qian-kge-gao-pin-dan-ci-by-leetcode-solu-3qk0/",
	"content": "#### æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨ + æ’åº\n\n**æ€è·¯åŠç®—æ³•**\n\næˆ‘ä»¬å¯ä»¥é¢„å¤„ç†å‡ºæ¯ä¸€ä¸ªå•è¯å‡ºç°çš„é¢‘ç‡ï¼Œç„¶åä¾æ®æ¯ä¸ªå•è¯å‡ºç°çš„é¢‘ç‡é™åºæ’åºï¼Œæœ€åè¿”å›å‰ $k$ ä¸ªå­—ç¬¦ä¸²å³å¯ã€‚\n\nå…·ä½“åœ°ï¼Œæˆ‘ä»¬åˆ©ç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸€ä¸ªå­—ç¬¦ä¸²å‡ºç°çš„é¢‘ç‡ï¼Œç„¶åå°†å“ˆå¸Œè¡¨ä¸­æ‰€æœ‰å­—ç¬¦ä¸²è¿›è¡Œæ’åºï¼Œæ’åºæ—¶ï¼Œå¦‚æœä¸¤ä¸ªå­—ç¬¦ä¸²å‡ºç°é¢‘ç‡ç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬è®©ä¸¤å­—ç¬¦ä¸²ä¸­å­—å…¸åºè¾ƒå°çš„æ’åœ¨å‰é¢ï¼Œå¦åˆ™æˆ‘ä»¬è®©å‡ºç°é¢‘ç‡è¾ƒé«˜çš„æ’åœ¨å‰é¢ã€‚æœ€åæˆ‘ä»¬åªéœ€è¦ä¿ç•™åºåˆ—ä¸­çš„å‰ $k$ ä¸ªå­—ç¬¦ä¸²å³å¯ã€‚\n\n**ä»£ç **\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) {\n        unordered_map<string, int> cnt;\n        for (auto& word : words) {\n            ++cnt[word];\n        }\n        vector<string> rec;\n        for (auto& [key, value] : cnt) {\n            rec.emplace_back(key);\n        }\n        sort(rec.begin(), rec.end(), [&](const string& a, const string& b) -> bool {\n            return cnt[a] == cnt[b] ? a < b : cnt[a] > cnt[b];\n        });\n        rec.erase(rec.begin() + k, rec.end());\n        return rec;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Integer> cnt = new HashMap<String, Integer>();\n        for (String word : words) {\n            cnt.put(word, cnt.getOrDefault(word, 0) + 1);\n        }\n        List<String> rec = new ArrayList<String>();\n        for (Map.Entry<String, Integer> entry : cnt.entrySet()) {\n            rec.add(entry.getKey());\n        }\n        Collections.sort(rec, new Comparator<String>() {\n            public int compare(String word1, String word2) {\n                return cnt.get(word1) == cnt.get(word2) ? word1.compareTo(word2) : cnt.get(word2) - cnt.get(word1);\n            }\n        });\n        return rec.subList(0, k);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<string> TopKFrequent(string[] words, int k) {\n        Dictionary<string, int> cnt = new Dictionary<string, int>();\n        foreach (string word in words) {\n            if (cnt.ContainsKey(word)) {\n                cnt[word]++;\n            } else {\n                cnt.Add(word, 1);\n            }\n        }\n        List<string> rec = new List<string>();\n        foreach (var item in cnt) {\n            rec.Add(item.Key);\n        }\n        rec.Sort(\n            delegate(string word1, string word2) {\n                return cnt[word1] == cnt[word2] ? word1.CompareTo(word2) : cnt[word2] - cnt[word1];\n            }\n        );\n        return rec.GetRange(0, k);\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc topKFrequent(words []string, k int) []string {\n    cnt := map[string]int{}\n    for _, w := range words {\n        cnt[w]++\n    }\n    uniqueWords := make([]string, 0, len(cnt))\n    for w := range cnt {\n        uniqueWords = append(uniqueWords, w)\n    }\n    sort.Slice(uniqueWords, func(i, j int) bool {\n        s, t := uniqueWords[i], uniqueWords[j]\n        return cnt[s] > cnt[t] || cnt[s] == cnt[t] && s < t\n    })\n    return uniqueWords[:k]\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar topKFrequent = function(words, k) {\n    const cnt = new Map();\n    for (const word of words) {\n        cnt.set(word, (cnt.get(word) || 0) + 1);\n    }\n    const rec = [];\n    for (const entry of cnt.keys()) {\n        rec.push(entry);\n    }\n    rec.sort((word1, word2) => {\n        return cnt.get(word1) === cnt.get(word2) ? word1.localeCompare(word2) : cnt.get(word2) - cnt.get(word1);\n    })\n    return rec.slice(0, k);\n};\n```\n\n```C [sol1-C]\nstruct HashTable {\n    char* key;\n    int val;\n    UT_hash_handle hh;\n};\n\nstruct HashTable* cnt;\n\nint queryVal(struct HashTable* hashTable, char* ikey) {\n    struct HashTable* tmp;\n    HASH_FIND_STR(hashTable, ikey, tmp);\n    return tmp == NULL ? 0 : tmp->val;\n}\n\nint cmp(char** a, char** b) {\n    int valA = queryVal(cnt, *a), valB = queryVal(cnt, *b);\n    if (valA != valB) {\n        return valB - valA;\n    }\n    int lenA = strlen(*a), lenB = strlen(*b);\n    int len = fmin(lenA, lenB);\n    for (int i = 0; i < len; i++) {\n        if ((*a)[i] != (*b)[i]) {\n            return (*a)[i] - (*b)[i];\n        }\n    }\n    return lenA - lenB;\n}\n\nchar** topKFrequent(char** words, int wordsSize, int k, int* returnSize) {\n    cnt = NULL;\n    for (int i = 0; i < wordsSize; i++) {\n        struct HashTable* tmp;\n        HASH_FIND_STR(cnt, words[i], tmp);\n        if (tmp == NULL) {\n            struct HashTable* tmp = malloc(sizeof(struct HashTable));\n            tmp->key = words[i];\n            tmp->val = 1;\n            HASH_ADD_KEYPTR(hh, cnt, tmp->key, strlen(tmp->key), tmp);\n        } else {\n            tmp->val++;\n        }\n    }\n    char** ret = malloc(sizeof(char*) * HASH_COUNT(cnt));\n    *returnSize = 0;\n\n    struct HashTable *iter, *tmp;\n    HASH_ITER(hh, cnt, iter, tmp) {\n        ret[(*returnSize)++] = iter->key;\n    }\n\n    qsort(ret, *returnSize, sizeof(char*), cmp);\n    *returnSize = k;\n    return ret;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(l \\times n + l \\times m \\log m)$ï¼Œå…¶ä¸­ $n$ è¡¨ç¤ºç»™å®šå­—ç¬¦ä¸²åºåˆ—çš„é•¿åº¦ï¼Œ$l$ è¡¨ç¤ºå­—ç¬¦ä¸²çš„å¹³å‡é•¿åº¦ï¼Œ$m$ è¡¨ç¤ºå®é™…å­—ç¬¦ä¸²ç§ç±»æ•°ã€‚æˆ‘ä»¬éœ€è¦ $l \\times n$ çš„æ—¶é—´å°†å­—ç¬¦ä¸²æ’å…¥åˆ°å“ˆå¸Œè¡¨ä¸­ï¼Œä»¥åŠ $l \\times m \\log m$ çš„æ—¶é—´å®Œæˆå­—ç¬¦ä¸²æ¯”è¾ƒï¼ˆæœ€åæƒ…å†µä¸‹æ‰€æœ‰å­—ç¬¦ä¸²å‡ºç°é¢‘ç‡éƒ½ç›¸åŒï¼Œæˆ‘ä»¬éœ€è¦å°†å®ƒä»¬ä¸¤ä¸¤æ¯”è¾ƒï¼‰ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(l \\times m)$ï¼Œå…¶ä¸­ $l$ è¡¨ç¤ºå­—ç¬¦ä¸²çš„å¹³å‡é•¿åº¦ï¼Œ$m$ è¡¨ç¤ºå®é™…å­—ç¬¦ä¸²ç§ç±»æ•°ã€‚å“ˆå¸Œè¡¨å’Œç”Ÿæˆçš„æ’åºæ•°ç»„ç©ºé—´å ç”¨å‡ä¸º $O(l \\times m)$ã€‚\n\n#### æ–¹æ³•äºŒï¼šä¼˜å…ˆé˜Ÿåˆ—\n\n**æ€è·¯åŠç®—æ³•**\n\nå¯¹äºå‰ $k$ å¤§æˆ–å‰ $k$ å°è¿™ç±»é—®é¢˜ï¼Œæœ‰ä¸€ä¸ªé€šç”¨çš„è§£æ³•ï¼šä¼˜å…ˆé˜Ÿåˆ—ã€‚ä¼˜å…ˆé˜Ÿåˆ—å¯ä»¥åœ¨ $O(\\log n)$ çš„æ—¶é—´å†…å®Œæˆæ’å…¥æˆ–åˆ é™¤å…ƒç´ çš„æ“ä½œï¼ˆå…¶ä¸­ $n$ ä¸ºä¼˜å…ˆé˜Ÿåˆ—çš„å¤§å°ï¼‰ï¼Œå¹¶å¯ä»¥ $O(1)$ åœ°æŸ¥è¯¢ä¼˜å…ˆé˜Ÿåˆ—é¡¶ç«¯å…ƒç´ ã€‚\n\nåœ¨æœ¬é¢˜ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå°æ ¹ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯ä¼˜å…ˆé˜Ÿåˆ—é¡¶ç«¯å…ƒç´ æ˜¯æœ€å°å…ƒç´ çš„ä¼˜å…ˆé˜Ÿåˆ—ï¼‰ã€‚æˆ‘ä»¬å°†æ¯ä¸€ä¸ªå­—ç¬¦ä¸²æ’å…¥åˆ°ä¼˜å…ˆé˜Ÿåˆ—ä¸­ï¼Œå¦‚æœä¼˜å…ˆé˜Ÿåˆ—çš„å¤§å°è¶…è¿‡äº† $k$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å°†ä¼˜å…ˆé˜Ÿåˆ—é¡¶ç«¯å…ƒç´ å¼¹å‡ºã€‚è¿™æ ·æœ€ç»ˆä¼˜å…ˆé˜Ÿåˆ—ä¸­å‰©ä¸‹çš„ $k$ ä¸ªå…ƒç´ å°±æ˜¯å‰ $k$ ä¸ªå‡ºç°æ¬¡æ•°æœ€å¤šçš„å•è¯ã€‚\n\n**ä»£ç **\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) {\n        unordered_map<string, int> cnt;\n        for (auto& word : words) {\n            cnt[word]++;\n        }\n        auto cmp = [](const pair<string, int>& a, const pair<string, int>& b) {\n            return a.second == b.second ? a.first < b.first : a.second > b.second;\n        };\n        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp)> que(cmp);\n        for (auto& it : cnt) {\n            que.emplace(it);\n            if (que.size() > k) {\n                que.pop();\n            }\n        }\n        vector<string> ret(k);\n        for (int i = k - 1; i >= 0; i--) {\n            ret[i] = que.top().first;\n            que.pop();\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Integer> cnt = new HashMap<String, Integer>();\n        for (String word : words) {\n            cnt.put(word, cnt.getOrDefault(word, 0) + 1);\n        }\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<Map.Entry<String, Integer>>(new Comparator<Map.Entry<String, Integer>>() {\n            public int compare(Map.Entry<String, Integer> entry1, Map.Entry<String, Integer> entry2) {\n                return entry1.getValue() == entry2.getValue() ? entry2.getKey().compareTo(entry1.getKey()) : entry1.getValue() - entry2.getValue();\n            }\n        });\n        for (Map.Entry<String, Integer> entry : cnt.entrySet()) {\n            pq.offer(entry);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        }\n        List<String> ret = new ArrayList<String>();\n        while (!pq.isEmpty()) {\n            ret.add(pq.poll().getKey());\n        }\n        Collections.reverse(ret);\n        return ret;\n    }\n}\n```\n\n```go [sol2-Golang]\ntype pair struct {\n    w string\n    c int\n}\ntype hp []pair\nfunc (h hp) Len() int            { return len(h) }\nfunc (h hp) Less(i, j int) bool  { a, b := h[i], h[j]; return a.c < b.c || a.c == b.c && a.w > b.w }\nfunc (h hp) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\nfunc (h *hp) Push(v interface{}) { *h = append(*h, v.(pair)) }\nfunc (h *hp) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }\n\nfunc topKFrequent(words []string, k int) []string {\n    cnt := map[string]int{}\n    for _, w := range words {\n        cnt[w]++\n    }\n    h := &hp{}\n    for w, c := range cnt {\n        heap.Push(h, pair{w, c})\n        if h.Len() > k {\n            heap.Pop(h)\n        }\n    }\n    ans := make([]string, k)\n    for i := k - 1; i >= 0; i-- {\n        ans[i] = heap.Pop(h).(pair).w\n    }\n    return ans\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(l \\times n + m \\times l \\log k)$ï¼Œå…¶ä¸­ $n$ è¡¨ç¤ºç»™å®šå­—ç¬¦ä¸²åºåˆ—çš„é•¿åº¦ï¼Œ$m$ è¡¨ç¤ºå®é™…å­—ç¬¦ä¸²ç§ç±»æ•°ï¼Œ$l$ è¡¨ç¤ºå­—ç¬¦ä¸²çš„å¹³å‡é•¿åº¦ã€‚æˆ‘ä»¬éœ€è¦ $l \\times n$ çš„æ—¶é—´å°†å­—ç¬¦ä¸²æ’å…¥åˆ°å“ˆå¸Œè¡¨ä¸­ï¼Œä»¥åŠæ¯æ¬¡æ’å…¥å…ƒç´ åˆ°ä¼˜å…ˆé˜Ÿåˆ—ä¸­éƒ½éœ€è¦ $l \\log k$ çš„æ—¶é—´ï¼Œå…±éœ€è¦æ’å…¥ $m$ æ¬¡ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(l \\times (m + k))$ï¼Œå…¶ä¸­ $l$ è¡¨ç¤ºå­—ç¬¦ä¸²çš„å¹³å‡é•¿åº¦ï¼Œ$m$ è¡¨ç¤ºå®é™…å­—ç¬¦ä¸²ç§ç±»æ•°ã€‚å“ˆå¸Œè¡¨ç©ºé—´å ç”¨ä¸º $O(l \\times m)$ï¼Œä¼˜å…ˆé˜Ÿåˆ—ç©ºé—´å ç”¨ä¸º $O(l \\times k)$ã€‚\n\n---\n## âœ¨æ‰£å‹å¸®å¸®å›¢ - äº’åŠ¨ç­”ç–‘\n\n[![è®¨è®º.jpg](https://pic.leetcode-cn.com/1621178600-MKHFrl-%E8%AE%A8%E8%AE%BA.jpg){:width=260px}](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)\n\n\nå³æ—¥èµ· - 5 æœˆ 30 æ—¥ï¼Œç‚¹å‡»Â [è¿™é‡Œ](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)Â å‰å¾€ã€Œ[æ‰£å‹å¸®å¸®å›¢](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)ã€æ´»åŠ¨é¡µï¼ŒæŠŠä½ é‡åˆ°çš„é—®é¢˜å¤§èƒ†åœ°æå‡ºæ¥ï¼Œè®©æ‰£å‹ä¸ºä½ è§£ç­”ï½\n\n### ğŸ å¥–åŠ±è§„åˆ™\nè¢«é‡‡çº³æ•°é‡æ’å 1ï½3 åï¼šã€ŒåŠ›æ‰£æå®¢å¥—è£…ã€ *1 å¹¶å°†è·å¾—ã€ŒåŠ›æ‰£ç¥ç§˜åº”æ´å›¢ã€å†…æµ‹èµ„æ ¼\nè¢«é‡‡çº³æ•°é‡æ’å 4ï½10 åï¼šã€ŒåŠ›æ‰£é¼ æ ‡å«ã€ *1 å¹¶å°†è·å¾—ã€ŒåŠ›æ‰£ç¥ç§˜åº”æ´å›¢ã€å†…æµ‹èµ„æ ¼\nã€Œè¯²äººä¸å€¦ã€ï¼šæ´»åŠ¨æœŸé—´ã€Œè§£æƒ‘è€…ã€åªè¦æœ‰ 1 ä¸ªå›ç­”è¢«é‡‡çº³ï¼Œå³å¯è·å¾— 20 LeetCoins å¥–åŠ±ï¼\nã€Œæ±‚çŸ¥è‹¥æ¸´ã€ï¼šæ´»åŠ¨æœŸé—´ã€Œæ±‚çŸ¥è€…ã€åœ¨æ´»åŠ¨é¡µå‘èµ·ä¸€æ¬¡ç¬¦åˆè¦æ±‚çš„ç–‘é—®å¸–å¹¶è‡³å°‘é‡‡çº³ä¸€æ¬¡ã€Œè§£æƒ‘è€…ã€çš„å›ç­”ï¼Œå³å¯è·å¾— 20 LeetCoins å¥–åŠ±ï¼\n\næ´»åŠ¨è¯¦æƒ…çŒ›æˆ³é“¾æ¥äº†è§£æ›´å¤šï¼š[æ´»åŠ¨ï½œä½ æœ‰ BUG æˆ‘æ¥å¸® - åŠ›æ‰£äº’åŠ¨ç­”ç–‘å­£](https://leetcode-cn.com/circle/discuss/xtliW6/)"
}