{
	"titleSlug": "k-th-smallest-prime-fraction",
	"slug": "di-k-ge-zui-xiao-de-su-shu-fen-shu-by-le-argw",
	"url": "https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/solution/di-k-ge-zui-xiao-de-su-shu-fen-shu-by-le-argw/",
	"content": "#### 方法一：自定义排序\n\n**思路与算法**\n\n记数组 $\\textit{arr}$ 的长度为 $n$。我们可以将全部的 $\\dfrac{n(n-1)}{2}$ 个分数放入数组中进行自定义排序，规则为将这些分数按照升序进行排序。\n\n在排序完成后，我们就可以得到第 $k$ 个最小的素数分数。\n\n**细节**\n\n当我们比较两个分数 $\\dfrac{a}{b}$ 和 $\\dfrac{c}{d}$ 时，我们可以直接对它们的值进行比较，但这会产生浮点数的计算，降低程序的效率，并且可能会引入浮点数误差。一种可行的替代方法是用：\n\n$$\na \\times d < b \\times c\n$$\n\n来替代 $\\dfrac{a}{b} < \\dfrac{c}{d}$ 的判断，二者是等价的。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\n        int n = arr.size();\n        vector<pair<int, int>> frac;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                frac.emplace_back(arr[i], arr[j]);\n            }\n        }\n        sort(frac.begin(), frac.end(), [&](const auto& x, const auto& y) {\n            return x.first * y.second < x.second * y.first;\n        });\n        return {frac[k - 1].first, frac[k - 1].second};\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\n        int n = arr.length;\n        List<int[]> frac = new ArrayList<int[]>();\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                frac.add(new int[]{arr[i], arr[j]});\n            }\n        }\n        Collections.sort(frac, (x, y) -> x[0] * y[1] - y[0] * x[1]);\n        return frac.get(k - 1);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] KthSmallestPrimeFraction(int[] arr, int k) {\n        int n = arr.Length;\n        List<int[]> frac = new List<int[]>();\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                frac.Add(new int[]{arr[i], arr[j]});\n            }\n        }\n        frac.Sort((x, y) => x[0] * y[1] - y[0] * x[1]);\n        return frac[k - 1];\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n        def cmp(x: Tuple[int, int], y: Tuple[int, int]) -> int:\n            return -1 if x[0] * y[1] < x[1] * y[0] else 1\n        \n        n = len(arr)\n        frac = list()\n        for i in range(n):\n            for j in range(i + 1, n):\n                frac.append((arr[i], arr[j]))\n        \n        frac.sort(key=cmp_to_key(cmp))\n        return list(frac[k - 1])\n```\n\n```go [sol1-Golang]\nfunc kthSmallestPrimeFraction(arr []int, k int) []int {\n    n := len(arr)\n    type pair struct{ x, y int }\n    frac := make([]pair, 0, n*(n-1)/2)\n    for i, x := range arr {\n        for _, y := range arr[i+1:] {\n            frac = append(frac, pair{x, y})\n        }\n    }\n    sort.Slice(frac, func(i, j int) bool {\n        a, b := frac[i], frac[j]\n        return a.x*b.y < a.y*b.x\n    })\n    return []int{frac[k-1].x, frac[k-1].y}\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar kthSmallestPrimeFraction = function(arr, k) {\n    const n = arr.length;\n    const frac = [];\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            frac.push([arr[i], arr[j]]);\n        }\n    }\n    frac.sort((x, y) => x[0] * y[1] - y[0] * x[1]);\n    return frac[k - 1];\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2 \\log n)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度。素数分数一共有 $\\dfrac{n(n-1)}{2} = O(n^2)$ 个，因此排序需要的时间为 $O(n^2 \\log n)$。\n\n- 空间复杂度：$O(n^2)$，即为存储所有素数分数需要的空间。\n\n#### 方法二：优先队列\n\n**思路与算法**\n\n当分母为给定的 $\\textit{arr}[j]$ 时，分子可以在 $\\textit{arr}[0], \\cdots, \\textit{arr}[j-1]$ 中进行选择。由于数组 $\\textit{arr}$ 是严格递增的，那么记分子为 $\\textit{arr}[i] ~ (0 \\leq i < j)$，随着 $i$ 的增加，分数的值也是严格递增的。\n\n因此我们可以将每个分母 $\\textit{arr}[j]$ 看成一个长度为 $j$ 的列表，它包含了：\n\n$$\n\\frac{\\textit{arr}[0]}{\\textit{arr}[j]}, \\frac{\\textit{arr}[1]}{\\textit{arr}[j]}, \\cdots, \\frac{arr[j-1]}{\\textit{arr}[j]}\n$$\n\n这些分数，并且它们的值是严格递增的。我们的目标是找出这 $n-1$ 个列表（$\\textit{arr}[0]$ 的列表为空，我们可以直接忽略）中第 $k$ 小的素数分数，这就提示我们参考[「23. 合并 K 个升序链表」](https://leetcode-cn.com/problems/merge-k-sorted-lists/)中的方法，使用优先队列来得到答案。\n\n初始时，优先队列中存储了 $n-1$ 个分数 $\\dfrac{\\textit{arr}[0]}{\\textit{arr}[1]}, \\cdots, \\dfrac{\\textit{arr}[0]}{\\textit{arr}[n-1]}$。在求解答案的过程中，我们每次从优先队列中取出一个最小的分数，记为 $\\dfrac{\\textit{arr}[i]}{\\textit{arr}[j]}$。如果 $i + 1 < j$，我们将一个新的分数 $\\dfrac{\\textit{arr}[i+1]}{\\textit{arr}[j]}$ 放入优先队列中。这样一来，当我们进行第 $k$ 次「取出」操作时，得到的分数就是第 $k$ 小的素数分数。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\n        int n = arr.size();\n        auto cmp = [&](const pair<int, int>& x, const pair<int, int>& y) {\n            return arr[x.first] * arr[y.second] > arr[x.second] * arr[y.first];\n        };\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> q(cmp);\n        for (int j = 1; j < n; ++j) {\n            q.emplace(0, j);\n        }\n        for (int _ = 1; _ < k; ++_) {\n            auto [i, j] = q.top();\n            q.pop();\n            if (i + 1 < j) {\n                q.emplace(i + 1, j);\n            }\n        }\n        return {arr[q.top().first], arr[q.top().second]};\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\n        int n = arr.length;\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((x, y) -> arr[x[0]] * arr[y[1]] - arr[y[0]] * arr[x[1]]);\n        for (int j = 1; j < n; ++j) {\n            pq.offer(new int[]{0, j});\n        }\n        for (int i = 1; i < k; ++i) {\n            int[] frac = pq.poll();\n            int x = frac[0], y = frac[1];\n            if (x + 1 < y) {\n                pq.offer(new int[]{x + 1, y});\n            }\n        }\n        return new int[]{arr[pq.peek()[0]], arr[pq.peek()[1]]};\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Frac:\n    def __init__(self, idx: int, idy: int, x: int, y: int) -> None:\n        self.idx = idx\n        self.idy = idy\n        self.x = x\n        self.y = y\n\n    def __lt__(self, other: \"Frac\") -> bool:\n        return self.x * other.y < self.y * other.x\n\n\nclass Solution:\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n        n = len(arr)\n        q = [Frac(0, i, arr[0], arr[i]) for i in range(1, n)]\n        heapq.heapify(q)\n\n        for _ in range(k - 1):\n            frac = heapq.heappop(q)\n            i, j = frac.idx, frac.idy\n            if i + 1 < j:\n                heapq.heappush(q, Frac(i + 1, j, arr[i + 1], arr[j]))\n        \n        return [q[0].x, q[0].y]\n```\n\n```go [sol2-Golang]\nfunc kthSmallestPrimeFraction(arr []int, k int) []int {\n    n := len(arr)\n    h := make(hp, n-1)\n    for j := 1; j < n; j++ {\n        h[j-1] = frac{arr[0], arr[j], 0, j}\n    }\n    heap.Init(&h)\n    for loop := k - 1; loop > 0; loop-- {\n        f := heap.Pop(&h).(frac)\n        if f.i+1 < f.j {\n            heap.Push(&h, frac{arr[f.i+1], f.y, f.i + 1, f.j})\n        }\n    }\n    return []int{h[0].x, h[0].y}\n}\n\ntype frac struct{ x, y, i, j int }\ntype hp []frac\nfunc (h hp) Len() int            { return len(h) }\nfunc (h hp) Less(i, j int) bool  { return h[i].x*h[j].y < h[i].y*h[j].x }\nfunc (h hp) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\nfunc (h *hp) Push(v interface{}) { *h = append(*h, v.(frac)) }\nfunc (h *hp) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(k \\log n)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度。优先队列的单次操作时间复杂度为 $O(\\log n)$，一共需要进行 $O(k)$ 次操作。\n\n- 空间复杂度：$O(n)$，即为优先队列需要使用的空间。\n\n#### 方法三：二分查找 + 双指针\n\n**思路与算法**\n\n我们可以随便猜测一个实数 $\\alpha$，如果恰好有 $k$ 个素数分数小于 $\\alpha$，那么这 $k$ 个素数分数中最大的那个就是第 $k$ 个最小的素数分数。\n\n对于 $\\alpha$，我们如何求出有多少个小于 $\\alpha$ 的素数分数呢？我们可以使用双指针来求出答案：\n\n- 我们使用一个指针 $j$ 指向分母，这个指针每次会向右移动一个位置，表示枚举不同的分母；\n\n- 我们再使用一个指针 $i$ 指向分子，这个指针会不断向右移动，并且保证 $\\dfrac{\\textit{arr}[i]}{\\textit{arr}[j]} < \\alpha$ 一直成立。当指针 $i$ 无法移动时，我们就可以知道 $\\textit{arr}[0], \\cdots, \\textit{arr}[i]$ 都可以作为分子，但 $\\textit{arr}[i+1]$ 及以后的元素都不可以，即分母为 $\\textit{arr}[j]$ 并且小于 $\\alpha$ 的素数分数有 $i+1$ 个。\n\n- 在 $j$ 向右移动的过程中，我们把每一个 $j$ 对应的 $i+1$ 都加入答案。这样在双指针的过程完成后，我们就可以得到有多少个小于 $\\alpha$ 的素数分数了。\n\n如果我们得到的答案恰好等于 $k$，那么我们再进行一遍上面的过程，求出所有 $\\dfrac{\\textit{arr}[i]}{\\textit{arr}[j]}$ 中的最大值即为第 $k$ 个最小的素数分数。但如果答案小于 $k$，这说明我们猜测的 $\\alpha$ 太小了，我们需要增加它的值；如果答案大于 $k$，这说明我们猜测的 $\\alpha$ 太大了，我们需要减少它的值。\n\n这就提示我们使用二分查找来找到合适的 $\\alpha$。二分查找的上界为 $1$，下界为 $0$。在二分查找的每一步中，我们取上下界区间的中点作为 $\\alpha$，并计算小于 $\\alpha$ 的素数分数的个数，并根据这个值来调整二分查找的上界或下界。\n\n**细节**\n\n由于我们是在实数范围内进行二分查找，那么最坏情况下需要进行多少步查找呢？\n\n可以发现，数组 $\\textit{arr}$ 中元素的最大值为 $3 \\times 10^4$，即任意两个素数分数的差值不会小于 $\\dfrac{1}{(3 \\times 10^4)^2} = \\dfrac{1}{9 \\times 10^8}$。假设第 $k$ 个最小的素数分数为 $\\beta_k$，第 $k+1$ 个为 $\\beta_{k+1}$，那么有：\n\n$$\n\\beta_{k+1} - \\beta_k > \\dfrac{1}{9 \\times 10^8}\n$$\n\n只要我们的二分查找选取的 $\\alpha$ 落在 $(\\beta_k, \\beta_{k+1}]$ 的区间内，那么就可以结束二分查找并返回答案。而二分查找的初始区间为 $[0, 1]$，每一步区间的长度会减少一半，因此在进行第 $\\lceil \\log (9 \\times 10^8) \\rceil = 30$ 次二分查找后，区间的长度小于 $\\dfrac{1}{9 \\times 10^8}$，这说明左边界和右边界中至少有一个落在 $(\\beta_k, \\beta_{k+1}]$ 区间内。不失一般性设落在区间内的是左边界，由于左边界的初始值 $0 \\notin (\\beta_k, \\beta_{k+1}]$，说明左边界的值在之前的某一步二分查找时被修改，即那一次二分查找选取的 $\\alpha$ 就落在 $(\\beta_k, \\beta_{k+1}]$ 内。\n\n这就说明我们最多只需要进行 $30$ 次二分查找。\n\n**代码**\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\n        int n = arr.size();\n        double left = 0.0, right = 1.0;\n        while (true) {\n            double mid = (left + right) / 2;\n            int i = -1, count = 0;\n            // 记录最大的分数\n            int x = 0, y = 1;\n            \n            for (int j = 1; j < n; ++j) {\n                while ((double)arr[i + 1] / arr[j] < mid) {\n                    ++i;\n                    if (arr[i] * y > arr[j] * x) {\n                        x = arr[i];\n                        y = arr[j];\n                    }\n                }\n                count += i + 1;\n            }\n\n            if (count == k) {\n                return {x, y};\n            }\n            if (count < k) {\n                left = mid;\n            }\n            else {\n                right = mid;\n            }\n        }\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\n        int n = arr.length;\n        double left = 0.0, right = 1.0;\n        while (true) {\n            double mid = (left + right) / 2;\n            int i = -1, count = 0;\n            // 记录最大的分数\n            int x = 0, y = 1;\n            \n            for (int j = 1; j < n; ++j) {\n                while ((double) arr[i + 1] / arr[j] < mid) {\n                    ++i;\n                    if (arr[i] * y > arr[j] * x) {\n                        x = arr[i];\n                        y = arr[j];\n                    }\n                }\n                count += i + 1;\n            }\n\n            if (count == k) {\n                return new int[]{x, y};\n            }\n            if (count < k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int[] KthSmallestPrimeFraction(int[] arr, int k) {\n        int n = arr.Length;\n        double left = 0.0, right = 1.0;\n        while (true) {\n            double mid = (left + right) / 2;\n            int i = -1, count = 0;\n            // 记录最大的分数\n            int x = 0, y = 1;\n            \n            for (int j = 1; j < n; ++j) {\n                while ((double) arr[i + 1] / arr[j] < mid) {\n                    ++i;\n                    if (arr[i] * y > arr[j] * x) {\n                        x = arr[i];\n                        y = arr[j];\n                    }\n                }\n                count += i + 1;\n            }\n\n            if (count == k) {\n                return new int[]{x, y};\n            }\n            if (count < k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n    }\n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n        n = len(arr)\n        left, right = 0.0, 1.0\n\n        while True:\n            mid = (left + right) / 2\n            i, count = -1, 0\n            # 记录最大的分数\n            x, y = 0, 1\n            \n            for j in range(1, n):\n                while arr[i + 1] / arr[j] < mid:\n                    i += 1\n                    if arr[i] * y > arr[j] * x:\n                        x, y = arr[i], arr[j]\n                count += i + 1\n\n            if count == k:\n                return [x, y]\n            \n            if count < k:\n                left = mid\n            else:\n                right = mid\n```\n\n```go [sol3-Golang]\nfunc kthSmallestPrimeFraction(arr []int, k int) []int {\n    n := len(arr)\n    left, right := 0., 1.\n    for {\n        mid := (left + right) / 2\n        i, count := -1, 0\n        // 记录最大的分数\n        x, y := 0, 1\n\n        for j := 1; j < n; j++ {\n            for float64(arr[i+1])/float64(arr[j]) < mid {\n                i++\n                if arr[i]*y > arr[j]*x {\n                    x, y = arr[i], arr[j]\n                }\n            }\n            count += i + 1\n        }\n\n        if count == k {\n            return []int{x, y}\n        }\n        if count < k {\n            left = mid\n        } else {\n            right = mid\n        }\n    }\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar kthSmallestPrimeFraction = function(arr, k) {\n    const n = arr.length;\n    let left = 0.0, right = 1.0;\n    while (true) {\n        const mid = (left + right) / 2;\n        let i = -1, count = 0;\n        // 记录最大的分数\n        let x = 0, y = 1;\n        \n        for (let j = 1; j < n; ++j) {\n            while (arr[i + 1] / arr[j] < mid) {\n                ++i;\n                if (arr[i] * y > arr[j] * x) {\n                    x = arr[i];\n                    y = arr[j];\n                }\n            }\n            count += i + 1;\n        }\n\n        if (count === k) {\n            return [x, y];\n        }\n        if (count < k) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log C)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度，$C$ 是数组 $\\textit{arr}$ 中元素的上界。二分查找需要进行 $\\lceil \\log C^2 \\rceil = O(\\log C)$ 次，每一步需要 $O(n)$ 的时间得到小于 $\\alpha$ 的素数分数的个数。\n\n- 空间复杂度：O(1)。"
}