{
	"titleSlug": "minimize-hamming-distance-after-swap-operations",
	"slug": "by-o240qnhzj6-tf38",
	"url": "https://leetcode-cn.com/problems/minimize-hamming-distance-after-swap-operations/solution/by-o240qnhzj6-tf38/",
	"content": "### 解题思路\n把所有可以互换的位置合并，尽量使相同的数字对应。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int Find(vector<int>& parent,int index) {\n        return index == parent[index] ? index : (parent[index] = Find(parent,parent[index]));\n    }\n\n    void Union(vector<int>& parent,vector<int>& rank,int index1, int index2) {\n        int x = Find(parent,index1), y = Find(parent,index2);\n        if (rank[x] <= rank[y]) parent[x] = y;\n        else parent[y] = x;\n        if (rank[x] == rank[y] && x != y) rank[y]++;\n    }\n    int minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& allowedSwaps) {\n        vector<int> parent(source.size()), rank(source.size(),1);\n        iota(parent.begin(),parent.end(),0);\n        unordered_map<int,unordered_map<int,int>> exist;\n        int ans =0;\n        for(auto& swap : allowedSwaps) Union(parent,rank,swap[0],swap[1]);\n        for(int i = 0;i<source.size();i++){\n            exist[Find(parent,i)][source[i]]++;\n            exist[Find(parent,i)][target[i]]--;\n        } \n        for(auto& [_,v] : exist){\n            for(auto& [_,occur] : v){\n                if(occur > 0) ans += occur;\n            }\n        }\n        return ans;\n    }\n};\n```"
}