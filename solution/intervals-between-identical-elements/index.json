{
	"titleSlug": "intervals-between-identical-elements",
	"slug": "xiang-tong-yuan-su-de-jian-ge-zhi-he-by-8r26b",
	"url": "https://leetcode-cn.com/problems/intervals-between-identical-elements/solution/xiang-tong-yuan-su-de-jian-ge-zhi-he-by-8r26b/",
	"content": "#### 方法一：数学\n\n**思路与算法**\n\n每个元素与相同数值元素间隔之和的一种方法是遍历 $\\textit{arr}$ 数组，判断每个元素是否与 $\\textit{arr}[i]$ 相等，并统计间隔之和。但对于每一个元素，统计的时间复杂度均为 $O(n)$，整体时间复杂度为 $O(n^2)$，不符合题目要求。因此我们需要对统计的过程进行优化。\n\n我们用 $\\textit{res}$ 数组来维护每个元素与相同数值元素间隔之和。对于数组 $\\textit{arr}$ 的第 $i$ 个元素，它与相同数值元素的间隔之和 $\\textit{res}[i]$ 为：\n\n$$\n\\textit{res}[i] = \\sum_{j,\\ \\textit{arr}[j] = \\textit{arr}[i]} |i - j|.\n$$\n\n我们可以将这些满足 $\\textit{arr}[j] = \\textit{arr}[i]$ 的下标 $j$ 按照相对于 $i$ 的大小分成两部分，同时将绝对值展开：\n\n$$\n\\textit{res}[i] = \\sum_{j > i,\\ \\textit{arr}[j] = \\textit{arr}[i]} (j - i) + \\sum_{j < i,\\ \\textit{arr}[j] = \\textit{arr}[i]} (i - j).\n$$\n\n我们不妨设这些下标 $j$ 中小于 $i$ 的有 $n_1$ 个，大于 $i$ 的有 $n_2$ 个，那么我们可以对上式进一步展开：\n\n$$\n\\begin{aligned}\n\\textit{res}[i] &= \\sum_{j > i,\\ \\textit{arr}[j] = \\textit{arr}[i]} j - n_2 i + n_1 i - \\sum_{j < i,\\ \\textit{arr}[j] = \\textit{arr}[i]} j  \\\\\n&= (n_1 - n_2) i  + \\sum_{j > i,\\ \\textit{arr}[j] = \\textit{arr}[i]} j - \\sum_{j < i,\\ \\textit{arr}[j] = \\textit{arr}[i]} j.\n\\end{aligned}\n$$\n\n我们可以通过降低计算 $n_1, n_2$ 与两个 $j$ 的求和式的时间复杂度以满足时间复杂度的要求。\n\n一种方法是**整体计算**每个 $\\textit{res}[i]$ 对应项的数值。\n\n考虑**正向**遍历 $\\textit{arr}$ 数组，在遍历的时候利用哈希表维护每个数值迄今为止的**出现次数**和**下标之和**，这样就可以在 $O(n)$ 的时间内计算出每个 $i$ 对应的 $n_1$（即出现次数）与 $\\sum_{j < i,\\ \\textit{arr}[j] = \\textit{arr}[i]} j$（即下标之和）。同理，如果我们**反向**遍历 $\\textit{arr}$ 数组，也可以在 $O(n)$ 的时间内计算出每个 $i$ 对应的 $n_2$（即出现次数）与 $\\sum_{j > i,\\ \\textit{arr}[j] = \\textit{arr}[i]} j$（即下标之和）。那么我们便可以在 $O(n)$ 的时间内计算出所有的 $\\textit{res}[i]$。\n\n我们将 $\\textit{res}$ 数组的初值均设为 $0$，并对 $\\textit{arr}$ 数组进行两次遍历。在每次遍历时**分别维护**以数值为键，**出现次数**为值的哈希表 $\\textit{cnt}$ 以及以数值为键，**下标之和**为值的哈希表 $\\textit{total}$。具体地：\n\n- 在**正向遍历**到下标 $i$ 时，我们将 $\\textit{res}[i]$ 加上 $\\textit{cnt}[\\textit{arr}[i]] \\times i - \\textit{total}[\\textit{arr}[i]]$，即为 $n_1 i - \\sum_{j < i,\\ \\textit{arr}[j] = \\textit{arr}[i]} j$；\n\n- 在**反向遍历**到下标 $i$ 时，我们将 $\\textit{res}[i]$ 加上 $\\textit{total}[\\textit{arr}[i]] - \\textit{cnt}[\\textit{arr}[i]] \\times i$，即为 $\\sum_{j > i,\\ \\textit{arr}[j] = \\textit{arr}[i]} j - n_2 i$。\n\n两次遍历完成后，$\\textit{res}$ 数组即为 $\\textit{arr}$ 中每个元素与相同数值元素间隔之和。我们返回该数组作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<long long> getDistances(vector<int>& arr) {\n        int n = arr.size();\n        vector<long long> res(n);   // 每个元素与相同元素间隔之和\n        unordered_map<int, long long> total;   // 每个数值出现下标之和\n        unordered_map<int, int> cnt;   // 每个数值出现次数\n        // 正向遍历并更新两个哈希表以及间隔之和数组\n        for (int i = 0; i < n; ++i) {\n            int val = arr[i];\n            if (cnt.count(val)) {\n                res[i] += (long long)i * cnt[val] - total[val];\n            }\n            total[val] += i;\n            ++cnt[val];\n        }\n        // 清空哈希表，反向遍历并更新两个哈希表以及间隔之和数组\n        total.clear();\n        cnt.clear();\n        for (int i = n - 1; i >= 0; --i) {\n            int val = arr[i];\n            if (cnt.count(val)) {\n                res[i] += total[val] - (long long)i * cnt[val];\n            }\n            total[val] += i;\n            ++cnt[val];\n        }\n        return res;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def getDistances(self, arr: List[int]) -> List[int]:\n        n = len(arr)\n        res = [0] * n   # 每个元素与相同元素间隔之和\n        total = defaultdict(int)   # 每个数值出现下标之和\n        cnt = defaultdict(int)   # 每个数值出现次数\n        # 正向遍历并更新两个哈希表以及间隔之和数组\n        for i in range(n):\n            val = arr[i]\n            if val in cnt:\n                res[i] += i * cnt[val] - total[val]\n            total[val] += i\n            cnt[val] += 1\n        # 清空哈希表，反向遍历并更新两个哈希表以及间隔之和数组\n        total.clear()\n        cnt.clear()\n        for i in range(n - 1, -1, -1):\n            val = arr[i]\n            if val in cnt:\n                res[i] += total[val] - i * cnt[val] \n            total[val] += i\n            cnt[val] += 1\n        return res\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{arr}$ 的长度。即为两次遍历维护哈希表与间隔之和数组的时间复杂度。\n\n- 空间复杂度：$O(n)$，即为遍历时维护出现次数与下标之和的两个哈希表的空间开销。"
}