{
	"titleSlug": "find-if-path-exists-in-graph",
	"slug": "by-stormsunshine-jakx",
	"url": "https://leetcode-cn.com/problems/find-if-path-exists-in-graph/solution/by-stormsunshine-jakx/",
	"content": "# 前言\r\n\r\n由于给定的图是双向图，每条边都是双向边，因此对于同一条边连接的两个顶点，可以从其中任意一个顶点到达另一个顶点。\r\n\r\n判断是否存在从顶点 $\\textit{source}$ 到顶点 $\\textit{destination}$ 的有效路径，等价于判断顶点 $\\textit{source}$ 和顶点 $\\textit{destination}$ 是否连通。连通性问题可以使用广度优先搜索或深度优先搜索解决，也可以使用并查集解决。\r\n\r\n# 解法一\r\n\r\n## 思路和算法\r\n\r\n使用广度优先搜索判断是否存在从顶点 $\\textit{source}$ 到顶点 $\\textit{destination}$ 的有效路径，需要从顶点 $\\textit{source}$ 开始依次遍历每一层的顶点，判断可以到达顶点 $\\textit{destination}$。\r\n\r\n由于题目中的图的表示方式是边数组，为了方便处理，需要首先将边数组转换成邻接顶点列表的形式，转换后可以在 $O(1)$ 时间获得一个顶点的全部相邻顶点，然后使用广度优先搜索遍历图。\r\n\r\n广度优先搜索需要使用哈希表（或数组）记录每个顶点的访问状态，使用队列存储最近访问过的顶点。初始时将顶点 $\\textit{source}$ 设为已访问，并将其入队列。每次将一个顶点 $\\textit{vertex}$ 出队列，对于每个与 $\\textit{vertex}$ 相邻且未访问的顶点 $\\textit{next}$，将 $\\textit{next}$ 设为已访问，并将其入队列。当队列为空或访问到顶点 $\\textit{destination}$ 时，遍历结束，将顶点 $\\textit{destination}$ 的访问状态返回。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public boolean validPath(int n, int[][] edges, int source, int destination) {\r\n        List<Integer>[] adjacentArr = new List[n];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new ArrayList<Integer>();\r\n        }\r\n        for (int[] edge : edges) {\r\n            adjacentArr[edge[0]].add(edge[1]);\r\n            adjacentArr[edge[1]].add(edge[0]);\r\n        }\r\n        boolean[] visited = new boolean[n];\r\n        visited[source] = true;\r\n        Queue<Integer> queue = new ArrayDeque<Integer>();\r\n        queue.offer(source);\r\n        while (!queue.isEmpty() && !visited[destination]) {\r\n            int vertex = queue.poll();\r\n            List<Integer> adjacent = adjacentArr[vertex];\r\n            for (int next : adjacent) {\r\n                if (!visited[next]) {\r\n                    visited[next] = true;\r\n                    queue.offer(next);\r\n                }\r\n            }\r\n        }\r\n        return visited[destination];\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public bool ValidPath(int n, int[][] edges, int source, int destination) {\r\n        IList<int>[] adjacentArr = new IList<int>[n];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new List<int>();\r\n        }\r\n        foreach (int[] edge in edges) {\r\n            adjacentArr[edge[0]].Add(edge[1]);\r\n            adjacentArr[edge[1]].Add(edge[0]);\r\n        }\r\n        bool[] visited = new bool[n];\r\n        visited[source] = true;\r\n        Queue<int> queue = new Queue<int>();\r\n        queue.Enqueue(source);\r\n        while (queue.Count > 0 && !visited[destination]) {\r\n            int vertex = queue.Dequeue();\r\n            IList<int> adjacent = adjacentArr[vertex];\r\n            foreach (int next in adjacent) {\r\n                if (!visited[next]) {\r\n                    visited[next] = true;\r\n                    queue.Enqueue(next);\r\n                }\r\n            }\r\n        }\r\n        return visited[destination];\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n + m)$，其中 $n$ 是图中的顶点数，$m$ 是图中的边数。广度优先搜索的时间复杂度由顶点数和边数决定。\r\n\r\n- 空间复杂度：$O(n + m)$，其中 $n$ 是图中的顶点数，$m$ 是图中的边数。空间复杂度主要取决于邻接顶点列表、记录每个顶点访问状态的数组和队列，邻接顶点列表需要 $O(n + m)$ 的空间，记录每个顶点访问状态的数组和队列需要 $O(n)$ 的空间。\r\n\r\n# 解法二\r\n\r\n## 思路和算法\r\n\r\n使用深度优先搜索判断是否存在从顶点 $\\textit{source}$ 到顶点 $\\textit{destination}$ 的有效路径，需要从顶点 $\\textit{source}$ 开始依次遍历每一条路径，判断可以到达顶点 $\\textit{destination}$。\r\n\r\n由于题目中的图的表示方式是边数组，为了方便处理，需要首先将边数组转换成邻接顶点列表的形式，转换后可以在 $O(1)$ 时间获得一个顶点的全部相邻顶点，然后使用深度优先搜索遍历图。\r\n\r\n深度优先搜索需要使用哈希表（或数组）记录每个顶点的访问状态。从顶点 $\\textit{source}$ 开始遍历。每次访问一个顶点 $\\textit{vertex}$ 时，将该顶点设为已访问，对于每个与 $\\textit{vertex}$ 相邻且未访问的顶点 $\\textit{next}$，递归地访问 $\\textit{next}$。当没有更多顶点可以访问或访问到顶点 $\\textit{destination}$ 时，遍历结束，将顶点 $\\textit{destination}$ 的访问状态返回。\r\n\r\n## 代码\r\n\r\n```Java [sol2-Java]\r\nclass Solution {\r\n    List<Integer>[] adjacentArr;\r\n    boolean[] visited;\r\n\r\n    public boolean validPath(int n, int[][] edges, int source, int destination) {\r\n        adjacentArr = new List[n];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new ArrayList<Integer>();\r\n        }\r\n        for (int[] edge : edges) {\r\n            adjacentArr[edge[0]].add(edge[1]);\r\n            adjacentArr[edge[1]].add(edge[0]);\r\n        }\r\n        visited = new boolean[n];\r\n        return dfs(source, destination);\r\n    }\r\n\r\n    public boolean dfs(int vertex, int destination) {\r\n        visited[vertex] = true;\r\n        if (!visited[destination]) {\r\n            List<Integer> adjacent = adjacentArr[vertex];\r\n            for (int next : adjacent) {\r\n                if (!visited[next] && dfs(next, destination)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return visited[destination];\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol2-C#]\r\npublic class Solution {\r\n    IList<int>[] adjacentArr;\r\n    bool[] visited;\r\n\r\n    public bool ValidPath(int n, int[][] edges, int source, int destination) {\r\n        adjacentArr = new List<int>[n];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new List<int>();\r\n        }\r\n        foreach (int[] edge in edges) {\r\n            adjacentArr[edge[0]].Add(edge[1]);\r\n            adjacentArr[edge[1]].Add(edge[0]);\r\n        }\r\n        visited = new bool[n];\r\n        return DFS(source, destination);\r\n    }\r\n\r\n    public bool DFS(int vertex, int destination) {\r\n        visited[vertex] = true;\r\n        if (!visited[destination]) {\r\n            IList<int> adjacent = adjacentArr[vertex];\r\n            foreach (int next in adjacent) {\r\n                if (!visited[next] && DFS(next, destination)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return visited[destination];\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n + m)$，其中 $n$ 是图中的顶点数，$m$ 是图中的边数。深度优先搜索的时间复杂度由顶点数和边数决定。\r\n\r\n- 空间复杂度：$O(n + m)$，其中 $n$ 是图中的顶点数，$m$ 是图中的边数。空间复杂度主要取决于邻接顶点列表、记录每个顶点访问状态的数组和递归调用栈，邻接顶点列表需要 $O(n + m)$ 的空间，记录每个顶点访问状态的数组和递归调用栈需要 $O(n)$ 的空间。\r\n\r\n# 解法三\r\n\r\n## 预备知识\r\n\r\n该解法涉及到并查集。\r\n\r\n并查集是一种树型的数据结构，用于处理不相交集合的合并与查询问题。\r\n\r\n## 思路和算法\r\n\r\n这道题要求判断顶点 $\\textit{source}$ 和顶点 $\\textit{destination}$ 是否连通，连通性问题可以使用并查集解决。\r\n\r\n并查集初始化时，$n$ 个顶点分别属于 $n$ 个不同的集合，每个集合只包含一个顶点。\r\n\r\n初始化之后，遍历每条边，将同一条边连接的两个顶点所在的集合做合并。\r\n\r\n遍历所有的边之后，判断顶点 $\\textit{source}$ 和顶点 $\\textit{destination}$ 所在的集合是否相同，如果两个顶点所在的集合相同则两个顶点连通，如果两个顶点所在的集合不同则两个顶点不连通。\r\n\r\n## 代码\r\n\r\n```Java [sol3-Java]\r\nclass Solution {\r\n    public boolean validPath(int n, int[][] edges, int source, int destination) {\r\n        UnionFind uf = new UnionFind(n);\r\n        for (int[] edge : edges) {\r\n            uf.union(edge[0], edge[1]);\r\n            if (uf.find(source) == uf.find(destination)) {\r\n                return true;\r\n            }\r\n        }\r\n        return uf.find(source) == uf.find(destination);\r\n    }\r\n}\r\n\r\nclass UnionFind {\r\n    private int[] parent;\r\n    private int[] rank;\r\n\r\n    public UnionFind(int n) {\r\n        parent = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            parent[i] = i;\r\n        }\r\n        rank = new int[n];\r\n    }\r\n\r\n    public void union(int x, int y) {\r\n        int rootx = find(x);\r\n        int rooty = find(y);\r\n        if (rootx != rooty) {\r\n            if (rank[rootx] > rank[rooty]) {\r\n                parent[rooty] = rootx;\r\n            } else if (rank[rootx] < rank[rooty]) {\r\n                parent[rootx] = rooty;\r\n            } else {\r\n                parent[rooty] = rootx;\r\n                rank[rootx]++;\r\n            }\r\n        }\r\n    }\r\n\r\n    public int find(int x) {\r\n        if (parent[x] != x) {\r\n            parent[x] = find(parent[x]);\r\n        }\r\n        return parent[x];\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol3-C#]\r\npublic class Solution {\r\n    public bool ValidPath(int n, int[][] edges, int source, int destination) {\r\n        UnionFind uf = new UnionFind(n);\r\n        foreach (int[] edge in edges) {\r\n            uf.Union(edge[0], edge[1]);\r\n            if (uf.Find(source) == uf.Find(destination)) {\r\n                return true;\r\n            }\r\n        }\r\n        return uf.Find(source) == uf.Find(destination);\r\n    }\r\n}\r\n\r\nclass UnionFind {\r\n    private int[] parent;\r\n    private int[] rank;\r\n\r\n    public UnionFind(int n) {\r\n        parent = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            parent[i] = i;\r\n        }\r\n        rank = new int[n];\r\n    }\r\n\r\n    public void Union(int x, int y) {\r\n        int rootx = Find(x);\r\n        int rooty = Find(y);\r\n        if (rootx != rooty) {\r\n            if (rank[rootx] > rank[rooty]) {\r\n                parent[rooty] = rootx;\r\n            } else if (rank[rootx] < rank[rooty]) {\r\n                parent[rootx] = rooty;\r\n            } else {\r\n                parent[rooty] = rootx;\r\n                rank[rootx]++;\r\n            }\r\n        }\r\n    }\r\n\r\n    public int Find(int x) {\r\n        if (parent[x] != x) {\r\n            parent[x] = Find(parent[x]);\r\n        }\r\n        return parent[x];\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n + m \\times \\alpha(m))$，其中 $n$ 是图中的顶点数，$m$ 是图中的边数，$\\alpha$ 是反阿克曼函数。并查集的初始化需要 $O(n)$ 的时间，然后遍历 $m$ 条边执行 $m$ 次合并操作，最后对 $\\textit{source}$ 和 $\\textit{destination}$ 分别执行查询操作，这里的并查集使用了路径压缩和按秩合并，单次操作的时间复杂度是 $O(\\alpha(m))$，因此并查集初始化之后的操作的时间复杂度是 $O(m \\times \\alpha(m))$，总时间复杂度是 $O(n + m \\times \\alpha(m))$。\r\n\r\n- 空间复杂度：$O(n)$，其中 $n$ 是图中的顶点数。并查集需要 $O(n)$ 的空间。"
}