{
	"titleSlug": "linked-list-random-node",
	"slug": "lian-biao-sui-ji-jie-dian-by-leetcode-so-x6it",
	"url": "https://leetcode-cn.com/problems/linked-list-random-node/solution/lian-biao-sui-ji-jie-dian-by-leetcode-so-x6it/",
	"content": "#### 方法一：记录所有链表元素\n\n我们可以在初始化时，用一个数组记录链表中的所有元素，这样随机选择链表的一个节点，就变成在数组中随机选择一个元素。\n\n```Python [sol1-Python3]\nclass Solution:\n    def __init__(self, head: Optional[ListNode]):\n        self.arr = []\n        while head:\n            self.arr.append(head.val)\n            head = head.next\n\n    def getRandom(self) -> int:\n        return choice(self.arr)\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    vector<int> arr;\n\npublic:\n    Solution(ListNode *head) {\n        while (head) {\n            arr.emplace_back(head->val);\n            head = head->next;\n        }\n    }\n\n    int getRandom() {\n        return arr[rand() % arr.size()];\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    List<Integer> list;\n    Random random;\n\n    public Solution(ListNode head) {\n        list = new ArrayList<Integer>();\n        while (head != null) {\n            list.add(head.val);\n            head = head.next;\n        }\n        random = new Random();\n    }\n\n    public int getRandom() {\n        return list.get(random.nextInt(list.size()));\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    IList<int> list;\n    Random random;\n\n    public Solution(ListNode head) {\n        list = new List<int>();\n        while (head != null) {\n            list.Add(head.val);\n            head = head.next;\n        }\n        random = new Random();\n    }\n\n    public int GetRandom() {\n        return list[random.Next(list.Count)];\n    }\n}\n```\n\n```go [sol1-Golang]\ntype Solution []int\n\nfunc Constructor(head *ListNode) (s Solution) {\n    for node := head; node != nil; node = node.Next {\n        s = append(s, node.Val)\n    }\n    return s\n}\n\nfunc (s Solution) GetRandom() int {\n    return s[rand.Intn(len(s))]\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int * arr;\n    int length;\n} Solution;\n\nSolution* solutionCreate(struct ListNode* head) {\n    Solution * obj = (Solution *)malloc(sizeof(Solution));\n    assert(obj != NULL);\n    obj->length = 0;\n    struct ListNode * node = head;\n\n    while (node) {\n        node = node->next;\n        obj->length++;\n    }\n    obj->arr = (int *)malloc(sizeof(int) * obj->length);\n    assert(obj->arr != NULL);\n    node = head;\n    for (int i = 0; i < obj->length; i++) {\n        obj->arr[i] = node->val;\n        node = node->next;\n    }\n    return obj;\n}\n\nint solutionGetRandom(Solution* obj) {\n    return obj->arr[rand() % obj->length];\n}\n\nvoid solutionFree(Solution* obj) {\n    free(obj->arr);\n    free(obj);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar Solution = function(head) {\n    this.list = [];\n    while (head != null) {\n        this.list.push(head.val);\n        head = head.next;\n    }\n};\n\nSolution.prototype.getRandom = function() {\n    return this.list[Math.floor(Math.random() * this.list.length)];\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化为 $O(n)$，随机选择为 $O(1)$，其中 $n$ 是链表的元素个数。\n\n- 空间复杂度：$O(n)$。我们需要 $O(n)$ 的空间存储链表中的所有元素。\n\n#### 方法二：水塘抽样\n\n方法一需要花费 $O(n)$ 的空间存储链表中的所有元素，那么能否做到 $O(1)$ 的空间复杂度呢？\n\n我们可以设计如下算法：\n\n从链表头开始，遍历整个链表，对遍历到的第 $i$ 个节点，随机选择区间 $[0,i)$ 内的一个整数，如果其等于 $0$，则将答案置为该节点值，否则答案不变。\n\n该算法会保证每个节点的值成为最后被返回的值的概率均为 $\\dfrac{1}{n}$，证明如下：\n\n$$\n\\begin{aligned} \n&P(第\\ i\\ 个节点的值成为最后被返回的值)\\\\\n=&P(第\\ i\\ 次随机选择的值= 0) \\times P(第\\ i+1\\ 次随机选择的值\\ne 0) \\times \\cdots \\times P(第\\ n\\ 次随机选择的值\\ne 0)\\\\\n=&\\dfrac{1}{i} \\times (1-\\dfrac{1}{i+1}) \\times \\cdots \\times (1-\\dfrac{1}{n})\\\\\n=&\\dfrac{1}{i} \\times \\dfrac{i}{i+1} \\times \\cdots \\times \\dfrac{n-1}{n}\\\\\n=&\\dfrac{1}{n}\n\\end{aligned}\n$$\n\n```Python [sol2-Python3]\nclass Solution:\n    def __init__(self, head: Optional[ListNode]):\n        self.head = head\n\n    def getRandom(self) -> int:\n        node, i, ans = self.head, 1, 0\n        while node:\n            if randrange(i) == 0:  # 1/i 的概率选中（替换为答案）\n                ans = node.val\n            i += 1\n            node = node.next\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\n    ListNode *head;\n\npublic:\n    Solution(ListNode *head) {\n        this->head = head;\n    }\n\n    int getRandom() {\n        int i = 1, ans = 0;\n        for (auto node = head; node; node = node->next) {\n            if (rand() % i == 0) { // 1/i 的概率选中（替换为答案）\n                ans = node->val;\n            }\n            ++i;\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    ListNode head;\n    Random random;\n\n    public Solution(ListNode head) {\n        this.head = head;\n        random = new Random();\n    }\n\n    public int getRandom() {\n        int i = 1, ans = 0;\n        for (ListNode node = head; node != null; node = node.next) {\n            if (random.nextInt(i) == 0) { // 1/i 的概率选中（替换为答案）\n                ans = node.val;\n            }\n            ++i;\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    ListNode head;\n    Random random;\n\n    public Solution(ListNode head) {\n        this.head = head;\n        random = new Random();\n    }\n\n    public int GetRandom() {\n        int i = 1, ans = 0;\n        for (ListNode node = head; node != null; node = node.next) {\n            if (random.Next(i) == 0) { // 1/i 的概率选中（替换为答案）\n                ans = node.val;\n            }\n            ++i;\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol2-Golang]\ntype Solution struct {\n    head *ListNode\n}\n\nfunc Constructor(head *ListNode) Solution {\n    return Solution{head}\n}\n\nfunc (s *Solution) GetRandom() (ans int) {\n    for node, i := s.head, 1; node != nil; node = node.Next {\n        if rand.Intn(i) == 0 { // 1/i 的概率选中（替换为答案）\n            ans = node.Val\n        }\n        i++\n    }\n    return\n}\n```\n\n```C [sol2-C]\ntypedef struct {\n    struct ListNode * head;\n} Solution;\n\n\nSolution* solutionCreate(struct ListNode* head) {\n    Solution * obj = (Solution *)malloc(sizeof(Solution));\n    assert(obj != NULL);\n    obj->head = head;\n    return obj;\n}\n\nint solutionGetRandom(Solution* obj) {\n    int i = 1, ans = 0;\n    for (struct ListNode * node = obj->head; node; node = node->next) {\n        if (rand() % i == 0) { // 1/i 的概率选中（替换为答案）\n            ans = node->val;\n        }\n        ++i;\n    }\n    return ans;\n}\n\nvoid solutionFree(Solution* obj) {\n    free(obj);\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar Solution = function(head) {\n    this.head = head;\n};\n\nSolution.prototype.getRandom = function() {\n    let i = 1, ans = 0;\n    for (let node = this.head; node != null; node = node.next) {\n        if (Math.floor(Math.random() * i) === 0) { // 1/i 的概率选中（替换为答案）\n            ans = node.val;\n        }\n        ++i;\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化为 $O(1)$，随机选择为 $O(n)$，其中 $n$ 是链表的元素个数。\n\n- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。"
}