{
	"titleSlug": "stamping-the-grid",
	"slug": "wu-nao-zuo-fa-er-wei-qian-zhui-he-er-wei-zwiu",
	"url": "https://leetcode-cn.com/problems/stamping-the-grid/solution/wu-nao-zuo-fa-er-wei-qian-zhui-he-er-wei-zwiu/",
	"content": "不了解二维前缀和的同学可以先看看 [304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)。\r\n\r\n二维差分可以结合二维前缀和与一维差分的思想推导出来。当我们对一个左上角在 $(x1,y1)$，右下角在 $(x2,y2)$ 矩形区域全部增加 $x$ 时，相当于在二维差分矩阵上对 $(x1,y1)$ 增加 $x$，对 $(x1,y2+1)$ 和 $(x2+1,y1)$ 减少 $x$，由于这样两个地方都减少了 $x$，我们还需要在 $(x2+1,y2+1)$ 处增加 $x$，读者可以用二维前缀和对比体会这一做法。\r\n\r\n回到本题。由于邮票可以互相重叠，我们遵从能放就放邮票的策略，遍历所有的空位，尝试以该空位为左上角放置邮票。如果这一矩形没有出界且区域内没有被占据的格子，那么就可以放置邮票，并按照二维差分的做法将区域内的所有元素值加一。判断区域内有没有被占据的格子，可以先求出 $\\textit{grid}$ 的二维前缀和，这样可以 $O(1)$ 判断。\r\n\r\n遍历结束后，我们需要从二维差分矩阵还原出二维计数矩阵，这可以通过对二维差分矩阵求二维前缀和求出。遍历计数矩阵，如果存在一个空格子的计数值为 $0$，就表明该空格子没有被邮票覆盖，返回 $\\texttt{false}$，否则返回 $\\texttt{true}$。\r\n\r\n时间复杂度和空间复杂度均为 $O(mn)$。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\r\n        m, n = len(grid), len(grid[0])\r\n        sum = [[0] * (n + 1) for _ in range(m + 1)]\r\n        diff = [[0] * (n + 1) for _ in range(m + 1)]\r\n        for i, row in enumerate(grid):\r\n            for j, v in enumerate(row):  # grid 的二维前缀和\r\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + v\r\n\r\n        for i, row in enumerate(grid):\r\n            for j, v in enumerate(row):\r\n                if v == 0:\r\n                    x, y = i + stampHeight, j + stampWidth  # 注意这是矩形右下角横纵坐标都 +1 后的位置\r\n                    if x <= m and y <= n and sum[x][y] - sum[x][j] - sum[i][y] + sum[i][j] == 0:\r\n                        diff[i][j] += 1\r\n                        diff[i][y] -= 1\r\n                        diff[x][j] -= 1\r\n                        diff[x][y] += 1  # 更新二维差分\r\n\r\n        # 还原二维差分矩阵对应的计数矩阵，这里用滚动数组实现\r\n        cnt, pre = [0] * (n + 1), [0] * (n + 1)\r\n        for i, row in enumerate(grid):\r\n            for j, v in enumerate(row):\r\n                cnt[j + 1] = cnt[j] + pre[j + 1] - pre[j] + diff[i][j]\r\n                if cnt[j + 1] == 0 and v == 0:\r\n                    return False\r\n            cnt, pre = pre, cnt\r\n        return True\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    bool possibleToStamp(vector<vector<int>> &grid, int stampHeight, int stampWidth) {\r\n        int m = grid.size(), n = grid[0].size();\r\n        vector<vector<int>> sum(m + 1, vector<int>(n + 1)), diff(m + 1, vector<int>(n + 1));\r\n        for (int i = 0; i < m; ++i) {\r\n            for (int j = 0; j < n; ++j) { // grid 的二维前缀和\r\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < m; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                int x = i + stampHeight, y = j + stampWidth; // 注意这是矩形右下角横纵坐标都 +1 后的位置\r\n                if (x <= m && y <= n && sum[x][y] - sum[x][j] - sum[i][y] + sum[i][j] == 0) {\r\n                    ++diff[i][j];\r\n                    --diff[i][y];\r\n                    --diff[x][j];\r\n                    ++diff[x][y]; // 更新二维差分\r\n                }\r\n            }\r\n        }\r\n\r\n        // 还原二维差分矩阵对应的计数矩阵，这里用滚动数组实现\r\n        vector<int> cnt(n + 1), pre(n + 1);\r\n        for (int i = 0; i < m; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                cnt[j + 1] = cnt[j] + pre[j + 1] - pre[j] + diff[i][j];\r\n                if (cnt[j + 1] == 0 && grid[i][j] == 0) {\r\n                    return false;\r\n                }\r\n            }\r\n            swap(cnt, pre);\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```\r\n \r\n```go [sol1-Go]\r\nfunc possibleToStamp(grid [][]int, stampHeight, stampWidth int) bool {\r\n\tm, n := len(grid), len(grid[0])\r\n\tsum := make([][]int, m+1)\r\n\tsum[0] = make([]int, n+1)\r\n\tdiff := make([][]int, m+1)\r\n\tdiff[0] = make([]int, n+1)\r\n\tfor i, row := range grid {\r\n\t\tsum[i+1] = make([]int, n+1)\r\n\t\tfor j, v := range row { // grid 的二维前缀和\r\n\t\t\tsum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + v\r\n\t\t}\r\n\t\tdiff[i+1] = make([]int, n+1)\r\n\t}\r\n\r\n\tfor i, row := range grid {\r\n\t\tfor j, v := range row {\r\n\t\t\tif v == 0 {\r\n\t\t\t\tx, y := i+stampHeight, j+stampWidth // 注意这是矩形右下角横纵坐标都 +1 后的位置\r\n\t\t\t\tif x <= m && y <= n && sum[x][y]-sum[x][j]-sum[i][y]+sum[i][j] == 0 {\r\n\t\t\t\t\tdiff[i][j]++\r\n\t\t\t\t\tdiff[i][y]--\r\n\t\t\t\t\tdiff[x][j]--\r\n\t\t\t\t\tdiff[x][y]++ // 更新二维差分\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// 还原二维差分矩阵对应的计数矩阵，这里用滚动数组实现\r\n\tcnt := make([]int, n+1)\r\n\tpre := make([]int, n+1)\r\n\tfor i, row := range grid {\r\n\t\tfor j, v := range row {\r\n\t\t\tcnt[j+1] = cnt[j] + pre[j+1] - pre[j] + diff[i][j]\r\n\t\t\tif cnt[j+1] == 0 && v == 0 {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\tcnt, pre = pre, cnt\r\n\t}\r\n\treturn true\r\n}\r\n```\r\n"
}