{
	"titleSlug": "most-common-word",
	"slug": "zui-chang-jian-de-dan-ci-by-leetcode-sol-mzjb",
	"url": "https://leetcode-cn.com/problems/most-common-word/solution/zui-chang-jian-de-dan-ci-by-leetcode-sol-mzjb/",
	"content": "#### 方法一：哈希表 + 计数\n\n为了判断给定段落中的每个单词是否在禁用单词列表中，需要使用哈希集合存储禁用单词列表中的单词。以下将禁用单词列表中的单词称为禁用单词。\n\n遍历段落 $\\textit{paragraph}$，得到段落中的所有单词，并对每个单词计数，使用哈希表记录每个单词的计数。由于每个单词由连续的字母组成，因此当遇到一个非字母的字符且该字符的前一个字符是字母时，即为一个单词的结束，如果该单词不是禁用单词，则将该单词的计数加 $1$。如果段落的最后一个字符是字母，则当遍历结束时需要对段落中的最后一个单词判断是否为禁用单词，如果不是禁用单词则将次数加 $1$。\n\n在遍历段落的过程中，对于每个单词都会更新计数，因此遍历结束之后即可得到最大计数，即出现次数最多的单词的出现次数。\n\n遍历段落之后，遍历哈希表，寻找出现次数等于最大计数的单词，该单词即为最常见的单词。\n\n```Python [sol1-Python3]\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        ban = set(banned)\n        freq = Counter()\n        word, n = \"\", len(paragraph)\n        for i in range(n + 1):\n            if i < n and paragraph[i].isalpha():\n                word += paragraph[i].lower()\n            elif word:\n                if word not in ban:\n                    freq[word] += 1\n                word = \"\"\n        maxFreq = max(freq.values())\n        return next(word for word, f in freq.items() if f == maxFreq)\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String mostCommonWord(String paragraph, String[] banned) {\n        Set<String> bannedSet = new HashSet<String>();\n        for (String word : banned) {\n            bannedSet.add(word);\n        }\n        int maxFrequency = 0;\n        Map<String, Integer> frequencies = new HashMap<String, Integer>();\n        StringBuffer sb = new StringBuffer();\n        int length = paragraph.length();\n        for (int i = 0; i <= length; i++) {\n            if (i < length && Character.isLetter(paragraph.charAt(i))) {\n                sb.append(Character.toLowerCase(paragraph.charAt(i)));\n            } else if (sb.length() > 0) {\n                String word = sb.toString();\n                if (!bannedSet.contains(word)) {\n                    int frequency = frequencies.getOrDefault(word, 0) + 1;\n                    frequencies.put(word, frequency);\n                    maxFrequency = Math.max(maxFrequency, frequency);\n                }\n                sb.setLength(0);\n            }\n        }\n        String mostCommon = \"\";\n        Set<Map.Entry<String, Integer>> entries = frequencies.entrySet();\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            int frequency = entry.getValue();\n            if (frequency == maxFrequency) {\n                mostCommon = word;\n                break;\n            }\n        }\n        return mostCommon;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string MostCommonWord(string paragraph, string[] banned) {\n        ISet<string> bannedSet = new HashSet<string>();\n        foreach (string word in banned) {\n            bannedSet.Add(word);\n        }\n        int maxFrequency = 0;\n        Dictionary<string, int> frequencies = new Dictionary<string, int>();\n        StringBuilder sb = new StringBuilder();\n        int length = paragraph.Length;\n        for (int i = 0; i <= length; i++) {\n            if (i < length && char.IsLetter(paragraph[i])) {\n                sb.Append(char.ToLower(paragraph[i]));\n            } else if (sb.Length > 0) {\n                string word = sb.ToString();\n                if (!bannedSet.Contains(word)) {\n                    if (!frequencies.ContainsKey(word)) {\n                        frequencies.Add(word, 1);\n                    } else {\n                        frequencies[word]++;\n                    }\n                    maxFrequency = Math.Max(maxFrequency, frequencies[word]);\n                }\n                sb.Length = 0;\n            }\n        }\n        string mostCommon = \"\";\n        foreach (KeyValuePair<string, int> pair in frequencies) {\n            string word = pair.Key;\n            int frequency = pair.Value;\n            if (frequency == maxFrequency) {\n                mostCommon = word;\n                break;\n            }\n        }\n        return mostCommon;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string mostCommonWord(string paragraph, vector<string>& banned) {\n        unordered_set<string> bannedSet;\n        for (auto & word : banned) {\n            bannedSet.emplace(word);\n        }\n        int maxFrequency = 0;\n        unordered_map<string, int> frequencies;\n        string word;\n        int length = paragraph.size();\n        for (int i = 0; i <= length; i++) {\n            if (i < length && isalpha(paragraph[i])) {\n                word.push_back(tolower(paragraph[i]));\n            } else if (word.size() > 0) {\n                if (!bannedSet.count(word)) {\n                    frequencies[word]++;\n                    maxFrequency = max(maxFrequency, frequencies[word]);\n                }\n                word = \"\";\n            }\n        }\n        string mostCommon = \"\";\n        for (auto &[word , frequency] : frequencies) {\n            if (frequency == maxFrequency) {\n                mostCommon = word;\n                break;\n            }\n        }\n        return mostCommon;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    char * key;\n    UT_hash_handle hh;\n} HashSetItem;\n\ntypedef struct {\n    char * key;\n    int val;\n    UT_hash_handle hh;\n} HashMapItem;\n\n#define MAX_STR_LEN 1024\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nchar * mostCommonWord(char * paragraph, char ** banned, int bannedSize){\n    HashSetItem * bannedSet = NULL;\n    for (int i = 0; i < bannedSize; i++) {\n        HashSetItem * pSetEntry = NULL;\n        HASH_FIND_STR(bannedSet, banned[i], pSetEntry);\n        if (NULL == pSetEntry) {\n            pSetEntry = (HashSetItem *)malloc(sizeof(HashSetItem));\n            pSetEntry->key = banned[i];\n            HASH_ADD_STR(bannedSet, key, pSetEntry);\n        }\n    }\n    int maxFrequency = 0;\n    char * mostCommon = (char *)malloc(sizeof(char) * MAX_STR_LEN);\n    HashMapItem * frequencies = NULL;\n    char word[MAX_STR_LEN];\n    int pos = 0;\n    int length = strlen(paragraph);\n    for (int i = 0; i <= length; i++) {\n        if (i < length && isalpha(paragraph[i])) {\n            word[pos++] = tolower(paragraph[i]);\n        } else if (pos > 0) {\n            HashSetItem * pSetEntry = NULL;\n            word[pos] = 0;\n            HASH_FIND_STR(bannedSet, word, pSetEntry);\n            if (NULL == pSetEntry) {\n                HashMapItem * pMapEntry = NULL;\n                HASH_FIND_STR(frequencies, word, pMapEntry);\n                if (NULL == pMapEntry) {\n                    pMapEntry = (HashMapItem *)malloc(sizeof(HashMapItem));\n                    pMapEntry->key = (char *)malloc(sizeof(char) * pos);\n                    strcpy(pMapEntry->key, word);\n                    pMapEntry->val = 1;\n                    HASH_ADD_STR(frequencies, key, pMapEntry);\n                } else {\n                    pMapEntry->val++;\n                }\n                if (maxFrequency < pMapEntry->val) {\n                    maxFrequency = pMapEntry->val;\n                    strcpy(mostCommon, word);\n                }\n            }\n            pos = 0;\n        }\n    }\n    return mostCommon;\n}\n```\n\n```go [sol1-Golang]\nfunc mostCommonWord(paragraph string, banned []string) string {\n    ban := map[string]bool{}\n    for _, s := range banned {\n        ban[s] = true\n    }\n    freq := map[string]int{}\n    maxFreq := 0\n    var word []byte\n    for i, n := 0, len(paragraph); i <= n; i++ {\n        if i < n && unicode.IsLetter(rune(paragraph[i])) {\n            word = append(word, byte(unicode.ToLower(rune(paragraph[i]))))\n        } else if word != nil {\n            s := string(word)\n            if !ban[s] {\n                freq[s]++\n                maxFreq = max(maxFreq, freq[s])\n            }\n            word = nil\n        }\n    }\n    for s, f := range freq {\n        if f == maxFreq {\n            return s\n        }\n    }\n    return \"\"\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar mostCommonWord = function(paragraph, banned) {\n    const bannedSet = new Set();\n    for (const word of banned) {\n        bannedSet.add(word);\n    }\n    let maxFrequency = 0;\n    const frequencies = new Map();\n    let sb = '';\n    const length = paragraph.length;\n    for (let i = 0; i <= length; i++) {\n        if (i < length && isLetter(paragraph[i])) {\n            sb = sb + paragraph[i].toLowerCase();\n        } else if (sb.length > 0) {\n            if (!bannedSet.has(sb)) {\n                const frequency = (frequencies.get(sb) || 0) + 1;\n                frequencies.set(sb, frequency);\n                maxFrequency = Math.max(maxFrequency, frequency);\n            }\n            sb = '';\n        }\n    }\n    let mostCommon = \"\";\n    for (const [word, frequency] of frequencies.entries()) {\n        if (frequency === maxFrequency) {\n            mostCommon = word;\n            break;\n        }\n    }\n    return mostCommon;\n};\n\nconst isLetter = (ch) => {\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + m)$，其中 $n$ 是段落 $\\textit{paragraph}$ 的长度，$m$ 是禁用单词列表 $\\textit{banned}$ 的长度。遍历禁用单词列表一次将禁用单词存入哈希集合中需要 $O(m)$ 的时间，遍历段落得到每个非禁用单词的计数需要 $O(n)$ 的时间，遍历哈希表得到最常见的单词需要 $O(n)$ 的时间。\n\n- 空间复杂度：$O(n + m)$，其中 $n$ 是段落 $\\textit{paragraph}$ 的长度，$m$ 是禁用单词列表 $\\textit{banned}$ 的长度。存储禁用单词的哈希集合需要 $O(m)$ 的空间，记录每个单词的计数的哈希表需要 $O(n)$ 的空间。"
}