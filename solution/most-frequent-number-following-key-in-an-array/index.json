{
	"titleSlug": "most-frequent-number-following-key-in-an-array",
	"slug": "shu-zu-zhong-jin-gen-key-zhi-hou-chu-xia-elzm",
	"url": "https://leetcode-cn.com/problems/most-frequent-number-following-key-in-an-array/solution/shu-zu-zhong-jin-gen-key-zhi-hou-chu-xia-elzm/",
	"content": "#### 方法一：哈希表\n\n**思路与算法**\n\n我们不妨用 $n$ 表示 $\\textit{nums}$ 数组的元素数量。为了统计不同 $\\textit{target}$ 的出现次数，我们可以用哈希表 $\\textit{freq}$ 来维护。\n\n具体而言，我们遍历 $\\textit{nums}$ 数组中下标 $i$ 在**闭区间** $[0, n - 2]$ 的元素。当 $\\textit{nums}[i] = \\textit{key}$ 时，$\\textit{nums}[i + 1]$ 即为 $\\textit{target}$，我们在 $\\textit{freq}$ 中将该元素的出现次数加上 $1$。最终，我们统计哈希表 $\\textit{freq}$ 中统计出现次数最多的数字，并返回作为答案。\n\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int mostFrequent(vector<int>& nums, int key) {\n        int n = nums.size();\n        unordered_map<int, int> freq;   // 统计出现次数的哈希表\n        for (int i = 0; i < n - 1; ++i) {\n            if (nums[i] == key) {\n                ++freq[nums[i+1]];\n            }\n        }\n        // 计算并返回最高频元素\n        int maxfreq = 0;\n        int res = 0;\n        for (const auto& [v, f]: freq) {\n            if (f > maxfreq) {\n                res = v; \n                maxfreq = f;\n            }\n        }\n        return res;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def mostFrequent(self, nums: List[int], key: int) -> int:\n        n = len(nums)\n        freq = Counter()   # 统计出现次数的哈希表\n        for i in range(n - 1):\n            if nums[i] == key:\n                freq[nums[i+1]] += 1;\n        return freq.most_common(1)[0][0]   # 计算并返回最高频元素\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度。即为统计各个 $\\textit{target}$ 出现次数哈希表，并计算出现次数最多的 $\\textit{target}$ 的时间复杂度。\n\n- 空间复杂度：$O(n)$，即为统计各个 $\\textit{target}$ 出现次数哈希表的空间开销。"
}