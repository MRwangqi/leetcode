{
	"titleSlug": "reduce-array-size-to-the-half",
	"slug": "shu-zu-da-xiao-jian-ban-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/reduce-array-size-to-the-half/solution/shu-zu-da-xiao-jian-ban-by-leetcode-solution/",
	"content": "#### 方法一：贪心算法\n\n在每一步操作中，我们需要选择一个数 `x`，并且删除数组 `arr` 中所有的 `x`。显然选择的数 `x` 在数组 `arr` 中出现的次数越多越好。因此我们可以统计数组 `arr` 中每个数出现的次数，并进行降序排序。在得到了排序的结果之后，我们依次选择这些数进行删除，直到删除了至少一半的数。\n\n在统计数组 `arr` 中每个数出现的次数时，我们可以借助哈希映射（HashMap），对于其中的每个键值对，键表示数 `x`，值表示数 `x` 出现的次数。在统计结束后，我们只要取出哈希映射中的所有值进行降序排序即可。在进行删除时，我们实际上也只需要将删除的数的个数进行累加，直到累加的值达到数组 `arr` 长度的一半，而不需要真正地将数组 `arr` 中的数删除。\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minSetSize(vector<int>& arr) {\n        unordered_map<int, int> freq;\n        for (int num: arr) {\n            ++freq[num];\n        }\n        vector<int> occ;\n        for (auto& [k, v]: freq) {\n            occ.push_back(v);\n        }\n        sort(occ.begin(), occ.end(), greater<int>());\n        int cnt = 0, ans = 0;\n        for (int c: occ) {\n            cnt += c;\n            ans += 1;\n            if (cnt * 2 >= arr.size()) {\n                break;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        freq = collections.Counter(arr)\n        cnt, ans = 0, 0\n        for num, occ in freq.most_common():\n            cnt += occ\n            ans += 1\n            if cnt * 2 >= len(arr):\n                break\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N\\log N)$，其中 $N$ 是数组 `arr` 的长度。\n\n- 空间复杂度：$O(N)$。"
}