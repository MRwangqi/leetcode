{
	"titleSlug": "maximize-the-confusion-of-an-exam",
	"slug": "kao-shi-de-zui-da-kun-rao-du-by-leetcode-qub5",
	"url": "https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/solution/kao-shi-de-zui-da-kun-rao-du-by-leetcode-qub5/",
	"content": "#### 方法一：滑动窗口\n\n**思路和算法**\n\n只要求最大连续指定字符的数目时，本题和「[1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)」完全一致。\n\n在指定字符的情况下，我们可以计算其最大连续数目。具体地，我们使用滑动窗口的方法，从左到右枚举右端点，维护区间中另一种字符的数量为 $\\textit{sum}$，当 $\\textit{sum}$ 超过 $k$，我们需要让左端点右移，直到 $\\textit{sum} \\leq k$。移动过程中，我们记录滑动窗口的最大长度，即为指定字符的最大连续数目。\n\n本题的答案为分别指定字符为 $T$ 和 $F$ 时的最大连续数目的较大值。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\n        def maxConsecutiveChar(ch: str) -> int:\n            ans, left, sum = 0, 0, 0\n            for right in range(len(answerKey)):\n                sum += answerKey[right] != ch\n                while sum > k:\n                    sum -= answerKey[left] != ch\n                    left += 1\n                ans = max(ans, right - left + 1)\n            return ans\n        return max(maxConsecutiveChar('T'), maxConsecutiveChar('F'))\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxConsecutiveChar(string& answerKey, int k, char ch) {\n        int n = answerKey.length();\n        int ans = 0;\n        for (int left = 0, right = 0, sum = 0; right < n; right++) {\n            sum += answerKey[right] != ch;\n            while (sum > k) {\n                sum -= answerKey[left++] != ch;\n            }\n            ans = max(ans, right - left + 1);\n        }\n        return ans;\n    }\n\n    int maxConsecutiveAnswers(string answerKey, int k) {\n        return max(maxConsecutiveChar(answerKey, k, 'T'),\n                   maxConsecutiveChar(answerKey, k, 'F'));\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maxConsecutiveAnswers(String answerKey, int k) {\n        return Math.max(maxConsecutiveChar(answerKey, k, 'T'), maxConsecutiveChar(answerKey, k, 'F'));\n    }\n\n    public int maxConsecutiveChar(String answerKey, int k, char ch) {\n        int n = answerKey.length();\n        int ans = 0;\n        for (int left = 0, right = 0, sum = 0; right < n; right++) {\n            sum += answerKey.charAt(right) != ch ? 1 : 0;\n            while (sum > k) {\n                sum -= answerKey.charAt(left++) != ch ? 1 : 0;\n            }\n            ans = Math.max(ans, right - left + 1);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MaxConsecutiveAnswers(string answerKey, int k) {\n        return Math.Max(MaxConsecutiveChar(answerKey, k, 'T'), MaxConsecutiveChar(answerKey, k, 'F'));\n    }\n\n    public int MaxConsecutiveChar(string answerKey, int k, char ch) {\n        int n = answerKey.Length;\n        int ans = 0;\n        for (int left = 0, right = 0, sum = 0; right < n; right++) {\n            sum += answerKey[right] != ch ? 1 : 0;\n            while (sum > k) {\n                sum -= answerKey[left++] != ch ? 1 : 0;\n            }\n            ans = Math.Max(ans, right - left + 1);\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint maxConsecutiveChar(const char * answerKey, int k, char ch) {\n    int n = strlen(answerKey);\n    int ans = 0;\n    for (int left = 0, right = 0, sum = 0; right < n; right++) {\n        sum += answerKey[right] != ch;\n        while (sum > k) {\n            sum -= answerKey[left++] != ch;\n        }\n        ans = MAX(ans, right - left + 1);\n    }\n    return ans;\n}\n\nint maxConsecutiveAnswers(char * answerKey, int k) {\n    int cnt1 = maxConsecutiveChar(answerKey, k, 'T');\n    int cnt2 = maxConsecutiveChar(answerKey, k, 'F');\n    return MAX(cnt1, cnt2);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maxConsecutiveAnswers = function(answerKey, k) {\n    return Math.max(maxConsecutiveChar(answerKey, k, 'T'), maxConsecutiveChar(answerKey, k, 'F'));\n}\n\nconst maxConsecutiveChar = (answerKey, k, ch) => {\n    const n = answerKey.length;\n    let ans = 0;\n    for (let left = 0, right = 0, sum = 0; right < n; right++) {\n        sum += answerKey.charAt(right) !== ch ? 1 : 0;\n        while (sum > k) {\n            sum -= answerKey[left++] !== ch ? 1 : 0;\n        }\n        ans = Math.max(ans, right - left + 1);\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc maxConsecutiveChar(answerKey string, k int, ch byte) (ans int) {\n    left, sum := 0, 0\n    for right := range answerKey {\n        if answerKey[right] != ch {\n            sum++\n        }\n        for sum > k {\n            if answerKey[left] != ch {\n                sum--\n            }\n            left++\n        }\n        ans = max(ans, right-left+1)\n    }\n    return\n}\n\nfunc maxConsecutiveAnswers(answerKey string, k int) int {\n    return max(maxConsecutiveChar(answerKey, k, 'T'),\n               maxConsecutiveChar(answerKey, k, 'F'))\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为字符串长度，我们只需要遍历该字符串两次。\n\n- 空间复杂度：$O(1)$，我们只需要常数的空间保存若干变量。"
}