{
	"titleSlug": "tree-of-coprimes",
	"slug": "by-masx200-t21r",
	"url": "https://leetcode-cn.com/problems/tree-of-coprimes/solution/by-masx200-t21r/",
	"content": "### 解题思路\n深度优先搜索,预处理所有的互质数,记录每个节点的深度\n对于每个值,维护一个栈,记录当前的序号和深度\n回溯时,从当前值的栈中移除栈顶\n由于节点数量10**5个,而值的个数只有50个,导致树的深度可能非常大\n\n对于每个节点,在值从1到50的栈中找到互质且深度最大的节点,放入结果数组中\n\n给你一个 n 个节点的树\n\n时间复杂度O(n)\n\n\n### 代码\ntypescript\n784 ms\t 95.6 MB\n\ngo\n480 ms\t 76.8 MB \n```typescript []\nfunction getCoprimes(nums: number[], edges: number[][]): number[] {\n    const edge = Array(nums.length)\n        .fill(0)\n        .map(() => Array<number>());\n    for (const [a, b] of edges) {\n        edge[a].push(b);\n        edge[b].push(a);\n    }\n\n    if (prime.length === 0) {\n        for (const i of Array(51).keys()) {\n            prime[i] = Array(51).fill(false);\n        }\n\n        for (const i of Array(51).keys())\n            for (let j = i; j < 51; j++) {\n                prime[i][j] = prime[j][i] = greatestCommonDivisor(i, j) === 1;\n            }\n    }\nconst set=new Set(nums)\n    const visited = new Set<number>();\n    const currents: [number, number][][] = Array(51)\n        .fill(0)\n        .map(() => []);\n    function dfs(node: number, depth: number) {\n        if (visited.has(node)) {\n            return;\n        }\n        visited.add(node);\n        const value = nums[node];\n\n        let ans = [-1, -1];\n        for (const i of set) {\n            if (currents[i].length && prime[value][i]) {\n                const get = currents[i].at(-1) as [number, number];\n\n                if (get[1] > ans[1]) {\n                    ans = get;\n                }\n            }\n        }\n        results[node] = ans[0];\n        for (const child of edge[node]) {\n            currents[value].push([node, depth]);\n            dfs(child, depth + 1);\n            currents[value].pop();\n        }\n    }\n    const results: number[] = Array(nums.length).fill(-1);\n    dfs(0, 0);\n    return results;\n}\n\nconst prime: boolean[][] = [];\n\nfunction greatestCommonDivisor(a: number, b: number): number {\n    return b != 0 ? greatestCommonDivisor(b, a % b) : a;\n}\n```\n```go []\n\nvar prime = make([][]bool, 0)\n\nfunc getCoprimes(nums []int, edges [][]int) []int {\n\tvar edge = make([][]int, len(nums))\n\n\tfor i := range edge {\n\t\tedge[i] = make([]int, 0)\n\t}\n\tfor _, e := range edges {\n\t\ta, b := e[0], e[1]\n\t\tedge[a] = append(edge[a], b)\n\t\tedge[b] = append(edge[b], a)\n\t}\n\tif len(prime) == 0 {\n\t\tfor i := 0; i < 51; i++ {\n\t\t\tprime = append(prime, make([]bool, 51))\n\t\t}\n\t\tfor i := 0; i < 51; i++ {\n\t\t\tfor j := i; j < 51; j++ {\n\t\t\t\tprime[j][i] = greatestCommonDivisor(i, j) == 1\n\t\t\t\tprime[i][j] = prime[j][i]\n\t\t\t}\n\t\t}\n\t}\n\n\tvar set = make(map[int]bool, 0)\n\tfor _, n := range nums {\n\t\tset[n] = true\n\t}\n\tvar visited = make(map[int]bool, 0)\n\tvar currents = make([][][]int, 51)\n\tfor i := 0; i < 51; i++ {\n\t\tcurrents[i] = make([][]int, 0)\n\t}\n\n\tvar results = make([]int, len(nums))\n\tvar dfs func(node, depth int)\n\tdfs = func(node, depth int) {\n\t\tif visited[node] {\n\t\t\treturn\n\t\t}\n\t\tvisited[node] = true\n\t\tvar value = nums[node]\n\t\tvar ans = []int{-1, -1}\n\t\tfor i := range set {\n\t\t\tif len(currents[i]) > 0 && prime[value][i] {\n\t\t\t\t\tvar get = currents[i][len(currents[i])-1]\n\t\t\t\tif get[1] > ans[1] {\n\t\t\t\t\tans = get\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresults[node] = ans[0]\n\n\t\tfor _, child := range edge[node] {\n\t\t\tcurrents[value] = append(currents[value], []int{node, depth})\n\n\t\t\tdfs(child, depth+1)\n\t\t\tcurrents[value] = currents[value][0 : len(currents[value])-1]\n\t\t}\n\t}\n\tdfs(0, 0)\n\n\treturn results\n}\n\nfunc greatestCommonDivisor(a int, b int) int {\n\tfor b != 0 {\n\t\treturn greatestCommonDivisor(b, a%b)\n\t}\n\treturn a\n}\n```"
}