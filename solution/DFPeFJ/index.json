{
	"titleSlug": "DFPeFJ",
	"slug": "dijkstrasuan-fa-qiu-zui-duan-lu-jing-by-usiix",
	"url": "https://leetcode-cn.com/problems/DFPeFJ/solution/dijkstrasuan-fa-qiu-zui-duan-lu-jing-by-usiix/",
	"content": "### 解题思路\n我们将`(city,charge)`二元组视为节点，然后建图，以`(start,0)`为起点跑一遍Dijkstra即可得到结果。\n\n新图的节点数为$\\mathcal{O}(NC)$，边数为$\\mathcal{O}(N(C+M))$。$C$为最大电量，$M$为原来的边数。\n\n### 代码\n\n```c++\nconst int INF = 0x3f3f3f3f;\n\nclass Solution {\npublic:\n    int electricCarPlan(vector<vector<int>>& paths, int cnt, int start, int end, vector<int>& charge) {\n        int n = charge.size();\n        vector<vector<int>> dist(n, vector<int>(cnt + 1, INF));\n        dist[start][0] = 0;\n        \n        vector<vector<pair<int, int>>> adj(n);\n        for (auto &path : paths) {\n            int u = path[0], v = path[1], w = path[2];\n            adj[u].emplace_back(v, w);\n            adj[v].emplace_back(u, w);\n        }\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;\n        pq.emplace(0, start, 0);\n        \n        while (!pq.empty()) {\n            auto [t, u, c] = pq.top();\n            pq.pop();\n            if (t > dist[u][c])\n                continue;\n            if (u == end)\n                return t;\n\n            // 当前电不满，充电一分钟，状态变为(u,c+1)\n            if (c < cnt) {\n                int nt = t + charge[u];\n                if (nt < dist[u][c + 1]) {\n                    dist[u][c + 1] = nt;\n                    pq.emplace(nt, u, c + 1);\n                }\n            }\n\n            // 如果一条边(u,v,w)能走，尝试走这条边，状态变为(v,c-w)\n            for (auto [v, w] : adj[u]) {\n                if (c >= w && t + w < dist[v][c - w]) {\n                    dist[v][c - w] = t + w;\n                    pq.emplace(t + w, v, c - w);\n                }\n            }\n        }\n        \n        return -1;\n    }\n};\n```"
}