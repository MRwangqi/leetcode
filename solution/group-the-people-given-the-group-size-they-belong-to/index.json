{
	"titleSlug": "group-the-people-given-the-group-size-they-belong-to",
	"slug": "yong-hu-fen-zu-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/group-the-people-given-the-group-size-they-belong-to/solution/yong-hu-fen-zu-by-leetcode-solution/",
	"content": "#### 方法一：哈希表\n\n由于给定的输入一定存在有效的解，因此对于数组 $\\textit{groupSizes}$ 中的每个元素 $x$，当 $x$ 在数组中出现 $y$ 次时，$y$ 一定能被 $x$ 整除，且大小为 $x$ 的组有 $\\dfrac{y}{x}$ 个。\n\n首先将每个人的编号按照组的大小划分，使用哈希表记录每个组的大小对应的所有人的编号。然后遍历哈希表，对于大小为 $x$ 的组，得到对应的所有人编号列表，将列表的大小记为 $y$，则 $y$ 一定能被 $x$ 整除，将列表分成 $\\dfrac{y}{x}$ 个大小为 $x$ 的组，并将每个组添加到答案中。遍历结束之后，即完成分组。\n\n考虑示例 1 的分组。\n\n1. 根据数组 $\\textit{groupSizes}$ 得到每个组的大小对应的所有人的编号：大小为 $1$ 的组对应的编号列表是 $[5]$，大小为 $3$ 的组对应的编号列表是 $[0, 1, 2, 3, 4, 6]$。\n\n2. 将每个组的大小对应的编号列表分成特定大小的列表。\n\n   - 大小为 $1$ 的组对应的编号列表的长度是 $1$，因此有 $1$ 个大小为 $1$ 的组：$[5]$。\n\n   - 大小为 $3$ 的组对应的编号列表的长度是 $6$，因此有 $2$ 个大小为 $3$ 的组：$[0, 1, 2], [3, 4, 6]$。\n\n3. 最终分组情况是 $[[5], [0, 1, 2], [3, 4, 6]$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        groups = defaultdict(list)\n        for i, size in enumerate(groupSizes):\n            groups[size].append(i)\n        ans = []\n        for size, people in groups.items():\n            ans.extend(people[i: i + size] for i in range(0, len(people), size))\n        return ans\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<List<Integer>> groupThePeople(int[] groupSizes) {\n        Map<Integer, List<Integer>> groups = new HashMap<Integer, List<Integer>>();\n        int n = groupSizes.length;\n        for (int i = 0; i < n; i++) {\n            int size = groupSizes[i];\n            groups.putIfAbsent(size, new ArrayList<Integer>());\n            groups.get(size).add(i);\n        }\n        List<List<Integer>> groupList = new ArrayList<List<Integer>>();\n        for (Map.Entry<Integer, List<Integer>> entry : groups.entrySet()) {\n            int size = entry.getKey();\n            List<Integer> people = entry.getValue();\n            int groupCount = people.size() / size;\n            for (int i = 0; i < groupCount; i++) {\n                List<Integer> group = new ArrayList<Integer>();\n                int start = i * size;\n                for (int j = 0; j < size; j++) {\n                    group.add(people.get(start + j));\n                }\n                groupList.add(group);\n            }\n        }\n        return groupList;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<IList<int>> GroupThePeople(int[] groupSizes) {\n        Dictionary<int, IList<int>> groups = new Dictionary<int, IList<int>>();\n        int n = groupSizes.Length;\n        for (int i = 0; i < n; i++) {\n            int size = groupSizes[i];\n            groups.TryAdd(size, new List<int>());\n            groups[size].Add(i);\n        }\n        IList<IList<int>> groupList = new List<IList<int>>();\n        foreach (KeyValuePair<int, IList<int>> pair in groups) {\n            int size = pair.Key;\n            IList<int> people = pair.Value;\n            int groupCount = people.Count / size;\n            for (int i = 0; i < groupCount; i++) {\n                IList<int> group = new List<int>();\n                int start = i * size;\n                for (int j = 0; j < size; j++) {\n                    group.Add(people[start + j]);\n                }\n                groupList.Add(group);\n            }\n        }\n        return groupList;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> groupThePeople(vector<int>& groupSizes) {\n        unordered_map<int, vector<int>> groups;\n        int n = groupSizes.size();\n        for (int i = 0; i < n; i++) {\n            int size = groupSizes[i];\n            groups[size].emplace_back(i);\n        }\n        vector<vector<int>> groupList;\n        for (auto &[size, people] : groups) {\n            int groupCount = people.size() / size;\n            for (int i = 0; i < groupCount; i++) {\n                vector<int> group;\n                int start = i * size;\n                for (int j = 0; j < size; j++) {\n                    group.emplace_back(people[start + j]);\n                }\n                groupList.emplace_back(group);\n            }\n        }\n        return groupList;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct Array {\n    int *arr;\n    int pos;\n    int size;\n} Array;\n\nArray* creatArray(int size) {\n    Array *obj = (Array *)malloc(sizeof(Array));\n    obj->arr = (int *)malloc(sizeof(int) * size);\n    obj->size = size;\n    obj->pos = 0;\n    return obj;\n}\n\nvoid freeArray(Array *obj) {\n    free(obj->arr);\n    free(obj);\n}\n\nint** groupThePeople(int* groupSizes, int groupSizesSize, int* returnSize, int** returnColumnSizes){\n    Array **groups = (Array **)malloc(sizeof(Array *) * (groupSizesSize + 1));\n    for (int i = 0; i <= groupSizesSize; i++) {\n        groups[i] = creatArray(groupSizesSize);\n    }\n    for (int i = 0; i < groupSizesSize; i++) {\n        int size = groupSizes[i];\n        groups[size]->arr[groups[size]->pos++] = i;\n    }\n    int **groupList = (int **)malloc(sizeof(int *) * groupSizesSize);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * groupSizesSize);\n    int pos = 0;\n    for (int k = 0; k <= groupSizesSize; k++) {\n        if (groups[k]->pos == 0) {\n            continue;\n        }\n        int size = k;\n        int groupCount = groups[k]->pos / size;\n        for (int i = 0; i < groupCount; i++) {\n            int *group = (int *)malloc(sizeof(int) * size);\n            int start = i * size, index = 0;\n            for (int j = 0; j < size; j++) {\n                group[index++] = groups[k]->arr[start + j];\n            }\n            (*returnColumnSizes)[pos] = size;\n            groupList[pos++] = group;\n        }\n    }\n    *returnSize = pos;\n    for (int i = 0; i <= groupSizesSize; i++) {\n        freeArray(groups[i]);\n    }\n    return groupList;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar groupThePeople = function(groupSizes) {\n    const groups = new Map();\n    const n = groupSizes.length;\n    for (let i = 0; i < n; i++) {\n        const size = groupSizes[i];\n        if (!groups.has(size)) {\n            groups.set(size, []);\n        }\n        groups.get(size).push(i);\n    }\n    const groupList = [];\n    for (const [size, people] of groups.entries()) {\n        const groupCount = Math.floor(people.length / size);\n        for (let i = 0; i < groupCount; i++) {\n            const group = [];\n            const start = i * size;\n            for (let j = 0; j < size; j++) {\n                group.push(people[start + j]);\n            }\n            groupList.push(group);\n        }\n    }\n    return groupList;\n};\n```\n\n```go [sol1-Golang]\nfunc groupThePeople(groupSizes []int) (ans [][]int) {\n    groups := map[int][]int{}\n    for i, size := range groupSizes {\n        groups[size] = append(groups[size], i)\n    }\n    for size, people := range groups {\n        for i := 0; i < len(people); i += size {\n            ans = append(ans, people[i:i+size])\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{groupSize}$ 的长度。需要遍历数组一次得到每个组的大小对应的所有人的编号，然后需要遍历所有元素完成分组。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{groupSize}$ 的长度。空间复杂度主要取决于哈希表，哈希表需要 $O(n)$ 的空间记录每个组的大小对应的所有人的编号。"
}