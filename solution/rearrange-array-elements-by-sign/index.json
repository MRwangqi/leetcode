{
	"titleSlug": "rearrange-array-elements-by-sign",
	"slug": "an-fu-hao-zhong-pai-shu-zu-by-leetcode-s-bgds",
	"url": "https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/solution/an-fu-hao-zhong-pai-shu-zu-by-leetcode-s-bgds/",
	"content": "#### 方法一：双指针\n\n**思路与算法**\n\n我们可以使用两个指针对数组 $\\textit{left}$ 进行遍历，其中指针 $\\textit{pos}$ 负责遍历所有的正数，指针 $\\textit{neg}$ 负责遍历所有的负数。\n\n记数组 $\\textit{nums}$ 的长度为 $n$，那么其中分别包含 $n/2$ 个正数和负数。因此我们只需要重复如下操作 $n/2$ 次：\n\n- 指针 $\\textit{pos}$ 不断向后移动，直到遇到一个正数为止，并将该正数放入答案数组；\n\n- 指针 $\\textit{neg}$ 不断向后移动，直到遇到一个负数为止，并将该负数放入答案数组。\n\n$\\textit{pos}$ 和 $\\textit{neg}$ 初识时均指向 $\\textit{nums}$ 的首个元素。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int n = nums.size();\n        int pos = 0, neg = 0;\n        vector<int> ans;\n        for (int i = 0; i + i < n; ++i) {\n            while (nums[pos] < 0) {\n                ++pos;\n            }\n            ans.push_back(nums[pos]);\n            ++pos;\n            while (nums[neg] > 0) {\n                ++neg;\n            }\n            ans.push_back(nums[neg]);\n            ++neg;\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        pos = neg = 0\n        ans = list()\n\n        for i in range(n // 2):\n            while nums[pos] < 0:\n                pos += 1\n            ans.append(nums[pos])\n            pos += 1\n            while nums[neg] > 0:\n                neg += 1\n            ans.append(nums[neg])\n            neg += 1\n        \n        return ans\n```\n\n```Golang [sol1-Golang]\nfunc rearrangeArray(nums []int) []int {\n\tn := len(nums)\n\tpos, neg, ans := 0, 0, []int{}\n\n\tfor i := 0; i+i < n; i++ {\n\t\tfor ; nums[pos] < 0; pos++ {\n\t\t}\n\t\tans = append(ans, nums[pos])\n\t\tpos++\n\t\tfor ; nums[neg] > 0; neg++ {\n\t\t}\n\t\tans = append(ans, nums[neg])\n\t\tneg++\n\t}\n\n\treturn ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(1)$。这里不计入返回值需要使用的空间。"
}