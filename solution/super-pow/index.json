{
	"titleSlug": "super-pow",
	"slug": "chao-ji-ci-fang-by-leetcode-solution-ow8j",
	"url": "https://leetcode-cn.com/problems/super-pow/solution/chao-ji-ci-fang-by-leetcode-solution-ow8j/",
	"content": "#### 前置知识\n\n在阅读本文前，读者需要掌握快速幂这一算法，具体可以见「[50. Pow(x, n) 的官方题解](https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/)」。\n\n此外，乘法在取模的意义下满足分配律，即\n\n$$\n(a \\cdot b) \\bmod m = [(a \\bmod m) \\cdot (b \\bmod m)] \\bmod m\n$$\n\n#### 方法一：倒序遍历\n\n设 $a$ 的幂次为 $n$。根据题意，$n$ 从最高位到最低位的所有数位构成了数组 $b$。记数组 $b$ 的长度为 $m$，有\n\n$$\nn=\\sum\\limits_{i=0}^{m-1} 10^{m-1-i} \\cdot b_i\n$$\n\n由于 $a^{x+y}=a^x\\cdot a^y$ 以及 $a^{x\\cdot y} = (a^x)^y$，得\n\n$$\na^n = \\prod\\limits_{i=0}^{m-1} a^{10^{m-1-i} \\cdot b_i} = \\prod\\limits_{i=0}^{m-1} \\Big(a^{10^{m-1-i}}\\Big)^{b_i}\n$$\n\n可以根据如下等式计算上式括号内的部分：\n\n$$\na^{10^k} = a^{10^{k-1}\\cdot 10} = \\Big(a^{10^{k-1}}\\Big)^{10}\n$$\n\n我们可以从 $a^1$ 开始，递推地计算出 $a^{10^k}$。\n\n代码实现时，可以从 $b_{m-1}$ 开始倒序计算，在计算的过程中同时递推计算出 $a^{10^k}$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def superPow(self, a: int, b: List[int]) -> int:\n        MOD = 1337\n        ans = 1\n        for e in reversed(b):\n            ans = ans * pow(a, e, MOD) % MOD\n            a = pow(a, 10, MOD)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    const int MOD = 1337;\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n) {\n            if (n % 2) {\n                res = (long) res * x % MOD;\n            }\n            x = (long) x * x % MOD;\n            n /= 2;\n        }\n        return res;\n    }\n\npublic:\n    int superPow(int a, vector<int> &b) {\n        int ans = 1;\n        for (int i = b.size() - 1; i >= 0; --i) {\n            ans = (long) ans * pow(a, b[i]) % MOD;\n            a = pow(a, 10);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static final int MOD = 1337;\n\n    public int superPow(int a, int[] b) {\n        int ans = 1;\n        for (int i = b.length - 1; i >= 0; --i) {\n            ans = (int) ((long) ans * pow(a, b[i]) % MOD);\n            a = pow(a, 10);\n        }\n        return ans;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n != 0) {\n            if (n % 2 != 0) {\n                res = (int) ((long) res * x % MOD);\n            }\n            x = (int) ((long) x * x % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    const int MOD = 1337;\n\n    public int SuperPow(int a, int[] b) {\n        int ans = 1;\n        for (int i = b.Length - 1; i >= 0; --i) {\n            ans = (int) ((long) ans * Pow(a, b[i]) % MOD);\n            a = Pow(a, 10);\n        }\n        return ans;\n    }\n\n    public int Pow(int x, int n) {\n        int res = 1;\n        while (n != 0) {\n            if (n % 2 != 0) {\n                res = (int) ((long) res * x % MOD);\n            }\n            x = (int) ((long) x * x % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}\n```\n\n```go [sol1-Golang]\nconst mod = 1337\n\nfunc pow(x, n int) int {\n    res := 1\n    for ; n > 0; n /= 2 {\n        if n&1 > 0 {\n            res = res * x % mod\n        }\n        x = x * x % mod\n    }\n    return res\n}\n\nfunc superPow(a int, b []int) int {\n    ans := 1\n    for i := len(b)-1; i >= 0; i-- {\n        ans = ans * pow(a, b[i]) % mod\n        a = pow(a, 10)\n    }\n    return ans\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst MOD = BigInt(1337);\n\nvar superPow = function(a, b) {\n    let ans = BigInt(1);\n    for (let i = b.length - 1; i >= 0; --i) {\n        ans = ans * pow(BigInt(a), b[i]) % MOD;\n        a = pow(BigInt(a), 10);\n    }\n    return ans;\n};\n\nconst pow = (x, n) => {\n    let res = BigInt(1);\n    while (n !== 0) {\n        if (n % 2 !== 0) {\n            res = res * BigInt(x) % MOD;\n        }\n        x = x * x % MOD;\n        n = Math.floor(n / 2);\n    }\n    return res;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\sum\\limits_{i=0}^{m-1} \\log b_i)$，其中 $m$ 是数组 $b$ 的长度。对每个 $b_i$ 计算快速幂的时间为 $O(\\log b_i)$。\n\n- 空间复杂度：$O(1)$，只需要常数的空间存放若干变量。\n\n#### 方法二：秦九韶算法（正序遍历）\n\n由于\n\n$$\nn = \\sum\\limits_{i=0}^{m-1} 10^{m-1-i} \\cdot b_i = \\Big(\\sum\\limits_{i=0}^{m-2} 10^{m-2-i} \\cdot b_i\\Big)\\cdot 10 + b_{m-1}\n$$\n\n记 $n'=\\sum\\limits_{i=0}^{m-2} 10^{m-2-i} \\cdot b_i$，有\n\n$$\na^n = a^{n'\\cdot 10 + b_{m-1}} = (a^{n'})^{10}\\cdot a^{b_{m-1}}\n$$\n\n根据该式，可以得到如下递推式：\n\n$$\n\\textit{superPow}(a,b) =\n\\begin{cases} \n1,&m=0\\\\\n\\textit{superPow}(a,b')^{10}\\cdot a^{b_{m-1}},&m\\ge 1\n\\end{cases}\n$$\n\n其中 $b'$ 为 $b$ 去掉末尾元素后的部分。\n\n```Python [sol2-Python3]\nclass Solution:\n    def superPow(self, a: int, b: List[int]) -> int:\n        MOD = 1337\n        ans = 1\n        for e in b:\n            ans = pow(ans, 10, MOD) * pow(a, e, MOD) % MOD\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\n    const int MOD = 1337;\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n) {\n            if (n % 2) {\n                res = (long) res * x % MOD;\n            }\n            x = (long) x * x % MOD;\n            n /= 2;\n        }\n        return res;\n    }\n\npublic:\n    int superPow(int a, vector<int> &b) {\n        int ans = 1;\n        for (int e: b) {\n            ans = (long) pow(ans, 10) * pow(a, e) % MOD;\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    static final int MOD = 1337;\n\n    public int superPow(int a, int[] b) {\n        int ans = 1;\n        for (int e : b) {\n            ans = (int) ((long) pow(ans, 10) * pow(a, e) % MOD);\n        }\n        return ans;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n != 0) {\n            if (n % 2 != 0) {\n                res = (int) ((long) res * x % MOD);\n            }\n            x = (int) ((long) x * x % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    const int MOD = 1337;\n\n    public int SuperPow(int a, int[] b) {\n        int ans = 1;\n        foreach (int e in b) {\n            ans = (int) ((long) Pow(ans, 10) * Pow(a, e) % MOD);\n        }\n        return ans;\n    }\n\n    public int Pow(int x, int n) {\n        int res = 1;\n        while (n != 0) {\n            if (n % 2 != 0) {\n                res = (int) ((long) res * x % MOD);\n            }\n            x = (int) ((long) x * x % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}\n```\n\n```go [sol2-Golang]\nconst mod = 1337\n\nfunc pow(x, n int) int {\n    res := 1\n    for ; n > 0; n /= 2 {\n        if n&1 > 0 {\n            res = res * x % mod\n        }\n        x = x * x % mod\n    }\n    return res\n}\n\nfunc superPow(a int, b []int) int {\n    ans := 1\n    for _, e := range b {\n        ans = pow(ans, 10) * pow(a, e) % mod\n    }\n    return ans\n}\n```\n\n```JavaScript [sol2-JavaScript]\nconst MOD = BigInt(1337);\n\nvar superPow = function(a, b) {\n    let ans = 1;\n    for (const e of b) {\n        ans = pow(BigInt(ans), 10) * pow(BigInt(a), e) % MOD;\n    }\n    return ans;\n};\n\nconst pow = (x, n) => {\n    let res = BigInt(1);\n    while (n !== 0) {\n        if (n % 2 !== 0) {\n            res = res * BigInt(x) % MOD;\n        }\n        x = x * x % MOD;\n        n = Math.floor(n / 2);\n    }\n    return res;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\sum\\limits_{i=0}^{m-1} \\log b_i)$，其中 $m$ 是数组 $b$ 的长度。对每个 $b_i$ 计算快速幂的时间为 $O(\\log b_i)$。\n\n- 空间复杂度：$O(1)$，只需要常数的空间存放若干变量。"
}