{
	"titleSlug": "minimum-swaps-to-group-all-1s-together-ii",
	"slug": "zui-shao-jiao-huan-ci-shu-lai-zu-he-suo-iaghf",
	"url": "https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/solution/zui-shao-jiao-huan-ci-shu-lai-zu-he-suo-iaghf/",
	"content": "#### 方法一：转化为统计区间内 $0$ 的个数\n\n**思路与算法**\n\n我们首先统计出数组 $\\textit{nums}$ 中 $1$ 的个数，记为 $\\textit{cnt}$。这样一来，如果我们枚举交换完成之后连续 $1$ 的起始位置 $i$，那么结束位置即为 $(i + \\textit{cnt} - 1) \\bmod n$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n可以发现，从位置 $i$ 开始到位置 $(i + \\textit{cnt} - 1) \\bmod n$ 结束的这一段区间内，$0$ 的个数即为需要交换的次数。这是因为我们每一次交换都需要把区间内的一个 $0$ 与区间外的 $0$ 进行交换。因此最少的交换次数即为区间内 $0$ 的个数的最小值。\n\n我们有两种方法可以计算出这一段区间内 $0$ 的个数：\n\n- 第一种方法是使用前缀和数组。我们使用数组 $\\textit{pre}$ 表示数组 $\\textit{nums}$ 中 $0$ 的个数的前缀和，即 $\\textit{pre}[i]$ 表示 $\\textit{nums}[0..i]$ 中 $0$ 的个数。那么：\n\n    - 如果 $i < (i + \\textit{cnt} - 1) \\bmod n$，那么区间内 $0$ 的个数即为：\n\n    $$\n    \\textit{pre}\\big[ (i + \\textit{cnt} - 1) \\bmod n \\big] - \\textit{pre}[i-1]\n    $$\n\n    - 如果 $i > (i + \\textit{cnt} - 1) \\bmod n$，那么区间内 $0$ 的个数即为：\n\n    $$\n    \\textit{pre}\\big[ (i + \\textit{cnt} - 1) \\bmod n \\big] + (\\textit{pre}[n - 1] - \\textit{pre}[i-1])\n    $$\n\n- 第二种方法是递增地枚举 $i$ 并实时维护区间内 $0$ 的个数。我们首先统计 $i=0$ 时区间 $[0, \\textit{cnt})$ 内 $0$ 的个数，随后从 $1$ 开始递增地枚举 $i$。当起始位置从 $i-1$ 增加到 $i$ 时，$\\textit{nums}[i-1]$ 被从区间内移除，而 $\\textit{nums}\\big[ (i + \\textit{cnt} - 1) \\bmod n \\big]$ 被加入区间内。因此如果前者为 $0$，就将 $0$ 的个数减少 $1$；如果后者为 $0$，就将 $0$ 的个数增加 $1$。\n\n下面的代码给出的是第二种方法的实现。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minSwaps(vector<int>& nums) {\n        int n = nums.size();\n        int cnt = accumulate(nums.begin(), nums.end(), 0);\n        if (cnt == 0) {\n            return 0;\n        }\n        \n        int cur = 0;\n        for (int i = 0; i < cnt; ++i) {\n            cur += (1 - nums[i]);\n        }\n        int ans = cur;\n        for (int i = 1; i < n; ++i) {\n            if (nums[i - 1] == 0) {\n                --cur;\n            }\n            if (nums[(i + cnt - 1) % n] == 0) {\n                ++cur;\n            }\n            ans = min(ans, cur);\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minSwaps(self, nums: List[int]) -> int:\n        n = len(nums)\n        cnt = sum(nums)\n        if cnt == 0:\n            return 0\n        \n        cur = 0\n        for i in range(cnt):\n            cur += (1 - nums[i])\n        \n        ans = cur\n        for i in range(1, n):\n            if nums[i - 1] == 0:\n                cur -= 1\n            if nums[(i + cnt - 1) % n] == 0:\n                cur += 1\n            ans = min(ans, cur)\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(1)$。"
}