{
	"titleSlug": "maximum-binary-tree-ii",
	"slug": "zui-da-er-cha-shu-ii-by-leetcode-solutio-piv2",
	"url": "https://leetcode-cn.com/problems/maximum-binary-tree-ii/solution/zui-da-er-cha-shu-ii-by-leetcode-solutio-piv2/",
	"content": "#### 方法一：遍历右子节点\n\n**思路与算法**\n\n如果根节点的值小于给定的整数 $\\textit{val}$，那么新的树会以 $\\textit{val}$ 作为根节点，并将原来的树作为新的根节点的左子树。\n\n否则，我们从根节点开始不断地向右子节点进行遍历。这是因为，当遍历到的节点的值大于 $\\textit{val}$ 时，由于 $\\textit{val}$ 是新添加的位于数组末尾的元素，那么在构造的结果中，$\\textit{val}$ 一定出现在该节点的右子树中。\n\n当我们遍历到节点 $\\textit{cur}$ 以及它的父节点 $\\textit{parent}$，并且 $\\textit{cur}$ 节点的值小于 $\\textit{val}$ 时，我们就可以停止遍历，构造一个新的节点，以 $\\textit{val}$ 为值且以 $\\textit{cur}$ 为左子树。我们将该节点作为 $\\textit{parent}$ 的新的右节点，并返回根节点作为答案即可。\n\n如果遍历完成之后，仍然没有找到比 $\\textit{val}$ 值小的节点，那么我们构造一个新的节点，以 $\\textit{val}$ 为值，将该节点作为 $\\textit{parent}$ 的右节点，并返回根节点作为答案即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    TreeNode* insertIntoMaxTree(TreeNode* root, int val) {\n        TreeNode* parent = nullptr;\n        TreeNode* cur = root;\n        while (cur) {\n            if (val > cur->val) {\n                if (!parent) {\n                    return new TreeNode(val, root, nullptr);\n                }\n                TreeNode* node = new TreeNode(val, cur, nullptr);\n                parent->right = node;\n                return root;\n            }\n            else {\n                parent = cur;\n                cur = cur->right;\n            }\n        }\n        parent->right = new TreeNode(val);\n        return root;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public TreeNode insertIntoMaxTree(TreeNode root, int val) {\n        TreeNode parent = null;\n        TreeNode cur = root;\n        while (cur != null) {\n            if (val > cur.val) {\n                if (parent == null) {\n                    return new TreeNode(val, root, null);\n                }\n                TreeNode node = new TreeNode(val, cur, null);\n                parent.right = node;\n                return root;\n            } else {\n                parent = cur;\n                cur = cur.right;\n            }\n        }\n        parent.right = new TreeNode(val);\n        return root;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public TreeNode InsertIntoMaxTree(TreeNode root, int val) {\n        TreeNode parent = null;\n        TreeNode cur = root;\n        while (cur != null) {\n            if (val > cur.val) {\n                if (parent == null) {\n                    return new TreeNode(val, root, null);\n                }\n                TreeNode node = new TreeNode(val, cur, null);\n                parent.right = node;\n                return root;\n            } else {\n                parent = cur;\n                cur = cur.right;\n            }\n        }\n        parent.right = new TreeNode(val);\n        return root;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        parent, cur = None, root\n        while cur:\n            if val > cur.val:\n                if not parent:\n                    return TreeNode(val, root, None)\n                node = TreeNode(val, cur, None)\n                parent.right = node\n                return root\n            else:\n                parent = cur\n                cur = cur.right\n        \n        parent.right = TreeNode(val)\n        return root\n```\n\n```C [sol1-C]\nstruct TreeNode* creatTreeNode(int val, const struct TreeNode *left, const struct TreeNode *right) {\n    struct TreeNode* node = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n    node->val = val;\n    node->left = left;\n    node->right = right;\n    return node;\n}\n\nstruct TreeNode* insertIntoMaxTree(struct TreeNode* root, int val){\n    struct TreeNode* parent = NULL;\n    struct TreeNode* cur = root;\n    struct TreeNode* node = NULL;\n    while (cur) {\n        if (val > cur->val) {\n            if (!parent) {\n                return creatTreeNode(val, root, NULL);\n            } \n            parent->right = creatTreeNode(val, cur, NULL);\n            return root;\n        }\n        else {\n            parent = cur;\n            cur = cur->right;\n        }\n    }\n    parent->right = creatTreeNode(val, NULL, NULL);;\n    return root;\n}\n```\n\n```go [sol1-Golang]\nfunc insertIntoMaxTree(root *TreeNode, val int) *TreeNode {\n    var parent *TreeNode\n    for cur := root; cur != nil; cur = cur.Right {\n        if val > cur.Val {\n            if parent == nil {\n                return &TreeNode{val, root, nil}\n            }\n            parent.Right = &TreeNode{val, cur, nil}\n            return root\n        }\n        parent = cur\n    }\n    parent.Right = &TreeNode{Val: val}\n    return root\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar insertIntoMaxTree = function(root, val) {\n    let parent = null;\n    let cur = root;\n    while (cur) {\n        if (val > cur.val) {\n            if (!parent) {\n                return new TreeNode(val, root, null);\n            }\n            let node = new TreeNode(val, cur, null);\n            parent.right = node;\n            return root;\n        } else {\n            parent = cur;\n            cur = cur.right;\n        }\n    }\n    parent.right = new TreeNode(val);\n    return root;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是给定的树中的节点个数。在最坏情况下，树呈现链状结构，前 $n-1$ 个节点有唯一的右子节点，并且 $\\textit{val}$ 比树中任一节点的值都要小，此时需要遍历完整棵树，时间复杂度为 $O(n)$。\n\n- 空间复杂度：$O(1)$。"
}