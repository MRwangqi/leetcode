{
	"titleSlug": "flip-columns-for-maximum-number-of-equal-rows",
	"slug": "1072-an-lie-fan-zhuan-de-dao-zui-da-zhi-deng-xing-",
	"url": "https://leetcode-cn.com/problems/flip-columns-for-maximum-number-of-equal-rows/solution/1072-an-lie-fan-zhuan-de-dao-zui-da-zhi-deng-xing-/",
	"content": "### 解题思路：\n第一眼看过去，这题是个矩阵啊，再看一眼，表象都是骗人的。\n\n如果某两行可以通过这个规则达成一致，要么它们全等，要么它们相反。\n\n题目要求找到最大值等行数，那么我们就是要去找哪种**特征**的行出现的次数最多。\n\n我第一反应就是：这不就是个二进制数么？首位 $0$ 的直接做 `key`， 首位 $1$ 的按全 $1$ 异或后做 `key`，然后统计哪个 `key` 出现的次数最多。\n\n然后我看到了提示\n```\n1 <= matrix.length <= 300\n1 <= matrix[i].length <= 300\n```\n无法用二进制... 还是直接当做字符串看待吧。\n\n\n于是我想到了一个非常粗糙的方法。\n### 代码：\n```\nvar maxEqualRowsAfterFlips = function(matrix) {\n    let obj = matrix.reduce((obj, item) => {\n      let str\n      if (item[0] === 0) {\n        str = item.map(item => item ^ 1).join('')\n      } else {\n        str = item.join('')\n      }\n      obj[str] ? obj[str]++ : obj[str] = 1\n      return obj\n    }, {})\n    return Math.max(...Object.values(obj))\n};\n```\n\n这样就能把所有的 $01$ 串转化为 $1$ 开头，然后以此做 `key`，出现最多次数的特征。\n\n另外一个思路，是避开 $01$ 转化，直接从特点找特征。\n\n按照数字出现的连续次数定义特征，比如 `11100110 -> 3221`，这样的好处是，`00011001` 同样也是 `3221`，避开了特殊情况下 $01$ 互转，而且最终也跑出了 `228 ms/52.1 MB` 的好成绩。\n\n### 核心代码如下：\n```\n      item.forEach((i) => {\n        if (temp === i) {\n          sum++\n        } else {\n          temp = i\n          str += sum\n          sum = 1\n        }\n      })\n      str += sum\n```"
}