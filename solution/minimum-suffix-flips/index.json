{
	"titleSlug": "minimum-suffix-flips",
	"slug": "deng-pao-kai-guan-iv-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/minimum-suffix-flips/solution/deng-pao-kai-guan-iv-by-leetcode-solution/",
	"content": "#### 方法一：贪心\n\n根据翻转操作的定义，选定下标 $i$ 之后，翻转从下标 $i$ 到下标 $n-1$ 的每个字符，在下标 $i$ 前面的字符则不被翻转。因此，如果一个字符被翻转，则一定是选择了该字符的下标或者该字符前面的某个下标，然后进行了翻转操作。\n\n初始时，所有的字符都是 $0$。对于下标为 $0$ 的字符，如果其在 $\\textit{target}$ 中的值是 $1$，则一定有一次对下标为 $0$ 的字符的翻转操作。\n\n对于下标为 $i$（$i>0$）的字符，如果其在 $\\textit{target}$ 中的值与前一个字符（即下标为 $i-1$ 的字符）的值不同，则一定有一次对下标为 $i$ 的字符的翻转操作。\n\n由此可以想到一个贪心的思路：从前往后遍历 $\\textit{target}$，对每个下标判断是否进行了翻转操作即可，同时计算最少翻转次数。\n\n```Java [sol1-Java]\nclass Solution {\n    public int minFlips(String target) {\n        int flips = 0;\n        char prev = '0';\n        int n = target.length();\n        for (int i = 0; i < n; i++) {\n            char curr = target.charAt(i);\n            if (curr != prev) {\n                flips++;\n                prev = curr;\n            }\n        }\n        return flips;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinFlips(string target) {\n        int flips = 0;\n        char prev = '0';\n        int n = target.Length;\n        for (int i = 0; i < n; i++) {\n            char curr = target[i];\n            if (curr != prev) {\n                flips++;\n                prev = curr;\n            }\n        }\n        return flips;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minFlips(string target) {\n        int flips = 0;\n        char prev = '0';\n        int n = target.size();\n        for (int i = 0; i < n; i++) {\n            char curr = target.at(i);\n            if (curr != prev) {\n                flips++;\n                prev = curr;\n            }\n        }\n        return flips;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minFlips(self, target: str) -> int:\n        flips, prev = 0, \"0\"\n        for curr in target:\n            if curr != prev:\n                flips += 1\n                prev = curr\n        return flips\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $\\textit{target}$ 的长度。遍历字符串一次。\n\n- 空间复杂度：$O(1)$。只需要维护常量的额外空间。"
}