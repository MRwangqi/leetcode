{
	"titleSlug": "frog-position-after-t-seconds",
	"slug": "by-minit-s4wi",
	"url": "https://leetcode-cn.com/problems/frog-position-after-t-seconds/solution/by-minit-s4wi/",
	"content": "BFS还是挺好想的并且挺快的\r\n\r\n执行用时：20 ms, 在所有 C++ 提交中击败了72.22%的用户\r\n\r\n内存消耗：14.1 MB, 在所有 C++ 提交中击败了88.89%的用户\r\n\r\n以1起跳，并设定hash数组判断是否已经到达过，每次遍历队首的点的边，判断是否已经跳过，并且统计剩余能跳的值\r\n**这里要注意**，如果无处可跳，那它就只能一直在这蹦，概率就不用改变，如果可以继续往下跳，**当前的概率应该设置为0**，因为在时间范围内，如果这个点是target，是不允许他跳回来的（因为有下一步可跳并且已经跳出去了，所以target设为已到达过），最后返回target的概率即可\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\r\n        int hash[n+1];\r\n        memset(hash,0,sizeof(hash));\r\n        double perhaps[n+1];\r\n        memset(perhaps,0,sizeof(perhaps));\r\n        perhaps[1]=1.0;\r\n        hash[1]=1;\r\n        vector<int> edge[n+1];\r\n        for(int i=0;i<edges.size();++i){\r\n            edge[edges[i][0]].push_back(edges[i][1]);\r\n            edge[edges[i][1]].push_back(edges[i][0]);\r\n        }\r\n        queue<int> q;\r\n        q.push(1);\r\n        for(int i=0;i<t;++i){\r\n            if(!q.size()){\r\n                break;\r\n            }\r\n            int s=q.size();\r\n            while(s-->0){\r\n                int u=q.front();\r\n                // cout<<u<<\" \";\r\n                q.pop();\r\n                double gailu=perhaps[u];\r\n                int cnt=0;\r\n                for(int j=0;j<edge[u].size();++j){\r\n                    int v=edge[u][j];\r\n                    if(!hash[v]){\r\n                        ++cnt;\r\n                    }\r\n                }\r\n                if(cnt!=0){perhaps[u]=0;}\r\n                for(int j=0;j<edge[u].size();++j){\r\n                    int v=edge[u][j];\r\n                    if(hash[v]){\r\n                        continue;\r\n                    }else{\r\n                        // cout<<v<<\" \";\r\n                        q.push(v);\r\n                        hash[v]=1;\r\n                        perhaps[v]=gailu/cnt;\r\n                    }\r\n                }\r\n                // cout<<endl;\r\n            }\r\n            // cout<<endl;\r\n        }\r\n        return perhaps[target];\r\n\r\n    }\r\n};\r\n```\r\n\r\n"
}