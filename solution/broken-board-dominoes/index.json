{
	"titleSlug": "broken-board-dominoes",
	"slug": "suan-fa-xiao-ai-cong-ling-dao-yi-jiao-hu-8b4k",
	"url": "https://leetcode-cn.com/problems/broken-board-dominoes/solution/suan-fa-xiao-ai-cong-ling-dao-yi-jiao-hu-8b4k/",
	"content": "> 关注[小爱老师的算法课堂](https://space.bilibili.com/1716757387/)，分享高质量算法视频与文字题解\r\n\r\n---\r\n\r\n### 题目分析：二分图最大匹配\r\n\r\n我们首先可以将棋盘抽象成 $x, y$ 交替的格子：$x$ 周围均为 $y$，$y$ 周围均为 $x$，如下图所示：\r\n![image.png](https://pic.leetcode-cn.com/1630982158-ZqfjKv-image.png)\r\n\r\n那么，一个多米诺骨牌一定占据一个 $x$ 格子及一个 $y$ 格子，且这两个格子必须相邻。也就是说，棋盘中的每个 $x$ 相连的点均为 $y$，而所有的 $y$ 相连的点均为 $x$。这就抽象成了一个**二分图**（二分图的定义可以参考[785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)），而我们要放置最多的多米诺骨牌，也就是找到一种方式，使得二分图中连的边数量最大。这就是典型的**二分图最大匹配**。\r\n\r\n二分图最大匹配问题，一般可以用匈牙利算法解决。在介绍匈牙利算法之前，我们需要明确一些专有名词：\r\n\r\n1. 匹配集合：我们最终的目标是最大化边的数量，这些边将加入匹配集合。\r\n2. 匹配边、匹配点：在二分图中，如果我们本次将两个点连成的边加入匹配集合，就说我们当前将这条边作为了匹配边，边的两个端点均称作匹配点。\r\n3. 未匹配边、未匹配点：在二分图中，如果一个点有一条以上的边，并且其中某一条边已经被加入了匹配集合成为了匹配边，那么剩余的边均称作未匹配边，这些边的另一个端点称为未匹配点。\r\n4. 增广路：以未匹配边开始和结束，且未匹配边与匹配边交替出现的路径。\r\n\r\n为了便于大家理解，我们通过下图（红框和篮框分别表示二分图中的两部分，黑色圆圈表示不同的点。黄色和绿色线条都表示点之间的边）来解释上面 $4$ 个概念：\r\n![image.png](https://pic.leetcode-cn.com/1630983504-mVLUxa-image.png)\r\n\r\n我们首先将 $1$ 号点和 $5$ 号点之间的边放入匹配集合，该边就变成了匹配边（黄色标识）。$1$ 和 $5$ 号点就均变为了匹配点，此时，这两个点连接的其他边（$(1, 7), (2, 5), (4, 5)$）就称作未匹配边，对应的点 $2, 4, 7$ 就均称作未匹配点。我们其次将 $3$ 号点和 $6$ 号点之间的边放入匹配集合，该边就变成了匹配边，这两个点变为了匹配点。由于这两个点没有连其他的边，所以不会出现新的未匹配边。\r\n\r\n此时，我们发现，路径 $2-5-1-7$ 就是一条 未匹配边-匹配边-未匹配边 组合的增广路径。\r\n\r\n---\r\n\r\n明确了这些概念后，我们便来看我们的匈牙利算法：\r\n\r\n1. 初始时，最大匹配集合为空。\r\n2. 我们先找到一组匹配边，加入匹配集合。\r\n3. 找到一条增广路径，我们将其中的所有匹配边变为未匹配边，将所有的未匹配边变为匹配边。\r\n4. 循环步骤 $3$，直到图中不存在增广路径。算法结束\r\n\r\n匈牙利算法中，最重要的便是步骤 $3$。我们来深入理解一下：\r\n\r\n对于一条增广路径，根据其定义，必定含有 $k + 1$ 条未匹配边以及 $k$ 条匹配边。那么，步骤 $3$ 的作用，其实就是将未匹配边和匹配边互换，这样，该路径上就会更新为 $k$ 条未匹配边以及 $k + 1$ 条匹配边，这样匹配边的数量就比互换之前多了 $1$ 个。结合刚才的图片来看：\r\n![image.png](https://pic.leetcode-cn.com/1630984075-avxQSO-image.png)\r\n\r\n我们将增广路径 $2-5-1-7$ 上的未匹配边 $(2, 5), (1, 7)$ 变为匹配边，将匹配边 $(5, 1)$ 变为未匹配边，图中总匹配边数就从原来的两条（$(1, 5), (3, 6)$）变成了三条（$(2, 5), (1, 7), (3, 6)$）。\r\n\r\n---\r\n\r\n以上就是我们的匈牙利算法啦！在代码中，我们使用了二分图模板 `BinaryGraph` 类初始化二分图，利用其中的 `add` 函数完成加边，并利用其中的 `solve` 方法即可直接求得最大匹配。\r\n\r\n---\r\n\r\n### 算法细节：\r\n\r\n首先，我们要初始化二分图。初始化方法 `init` 需要两个参数 $n_1, n_2$，分别为两个部分中点的数量，为了方便起见，我们可以直接令 $n_1 = n_2 = n$，因为最终进行最大匹配是根据边来求解的，点的数量不会影响该过程。\r\n\r\n其次，我们需要利用 `add` 方法进行加边。一般情况下，我们需要预处理，先将题目给定的图标识成二分图（比如一部分标识为 $0$，另一部分标识为 $1$）。但在本题中，棋盘上第 $i$ 行第 $j$ 列属于哪一部分可以直接根据 $i + j$ 的奇偶性得到。\r\n\r\n然后，我们可以通过深度优先搜索遍历每个点，将该点连向四周的点。特别地，在二分图中，只需要从一个集合向另一个集合连有向边即可，不需要双向连边。在代码中，我们**从偶数部分向奇数部分连边**。另外，本题中棋盘上有些点不可以放多米诺骨牌，在连边过程中进行特判即可。\r\n\r\n最终，我们直接利用二分图类中的 `solve` 方法即可求解。具体可见代码。\r\n\r\n\r\n---\r\n\r\n### 代码\r\n\r\n```C++ []\r\nclass BinaryGraph {\r\npublic: \r\n    vector<vector<int> > g;\r\n    vector<int> pa;  // 匹配\r\n    vector<int> pb;\r\n    vector<int> vis;  // 访问\r\n    int n, m;         // 两个点集中的顶点数量\r\n    int dfn;          // 时间戳记\r\n    int res;          // 匹配数\r\n\r\n    // 二分图初始化\r\n    void init(int _n, int _m) {\r\n        n = _n;\r\n        m = _m;\r\n        pa = vector<int>(n, -1);\r\n        pb = vector<int>(m, -1);\r\n        vis = vector<int>(n);\r\n        g.resize(n);\r\n        res = 0;\r\n        dfn = 0;\r\n    }\r\n\r\n    // 加边函数\r\n    void add(int from, int to) {\r\n        g[from].push_back(to);\r\n    }\r\n\r\n    // 最大匹配\r\n    bool dfs(int v) {\r\n        vis[v] = dfn;\r\n        for (int u : g[v]) {\r\n            if (pb[u] == -1) {\r\n                pb[u] = v;\r\n                pa[v] = u;\r\n                return true;\r\n            }\r\n        }\r\n        for (int u : g[v]) {\r\n            if (vis[pb[u]] != dfn && dfs(pb[u])) {\r\n                pa[v] = u;\r\n                pb[u] = v;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    int solve() {\r\n        while (true) {\r\n            dfn++;\r\n            int cnt = 0;\r\n            for (int i = 0; i < n; i++) {\r\n                if (pa[i] == -1 && dfs(i)) {\r\n                    cnt++;\r\n                }\r\n            }\r\n            if (cnt == 0) {\r\n                break;\r\n            }\r\n            res += cnt;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    int x[4] = {-1, 0, 1, 0};\r\n    int y[4] = {0, 1, 0, -1};\r\n\r\n    int domino(int n, int m, vector<vector<int>>& broken) {\r\n        // 建图，若为 0 则不能放多米诺骨牌，否则可以放置\r\n        vector<vector<int>> graph(n, vector<int>(m, 1));\r\n        for(auto b : broken) graph[b[0]][b[1]] = 0;\r\n\r\n        // 初始化二分图\r\n        BinaryGraph *bg = new BinaryGraph();\r\n        bg->init(n * m, n * m);\r\n\r\n        // 深度优先搜索，加边\r\n        for(int i = 0; i < n; i++) {\r\n            for(int j = 0; j < m; j++) {\r\n                if(!graph[i][j]) continue;\r\n                // (i, j) -> 四边扩展\r\n                for(int k = 0; k < 4; k++) {\r\n                    int dx = i + x[k], dy = j + y[k];\r\n                    if(dx < 0 || dx >= n || dy < 0 || dy >= m || !graph[dx][dy]) continue;\r\n                    if((i + j) % 2 == 0) bg->add(i * m + j, dx * m + dy);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // 求解\r\n        return bg->solve();\r\n    }\r\n};\r\n```\r\n\r\n---\r\n\r\n### 复杂度分析：\r\n\r\n* 时间复杂度：$O(n^2m^2)$，匈牙利算法每次选择图中一个顶点，寻找增广路径。寻找增广路径最多会遍历图中所有边，故总复杂度为 $O(EV)$，其中 $E$ 为点数量，$V$ 为边数量。又因为每个点最多连出 $4$ 条边，且点数量为 $nm$，故总复杂度大约在 $O(n^2m^2)$ 量级。\r\n\r\n"
}