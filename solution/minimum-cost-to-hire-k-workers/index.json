{
	"titleSlug": "minimum-cost-to-hire-k-workers",
	"slug": "gu-yong-k-ming-gong-ren-de-zui-di-cheng-rsz3t",
	"url": "https://leetcode-cn.com/problems/minimum-cost-to-hire-k-workers/solution/gu-yong-k-ming-gong-ren-de-zui-di-cheng-rsz3t/",
	"content": "#### 方法一：贪心 + 优先队列\n\n**思路与算法**\n\n题目给出 $n$ 名工人和他们的工作质量数组 $\\textit{quality}$ 和薪资数组 $\\textit{wage}$。其中 $\\textit{quality}[i]$ 表示第 $i$ 名工人的工作质量，$\\textit{wage}[i]$ 表示第 $i$ 名工人的最低期望工资。现在我们需要选择 $k$ 名工人来组成一个工资组，支付工资时我们需要按照下述的规则来向这些工人支付工资：\n\n1. 对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。\n2. 工资组中的每名工人至少应当得到他们的最低期望工资。\n\n然后我们需要求符合上述条件的最小支付金额。那么首先假设我们已经选择了某一个工资组，组成成员为 $[h_1,h_2,\\cdots,h_k]$，其中 $h_i$ 表示第 $h_i$ 个工人，整个工作组的总工作质量为：$\\textit{totalq}$，总的支付金额为 $\\textit{totalc}$。那么按照题目的要求对于任意工人 $h_i$ 需要满足：\n\n$$\\textit{totalc} \\times \\frac{\\textit{quality}[h_i]}{\\textit{totalq}}\\ge \\textit{wage}[h_i]$$\n\n即：\n\n$$\\textit{totalc} \\ge \\textit{totalq} \\times \\frac{\\textit{wage}[h_i]}{\\textit{quality}[h_i]}$$\n\n所以当某一个工资组的总工作质量固定时，最少的付费金额只与工资组中 $\\max \\frac{\\textit{wage}[h_i]}{\\textit{quality}[h_i]}, 1 \\le i \\le k$ 有关。那么贪心的思路就出来了：设一个工人 $i$ 在某一个工资组中的权重表示为 $\\frac{\\textit{wage}[i]}{\\textit{quality}[i]}$，那么当我们以某一个工人 $x$ 作为一个工资组中权重最高时，工资组中其他人员只需要在权重小于工人 $x$ 的集合中选择工作质量最少的 $k-1$ 名工人来组成工资组即可，此时便能达到以工人 $x$ 为权重最高的工资组的总工作量最小，从而达到以工人 $x$ 为权重最高的工资组的最小工资开销。然后我们枚举以每一个能成为工资组中权重最大的工人来计算最小工资组开销，然后取其中的最小即可。在处理的过程中，我们可以先将工人按照权重进行升序排序，然后在遍历过程中可以用优先队列来维护之前工作质量最少的 $k-1$ 名工人。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        pairs = sorted(zip(quality, wage), key=lambda p: p[1] / p[0])\n        ans = inf\n        totalq = 0\n        h = []\n        for q, w in pairs[:k - 1]:\n            totalq += q\n            heappush(h, -q)\n        for q, w in pairs[k - 1:]:\n            totalq += q\n            heappush(h, -q)\n            ans = min(ans, w / q * totalq)\n            totalq += heappop(h)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {\n        int n = quality.size();\n        vector<int> h(n, 0);\n        iota(h.begin(), h.end(), 0);\n        sort(h.begin(), h.end(), [&](int& a, int& b) {\n            return quality[a] * wage[b] > quality[b] * wage[a];\n        });\n        double res = 1e9;\n        double totalq = 0.0;\n        priority_queue<int, vector<int>, less<int>> q;\n        for (int i = 0; i < k - 1; i++) {\n            totalq += quality[h[i]];\n            q.push(quality[h[i]]);\n        }\n        for (int i = k - 1; i < n; i++) {\n            int idx = h[i];\n            totalq += quality[idx];\n            q.push(quality[idx]);\n            double totalc = ((double) wage[idx] / quality[idx]) * totalq;\n            res = min(res, totalc);\n            totalq -= q.top();\n            q.pop();\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {\n        int n = quality.length;\n        Integer[] h = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            h[i] = i;\n        }\n        Arrays.sort(h, (a, b) -> {\n            return quality[b] * wage[a] - quality[a] * wage[b];\n        });\n        double res = 1e9;\n        double totalq = 0.0;\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\n        for (int i = 0; i < k - 1; i++) {\n            totalq += quality[h[i]];\n            pq.offer(quality[h[i]]);\n        }\n        for (int i = k - 1; i < n; i++) {\n            int idx = h[i];\n            totalq += quality[idx];\n            pq.offer(quality[idx]);\n            double totalc = ((double) wage[idx] / quality[idx]) * totalq;\n            res = Math.min(res, totalc);\n            totalq -= pq.poll();\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public double MincostToHireWorkers(int[] quality, int[] wage, int k) {\n        int n = quality.Length;\n        int[] h = new int[n];\n        for (int i = 0; i < n; i++) {\n            h[i] = i;\n        }\n        Array.Sort(h, (a, b) => {\n            return quality[b] * wage[a] - quality[a] * wage[b];\n        });\n        double res = 1e9;\n        double totalq = 0.0;\n        PriorityQueue<int, int> pq = new PriorityQueue<int, int>();\n        for (int i = 0; i < k - 1; i++) {\n            totalq += quality[h[i]];\n            pq.Enqueue(quality[h[i]], -quality[h[i]]);\n        }\n        for (int i = k - 1; i < n; i++) {\n            int idx = h[i];\n            totalq += quality[idx];\n            pq.Enqueue(quality[idx], -quality[idx]);\n            double totalc = ((double) wage[idx] / quality[idx]) * totalq;\n            res = Math.Min(res, totalc);\n            totalq -= pq.Dequeue();\n        }\n        return res;\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar mincostToHireWorkers = function(quality, wage, k) {\n    const n = quality.length;\n    const h = new Array(n).fill(0).map((_, i) => i);\n    h.sort((a, b) => {\n        return quality[b] * wage[a] - quality[a] * wage[b];\n    });\n    let res = 1e9;\n    let totalq = 0.0;\n    const pq = new MaxPriorityQueue();\n    for (let i = 0; i < k - 1; i++) {\n        totalq += quality[h[i]];\n        pq.enqueue(quality[h[i]]);\n    }\n    for (let i = k - 1; i < n; i++) {\n        let idx = h[i];\n        totalq += quality[idx];\n        pq.enqueue(quality[idx]);\n        const totalc = (wage[idx] / quality[idx]) * totalq;\n        res = Math.min(res, totalc);\n        totalq -= pq.dequeue().element;\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc mincostToHireWorkers(quality, wage []int, k int) float64 {\n    n := len(quality)\n    h := make([]int, n)\n    for i := range h {\n        h[i] = i\n    }\n    sort.Slice(h, func(i, j int) bool {\n        a, b := h[i], h[j]\n        return quality[a]*wage[b] > quality[b]*wage[a]\n    })\n    totalq := 0\n    q := hp{}\n    for i := 0; i < k-1; i++ {\n        totalq += quality[h[i]]\n        heap.Push(&q, quality[h[i]])\n    }\n    ans := 1e9\n    for i := k - 1; i < n; i++ {\n        idx := h[i]\n        totalq += quality[idx]\n        heap.Push(&q, quality[idx])\n        ans = math.Min(ans, float64(wage[idx])/float64(quality[idx])*float64(totalq))\n        totalq -= heap.Pop(&q).(int)\n    }\n    return ans\n}\n\ntype hp struct{ sort.IntSlice }\n\nfunc (h hp) Less(i, j int) bool  { return h.IntSlice[i] > h.IntSlice[j] }\nfunc (h *hp) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) }\nfunc (h *hp) Pop() interface{}   { a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v }\n``` \n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times \\log n)$，主要为排序和每一个元素进出优先队列的时间复杂度。\n- 空间复杂度：$O(n)$，主要为排序的辅助数组和优先队列的空间开销。"
}