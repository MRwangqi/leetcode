{
	"titleSlug": "intersection-lcci",
	"slug": "jiao-dian-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/intersection-lcci/solution/jiao-dian-by-leetcode-solution/",
	"content": "#### 方法一：参数方程\n\n**预备知识**\n\n在数学上，我们一般会使用直线的方程加上一些限制，来表示一条线段。常用的表示直线的方法有如下几种：\n\n- 斜截式，用两个参数分别表示斜率和截距，即：\n\n    $$\n    y = kx + b\n    $$\n\n- 截距式，用两个参数分别表示在 $x$ 轴和 $y$ 轴上的截距，即：\n\n    $$\n    \\frac{x}{a} + \\frac{y}{b} = 1\n    $$\n\n    或者也可以写成：\n\n    $$\n    ax + by + c = 0\n    $$\n\n- 参数方程式，用三个参数分别表示直线上的一个已知点以及参数 $t$，即：\n\n    $$\n    \\begin{cases}\n    x = x0 + t\\triangle x \\\\\n    y = y0 + t\\triangle y\n    \\end{cases}\n    $$\n\n那么对于本题而言，我们使用哪一种方法比较好呢？我们需要依次考虑上述的方法在表示「线段」时有没有潜在的缺陷：\n\n- 对于「斜截式」，它本身就有一个很严重的缺陷：它无法表示与 $y$ 轴平行的直线或线段（即直线 $x=c$）；\n\n- 对于「截距式」，它可以表示任意的直线，但在表示线段时非常不直观；\n\n- 对于「参数方程式」，它可以表示任意的直线，并且它非常适合用于表示线段。假设我们给定两个点 $(x_1, y_1)$ 以及 $(x_2, y_2)$，我们只需要令：\n\n    $$\n    \\begin{cases}\n    x = x_1 + t(x_2 - x_1) \\\\\n    y = y_1 + t(y_2 - y_1)\n    \\end{cases}\n    $$\n\n    并且将 $t$ 限制在 $[0, 1]$ 的范围内，就可以表示端点为 $(x_1, y_1)$ 以及 $(x_2, y_2)$ 的线段，十分方便。\n\n因此，使用「参数方程式」表示线段是最适合本题的。在下面的题解中，我们会给出使用「参数方程式」解决本题的方法。\n\n\n**说明**\n\n为了叙述方便，我们设一条线段的两个端点分别为 $(x_1, y_1)$ 以及 $(x_2, y_2)$，另一条线段的两个端点分别为 $(x_3, y_3)$ 以及 $(x_4, y_4)$。\n\n初中数学告诉我们：**平面上的两条直线如果不平行，那么它们一定相交，并且有唯一的交点**。那么我们首先就来处理两条线段不平行的情况：\n\n- 写出这两条线段所在直线的参数方程；\n\n- 联立这两个参数方程求出交点；\n\n- 判断这个交点是否在线段上。\n\n思路很简单，但需要小心一些，因为有不少的数学推导。我们一步一步来：\n\n- 写出这两条线段所在直线的参数方程：\n\n    对于线段 $(x1, y1) \\sim (x2, y2)$，它的参数方程为：\n\n    $$\n    \\begin{cases}\n    x = x_1 + t_1(x_2 - x_1) \\\\\n    y = y_1 + t_1(y_2 - y_1)\n    \\end{cases}\n    \\quad t_1 \\in [0, 1]\n    $$\n\n    对于线段 $(x3, y3) \\sim (x4, y4)$，它的参数方程为：\n\n    $$\n    \\begin{cases}\n    x = x_3 + t_2(x_4 - x_3) \\\\\n    y = y_3 + t_2(y_4 - y_3)\n    \\end{cases}\n    \\quad t_2 \\in [0, 1]\n    $$\n\n- 联立这两个参数方程求出交点：\n\n    我们先忽略 $t1, t2 \\in [0, 1]$ 的限制，求出它们的值之后再进行判断。联立得到的方程组为：\n\n    $$\n    \\begin{cases}\n    x_1 + t_1(x_2 - x_1) = x_3 + t_2(x_4 - x_3) \\\\\n    y_1 + t_1(y_2 - y_1) = y_3 + t_2(y_4 - y_3)\n    \\end{cases}\n    $$\n\n    这是一个普通的二元一次方程组，我们可以得到解为：\n\n    $$\n    \\begin{cases}\n    t_1 = \\frac{x_3(y_4-y_3)+y_1(x_4-x_3)-y_3(x_4-x_3)-x_1(y_4-y_3)}{(x_2-x_1)(y_4-y_3)-(x_4-x_3)(y_2-y_1)}\\\\\n    t_2 = \\frac{x_1(y_2-y_1)+y_3(x_2-x_1)-y_1(x_2-x_1)-x_3(y_2-y_1)}{(x_4-x_3)(y_2-y_1)-(x_2-x_1)(y_4-y_3)}\n    \\end{cases}\n    $$\n\n    这里可能会有读者产生疑问：**需要判定这个解的分母可能为 $0$ 吗**？答案是不需要的，这是因为这两条线段对应的直线一定有 **唯一** 的交点，也就是说，一定有且仅有一组 $(t_1, t_2)$ 使得上面的二元一次方程组成立，$t_1$ 描述了交点在线段 $(x1, y1) \\sim (x2, y2)$ 所在直线上的位置，$t_2$ 描述了交点在线段 $(x3, y3) \\sim (x4, y4)$ 所在直线上的位置。\n    \n    并且，我们也可以用数学推导出分母不可能为 $0$。以 $t_1$ 为例，分母为：\n\n    $$\n    (x_2-x_1)(y_4-y_3)-(x_4-x_3)(y_2-y_1)\n    $$\n\n    若它的值为 $0$，那么有：\n\n    $$\n    \\begin{aligned}\n    & (x_2-x_1)(y_4-y_3)-(x_4-x_3)(y_2-y_1) = 0\\\\\n    \\Rightarrow & (x_2-x_1)(y_4-y_3) = (x_4-x_3)(y_2-y_1)\\\\\n    \\Rightarrow & \\frac{y_4-y_3}{x_4-x_3} = \\frac{y_2-y_1}{x_2-x_1}\n    \\end{aligned}\n    $$\n\n    得到等式的左右两侧分别为两条直线的斜率，由于它们不平行，斜率显然不会相等，那么分母不可能为 $0$。\n\n- 判断这个交点是否在线段上：\n\n    我们只要判断是否有 $0 \\leq t_1 \\leq 1$ 以及 $0 \\leq t_2 \\leq 1$ 即可。\n\n\n解决了两条线段不平行的情况，下面我们只要再解决平行的情况，就可以完成本题了。上文也提到过，可以通过检查斜率来判断两条线段是否平行，即当：\n\n$$\n\\frac{y_4-y_3}{x_4-x_3} = \\frac{y_2-y_1}{x_2-x_1}\n$$\n\n满足时，两条线段平行。但这里需要注意的是，可能出现斜率无穷大的情况（即线段与 $y$ 轴平行），此时 $x_2 - x_1$ 以及 $x_4 - x_3$ 的值为 $0$，无法作为分母。因此我们需要将除法变为乘法，用：\n\n$$\n(y_4-y_3)(x_2-x_1) = (y_2-y_1)(x_4-x_3)\n$$\n\n进行判断。\n\n当我们知道了两条线段平行之后，会有两种情况：\n\n- 这两条线段不在同一条直线上，那么它们不会有交点；\n\n- 这两条线段在同一条直线上，此时如果它们有交点，最优的交点一定是 $(x_1, y_1)$、$(x_2, y_2)$、$(x_3, y_3)$ 以及 $(x_4, y_4)$ 中的一个。这是因为假设这两条线段有交点 $(x_i, y_i)$，那么我们一定可以不断地将这个交点往更优的方向移动，直到到达某一条线段的端点，这个端点即为上述四个端点中的一个。\n\n那么我们如何判断这两条线段是否在同一条直线上呢？由于它们平行，因此我们只需要判断 $(x_3, y_3)$ 是否在 $(x_1, y_1) \\sim (x_2, y_2)$ 所在的直线上。即存在 $t \\in \\mathbb{R}$ 使得：\n\n$$\n\\begin{cases}\nx_3 = x_1 + t(x_2 - x_1)\\\\\ny_3 = y_1 + t(y_2 - y_1)\n\\end{cases}\n$$\n\n联立这两个等式即可得到\n$$\n\\begin{aligned}\n& t = \\frac{x_3 - x_1}{x_2 - x_1} = \\frac{y_3 - y_1}{y_2 - y_1}\\\\\n\\Rightarrow & \\frac{y_2 - y_1}{x_2 - x_1} = \\frac{y_3 - y_1}{x_3 - x_1}\n\\end{aligned}\n$$\n\n它的几何意义为：$(x_1, y_1) \\sim (x_2, y_2)$ 的斜率等于 $(x_1, y_1) \\sim (x_3, y_3)$ 的斜率，这也是比较直观的。同样地，我们需要将除法变为乘法进行判断:\n\n$$\n(y_2 - y_1)(x_3 - x_1) = (y_3 - y_1)(x_2 - x_1)\n$$\n\n最后一步我们只需要判断：\n\n- $(x_1, y_1)$ 是否在线段 $(x_3, y_3) \\sim (x_4, y_4)$ 上；\n\n- $(x_2, y_2)$ 是否在线段 $(x_3, y_3) \\sim (x_4, y_4)$ 上；\n\n- $(x_3, y_3)$ 是否在线段 $(x_1, y_1) \\sim (x_2, y_2)$ 上；\n\n- $(x_4, y_4)$ 是否在线段 $(x_1, y_1) \\sim (x_2, y_2)$ 上。\n\n并在满足条件的端点中选择一个最优的。我们以判断 $(x_3, y_3)$ 是否在线段 $(x_1, y_1) \\sim (x_2, y_2)$ 上为例，根据上文的推导，需要满足：\n\n$$\n0 \\leq \\frac{x_3 - x_1}{x_2 - x_1} = \\frac{y_3 - y_1}{y_2 - y_1} \\leq 1\n$$\n\n这里有一些边界情况，我们一种一种来考虑：\n\n- 如果线段 $(x_1, y_1) \\sim (x_2, y_2)$ 与 $x$ 轴平行，即 $y_1 = y_2$，那么只需要判断是否有：\n\n    $$\n    0 \\leq \\frac{x_3 - x_1}{x_2 - x_1} \\leq 1\n    $$\n    \n    它等价于 $\\min(x_1, x_2) \\leq x_3 \\leq \\max(x_1, x_2)$。它的几何意义也是很显然的，因为线段与 $x$ 轴平行，所以只要 $x_3$ 在 $x_1$ 与 $x_2$ 之间就行了；\n\n- 如果线段 $(x_1, y_1) \\sim (x_2, y_2)$ 与 $y$ 轴平行，即 $x_1 = x_2$，那么只需要判断是否有：\n\n    $$\n    0 \\leq \\frac{y_3 - y_1}{y_2 - y_1} \\leq 1\n    $$\n    \n    它等价于 $\\min(y_1, y_2) \\leq y_3 \\leq \\max(y_1, y_2)$；\n\n- 如果是其余的情况，那么需要判断 $\\min(x_1, x_2) \\leq x_3 \\leq \\max(x_1, x_2)$ 和 $\\min(y_1, y_2) \\leq y_3 \\leq \\max(y_1, y_2)$ 这两者。\n\n自此为止，我们就完美地解决了这个问题。\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    // 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上\n    // 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上\n    bool inside(int x1, int y1, int x2, int y2, int xk, int yk) {\n        // 若与 x 轴平行，只需要判断 x 的部分\n        // 若与 y 轴平行，只需要判断 y 的部分\n        // 若为普通线段，则都要判断\n        return (x1 == x2 || (min(x1, x2) <= xk && xk <= max(x1, x2))) && (y1 == y2 || (min(y1, y2) <= yk && yk <= max(y1, y2)));\n    }\n\n    void update(vector<double>& ans, double xk, double yk) {\n        // 将一个交点与当前 ans 中的结果进行比较\n        // 若更优则替换\n        if (!ans.size() || xk < ans[0] || (xk == ans[0] && yk < ans[1])) {\n            ans = {xk, yk};\n        }\n    }\n\n    vector<double> intersection(vector<int>& start1, vector<int>& end1, vector<int>& start2, vector<int>& end2) {\n        int x1 = start1[0], y1 = start1[1];\n        int x2 = end1[0], y2 = end1[1];\n        int x3 = start2[0], y3 = start2[1];\n        int x4 = end2[0], y4 = end2[1];\n\n        vector<double> ans;\n        // 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y3) 是否平行\n        if ((y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3)) {\n            // 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上\n            if ((y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)) {\n                // 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上\n                if (inside(x1, y1, x2, y2, x3, y3)) {\n                    update(ans, (double)x3, (double)y3);\n                }\n                // 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上\n                if (inside(x1, y1, x2, y2, x4, y4)) {\n                    update(ans, (double)x4, (double)y4);\n                }\n                // 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上\n                if (inside(x3, y3, x4, y4, x1, y1)) {\n                    update(ans, (double)x1, (double)y1);\n                }\n                // 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上\n                if (inside(x3, y3, x4, y4, x2, y2)) {\n                    update(ans, (double)x2, (double)y2);\n                }\n            }\n            // 在平行时，其余的所有情况都不会有交点\n        } else {\n            // 联立方程得到 t1 和 t2 的值\n            double t1 = (double)(x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1));\n            double t2 = (double)(x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3));\n            // 判断 t1 和 t2 是否均在 [0, 1] 之间\n            if (t1 >= 0.0 && t1 <= 1.0 && t2 >= 0.0 && t2 <= 1.0) {\n                ans = {x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)};\n            }\n        }\n        return ans;\n    }\n};\n```\n```Java [sol1-Java]\nclass Solution {\n    double[] ans = new double[0];\n\n    public double[] intersection(int[] start1, int[] end1, int[] start2, int[] end2) {\n        int x1 = start1[0], y1 = start1[1];\n        int x2 = end1[0], y2 = end1[1];\n        int x3 = start2[0], y3 = start2[1];\n        int x4 = end2[0], y4 = end2[1];\n\n        // 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y4) 是否平行\n        if ((y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3)) {\n            // 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上\n            if ((y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)) {\n                // 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上\n                if (inside(x1, y1, x2, y2, x3, y3)) {\n                    update(x3, y3);\n                }\n                // 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上\n                if (inside(x1, y1, x2, y2, x4, y4)) {\n                    update(x4, y4);\n                }\n                // 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上\n                if (inside(x3, y3, x4, y4, x1, y1)) {\n                    update(x1, y1);\n                }\n                // 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上\n                if (inside(x3, y3, x4, y4, x2, y2)) {\n                    update(x2, y2);\n                }\n            }\n            // 在平行时，其余的所有情况都不会有交点\n        } else {\n            // 联立方程得到 t1 和 t2 的值\n            double t1 = (double) (x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1));\n            double t2 = (double) (x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3));\n            // 判断 t1 和 t2 是否均在 [0, 1] 之间\n            if (t1 >= 0.0 && t1 <= 1.0 && t2 >= 0.0 && t2 <= 1.0) {\n                ans = new double[]{x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)};\n            }\n        }\n        return ans;\n    }\n\n    // 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上\n    // 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上\n    public boolean inside(int x1, int y1, int x2, int y2, int xk, int yk) {\n        // 若与 x 轴平行，只需要判断 x 的部分\n        // 若与 y 轴平行，只需要判断 y 的部分\n        // 若为普通线段，则都要判断\n        return (x1 == x2 || (Math.min(x1, x2) <= xk && xk <= Math.max(x1, x2))) && (y1 == y2 || (Math.min(y1, y2) <= yk && yk <= Math.max(y1, y2)));\n    }\n\n    public void update(double xk, double yk) {\n        // 将一个交点与当前 ans 中的结果进行比较\n        // 若更优则替换\n        if (ans.length == 0 || xk < ans[0] || (xk == ans[0] && yk < ans[1])) {\n            ans = new double[]{xk, yk};\n        }\n    }\n}\n```\n```Python [sol1-Python3]\nclass Solution:\n    def intersection(self, start1: List[int], end1: List[int], start2: List[int], end2: List[int]) -> List[float]:\n        # 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上\n        # 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上\n        def inside(x1, y1, x2, y2, xk, yk):\n            # 若与 x 轴平行，只需要判断 x 的部分\n            # 若与 y 轴平行，只需要判断 y 的部分\n            # 若为普通线段，则都要判断\n            return (x1 == x2 or min(x1, x2) <= xk <= max(x1, x2)) and (y1 == y2 or min(y1, y2) <= yk <= max(y1, y2))\n        \n        def update(ans, xk, yk):\n            # 将一个交点与当前 ans 中的结果进行比较\n            # 若更优则替换\n            return [xk, yk] if not ans or [xk, yk] < ans else ans\n        \n        x1, y1 = start1\n        x2, y2 = end1\n        x3, y3 = start2\n        x4, y4 = end2\n\n        ans = list()\n        # 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y3) 是否平行\n        if (y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3):\n            # 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上\n            if (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1):\n                # 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上\n                if inside(x1, y1, x2, y2, x3, y3):\n                    ans = update(ans, x3, y3)\n                # 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上\n                if inside(x1, y1, x2, y2, x4, y4):\n                    ans = update(ans, x4, y4)\n                # 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上\n                if inside(x3, y3, x4, y4, x1, y1):\n                    ans = update(ans, x1, y1)\n                # 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上\n                if inside(x3, y3, x4, y4, x2, y2):\n                    ans = update(ans, x2, y2)\n            # 在平行时，其余的所有情况都不会有交点\n        else:\n            # 联立方程得到 t1 和 t2 的值\n            t1 = (x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1))\n            t2 = (x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3))\n            # 判断 t1 和 t2 是否均在 [0, 1] 之间\n            if 0.0 <= t1 <= 1.0 and 0.0 <= t2 <= 1.0:\n                ans = [x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)]\n\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：叉积法\n\n**预备知识**\n\n我们也可以不用表示出线段的方程，通过向量的基本运算来解决这个问题。这里引入一些向量运算的基本概念。\n\n+ 向量叉积的模：对于向量 $\\boldsymbol{a} = (x_1, y_1)$ 和 $\\boldsymbol{b} = (x_2, y_2)$，定义向量的叉积的模为 \n    $$|\\boldsymbol{c}| = |\\boldsymbol{a} \\times \\boldsymbol{b}| = |\\boldsymbol{a}||\\boldsymbol{b}| \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle  = x_1 y_2 - x_2 y_1$$\n其中 $\\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle$ 表示 $\\boldsymbol{a}$ 和 $\\boldsymbol{b}$ 的夹角。这个模的正负性可以表示这两个向量的位置关系，如果 $\\boldsymbol{a}$ 可以逆时针旋转与 $\\boldsymbol{b}$ 共线，那么这个模大于 0；如果 $\\boldsymbol{a}$ 可以顺时针旋转与 $\\boldsymbol{b}$ 共线，那么这个模小于 0；如果已经共线，则等于 0。\n+ 三角形的面积：有了叉积的定义，我们可以这样计算三角形 $ABC$ 的面积\n$$ S = \\frac{|\\boldsymbol{AB}\\times \\boldsymbol{AC}|}{2} $$\n很好理解，画图可以看出 $\\sin \\langle \\boldsymbol{a}, \\boldsymbol{b}\\rangle$ 相当于把一个向量投影成了另一个向量为底边的高。\n+ 定比分点：若 $P(x, y)$ 在线段 $AB$ 上，端点坐标 $A(x_1, y_2)$，$B(x_2, y_2)$，且 $AP$ 和 $BP$ 的长度之比为 $\\lambda$，那么\n$$\n    \\left \\{\n    \\begin{aligned}\n    x &=& \\frac{x_1 + \\lambda x_2}{1 + \\lambda} \\\\\n    y &=& \\frac{y_1 + \\lambda y_2}{1 + \\lambda}\n    \\end{aligned}\n    \\right .\n$$\n\n**说明**\n\n题目要求「如果有交点则计算交点，没有则返回空值」，并说明有多个交点的时候返回以 $x$ 为第一关键字，以 $y$ 为第二关键字排序的最小点。\n\n首先我们要判断线段 $AB$ 和 $CD$ 是否存在交点，等价转换这个条件就是 $A$ 和 $B$ 位于 $CD$ 的两侧并且 $C$ 和 $D$ 位于 $AB$ 的两侧。那么如何判断「$P$ 和 $Q$ 位于 $MN$ 的两侧」呢？我们可以连接 $PM$ 和 $QM$，如果能满足 $(\\boldsymbol{MN} \\times \\boldsymbol{MP})(\\boldsymbol{MN} \\times \\boldsymbol{MQ}) \\leq 0$，即把 $\\boldsymbol{MN}$ 向两个不同的方向旋转可以分别得到 $\\boldsymbol{MP}$ 和 $\\boldsymbol{MQ}$，则说明$P$ 和 $Q$ 位于 $MN$ 的两侧。**考虑：什么时候等于 $0$？** 很明显当 $P$ 或 $Q$ 位于 $MN$ 上的时候，这个值等于 $0$。这里我们也可以先通过叉积的方法判断 $\\boldsymbol{MN}$ 和 $\\boldsymbol{PQ}$ 是否共线，如果 $\\boldsymbol{MN} \\times \\boldsymbol{MP}$ 和 $\\boldsymbol{MN} \\times \\boldsymbol{MQ}$ 都为 $0$，则说明共线。对于共线的情况，我们可以根据方法一的做法做四个 `update`。\n\n\n当已经确定两个线段 $AB$ 和 $CD$ 是相交的时候，如何求解线段的交点呢？我们可以把 $AB$ 和 $CD$ 看成一个四边形的两条对角线，它们相交与点 $O$。我们可以通过三角形面积公式求出 $ABC$ 和 $ABD$ 的面积，它们的比值就是 $OC$ 和 $OD$ 的比值，然后再用定比分点公式求出 $O$ 的坐标。\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    using Coor = vector <double>;\n\n    vector<double> intersection(vector<int>& start1, vector<int>& end1, vector<int>& start2, vector<int>& end2) {\n        int ax = start1[0], ay = start1[1], bx = end1[0], by = end1[1];\n        int cx = start2[0], cy = start2[1], dx = end2[0], dy = end2[1];\n        int acx = cx - ax, acy = cy - ay, abx = bx - ax, aby = by - ay, adx = dx - ax, ady = dy - ay;\n        int cax = ax - cx, cay = ay - cy, cbx = bx - cx, cby = by - cy, cdx = dx - cx, cdy = dy - cy;\n        // 叉积运算\n        auto cross = [] (int ux, int uy, int vx, int vy) {\n            return ux * vy - vx * uy;\n        };\n        // 判断线段 (ux, uy) -- (vx, vy) 是否包含 (mx, my)  \n        auto bothSide = [&] (int mx, int my, int ux, int uy, int vx, int vy) {\n            double um = sqrt((ux - mx) * (ux - mx) + (uy - my) * (uy - my));\n            double vm = sqrt((vx - mx) * (vx - mx) + (vy - my) * (vy - my));\n            double uv = sqrt((vx - ux) * (vx - ux) + (vy - uy) * (vy - uy));\n            return (ux - mx) * (vx - mx) <= 0 && (uy - my) * (vy - my) <= 0;\n        };\n        // 以 x 为第一关键字，y 为第二关键字比较两个点的大小\n        auto cmp = [] (const Coor& u, const Coor& v) {\n            if (u.size() == 0 || v.size() == 0) return v.size() == 0;\n            return (u[0] != v[0]) ? (u[0] < v[0]) : (u[1] < v[1]);\n        };\n        // 共线处理和 T 形处理\n        if (cross(cax, cay, cbx, cby) == 0 || cross(adx, ady, abx, aby) == 0) {\n            bool aInCd = bothSide(ax, ay, cx, cy, dx, dy), bInCd = bothSide(bx, by, cx, cy, dx, dy);\n            bool cInAb = bothSide(cx, cy, ax, ay, bx, by), dInAb = bothSide(dx, dy, ax, ay, bx, by);\n            Coor ans;\n            if (aInCd) ans = min(ans, Coor({(double)ax, (double)ay}), cmp) ;\n            if (bInCd) ans = min(ans, Coor({(double)bx, (double)by}), cmp);\n            if (cInAb) ans = min(ans, Coor({(double)cx, (double)cy}), cmp);\n            if (dInAb) ans = min(ans, Coor({(double)dx, (double)dy}), cmp);\n            return ans;\n        }\n        // 判断两条线段是否有公共点\n        auto intersect = [&] () {\n            return cross(acx, acy, abx, aby) * cross(adx, ady, abx, aby) <= 0 && cross(cax, cay, cdx, cdy) * cross(cbx, cby, cdx, cdy) <= 0;\n        };\n        if (!intersect()) {\n            return Coor();\n        }\n        // 计算三角形 PQM 的面积\n        auto getArea = [&] (int px, int py, int qx, int qy, int mx, int my) -> double {\n            int mpx = px - mx, mpy = py - my, mqx = qx - mx, mqy = qy - my;\n            return fabs(double(0.5) * cross(mpx, mpy, mqx, mqy));\n        };\n        // 定比分点\n        double ck = getArea(ax, ay, bx, by, cx, cy), dk = getArea(ax, ay, bx, by, dx, dy);\n        double k = ck / dk;\n        double rx = (cx + k * dx) / (1 + k), ry = (cy + k * dy) / (1 + k);\n        return Coor({rx, ry});\n    }\n};\n```\n```Java [sol2-Java]\nclass Solution {\n    double[] ans = new double[0];\n\n    public double[] intersection(int[] start1, int[] end1, int[] start2, int[] end2) {\n        int ax = start1[0], ay = start1[1], bx = end1[0], by = end1[1];\n        int cx = start2[0], cy = start2[1], dx = end2[0], dy = end2[1];\n        int acx = cx - ax, acy = cy - ay, abx = bx - ax, aby = by - ay, adx = dx - ax, ady = dy - ay;\n        int cax = ax - cx, cay = ay - cy, cbx = bx - cx, cby = by - cy, cdx = dx - cx, cdy = dy - cy;\n        // 共线处理和 T 形处理\n        if (cross(cax, cay, cbx, cby) == 0 || cross(adx, ady, abx, aby) == 0) {\n            boolean aInCd = bothSide(ax, ay, cx, cy, dx, dy), bInCd = bothSide(bx, by, cx, cy, dx, dy);\n            boolean cInAb = bothSide(cx, cy, ax, ay, bx, by), dInAb = bothSide(dx, dy, ax, ay, bx, by);\n            if (aInCd) {\n                update(ax, ay);\n            }\n            if (bInCd) {\n                update(bx, by);\n            }\n            if (cInAb) {\n                update(cx, cy);\n            }\n            if (dInAb) {\n                update(dx, dy);\n            }\n            return ans;\n        }\n        \n        if (!intersect(acx, acy, abx, aby, adx, ady, cax, cay, cbx, cby, cdx, cdy)) {\n            return new double[0];\n        }\n        // 定比分点\n        double ck = getArea(ax, ay, bx, by, cx, cy), dk = getArea(ax, ay, bx, by, dx, dy);\n        double k = ck / dk;\n        double rx = (cx + k * dx) / (1 + k), ry = (cy + k * dy) / (1 + k);\n        return new double[]{rx, ry};\n    }\n\n    // 判断线段 (ux, uy) -- (vx, vy) 是否包含 (mx, my)  \n    public boolean bothSide(int mx, int my, int ux, int uy, int vx, int vy) {\n        double um = Math.sqrt((ux - mx) * (ux - mx) + (uy - my) * (uy - my));\n        double vm = Math.sqrt((vx - mx) * (vx - mx) + (vy - my) * (vy - my));\n        double uv = Math.sqrt((vx - ux) * (vx - ux) + (vy - uy) * (vy - uy));\n        return (ux - mx) * (vx - mx) <= 0 && (uy - my) * (vy - my) <= 0;\n    }\n\n    // 叉积运算\n    public int cross(int ux, int uy, int vx, int vy) {\n        return ux * vy - vx * uy;\n    }\n\n    public void update(double x, double y) {\n        // 以 x 为第一关键字，y 为第二关键字比较两个点的大小\n        // 将一个交点与当前 ans 中的结果进行比较\n        // 若更优则替换\n        if (ans.length == 0 || x < ans[0] || (x == ans[0] && y < ans[1])) {\n            ans = new double[]{x, y};\n        }\n    }\n\n    // 判断两条线段是否有公共点\n    public boolean intersect(int acx, int acy, int abx, int aby, int adx, int ady, int cax, int cay, int cbx, int cby, int cdx, int cdy) {\n        return cross(acx, acy, abx, aby) * cross(adx, ady, abx, aby) <= 0 && cross(cax, cay, cdx, cdy) * cross(cbx, cby, cdx, cdy) <= 0;\n    }\n\n    // 计算三角形 PQM 的面积\n    public double getArea(int px, int py, int qx, int qy, int mx, int my) {\n        int mpx = px - mx, mpy = py - my, mqx = qx - mx, mqy = qy - my;\n        return Math.abs(0.5 * cross(mpx, mpy, mqx, mqy));\n    }\n}\n```\n\n在代码中「共线处理和 T 形处理」部分，为什么只判断了 $ABC$ 共线或者 $ABD$ 共线呢？\n\n+ 如果 $ABC$ 共线且 $ABD$ 共线，那么说明 $ABCD$ 共线\n+ 如果 $ABC$ 共线但是 $ABD$ 不共线，那么说明 $C$ 在「直线」$AB$ 上，如果 $C$ 在「线段」$AB$ 上则形成一个 T 形结构\n+ 如果 $ABD$ 共线但是 $ABC$ 不共线，那么说明 $D$ 在「直线」$AB$ 上，如果 $D$ 在「线段」$AB$ 上则形成一个 T 形结构\n\n这里只能判断点是否在「直线」上，在 `if` 里面才可以判断点是否在线段上。这三种情况都能得到正确的结果，因为经过四个取 `min` 的操作（即方法一中的四个 `update`），所有「点 $P$ 在 $MN$ 上」的情况可以被讨论出来，所以这里不仅处理的是共线的情况，还有四种 T 形的情况中的两种。**思考：为什么不用处理剩下的两种呢？** 不判断 $ACD$ 和 $BCD$，因为后面定比分点用的是 $ABC$ 和 $ABD$ 的面积，前面 $ABC$ 共线和 $ABD$ 共线被处理掉之后，就不存在面积为 $0$ 的状况，也就不会出现分母为 $0$。即使 $ACD$ 和 $BCD$ 共线，$ABC$ 和 $ABD$ 的面积依然是大于 $0$ 的，不影响定比分点。\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$。\n\n- 空间复杂度：$O(1)$。"
}