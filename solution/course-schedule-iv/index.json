{
	"titleSlug": "course-schedule-iv",
	"slug": "-by-wa-pian-d-b1dk",
	"url": "https://leetcode-cn.com/problems/course-schedule-iv/solution/-by-wa-pian-d-b1dk/",
	"content": "### 解题思路\n\n深搜比拓扑好吧？\n\n拓扑和宽搜需要保存太多的状态。\n\n### 代码\n\n```java\nclass Solution {\n\tpublic List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {\n\t\t// 建立前置课程图:前置课->课\n\t\tint len = prerequisites.length;\n\t\tMap<Integer, List<Integer>> edges = new HashMap<>();// 边集合\n\t\tint[] ins = new int[numCourses];// 课程入度\n\t\tthis.buildGraph(len, prerequisites, edges, ins);\n\t\t// 建立到达关系\n\t\tboolean[][] reach = new boolean[numCourses][numCourses];// reach[a][b]=true表示有从a到b的路，a为b的前置\n\t\t// 准备宽度优先搜索\n\t\tQueue<Integer> queue = new LinkedList<>();\n\t\tfor (int i = 0; i < numCourses; i++) {\n\t\t\tint in = ins[i];// 面壁思过\n\t\t\tif (in == 0 && edges.containsKey(i)) {// if(疑似前置课程 && 有后续课程){确认是前置课程}\n\t\t\t\tqueue.add(i);// 面壁思过，入度添加到队列，错的离谱\n\t\t\t}\n\t\t}\n\t\tMap<Integer, Set<Integer>> preCourses = new HashMap<>();\n\t\tSet<Integer> preCourse = null;\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint course = queue.poll();\n\t\t\tpreCourse = preCourses.getOrDefault(course, new HashSet<>());\n\t\t\tfor (int pre : preCourse) {\n\t\t\t\treach[pre][course] = true;\n\t\t\t}\n\t\t\tpreCourse.add(course);\n\t\t\tList<Integer> edge = edges.getOrDefault(course, null);\n\t\t\tif (edge == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int to : edge) {\n\t\t\t\tint in = --ins[to];\n\t\t\t\tSet<Integer> preCourse4to = preCourses.getOrDefault(to, new HashSet<>());\n\t\t\t\tpreCourse4to.addAll(preCourse);\n\t\t\t\tpreCourses.put(to, preCourse4to);\n\t\t\t\tif (in == 0) {\n\t\t\t\t\tqueue.add(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 到reach表中找答案\n\t\tint queryLen = queries.length;\n\t\tList<Boolean> ans = new ArrayList<>();\n\t\tfor (int i = 0; i < queryLen; i++) {\n\t\t\tint[] query = queries[i];\n\t\t\tint from = query[0], to = query[1];\n\t\t\tans.add(reach[from][to]);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate void buildGraph(int len, int[][] prerequisites, Map<Integer, List<Integer>> edges, int[] ins) {\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tint[] pre = prerequisites[i];\n\t\t\tint courseStart = pre[0], courseEnd = pre[1];\n\t\t\tList<Integer> edge = edges.getOrDefault(courseStart, new ArrayList<>());// 取出class1的边集\n\t\t\tedge.add(courseEnd);// 添加新边\n\t\t\tedges.put(courseStart, edge);\n\t\t\tins[courseEnd]++;// 入度增加1\n\t\t}\n\t}\n}\n```"
}