{
	"titleSlug": "generate-parentheses",
	"slug": "gua-hao-sheng-cheng-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/generate-parentheses/solution/gua-hao-sheng-cheng-by-leetcode-solution/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£ \n![22. æ‹¬å·ç”Ÿæˆv2.mp4](50358f3a-2331-4604-a089-a4bf80c4cc61)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n\n#### æ–¹æ³•ä¸€ï¼šæš´åŠ›æ³•\n\n**æ€è·¯**\n\næˆ‘ä»¬å¯ä»¥ç”Ÿæˆæ‰€æœ‰ $2^{2n}$ ä¸ª $\\text{`('}$ å’Œ $\\text{`)'}$ å­—ç¬¦æ„æˆçš„åºåˆ—ï¼Œç„¶åæˆ‘ä»¬æ£€æŸ¥æ¯ä¸€ä¸ªæ˜¯å¦æœ‰æ•ˆå³å¯ã€‚\n\n**ç®—æ³•**\n\nä¸ºäº†ç”Ÿæˆæ‰€æœ‰åºåˆ—ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨é€’å½’ã€‚é•¿åº¦ä¸º $n$ çš„åºåˆ—å°±æ˜¯åœ¨é•¿åº¦ä¸º $n - 1$ çš„åºåˆ—å‰åŠ ä¸€ä¸ª $\\text{`('}$ æˆ– $\\text{`)'}$ã€‚\n\nä¸ºäº†æ£€æŸ¥åºåˆ—æ˜¯å¦æœ‰æ•ˆï¼Œæˆ‘ä»¬éå†è¿™ä¸ªåºåˆ—ï¼Œå¹¶ä½¿ç”¨ä¸€ä¸ªå˜é‡ $\\textit{balance}$ è¡¨ç¤ºå·¦æ‹¬å·çš„æ•°é‡å‡å»å³æ‹¬å·çš„æ•°é‡ã€‚å¦‚æœåœ¨éå†è¿‡ç¨‹ä¸­ $\\textit{balance}$ çš„å€¼å°äºé›¶ï¼Œæˆ–è€…ç»“æŸæ—¶ $\\textit{balance}$ çš„å€¼ä¸ä¸ºé›¶ï¼Œé‚£ä¹ˆè¯¥åºåˆ—å°±æ˜¯æ— æ•ˆçš„ï¼Œå¦åˆ™å®ƒæ˜¯æœ‰æ•ˆçš„ã€‚\n\n```Java [sol1-Java]\nclass Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> combinations = new ArrayList<String>();\n        generateAll(new char[2 * n], 0, combinations);\n        return combinations;\n    }\n\n    public void generateAll(char[] current, int pos, List<String> result) {\n        if (pos == current.length) {\n            if (valid(current)) {\n                result.add(new String(current));\n            }\n        } else {\n            current[pos] = '(';\n            generateAll(current, pos + 1, result);\n            current[pos] = ')';\n            generateAll(current, pos + 1, result);\n        }\n    }\n\n    public boolean valid(char[] current) {\n        int balance = 0;\n        for (char c: current) {\n            if (c == '(') {\n                ++balance;\n            } else {\n                --balance;\n            }\n            if (balance < 0) {\n                return false;\n            }\n        }\n        return balance == 0;\n    }\n}\n```\n```Python [sol1-Python3]\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        def generate(A):\n            if len(A) == 2*n:\n                if valid(A):\n                    ans.append(\"\".join(A))\n            else:\n                A.append('(')\n                generate(A)\n                A.pop()\n                A.append(')')\n                generate(A)\n                A.pop()\n\n        def valid(A):\n            bal = 0\n            for c in A:\n                if c == '(': bal += 1\n                else: bal -= 1\n                if bal < 0: return False\n            return bal == 0\n\n        ans = []\n        generate([])\n        return ans\n```\n```C++ [sol1-C++]\nclass Solution {\n    bool valid(const string& str) {\n        int balance = 0;\n        for (char c : str) {\n            if (c == '(') {\n                ++balance;\n            } else {\n                --balance;\n            }\n            if (balance < 0) {\n                return false;\n            }\n        }\n        return balance == 0;\n    }\n\n    void generate_all(string& current, int n, vector<string>& result) {\n        if (n == current.size()) {\n            if (valid(current)) {\n                result.push_back(current);\n            }\n            return;\n        }\n        current += '(';\n        generate_all(current, n, result);\n        current.pop_back();\n        current += ')';\n        generate_all(current, n, result);\n        current.pop_back();\n    }\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> result;\n        string current;\n        generate_all(current, n * 2, result);\n        return result;\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n* æ—¶é—´å¤æ‚åº¦ï¼š$O(2^{2n}n)$ï¼Œå¯¹äº $2^{2n}$ ä¸ªåºåˆ—ä¸­çš„æ¯ä¸€ä¸ªï¼Œæˆ‘ä»¬ç”¨äºå»ºç«‹å’ŒéªŒè¯è¯¥åºåˆ—çš„å¤æ‚åº¦ä¸º $O(n)$ã€‚\n\n* ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œé™¤äº†ç­”æ¡ˆæ•°ç»„ä¹‹å¤–ï¼Œæˆ‘ä»¬æ‰€éœ€è¦çš„ç©ºé—´å–å†³äºé€’å½’æ ˆçš„æ·±åº¦ï¼Œæ¯ä¸€å±‚é€’å½’å‡½æ•°éœ€è¦ $O(1)$ çš„ç©ºé—´ï¼Œæœ€å¤šé€’å½’ $2n$ å±‚ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ã€‚\n\n#### æ–¹æ³•äºŒï¼šå›æº¯æ³•\n\n**æ€è·¯å’Œç®—æ³•**\n\næ–¹æ³•ä¸€è¿˜æœ‰æ”¹è¿›çš„ä½™åœ°ï¼šæˆ‘ä»¬å¯ä»¥åªåœ¨åºåˆ—ä»ç„¶ä¿æŒæœ‰æ•ˆæ—¶æ‰æ·»åŠ  $\\text{`('}$ æˆ– $\\text{`)'}$ï¼Œè€Œä¸æ˜¯åƒ [æ–¹æ³•ä¸€](#æ–¹æ³•ä¸€ï¼šæš´åŠ›æ³•) é‚£æ ·æ¯æ¬¡æ·»åŠ ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è·Ÿè¸ªåˆ°ç›®å‰ä¸ºæ­¢æ”¾ç½®çš„å·¦æ‹¬å·å’Œå³æ‹¬å·çš„æ•°ç›®æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œ\n\nå¦‚æœå·¦æ‹¬å·æ•°é‡ä¸å¤§äº $n$ï¼Œæˆ‘ä»¬å¯ä»¥æ”¾ä¸€ä¸ªå·¦æ‹¬å·ã€‚å¦‚æœå³æ‹¬å·æ•°é‡å°äºå·¦æ‹¬å·çš„æ•°é‡ï¼Œæˆ‘ä»¬å¯ä»¥æ”¾ä¸€ä¸ªå³æ‹¬å·ã€‚\n\n```Java [sol2-Java]\nclass Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> ans = new ArrayList<String>();\n        backtrack(ans, new StringBuilder(), 0, 0, n);\n        return ans;\n    }\n\n    public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max) {\n        if (cur.length() == max * 2) {\n            ans.add(cur.toString());\n            return;\n        }\n        if (open < max) {\n            cur.append('(');\n            backtrack(ans, cur, open + 1, close, max);\n            cur.deleteCharAt(cur.length() - 1);\n        }\n        if (close < open) {\n            cur.append(')');\n            backtrack(ans, cur, open, close + 1, max);\n            cur.deleteCharAt(cur.length() - 1);\n        }\n    }\n}\n```\n```Python [sol2-Python3]\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        ans = []\n        def backtrack(S, left, right):\n            if len(S) == 2 * n:\n                ans.append(''.join(S))\n                return\n            if left < n:\n                S.append('(')\n                backtrack(S, left+1, right)\n                S.pop()\n            if right < left:\n                S.append(')')\n                backtrack(S, left, right+1)\n                S.pop()\n\n        backtrack([], 0, 0)\n        return ans\n```\n```C++ [sol2-C++]\nclass Solution {\n    void backtrack(vector<string>& ans, string& cur, int open, int close, int n) {\n        if (cur.size() == n * 2) {\n            ans.push_back(cur);\n            return;\n        }\n        if (open < n) {\n            cur.push_back('(');\n            backtrack(ans, cur, open + 1, close, n);\n            cur.pop_back();\n        }\n        if (close < open) {\n            cur.push_back(')');\n            backtrack(ans, cur, open, close + 1, n);\n            cur.pop_back();\n        }\n    }\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> result;\n        string current;\n        backtrack(result, current, 0, 0, n);\n        return result;\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\næˆ‘ä»¬çš„å¤æ‚åº¦åˆ†æä¾èµ–äºç†è§£ $\\textit{generateParenthesis}(n)$ ä¸­æœ‰å¤šå°‘ä¸ªå…ƒç´ ã€‚è¿™ä¸ªåˆ†æè¶…å‡ºäº†æœ¬æ–‡çš„èŒƒç•´ï¼Œä½†äº‹å®è¯æ˜è¿™æ˜¯ç¬¬ $n$ ä¸ªå¡ç‰¹å…°æ•° $\\dfrac{1}{n+1}\\dbinom{2n}{n}$ï¼Œè¿™æ˜¯ç”± $\\dfrac{4^n}{n\\sqrt{n}}$ æ¸è¿‘ç•Œå®šçš„ã€‚\n\n* æ—¶é—´å¤æ‚åº¦ï¼š$O(\\dfrac{4^n}{\\sqrt{n}})$ï¼Œåœ¨å›æº¯è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸ªç­”æ¡ˆéœ€è¦ $O(n)$ çš„æ—¶é—´å¤åˆ¶åˆ°ç­”æ¡ˆæ•°ç»„ä¸­ã€‚\n\n* ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œé™¤äº†ç­”æ¡ˆæ•°ç»„ä¹‹å¤–ï¼Œæˆ‘ä»¬æ‰€éœ€è¦çš„ç©ºé—´å–å†³äºé€’å½’æ ˆçš„æ·±åº¦ï¼Œæ¯ä¸€å±‚é€’å½’å‡½æ•°éœ€è¦ $O(1)$ çš„ç©ºé—´ï¼Œæœ€å¤šé€’å½’ $2n$ å±‚ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ã€‚\n\n\n#### æ–¹æ³•ä¸‰ï¼šæŒ‰æ‹¬å·åºåˆ—çš„é•¿åº¦é€’å½’\n\n**æ€è·¯ä¸ç®—æ³•**\n\nä»»ä½•ä¸€ä¸ªæ‹¬å·åºåˆ—éƒ½ä¸€å®šæ˜¯ç”± $\\text{`('}$ å¼€å¤´ï¼Œå¹¶ä¸”ç¬¬ä¸€ä¸ª $\\text{`('}$ ä¸€å®šæœ‰ä¸€ä¸ªå”¯ä¸€ä¸ä¹‹å¯¹åº”çš„ $\\text{`)'}$ã€‚è¿™æ ·ä¸€æ¥ï¼Œæ¯ä¸€ä¸ªæ‹¬å·åºåˆ—å¯ä»¥ç”¨ $(a)b$ æ¥è¡¨ç¤ºï¼Œå…¶ä¸­ $a$ ä¸ $b$ åˆ†åˆ«æ˜¯ä¸€ä¸ªåˆæ³•çš„æ‹¬å·åºåˆ—ï¼ˆå¯ä»¥ä¸ºç©ºï¼‰ã€‚\n\né‚£ä¹ˆï¼Œè¦ç”Ÿæˆæ‰€æœ‰é•¿åº¦ä¸º $2n$ çš„æ‹¬å·åºåˆ—ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå‡½æ•° $\\textit{generate}(n)$ æ¥è¿”å›æ‰€æœ‰å¯èƒ½çš„æ‹¬å·åºåˆ—ã€‚é‚£ä¹ˆåœ¨å‡½æ•° $\\textit{generate}(n)$ çš„è¿‡ç¨‹ä¸­ï¼š\n\n- æˆ‘ä»¬éœ€è¦æšä¸¾ä¸ç¬¬ä¸€ä¸ª $\\text{`('}$ å¯¹åº”çš„ $\\text{`)'}$ çš„ä½ç½® $2i + 1$ï¼›\n- é€’å½’è°ƒç”¨ $\\textit{generate}(i)$ å³å¯è®¡ç®— $a$ çš„æ‰€æœ‰å¯èƒ½æ€§ï¼›\n- é€’å½’è°ƒç”¨ $\\textit{generate}(n - i - 1)$ å³å¯è®¡ç®— $b$ çš„æ‰€æœ‰å¯èƒ½æ€§ï¼›\n- éå† $a$ ä¸ $b$ çš„æ‰€æœ‰å¯èƒ½æ€§å¹¶æ‹¼æ¥ï¼Œå³å¯å¾—åˆ°æ‰€æœ‰é•¿åº¦ä¸º $2n$ çš„æ‹¬å·åºåˆ—ã€‚\n\nä¸ºäº†èŠ‚çœè®¡ç®—æ—¶é—´ï¼Œæˆ‘ä»¬åœ¨æ¯æ¬¡ $\\textit{generate}(i)$ å‡½æ•°è¿”å›ä¹‹å‰ï¼ŒæŠŠè¿”å›å€¼å­˜å‚¨èµ·æ¥ï¼Œä¸‹æ¬¡å†è°ƒç”¨ $\\textit{generate}(i)$ æ—¶å¯ä»¥ç›´æ¥è¿”å›ï¼Œä¸éœ€è¦å†é€’å½’è®¡ç®—ã€‚\n\n```Java [sol3-Java]\nclass Solution {\n    ArrayList[] cache = new ArrayList[100];\n\n    public List<String> generate(int n) {\n        if (cache[n] != null) {\n            return cache[n];\n        }\n        ArrayList<String> ans = new ArrayList<String>();\n        if (n == 0) {\n            ans.add(\"\");\n        } else {\n            for (int c = 0; c < n; ++c) {\n                for (String left: generate(c)) {\n                    for (String right: generate(n - 1 - c)) {\n                        ans.add(\"(\" + left + \")\" + right);\n                    }\n                }\n            }\n        }\n        cache[n] = ans;\n        return ans;\n    }\n\n    public List<String> generateParenthesis(int n) {\n        return generate(n);\n    }\n}\n```\n```Python [sol3-Python3]\nclass Solution:\n    @lru_cache(None)\n    def generateParenthesis(self, n: int) -> List[str]:\n        if n == 0:\n            return ['']\n        ans = []\n        for c in range(n):\n            for left in self.generateParenthesis(c):\n                for right in self.generateParenthesis(n-1-c):\n                    ans.append('({}){}'.format(left, right))\n        return ans\n```\n```C++ [sol3-C++]\nclass Solution {\n    shared_ptr<vector<string>> cache[100] = {nullptr};\npublic:\n    shared_ptr<vector<string>> generate(int n) {\n        if (cache[n] != nullptr)\n            return cache[n];\n        if (n == 0) {\n            cache[0] = shared_ptr<vector<string>>(new vector<string>{\"\"});\n        } else {\n            auto result = shared_ptr<vector<string>>(new vector<string>);\n            for (int i = 0; i != n; ++i) {\n                auto lefts = generate(i);\n                auto rights = generate(n - i - 1);\n                for (const string& left : *lefts)\n                    for (const string& right : *rights)\n                        result -> push_back(\"(\" + left + \")\" + right);\n            }\n            cache[n] = result;\n        }\n        return cache[n];\n    }\n    vector<string> generateParenthesis(int n) {\n        return *generate(n);\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n* æ—¶é—´å¤æ‚åº¦ï¼š$O(\\dfrac{4^n}{\\sqrt{n}})$ï¼Œè¯¥åˆ†æä¸ [æ–¹æ³•äºŒ](#æ–¹æ³•äºŒï¼šå›æº¯æ³•) ç±»ä¼¼ã€‚\n\n* ç©ºé—´å¤æ‚åº¦ï¼š$O(\\dfrac{4^n}{\\sqrt{n}})$ï¼Œæ­¤æ–¹æ³•é™¤ç­”æ¡ˆæ•°ç»„å¤–ï¼Œä¸­é—´è¿‡ç¨‹ä¸­ä¼šå­˜å‚¨ä¸ç­”æ¡ˆæ•°ç»„åŒæ ·æ•°é‡çº§çš„ä¸´æ—¶æ•°ç»„ï¼Œæ˜¯æˆ‘ä»¬æ‰€éœ€è¦çš„ç©ºé—´å¤æ‚åº¦ã€‚"
}