{
	"titleSlug": "FortPu",
	"slug": "cha-ru-shan-chu-he-sui-ji-fang-wen-du-sh-8pqy",
	"url": "https://leetcode-cn.com/problems/FortPu/solution/cha-ru-shan-chu-he-sui-ji-fang-wen-du-sh-8pqy/",
	"content": "#### 方法一：变长数组 + 哈希表\n\n这道题要求实现一个类，满足插入、删除和随机访问元素操作的平均时间复杂度为 $O(1)$。\n\n变长数组可以在 $O(1)$ 的时间内完成随机访问元素操作，但是由于无法在 $O(1)$ 的时间内判断元素是否存在，因此不能在 $O(1)$ 的时间内完成插入和删除操作。哈希表可以在 $O(1)$ 的时间内完成插入和删除操作，但是由于无法根据下标定位到特定元素，因此不能在 $O(1)$ 的时间内完成随机访问元素操作。为了满足插入、删除和随机访问元素操作的时间复杂度都是 $O(1)$，需要将变长数组和哈希表结合，变长数组中存储元素，哈希表中存储每个元素在变长数组中的下标。\n\n插入操作时，首先判断 $\\textit{val}$ 是否在哈希表中，如果已经存在则返回 $\\text{false}$，如果不存在则插入 $\\textit{val}$，操作如下：\n\n1. 在变长数组的末尾添加 $\\textit{val}$；\n\n2. 在添加 $\\textit{val}$ 之前的变长数组长度为 $\\textit{val}$ 所在下标 $\\textit{index}$，将 $\\textit{val}$ 和下标 $\\textit{index}$ 存入哈希表；\n\n3. 返回 $\\text{true}$。\n\n删除操作时，首先判断 $\\textit{val}$ 是否在哈希表中，如果不存在则返回 $\\text{false}$，如果存在则删除 $\\textit{val}$，操作如下：\n\n1. 从哈希表中获得 $\\textit{val}$ 的下标 $\\textit{index}$；\n\n2. 将变长数组的最后一个元素 $\\textit{last}$ 移动到下标 $\\textit{index}$ 处，在哈希表中将 $\\textit{last}$ 的下标更新为 $\\textit{index}$；\n\n3. 在变长数组中删除最后一个元素，在哈希表中删除 $\\textit{val}$；\n\n4. 返回 $\\text{true}$。\n\n删除操作的重点在于将变长数组的最后一个元素移动到待删除元素的下标处，然后删除变长数组的最后一个元素。该操作的时间复杂度是 $O(1)$，且可以保证在删除操作之后变长数组中的所有元素的下标都连续，方便插入操作和随机访问元素操作。\n\n随机访问元素操作时，由于变长数组中的所有元素的下标都连续，因此随机选取一个下标，返回变长数组中该下标处的元素。\n\n```Python [sol1-Python3]\nclass RandomizedSet:\n    def __init__(self):\n        self.nums = []\n        self.indices = {}\n\n    def insert(self, val: int) -> bool:\n        if val in self.indices:\n            return False\n        self.indices[val] = len(self.nums)\n        self.nums.append(val)\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.indices:\n            return False\n        id = self.indices[val]\n        self.nums[id] = self.nums[-1]\n        self.indices[self.nums[id]] = id\n        self.nums.pop()\n        del self.indices[val]\n        return True\n\n    def getRandom(self) -> int:\n        return choice(self.nums)\n```\n\n```Java [sol1-Java]\nclass RandomizedSet {\n    List<Integer> nums;\n    Map<Integer, Integer> indices;\n    Random random;\n\n    public RandomizedSet() {\n        nums = new ArrayList<Integer>();\n        indices = new HashMap<Integer, Integer>();\n        random = new Random();\n    }\n\n    public boolean insert(int val) {\n        if (indices.containsKey(val)) {\n            return false;\n        }\n        int index = nums.size();\n        nums.add(val);\n        indices.put(val, index);\n        return true;\n    }\n\n    public boolean remove(int val) {\n        if (!indices.containsKey(val)) {\n            return false;\n        }\n        int index = indices.get(val);\n        int last = nums.get(nums.size() - 1);\n        nums.set(index, last);\n        indices.put(last, index);\n        nums.remove(nums.size() - 1);\n        indices.remove(val);\n        return true;\n    }\n\n    public int getRandom() {\n        int randomIndex = random.nextInt(nums.size());\n        return nums.get(randomIndex);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class RandomizedSet {\n    IList<int> nums;\n    Dictionary<int, int> indices;\n    Random random;\n\n    public RandomizedSet() {\n        nums = new List<int>();\n        indices = new Dictionary<int, int>();\n        random = new Random();\n    }\n\n    public bool Insert(int val) {\n        if (indices.ContainsKey(val)) {\n            return false;\n        }\n        int index = nums.Count;\n        nums.Add(val);\n        indices.Add(val, index);\n        return true;\n    }\n\n    public bool Remove(int val) {\n        if (!indices.ContainsKey(val)) {\n            return false;\n        }\n        int index = indices[val];\n        int last = nums[nums.Count - 1];\n        nums[index] = last;\n        indices[last] = index;\n        nums.RemoveAt(nums.Count - 1);\n        indices.Remove(val);\n        return true;\n    }\n\n    public int GetRandom() {\n        int randomIndex = random.Next(nums.Count);\n        return nums[randomIndex];\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass RandomizedSet {\npublic:\n    RandomizedSet() {\n        srand((unsigned)time(NULL));\n    }\n    \n    bool insert(int val) {\n        if (indices.count(val)) {\n            return false;\n        }\n        int index = nums.size();\n        nums.emplace_back(val);\n        indices[val] = index;\n        return true;\n    }\n    \n    bool remove(int val) {\n        if (!indices.count(val)) {\n            return false;\n        }\n        int index = indices[val];\n        int last = nums.back();\n        nums[index] = last;\n        indices[last] = index;\n        nums.pop_back();\n        indices.erase(val);\n        return true;\n    }\n    \n    int getRandom() {\n        int randomIndex = rand()%nums.size();\n        return nums[randomIndex];\n    }\nprivate:\n    vector<int> nums;\n    unordered_map<int, int> indices;\n};\n```\n\n```C [sol1-C]\n#define MAX_NUM_SIZE 10001\n\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh; \n} HashItem;\n\nbool findHash(const HashItem ** obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    if (NULL != pEntry) {\n        return true;\n    }\n    return false;\n}\n\nint getHash(const HashItem ** obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    if (NULL == pEntry) {\n        return -1;\n    }\n    return pEntry->val;\n}\n\nvoid insertHash(HashItem ** obj, int key, int val) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    if (NULL != pEntry) {\n        pEntry->val = val;\n    } else {\n        pEntry = (HashItem *)malloc(sizeof(HashItem));\n        pEntry->key = key;\n        pEntry->val = val;\n        HASH_ADD_INT(*obj, key, pEntry);\n    }\n}\n\nbool removeHash(HashItem ** obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    if (NULL != pEntry) {\n        HASH_DEL(*obj, pEntry);  \n        free(pEntry); \n    }\n    return true;\n}\n\nvoid freeHash(HashItem ** obj) {\n    HashItem *curr, *tmp;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);\n    }\n}\n\ntypedef struct {\n    int * nums;\n    int numsSize;\n    HashItem * indices;\n} RandomizedSet;\n\nRandomizedSet* randomizedSetCreate() {\n    srand((unsigned)time(NULL));\n    RandomizedSet * obj = (RandomizedSet *)malloc(sizeof(RandomizedSet));\n    obj->nums = (int *)malloc(sizeof(int) * MAX_NUM_SIZE);\n    obj->numsSize = 0;\n    obj->indices = NULL;\n    return obj;\n}\n\nbool randomizedSetInsert(RandomizedSet* obj, int val) {\n    HashItem *pEntry = NULL;\n    if (findHash(&obj->indices, val)) {\n        return false;\n    }\n    int index = obj->numsSize;\n    obj->nums[obj->numsSize++] = val;\n    insertHash(&obj->indices, val, obj->numsSize - 1);\n    return true;\n}\n\nbool randomizedSetRemove(RandomizedSet* obj, int val) {\n    if (!findHash(&obj->indices, val)) {\n        return false;\n    }\n    int index = getHash(&obj->indices, val);\n    int last = obj->nums[obj->numsSize - 1];\n    obj->nums[index] = last;\n    insertHash(&obj->indices, last, index);\n    obj->numsSize--;\n    removeHash(&obj->indices, val);\n    return true;\n}\n\nint randomizedSetGetRandom(RandomizedSet* obj) {\n    int randomIndex = rand() % obj->numsSize;\n    return obj->nums[randomIndex];\n}\n\nvoid randomizedSetFree(RandomizedSet* obj) {\n    freeHash(&obj->indices);\n    free(obj->nums);\n    free(obj);\n}\n```\n\n```go [sol1-Golang]\ntype RandomizedSet struct {\n    nums    []int\n    indices map[int]int\n}\n\nfunc Constructor() RandomizedSet {\n    return RandomizedSet{[]int{}, map[int]int{}}\n}\n\nfunc (rs *RandomizedSet) Insert(val int) bool {\n    if _, ok := rs.indices[val]; ok {\n        return false\n    }\n    rs.indices[val] = len(rs.nums)\n    rs.nums = append(rs.nums, val)\n    return true\n}\n\nfunc (rs *RandomizedSet) Remove(val int) bool {\n    id, ok := rs.indices[val]\n    if !ok {\n        return false\n    }\n    last := len(rs.nums) - 1\n    rs.nums[id] = rs.nums[last]\n    rs.indices[rs.nums[id]] = id\n    rs.nums = rs.nums[:last]\n    delete(rs.indices, val)\n    return true\n}\n\nfunc (rs *RandomizedSet) GetRandom() int {\n    return rs.nums[rand.Intn(len(rs.nums))]\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar RandomizedSet = function() {\n    this.nums = [];\n    this.indices = new Map();\n};\n\nRandomizedSet.prototype.insert = function(val) {\n    if (this.indices.has(val)) {\n        return false;\n    }\n    let index = this.nums.length;\n    this.nums.push(val);\n    this.indices.set(val, index);\n    return true;\n};\n\nRandomizedSet.prototype.remove = function(val) {\n    if (!this.indices.has(val)) {\n        return false;\n    }\n    let id = this.indices.get(val);\n    this.nums[id] = this.nums[this.nums.length - 1];\n    this.indices.set(this.nums[id], id);\n    this.nums.pop();\n    this.indices.delete(val);\n    return true;\n};\n\nRandomizedSet.prototype.getRandom = function() {\n    const randomIndex = Math.floor(Math.random() * this.nums.length);\n    return this.nums[randomIndex];\n};\n```\n \n**复杂度分析**\n\n- 时间复杂度：初始化和各项操作的时间复杂度都是 $O(1)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是集合中的元素个数。存储元素的数组和哈希表需要 $O(n)$ 的空间。"
}