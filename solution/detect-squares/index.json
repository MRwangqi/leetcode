{
	"titleSlug": "detect-squares",
	"slug": "jian-ce-zheng-fang-xing-by-leetcode-solu-vwzs",
	"url": "https://leetcode-cn.com/problems/detect-squares/solution/jian-ce-zheng-fang-xing-by-leetcode-solu-vwzs/",
	"content": "#### 方法一：哈希表\n\n**思路**\n\n先考虑如何实现 `int count(int[] point)`，记输入的 $\\textit{point}$ 的横纵坐标分别为 $x$ 和 $y$。则形成的正方形的上下两条边中，其中一条边的纵坐标为 $y$， 我们枚举另一条边的纵坐标为 $col$，则正方形的边长 $d$ 为 $|y - col|$ 且大于 $0$。有了其中一个点的坐标 $(x, y)$ 和一条横边的纵坐标 $col$，我们可以得到正方形的四个点的坐标分别为 $(x, y)$，$(x, col)$，$(x+d, y)$，$(x+d, col)$ 或 $(x, y)$，$(x, col)$，$(x-d, y)$，$(x-d, col)$。\n\n据此，我们可以用一个哈希表来存储 `void add(int[] point)` 函数中加入的点。先把点按照行来划分，键为行的纵坐标，值为另一个哈希表，其中键为该行中的点的横坐标，值为这样的点的个数。因为点会重复出现，所以计算正方形的个数时需要把另外三个坐标出现的次数相乘。\n\n**代码**\n\n```Python [sol1-Python3]\nclass DetectSquares:\n\n    def __init__(self):\n        self.map = defaultdict(Counter)\n\n    def add(self, point: List[int]) -> None:\n        x, y = point\n        self.map[y][x] += 1\n\n    def count(self, point: List[int]) -> int:\n        res = 0\n        x, y = point\n\n        if not y in self.map:\n            return 0\n        yCnt = self.map[y]\n\n        for col, colCnt in self.map.items():\n            if col != y:\n                # 根据对称性，这里可以不用取绝对值\n                d = col - y\n                res += colCnt[x] * yCnt[x + d] * colCnt[x + d]\n                res += colCnt[x] * yCnt[x - d] * colCnt[x - d]\n        \n        return res\n```\n\n```Java [sol1-Java]\nclass DetectSquares {\n    Map<Integer, Map<Integer, Integer>> cnt;\n\n    public DetectSquares() {\n        cnt = new HashMap<Integer, Map<Integer, Integer>>();\n    }\n\n    public void add(int[] point) {\n        int x = point[0], y = point[1];\n        cnt.putIfAbsent(y, new HashMap<Integer, Integer>());\n        Map<Integer, Integer> yCnt = cnt.get(y);\n        yCnt.put(x, yCnt.getOrDefault(x, 0) + 1);\n    }\n\n    public int count(int[] point) {\n        int res = 0;\n        int x = point[0], y = point[1];\n        if (!cnt.containsKey(y)) {\n            return 0;\n        }\n        Map<Integer, Integer> yCnt = cnt.get(y);\n        Set<Map.Entry<Integer, Map<Integer, Integer>>> entries = cnt.entrySet();\n        for (Map.Entry<Integer, Map<Integer, Integer>> entry : entries) {\n            int col = entry.getKey();\n            Map<Integer, Integer> colCnt = entry.getValue();\n            if (col != y) {\n                // 根据对称性，这里可以不用取绝对值\n                int d = col - y;\n                res += colCnt.getOrDefault(x, 0) * yCnt.getOrDefault(x + d, 0) * colCnt.getOrDefault(x + d, 0);\n                res += colCnt.getOrDefault(x, 0) * yCnt.getOrDefault(x - d, 0) * colCnt.getOrDefault(x - d, 0);\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class DetectSquares {\n    Dictionary<int, Dictionary<int, int>> cnt;\n\n    public DetectSquares() {\n        cnt = new Dictionary<int, Dictionary<int, int>>();\n    }\n\n    public void Add(int[] point) {\n        int x = point[0], y = point[1];\n        if (!cnt.ContainsKey(y)) {\n            cnt.Add(y, new Dictionary<int, int>());\n        }\n        Dictionary<int, int> yCnt = cnt[y];\n        if (!yCnt.ContainsKey(x)) {\n            yCnt.Add(x, 0);\n        }\n        yCnt[x]++;\n    }\n\n    public int Count(int[] point) {\n        int res = 0;\n        int x = point[0], y = point[1];\n        if (!cnt.ContainsKey(y)) {\n            return 0;\n        }\n        Dictionary<int, int> yCnt = cnt[y];\n        foreach(KeyValuePair<int, Dictionary<int, int>> pair in cnt) {\n            int col = pair.Key;\n            Dictionary<int, int> colCnt = pair.Value;\n            if (col != y) {\n                // 根据对称性，这里可以不用取绝对值\n                int d = col - y;\n                int cnt1 = colCnt.ContainsKey(x) ? colCnt[x] : 0;\n                int cnt2 = colCnt.ContainsKey(x + d) ? colCnt[x + d] : 0;\n                int cnt3 = colCnt.ContainsKey(x - d) ? colCnt[x - d] : 0;\n                res += (colCnt.ContainsKey(x) ? colCnt[x] : 0) * (yCnt.ContainsKey(x + d) ? yCnt[x + d] : 0) * (colCnt.ContainsKey(x + d) ? colCnt[x + d] : 0);\n                res += (colCnt.ContainsKey(x) ? colCnt[x] : 0) * (yCnt.ContainsKey(x - d) ? yCnt[x - d] : 0) * (colCnt.ContainsKey(x - d) ? colCnt[x - d] : 0);\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass DetectSquares {\npublic:\n    unordered_map<int, unordered_map<int, int>> cnt;\n    DetectSquares() {\n\n    }\n    \n    void add(vector<int> point) {\n        int x = point[0], y = point[1];\n        cnt[y][x]++;\n    }\n    \n    int count(vector<int> point) {\n        int res = 0;\n        int x = point[0], y = point[1];\n        if (!cnt.count(y)) {\n            return 0;\n        }\n        unordered_map<int, int> & yCnt = cnt[y];\n        for (auto & [col, colCnt] : cnt) {\n            if (col != y) {\n                // 根据对称性，这里可以不用取绝对值\n                int d = col - y;\n                res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x + d) ? yCnt[x + d] : 0) * \n                       (colCnt.count(x + d)? colCnt[x + d] : 0);\n                res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x - d) ? yCnt[x - d] : 0) * \n                       (colCnt.count(x - d) ? colCnt[x - d] : 0);\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key; \n    int val;\n    UT_hash_handle hh;         \n} HashMapEntry;\n\ntypedef struct {\n    int key;\n    HashMapEntry * obj;\n    UT_hash_handle hh;     \n} HashMapDictEntry;\n\nint hashMapGetVal(const HashMapEntry ** obj, int key) {\n    HashMapEntry * pEntry = NULL;\n    HASH_FIND(hh, *obj, &key, sizeof(int), pEntry);\n    if (NULL == pEntry) {\n        return 0;\n    }\n    return pEntry->val;\n}\n\nvoid hashMapFree(HashMapEntry ** obj) {\n    HashMapEntry *curr = NULL, *next = NULL;\n    HASH_ITER(hh, *obj, curr, next)\n    {\n        HASH_DEL(*obj, curr);  \n        free(curr);      \n    }\n}\n\ntypedef struct {\n    HashMapDictEntry * dict;\n} DetectSquares;\n\nDetectSquares* detectSquaresCreate() {\n    DetectSquares * obj = (DetectSquares *)malloc(sizeof(DetectSquares));\n    obj->dict = NULL;\n    return obj;\n}\n\nvoid detectSquaresAdd(DetectSquares* obj, int* point, int pointSize) {\n    int x = point[0], y = point[1];\n    HashMapDictEntry * pEntry = NULL;\n    HashMapEntry * pItemEntry = NULL;\n    \n    HASH_FIND(hh, obj->dict, &y, sizeof(int), pEntry);\n    if (NULL == pEntry) {\n        pItemEntry = (HashMapEntry *)malloc(sizeof(HashMapEntry));\n        pItemEntry->key = x;\n        pItemEntry->val = 1;\n        pEntry = (HashMapDictEntry *)malloc(sizeof(HashMapDictEntry));\n        pEntry->key = y;\n        pEntry->obj = NULL;\n        HASH_ADD(hh, pEntry->obj, key, sizeof(int), pItemEntry);\n        HASH_ADD(hh, obj->dict, key, sizeof(int), pEntry);\n    } else {\n        HASH_FIND(hh, pEntry->obj, &x, sizeof(int), pItemEntry);\n        if (NULL == pItemEntry) {\n            pItemEntry = (HashMapEntry *)malloc(sizeof(HashMapEntry));\n            pItemEntry->key = x;\n            pItemEntry->val = 1;\n            HASH_ADD(hh, pEntry->obj, key, sizeof(int), pItemEntry);\n        } else {\n            pItemEntry->val++;\n        }\n    }\n}\n\nint detectSquaresCount(DetectSquares* obj, int* point, int pointSize) {\n    int res = 0;\n    int x = point[0], y = point[1];\n    HashMapDictEntry * pEntry = NULL;\n    HashMapEntry * yCnt = NULL;\n    HASH_FIND(hh, obj->dict, &y, sizeof(int), pEntry);\n    if (NULL == pEntry) {\n        return 0;\n    }\n    yCnt = pEntry->obj;\n    HashMapDictEntry *curr = NULL, *next = NULL;\n    HASH_ITER(hh, obj->dict, curr, next) {\n        int col = curr->key;\n        HashMapEntry * colCnt = curr->obj;\n        if (col != y) {\n            // 根据对称性，这里可以不用取绝对值\n            int d = col - y;\n            res += hashMapGetVal(&colCnt, x) * hashMapGetVal(&yCnt, x + d) * hashMapGetVal(&colCnt, x + d);\n            res += hashMapGetVal(&colCnt, x) * hashMapGetVal(&yCnt, x - d) * hashMapGetVal(&colCnt, x - d);\n        }   \n    }\n    return res;\n}\n\nvoid detectSquaresFree(DetectSquares* obj) {\n    HashMapDictEntry *curr = NULL, *next = NULL;\n    HASH_ITER(hh, obj->dict, curr, next)\n    {\n        hashMapFree(&(curr->obj));\n        HASH_DEL(obj->dict, curr); \n        free(curr);      \n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar DetectSquares = function() {\n    this.cnt = new Map();\n};\n\nDetectSquares.prototype.add = function(point) {\n    const x = point[0], y = point[1];\n    if (!this.cnt.has(y)) {\n        this.cnt.set(y, new Map());\n    }\n    const yCnt = this.cnt.get(y);\n    yCnt.set(x, (yCnt.get(x) || 0) + 1);\n};\n\nDetectSquares.prototype.count = function(point) {\n    let res = 0;\n    let x = point[0], y = point[1];\n    if (!this.cnt.has(y)) {\n        return 0;\n    }\n    const yCnt = this.cnt.get(y);\n    const entries = this.cnt.entries();\n    for (const [col, colCnt] of entries) {\n        if (col !== y) {\n            // 根据对称性，这里可以不用取绝对值\n            let d = col - y;\n            res += (colCnt.get(x) || 0) * (yCnt.get(x + d) || 0) * (colCnt.get(x + d) || 0);\n            res += (colCnt.get(x) || 0) * (yCnt.get(x - d) || 0) * (colCnt.get(x - d) || 0);\n        }\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\ntype DetectSquares map[int]map[int]int\n\nfunc Constructor() DetectSquares {\n    return DetectSquares{}\n}\n\nfunc (s DetectSquares) Add(point []int) {\n    x, y := point[0], point[1]\n    if s[y] == nil {\n        s[y] = map[int]int{}\n    }\n    s[y][x]++\n}\n\nfunc (s DetectSquares) Count(point []int) (ans int) {\n    x, y := point[0], point[1]\n    if s[y] == nil {\n        return\n    }\n    yCnt := s[y]\n    for col, colCnt := range s {\n        if col != y {\n            // 根据对称性，这里可以不用取绝对值\n            d := col - y\n            ans += colCnt[x] * yCnt[x+d] * colCnt[x+d]\n            ans += colCnt[x] * yCnt[x-d] * colCnt[x-d]\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：`DetectSquares()` 消耗 $O(1)$ 时间复杂度，`void add(int[] point)` 消耗 $O(1)$ 时间复杂度，`int count(int[] point)` 消耗 $O(n)$ 时间复杂度，其中 $n$ 为 `void add(int[] point)` 已经调用的次数。\n\n- 空间复杂度：`DetectSquares()` 消耗 $O(1)$ 空间复杂度，`void add(int[] point)` 消耗 $O(1)$ 空间复杂度，`int count(int[] point)` 消耗 $O(1)$ 空间复杂度。"
}