{
	"titleSlug": "longest-cycle-in-a-graph",
	"slug": "nei-xiang-ji-huan-shu-zhao-huan-li-yong-pmqmr",
	"url": "https://leetcode-cn.com/problems/longest-cycle-in-a-graph/solution/nei-xiang-ji-huan-shu-zhao-huan-li-yong-pmqmr/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1Ba411N78j) 已出炉，包含**思考题**的讲解，欢迎点赞三连，在评论区分享你对这场周赛的看法~\r\n\r\n---\r\n\r\n对于**内向基环树**的概念和性质，我之前在 [2127. 参加会议的最多员工数](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/) 的题解中作了详细介绍，本文不再赘述（把我那篇题解的代码拿来改一改就能过）。\r\n\r\n除了使用那篇题解中的通用做法（拓扑排序）外，我们还可以利用**时间戳**来实现找环的逻辑。\r\n\r\n具体来说，初始时间戳 $\\textit{clock}=1$，首次访问一个点 $x$ 时，记录访问这个点的时间 $\\textit{time}[x]=\\textit{clock}$，然后将 $\\textit{clock}$ 加一。\r\n\r\n如果首次访问一个点，则记录当前时间 $\\textit{startTime}=\\textit{clock}$，并尝试从这个点出发，看能否找到环。如果找到了一个之前访问过的点 $x$，且之前访问 $x$ 的时间不早于 $\\textit{startTime}$，则说明我们找到了一个**新的**环，此时的环长就是前后两次访问 $x$ 的时间差，即 $\\textit{clock}-\\textit{time}[x]$。\r\n\r\n取所有环长的最大值作为答案。若没有找到环，则返回 $-1$。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{edges}$ 的长度。\r\n- 空间复杂度：$O(n)$。\r\n\r\n#### 思考题\r\n\r\n如果题目要你返回最长环上的所有节点呢？（见 [视频讲解](https://www.bilibili.com/video/BV1Ba411N78j)）\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def longestCycle(self, edges: List[int]) -> int:\r\n        time = [0] * len(edges)\r\n        clock, ans = 1, -1\r\n        for x, t in enumerate(time):\r\n            if t: continue\r\n            start_time = clock\r\n            while x >= 0:\r\n                if time[x]:  # 重复访问\r\n                    if time[x] >= start_time:  # 找到了一个新的环\r\n                        ans = max(ans, clock - time[x])\r\n                    break\r\n                time[x] = clock\r\n                clock += 1\r\n                x = edges[x]\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int longestCycle(int[] edges) {\r\n        int n = edges.length, ans = -1;\r\n        var time = new int[n];\r\n        for (int i = 0, clock = 1; i < n; ++i) {\r\n            if (time[i] > 0) continue;\r\n            for (int x = i, startTime = clock; x >= 0; x = edges[x]) {\r\n                if (time[x] > 0) { // 重复访问\r\n                    if (time[x] >= startTime) // 找到了一个新的环\r\n                        ans = Math.max(ans, clock - time[x]);\r\n                    break;\r\n                }\r\n                time[x] = clock++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int longestCycle(vector<int> &edges) {\r\n        int n = edges.size(), time[n], ans = -1;\r\n        memset(time, 0, sizeof(time));\r\n        for (int i = 0, clock = 1; i < n; ++i) {\r\n            if (time[i]) continue;\r\n            for (int x = i, start_time = clock; x >= 0; x = edges[x]) {\r\n                if (time[x]) { // 重复访问\r\n                    if (time[x] >= start_time) // 找到了一个新的环\r\n                        ans = max(ans, clock - time[x]);\r\n                    break;\r\n                }\r\n                time[x] = clock++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc longestCycle(edges []int) int {\r\n\ttime := make([]int, len(edges))\r\n\tclock, ans := 1, -1\r\n\tfor x, t := range time {\r\n\t\tif t > 0 {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tfor startTime := clock; x >= 0; x = edges[x] {\r\n\t\t\tif time[x] > 0 { // 重复访问\r\n\t\t\t\tif time[x] >= startTime { // 找到了一个新的环\r\n\t\t\t\t\tans = max(ans, clock-time[x])\r\n\t\t\t\t}\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\ttime[x] = clock\r\n\t\t\tclock++\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n"
}