{
	"titleSlug": "count-nice-pairs-in-an-array",
	"slug": "onjie-by-yxj33-mgj8",
	"url": "https://leetcode-cn.com/problems/count-nice-pairs-in-an-array/solution/onjie-by-yxj33-mgj8/",
	"content": "由题好对子$nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])$\r\n则有$nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])$\r\n则可统计$nums[i] - rev(nums[i])$各值的出现次数，对于$nums[i] - rev(nums[i])$值相等的序号i和j，两两组合即为所求\r\n而假设$nums[i] - rev(nums[i])$的值出现的次数为k次，则两两组合数共k*(k-1)/2个好对子\r\n```java\r\nclass Solution {\r\n    public int countNicePairs(int[] nums) {\r\n        //nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])\r\n        //nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])\r\n        int mod = (int)1e9+7;\r\n        Map<Integer ,Integer> count = new HashMap<>();\r\n        for (int i = 0; i < nums.length ; i++) {\r\n            int key = nums[i] -rev(nums[i]);\r\n            count.put(key ,count.getOrDefault(key,0)+1);\r\n        }\r\n        long result = 0;\r\n        for (int key : count.keySet()) {\r\n            long times = count.get(key); //long，因为1 <= nums.length <= 10^5,int时time*(time-1)会溢出\r\n            result = (result + (times)*(times-1)/2)%mod;\r\n        }\r\n        return (int) (result%mod);\r\n    }\r\n\r\n    private static int rev(int num){\r\n        int result = 0;\r\n        while (num > 0){\r\n            int dig = num % 10;\r\n            result = result*10 + dig;\r\n            num /=10;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n"
}