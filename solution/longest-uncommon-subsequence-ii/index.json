{
	"titleSlug": "longest-uncommon-subsequence-ii",
	"slug": "zui-chang-te-shu-xu-lie-ii-by-leetcode-s-bo2e",
	"url": "https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii/solution/zui-chang-te-shu-xu-lie-ii-by-leetcode-s-bo2e/",
	"content": "#### 方法一：枚举每个字符串\n\n**思路与算法**\n\n对于给定的某个字符串 $\\textit{str}[i]$，如果它的一个子序列 $\\textit{sub}$ 是「特殊序列」，那么 $\\textit{str}[i]$ 本身也是一个「特殊序列」。\n\n> 这是因为如果 $\\textit{sub}$ 如果没有在除了 $\\textit{str}[i]$ 之外的字符串中以子序列的形式出现过，那么给 $\\textit{sub}$ 不断地添加字符，它也不会出现。而 $\\textit{str}[i]$ 就是 $\\textit{sub}$ 添加若干个（可以为零个）字符得到的结果。\n\n因此我们只需要使用一个双重循环，外层枚举每一个字符串 $\\textit{str}[i]$ 作为特殊序列，内层枚举每一个字符串 $\\textit{str}[j]~(i \\neq j)$，判断 $\\textit{str}[i]$ 是否不为 $\\textit{str}[j]$ 的子序列即可。\n\n要想判断 $\\textit{str}[i]$ 是否为 $\\textit{str}[j]$ 的子序列，我们可以使用贪心 + 双指针的方法：即初始时指针 $\\textit{pt}_i$ 和 $\\textit{pt}_j$ 分别指向两个字符串的首字符。如果两个字符相同，那么两个指针都往右移动一个位置，表示匹配成功；否则只往右移动指针 $\\textit{pt}_j$，表示匹配失败。如果 $\\textit{pt}_i$ 遍历完了整个字符串，就说明 $\\textit{str}[i]$ 是 $\\textit{str}[j]$ 的子序列。\n\n在所有满足要求的 $\\textit{str}[i]$ 中，我们选出最长的那个，返回其长度作为答案。如果不存在满足要求的字符串，那么返回 $-1$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findLUSlength(vector<string>& strs) {\n        auto is_subseq = [](const string& s, const string& t) -> bool {\n            int pt_s = 0, pt_t = 0;\n            while (pt_s < s.size() && pt_t < t.size()) {\n                if (s[pt_s] == t[pt_t]) {\n                    ++pt_s;\n                }\n                ++pt_t;\n            }\n            return pt_s == s.size();\n        };\n\n        int n = strs.size();\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            bool check = true;\n            for (int j = 0; j < n; ++j) {\n                if (i != j && is_subseq(strs[i], strs[j])) {\n                    check = false;\n                    break;\n                }\n            }\n            if (check) {\n                ans = max(ans, static_cast<int>(strs[i].size()));\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findLUSlength(String[] strs) {\n        int n = strs.length;\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            boolean check = true;\n            for (int j = 0; j < n; ++j) {\n                if (i != j && isSubseq(strs[i], strs[j])) {\n                    check = false;\n                    break;\n                }\n            }\n            if (check) {\n                ans = Math.max(ans, strs[i].length());\n            }\n        }\n        return ans;\n    }\n\n    public boolean isSubseq(String s, String t) {\n        int ptS = 0, ptT = 0;\n        while (ptS < s.length() && ptT < t.length()) {\n            if (s.charAt(ptS) == t.charAt(ptT)) {\n                ++ptS;\n            }\n            ++ptT;\n        }\n        return ptS == s.length();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindLUSlength(string[] strs) {\n        int n = strs.Length;\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            bool check = true;\n            for (int j = 0; j < n; ++j) {\n                if (i != j && IsSubseq(strs[i], strs[j])) {\n                    check = false;\n                    break;\n                }\n            }\n            if (check) {\n                ans = Math.Max(ans, strs[i].Length);\n            }\n        }\n        return ans;\n    }\n\n    public bool IsSubseq(string s, string t) {\n        int ptS = 0, ptT = 0;\n        while (ptS < s.Length && ptT < t.Length) {\n            if (s[ptS] == t[ptT]) {\n                ++ptS;\n            }\n            ++ptT;\n        }\n        return ptS == s.Length;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def findLUSlength(self, strs: List[str]) -> int:\n        def is_subseq(s: str, t: str) -> bool:\n            pt_s = pt_t = 0\n            while pt_s < len(s) and pt_t < len(t):\n                if s[pt_s] == t[pt_t]:\n                    pt_s += 1\n                pt_t += 1\n            return pt_s == len(s)\n        \n        ans = -1\n        for i, s in enumerate(strs):\n            check = True\n            for j, t in enumerate(strs):\n                if i != j and is_subseq(s, t):\n                    check = False\n                    break\n            if check:\n                ans = max(ans, len(s))\n        \n        return ans\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nbool is_subseq(const char *s, const char *t) {\n    int pt_s = 0, pt_t = 0;\n    int len_s = strlen(s), len_t = strlen(t);\n    while (pt_s < len_s && pt_t < len_t) {\n        if (s[pt_s] == t[pt_t]) {\n            ++pt_s;\n        }\n        ++pt_t;\n    }\n    return pt_s == len_s;\n}\n\nint findLUSlength(char ** strs, int strsSize){\n    int ans = -1;\n    for (int i = 0; i < strsSize; ++i) {\n        bool check = true;\n        for (int j = 0; j < strsSize; ++j) {\n            if (i != j && is_subseq(strs[i], strs[j])) {\n                check = false;\n                break;\n            }\n        }\n        if (check) {\n            ans = MAX(ans, (int)strlen(strs[i]));\n        }\n    }\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc isSubseq(s, t string) bool {\n    ptS := 0\n    for ptT := range t {\n        if s[ptS] == t[ptT] {\n            if ptS++; ptS == len(s) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nfunc findLUSlength(strs []string) int {\n    ans := -1\nnext:\n    for i, s := range strs {\n        for j, t := range strs {\n            if i != j && isSubseq(s, t) {\n                continue next\n            }\n        }\n        if len(s) > ans {\n            ans = len(s)\n        }\n    }\n    return ans\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findLUSlength = function(strs) {\n    const n = strs.length;\n    let ans = -1;\n    for (let i = 0; i < n; ++i) {\n        let check = true;\n        for (let j = 0; j < n; ++j) {\n            if (i !== j && isSubseq(strs[i], strs[j])) {\n                check = false;\n                break;\n            }\n        }\n        if (check) {\n            ans = Math.max(ans, strs[i].length);\n        }\n    }\n    return ans;\n};\n\nconst isSubseq = (s, t) => {\n    let ptS = 0, ptT = 0;\n    while (ptS < s.length && ptT < t.length) {\n        if (s[ptS] === t[ptT]) {\n            ++ptS;\n        }\n        ++ptT;\n    }\n    return ptS === s.length;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2 \\cdot l)$，其中 $n$ 是数组 $\\textit{strs}$ 的长度，$l$ 是字符串的平均长度。\n\n- 空间复杂度：$O(1)$。"
}