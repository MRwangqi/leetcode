{
	"titleSlug": "unique-substrings-in-wraparound-string",
	"slug": "huan-rao-zi-fu-chuan-zhong-wei-yi-de-zi-ndvea",
	"url": "https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/solution/huan-rao-zi-fu-chuan-zhong-wei-yi-de-zi-ndvea/",
	"content": "#### 方法一：动态规划\n\n由于 $s$ 是周期字符串，对于在 $s$ 中的子串，只要知道子串的第一个字符（或最后一个字符）和子串长度，就能确定这个子串。例如子串以 $\\text{`d'}$ 结尾，长度为 $3$，那么该子串为 $\\text{``bcd''}$。\n\n题目要求不同的子串个数，那么对于两个以同一个字符结尾的子串，长的那个子串必然包含短的那个。例如 $\\text{``abcd''}$ 和 $\\text{``bcd''}$ 均以 $\\text{`d'}$ 结尾，$\\text{``bcd''}$ 是 $\\text{``abcd''}$ 的子串。\n\n据此，我们可以定义 $\\textit{dp}[\\alpha]$ 表示 $p$ 中以字符 $\\alpha$ 结尾且在 $s$ 中的子串的最长长度，知道了最长长度，也就知道了不同的子串的个数。\n\n如何计算 $\\textit{dp}[\\alpha]$ 呢？我们可以在遍历 $p$ 时，维护连续递增的子串长度 $k$。具体来说，遍历到 $p[i]$ 时，如果 $p[i]$ 是 $p[i-1]$ 在字母表中的下一个字母，则将 $k$ 加一，否则将 $k$ 置为 $1$，表示重新开始计算连续递增的子串长度。然后，用 $k$ 更新 $\\textit{dp}[p[i]]$ 的最大值。\n\n遍历结束后，$p$ 中以字符 $c$ 结尾且在 $s$ 中的子串有 $\\textit{dp}[c]$ 个。例如 $\\textit{dp}[\\text{`d'}]=3$ 表示子串 $\\text{``bcd''}$、$\\text{``cd''}$ 和 $\\text{``d''}$。\n\n最后答案为 \n\n$$\n\\sum_{\\alpha=\\text{`a'}}^{\\text{`z'}}\\textit{dp}[\\alpha]\n$$\n\n```Python [sol1-Python3]\nclass Solution:\n    def findSubstringInWraproundString(self, p: str) -> int:\n        dp = defaultdict(int)\n        k = 0\n        for i, ch in enumerate(p):\n            if i > 0 and (ord(ch) - ord(p[i - 1])) % 26 == 1:  # 字符之差为 1 或 -25\n                k += 1\n            else:\n                k = 1\n            dp[ch] = max(dp[ch], k)\n        return sum(dp.values())\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findSubstringInWraproundString(string p) {\n        vector<int> dp(26);\n        int k = 0;\n        for (int i = 0; i < p.length(); ++i) {\n            if (i && (p[i] - p[i - 1] + 26) % 26 == 1) { // 字符之差为 1 或 -25\n                ++k;\n            } else {\n                k = 1;\n            }\n            dp[p[i] - 'a'] = max(dp[p[i] - 'a'], k);\n        }\n        return accumulate(dp.begin(), dp.end(), 0);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findSubstringInWraproundString(String p) {\n        int[] dp = new int[26];\n        int k = 0;\n        for (int i = 0; i < p.length(); ++i) {\n            if (i > 0 && (p.charAt(i) - p.charAt(i - 1) + 26) % 26 == 1) { // 字符之差为 1 或 -25\n                ++k;\n            } else {\n                k = 1;\n            }\n            dp[p.charAt(i) - 'a'] = Math.max(dp[p.charAt(i) - 'a'], k);\n        }\n        return Arrays.stream(dp).sum();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindSubstringInWraproundString(string p) {\n        int[] dp = new int[26];\n        int k = 0;\n        for (int i = 0; i < p.Length; ++i) {\n            if (i > 0 && (p[i] - p[i - 1] + 26) % 26 == 1) { // 字符之差为 1 或 -25\n                ++k;\n            } else {\n                k = 1;\n            }\n            dp[p[i] - 'a'] = Math.Max(dp[p[i] - 'a'], k);\n        }\n        return dp.Sum();\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc findSubstringInWraproundString(p string) (ans int) {\n    dp := [26]int{}\n    k := 0\n    for i, ch := range p {\n        if i > 0 && (byte(ch)-p[i-1]+26)%26 == 1 { // 字符之差为 1 或 -25\n            k++\n        } else {\n            k = 1\n        }\n        dp[ch-'a'] = max(dp[ch-'a'], k)\n    }\n    for _, v := range dp {\n        ans += v\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint findSubstringInWraproundString(char * p) {\n    int dp[26];\n    int len = strlen(p);\n    memset(dp, 0, sizeof(dp));\n    int k = 0;\n    for (int i = 0; i < len; ++i) {\n        if (i && (p[i] - p[i - 1] + 26) % 26 == 1) { // 字符之差为 1 或 -25\n            ++k;\n        } else {\n            k = 1;\n        }\n        dp[p[i] - 'a'] = MAX(dp[p[i] - 'a'], k);\n    }\n    int res = 0;\n    for (int i = 0; i < 26; i++) {\n        res += dp[i];\n    }\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findSubstringInWraproundString = function(p) {\n    const dp = new Array(26).fill(0);\n    let k = 0;\n    for (let i = 0; i < p.length; ++i) {\n        if (i > 0 && (p[i].charCodeAt() - p[i - 1].charCodeAt() + 26) % 26 === 1) { // 字符之差为 1 或 -25\n            ++k;\n        } else {\n            k = 1;\n        }\n        dp[p[i].charCodeAt() - 'a'.charCodeAt()] = Math.max(dp[p[i].charCodeAt() - 'a'.charCodeAt()], k);\n    }\n    return _.sum(dp);\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $p$ 的长度。\n\n- 空间复杂度：$O(|\\Sigma|)$，其中 $|\\Sigma|$ 为字符集合的大小，本题中字符均为小写字母，故 $|\\Sigma|=26$。"
}