{
	"titleSlug": "array-nesting",
	"slug": "shu-zu-qian-tao-by-leetcode-solution-7ur3",
	"url": "https://leetcode-cn.com/problems/array-nesting/solution/shu-zu-qian-tao-by-leetcode-solution-7ur3/",
	"content": "#### 方法一：图\n\n遍历数组，从 $i$ 向 $\\textit{nums}[i]$ 连边，我们可以得到一张有向图。\n\n由于题目保证 $\\textit{nums}$ 中不含有重复的元素，因此有向图中每个点的出度和入度均为 $1$。\n\n在这种情况下，有向图必然由一个或多个环组成。我们可以遍历 $\\textit{nums}$，找到节点个数最大的环。\n\n代码实现时需要用一个 $\\textit{vis}$ 数组来标记访问过的节点。\n\n```Python [sol1-Python3]\nclass Solution:\n    def arrayNesting(self, nums: List[int]) -> int:\n        ans, n = 0, len(nums)\n        vis = [False] * n\n        for i in range(n):\n            cnt = 0\n            while not vis[i]:\n                vis[i] = True\n                i = nums[i]\n                cnt += 1\n            ans = max(ans, cnt)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int arrayNesting(vector<int> &nums) {\n        int ans = 0, n = nums.size();\n        vector<int> vis(n);\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            while (!vis[i]) {\n                vis[i] = true;\n                i = nums[i];\n                ++cnt;\n            }\n            ans = max(ans, cnt);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int arrayNesting(int[] nums) {\n        int ans = 0, n = nums.length;\n        boolean[] vis = new boolean[n];\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            while (!vis[i]) {\n                vis[i] = true;\n                i = nums[i];\n                ++cnt;\n            }\n            ans = Math.max(ans, cnt);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int ArrayNesting(int[] nums) {\n        int ans = 0, n = nums.Length;\n        bool[] vis = new bool[n];\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            while (!vis[i]) {\n                vis[i] = true;\n                i = nums[i];\n                ++cnt;\n            }\n            ans = Math.Max(ans, cnt);\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc arrayNesting(nums []int) (ans int) {\n    vis := make([]bool, len(nums))\n    for i := range vis {\n        cnt := 0\n        for !vis[i] {\n            vis[i] = true\n            i = nums[i]\n            cnt++\n        }\n        if cnt > ans {\n            ans = cnt\n        }\n    }\n    return\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint arrayNesting(int* nums, int numsSize){\n    int ans = 0;\n    bool *vis = (bool *)malloc(sizeof(bool) * numsSize);\n    memset(vis, 0, sizeof(bool) * numsSize);\n    for (int i = 0; i < numsSize; ++i) {\n        int cnt = 0;\n        while (!vis[i]) {\n            vis[i] = true;\n            i = nums[i];\n            ++cnt;\n        }\n        ans = MAX(ans, cnt);\n    }\n    free(vis);\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar arrayNesting = function(nums) {\n    let ans = 0, n = nums.length;\n    const vis = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        let cnt = 0;\n        while (!vis[i]) {\n            vis[i] = true;\n            i = nums[i];\n            ++cnt;\n        }\n        ans = Math.max(ans, cnt);\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(n)$。\n\n#### 方法二：原地标记\n\n利用「$\\textit{nums}$ 中的元素大小在 $[0, n-1]$ 之间」这一条件，我们可以省略 $\\textit{vis}$ 数组，改为标记 $\\textit{nums}[i] = n$，来实现和 $\\textit{vis}$ 数组同样的功能。\n\n```Python [sol2-Python3]\nclass Solution:\n    def arrayNesting(self, nums: List[int]) -> int:\n        ans, n = 0, len(nums)\n        for i in range(n):\n            cnt = 0\n            while nums[i] < n:\n                num = nums[i]\n                nums[i] = n\n                i = num\n                cnt += 1\n            ans = max(ans, cnt)\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int arrayNesting(vector<int> &nums) {\n        int ans = 0, n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            while (nums[i] < n) {\n                int num = nums[i];\n                nums[i] = n;\n                i = num;\n                ++cnt;\n            }\n            ans = max(ans, cnt);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int arrayNesting(int[] nums) {\n        int ans = 0, n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            while (nums[i] < n) {\n                int num = nums[i];\n                nums[i] = n;\n                i = num;\n                ++cnt;\n            }\n            ans = Math.max(ans, cnt);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int ArrayNesting(int[] nums) {\n        int ans = 0, n = nums.Length;\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            while (nums[i] < n) {\n                int num = nums[i];\n                nums[i] = n;\n                i = num;\n                ++cnt;\n            }\n            ans = Math.Max(ans, cnt);\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc arrayNesting(nums []int) (ans int) {\n    n := len(nums)\n    for i := range nums {\n        cnt := 0\n        for nums[i] < n {\n            i, nums[i] = nums[i], n\n            cnt++\n        }\n        if cnt > ans {\n            ans = cnt\n        }\n    }\n    return\n}\n```\n\n```C [sol2-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint arrayNesting(int* nums, int numsSize){\n    int ans = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        int cnt = 0;\n        while (nums[i] < numsSize) {\n            int num = nums[i];\n            nums[i] = numsSize;\n            i = num;\n            ++cnt;\n        }\n        ans = MAX(ans, cnt);\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar arrayNesting = function(nums) {\n    let ans = 0, n = nums.length;\n    for (let i = 0; i < n; ++i) {\n        let cnt = 0;\n        while (nums[i] < n) {\n            const num = nums[i];\n            nums[i] = n;\n            i = num;\n            ++cnt;\n        }\n        ans = Math.max(ans, cnt);\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(1)$，我们只需要常数的空间保存若干变量。"
}