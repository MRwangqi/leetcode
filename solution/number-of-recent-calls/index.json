{
	"titleSlug": "number-of-recent-calls",
	"slug": "zui-jin-de-qing-qiu-ci-shu-by-leetcode-s-ncm1",
	"url": "https://leetcode-cn.com/problems/number-of-recent-calls/solution/zui-jin-de-qing-qiu-ci-shu-by-leetcode-s-ncm1/",
	"content": "#### 方法一：队列\n\n我们可以用一个队列维护发生请求的时间，当在时间 $t$ 收到请求时，将时间 $t$ 入队。\n\n由于每次收到的请求的时间都比之前的大，因此从队首到队尾的时间值是单调递增的。当在时间 $t$ 收到请求时，为了求出 $[t-3000,t]$ 内发生的请求数，我们可以不断从队首弹出早于 $t-3000$ 的时间。循环结束后队列的长度就是 $[t-3000,t]$ 内发生的请求数。\n\n```Python [sol1-Python3]\nclass RecentCounter:\n    def __init__(self):\n        self.q = deque()\n\n    def ping(self, t: int) -> int:\n        self.q.append(t)\n        while self.q[0] < t - 3000:\n            self.q.popleft()\n        return len(self.q)\n```\n\n```C++ [sol1-C++]\nclass RecentCounter {\n    queue<int> q;\npublic:\n    RecentCounter() {}\n\n    int ping(int t) {\n        q.push(t);\n        while (q.front() < t - 3000) {\n            q.pop();\n        }\n        return q.size();\n    }\n};\n```\n\n```Java [sol1-Java]\nclass RecentCounter {\n    Queue<Integer> queue;\n\n    public RecentCounter() {\n        queue = new ArrayDeque<Integer>();\n    }\n\n    public int ping(int t) {\n        queue.offer(t);\n        while (queue.peek() < t - 3000) {\n            queue.poll();\n        }\n        return queue.size();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class RecentCounter {\n    Queue<int> queue;\n\n    public RecentCounter() {\n        queue = new Queue<int>();\n    }\n\n    public int Ping(int t) {\n        queue.Enqueue(t);\n        while (queue.Peek() < t - 3000) {\n            queue.Dequeue();\n        }\n        return queue.Count;\n    }\n}\n```\n\n```go [sol1-Golang]\ntype RecentCounter []int\n\nfunc Constructor() (_ RecentCounter) { return }\n\nfunc (q *RecentCounter) Ping(t int) int {\n    *q = append(*q, t)\n    for (*q)[0] < t-3000 {\n        *q = (*q)[1:]\n    }\n    return len(*q)\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int *queue;\n    int capability;\n    int head;\n    int tail;\n} RecentCounter;\n\n\nRecentCounter* recentCounterCreate() {\n    RecentCounter *obj = (RecentCounter *)malloc(sizeof(RecentCounter));\n    obj->capability = 10001;\n    obj->queue = (int *)malloc(sizeof(int) * obj->capability);\n    obj->head = 0;\n    obj->tail = 0;\n    return obj;\n}\n\nint recentCounterPing(RecentCounter* obj, int t) {\n    obj->queue[obj->tail++] = t;\n    while (obj->queue[obj->head] < t - 3000) {\n        obj->head++;\n    }\n    return obj->tail - obj->head;\n}\n\nvoid recentCounterFree(RecentCounter* obj) {\n    free(obj->queue);\n    free(obj);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar RecentCounter = function() {\n    this.queue = [];\n};\n\nRecentCounter.prototype.ping = function(t) {\n    this.queue.push(t);\n    while (this.queue[0] < t - 3000) {\n        this.queue.shift();\n    }\n    return this.queue.length;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：均摊 $O(1)$，每个元素至多入队出队各一次。\n\n- 空间复杂度：$O(L)$，其中 $L$ 为队列的最大元素个数。"
}