{
	"titleSlug": "minimum-total-space-wasted-with-k-resizing-operations",
	"slug": "k-ci-diao-zheng-shu-zu-da-xiao-lang-fei-wxg6y",
	"url": "https://leetcode-cn.com/problems/minimum-total-space-wasted-with-k-resizing-operations/solution/k-ci-diao-zheng-shu-zu-da-xiao-lang-fei-wxg6y/",
	"content": "#### 方法一：动态规划 + 预处理\n\n**思路与算法**\n\n题目描述等价于：\n\n> 给定数组 $\\textit{nums}$ 以及整数 $k$，需要把数组完整地分成 $k+1$ 段连续的子数组，每一段的权值是「这一段的最大值**乘以**这一段的长度**再减去**这一段的元素和」。需要最小化总权值。\n\n我们可以使用动态规划解决本题。\n\n记 $f[i][j]$ 表示将 $\\textit{nums}[0..i]$ 分成 $j$ 段的最小总权值。在进行状态转移时，我们可以枚举最后的一段，那么就有状态转移方程：\n\n$$\nf[i][j] = \\min_{0 \\leq i_0 \\leq i} \\{ f[i_0-1][j-1] + g[i_0][i] \\}\n$$\n\n其中 $g[i_0][i]$ 表示「$\\textit{nums}[i_0..i]$ 这一段的最大值**乘以**这一段的长度**再减去**这一段的元素和」。在进行动态规划之前，我们可以使用二重循环预处理出所有的 $g$ 值。\n\n最终的答案即为 $f[n-1][k+1]$。\n\n**细节**\n\n在状态转移时我们需要枚举 $i_0$，而当 $i_0 = 0$ 时，$f[-1][j-1]$ 并不是一个合法的状态。\n\n我们可以考虑 $f[-1][..]$ 表示的意义：对于一段空的数组，我们希望将它分成若干段。由于每一段至少都要有一个元素，那么「空的数组」只能够分成 $0$ 段，即 $f[-1][0] = 0$；而不能分成任意正整数段，即其余的 $f[-1][..] = \\infty$（因为我们需要求出的是最小总权值，因此将不合法的状态标记为极大值）。\n\n然而本题有一个很好的性质，即当 $k_1 < k_2$ 时，分成 $k_1$ 段的最小总权值一定不会小于分成 $k_2$ 段的最小总权值，因此将所有的 $f[-1][..]$ 都置为 $0$ 也是不会影响最终答案的。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minSpaceWastedKResizing(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        // 预处理数组 g\n        vector<vector<int>> g(n, vector<int>(n));\n        for (int i = 0; i < n; ++i) {\n            // 记录子数组的最大值\n            int best = INT_MIN;\n            // 记录子数组的和\n            int total = 0;\n            for (int j = i; j < n; ++j) {\n                best = max(best, nums[j]);\n                total += nums[j];\n                g[i][j] = best * (j - i + 1) - total;\n            }\n        }\n        \n        vector<vector<int>> f(n, vector<int>(k + 2, INT_MAX / 2));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 1; j <= k + 1; ++j) {\n                for (int i0 = 0; i0 <= i; ++i0) {\n                    f[i][j] = min(f[i][j], (i0 == 0 ? 0 : f[i0 - 1][j - 1]) + g[i0][i]);\n                }\n            }\n        }\n\n        return f[n - 1][k + 1];\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        \n        # 预处理数组 g\n        g = [[0] * n for _ in range(n)]\n        for i in range(n):\n            # 记录子数组的最大值\n            best = float(\"-inf\")\n            # 记录子数组的和\n            total = 0\n            for j in range(i, n):\n                best = max(best, nums[j])\n                total += nums[j]\n                g[i][j] = best * (j - i + 1) - total\n        \n        f = [[float(\"inf\")] * (k + 2) for _ in range(n)]\n        for i in range(n):\n            for j in range(1, k + 2):\n                for i0 in range(i + 1):\n                    f[i][j] = min(f[i][j], (0 if i0 == 0 else f[i0 - 1][j - 1]) + g[i0][i])\n\n        return f[n - 1][k + 1]\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2k)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。状态的数量为 $O(nk)$，每个状态需要 $O(n)$ 的时间枚举 $i_0$ 进行转移。\n\n- 空间复杂度：$O(n(n+k))$。我们需要 $O(n^2)$ 的空间存储数组 $g$，$O(nk)$ 的空间存储所有的状态。"
}