{
	"titleSlug": "number-of-pairs-satisfying-inequality",
	"slug": "by-endlesscheng-9prc",
	"url": "https://leetcode-cn.com/problems/number-of-pairs-satisfying-inequality/solution/by-endlesscheng-9prc/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1tW4y1e7rb) 已出炉，欢迎点赞三连，在评论区分享你对这场双周赛的看法~\r\n\r\n包含树状数组的原理，以及另外一种归并排序的做法。\r\n\r\n---\r\n\r\n树状数组/线段树逐渐成为周赛必备技能了。\r\n\r\n本题用到的技巧是，合并下标相同的元素。\r\n\r\n式子变形得\r\n\r\n$$\r\n\\textit{nums}_1[i]-\\textit{nums}_2[i]\\le\\textit{nums}_1[j]-\\textit{nums}_2[j]+\\textit{diff}\r\n$$\r\n\r\n记 $a[i]=\\textit{nums}_1[i]-\\textit{nums}_2[i]$，上式为\r\n\r\n$$\r\na[i]\\le a[j]+\\textit{diff}\r\n$$\r\n\r\n因此本题和 [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)、[315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/) 等题目实质上是同一类题，用**归并排序**或者**树状数组**等均可以通过。\r\n\r\n**下面代码用的离散化树状数组，即使元素范围达到 $10^9$ 也适用。**\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def numberOfPairs(self, a: List[int], nums2: List[int], diff: int) -> int:\r\n        for i, x in enumerate(nums2):\r\n            a[i] -= x\r\n        b = a.copy()\r\n        b.sort()  # 配合下面的二分，离散化\r\n\r\n        ans = 0\r\n        t = BIT(len(a) + 1)\r\n        for x in a:\r\n            ans += t.query(bisect_right(b, x + diff))\r\n            t.add(bisect_left(b, x) + 1)\r\n        return ans\r\n\r\nclass BIT:\r\n    def __init__(self, n):\r\n        self.tree = [0] * n\r\n\r\n    def add(self, x):\r\n        while x < len(self.tree):\r\n            self.tree[x] += 1\r\n            x += x & -x\r\n\r\n    def query(self, x):\r\n        res = 0\r\n        while x > 0:\r\n            res += self.tree[x]\r\n            x &= x - 1\r\n        return res\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public long numberOfPairs(int[] a, int[] nums2, int diff) {\r\n        var n = a.length;\r\n        for (var i = 0; i < n; ++i)\r\n            a[i] -= nums2[i];\r\n        var b = a.clone();\r\n        Arrays.sort(b); // 配合下面的二分，离散化\r\n\r\n        var ans = 0L;\r\n        var t = new BIT(n + 1);\r\n        for (var x : a) {\r\n            ans += t.query(lowerBound(b, x + diff + 1));\r\n            t.add(lowerBound(b, x) + 1);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    private int lowerBound(int[] a, int x) {\r\n        int left = 0, right = a.length;\r\n        while (left < right) {\r\n            var mid = left + (right - left) / 2;\r\n            if (a[mid] < x) left = mid + 1;\r\n            else right = mid;\r\n        }\r\n        return left;\r\n    }\r\n}\r\n\r\nclass BIT {\r\n    private final int[] tree;\r\n\r\n    public BIT(int n) {\r\n        tree = new int[n];\r\n    }\r\n\r\n    public void add(int x) {\r\n        while (x < tree.length) {\r\n            ++tree[x];\r\n            x += x & -x;\r\n        }\r\n    }\r\n\r\n    public int query(int x) {\r\n        var res = 0;\r\n        while (x > 0) {\r\n            res += tree[x];\r\n            x &= x - 1;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass BIT {\r\nprivate:\r\n    vector<int> tree;\r\n\r\npublic:\r\n    BIT(int n) : tree(n) {}\r\n\r\n    void add(int x) {\r\n        while (x < tree.size()) {\r\n            ++tree[x];\r\n            x += x & -x;\r\n        }\r\n    }\r\n\r\n    int query(int x) {\r\n        int res = 0;\r\n        while (x > 0) {\r\n            res += tree[x];\r\n            x &= x - 1;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    long long numberOfPairs(vector<int> &a, vector<int> &nums2, int diff) {\r\n        int n = a.size();\r\n        for (int i = 0; i < n; ++i)\r\n            a[i] -= nums2[i];\r\n        auto b = a;\r\n        sort(b.begin(), b.end()); // 配合下面的二分，离散化\r\n\r\n        long ans = 0L;\r\n        auto t = new BIT(n + 1);\r\n        for (int x : a) {\r\n            ans += t->query(upper_bound(b.begin(), b.end(), x + diff) - b.begin());\r\n            t->add(lower_bound(b.begin(), b.end(), x) - b.begin() + 1);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc numberOfPairs(a, nums2 []int, diff int) (ans int64) {\r\n\tfor i, x := range nums2 {\r\n\t\ta[i] -= x\r\n\t}\r\n\tb := append(sort.IntSlice{}, a...)\r\n\tb.Sort() // 配合下面的二分，离散化\r\n\r\n\tt := make(BIT, len(a)+1)\r\n\tfor _, x := range a {\r\n\t\tans += int64(t.query(b.Search(x + diff + 1)))\r\n\t\tt.add(b.Search(x) + 1)\r\n\t}\r\n\treturn\r\n}\r\n\r\ntype BIT []int\r\n\r\nfunc (t BIT) add(x int) {\r\n\tfor x < len(t) {\r\n\t\tt[x]++\r\n\t\tx += x & -x\r\n\t}\r\n}\r\n\r\nfunc (t BIT) query(x int) (res int) {\r\n\tfor x > 0 {\r\n\t\tres += t[x]\r\n\t\tx &= x - 1\r\n\t}\r\n\treturn\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\log n)$，其中 $n$ 为 $\\textit{nums}_1$ 的长度。\r\n- 空间复杂度：$O(n)$。\r\n"
}