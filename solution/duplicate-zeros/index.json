{
	"titleSlug": "duplicate-zeros",
	"slug": "fu-xie-ling-by-leetcode-solution-7ael",
	"url": "https://leetcode-cn.com/problems/duplicate-zeros/solution/fu-xie-ling-by-leetcode-solution-7ael/",
	"content": "#### 方法一：双指针\n\n**思路与算法**\n\n首先如果没有原地修改的限制，那么我们可以另开辟一个栈来进行模拟放置：\n\n<![fig1](https://assets.leetcode-cn.com/solution-static/1089/1.png),![fig2](https://assets.leetcode-cn.com/solution-static/1089/2.png),![fig3](https://assets.leetcode-cn.com/solution-static/1089/3.png),![fig4](https://assets.leetcode-cn.com/solution-static/1089/4.png),![fig5](https://assets.leetcode-cn.com/solution-static/1089/5.png),![fig6](https://assets.leetcode-cn.com/solution-static/1089/6.png),![fig7](https://assets.leetcode-cn.com/solution-static/1089/7.png),![fig8](https://assets.leetcode-cn.com/solution-static/1089/8.png),![fig9](https://assets.leetcode-cn.com/solution-static/1089/9.png),![fig10](https://assets.leetcode-cn.com/solution-static/1089/10.png)>\n\n而实际上我们可以不需要开辟栈空间来模拟放置元素，我们只需要用两个指针来进行标记栈顶位置和现在需要放置的元素位置即可。我们用 $\\textit{top}$ 来标记栈顶位置，用 $i$ 来标记现在需要放置的元素位置，那么我们找到原数组中对应放置在最后位置的元素位置，然后在数组最后从该位置元素往前来进行模拟放置即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def duplicateZeros(self, arr: List[int]) -> None:\n        n = len(arr)\n        top = 0\n        i = -1\n        while top < n:\n            i += 1\n            top += 1 if arr[i] else 2\n        j = n - 1\n        if top == n + 1:\n            arr[j] = 0\n            j -= 1\n            i -= 1\n        while j >= 0:\n            arr[j] = arr[i]\n            j -= 1\n            if arr[i] == 0:\n                arr[j] = arr[i]\n                j -= 1\n            i -= 1\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    void duplicateZeros(vector<int>& arr) {\n        int n = arr.size();\n        int top = 0;\n        int i = -1;\n        while (top < n) {\n            i++;\n            if (arr[i] != 0) {\n                top++;\n            } else {\n                top += 2;\n            }\n        }\n        int j = n - 1;\n        if (top == n + 1) {\n            arr[j] = 0;\n            j--;\n            i--;\n        } \n        while (j >= 0) {\n            arr[j] = arr[i];\n            j--;\n            if (!arr[i]) {\n                arr[j] = arr[i];\n                j--;\n            } \n            i--;\n        }\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public void duplicateZeros(int[] arr) {\n        int n = arr.length;\n        int top = 0;\n        int i = -1;\n        while (top < n) {\n            i++;\n            if (arr[i] != 0) {\n                top++;\n            } else {\n                top += 2;\n            }\n        }\n        int j = n - 1;\n        if (top == n + 1) {\n            arr[j] = 0;\n            j--;\n            i--;\n        } \n        while (j >= 0) {\n            arr[j] = arr[i];\n            j--;\n            if (arr[i] == 0) {\n                arr[j] = arr[i];\n                j--;\n            } \n            i--;\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public void DuplicateZeros(int[] arr) {\n        int n = arr.Length;\n        int top = 0;\n        int i = -1;\n        while (top < n) {\n            i++;\n            if (arr[i] != 0) {\n                top++;\n            } else {\n                top += 2;\n            }\n        }\n        int j = n - 1;\n        if (top == n + 1) {\n            arr[j] = 0;\n            j--;\n            i--;\n        } \n        while (j >= 0) {\n            arr[j] = arr[i];\n            j--;\n            if (arr[i] == 0) {\n                arr[j] = arr[i];\n                j--;\n            } \n            i--;\n        }\n    }\n}\n```\n\n```C [sol1-C]\nvoid duplicateZeros(int* arr, int arrSize){\n    int top = 0;\n    int i = -1;\n    while (top < arrSize) {\n        i++;\n        if (arr[i] != 0) {\n            top++;\n        } else {\n            top += 2;\n        }\n    }\n    int j = arrSize - 1;\n    if (top == arrSize + 1) {\n        arr[j] = 0;\n        j--;\n        i--;\n    } \n    while (j >= 0) {\n        arr[j] = arr[i];\n        j--;\n        if (!arr[i]) {\n            arr[j] = arr[i];\n            j--;\n        } \n        i--;\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar duplicateZeros = function(arr) {\n    const n = arr.length;\n    let top = 0;\n    let i = -1;\n    while (top < n) {\n        i++;\n        if (arr[i] !== 0) {\n            top++;\n        } else {\n            top += 2;\n        }\n    }\n    let j = n - 1;\n    if (top === n + 1) {\n        arr[j] = 0;\n        j--;\n        i--;\n    } \n    while (j >= 0) {\n        arr[j] = arr[i];\n        j--;\n        if (arr[i] === 0) {\n            arr[j] = arr[i];\n            j--;\n        } \n        i--;\n    }\n};\n```\n\n```go [sol1-Golang]\nfunc duplicateZeros(arr []int) {\n    n := len(arr)\n    top := 0\n    i := -1\n    for top < n {\n        i++\n        if arr[i] != 0 {\n            top++\n        } else {\n            top += 2\n        }\n    }\n    j := n - 1\n    if top == n+1 {\n        arr[j] = 0\n        j--\n        i--\n    }\n    for j >= 0 {\n        arr[j] = arr[i]\n        j--\n        if arr[i] == 0 {\n            arr[j] = arr[i]\n            j--\n        }\n        i--\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{arr}$ 的长度。需要遍历两遍数组。\n\n- 空间复杂度：$O(1)$，仅使用常量空间。"
}