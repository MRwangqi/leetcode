{
	"titleSlug": "candy",
	"slug": "fen-fa-tang-guo-by-leetcode-solution-f01p",
	"url": "https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/",
	"content": "#### 方法一：两次遍历\n\n**思路及解法**\n\n我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。\n\n- 左规则：当 $\\textit{ratings}[i - 1] < \\textit{ratings}[i]$ 时，$i$ 号学生的糖果数量将比 $i - 1$ 号孩子的糖果数量多。\n\n- 右规则：当 $\\textit{ratings}[i] > \\textit{ratings}[i + 1]$ 时，$i$ 号学生的糖果数量将比 $i + 1$ 号孩子的糖果数量多。\n\n我们遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。\n\n具体地，以左规则为例：我们从左到右遍历该数组，假设当前遍历到位置 $i$，如果有 $\\textit{ratings}[i - 1] < \\textit{ratings}[i]$ 那么 $i$ 号学生的糖果数量将比 $i - 1$ 号孩子的糖果数量多，我们令 $\\textit{left}[i] = \\textit{left}[i - 1] + 1$ 即可，否则我们令 $\\textit{left}[i] = 1$。\n\n在实际代码中，我们先计算出左规则 $\\textit{left}$ 数组，在计算右规则的时候只需要用单个变量记录当前位置的右规则，同时计算答案即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int n = ratings.size();\n        vector<int> left(n);\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && ratings[i] > ratings[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            } else {\n                left[i] = 1;\n            }\n        }\n        int right = 0, ret = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            if (i < n - 1 && ratings[i] > ratings[i + 1]) {\n                right++;\n            } else {\n                right = 1;\n            }\n            ret += max(left[i], right);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        int[] left = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && ratings[i] > ratings[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            } else {\n                left[i] = 1;\n            }\n        }\n        int right = 0, ret = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            if (i < n - 1 && ratings[i] > ratings[i + 1]) {\n                right++;\n            } else {\n                right = 1;\n            }\n            ret += Math.max(left[i], right);\n        }\n        return ret;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc candy(ratings []int) (ans int) {\n    n := len(ratings)\n    left := make([]int, n)\n    for i, r := range ratings {\n        if i > 0 && r > ratings[i-1] {\n            left[i] = left[i-1] + 1\n        } else {\n            left[i] = 1\n        }\n    }\n    right := 0\n    for i := n - 1; i >= 0; i-- {\n        if i < n-1 && ratings[i] > ratings[i+1] {\n            right++\n        } else {\n            right = 1\n        }\n        ans += max(left[i], right)\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        left = [0] * n\n        for i in range(n):\n            if i > 0 and ratings[i] > ratings[i - 1]:\n                left[i] = left[i - 1] + 1\n            else:\n                left[i] = 1\n        \n        right = ret = 0\n        for i in range(n - 1, -1, -1):\n            if i < n - 1 and ratings[i] > ratings[i + 1]:\n                right += 1\n            else:\n                right = 1\n            ret += max(left[i], right)\n        \n        return ret\n```\n\n```JavaScript [sol1-JavaScript]\nvar candy = function(ratings) {\n    const n = ratings.length;\n    const left = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        if (i > 0 && ratings[i] > ratings[i - 1]) {\n            left[i] = left[i - 1] + 1;\n        } else {\n            left[i] = 1;\n        }\n    }\n\n    let right = 0, ret = 0;\n    for (let i = n - 1; i > -1; i--) {\n        if (i < n - 1 && ratings[i] > ratings[i + 1]) {\n            right++;\n        } else {\n            right = 1;\n        }\n        ret += Math.max(left[i], right);\n    }\n    return ret;\n};\n```\n\n```C [sol1-C]\nint candy(int* ratings, int ratingsSize) {\n    int left[ratingsSize];\n    for (int i = 0; i < ratingsSize; i++) {\n        if (i > 0 && ratings[i] > ratings[i - 1]) {\n            left[i] = left[i - 1] + 1;\n        } else {\n            left[i] = 1;\n        }\n    }\n    int right = 0, ret = 0;\n    for (int i = ratingsSize - 1; i >= 0; i--) {\n        if (i < ratingsSize - 1 && ratings[i] > ratings[i + 1]) {\n            right++;\n        } else {\n            right = 1;\n        }\n        ret += fmax(left[i], right);\n    }\n    return ret;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是孩子的数量。我们需要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是孩子的数量。我们需要保存所有的左规则对应的糖果数量。\n\n#### 方法二：常数空间遍历\n\n**思路及解法**\n\n注意到糖果总是尽量少给，且从 $1$ 开始累计，每次要么比相邻的同学多给一个，要么重新置为 $1$。依据此规则，我们可以画出下图：\n\n![fig1](https://assets.leetcode-cn.com/solution-static/135/1.png)\n\n其中相同颜色的柱状图的高度总恰好为 $1,2,3 \\dots$。\n\n而高度也不一定一定是升序，也可能是 $\\dots 3,2,1$ 的降序：\n\n![fig2](https://assets.leetcode-cn.com/solution-static/135/2.png)\n\n注意到在上图中，对于第三个同学，他既可以被认为是属于绿色的升序部分，也可以被认为是属于蓝色的降序部分。因为他同时比两边的同学评分更高。我们对序列稍作修改：\n\n![fig3](https://assets.leetcode-cn.com/solution-static/135/3.png)\n\n注意到右边的升序部分变长了，使得第三个同学不得不被分配 $4$ 个糖果。\n\n依据前面总结的规律，我们可以提出本题的解法。我们从左到右枚举每一个同学，记前一个同学分得的糖果数量为 $\\textit{pre}$：\n\n- 如果当前同学比上一个同学评分高，说明我们就在最近的递增序列中，直接分配给该同学 $\\textit{pre} + 1$ 个糖果即可。\n\n- 否则我们就在一个递减序列中，我们直接分配给当前同学一个糖果，并把该同学所在的递减序列中所有的同学都再多分配一个糖果，以保证糖果数量还是满足条件。\n\n  - 我们无需显式地额外分配糖果，只需要记录当前的递减序列长度，即可知道需要额外分配的糖果数量。\n\n  - 同时注意当当前的递减序列长度和上一个递增序列等长时，需要把最近的递增序列的最后一个同学也并进递减序列中。\n\n这样，我们只要记录当前递减序列的长度 $\\textit{dec}$，最近的递增序列的长度 $\\textit{inc}$ 和前一个同学分得的糖果数量 $\\textit{pre}$ 即可。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int n = ratings.size();\n        int ret = 1;\n        int inc = 1, dec = 0, pre = 1;\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] >= ratings[i - 1]) {\n                dec = 0;\n                pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1;\n                ret += pre;\n                inc = pre;\n            } else {\n                dec++;\n                if (dec == inc) {\n                    dec++;\n                }\n                ret += dec;\n                pre = 1;\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        int ret = 1;\n        int inc = 1, dec = 0, pre = 1;\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] >= ratings[i - 1]) {\n                dec = 0;\n                pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1;\n                ret += pre;\n                inc = pre;\n            } else {\n                dec++;\n                if (dec == inc) {\n                    dec++;\n                }\n                ret += dec;\n                pre = 1;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc candy(ratings []int) int {\n    n := len(ratings)\n    ans, inc, dec, pre := 1, 1, 0, 1\n    for i := 1; i < n; i++ {\n        if ratings[i] >= ratings[i-1] {\n            dec = 0\n            if ratings[i] == ratings[i-1] {\n                pre = 1\n            } else {\n                pre++\n            }\n            ans += pre\n            inc = pre\n        } else {\n            dec++\n            if dec == inc {\n                dec++\n            }\n            ans += dec\n            pre = 1\n        }\n    }\n    return ans\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        ret = 1\n        inc, dec, pre = 1, 0, 1\n\n        for i in range(1, n):\n            if ratings[i] >= ratings[i - 1]:\n                dec = 0\n                pre = (1 if ratings[i] == ratings[i - 1] else pre + 1)\n                ret += pre\n                inc = pre\n            else:\n                dec += 1\n                if dec == inc:\n                    dec += 1\n                ret += dec\n                pre = 1\n        \n        return ret\n```\n\n```JavaScript [sol2-JavaScript]\nvar candy = function(ratings) {\n    const n = ratings.length;\n    let ret = 1;\n    let inc = 1, dec = 0, pre = 1;\n\n    for (let i = 1; i < n; i++) {\n        if (ratings[i] >= ratings[i - 1]) {\n            dec = 0;\n            if (ratings[i] === ratings[i - 1]) pre = 1;\n            else pre++;\n            ret += pre;\n            inc = pre;\n        } else {\n            dec++;\n            if (dec === inc) {\n                dec++;\n            }\n            ret += dec;\n            pre = 1;\n        }\n    }\n    return ret;\n};\n```\n\n```C [sol2-C]\nint candy(int* ratings, int ratingsSize) {\n    int ret = 1;\n    int inc = 1, dec = 0, pre = 1;\n    for (int i = 1; i < ratingsSize; i++) {\n        if (ratings[i] >= ratings[i - 1]) {\n            dec = 0;\n            pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1;\n            ret += pre;\n            inc = pre;\n        } else {\n            dec++;\n            if (dec == inc) {\n                dec++;\n            }\n            ret += dec;\n            pre = 1;\n        }\n    }\n    return ret;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是孩子的数量。我们需要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。\n\n- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。"
}