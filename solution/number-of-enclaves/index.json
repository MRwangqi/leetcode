{
	"titleSlug": "number-of-enclaves",
	"slug": "fei-di-de-shu-liang-by-leetcode-solution-nzs3",
	"url": "https://leetcode-cn.com/problems/number-of-enclaves/solution/fei-di-de-shu-liang-by-leetcode-solution-nzs3/",
	"content": "#### 方法一：深度优先搜索\n\n根据飞地的定义，如果从一个陆地单元格出发无法移动到网格边界，则这个陆地单元格是飞地。因此可以将所有陆地单元格分成两类：第一类陆地单元格和网格边界相连，这些陆地单元格不是飞地；第二类陆地单元格不和网格边界相连，这些陆地单元格是飞地。\n\n我们可以从网格边界上的每个陆地单元格开始深度优先搜索，遍历完边界之后，所有和网格边界相连的陆地单元格就都被访问过了。然后遍历整个网格，如果网格中的一个陆地单元格没有被访问过，则该陆地单元格不和网格的边界相连，是飞地。\n\n代码实现时，由于网格边界上的单元格一定不是飞地，因此遍历网格统计飞地的数量时只需要遍历不在网格边界上的单元格。\n\n```Java [sol1-Java]\nclass Solution {\n    public static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    private int m, n;\n    private boolean[][] visited;\n\n    public int numEnclaves(int[][] grid) {\n        m = grid.length;\n        n = grid[0].length;\n        visited = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            dfs(grid, i, 0);\n            dfs(grid, i, n - 1);\n        }\n        for (int j = 1; j < n - 1; j++) {\n            dfs(grid, 0, j);\n            dfs(grid, m - 1, j);\n        }\n        int enclaves = 0;\n        for (int i = 1; i < m - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    enclaves++;\n                }\n            }\n        }\n        return enclaves;\n    }\n\n    public void dfs(int[][] grid, int row, int col) {\n        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == 0 || visited[row][col]) {\n            return;\n        }\n        visited[row][col] = true;\n        for (int[] dir : dirs) {\n            dfs(grid, row + dir[0], col + dir[1]);\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public static int[][] dirs = {new int[]{-1, 0}, new int[]{1, 0}, new int[]{0, -1}, new int[]{0, 1}};\n    private int m, n;\n    private bool[][] visited;\n\n    public int NumEnclaves(int[][] grid) {\n        m = grid.Length;\n        n = grid[0].Length;\n        visited = new bool[m][];\n        for (int i = 0; i < m; i++) {\n            visited[i] = new bool[n];\n        }\n        for (int i = 0; i < m; i++) {\n            DFS(grid, i, 0);\n            DFS(grid, i, n - 1);\n        }\n        for (int j = 1; j < n - 1; j++) {\n            DFS(grid, 0, j);\n            DFS(grid, m - 1, j);\n        }\n        int enclaves = 0;\n        for (int i = 1; i < m - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    enclaves++;\n                }\n            }\n        }\n        return enclaves;\n    }\n\n    public void DFS(int[][] grid, int row, int col) {\n        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == 0 || visited[row][col]) {\n            return;\n        }\n        visited[row][col] = true;\n        foreach (int[] dir in dirs) {\n            DFS(grid, row + dir[0], col + dir[1]);\n        }\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    int numEnclaves(vector<vector<int>>& grid) {\n        this->m = grid.size();\n        this->n = grid[0].size();\n        this->visited = vector<vector<bool>>(m, vector<bool>(n, false));\n        for (int i = 0; i < m; i++) {\n            dfs(grid, i, 0);\n            dfs(grid, i, n - 1);\n        }\n        for (int j = 1; j < n - 1; j++) {\n            dfs(grid, 0, j);\n            dfs(grid, m - 1, j);\n        }\n        int enclaves = 0;\n        for (int i = 1; i < m - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    enclaves++;\n                }\n            }\n        }\n        return enclaves;\n    }\n\n    void dfs(const vector<vector<int>> & grid, int row, int col) {\n        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == 0 || visited[row][col]) {\n            return;\n        }\n        visited[row][col] = true;\n        for (auto & dir : dirs) {\n            dfs(grid, row + dir[0], col + dir[1]);\n        }\n    }\nprivate:\n    int m, n;\n    vector<vector<bool>> visited;\n};\n```\n\n```C [sol1-C]\nint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nvoid dfs(const int** grid, int m, int n, uint8_t** visited, int row, int col) {\n    if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == 0 || visited[row][col]) {\n        return;\n    }\n    visited[row][col] = 1;\n    for (int i = 0; i < 4 ; i++) {\n        dfs(grid, m, n, visited, row + dirs[i][0], col + dirs[i][1]);\n    }\n}\n\nint numEnclaves(int** grid, int gridSize, int* gridColSize) {\n    int m = gridSize, n = gridColSize[0];\n    uint8_t ** visited = (uint8_t **)malloc(sizeof(uint8_t *) * m);\n    for (int i = 0; i < m; i++) {\n        visited[i] = (uint8_t *)malloc(sizeof(uint8_t) * n);\n        memset(visited[i], 0, sizeof(uint8_t) * n);\n    }\n    for (int i = 0; i < m; i++) {\n        dfs(grid, m, n, visited, i, 0);\n        dfs(grid, m, n, visited, i, n - 1);\n    }\n    for (int j = 1; j < n - 1; j++) {\n        dfs(grid, m, n, visited, 0, j);\n        dfs(grid, m, n, visited, m - 1, j);\n    }\n    int enclaves = 0;\n    for (int i = 1; i < m - 1; i++) {\n        for (int j = 1; j < n - 1; j++) {\n            if (grid[i][j] == 1 && !visited[i][j]) {\n                enclaves++;\n            }\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        free(visited[i]);\n    }\n    free(visited);\n    return enclaves;\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def numEnclaves(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        vis = [[False] * n for _ in range(m)]\n\n        def dfs(r: int, c: int) -> None:\n            if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] == 0 or vis[r][c]:\n                return\n            vis[r][c] = True\n            for x, y in ((r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)):\n                dfs(x, y)\n\n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(1, n - 1):\n            dfs(0, j)\n            dfs(m - 1, j)\n        return sum(grid[i][j] and not vis[i][j] for i in range(1, m - 1) for j in range(1, n - 1))\n```\n\n```go [sol1-Golang]\nvar dirs = []struct{ x, y int }{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\nfunc numEnclaves(grid [][]int) (ans int) {\n    m, n := len(grid), len(grid[0])\n    vis := make([][]bool, m)\n    for i := range vis {\n        vis[i] = make([]bool, n)\n    }\n    var dfs func(int, int)\n    dfs = func(r, c int) {\n        if r < 0 || r >= m || c < 0 || c >= n || grid[r][c] == 0 || vis[r][c] {\n            return\n        }\n        vis[r][c] = true\n        for _, d := range dirs {\n            dfs(r+d.x, c+d.y)\n        }\n    }\n    for i := range grid {\n        dfs(i, 0)\n        dfs(i, n-1)\n    }\n    for j := 1; j < n-1; j++ {\n        dfs(0, j)\n        dfs(m-1, j)\n    }\n    for i := 1; i < m-1; i++ {\n        for j := 1; j < n-1; j++ {\n            if grid[i][j] == 1 && !vis[i][j] {\n                ans++\n            }\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar numEnclaves = function(grid) {\n    const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    const m = grid.length;\n    const n = grid[0].length;\n    const visited = new Array(m).fill(0).map(() => new Array(n).fill(false));\n\n    const dfs = (grid, row, col) => {\n        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == 0 || visited[row][col]) {\n            return;\n        }\n        visited[row][col] = true;\n        for (const dir of dirs) {\n            dfs(grid, row + dir[0], col + dir[1]);\n        }\n    };\n\n    for (let i = 0; i < m; i++) {\n        dfs(grid, i, 0);\n        dfs(grid, i, n - 1);\n    }\n    for (let j = 1; j < n - 1; j++) {\n        dfs(grid, 0, j);\n        dfs(grid, m - 1, j);\n    }\n    let enclaves = 0;\n    for (let i = 1; i < m - 1; i++) {\n        for (let j = 1; j < n - 1; j++) {\n            if (grid[i][j] === 1 && !visited[i][j]) {\n                enclaves++;\n            }\n        }\n    }\n    return enclaves;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是网格 $\\textit{grid}$ 的行数和列数。深度优先搜索最多访问每个单元格一次，需要 $O(mn)$ 的时间，遍历网格统计飞地的数量也需要 $O(mn)$ 的时间。\n\n- 空间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是网格 $\\textit{grid}$ 的行数和列数。空间复杂度主要取决于 $\\textit{visited}$ 数组和递归调用栈空间，空间复杂度是 $O(mn)$。\n\n#### 方法二：广度优先搜索\n\n也可以通过广度优先搜索判断每个陆地单元格是否和网格边界相连。\n\n首先从网格边界上的每个陆地单元格开始广度优先搜索，访问所有和网格边界相连的陆地单元格，然后遍历整个网格，统计飞地的数量。\n\n```Java [sol2-Java]\nclass Solution {\n    public static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public int numEnclaves(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        Queue<int[]> queue = new ArrayDeque<int[]>();\n        for (int i = 0; i < m; i++) {\n            if (grid[i][0] == 1) {\n                visited[i][0] = true;\n                queue.offer(new int[]{i, 0});\n            }\n            if (grid[i][n - 1] == 1) {\n                visited[i][n - 1] = true;\n                queue.offer(new int[]{i, n - 1});\n            }\n        }\n        for (int j = 1; j < n - 1; j++) {\n            if (grid[0][j] == 1) {\n                visited[0][j] = true;\n                queue.offer(new int[]{0, j});\n            }\n            if (grid[m - 1][j] == 1) {\n                visited[m - 1][j] = true;\n                queue.offer(new int[]{m - 1, j});\n            }\n        }\n        while (!queue.isEmpty()) {\n            int[] cell = queue.poll();\n            int currRow = cell[0], currCol = cell[1];\n            for (int[] dir : dirs) {\n                int nextRow = currRow + dir[0], nextCol = currCol + dir[1];\n                if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && grid[nextRow][nextCol] == 1 && !visited[nextRow][nextCol]) {\n                    visited[nextRow][nextCol] = true;\n                    queue.offer(new int[]{nextRow, nextCol});\n                }\n            }\n        }\n        int enclaves = 0;\n        for (int i = 1; i < m - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    enclaves++;\n                }\n            }\n        }\n        return enclaves;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public static int[][] dirs = {new int[]{-1, 0}, new int[]{1, 0}, new int[]{0, -1}, new int[]{0, 1}};\n\n    public int NumEnclaves(int[][] grid) {\n        int m = grid.Length, n = grid[0].Length;\n        bool[][] visited = new bool[m][];\n        for (int i = 0; i < m; i++) {\n            visited[i] = new bool[n];\n        }\n        Queue<Tuple<int, int>> queue = new Queue<Tuple<int, int>>();\n        for (int i = 0; i < m; i++) {\n            if (grid[i][0] == 1) {\n                visited[i][0] = true;\n                queue.Enqueue(new Tuple<int, int>(i, 0));\n            }\n            if (grid[i][n - 1] == 1) {\n                visited[i][n - 1] = true;\n                queue.Enqueue(new Tuple<int, int>(i, n - 1));\n            }\n        }\n        for (int j = 1; j < n - 1; j++) {\n            if (grid[0][j] == 1) {\n                visited[0][j] = true;\n                queue.Enqueue(new Tuple<int, int>(0, j));\n            }\n            if (grid[m - 1][j] == 1) {\n                visited[m - 1][j] = true;\n                queue.Enqueue(new Tuple<int, int>(m - 1, j));\n            }\n        }\n        while (queue.Count > 0) {\n            Tuple<int, int> cell = queue.Dequeue();\n            int currRow = cell.Item1, currCol = cell.Item2;\n            foreach (int[] dir in dirs) {\n                int nextRow = currRow + dir[0], nextCol = currCol + dir[1];\n                if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && grid[nextRow][nextCol] == 1 && !visited[nextRow][nextCol]) {\n                    visited[nextRow][nextCol] = true;\n                    queue.Enqueue(new Tuple<int, int>(nextRow, nextCol));\n                }\n            }\n        }\n        int enclaves = 0;\n        for (int i = 1; i < m - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    enclaves++;\n                }\n            }\n        }\n        return enclaves;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    int numEnclaves(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<bool>> visited = vector<vector<bool>>(m, vector<bool>(n, false));\n        queue<pair<int,int>> qu;\n        for (int i = 0; i < m; i++) {\n            if (grid[i][0] == 1) {\n                visited[i][0] = true;\n                qu.emplace(i, 0);\n            }\n            if (grid[i][n - 1] == 1) {\n                visited[i][n - 1] = true;\n                qu.emplace(i, n - 1);\n            }\n        }\n        for (int j = 1; j < n - 1; j++) {\n            if (grid[0][j] == 1) {\n                visited[0][j] = true;\n                qu.emplace(0, j);\n            }\n            if (grid[m - 1][j] == 1) {\n                visited[m - 1][j] = true;\n                qu.emplace(m - 1, j);\n            }\n        }\n        while (!qu.empty()) {\n            auto [currRow, currCol] = qu.front();\n            qu.pop();\n            for (auto & dir : dirs) {\n                int nextRow = currRow + dir[0], nextCol = currCol + dir[1];\n                if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && grid[nextRow][nextCol] == 1 && !visited[nextRow][nextCol]) {\n                    visited[nextRow][nextCol] = true;\n                    qu.emplace(nextRow, nextCol);\n                }\n            }\n        }\n        int enclaves = 0;\n        for (int i = 1; i < m - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    enclaves++;\n                }\n            }\n        }\n        return enclaves;\n    }\n};\n```\n\n```C [sol2-C]\ntypedef struct {\n    int x;\n    int y;\n} Pair;\n\nint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nint numEnclaves(int** grid, int gridSize, int* gridColSize){\n    int m = gridSize, n = gridColSize[0];\n    bool ** visited = (bool **)malloc(sizeof(bool *) * m);\n    for (int i = 0; i < m; i++) {\n        visited[i] = (bool *)malloc(sizeof(bool) * n);\n        memset(visited[i], 0, sizeof(bool) * n);\n    }\n    Pair * queue = (Pair *)malloc(sizeof(Pair) * m * n);\n    int head = 0;\n    int tail = 0;\n    for (int i = 0; i < m; i++) {\n        if (grid[i][0] == 1) {\n            visited[i][0] = true;\n            queue[tail].x = i;\n            queue[tail].y = 0;\n            tail++;\n        }\n        if (grid[i][n - 1] == 1) {\n            visited[i][n - 1] = true;\n            queue[tail].x = i;\n            queue[tail].y = n - 1;\n            tail++;\n        }\n    }\n    for (int j = 1; j < n - 1; j++) {\n        if (grid[0][j] == 1) {\n            visited[0][j] = true;\n            queue[tail].x = 0;\n            queue[tail].y = j;\n            tail++;\n        }\n        if (grid[m - 1][j] == 1) {\n            visited[m - 1][j] = true;\n            queue[tail].x = m - 1;\n            queue[tail].y = j;\n            tail++;\n        }\n    }\n    while (head != tail) {\n        int currRow = queue[head].x;\n        int currCol = queue[head].y;\n        head++;\n        for (int i = 0; i < 4; i++) {\n            int nextRow = currRow + dirs[i][0], nextCol = currCol + dirs[i][1];\n            if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && grid[nextRow][nextCol] == 1 && !visited[nextRow][nextCol]) {\n                visited[nextRow][nextCol] = true;\n                queue[tail].x = nextRow;\n                queue[tail].y = nextCol;\n                tail++;\n            }\n        }\n    }\n    int enclaves = 0;\n    for (int i = 1; i < m - 1; i++) {\n        for (int j = 1; j < n - 1; j++) {\n            if (grid[i][j] == 1 && !visited[i][j]) {\n                enclaves++;\n            }\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        free(visited[i]);\n    }\n    free(visited);\n    free(queue);\n    return enclaves;\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def numEnclaves(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        vis = [[False] * n for _ in range(m)]\n        q = deque()\n        for i, row in enumerate(grid):\n            if row[0]:\n                vis[i][0] = True\n                q.append((i, 0))\n            if row[n - 1]:\n                vis[i][n - 1] = True\n                q.append((i, n - 1))\n        for j in range(1, n - 1):\n            if grid[0][j]:\n                vis[0][j] = True\n                q.append((0, j))\n            if grid[m - 1][j]:\n                vis[m - 1][j] = True\n                q.append((m - 1, j))\n        while q:\n            r, c = q.popleft()\n            for x, y in ((r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)):\n                if 0 <= x < m and 0 <= y < n and grid[x][y] and not vis[x][y]:\n                    vis[x][y] = True\n                    q.append((x, y))\n        return sum(grid[i][j] and not vis[i][j] for i in range(1, m - 1) for j in range(1, n - 1))\n```\n\n```go [sol2-Golang]\ntype pair struct{ x, y int }\nvar dirs = []pair{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\nfunc numEnclaves(grid [][]int) (ans int) {\n    m, n := len(grid), len(grid[0])\n    vis := make([][]bool, m)\n    for i := range vis {\n        vis[i] = make([]bool, n)\n    }\n    q := []pair{}\n    for i, row := range grid {\n        if row[0] == 1 {\n            vis[i][0] = true\n            q = append(q, pair{i, 0})\n        }\n        if row[n-1] == 1 {\n            vis[i][n-1] = true\n            q = append(q, pair{i, n - 1})\n        }\n    }\n    for j := 1; j < n-1; j++ {\n        if grid[0][j] == 1 {\n            vis[0][j] = true\n            q = append(q, pair{0, j})\n        }\n        if grid[m-1][j] == 1 {\n            vis[m-1][j] = true\n            q = append(q, pair{m - 1, j})\n        }\n    }\n    for len(q) > 0 {\n        p := q[0]\n        q = q[1:]\n        for _, d := range dirs {\n            if x, y := p.x+d.x, p.y+d.y; 0 <= x && x < m && 0 <= y && y < n && grid[x][y] == 1 && !vis[x][y] {\n                vis[x][y] = true\n                q = append(q, pair{x, y})\n            }\n        }\n    }\n    for i := 1; i < m-1; i++ {\n        for j := 1; j < n-1; j++ {\n            if grid[i][j] == 1 && !vis[i][j] {\n                ans++\n            }\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar numEnclaves = function(grid) {\n    const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    const m = grid.length, n = grid[0].length;\n    const visited = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    const queue = [];\n    for (let i = 0; i < m; i++) {\n        if (grid[i][0] === 1) {\n            visited[i][0] = true;\n            queue.push([i, 0]);\n        }\n        if (grid[i][n - 1] === 1) {\n            visited[i][n - 1] = true;\n            queue.push([i, n - 1]);\n        }\n    }\n    for (let j = 1; j < n - 1; j++) {\n        if (grid[0][j] === 1) {\n            visited[0][j] = true;\n            queue.push([0, j]);\n        }\n        if (grid[m - 1][j] === 1) {\n            visited[m - 1][j] = true;\n            queue.push([m - 1, j]);\n        }\n    }\n    while (queue.length) {\n        const cell = queue.shift();\n        const currRow = cell[0], currCol = cell[1];\n        for (const dir of dirs) {\n            const nextRow = currRow + dir[0], nextCol = currCol + dir[1];\n            if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && grid[nextRow][nextCol] == 1 && !visited[nextRow][nextCol]) {\n                visited[nextRow][nextCol] = true;\n                queue.push([nextRow, nextCol]);\n            }\n        }\n    }\n    let enclaves = 0;\n    for (let i = 1; i < m - 1; i++) {\n        for (let j = 1; j < n - 1; j++) {\n            if (grid[i][j] === 1 && !visited[i][j]) {\n                enclaves++;\n            }\n        }\n    }\n    return enclaves;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是网格 $\\textit{grid}$ 的行数和列数。广度优先搜索最多访问每个单元格一次，需要 $O(mn)$ 的时间，遍历网格统计飞地的数量也需要 $O(mn)$ 的时间。\n\n- 空间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是网格 $\\textit{grid}$ 的行数和列数。空间复杂度主要取决于 $\\textit{visited}$ 数组和队列空间，空间复杂度是 $O(mn)$。\n\n#### 方法三：并查集\n\n除了深度优先搜索和广度优先搜索的方法以外，也可以使用并查集判断每个陆地单元格是否和网格边界相连。\n\n并查集的核心思想是计算网格中的每个陆地单元格所在的连通分量。对于网格边界上的每个陆地单元格，其所在的连通分量中的所有陆地单元格都不是飞地。如果一个陆地单元格所在的连通分量不同于任何一个网格边界上的陆地单元格所在的连通分量，则该陆地单元格是飞地。\n\n并查集的做法是，遍历整个网格，对于网格中的每个陆地单元格，将其与所有相邻的陆地单元格做合并操作。由于需要判断每个陆地单元格所在的连通分量是否和网格边界相连，因此并查集还需要记录每个单元格是否和网格边界相连的信息，在合并操作时更新该信息。\n\n在遍历网格完成并查集的合并操作之后，再次遍历整个网格，通过并查集中的信息判断每个陆地单元格是否和网格边界相连，统计飞地的数量。\n\n```Java [sol3-Java]\nclass Solution {\n    public int numEnclaves(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        UnionFind uf = new UnionFind(grid);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int index = i * n + j;\n                    if (j + 1 < n && grid[i][j + 1] == 1) {\n                        uf.union(index, index + 1);\n                    }\n                    if (i + 1 < m && grid[i + 1][j] == 1) {\n                        uf.union(index, index + n);\n                    }\n                }\n            }\n        }\n        int enclaves = 0;\n        for (int i = 1; i < m - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                if (grid[i][j] == 1 && !uf.isOnEdge(i * n + j)) {\n                    enclaves++;\n                }\n            }\n        }\n        return enclaves;\n    }\n}\n\nclass UnionFind {\n    private int[] parent;\n    private boolean[] onEdge;\n    private int[] rank;\n\n    public UnionFind(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        parent = new int[m * n];\n        onEdge = new boolean[m * n];\n        rank = new int[m * n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int index = i * n + j;\n                    parent[index] = index;\n                    if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\n                        onEdge[index] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    public int find(int i) {\n        if (parent[i] != i) {\n            parent[i] = find(parent[i]);\n        }\n        return parent[i];\n    }\n\n    public void union(int x, int y) {\n        int rootx = find(x);\n        int rooty = find(y);\n        if (rootx != rooty) {\n            if (rank[rootx] > rank[rooty]) {\n                parent[rooty] = rootx;\n                onEdge[rootx] |= onEdge[rooty];\n            } else if (rank[rootx] < rank[rooty]) {\n                parent[rootx] = rooty;\n                onEdge[rooty] |= onEdge[rootx];\n            } else {\n                parent[rooty] = rootx;\n                onEdge[rootx] |= onEdge[rooty];\n                rank[rootx]++;\n            }\n        }\n    }\n\n    public boolean isOnEdge(int i) {\n        return onEdge[find(i)];\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int NumEnclaves(int[][] grid) {\n        int m = grid.Length, n = grid[0].Length;\n        UnionFind uf = new UnionFind(grid);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int index = i * n + j;\n                    if (j + 1 < n && grid[i][j + 1] == 1) {\n                        uf.Union(index, index + 1);\n                    }\n                    if (i + 1 < m && grid[i + 1][j] == 1) {\n                        uf.Union(index, index + n);\n                    }\n                }\n            }\n        }\n        int enclaves = 0;\n        for (int i = 1; i < m - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                if (grid[i][j] == 1 && !uf.IsOnEdge(i * n + j)) {\n                    enclaves++;\n                }\n            }\n        }\n        return enclaves;\n    }\n}\n\nclass UnionFind {\n    private int[] parent;\n    private bool[] onEdge;\n    private int[] rank;\n\n    public UnionFind(int[][] grid) {\n        int m = grid.Length, n = grid[0].Length;\n        parent = new int[m * n];\n        onEdge = new bool[m * n];\n        rank = new int[m * n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int index = i * n + j;\n                    parent[index] = index;\n                    if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\n                        onEdge[index] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    public int Find(int i) {\n        if (parent[i] != i) {\n            parent[i] = Find(parent[i]);\n        }\n        return parent[i];\n    }\n\n    public void Union(int x, int y) {\n        int rootx = Find(x);\n        int rooty = Find(y);\n        if (rootx != rooty) {\n            if (rank[rootx] > rank[rooty]) {\n                parent[rooty] = rootx;\n                onEdge[rootx] |= onEdge[rooty];\n            } else if (rank[rootx] < rank[rooty]) {\n                parent[rootx] = rooty;\n                onEdge[rooty] |= onEdge[rootx];\n            } else {\n                parent[rooty] = rootx;\n                onEdge[rootx] |= onEdge[rooty];\n                rank[rootx]++;\n            }\n        }\n    }\n\n    public bool IsOnEdge(int i) {\n        return onEdge[Find(i)];\n    }\n}\n```\n\n```C++ [sol3-C++]\nclass UnionFind {\npublic:\n    UnionFind(const vector<vector<int>> & grid) {\n        int m = grid.size(), n = grid[0].size();\n        this->parent = vector<int>(m * n);\n        this->onEdge = vector<bool>(m * n, false);\n        this->rank = vector<int>(m * n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int index = i * n + j;\n                    parent[index] = index;\n                    if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\n                        onEdge[index] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int find(int i) {\n        if (parent[i] != i) {\n            parent[i] = find(parent[i]);\n        }\n        return parent[i];\n    }\n\n    void uni(int x, int y) {\n        int rootx = find(x);\n        int rooty = find(y);\n        if (rootx != rooty) {\n            if (rank[rootx] > rank[rooty]) {\n                parent[rooty] = rootx;\n                onEdge[rootx] = onEdge[rootx] | onEdge[rooty];\n            } else if (rank[rootx] < rank[rooty]) {\n                parent[rootx] = rooty;\n                onEdge[rooty] = onEdge[rooty] | onEdge[rootx];\n            } else {\n                parent[rooty] = rootx;\n                onEdge[rootx] = onEdge[rootx] | onEdge[rooty];\n                rank[rootx]++;\n            }\n        }\n    }\n\n    bool isOnEdge(int i) {\n        return onEdge[find(i)];\n    }\nprivate:\n    vector<int> parent;\n    vector<bool> onEdge;\n    vector<int> rank;    \n};\n\nclass Solution {\npublic:\n    int numEnclaves(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        UnionFind uf(grid);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int index = i * n + j;\n                    if (j + 1 < n && grid[i][j + 1] == 1) {\n                        uf.uni(index, index + 1);\n                    }\n                    if (i + 1 < m && grid[i + 1][j] == 1) {\n                        uf.uni(index, index + n);\n                    }\n                }\n            }\n        }\n        int enclaves = 0;\n        for (int i = 1; i < m - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                if (grid[i][j] == 1 && !uf.isOnEdge(i * n + j)) {\n                    enclaves++;\n                }\n            }\n        }\n        return enclaves;\n    }\n};\n```\n\n```C [sol3-C]\ntypedef struct {\n    int * parent;\n    bool * onEdge;\n    int * rank;  \n} UnionFind;\n\nvoid initUnionFind(UnionFind * uf, const int** grid, int gridSize, int* gridColSize) {\n    int m = gridSize, n = gridColSize[0];\n    assert(NULL != uf);\n    uf->parent = (int *)malloc(sizeof(int) * m * n);\n    uf->onEdge = (bool *)malloc(sizeof(bool) * m * n);\n    uf->rank = (int *)malloc(sizeof(int) * m * n);\n    memset(uf->parent, 0, sizeof(int) * m * n);\n    memset(uf->onEdge, 0, sizeof(bool) * m * n);\n    memset(uf->rank, 0, sizeof(int) * m * n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                int index = i * n + j;\n                uf->parent[index] = index;\n                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\n                    uf->onEdge[index] = true;\n                }\n            }\n        }\n    }\n}\n\nvoid freeUnionFind(UnionFind * uf) {\n    free(uf->parent);\n    free(uf->onEdge);\n    free(uf->rank);\n}\n\nint find(UnionFind * uf, int i) {\n    if (uf->parent[i] != i) {\n        uf->parent[i] = find(uf, uf->parent[i]);\n    }\n    return uf->parent[i];\n}\n\nvoid uni(UnionFind * uf, int x, int y) {\n    int rootx = find(uf, x);\n    int rooty = find(uf, y);\n    if (rootx != rooty) {\n        if (uf->rank[rootx] > uf->rank[rooty]) {\n            uf->parent[rooty] = rootx;\n            uf->onEdge[rootx] = uf->onEdge[rootx] | uf->onEdge[rooty];\n        } else if (uf->rank[rootx] < uf->rank[rooty]) {\n            uf->parent[rootx] = rooty;\n            uf->onEdge[rooty] = uf->onEdge[rooty] | uf->onEdge[rootx];\n        } else {\n            uf->parent[rooty] = rootx;\n            uf->onEdge[rootx] = uf->onEdge[rootx] | uf->onEdge[rooty];\n            uf->rank[rootx]++;\n        }\n    }\n}\n\nbool isOnEdge(UnionFind * uf, int i) {\n    return uf->onEdge[find(uf, i)];\n}\n\nint numEnclaves(int** grid, int gridSize, int* gridColSize){\n    int m = gridSize, n = gridColSize[0];\n    UnionFind * uf = (UnionFind *)malloc(sizeof(UnionFind));\n    initUnionFind(uf, grid, gridSize, gridColSize);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                int index = i * n + j;\n                if (j + 1 < n && grid[i][j + 1] == 1) {\n                    uni(uf, index, index + 1);\n                }\n                if (i + 1 < m && grid[i + 1][j] == 1) {\n                    uni(uf, index, index + n);\n                }\n            }\n        }\n    }\n    int enclaves = 0;\n    for (int i = 1; i < m - 1; i++) {\n        for (int j = 1; j < n - 1; j++) {\n            if (grid[i][j] == 1 && !isOnEdge(uf, i * n + j)) {\n                enclaves++;\n            }\n        }\n    }\n    freeUnionFind(uf);\n    free(uf);\n    return enclaves;\n}\n```\n\n```Python [sol3-Python3]\nclass UnionFind:\n    def __init__(self, grid: List[List[int]]):\n        m, n = len(grid), len(grid[0])\n        self.parent = [0] * (m * n)\n        self.rank = [0] * (m * n)\n        self.onEdge = [False] * (m * n)\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                if v:\n                    idx = i * n + j\n                    self.parent[idx] = idx\n                    if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                        self.onEdge[idx] = True\n\n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def merge(self, x: int, y: int) -> None:\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] > self.rank[y]:\n            self.parent[y] = x\n            self.onEdge[x] |= self.onEdge[y]\n        elif self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n            self.onEdge[y] |= self.onEdge[x]\n        else:\n            self.parent[y] = x\n            self.onEdge[x] |= self.onEdge[y]\n            self.rank[x] += 1\n\nclass Solution:\n    def numEnclaves(self, grid: List[List[int]]) -> int:\n        uf = UnionFind(grid)\n        m, n = len(grid), len(grid[0])\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                if v:\n                    idx = i * n + j\n                    if j + 1 < n and grid[i][j + 1]:\n                        uf.merge(idx, idx + 1)\n                    if i + 1 < m and grid[i + 1][j]:\n                        uf.merge(idx, idx + n)\n        return sum(grid[i][j] and not uf.onEdge[uf.find(i * n + j)] for i in range(1, m - 1) for j in range(1, n - 1))\n```\n\n```go [sol3-Golang]\ntype unionFind struct {\n    parent []int\n    rank   []int\n    onEdge []bool\n}\n\nfunc newUnionFind(grid [][]int) unionFind {\n    m, n := len(grid), len(grid[0])\n    parent := make([]int, m*n)\n    rank := make([]int, m*n)\n    onEdge := make([]bool, m*n)\n    for i, row := range grid {\n        for j, v := range row {\n            if v == 1 {\n                idx := i*n + j\n                parent[idx] = idx\n                if i == 0 || i == m-1 || j == 0 || j == n-1 {\n                    onEdge[idx] = true\n                }\n            }\n        }\n    }\n    return unionFind{parent, rank, onEdge}\n}\n\nfunc (uf unionFind) find(x int) int {\n    if uf.parent[x] != x {\n        uf.parent[x] = uf.find(uf.parent[x])\n    }\n    return uf.parent[x]\n}\n\nfunc (uf unionFind) merge(x, y int) {\n    x, y = uf.find(x), uf.find(y)\n    if x == y {\n        return\n    }\n    if uf.rank[x] > uf.rank[y] {\n        uf.parent[y] = x\n        uf.onEdge[x] = uf.onEdge[x] || uf.onEdge[y]\n    } else if uf.rank[x] < uf.rank[y] {\n        uf.parent[x] = y\n        uf.onEdge[y] = uf.onEdge[y] || uf.onEdge[x]\n    } else {\n        uf.parent[y] = x\n        uf.onEdge[x] = uf.onEdge[x] || uf.onEdge[y]\n        uf.rank[x]++\n    }\n}\n\nfunc numEnclaves(grid [][]int) (ans int) {\n    uf := newUnionFind(grid)\n    m, n := len(grid), len(grid[0])\n    for i, row := range grid {\n        for j, v := range row {\n            if v == 1 {\n                idx := i*n + j\n                if j+1 < n && grid[i][j+1] == 1 {\n                    uf.merge(idx, idx+1)\n                }\n                if i+1 < m && grid[i+1][j] == 1 {\n                    uf.merge(idx, idx+n)\n                }\n            }\n        }\n    }\n    for i := 1; i < m-1; i++ {\n        for j := 1; j < n-1; j++ {\n            if grid[i][j] == 1 && !uf.onEdge[uf.find(i*n+j)] {\n                ans++\n            }\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar numEnclaves = function(grid) {\n    const m = grid.length, n = grid[0].length;\n    const uf = new UnionFind(grid);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1) {\n                const index = i * n + j;\n                if (j + 1 < n && grid[i][j + 1] === 1) {\n                    uf.union(index, index + 1);\n                }\n                if (i + 1 < m && grid[i + 1][j] === 1) {\n                    uf.union(index, index + n);\n                }\n            }\n        }\n    }\n    let enclaves = 0;\n    for (let i = 1; i < m - 1; i++) {\n        for (let j = 1; j < n - 1; j++) {\n            if (grid[i][j] === 1 && !uf.isOnEdge(i * n + j)) {\n                enclaves++;\n            }\n        }\n    }\n    return enclaves;\n}\n\nclass UnionFind {\n    constructor(grid) {\n        const m = grid.length, n = grid[0].length;\n        this.parent = new Array(m * n).fill(0);\n        this.onEdge = new Array(m * n).fill(false);\n        this.rank = new Array(m * n).fill(0);\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                if (grid[i][j] === 1) {\n                    const index = i * n + j;\n                    this.parent[index] = index;\n                    if (i === 0 || i === m - 1 || j === 0 || j === n - 1) {\n                        this.onEdge[index] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    find(i) {\n        if (this.parent[i] !== i) {\n            this.parent[i] = this.find(this.parent[i]);\n        }\n        return this.parent[i];\n    }\n\n    union(x, y) {\n        const rootx = this.find(x);\n        const rooty = this.find(y);\n        if (rootx !== rooty) {\n            if (this.rank[rootx] > this.rank[rooty]) {\n                this.parent[rooty] = rootx;\n                this.onEdge[rootx] |= this.onEdge[rooty];\n            } else if (this.rank[rootx] < this.rank[rooty]) {\n                this.parent[rootx] = rooty;\n                this.onEdge[rooty] |= this.onEdge[rootx];\n            } else {\n                this.parent[rooty] = rootx;\n                this.onEdge[rootx] |= this.onEdge[rooty];\n                this.rank[rootx]++;\n            }\n        }\n    }\n\n    isOnEdge(i) {\n        return this.onEdge[this.find(i)];\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn \\times \\alpha(mn))$，其中 $m$ 和 $n$ 分别是网格 $\\textit{grid}$ 的行数和列数，$\\alpha$ 是反阿克曼函数。这里的并查集使用了路径压缩和按秩合并，单次操作的时间复杂度是 $O(\\alpha(mn))$，因此整个网格的并查集操作的时间复杂度是 $O(mn \\times \\alpha(mn))$，并查集操作之后需要 $O(mn \\times \\alpha(mn))$ 的时间再次遍历网格统计飞地的数量，因此总时间复杂度是 $O(mn \\times \\alpha(mn))$。\n\n- 空间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是网格 $\\textit{grid}$ 的行数和列数。并查集需要 $O(mn)$ 的空间。"
}