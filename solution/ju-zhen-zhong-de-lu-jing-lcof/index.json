{
	"titleSlug": "ju-zhen-zhong-de-lu-jing-lcof",
	"slug": "ju-zhen-zhong-de-lu-jing-by-leetcode-sol-3lox",
	"url": "https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/ju-zhen-zhong-de-lu-jing-by-leetcode-sol-3lox/",
	"content": "#### 方法一：回溯\n\n**思路与算法**\n\n设函数 $\\text{check}(i, j, k)$ 表示判断以网格的 $(i, j)$ 位置出发，能否搜索到单词 $\\textit{word}[k..]$，其中 $\\textit{word}[k..]$ 表示字符串 $\\textit{word}$ 从第 $k$ 个字符开始的后缀子串。如果能搜索到，则返回 $\\texttt{true}$，反之返回  $\\texttt{false}$。函数 $\\text{check}(i, j, k)$ 的执行步骤如下：\n- 如果 $\\textit{board}[i][j] \\neq s[k]$，当前字符不匹配，直接返回 $\\texttt{false}$。\n- 如果当前已经访问到字符串的末尾，且对应字符依然匹配，此时直接返回 $\\texttt{true}$。\n- 否则，遍历当前位置的所有相邻位置。如果从某个相邻位置出发，能够搜索到子串 $\\textit{word}[k+1..]$，则返回 $\\texttt{true}$，否则返回 $\\texttt{false}$。\n\n这样，我们对每一个位置 $(i,j)$ 都调用函数 $\\text{check}(i, j, 0)$ 进行检查：只要有一处返回 $\\texttt{true}$，就说明网格中能够找到相应的单词，否则说明不能找到。\n\n为了防止重复遍历相同的位置，需要额外维护一个与 $\\textit{board}$ 等大的 $\\textit{visited}$ 数组，用于标识每个位置是否被访问过。每次遍历相邻位置时，需要跳过已经被访问的位置。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool check(vector<vector<char>>& board, vector<vector<int>>& visited, int i, int j, string& s, int k) {\n        if (board[i][j] != s[k]) {\n            return false;\n        } else if (k == s.length() - 1) {\n            return true;\n        }\n        visited[i][j] = true;\n        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        bool result = false;\n        for (const auto& dir: directions) {\n            int newi = i + dir.first, newj = j + dir.second;\n            if (newi >= 0 && newi < board.size() && newj >= 0 && newj < board[0].size()) {\n                if (!visited[newi][newj]) {\n                    bool flag = check(board, visited, newi, newj, s, k + 1);\n                    if (flag) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n        visited[i][j] = false;\n        return result;\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n        int h = board.size(), w = board[0].size();\n        vector<vector<int>> visited(h, vector<int>(w));\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                bool flag = check(board, visited, i, j, word, 0);\n                if (flag) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        int h = board.length, w = board[0].length;\n        boolean[][] visited = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                boolean flag = check(board, visited, i, j, word, 0);\n                if (flag) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) {\n        if (board[i][j] != s.charAt(k)) {\n            return false;\n        } else if (k == s.length() - 1) {\n            return true;\n        }\n        visited[i][j] = true;\n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        boolean result = false;\n        for (int[] dir : directions) {\n            int newi = i + dir[0], newj = j + dir[1];\n            if (newi >= 0 && newi < board.length && newj >= 0 && newj < board[0].length) {\n                if (!visited[newi][newj]) {\n                    boolean flag = check(board, visited, newi, newj, s, k + 1);\n                    if (flag) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n        visited[i][j] = false;\n        return result;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def check(i: int, j: int, k: int) -> bool:\n            if board[i][j] != word[k]:\n                return False\n            if k == len(word) - 1:\n                return True\n            \n            visited.add((i, j))\n            result = False\n            for di, dj in directions:\n                newi, newj = i + di, j + dj\n                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):\n                    if (newi, newj) not in visited:\n                        if check(newi, newj, k + 1):\n                            result = True\n                            break\n            \n            visited.remove((i, j))\n            return result\n\n        h, w = len(board), len(board[0])\n        visited = set()\n        for i in range(h):\n            for j in range(w):\n                if check(i, j, 0):\n                    return True\n        \n        return False\n```\n\n```JavaScript [sol1-JavaScript]\nvar exist = function(board, word) {\n    const h = board.length, w = board[0].length;\n    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    const visited = new Array(h);\n    for (let i = 0; i < visited.length; ++i) {\n        visited[i] = new Array(w).fill(false);\n    }\n    const check = (i, j, s, k) => {\n        if (board[i][j] != s.charAt(k)) {\n            return false;\n        } else if (k == s.length - 1) {\n            return true;\n        }\n        visited[i][j] = true;\n        let result = false;\n        for (const [dx, dy] of directions) {\n            let newi = i + dx, newj = j + dy;\n            if (newi >= 0 && newi < h && newj >= 0 && newj < w) {\n                if (!visited[newi][newj]) {\n                    const flag = check(newi, newj, s, k + 1);\n                    if (flag) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n        visited[i][j] = false;\n        return result;\n    }\n\n    for (let i = 0; i < h; i++) {\n        for (let j = 0; j < w; j++) {\n            const flag = check(i, j, word, 0);\n            if (flag) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n```\n\n```Golang [sol1-Golang]\ntype pair struct{ x, y int }\n\nvar directions = []pair{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} // 上下左右\n\nfunc exist(board [][]byte, word string) bool {\n\th, w := len(board), len(board[0])\n\tvis := make([][]bool, h)\n\tfor i := range vis {\n\t\tvis[i] = make([]bool, w)\n\t}\n\tvar check func(i, j, k int) bool\n\tcheck = func(i, j, k int) bool {\n\t\tif board[i][j] != word[k] { // 剪枝：当前字符不匹配\n\t\t\treturn false\n\t\t}\n\t\tif k == len(word)-1 { // 单词存在于网格中\n\t\t\treturn true\n\t\t}\n\t\tvis[i][j] = true\n\t\tdefer func() { vis[i][j] = false }() // 回溯时还原已访问的单元格\n\t\tfor _, dir := range directions {\n\t\t\tif newI, newJ := i+dir.x, j+dir.y; 0 <= newI && newI < h && 0 <= newJ && newJ < w && !vis[newI][newJ] {\n\t\t\t\tif check(newI, newJ, k+1) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfor i, row := range board {\n\t\tfor j := range row {\n\t\t\tif check(i, j, 0) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n```\n\n```C [sol1-C]\nint directions[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nbool check(char** board, int boardSize, int boardColSize, int** visited, int i, int j, char* s, int sSize, int k) {\n    if (board[i][j] != s[k]) {\n        return false;\n    } else if (k == sSize - 1) {\n        return true;\n    }\n    visited[i][j] = true;\n    bool result = false;\n    for (int sel = 0; sel < 4; sel++) {\n        int newi = i + directions[sel][0], newj = j + directions[sel][1];\n        if (newi >= 0 && newi < boardSize && newj >= 0 && newj < boardColSize) {\n            if (!visited[newi][newj]) {\n                bool flag = check(board, boardSize, boardColSize, visited, newi, newj, s, sSize, k + 1);\n                if (flag) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n    }\n    visited[i][j] = false;\n    return result;\n}\n\nbool exist(char** board, int boardSize, int* boardColSize, char* word) {\n    int** visited = malloc(sizeof(int*) * boardSize);\n    for (int i = 0; i < boardSize; i++) {\n        visited[i] = malloc(sizeof(int) * boardColSize[0]);\n        memset(visited[i], 0, sizeof(int) * boardColSize[0]);\n    }\n    int wordSize = strlen(word);\n    for (int i = 0; i < boardSize; i++) {\n        for (int j = 0; j < boardColSize[0]; j++) {\n            bool flag = check(board, boardSize, boardColSize[0], visited, i, j, word, wordSize, 0);\n            if (flag) {\n                return true;\n            }\n        }\n    }\n    return false;\n} \n```\n\n**复杂度分析**\n\n- 时间复杂度：一个非常宽松的上界为 $O(MN \\cdot 3^L)$，其中 $M, N$ 为网格的长度与宽度，$L$ 为字符串 $\\textit{word}$ 的长度。在每次调用函数 $\\text{check}$ 时，除了第一次可以进入 $4$ 个分支以外，其余时间我们最多会进入 $3$ 个分支（因为每个位置只能使用一次，所以走过来的分支没法走回去）。由于单词长为 $L$，故 $\\text{check}(i, j, 0)$ 的时间复杂度为 $O(3^L)$，而我们要执行 $O(MN)$ 次检查。然而，由于剪枝的存在，我们在遇到不匹配或已访问的字符时会提前退出，终止递归流程。因此，实际的时间复杂度会远远小于 $\\Theta(MN \\cdot 3^L)$。\n\n- 空间复杂度：$O(MN)$。我们额外开辟了 $O(MN)$ 的 $\\textit{visited}$ 数组，同时栈的深度最大为 $O(\\min(L, MN))$。"
}