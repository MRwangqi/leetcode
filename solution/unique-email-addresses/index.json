{
	"titleSlug": "unique-email-addresses",
	"slug": "du-te-de-dian-zi-you-jian-di-zhi-by-leet-f178",
	"url": "https://leetcode-cn.com/problems/unique-email-addresses/solution/du-te-de-dian-zi-you-jian-di-zhi-by-leet-f178/",
	"content": "#### 方法一：哈希表\n\n根据题意，我们需要将每个邮件地址的本地名按照规则转换，具体来说：\n\n- 去掉本地名中第一个加号之后的部分（包括加号）；\n- 去掉本地名中所有的句点。\n\n转换后得到了实际的邮件地址。\n\n为了计算不同地址的数目，我们可以用一个哈希表记录所有的邮件地址，答案为哈希表的长度。\n\n```Python [sol1-Python3]\nclass Solution:\n    def numUniqueEmails(self, emails: List[str]) -> int:\n        emailSet = set()\n        for email in emails:\n            i = email.index('@')\n            local = email[:i].split('+', 1)[0]  # 去掉本地名第一个加号之后的部分\n            local = local.replace('.', '')  # 去掉本地名中所有的句点\n            emailSet.add(local + email[i:])\n        return len(emailSet)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int numUniqueEmails(vector<string> &emails) {\n        unordered_set<string> emailSet;\n        for (auto &email: emails) {\n            string local;\n            for (char c: email) {\n                if (c == '+' || c == '@') {\n                    break;\n                }\n                if (c != '.') {\n                    local += c;\n                }\n            }\n            emailSet.emplace(local + email.substr(email.find('@')));\n        }\n        return emailSet.size();\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int numUniqueEmails(String[] emails) {\n        Set<String> emailSet = new HashSet<String>();\n        for (String email : emails) {\n            int i = email.indexOf('@');\n            String local = email.substring(0, i).split(\"\\\\+\")[0]; // 去掉本地名第一个加号之后的部分\n            local = local.replace(\".\", \"\"); // 去掉本地名中所有的句点\n            emailSet.add(local + email.substring(i));\n        }\n        return emailSet.size();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int NumUniqueEmails(string[] emails) {\n        ISet<string> emailSet = new HashSet<string>();\n        foreach (string email in emails) {\n            int i = email.IndexOf('@');\n            string local = email.Substring(0, i).Split(\"+\")[0]; // 去掉本地名第一个加号之后的部分\n            local = local.Replace(\".\", \"\"); // 去掉本地名中所有的句点\n            emailSet.Add(local + email.Substring(i));\n        }\n        return emailSet.Count;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc numUniqueEmails(emails []string) int {\n    emailSet := map[string]struct{}{}\n    for _, email := range emails {\n        i := strings.IndexByte(email, '@')\n        local := strings.SplitN(email[:i], \"+\", 2)[0] // 去掉本地名第一个加号之后的部分\n        local = strings.ReplaceAll(local, \".\", \"\")    // 去掉本地名中所有的句点\n        emailSet[local+email[i:]] = struct{}{}\n    }\n    return len(emailSet)\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    char *key;\n    UT_hash_handle hh;\n} HashItem;\n\nint numUniqueEmails(char ** emails, int emailsSize) {\n    HashItem *emailSet = NULL;\n    for (int i = 0; i < emailsSize; i++) {\n        char local[101];\n        int pos = 0;\n        for (int j = 0; emails[i][j] != 0; j++) {\n            if (emails[i][j] == '+' || emails[i][j] == '@') {\n                break;\n            }\n            if (emails[i][j] != '.') {\n                local[pos++] = emails[i][j];\n            }\n        }\n        sprintf(local + pos, \"%s\", strchr(emails[i], '@'));\n        HashItem *pEntry = NULL;\n        HASH_FIND_STR(emailSet, local, pEntry);\n        if (NULL == pEntry) {\n            pEntry = (HashItem *)malloc(sizeof(HashItem));\n            pEntry->key = (char *)malloc(sizeof(char) * (strlen(local) + 1));\n            strcpy(pEntry->key, local);\n            HASH_ADD_STR(emailSet, key, pEntry);\n        }\n    }\n    return HASH_COUNT(emailSet);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar numUniqueEmails = function(emails) {\n    const emailSet = new Set();\n    for (const email of emails) {\n        const i = email.indexOf('@');\n        let local = email.slice(0, i).split(\"+\")[0]; // 去掉本地名第一个加号之后的部分\n        local = local.replaceAll(\".\", \"\"); // 去掉本地名中所有的句点\n        emailSet.add(local + email.slice(i));\n    }\n    return emailSet.size;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(L)$，其中 $L$ 是 $\\textit{emails}$ 中字符串的长度之和。\n\n- 空间复杂度：$O(L)$。哈希表需要 $O(L)$ 的空间。"
}