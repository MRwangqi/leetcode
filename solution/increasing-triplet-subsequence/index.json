{
	"titleSlug": "increasing-triplet-subsequence",
	"slug": "di-zeng-de-san-yuan-zi-xu-lie-by-leetcod-dp2r",
	"url": "https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/di-zeng-de-san-yuan-zi-xu-lie-by-leetcod-dp2r/",
	"content": "#### 方法一：双向遍历\n\n如果数组 $\\textit{nums}$ 中存在一个下标 $i$ 满足 $1 \\le i < n - 1$，使得在 $\\textit{nums}[i]$ 的左边存在一个元素小于 $\\textit{nums}[i]$ 且在 $\\textit{nums}[i]$ 的右边存在一个元素大于 $\\textit{nums}[i]$，则数组 $\\textit{nums}$ 中存在递增的三元子序列。\n\n在 $\\textit{nums}[i]$ 的左边存在一个元素小于 $\\textit{nums}[i]$ 等价于在 $\\textit{nums}[i]$ 的左边的最小元素小于 $\\textit{nums}[i]$，在 $\\textit{nums}[i]$ 的右边存在一个元素大于 $\\textit{nums}[i]$ 等价于在 $\\textit{nums}[i]$ 的右边的最大元素大于 $\\textit{nums}[i]$，因此可以维护数组 $\\textit{nums}$ 中的每个元素左边的最小值和右边的最大值。\n\n创建两个长度为 $n$ 的数组 $\\textit{leftMin}$ 和 $\\textit{rightMax}$，对于 $0 \\le i < n$，$\\textit{leftMin}[i]$ 表示 $\\textit{nums}[0]$ 到 $\\textit{nums}[i]$ 中的最小值，$\\textit{rightMax}[i]$ 表示 $\\textit{nums}[i]$ 到 $\\textit{nums}[n - 1]$ 中的最大值。\n\n数组 $\\textit{leftMin}$ 的计算方式如下：\n\n- $\\textit{leftMin}[0] = \\textit{nums}[0]$；\n\n- 从左到右遍历数组 $\\textit{nums}$，对于 $1 \\le i < n$，$\\textit{leftMin}[i] = \\min(\\textit{leftMin}[i - 1], \\textit{nums}[i])$。\n\n数组 $\\textit{rightMax}$ 的计算方式如下：\n\n- $\\textit{rightMax}[n - 1] = \\textit{nums}[n - 1]$；\n\n- 从右到左遍历数组 $\\textit{nums}$，对于 $0 \\le i < n - 1$，$\\textit{rightMax}[i] = \\max(\\textit{rightMax}[i + 1], \\textit{nums}[i])$。\n\n得到数组 $\\textit{leftMin}$ 和 $\\textit{rightMax}$ 之后，遍历 $1 \\le i < n - 1$ 的每个下标 $i$，如果存在一个下标 $i$ 满足 $\\textit{leftMin}[i - 1] < \\textit{nums}[i] < \\textit{rightMax}[i + 1]$，则返回 $\\text{true}$，如果不存在这样的下标 $i$，则返回 $\\text{false}$。\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int n = nums.length;\n        if (n < 3) {\n            return false;\n        }\n        int[] leftMin = new int[n];\n        leftMin[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            leftMin[i] = Math.min(leftMin[i - 1], nums[i]);\n        }\n        int[] rightMax = new int[n];\n        rightMax[n - 1] = nums[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            rightMax[i] = Math.max(rightMax[i + 1], nums[i]);\n        }\n        for (int i = 1; i < n - 1; i++) {\n            if (nums[i] > leftMin[i - 1] && nums[i] < rightMax[i + 1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool IncreasingTriplet(int[] nums) {\n        int n = nums.Length;\n        if (n < 3) {\n            return false;\n        }\n        int[] leftMin = new int[n];\n        leftMin[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            leftMin[i] = Math.Min(leftMin[i - 1], nums[i]);\n        }\n        int[] rightMax = new int[n];\n        rightMax[n - 1] = nums[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            rightMax[i] = Math.Max(rightMax[i + 1], nums[i]);\n        }\n        for (int i = 1; i < n - 1; i++) {\n            if (nums[i] > leftMin[i - 1] && nums[i] < rightMax[i + 1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        int n = nums.size();\n        if (n < 3) {\n            return false;\n        }\n        vector<int> leftMin(n);\n        leftMin[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            leftMin[i] = min(leftMin[i - 1], nums[i]);\n        }\n        vector<int> rightMax(n);\n        rightMax[n - 1] = nums[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            rightMax[i] = max(rightMax[i + 1], nums[i]);\n        }\n        for (int i = 1; i < n - 1; i++) {\n            if (nums[i] > leftMin[i - 1] && nums[i] < rightMax[i + 1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) > (b) ? (b) : (a))\n#define MAX(a, b) ((a) < (b) ? (b) : (a))\n\nbool increasingTriplet(int* nums, int numsSize){\n    if (numsSize < 3) {\n        return false;\n    }\n    int * leftMin = (int *)malloc(sizeof(int) * numsSize);\n    int * rightMax = (int *)malloc(sizeof(int) * numsSize);\n    leftMin[0] = nums[0];\n    for (int i = 1; i < numsSize; i++) {\n        leftMin[i] = MIN(leftMin[i - 1], nums[i]);\n    }\n    rightMax[numsSize - 1] = nums[numsSize - 1];\n    for (int i = numsSize - 2; i >= 0; i--) {\n        rightMax[i] = MAX(rightMax[i + 1], nums[i]);\n    }\n    for (int i = 1; i < numsSize - 1; i++) {\n        if (nums[i] > leftMin[i - 1] && nums[i] < rightMax[i + 1]) {\n            return true;\n        }\n    }\n    free(leftMin);\n    free(rightMax);\n    return false;\n}\n```\n\n```go [sol1-Golang]\nfunc increasingTriplet(nums []int) bool {\n    n := len(nums)\n    if n < 3 {\n        return false\n    }\n    leftMin := make([]int, n)\n    leftMin[0] = nums[0]\n    for i := 1; i < n; i++ {\n        leftMin[i] = min(leftMin[i-1], nums[i])\n    }\n    rightMax := make([]int, n)\n    rightMax[n-1] = nums[n-1]\n    for i := n - 2; i >= 0; i-- {\n        rightMax[i] = max(rightMax[i+1], nums[i])\n    }\n    for i := 1; i < n-1; i++ {\n        if nums[i] > leftMin[i-1] && nums[i] < rightMax[i+1] {\n            return true\n        }\n    }\n    return false\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def increasingTriplet(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n < 3:\n            return False\n        leftMin = [0] * n\n        leftMin[0] = nums[0]\n        for i in range(1, n):\n            leftMin[i] = min(leftMin[i - 1], nums[i])\n        rightMax = [0] * n\n        rightMax[n - 1] = nums[n - 1]\n        for i in range(n - 2, -1, -1):\n            rightMax[i] = max(rightMax[i + 1], nums[i])\n        for i in range(1, n - 1):\n            if leftMin[i - 1] < nums[i] < rightMax[i + 1]:\n                return True\n        return False\n```\n\n```JavaScript [sol1-JavaScript]\nvar increasingTriplet = function(nums) {\n    const n = nums.length;\n    if (n < 3) {\n        return false;\n    }\n    const leftMin = new Array(n).fill(0);\n    leftMin[0] = nums[0];\n    for (let i = 1; i < n; i++) {\n        leftMin[i] = Math.min(leftMin[i - 1], nums[i]);\n    }\n    const rightMax = new Array(n).fill(0);\n    rightMax[n - 1] = nums[n - 1];\n    for (let i = n - 2; i >= 0; i--) {\n        rightMax[i] = Math.max(rightMax[i + 1], nums[i]);\n    }\n    for (let i = 1; i < n - 1; i++) {\n        if (nums[i] > leftMin[i - 1] && nums[i] < rightMax[i + 1]) {\n            return true;\n        }\n    }\n    return false;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。需要遍历数组三次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。需要创建两个长度为 $n$ 的数组 $\\textit{leftMin}$ 和 $\\textit{rightMax}$。\n\n#### 方法二：贪心\n\n可以使用贪心的方法将空间复杂度降到 $O(1)$。从左到右遍历数组 $\\textit{nums}$，遍历过程中维护两个变量 $\\textit{first}$ 和 $\\textit{second}$，分别表示递增的三元子序列中的第一个数和第二个数，任何时候都有 $\\textit{first} < \\textit{second}$。\n\n初始时，$\\textit{first} = \\textit{nums}[0]$，$\\textit{second} = +\\infty$。对于 $1 \\le i < n$，当遍历到下标 $i$ 时，令 $\\textit{num} = \\textit{nums}[i]$，进行如下操作：\n\n1. 如果 $\\textit{num} > \\textit{second}$，则找到了一个递增的三元子序列，返回 $\\text{true}$；\n\n2. 否则，如果 $\\textit{num} > \\textit{first}$，则将 $\\textit{second}$ 的值更新为 $\\textit{num}$；\n\n3. 否则，将 $\\textit{first}$ 的值更新为 $\\textit{num}$。\n\n如果遍历结束时没有找到递增的三元子序列，返回 $\\text{false}$。\n\n上述做法的贪心思想是：为了找到递增的三元子序列，$\\textit{first}$ 和 $\\textit{second}$ 应该尽可能地小，此时找到递增的三元子序列的可能性更大。\n\n假设 $(\\textit{first}, \\textit{second}, \\textit{num})$ 是一个递增的三元子序列，如果存在 $\\textit{second'}$ 满足 $\\textit{first} < \\textit{second'} < \\textit{second}$ 且 $\\textit{second'}$ 的下标位于 $\\textit{first}$ 的下标和 $\\textit{num}$ 的下标之间，则 $(\\textit{first}, \\textit{second'}, \\textit{num})$ 也是一个递增的三元子序列。但是当 $(\\textit{first}, \\textit{second'}, \\textit{num})$ 是递增的三元子序列时，由于 $\\textit{num}$ 不一定大于 $\\textit{second}$，因此 $(\\textit{first}, \\textit{second}, \\textit{num})$ 未必是递增的三元子序列。由此可见，为了使找到递增的三元子序列的可能性更大，三元子序列的第二个数应该尽可能地小，将 $\\textit{second'}$ 作为三元子序列的第二个数优于将 $\\textit{second}$ 作为三元子序列的第二个数。\n\n同理可得，三元子序列的第一个数也应该尽可能地小。\n\n如果遍历过程中遇到的所有元素都大于 $\\textit{first}$，则当遇到 $\\textit{num} > \\textit{second}$ 时，$\\textit{first}$ 一定出现在 $\\textit{second}$ 的前面，$\\textit{second}$ 一定出现在 $\\textit{num}$ 的前面，$(\\textit{first}, \\textit{second}, \\textit{num})$ 即为递增的三元子序列。\n\n如果遍历过程中遇到小于 $\\textit{first}$ 的元素，则会用该元素更新 $\\textit{first}$，虽然更新后的 $\\textit{first}$ 出现在 $\\textit{second}$ 的后面，但是在 $\\textit{second}$ 的前面一定存在一个元素 $\\textit{first'}$ 小于 $\\textit{second}$，因此当遇到 $\\textit{num} > \\textit{second}$ 时，$(\\textit{first'}, \\textit{second}, \\textit{num})$ 即为递增的三元子序列。\n\n根据上述分析可知，当遇到 $\\textit{num} > \\textit{second}$ 时，一定存在一个递增的三元子序列，该三元子序列的第二个数和第三个数分别是 $\\textit{second}$ 和 $\\textit{num}$，因此返回 $\\text{true}$。\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int n = nums.length;\n        if (n < 3) {\n            return false;\n        }\n        int first = nums[0], second = Integer.MAX_VALUE;\n        for (int i = 1; i < n; i++) {\n            int num = nums[i];\n            if (num > second) {\n                return true;\n            } else if (num > first) {\n                second = num;\n            } else {\n                first = num;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public bool IncreasingTriplet(int[] nums) {\n        int n = nums.Length;\n        if (n < 3) {\n            return false;\n        }\n        int first = nums[0], second = int.MaxValue;\n        for (int i = 1; i < n; i++) {\n            int num = nums[i];\n            if (num > second) {\n                return true;\n            } else if (num > first) {\n                second = num;\n            } else {\n                first = num;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        int n = nums.size();\n        if (n < 3) {\n            return false;\n        }\n        int first = nums[0], second = INT_MAX;\n        for (int i = 1; i < n; i++) {\n            int num = nums[i];\n            if (num > second) {\n                return true;\n            } else if (num > first) {\n                second = num;\n            } else {\n                first = num;\n            }\n        }\n        return false;\n    }\n};\n```\n\n```C [sol2-C]\nbool increasingTriplet(int* nums, int numsSize){\n    if (numsSize < 3) {\n        return false;\n    }\n    int first = nums[0], second = INT_MAX;\n    for (int i = 1; i < numsSize; i++) {\n        int num = nums[i];\n        if (num > second) {\n            return true;\n        } else if (num > first) {\n            second = num;\n        } else {\n            first = num;\n        }\n    }\n    return false;\n}\n```\n\n```go [sol2-Golang]\nfunc increasingTriplet(nums []int) bool {\n    n := len(nums)\n    if n < 3 {\n        return false\n    }\n    first, second := nums[0], math.MaxInt32\n    for i := 1; i < n; i++ {\n        num := nums[i]\n        if num > second {\n            return true\n        } else if num > first {\n            second = num\n        } else {\n            first = num\n        }\n    }\n    return false\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def increasingTriplet(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n < 3:\n            return False\n        first, second = nums[0], float('inf')\n        for i in range(1, n):\n            num = nums[i]\n            if num > second:\n                return True\n            if num > first:\n                second = num\n            else:\n                first = num\n        return False\n```\n\n```JavaScript [sol2-JavaScript]\nvar increasingTriplet = function(nums) {\n    const n = nums.length;\n    if (n < 3) {\n        return false;\n    }\n    let first = nums[0], second = Number.MAX_VALUE;\n    for (let i = 1; i < n; i++) {\n        const num = nums[i];\n        if (num > second) {\n            return true;\n        } else if (num > first) {\n            second = num;\n        } else {\n            first = num;\n        }\n    }\n    return false;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。需要遍历数组一次。\n\n- 空间复杂度：$O(1)$。"
}