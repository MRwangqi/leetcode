{
	"titleSlug": "find-elements-in-a-contaminated-binary-tree",
	"slug": "by-luobailin-remu",
	"url": "https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/solution/by-luobailin-remu/",
	"content": "## 时间复杂度：```log(N)```\n## 空间复杂度：```log(N)```\n\n## 原理：\n\n如果当前节点值为 **x**，那么 **```left.val = 2 * x + 1```** 并且 **```right.val = 2 * x + 2```**\n\n由此可知，**```left.val```** 一定为 **奇数**，**```right.val```** 一定为 **偶数**\n\n那么可以利用这一特性进行 **反向推导**\n\n## 举个🌰：查找 13 是否在树中\n\n因为 **13** 为奇数，那么通过 ```2 * x + 1 === 13``` 可得 ```x === 6``` , **6** 的 ```left``` 为 **13**\n\n递归查找 **6**\n\n因为 **6** 为偶数，那么通过 ```2 * x + 2 === 6``` 可得 ```x === 2```, **2** 的 ```right``` 为 **6**\n\n上述操作进行递归处理，最终得到一个访问路径栈 ```stack```\n\n```typescript\n[\n  { val: 6, nextDirection: 'left' },\n  { val: 2, nextDirection: 'right' },\n  { val: 0, nextDirection: 'right' },\n]\n// 注：实际过程可不存储 val 值\n// 上述过程表示：\n// 0 的 right 为 2\n// 2 的 right 为 6\n// 6 的 left 为 target\n```\n\n## 总结：\n1. 先递归查找访问路径，从而得到一个 ```nextDirection``` 栈\n2. 从根节点开始，当 ```root``` 及 ```stack``` 不为空的时候，依次对栈顶元素进行出栈处理\n3. 最终判断 ```stack``` 为空时，```root.val``` 是否等于 ```target```\n\n## 完整代码（TypeScript）：\n\n```typescript\nclass FindElements {\n    constructor(private root: TreeNode | null) {\n        this.root = this.recoverTree(root, 0)\n    }\n    \n    find(target: number): boolean {\n        if (target === 0) return true\n        \n        // 1.还原访问路径\n        const stack = this.recoverPath(target, [])\n        \n        // 2.查找\n        let root = this.root\n        while(stack.length && root) {\n            const direction = stack.pop()\n            root = root[direction]\n        }\n        return stack.length > 0 || !root ? false : root.val === target\n    }\n    \n    /**\n     * 利用 left 为奇数，right 为偶数特性还原访问路径\n     */\n    private recoverPath(target: number, stack: ('left' | 'right')[]) {\n        if (target === 0) return stack\n        \n        let v:number\n        if (target % 2 === 0) {\n            v = (target - 2) / 2\n            stack.push('right')\n        } else {\n            v = (target - 1) / 2\n            stack.push('left')\n        }\n        \n        this.recoverPath(v, stack)\n        return stack\n    }\n    \n    /**\n     * 恢复被污染的树\n    */\n    private recoverTree(root: TreeNode | null, v: number) {\n        if (!root)  return\n        \n        root.val = v\n        this.recoverTree(root.left, v * 2 + 1)\n        this.recoverTree(root.right, v * 2 + 2)\n        return root\n    }\n}\n```"
}