{
	"titleSlug": "gcd-sort-of-an-array",
	"slug": "by-zerzerzerz-fkfo",
	"url": "https://leetcode-cn.com/problems/gcd-sort-of-an-array/solution/by-zerzerzerz-fkfo/",
	"content": "### 解题思路\n- 为什么排序之后要判断parent是否相同\n\t- 假设排序前后这两个元素不一样，说明交换了，交换的两个元素一定是属于同一个group的，因此新老数组相同位置的元素必须有相同的parent\n\t- 要注意merge之后，有些节点的parent还不是根节点，因此需要使用find查询的时候进行路径压缩\n- [参考这个题目](https://leetcode.cn/problems/largest-component-size-by-common-factor/)，让每个数和自己的因数归为一类\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    static const int MAX_LEN = 1e5+1;\n    int parent[MAX_LEN];\n\n    int find(int i){\n        if(parent[i]!=i) parent[i] = find(parent[i]);\n        return parent[i];\n    }\n\n    void merge(int i, int j){\n        i = find(i);\n        j = find(j);\n        if(i!=j) parent[i]=j;\n    }\n\n    void init(){\n        for(int i=0; i<MAX_LEN; ++i){\n            parent[i] = i;\n        }\n    }\n\n    bool gcdSort(vector<int>& nums) {\n        init();\n        vector<int> nums_old = nums;\n        for(int n:nums){\n            for(int i=2; i*i<=n; ++i){\n                if(n%i==0){\n                    merge(n,i);\n                    merge(n,n/i);\n                }\n            }\n        }\n\n        sort(nums.begin(),nums.end());\n\n        int len = nums.size();\n        for(int i=0; i<len; ++i){\n            if(find(nums[i]) != find(nums_old[i])) return false;\n        }\n        return true;\n    }\n};\n```"
}