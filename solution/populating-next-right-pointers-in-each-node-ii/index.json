{
	"titleSlug": "populating-next-right-pointers-in-each-node-ii",
	"slug": "bfsjie-jue-zui-hao-de-ji-bai-liao-100de-yong-hu-by",
	"url": "https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/solution/bfsjie-jue-zui-hao-de-ji-bai-liao-100de-yong-hu-by/",
	"content": "\r\n### 1，BFS解决\r\n\r\n看到关于二叉树的问题，首先要想到关于二叉树的一些常见遍历方式，\r\n对于二叉树的遍历有\r\n\r\n1. **前序遍历**\r\n2. **中序遍历**\r\n3. **后续遍历**\r\n4. **深度优先搜索（DFS）**\r\n5. **宽度优先搜索（BFS）**\r\n\r\n\r\n除了上面介绍的5种以外，还有```Morris（莫里斯）的前中后3种遍历方式```，总共也就这8种。所以只要遇到二叉树相关的算法题，首先想到的就是上面的几种遍历方式，然后再稍加修改，基本上也就这个套路。\r\n\r\n这题让求的就是让把二叉树中每行都串联起来，对于这道题来说最适合的就是BFS。也就是一行一行的遍历，如下图所示\r\n\r\n![image.png](https://pic.leetcode-cn.com/1601255715-zYNzNP-image.png)\r\n\r\n\r\n他的代码如下\r\n```\r\n    public void levelOrder(TreeNode tree) {\r\n        if (tree == null)\r\n            return;\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.add(tree);//相当于把数据加入到队列尾部\r\n        while (!queue.isEmpty()) {\r\n            //poll方法相当于移除队列头部的元素\r\n            TreeNode node = queue.poll();\r\n            System.out.println(node.val);\r\n            if (node.left != null)\r\n                queue.add(node.left);\r\n            if (node.right != null)\r\n                queue.add(node.right);\r\n        }\r\n    }\r\n```\r\n\r\n在遍历每一行的时候，只要把他们串联起来就OK，下面就来把上面的代码改造一下\r\n\r\n```\r\n    public Node connect(Node root) {\r\n        if (root == null)\r\n            return root;\r\n        Queue<Node> queue = new LinkedList<>();\r\n        queue.add(root);\r\n        while (!queue.isEmpty()) {\r\n            //每一层的数量\r\n            int levelCount = queue.size();\r\n            //前一个节点\r\n            Node pre = null;\r\n            for (int i = 0; i < levelCount; i++) {\r\n                //出队\r\n                Node node = queue.poll();\r\n                //如果pre为空就表示node节点是这一行的第一个，\r\n                //没有前一个节点指向他，否则就让前一个节点指向他\r\n                if (pre != null) {\r\n                    pre.next = node;\r\n                }\r\n                //然后再让当前节点成为前一个节点\r\n                pre = node;\r\n                //左右子节点如果不为空就入队\r\n                if (node.left != null)\r\n                    queue.add(node.left);\r\n                if (node.right != null)\r\n                    queue.add(node.right);\r\n            }\r\n        }\r\n        return root;\r\n    }\r\n```\r\n看一下运行结果\r\n![image.png](https://pic.leetcode-cn.com/1601255293-sJQoFi-image.png)\r\n\r\n<br>\r\n\r\n上面运行效率并不是很高，这是因为我们把节点不同的入队然后再不停的出队，其实可以不需要队列，每一行都可以看成一个链表比如第一行就是只有一个节点的链表，第二行是只有两个节点的链表（假如根节点的左右两个子节点都不为空）……\r\n\r\n![image.png](https://pic.leetcode-cn.com/1601259285-fJOatB-image.png)\r\n![image.png](https://pic.leetcode-cn.com/1601259294-BbMQBc-image.png)\r\n\r\n\r\n\r\n```\r\n    public Node connect(Node root) {\r\n        if (root == null)\r\n            return root;\r\n        //cur我们可以把它看做是每一层的链表\r\n        Node cur = root;\r\n        while (cur != null) {\r\n            //遍历当前层的时候，为了方便操作在下一\r\n            //层前面添加一个哑结点（注意这里是访问\r\n            //当前层的节点，然后把下一层的节点串起来）\r\n            Node dummy = new Node(0);\r\n            //pre表示访下一层节点的前一个节点\r\n            Node pre = dummy;\r\n            //然后开始遍历当前层的链表\r\n            while (cur != null) {\r\n                if (cur.left != null) {\r\n                    //如果当前节点的左子节点不为空，就让pre节点\r\n                    //的next指向他，也就是把它串起来\r\n                    pre.next = cur.left;\r\n                    //然后再更新pre\r\n                    pre = pre.next;\r\n                }\r\n                //同理参照左子树\r\n                if (cur.right != null) {\r\n                    pre.next = cur.right;\r\n                    pre = pre.next;\r\n                }\r\n                //继续访问这一行的下一个节点\r\n                cur = cur.next;\r\n            }\r\n            //把下一层串联成一个链表之后，让他赋值给cur，\r\n            //后续继续循环，直到cur为空为止\r\n            cur = dummy.next;\r\n        }\r\n        return root;\r\n    }\r\n```\r\n看一下运行结果\r\n![image.png](https://pic.leetcode-cn.com/1601257187-yxQKrJ-image.png)\r\n\r\n\r\n<br>\r\n\r\n我把部分算法题整理成了PDF文档，截止目前总共有**900多页**，大家可以下载阅读\r\n**链接**：https://pan.baidu.com/s/1hjwK0ZeRxYGB8lIkbKuQgQ \r\n**提取码**：6666 \r\n\r\n#### 如果觉得有用就给个赞吧，还可以关注我的[LeetCode主页](https://leetcode-cn.com/u/sdwwld/)查看更多的详细题解"
}