{
	"titleSlug": "SNJvJP",
	"slug": "shu-xue-yi-ge-gong-shi-ji-ke-by-ivon_shi-mo6a",
	"url": "https://leetcode-cn.com/problems/SNJvJP/solution/shu-xue-yi-ge-gong-shi-ji-ke-by-ivon_shi-mo6a/",
	"content": "**思路：**\r\n1.获取所求点在第几层（此处根据所求点的位置，层数k可能会多算一层）\r\n2.前第`0，1...k`层的数量和 与 所求点相对第k层左上角元素(第k层的入口元素)的**相对路径**做`+`或`-`运算，求得所求点的**绝对路径**（从起始点到所求点经过的长度）\r\n![image.png](https://pic.leetcode-cn.com/1617634053-dCKzIX-image.png)\r\n\r\n**记：**`k(0,1,2...⌈n/2⌉ `(往上取整))\r\n`C(k)`=第`k`层的方块数目,如图`C(0)=16,C(1)=8,C(2)=1`;\r\n`T(k)`=第`k`层以外（不包括第`k`层）的方块 数目，如图`T(0)=0,T(1)=C(0)=16,T(2)=C(0)+C(1)=16+8=24,T(3)=16+8+1=25;`\r\n但是具体怎么计算呢 可以用补集的思想\r\n`T(k)=n*n-(n-2k)*(n-2k)=4*k*(n-k)`\r\n\r\n\r\n但是怎么求`(i,j)`点所在层 已经遍历过的数目呢 。(即下图深蓝色的路径长度)\r\n**1.求所在的层数`k`**\r\n`k=min(x,n-1-x,y,n-1-y)`(后续由于要分类讨论，k的求取可以直接通过其中某两个值求最小值即可); 即看该点距离哪个边界更近，所求的最小值就是第几层，如图 `k=min(2,2,3,1)`,即处于第一层。那么我们也就知道了该层以外的橙色数目`T(k)=T(1)=16`。\r\n**2.求所求点`(x,y)`相对该层左上角点的相对路径长度**\r\n![image.png](https://pic.leetcode-cn.com/1617634073-tvdBEu-image.png)\r\n**2.1 对于`x<=y`，我们可以知道`dl=(x-k)+(y-k)+1`**\r\n故 绝对路径长度为 `T(k)+dl`\r\n\r\n![image.png](https://pic.leetcode-cn.com/1617634087-vpXqyO-image.png)\r\n**2.2 但是对于`x>y`呢**\r\n如果我们采用相同的方法，就会导致对称的两个`(i,j)`与`(j,i)`相对路径相同。故才用另外一种方法\r\n在计算层数`k`的时候 多计算一层，再从下一层的入口处回`退dl`个路径\r\n此时绝对路径长度为 `T(k+1)-dl` ,注意`dl`计算时，仍用其真正所处的层数`k'-1=(k+1)-1=k`来计算。即：`dl=(x-(k'-1))+(y-(k'-1))-1`\r\n    \r\n(至于为何此处可直接`-dl`，可以看下图，下一层的入口点与上一层的入口点是右下和左上关系，按照螺旋顺序到`(i,j)`点的路径长度是相同的。)\r\n![image.png](https://pic.leetcode-cn.com/1617634883-nGyLdr-image.png)\r\n\r\n最后， 就是把相应的路径长度`len`转化为`1-9`的数字即可，`index=(len-1)%9+1`。\r\n\r\n*当然此题也可拓展到`m*n`型的矩阵，最后一圈应该是一条线。`n*n`可以看作是`m*n`的特例，对于`n`为奇数的情况，一条线压缩成了一个点。*\r\n（注：本题思路来自网络文章，非原创，聊作整理，供大家交流学习）\r\n\r\n```c++ []\r\nclass Solution {\r\npublic:\r\n    int orchestraLayout(int num, int xPos, int yPos) {\r\n        long long x=xPos,y=yPos,n=num;\r\n        if  (x <= y) {\r\n            long long  k= min(x, n-1-y);\r\n            return  (4*k*(n-k)+1+(x+y-k*2)-1)%9+1;\r\n        }\r\n        long long  kp =min(y, n-1-x)+1 ; \r\n        return   (4*kp*(n-kp)+1-(x+y-(kp-1)*2)-1)%9+1;\r\n    }\r\n};\r\n```\r\n```python3 []\r\nclass Solution(object):\r\n    def orchestraLayout(self, n, x, y):\r\n        if  x <= y :\r\n            k= min(x, n-1-y)\r\n            return  (4*k*(n-k)+1+(x+y-k*2)-1)%9+1\r\n        kp =min(y, n-1-x)+1 \r\n        return  (4*kp*(n-kp)+1-(x+y-(kp-1)*2)-1)%9+1\r\n```\r\n"
}