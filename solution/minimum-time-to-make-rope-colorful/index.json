{
	"titleSlug": "minimum-time-to-make-rope-colorful",
	"slug": "bi-mian-zhong-fu-zi-mu-de-zui-xiao-shan-chu-chen-4",
	"url": "https://leetcode-cn.com/problems/minimum-time-to-make-rope-colorful/solution/bi-mian-zhong-fu-zi-mu-de-zui-xiao-shan-chu-chen-4/",
	"content": "#### 方法一：贪心\n\n**思路与算法**\n\n根据题意可以知道，如果字符串 $\\textit{colors}$ 中有若干相邻的重复颜色，则这些颜色中最多只能保留一个。因此，我们可以采取贪心的策略：在这一系列重复颜色中，我们保留删除成本最高的颜色，并删除其他颜色。这样得到的删除成本一定是最低的。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minCost(string colors, vector<int>& neededTime) {\n        int i = 0, len = colors.length();\n        int ret = 0;\n        while (i < len) {\n            char ch = colors[i];\n            int maxValue = 0;\n            int sum = 0;\n\n            while (i < len && colors[i] == ch) {\n                maxValue = max(maxValue, neededTime[i]);\n                sum += neededTime[i];\n                i++;\n            }\n            ret += sum - maxValue;\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minCost(String colors, int[] neededTime) {\n        int i = 0, len = colors.length();\n        int ret = 0;\n        while (i < len) {\n            char ch = colors.charAt(i);\n            int maxValue = 0;\n            int sum = 0;\n\n            while (i < len && colors.charAt(i) == ch) {\n                maxValue = Math.max(maxValue, neededTime[i]);\n                sum += neededTime[i];\n                i++;\n            }\n            ret += sum - maxValue;\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinCost(string colors, int[] neededTime) {\n        int i = 0, len = colors.Length;\n        int ret = 0;\n        while (i < len) {\n            char ch = colors[i];\n            int maxValue = 0;\n            int sum = 0;\n\n            while (i < len && colors[i] == ch) {\n                maxValue = Math.Max(maxValue, neededTime[i]);\n                sum += neededTime[i];\n                i++;\n            }\n            ret += sum - maxValue;\n        }\n        return ret;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minCost(self, colors: str, neededTime: List[int]) -> int:\n        i = 0\n        length = len(colors)\n        ret = 0\n\n        while i < length:\n            ch = colors[i]\n            maxValue = 0\n            total = 0\n\n            while i < length and colors[i] == ch:\n                maxValue = max(maxValue, neededTime[i])\n                total += neededTime[i]\n                i += 1\n            \n            ret += total - maxValue\n        \n        return ret\n```\n\n```C [sol1-C]\nint minCost(char* colors, int* neededTime, int neededTimeSize) {\n    int i = 0;\n    int ret = 0;\n    while (i < neededTimeSize) {\n        char ch = colors[i];\n        int maxValue = 0;\n        int sum = 0;\n\n        while (i < neededTimeSize && colors[i] == ch) {\n            maxValue = fmax(maxValue, neededTime[i]);\n            sum += neededTime[i];\n            i++;\n        }\n        ret += sum - maxValue;\n    }\n    return ret;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为字符串的长度。我们只需对字符串进行一次线性的扫描。\n\n- 空间复杂度：$O(1)$。我们只开辟了常量大小的空间。"
}