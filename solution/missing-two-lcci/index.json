{
	"titleSlug": "missing-two-lcci",
	"slug": "xiao-shi-de-liang-ge-shu-zi-by-leetcode-zuwq3",
	"url": "https://leetcode-cn.com/problems/missing-two-lcci/solution/xiao-shi-de-liang-ge-shu-zi-by-leetcode-zuwq3/",
	"content": "#### 方法一：位运算\n\n**思路与算法**\n\n寻找消失的数字，最直观的方法是使用哈希表存储数组中出现过的数字。由于这道题有时间复杂度 $O(n)$ 和空间复杂度 $O(1)$ 的要求，因此不能使用哈希表求解，必须使用其他方法。利用位运算的性质，可以达到时间复杂度 $O(n)$ 和空间复杂度 $O(1)$。\n\n由于从 $1$ 到 $n$ 的整数中有两个整数消失，其余每个整数都在数组中出现一次，因此数组的长度是 $n - 2$。在数组中的 $n - 2$ 个数后面添加从 $1$ 到 $n$ 的每个整数各一次，则得到 $2n - 2$ 个数字，其中两个在数组中消失的数字各出现一次，其余每个数字各出现两次。\n\n假设数组 $\\textit{nums}$ 中消失的两个数字分别是 $x_1$ 和 $x_2$。如果把上述 $2n - 2$ 个数字全部异或起来，得到结果 $x$，那么一定有：\n\n$$\nx = x_1 \\oplus x_2\n$$\n\n其中 $\\oplus$ 表示异或运算。这是因为 $\\textit{nums}$ 中出现两次的元素都会因为异或运算的性质 $a \\oplus b \\oplus b = a$ 抵消掉，那么最终的结果就只剩下 $x_1$ 和 $x_2$ 的异或和。\n\n显然 $x \\ne 0$，因为如果 $x=0$，那么说明 $x_1 = x_2$，这样 $x_1$ 和 $x_2$ 就不是在上述 $2n - 2$ 个数字中只出现一次的数字了。因此，我们可以使用位运算 $\\texttt{x \\& -x}$ 取出 $x$ 的二进制表示中最低位那个 $1$，设其为第 $l$ 位，那么 $x_1$ 和 $x_2$ 中的某一个数的二进制表示的第 $l$ 位为 $0$，另一个数的二进制表示的第 $l$ 位为 $1$。在这种情况下，$x_1 \\oplus x_2$ 的二进制表示的第 $l$ 位才能为 $1$。\n\n这样一来，我们就可以把从 $1$ 到 $n$ 的所有整数分成两类，其中一类包含所有二进制表示的第 $l$ 位为 $0$ 的数，另一类包含所有二进制表示的第 $l$ 位为 $1$ 的数。可以发现：\n\n- 对于任意一个在数组 $\\textit{nums}$ 中出现一次的数字，这些数字在上述 $2n - 2$ 个数字中出现两次，两次出现会被包含在同一类中；\n\n- 对于任意一个在数组 $\\textit{nums}$ 中消失的数字，即 $x_1$ 和 $x_2$，这些数字在上述 $2n - 2$ 个数字中出现一次，会被包含在不同类中。\n\n因此，如果我们将每一类的元素全部异或起来，那么其中一类会得到 $x_1$，另一类会得到 $x_2$。这样我们就找出了这两个只出现一次的元素。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> missingTwo(vector<int>& nums) {\n        int xorsum = 0;\n        int n = nums.size() + 2;\n        for (int num : nums) {\n            xorsum ^= num;\n        }\n        for (int i = 1; i <= n; i++) {\n            xorsum ^= i;\n        }\n        // 防止溢出\n        int lsb = (xorsum == INT_MIN ? xorsum : xorsum & (-xorsum));\n        int type1 = 0, type2 = 0;\n        for (int num : nums) {\n            if (num & lsb) {\n                type1 ^= num;\n            } else {\n                type2 ^= num;\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            if (i & lsb) {\n                type1 ^= i;\n            } else {\n                type2 ^= i;\n            }\n        }\n        return {type1, type2};\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] missingTwo(int[] nums) {\n        int xorsum = 0;\n        int n = nums.length + 2;\n        for (int num : nums) {\n            xorsum ^= num;\n        }\n        for (int i = 1; i <= n; i++) {\n            xorsum ^= i;\n        }\n        // 防止溢出\n        int lsb = (xorsum == Integer.MIN_VALUE ? xorsum : xorsum & (-xorsum));\n        int type1 = 0, type2 = 0;\n        for (int num : nums) {\n            if ((num & lsb) != 0) {\n                type1 ^= num;\n            } else {\n                type2 ^= num;\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            if ((i & lsb) != 0) {\n                type1 ^= i;\n            } else {\n                type2 ^= i;\n            }\n        }\n        return new int[]{type1, type2};\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] MissingTwo(int[] nums) {\n        int xorsum = 0;\n        int n = nums.Length + 2;\n        foreach (int num in nums) {\n            xorsum ^= num;\n        }\n        for (int i = 1; i <= n; i++) {\n            xorsum ^= i;\n        }\n        // 防止溢出\n        int lsb = (xorsum == int.MinValue ? xorsum : xorsum & (-xorsum));\n        int type1 = 0, type2 = 0;\n        foreach (int num in nums) {\n            if ((num & lsb) != 0) {\n                type1 ^= num;\n            } else {\n                type2 ^= num;\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            if ((i & lsb) != 0) {\n                type1 ^= i;\n            } else {\n                type2 ^= i;\n            }\n        }\n        return new int[]{type1, type2};\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def missingTwo(self, nums: List[int]) -> List[int]:\n        xorsum = 0\n        n = len(nums) + 2\n        for num in nums:\n            xorsum ^= num\n        for i in range(1, n + 1):\n            xorsum ^= i\n        \n        lsb = xorsum & (-xorsum)\n        type1 = type2 = 0\n        for num in nums:\n            if num & lsb:\n                type1 ^= num\n            else:\n                type2 ^= num\n        for i in range(1, n + 1):\n            if i & lsb:\n                type1 ^= i\n            else:\n                type2 ^= i\n        \n        return [type1, type2]\n```\n\n```JavaScript [sol1-JavaScript]\nvar missingTwo = function(nums) {\n    let xorsum = 0;\n    let n = nums.length + 2;\n    for (const num of nums) {\n        xorsum ^= num;\n    }\n    for (let i = 1; i <= n; i++) {\n        xorsum ^= i;\n    }\n    let type1 = 0, type2 = 0;\n    const lsb = xorsum & (-xorsum);\n    for (const num of nums) {\n        if (num & lsb) {\n            type1 ^= num;\n        } else {\n            type2 ^= num;\n        }\n    }\n    for (let i = 1; i <= n; i++) {\n        if (i & lsb) {\n            type1 ^= i;\n        } else {\n            type2 ^= i;\n        }\n    }\n    return [type1, type2];\n};\n```\n\n```go [sol1-Golang]\nfunc missingTwo(nums []int) []int {\n    xorSum := 0\n    n := len(nums) + 2\n    for _, num := range nums {\n        xorSum ^= num\n    }\n    for i := 1; i <= n; i++ {\n        xorSum ^= i\n    }\n    lsb := xorSum & -xorSum\n    type1, type2 := 0, 0\n    for _, num := range nums {\n        if num&lsb > 0 {\n            type1 ^= num\n        } else {\n            type2 ^= num\n        }\n    }\n    for i := 1; i <= n; i++ {\n        if i&lsb > 0 {\n            type1 ^= i\n        } else {\n            type2 ^= i\n        }\n    }\n    return []int{type1, type2}\n}\n```\n\n```C [sol1-C]\nint* missingTwo(int* nums, int numsSize, int* returnSize) {\n    int xorsum = 0;\n    int n = numsSize + 2;\n    for (int i = 0; i < numsSize; i++) {\n        xorsum ^= nums[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        xorsum ^= i;\n    }\n    // 防止溢出\n    int lsb = (xorsum == INT_MIN ? xorsum : xorsum & (-xorsum));\n    int type1 = 0, type2 = 0;\n    for (int i = 0; i < numsSize; i++) {\n        int num = nums[i];\n        if (num & lsb) {\n            type1 ^= num;\n        } else {\n            type2 ^= num;\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        if (i & lsb) {\n            type1 ^= i;\n        } else {\n            type2 ^= i;\n        }\n    }\n\n    int *ans = (int *)malloc(sizeof(int) * 2);\n    ans[0] = type1;\n    ans[1] = type2;\n    *returnSize = 2;\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是最大的整数。需要遍历的数字有 $2n - 2$ 个，共遍历两次。\n\n- 空间复杂度：$O(1)$。"
}