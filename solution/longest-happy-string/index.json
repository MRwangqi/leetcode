{
	"titleSlug": "longest-happy-string",
	"slug": "zui-chang-kuai-le-zi-fu-chuan-by-leetcod-5nde",
	"url": "https://leetcode-cn.com/problems/longest-happy-string/solution/zui-chang-kuai-le-zi-fu-chuan-by-leetcod-5nde/",
	"content": "#### 方法一：贪心\n\n**思路**\n\n题目要求找到最长的快乐字符串，且快乐字符串中不含有三个连续相同的字母。为了找到最长的字符串，我们可以使用如下贪心策略：\n\n+ 尽可能优先使用当前数量最多的字母，因为最后同一种字母剩余的越多，越容易出现字母连续相同的情况。如果构建完成最长的快乐字符串后还存在剩余未选择的字母，则剩余的字母一定为同一种字母且该字母的总数量最多。\n\n+ 依次从当前数量最多的字母开始尝试，如果发现加入当前字母会导致出现三个连续相同字母，则跳过当前字母，直到我们找到可以添加的字母为止。实际上每次只会在数量最多和次多的字母中选择一个。\n\n+ 如果尝试所有的字母都无法添加，则直接退出，此时构成的字符串即为最长的快乐字符串。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        ans = []\n        cnt = [[a, 'a'], [b, 'b'], [c, 'c']]\n        while True:\n            cnt.sort(key=lambda x: -x[0])\n            hasNext = False\n            for i, (c, ch) in enumerate(cnt):\n                if c <= 0:\n                    break\n                if len(ans) >= 2 and ans[-2] == ch and ans[-1] == ch:\n                    continue\n                hasNext = True\n                ans.append(ch)\n                cnt[i][0] -= 1\n                break\n            if not hasNext:\n                return ''.join(ans)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string longestDiverseString(int a, int b, int c) {\n        string res;\n        vector<pair<int, char>> arr = {{a, 'a'}, {b, 'b'}, {c, 'c'}};\n        \n        while (true) {\n            sort(arr.begin(), arr.end(), [](const pair<int, char> & p1, const pair<int, char> & p2) {\n                return p1.first > p2.first;\n            });\n            bool hasNext = false;\n            for (auto & [freq, ch] : arr) {\n                int m = res.size();\n                if (freq <= 0) {\n                    break;\n                }\n                if (m >= 2 && res[m - 2] == ch && res[m - 1] == ch) {\n                    continue;\n                }\n                hasNext = true;\n                res.push_back(ch);\n                freq--;\n                break;\n            }\n            if (!hasNext) {\n                break;\n            }\n        }\n      \n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String longestDiverseString(int a, int b, int c) {\n        StringBuilder res = new StringBuilder();\n        Pair[] arr = {new Pair(a, 'a'), new Pair(b, 'b'), new Pair(c, 'c')};\n        \n        while (true) {\n            Arrays.sort(arr, (p1, p2) -> p2.freq - p1.freq);\n            boolean hasNext = false;\n            for (Pair pair : arr) {\n                if (pair.freq <= 0) {\n                    break;\n                }\n                int m = res.length();\n                if (m >= 2 && res.charAt(m - 2) == pair.ch && res.charAt(m - 1) == pair.ch) {\n                    continue;\n                }\n                hasNext = true;\n                res.append(pair.ch);\n                pair.freq--;\n                break;\n            }\n            if (!hasNext) {\n                break;\n            }\n        }\n      \n        return res.toString();\n    }\n\n    class Pair {\n        int freq;\n        char ch;\n\n        public Pair(int freq, char ch) {\n            this.freq = freq;\n            this.ch = ch;\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string LongestDiverseString(int a, int b, int c) {\n        StringBuilder res = new StringBuilder();\n        Pair[] arr = {new Pair(a, 'a'), new Pair(b, 'b'), new Pair(c, 'c')};\n        \n        while (true) {\n            Array.Sort(arr, (p1, p2) => p2.Freq - p1.Freq);\n            bool hasNext = false;\n            foreach (Pair pair in arr) {\n                if (pair.Freq <= 0) {\n                    break;\n                }\n                int m = res.Length;\n                if (m >= 2 && res[m - 2] == pair.Ch && res[m - 1] == pair.Ch) {\n                    continue;\n                }\n                hasNext = true;\n                res.Append(pair.Ch);\n                pair.Freq--;\n                break;\n            }\n            if (!hasNext) {\n                break;\n            }\n        }\n      \n        return res.ToString();\n    }\n\n    class Pair {\n        public int Freq { get; set; }\n        public char Ch { get; set; }\n\n        public Pair(int Freq, char Ch) {\n            this.Freq = Freq;\n            this.Ch = Ch;\n        }\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int freq;\n    char ch;\n} Pair;\n\nint cmp(const void * pa, const void * pb) {\n    return ((Pair *)pb)->freq - ((Pair *)pa)->freq;\n}\n\nchar * longestDiverseString(int a, int b, int c){\n    char * res = (char *)malloc(sizeof(char) * (a + b + c + 1));\n    Pair arr[3] = {{a, 'a'}, {b, 'b'}, {c, 'c'}};\n    int pos = 0;\n\n    while (true) {\n        qsort(arr, 3, sizeof(Pair), cmp);\n        bool hasNext = false;\n        for (int i = 0; i < 3; i++) {\n            int freq = arr[i].freq;\n            int ch = arr[i].ch;\n            if (freq <= 0) {\n                break;\n            }\n            if (pos >= 2 && res[pos - 2] == ch && res[pos - 1] == ch) {\n                continue;\n            }\n            hasNext = true;\n            res[pos++] = ch;\n            arr[i].freq--;\n            break;\n        }\n        if (!hasNext) {\n            break;\n        }\n    }\n    res[pos] = '\\0';\n    return res;\n}\n```\n\n```go [sol1-Golang]\nfunc longestDiverseString(a, b, c int) string {\n    ans := []byte{}\n    cnt := []struct{ c int; ch byte }{{a, 'a'}, {b, 'b'}, {c, 'c'}}\n    for {\n        sort.Slice(cnt, func(i, j int) bool { return cnt[i].c > cnt[j].c })\n        hasNext := false\n        for i, p := range cnt {\n            if p.c <= 0 {\n                break\n            }\n            m := len(ans)\n            if m >= 2 && ans[m-2] == p.ch && ans[m-1] == p.ch {\n                continue\n            }\n            hasNext = true\n            ans = append(ans, p.ch)\n            cnt[i].c--\n            break\n        }\n        if !hasNext {\n            return string(ans)\n        }\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar longestDiverseString = function(a, b, c) {\n    const res = [];\n    const arr = [[a, 'a'], [b, 'b'], [c, 'c']];\n    \n    while (true) {\n        arr.sort((a, b) => b[0] - a[0]);\n        let hasNext = false;\n        for (const [i, [c, ch]] of arr.entries()) {\n            if (c <= 0) {\n                break;\n            }\n            const m = res.length;\n            if (m >= 2 && res[m - 2] === ch && res[m - 1] === ch) {\n                continue;\n            }\n            hasNext = true;\n            res.push(ch);\n            arr[i][0]--;\n            break;\n        }\n        if (!hasNext) {\n            break;\n        }\n    }\n    \n    return res.join('');\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O((a + b + c) \\times C \\log C)$，其中 $a, b, c$ 为给定的整数，$C$ 表示字母的种类，在本题中 $C = 3$。每次从待选的字母中选择一个字母需要执行一次排序，时间复杂度为 $O(C \\log C)$，最多需要选择 $a + b + c$ 个字母。\n\n- 空间复杂度：$O(C)$，在本题中 $C = 3$。需要 $O(C)$ 的空间存储字母的当前计数。"
}