{
	"titleSlug": "0jQkd0",
	"slug": "java-by-da-pang-zi-f-7rj7",
	"url": "https://leetcode-cn.com/problems/0jQkd0/solution/java-by-da-pang-zi-f-7rj7/",
	"content": "题目写了一大堆，看起来非常复杂，开始我以为又是那种需要递归搜索加剪枝，或者动归的题目，最后看下来，发现**只需要判断在`target[][]`中，有几个数字没有出现`source[][]`中即可**。\n\n那这种就比较简单了，我们只需要把`source[][]`遍历完，将每个数字的出现频率都统计出来，之后再遍历`target[][]`，将`target[][]`中出现的数字减掉，那么最后的结果就可以统计出最少的次数了。\n\n需要注意的是，题目中已经严格表示了两个数组的大小长度相同，所以不要考虑额外的情况。同时，在统计最后的结果时，我们只需要考虑出现次数为**负数**的情况，因为负数才表示了`target[][]`中缺失的次数，统计正数是没有意义的。\n\n针对这种题目，我们要先看一下题目下方的数据大小，这道题表明了数组内数字在1～10000之间，所以我们可以申明一个大小为10001的数组，用来存储每个数字出现的次数。\n\n```java\nclass Solution {\n    public int minimumSwitchingTimes(int[][] source, int[][] target) {\n        // 统计每个数字出现的次数\n        int[] sources = new int[10001];\n\n        // 统计source中每个数字出现的次数\n        for (int i = 0; i < source.length; i++) {\n            int[] s = source[i];\n            for (int j = 0; j < s.length; j++) {\n                sources[s[j]]++;\n            }\n        }\n\n        // 如果数字在target中出现，将统计出来的数字-1\n        for (int i = 0; i < target.length; i++) {\n            int[] t = target[i];\n            for (int j = 0; j < t.length; j++) {\n                sources[t[j]]--;\n            }\n        }\n\n        int res = 0;\n        for (int i = 0; i < 10001; i++) {\n            // 只有当target的数字没有在source中出现时，值才会为负数，所以只统计负数\n            if (sources[i] < 0) {\n                res -= sources[i];\n            }\n        }\n\n        return res;\n    }\n}\n\n```\n![image.png](https://pic.leetcode-cn.com/1663807142-aDARSR-image.png)\n\n> 时间复杂度大概就是两次数组的循环，O(2*m*n) + O(1000)，常数级的都省略掉，所以是O(mn)。\n\n> 在这种数据规模可以确定的情况下，还是优先采用自己创建数组的方式，这种思路用Map也能做出来，但Map存取值都会先走一遍哈希算法，还是会对速度有一定的影响，这种比较简单的题就尽量不要用Map来做。"
}