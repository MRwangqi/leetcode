{
	"titleSlug": "minimum-score-after-removals-on-a-tree",
	"slug": "dfs-shi-jian-chuo-chu-li-shu-shang-wen-t-x1kk",
	"url": "https://leetcode-cn.com/problems/minimum-score-after-removals-on-a-tree/solution/dfs-shi-jian-chuo-chu-li-shu-shang-wen-t-x1kk/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1pW4y1r7xs) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n#### 何为时间戳？\r\n\r\n我们可以在 DFS 一棵树的过程中，维护一个全局的时间戳 $\\textit{clock}$，每访问一个新的节点，就将 $\\textit{clock}$ 加一。同时，记录进入节点 $x$ 时的时间戳 $\\textit{in}[x]$，和离开（递归结束）这个节点时的时间戳 $\\textit{out}[x]$。\r\n\r\n#### 时间戳有什么性质？\r\n\r\n根据 DFS 的性质，当我们递归以 $x$ 为根的子树时，设 $y$ 是 $x$ 的子孙节点，我们必须先递归完以 $y$ 为根的子树，之后才能递归完以 $x$ 为根的子树。\r\n\r\n从时间戳上看，如果 $y$ 是 $x$ 的子孙节点，那么区间 $[\\textit{in}[y],\\textit{out}[y]]$ 必然被区间 $[\\textit{in}[x],\\textit{out}[x]]$ 所包含。\r\n\r\n反之，如果区间 $[\\textit{in}[y],\\textit{out}[y]]$ 被区间 $[\\textit{in}[x],\\textit{out}[x]]$ 所包含，那么 $y$ 必然是 $x$ 的子孙节点（换句话说 $x$ 是 $y$ 的祖先节点）。因此我们可以通过\r\n\r\n$$\r\n\\textit{in}[x]<\\textit{in}[y]\\le\\textit{out}[y]\\le\\textit{out}[x]\r\n$$\r\n\r\n来判断 $x$ 是否为 $y$ 的祖先节点，由于 $\\textit{in}[y]\\le\\textit{out}[y]$ 恒成立，上式可以简化为\r\n\r\n$$\r\n\\textit{in}[x]<\\textit{in}[y]\\le\\textit{out}[x]\r\n$$\r\n\r\n---\r\n\r\n回到本题。由于需要求出子树的异或和，不妨以 $0$ 为根，DFS 这棵树，在求出时间戳的同时，求出每棵以 $x$ 为根的子树的异或和 $\\textit{xor}[x]$。\r\n\r\n由于 $n$ 比较小，我们可以用 $O(n^2)$ 的时间枚举要删除的两条边 $x_1\\text{-}y_1$ 和 $x_2\\text{-}y_2$，并假设 $x$ 是 $y$ 的父节点，这会产生以下三种情况：\r\n\r\n1. 删除的两条边在同一颗子树内，且 $y_1$ 是 $x_2$ 的祖先节点（或重合）。\r\n    \r\n   如下图所示，这三个连通块的异或和分别为 $\\textit{xor}[y_2]$、$\\textit{xor}[y_1]\\oplus\\textit{xor}[y_2]$ 和 $\\textit{xor}[0]\\oplus\\textit{xor}[y_1]$（$\\oplus$ 表示异或运算）。\r\n\r\n  ![same.png](https://pic.leetcode-cn.com/1656215504-THYbIW-same.png)\r\n\r\n2. 删除的两条边在同一颗子树内，且 $y_2$ 是 $x_1$ 的祖先节点（或重合）。\r\n    \r\n   同上，这三个连通块的异或和分别为 $\\textit{xor}[y_1]$、$\\textit{xor}[y_2]\\oplus\\textit{xor}[y_1]$ 和 $\\textit{xor}[0]\\oplus\\textit{xor}[y_2]$。\r\n   \r\n3. 删除的两条边分别属于两颗不相交的子树。\r\n\r\n   如下图所示，这三个连通块的异或和分别为 $\\textit{xor}[y_1]$、$\\textit{xor}[y_2]$ 和 $\\textit{xor}[0]\\oplus\\textit{xor}[y_1]\\oplus\\textit{xor}[y_2]$。\r\n\r\n   ![diff.png](https://pic.leetcode-cn.com/1656215343-RsPtkr-diff.png)\r\n\r\n因此关键之处在于判断这两条边的关系，这可以用上文提到的时间戳的性质 $O(1)$ 地判断出来。\r\n\r\n代码实现时，由于不知道 $\\textit{edges}[i]$ 两个点的父子关系，枚举边的写法需要额外的判断。我们可以改为枚举不是根的两个点，删除这两个点及其父节点形成的边，这样代码更简洁，效率也略优于枚举边的写法。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n^2)$，其中 $n$ 为 $\\textit{nums}$ 的长度。\r\n- 空间复杂度：$O(n)$。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\r\n        n = len(nums)\r\n        g = [[] for _ in range(n)]\r\n        for x, y in edges:\r\n            g[x].append(y)\r\n            g[y].append(x)\r\n\r\n        xor, in_, out, clock = [0] * n, [0] * n, [0] * n, 0\r\n        def dfs(x: int, fa: int) -> None:\r\n            nonlocal clock\r\n            clock += 1\r\n            in_[x] = clock\r\n            xor[x] = nums[x]\r\n            for y in g[x]:\r\n                if y != fa:\r\n                    dfs(y, x)\r\n                    xor[x] ^= xor[y]\r\n            out[x] = clock\r\n        dfs(0, -1)\r\n\r\n        ans = inf\r\n        for i in range(2, n):\r\n            for j in range(1, i):\r\n                if in_[i] < in_[j] <= out[i]:  # i 是 j 的祖先节点\r\n                    x, y, z = xor[j], xor[i] ^ xor[j], xor[0] ^ xor[i]\r\n                elif in_[j] < in_[i] <= out[j]:  # j 是 i 的祖先节点\r\n                    x, y, z = xor[i], xor[i] ^ xor[j], xor[0] ^ xor[j]\r\n                else:  # 删除的两条边分别属于两颗不相交的子树\r\n                    x, y, z = xor[i], xor[j], xor[0] ^ xor[i] ^ xor[j]\r\n                ans = min(ans, max(x, y, z) - min(x, y, z))\r\n                # 注：把 min max 拆开，改为下面的注释，可以明显加快速度\r\n                # mn = mx = x\r\n                # if y < mn: mn = y \r\n                # elif y > mx: mx = y\r\n                # if z < mn: mn = z \r\n                # elif z > mx: mx = z\r\n                # if mx - mn < ans: ans = mx - mn\r\n                if ans == 0: return 0  # 提前退出\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    List<Integer>[] g;\r\n    int[] nums, xor, in, out;\r\n    int clock;\r\n\r\n    public int minimumScore(int[] nums, int[][] edges) {\r\n        var n = nums.length;\r\n        g = new ArrayList[n];\r\n        Arrays.setAll(g, e -> new ArrayList<>());\r\n        for (var e : edges) {\r\n            int x = e[0], y = e[1];\r\n            g[x].add(y);\r\n            g[y].add(x);\r\n        }\r\n        this.nums = nums;\r\n        xor = new int[n];\r\n        in = new int[n];\r\n        out = new int[n];\r\n        dfs(0, -1);\r\n\r\n        var ans = Integer.MAX_VALUE;\r\n        for (int i = 2, x, y, z; i < n; ++i)\r\n            for (var j = 1; j < i; ++j) {\r\n                if (in[i] < in[j] && in[j] <= out[i]) { // i 是 j 的祖先节点\r\n                    x = xor[j];\r\n                    y = xor[i] ^ x;\r\n                    z = xor[0] ^ xor[i];\r\n                } else if (in[j] < in[i] && in[i] <= out[j]) { // j 是 i 的祖先节点\r\n                    x = xor[i];\r\n                    y = xor[j] ^ x;\r\n                    z = xor[0] ^ xor[j];\r\n                } else { // 删除的两条边分别属于两颗不相交的子树\r\n                    x = xor[i];\r\n                    y = xor[j];\r\n                    z = xor[0] ^ x ^ y;\r\n                }\r\n                ans = Math.min(ans, Math.max(Math.max(x, y), z) - Math.min(Math.min(x, y), z));\r\n                if (ans == 0) return 0; // 提前退出\r\n            }\r\n        return ans;\r\n    }\r\n\r\n    void dfs(int x, int fa) {\r\n        in[x] = ++clock;\r\n        xor[x] = nums[x];\r\n        for (var y : g[x])\r\n            if (y != fa) {\r\n                dfs(y, x);\r\n                xor[x] ^= xor[y];\r\n            }\r\n        out[x] = clock;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int minimumScore(vector<int> &nums, vector<vector<int>> &edges) {\r\n        int n = nums.size();\r\n        vector<vector<int>> g(n);\r\n        for (auto &e : edges) {\r\n            int x = e[0], y = e[1];\r\n            g[x].push_back(y);\r\n            g[y].push_back(x);\r\n        }\r\n\r\n        int xr[n], in[n], out[n], clock = 0;\r\n        function<void(int, int)> dfs = [&](int x, int fa) {\r\n            in[x] = ++clock;\r\n            xr[x] = nums[x];\r\n            for (int y : g[x])\r\n                if (y != fa) {\r\n                    dfs(y, x);\r\n                    xr[x] ^= xr[y];\r\n                }\r\n            out[x] = clock;\r\n        };\r\n        dfs(0, -1);\r\n\r\n        int ans = INT_MAX;\r\n        for (int i = 2, x, y, z; i < n; ++i)\r\n            for (int j = 1; j < i; ++j) {\r\n                if (in[i] < in[j] && in[j] <= out[i]) x = xr[j], y = xr[i] ^ x, z = xr[0] ^ xr[i]; // i 是 j 的祖先节点\r\n                else if (in[j] < in[i] && in[i] <= out[j]) x = xr[i], y = xr[j] ^ x, z = xr[0] ^ xr[j]; // j 是 i 的祖先节点\r\n                else x = xr[i], y = xr[j], z = xr[0] ^ x ^ y; // 删除的两条边分别属于两颗不相交的子树\r\n                ans = min(ans, max(max(x, y), z) - min(min(x, y), z));\r\n                if (ans == 0) return 0; // 提前退出\r\n            }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc minimumScore(nums []int, edges [][]int) int {\r\n\tn := len(nums)\r\n\tg := make([][]int, n)\r\n\tfor _, e := range edges {\r\n\t\tx, y := e[0], e[1]\r\n\t\tg[x] = append(g[x], y)\r\n\t\tg[y] = append(g[y], x)\r\n\t}\r\n\r\n\txor := make([]int, n)\r\n\tin := make([]int, n)\r\n\tout := make([]int, n)\r\n\tclock := 0\r\n\tvar dfs func(int, int)\r\n\tdfs = func(x, fa int) {\r\n\t\tclock++\r\n\t\tin[x] = clock\r\n\t\txor[x] = nums[x]\r\n\t\tfor _, y := range g[x] {\r\n\t\t\tif y != fa {\r\n\t\t\t\tdfs(y, x)\r\n\t\t\t\txor[x] ^= xor[y]\r\n\t\t\t}\r\n\t\t}\r\n\t\tout[x] = clock\r\n\t}\r\n\tdfs(0, -1)\r\n\tisAncestor := func(x, y int) bool { return in[x] < in[y] && in[y] <= out[x] }\r\n\r\n\tans := math.MaxInt32\r\n\tfor i := 2; i < n; i++ {\r\n\t\tfor j := 1; j < i; j++ {\r\n\t\t\tvar x, y, z int\r\n\t\t\tif isAncestor(i, j) { // i 是 j 的祖先节点\r\n\t\t\t\tx, y, z = xor[j], xor[i]^xor[j], xor[0]^xor[i]\r\n\t\t\t} else if isAncestor(j, i) { // j 是 i 的祖先节点\r\n\t\t\t\tx, y, z = xor[i], xor[i]^xor[j], xor[0]^xor[j]\r\n\t\t\t} else { // 删除的两条边分别属于两颗不相交的子树\r\n\t\t\t\tx, y, z = xor[i], xor[j], xor[0]^xor[i]^xor[j]\r\n\t\t\t}\r\n\t\t\tans = min(ans, max(max(x, y), z)-min(min(x, y), z))\r\n\t\t\tif ans == 0 {\r\n\t\t\t\treturn 0 // 提前退出\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc min(a, b int) int { if a > b { return b }; return a }\r\nfunc max(a, b int) int { if a < b { return b }; return a }\r\n```\r\n"
}