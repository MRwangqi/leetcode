{
	"titleSlug": "rectangle-area-ii",
	"slug": "ju-xing-mian-ji-ii-by-leetcode-solution-ulqz",
	"url": "https://leetcode-cn.com/problems/rectangle-area-ii/solution/ju-xing-mian-ji-ii-by-leetcode-solution-ulqz/",
	"content": "#### 方法一：离散化 + 扫描线 + 使用简单数组实时维护\n\n**思路与算法**\n\n我们先解释扫描线的概念：想象一条竖直的直线从平面的最左端扫到最右端，在扫描的过程中，直线上的一些线段会被给定的矩形覆盖。将这些覆盖的线段长度进行积分，就可以得到矩形的面积之和。每个矩形有一个左边界和一个右边界，在扫描到矩形的左边界时，覆盖的长度可能会增加；在扫描到矩形的右边界时，覆盖的长度可能会减少。如果给定了 $n$ 个矩形，那么覆盖的线段长度最多变化 $2n$ 次，此时我们就可以将两次变化之间的部分合并起来，一起计算：即这一部分矩形的面积，等于覆盖的线段长度，乘以扫描线在水平方向移动过的距离。\n\n因此，我们可以首先将所有矩形的左右边界按照横坐标进行排序，这样就确定了扫描线扫描的顺序。随后我们遍历这些左右边界，一次性地处理掉一批横坐标相同的左右边界，对应地增加或者减少覆盖的长度。在这之后，下一个未遍历到的坐右边界的横坐标，减去这一批左右边界的横坐标，就是扫描线在水平方向移动过的距离。\n\n那么我们如何维护「覆盖的线段长度」呢？这里同样可以使用到离散化的技巧（扫描线就是一种离散化的技巧，将大范围的连续的坐标转化成 $2n$ 个离散的坐标）。由于矩形的上下边界也只有 $2n$ 个，它们会将 $y$ 轴分成 $2n+1$ 个部分，中间的 $2n-1$ 个部分均为线段，会被矩形覆盖到（最外侧的 $2$ 个部分为射线，不会被矩形覆盖到），并且每一个线段要么完全被覆盖，要么完全不被覆盖。因此我们可以使用两个长度为 $2n-1$ 的数组 $\\textit{seg}$ 和 $\\textit{length}$，其中 $\\textit{seg}[i]$ 表示第 $i$ 个线段被矩形覆盖的次数，$\\textit{length}[i]$ 表示第 $i$ 个线段的长度。当扫描线遇到一个左边界时，我们就将左边界覆盖到的线段对应的 $\\textit{seg}[i]$ 全部加 $1$；遇到一个右边界时，我们就将右边界覆盖到的线段对应的 $\\textit{seg}[i]$ 全部减 $1$。在处理掉一批横坐标相同的左右边界后，$\\textit{seg}[i]$ 如果大于 $0$，说明它被覆盖，我们累加所有的 $\\textit{length}[i]$，即可得到「覆盖的线段长度」。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int rectangleArea(vector<vector<int>>& rectangles) {\n        int n = rectangles.size();\n        vector<int> hbound;\n        for (const auto& rect: rectangles) {\n            // 下边界\n            hbound.push_back(rect[1]);\n            // 上边界\n            hbound.push_back(rect[3]);\n        }\n        sort(hbound.begin(), hbound.end());\n        hbound.erase(unique(hbound.begin(), hbound.end()), hbound.end());\n        int m = hbound.size();\n        // 「思路与算法部分」的 length 数组并不需要显式地存储下来\n        // length[i] 可以通过 hbound[i+1] - hbound[i] 得到\n        vector<int> seg(m - 1);\n\n        vector<tuple<int, int, int>> sweep;\n        for (int i = 0; i < n; ++i) {\n            // 左边界\n            sweep.emplace_back(rectangles[i][0], i, 1);\n            // 右边界\n            sweep.emplace_back(rectangles[i][2], i, -1);\n        }\n        sort(sweep.begin(), sweep.end());\n\n        long long ans = 0;\n        for (int i = 0; i < sweep.size(); ++i) {\n            int j = i;\n            while (j + 1 < sweep.size() && get<0>(sweep[i]) == get<0>(sweep[j + 1])) {\n                ++j;\n            }\n            if (j + 1 == sweep.size()) {\n                break;\n            }\n            // 一次性地处理掉一批横坐标相同的左右边界\n            for (int k = i; k <= j; ++k) {\n                auto&& [_, idx, diff] = sweep[k];\n                int left = rectangles[idx][1], right = rectangles[idx][3];\n                for (int x = 0; x < m - 1; ++x) {\n                    if (left <= hbound[x] && hbound[x + 1] <= right) {\n                        seg[x] += diff;\n                    }\n                }\n            }\n            int cover = 0;\n            for (int k = 0; k < m - 1; ++k) {\n                if (seg[k] > 0) {\n                    cover += (hbound[k + 1] - hbound[k]);\n                }\n            }\n            ans += static_cast<long long>(cover) * (get<0>(sweep[j + 1]) - get<0>(sweep[j]));\n            i = j;\n        }\n        return ans % static_cast<int>(1e9 + 7);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int rectangleArea(int[][] rectangles) {\n        final int MOD = 1000000007;\n        int n = rectangles.length;\n        Set<Integer> set = new HashSet<Integer>();\n        for (int[] rect : rectangles) {\n            // 下边界\n            set.add(rect[1]);\n            // 上边界\n            set.add(rect[3]);\n        }\n        List<Integer> hbound = new ArrayList<Integer>(set);\n        Collections.sort(hbound);\n        int m = hbound.size();\n        // 「思路与算法部分」的 length 数组并不需要显式地存储下来\n        // length[i] 可以通过 hbound[i+1] - hbound[i] 得到\n        int[] seg = new int[m - 1];\n\n        List<int[]> sweep = new ArrayList<int[]>();\n        for (int i = 0; i < n; ++i) {\n            // 左边界\n            sweep.add(new int[]{rectangles[i][0], i, 1});\n            // 右边界\n            sweep.add(new int[]{rectangles[i][2], i, -1});\n        }\n        Collections.sort(sweep, (a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            } else if (a[1] != b[1]) {\n                return a[1] - b[1];\n            } else {\n                return a[2] - b[2];\n            }\n        });\n\n        long ans = 0;\n        for (int i = 0; i < sweep.size(); ++i) {\n            int j = i;\n            while (j + 1 < sweep.size() && sweep.get(i)[0] == sweep.get(j + 1)[0]) {\n                ++j;\n            }\n            if (j + 1 == sweep.size()) {\n                break;\n            }\n            // 一次性地处理掉一批横坐标相同的左右边界\n            for (int k = i; k <= j; ++k) {\n                int[] arr = sweep.get(k);\n                int idx = arr[1], diff = arr[2];\n                int left = rectangles[idx][1], right = rectangles[idx][3];\n                for (int x = 0; x < m - 1; ++x) {\n                    if (left <= hbound.get(x) && hbound.get(x + 1) <= right) {\n                        seg[x] += diff;\n                    }\n                }\n            }\n            int cover = 0;\n            for (int k = 0; k < m - 1; ++k) {\n                if (seg[k] > 0) {\n                    cover += (hbound.get(k + 1) - hbound.get(k));\n                }\n            }\n            ans += (long) cover * (sweep.get(j + 1)[0] - sweep.get(j)[0]);\n            i = j;\n        }\n        return (int) (ans % MOD);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int RectangleArea(int[][] rectangles) {\n        const int MOD = 1000000007;\n        int n = rectangles.Length;\n        ISet<int> set = new HashSet<int>();\n        foreach (int[] rect in rectangles) {\n            // 下边界\n            set.Add(rect[1]);\n            // 上边界\n            set.Add(rect[3]);\n        }\n        List<int> hbound = new List<int>(set);\n        hbound.Sort();\n        int m = hbound.Count;\n        // 「思路与算法部分」的 length 数组并不需要显式地存储下来\n        // length[i] 可以通过 hbound[i+1] - hbound[i] 得到\n        int[] seg = new int[m - 1];\n\n        List<Tuple<int, int, int>> sweep = new List<Tuple<int, int, int>>();\n        for (int i = 0; i < n; ++i) {\n            // 左边界\n            sweep.Add(new Tuple<int, int, int>(rectangles[i][0], i, 1));\n            // 右边界\n            sweep.Add(new Tuple<int, int, int>(rectangles[i][2], i, -1));\n        }\n        sweep.Sort();\n\n        long ans = 0;\n        for (int i = 0; i < sweep.Count; ++i) {\n            int j = i;\n            while (j + 1 < sweep.Count && sweep[i].Item1 == sweep[j + 1].Item1) {\n                ++j;\n            }\n            if (j + 1 == sweep.Count) {\n                break;\n            }\n            // 一次性地处理掉一批横坐标相同的左右边界\n            for (int k = i; k <= j; ++k) {\n                Tuple<int, int, int> tuple = sweep[k];\n                int idx = tuple.Item2, diff = tuple.Item3;\n                int left = rectangles[idx][1], right = rectangles[idx][3];\n                for (int x = 0; x < m - 1; ++x) {\n                    if (left <= hbound[x] && hbound[x + 1] <= right) {\n                        seg[x] += diff;\n                    }\n                }\n            }\n            int cover = 0;\n            for (int k = 0; k < m - 1; ++k) {\n                if (seg[k] > 0) {\n                    cover += (hbound[k + 1] - hbound[k]);\n                }\n            }\n            ans += (long) cover * (sweep[j + 1].Item1 - sweep[j].Item1);\n            i = j;\n        }\n        return (int) (ans % MOD);\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        hbound = set()\n        for rect in rectangles:\n            # 下边界\n            hbound.add(rect[1])\n            # 上边界\n            hbound.add(rect[3])\n        \n        hbound = sorted(hbound)\n        m = len(hbound)\n        # 「思路与算法部分」的 length 数组并不需要显式地存储下来\n        # length[i] 可以通过 hbound[i+1] - hbound[i] 得到\n        seg = [0] * (m - 1)\n\n        sweep = list()\n        for i, rect in enumerate(rectangles):\n            # 左边界\n            sweep.append((rect[0], i, 1))\n            # 右边界\n            sweep.append((rect[2], i, -1))\n        sweep.sort()\n\n        ans = i = 0\n        while i < len(sweep):\n            j = i\n            while j + 1 < len(sweep) and sweep[i][0] == sweep[j + 1][0]:\n                j += 1\n            if j + 1 == len(sweep):\n                break\n            \n            # 一次性地处理掉一批横坐标相同的左右边界\n            for k in range(i, j + 1):\n                _, idx, diff = sweep[k]\n                left, right = rectangles[idx][1], rectangles[idx][3]\n                for x in range(m - 1):\n                    if left <= hbound[x] and hbound[x + 1] <= right:\n                        seg[x] += diff\n            \n            cover = 0\n            for k in range(m - 1):\n                if seg[k] > 0:\n                    cover += (hbound[k + 1] - hbound[k])\n            ans += cover * (sweep[j + 1][0] - sweep[j][0])\n            i = j + 1\n        \n        return ans % (10**9 + 7)\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    UT_hash_handle hh;\n} HashItem; \n\ntypedef struct Tuple {\n    int val[3];\n} Tuple;\n\nHashItem *hashFindItem(HashItem **obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nbool hashAddItem(HashItem **obj, int key) {\n    if (hashFindItem(obj, key)) {\n        return false;\n    }\n    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = key;\n    HASH_ADD_INT(*obj, key, pEntry);\n    return true;\n}\n\nvoid hashFree(HashItem **obj) {\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);             \n    }\n}\n\nstatic inline int cmp1(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nstatic inline int cmp2(const void *pa, const void *pb) {\n    Tuple *a = (Tuple *)pa, *b = (Tuple *)pb;\n    if (a->val[0] != b->val[0]) {\n        return a->val[0] - b->val[0];\n    } else if (a->val[1] != b->val[1]) {\n        return a->val[1] - b->val[1];\n    } else {\n        return a->val[2] - b->val[2];\n    }\n}\n\nint rectangleArea(int** rectangles, int rectanglesSize, int* rectanglesColSize){\n    int n = rectanglesSize;\n    HashItem *set = NULL;\n    for (int i = 0; i < n; i++) {\n        // 下边界\n        hashAddItem(&set, rectangles[i][1]);\n        // 上边界\n        hashAddItem(&set, rectangles[i][3]);\n    }\n    int hboundSize = HASH_COUNT(set);\n    int hbound[hboundSize], pos = 0;\n    for (HashItem *pEntry = set; pEntry != NULL; pEntry = pEntry->hh.next) {\n        hbound[pos++] = pEntry->key;\n    }\n    hashFree(&set);\n\n    qsort(hbound, hboundSize, sizeof(int), cmp1);\n    // 「思路与算法部分」的 length 数组并不需要显式地存储下来\n    // length[i] 可以通过 hbound[i+1] - hbound[i] 得到\n    int seg[hboundSize - 1];\n    int sweepSize = n * 2;\n    Tuple sweep[sweepSize];\n    pos = 0;\n    memset(seg, 0, sizeof(seg));\n    for (int i = 0; i < n; ++i) {\n        // 左边界\n        sweep[pos].val[0] = rectangles[i][0];\n        sweep[pos].val[1] = i;\n        sweep[pos].val[2] = 1;\n        pos++;\n        // 右边界\n        sweep[pos].val[0] = rectangles[i][2];\n        sweep[pos].val[1] = i;\n        sweep[pos].val[2] = -1;\n        pos++;\n    }\n    qsort(sweep, sweepSize, sizeof(Tuple), cmp2);\n    long long ans = 0;\n    for (int i = 0; i < n * 2; ++i) {\n        int j = i;\n        while (j + 1 < sweepSize && sweep[i].val[0] == sweep[j + 1].val[0]) {\n            ++j;\n        }\n        if (j + 1 == sweepSize) {\n            break;\n        }\n        // 一次性地处理掉一批横坐标相同的左右边界\n        for (int k = i; k <= j; ++k) {\n            int idx = sweep[k].val[1], diff = sweep[k].val[2];\n            int left = rectangles[idx][1], right = rectangles[idx][3];\n            for (int x = 0; x < hboundSize - 1; ++x) {\n                if (left <= hbound[x] && hbound[x + 1] <= right) {\n                    seg[x] += diff;\n                }\n            }\n        }\n        int cover = 0;\n        for (int k = 0; k < hboundSize - 1; ++k) {\n            if (seg[k] > 0) {\n                cover += (hbound[k + 1] - hbound[k]);\n            }\n        }\n        ans += (long long)cover * (sweep[j + 1].val[0] - sweep[j].val[0]);\n        i = j;\n    }\n    return ans % (long long)(1e9 + 7);\n}\n```\n\n```go [sol1-Golang]\nfunc rectangleArea(rectangles [][]int) (ans int) {\n    n := len(rectangles) * 2\n    hBound := make([]int, 0, n)\n    for _, r := range rectangles {\n        hBound = append(hBound, r[1], r[3])\n    }\n    // 排序，方便下面去重\n    sort.Ints(hBound)\n    m := 0\n    for _, b := range hBound[1:] {\n        if hBound[m] != b {\n            m++\n            hBound[m] = b\n        }\n    }\n    hBound = hBound[:m+1]\n\n    type tuple struct{ x, i, d int }\n    sweep := make([]tuple, 0, n)\n    for i, r := range rectangles {\n        sweep = append(sweep, tuple{r[0], i, 1}, tuple{r[2], i, -1})\n    }\n    sort.Slice(sweep, func(i, j int) bool { return sweep[i].x < sweep[j].x })\n\n    seg := make([]int, m)\n    for i := 0; i < n; i++ {\n        j := i\n        for j+1 < n && sweep[j+1].x == sweep[i].x {\n            j++\n        }\n        if j+1 == n {\n            break\n        }\n        // 一次性地处理掉一批横坐标相同的左右边界\n        for k := i; k <= j; k++ {\n            idx, diff := sweep[k].i, sweep[k].d\n            left, right := rectangles[idx][1], rectangles[idx][3]\n            for x := 0; x < m; x++ {\n                if left <= hBound[x] && hBound[x+1] <= right {\n                    seg[x] += diff\n                }\n            }\n        }\n        cover := 0\n        for k := 0; k < m; k++ {\n            if seg[k] > 0 {\n                cover += hBound[k+1] - hBound[k]\n            }\n        }\n        ans += cover * (sweep[j+1].x - sweep[j].x)\n        i = j\n    }\n    return ans % (1e9 + 7)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 是矩形的个数。\n\n- 空间复杂度：$O(n)$，即为扫描线需要使用的空间。\n\n#### 方法二：离散化 + 扫描线 + 使用线段树实时维护\n\n**思路与算法**\n\n方法一中对于数组 $\\textit{seg}$ 的所有操作都可以使用线段树进行维护。线段树中需要存储：\n\n- 该节点对应的区间被完整覆盖的次数；\n\n- 该节点对应的区间被覆盖的线段长度。\n\n线段树需要支持：\n\n- 区间增加 $1$；\n\n- 区间减少 $1$，并且保证每个被增加 $1$ 的区间在之后一定会减少 $1$；\n\n- 对于所有非 $0$ 的位置，根据它们的权值进行求和。\n\n由于这种方法严重超纲，因此不在这里详细阐述。感兴趣的读者可以参考下面的代码和注释，仅供挑战自我。\n\n**代码**\n\n```C++ [sol2-C++]\nstruct Segtree {\n    int cover;\n    int length;\n    int max_length;\n};\n\nclass Solution {\npublic:\n    int rectangleArea(vector<vector<int>>& rectangles) {\n        int n = rectangles.size();\n        for (const auto& rect: rectangles) {\n            // 下边界\n            hbound.push_back(rect[1]);\n            // 上边界\n            hbound.push_back(rect[3]);\n        }\n        sort(hbound.begin(), hbound.end());\n        hbound.erase(unique(hbound.begin(), hbound.end()), hbound.end());\n        int m = hbound.size();\n        // 线段树有 m-1 个叶子节点，对应着 m-1 个会被完整覆盖的线段，需要开辟 ~4m 大小的空间\n        tree.resize(m * 4 + 1);\n        init(1, 1, m - 1);\n\n        vector<tuple<int, int, int>> sweep;\n        for (int i = 0; i < n; ++i) {\n            // 左边界\n            sweep.emplace_back(rectangles[i][0], i, 1);\n            // 右边界\n            sweep.emplace_back(rectangles[i][2], i, -1);\n        }\n        sort(sweep.begin(), sweep.end());\n\n        long long ans = 0;\n        for (int i = 0; i < sweep.size(); ++i) {\n            int j = i;\n            while (j + 1 < sweep.size() && get<0>(sweep[i]) == get<0>(sweep[j + 1])) {\n                ++j;\n            }\n            if (j + 1 == sweep.size()) {\n                break;\n            }\n            // 一次性地处理掉一批横坐标相同的左右边界\n            for (int k = i; k <= j; ++k) {\n                auto&& [_, idx, diff] = sweep[k];\n                // 使用二分查找得到完整覆盖的线段的编号范围\n                int left = lower_bound(hbound.begin(), hbound.end(), rectangles[idx][1]) - hbound.begin() + 1;\n                int right = lower_bound(hbound.begin(), hbound.end(), rectangles[idx][3]) - hbound.begin();\n                update(1, 1, m - 1, left, right, diff);\n            }\n            ans += static_cast<long long>(tree[1].length) * (get<0>(sweep[j + 1]) - get<0>(sweep[j]));\n            i = j;\n        }\n        return ans % static_cast<int>(1e9 + 7);\n    }\n\n    void init(int idx, int l, int r) {\n        tree[idx].cover = tree[idx].length = 0;\n        if (l == r) {\n            tree[idx].max_length = hbound[l] - hbound[l - 1];\n            return;\n        }\n        int mid = (l + r) / 2;\n        init(idx * 2, l, mid);\n        init(idx * 2 + 1, mid + 1, r);\n        tree[idx].max_length = tree[idx * 2].max_length + tree[idx * 2 + 1].max_length;\n    }\n\n    void update(int idx, int l, int r, int ul, int ur, int diff) {\n        if (l > ur || r < ul) {\n            return;\n        }\n        if (ul <= l && r <= ur) {\n            tree[idx].cover += diff;\n            pushup(idx, l, r);\n            return;\n        }\n        int mid = (l + r) / 2;\n        update(idx * 2, l, mid, ul, ur, diff);\n        update(idx * 2 + 1, mid + 1, r, ul, ur, diff);\n        pushup(idx, l, r);\n    }\n\n    void pushup(int idx, int l, int r) {\n        if (tree[idx].cover > 0) {\n            tree[idx].length = tree[idx].max_length;\n        }\n        else if (l == r) {\n            tree[idx].length = 0;\n        }\n        else {\n            tree[idx].length = tree[idx * 2].length + tree[idx * 2 + 1].length;\n        }\n    }\n\nprivate:\n    vector<Segtree> tree;\n    vector<int> hbound;\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    private Segtree[] tree;\n    private List<Integer> hbound;\n\n    public int rectangleArea(int[][] rectangles) {\n        final int MOD = 1000000007;\n        int n = rectangles.length;\n        Set<Integer> set = new HashSet<Integer>();\n        for (int[] rect : rectangles) {\n            // 下边界\n            set.add(rect[1]);\n            // 上边界\n            set.add(rect[3]);\n        }\n        hbound = new ArrayList<Integer>(set);\n        Collections.sort(hbound);\n        int m = hbound.size();\n        // 线段树有 m-1 个叶子节点，对应着 m-1 个会被完整覆盖的线段，需要开辟 ~4m 大小的空间\n        tree = new Segtree[m * 4 + 1];\n        init(1, 1, m - 1);\n\n        List<int[]> sweep = new ArrayList<int[]>();\n        for (int i = 0; i < n; ++i) {\n            // 左边界\n            sweep.add(new int[]{rectangles[i][0], i, 1});\n            // 右边界\n            sweep.add(new int[]{rectangles[i][2], i, -1});\n        }\n        Collections.sort(sweep, (a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            } else if (a[1] != b[1]) {\n                return a[1] - b[1];\n            } else {\n                return a[2] - b[2];\n            }\n        });\n\n        long ans = 0;\n        for (int i = 0; i < sweep.size(); ++i) {\n            int j = i;\n            while (j + 1 < sweep.size() && sweep.get(i)[0] == sweep.get(j + 1)[0]) {\n                ++j;\n            }\n            if (j + 1 == sweep.size()) {\n                break;\n            }\n            // 一次性地处理掉一批横坐标相同的左右边界\n            for (int k = i; k <= j; ++k) {\n                int[] arr = sweep.get(k);\n                int idx = arr[1], diff = arr[2];\n                // 使用二分查找得到完整覆盖的线段的编号范围\n                int left = binarySearch(hbound, rectangles[idx][1]) + 1;\n                int right = binarySearch(hbound, rectangles[idx][3]);\n                update(1, 1, m - 1, left, right, diff);\n            }\n            ans += (long) tree[1].length * (sweep.get(j + 1)[0] - sweep.get(j)[0]);\n            i = j;\n        }\n        return (int) (ans % MOD);\n    }\n\n    public void init(int idx, int l, int r) {\n        tree[idx] = new Segtree();\n        if (l == r) {\n            tree[idx].maxLength = hbound.get(l) - hbound.get(l - 1);\n            return;\n        }\n        int mid = (l + r) / 2;\n        init(idx * 2, l, mid);\n        init(idx * 2 + 1, mid + 1, r);\n        tree[idx].maxLength = tree[idx * 2].maxLength + tree[idx * 2 + 1].maxLength;\n    }\n\n    public void update(int idx, int l, int r, int ul, int ur, int diff) {\n        if (l > ur || r < ul) {\n            return;\n        }\n        if (ul <= l && r <= ur) {\n            tree[idx].cover += diff;\n            pushup(idx, l, r);\n            return;\n        }\n        int mid = (l + r) / 2;\n        update(idx * 2, l, mid, ul, ur, diff);\n        update(idx * 2 + 1, mid + 1, r, ul, ur, diff);\n        pushup(idx, l, r);\n    }\n\n    public void pushup(int idx, int l, int r) {\n        if (tree[idx].cover > 0) {\n            tree[idx].length = tree[idx].maxLength;\n        } else if (l == r) {\n            tree[idx].length = 0;\n        } else {\n            tree[idx].length = tree[idx * 2].length + tree[idx * 2 + 1].length;\n        }\n    }\n\n    public int binarySearch(List<Integer> hbound, int target) {\n        int left = 0, right = hbound.size() - 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (hbound.get(mid) >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n\nclass Segtree {\n    int cover = 0;\n    int length = 0;\n    int maxLength = 0;\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    private Segtree[] tree;\n    private List<int> hbound;\n\n    public int RectangleArea(int[][] rectangles) {\n        const int MOD = 1000000007;\n        int n = rectangles.Length;\n        ISet<int> set = new HashSet<int>();\n        foreach (int[] rect in rectangles) {\n            // 下边界\n            set.Add(rect[1]);\n            // 上边界\n            set.Add(rect[3]);\n        }\n        hbound = new List<int>(set);\n        hbound.Sort();\n        int m = hbound.Count;\n        // 线段树有 m-1 个叶子节点，对应着 m-1 个会被完整覆盖的线段，需要开辟 ~4m 大小的空间\n        tree = new Segtree[m * 4 + 1];\n        Init(1, 1, m - 1);\n\n        List<Tuple<int, int, int>> sweep = new List<Tuple<int, int, int>>();\n        for (int i = 0; i < n; ++i) {\n            // 左边界\n            sweep.Add(new Tuple<int, int, int>(rectangles[i][0], i, 1));\n            // 右边界\n            sweep.Add(new Tuple<int, int, int>(rectangles[i][2], i, -1));\n        }\n        sweep.Sort();\n\n        long ans = 0;\n        for (int i = 0; i < sweep.Count; ++i) {\n            int j = i;\n            while (j + 1 < sweep.Count && sweep[i].Item1 == sweep[j + 1].Item1) {\n                ++j;\n            }\n            if (j + 1 == sweep.Count) {\n                break;\n            }\n            // 一次性地处理掉一批横坐标相同的左右边界\n            for (int k = i; k <= j; ++k) {\n                Tuple<int, int, int> tuple = sweep[k];\n                int idx = tuple.Item2, diff = tuple.Item3;\n                // 使用二分查找得到完整覆盖的线段的编号范围\n                int left = BinarySearch(hbound, rectangles[idx][1]) + 1;\n                int right = BinarySearch(hbound, rectangles[idx][3]);\n                Update(1, 1, m - 1, left, right, diff);\n            }\n            ans += (long) tree[1].Length * (sweep[j + 1].Item1 - sweep[j].Item1);\n            i = j;\n        }\n        return (int) (ans % MOD);\n    }\n\n    public void Init(int idx, int l, int r) {\n        tree[idx] = new Segtree();\n        if (l == r) {\n            tree[idx].MaxLength = hbound[l] - hbound[l - 1];\n            return;\n        }\n        int mid = (l + r) / 2;\n        Init(idx * 2, l, mid);\n        Init(idx * 2 + 1, mid + 1, r);\n        tree[idx].MaxLength = tree[idx * 2].MaxLength + tree[idx * 2 + 1].MaxLength;\n    }\n\n    public void Update(int idx, int l, int r, int ul, int ur, int diff) {\n        if (l > ur || r < ul) {\n            return;\n        }\n        if (ul <= l && r <= ur) {\n            tree[idx].Cover += diff;\n            Pushup(idx, l, r);\n            return;\n        }\n        int mid = (l + r) / 2;\n        Update(idx * 2, l, mid, ul, ur, diff);\n        Update(idx * 2 + 1, mid + 1, r, ul, ur, diff);\n        Pushup(idx, l, r);\n    }\n\n    public void Pushup(int idx, int l, int r) {\n        if (tree[idx].Cover > 0) {\n            tree[idx].Length = tree[idx].MaxLength;\n        } else if (l == r) {\n            tree[idx].Length = 0;\n        } else {\n            tree[idx].Length = tree[idx * 2].Length + tree[idx * 2 + 1].Length;\n        }\n    }\n\n    public int BinarySearch(List<int> hbound, int target) {\n        int left = 0, right = hbound.Count - 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (hbound[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n\nclass Segtree {\n    public int Cover = 0;\n    public int Length = 0;\n    public int MaxLength = 0;\n}\n```\n\n```Python [sol2-Python3]\nclass Segtree:\n    def __init__(self):\n        self.cover = 0\n        self.length = 0\n        self.max_length = 0\n\n\nclass Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        hbound = set()\n        for rect in rectangles:\n            # 下边界\n            hbound.add(rect[1])\n            # 上边界\n            hbound.add(rect[3])\n        \n        hbound = sorted(hbound)\n        m = len(hbound)\n        # 线段树有 m-1 个叶子节点，对应着 m-1 个会被完整覆盖的线段，需要开辟 ~4m 大小的空间\n        tree = [Segtree() for _ in range(m * 4 + 1)]\n\n        def init(idx: int, l: int, r: int) -> None:\n            tree[idx].cover = tree[idx].length = 0\n            if l == r:\n                tree[idx].max_length = hbound[l] - hbound[l - 1]\n                return\n            \n            mid = (l + r) // 2\n            init(idx * 2, l, mid)\n            init(idx * 2 + 1, mid + 1, r)\n            tree[idx].max_length = tree[idx * 2].max_length + tree[idx * 2 + 1].max_length\n        \n        def update(idx: int, l: int, r: int, ul: int, ur: int, diff: int) -> None:\n            if l > ur or r < ul:\n                return\n            if ul <= l and r <= ur:\n                tree[idx].cover += diff\n                pushup(idx, l, r)\n                return\n            \n            mid = (l + r) // 2\n            update(idx * 2, l, mid, ul, ur, diff)\n            update(idx * 2 + 1, mid + 1, r, ul, ur, diff)\n            pushup(idx, l, r)\n        \n        def pushup(idx: int, l: int, r: int) -> None:\n            if tree[idx].cover > 0:\n                tree[idx].length = tree[idx].max_length\n            elif l == r:\n                tree[idx].length = 0\n            else:\n                tree[idx].length = tree[idx * 2].length + tree[idx * 2 + 1].length\n\n        init(1, 1, m - 1)\n        \n        sweep = list()\n        for i, rect in enumerate(rectangles):\n            # 左边界\n            sweep.append((rect[0], i, 1))\n            # 右边界\n            sweep.append((rect[2], i, -1))\n        sweep.sort()\n\n        ans = i = 0\n        while i < len(sweep):\n            j = i\n            while j + 1 < len(sweep) and sweep[i][0] == sweep[j + 1][0]:\n                j += 1\n            if j + 1 == len(sweep):\n                break\n            \n            # 一次性地处理掉一批横坐标相同的左右边界\n            for k in range(i, j + 1):\n                _, idx, diff = sweep[k]\n                # 使用二分查找得到完整覆盖的线段的编号范围\n                left = bisect_left(hbound, rectangles[idx][1]) + 1\n                right = bisect_left(hbound, rectangles[idx][3])\n                update(1, 1, m - 1, left, right, diff)\n            \n            ans += tree[1].length * (sweep[j + 1][0] - sweep[j][0])\n            i = j + 1\n        \n        return ans % (10**9 + 7)\n```\n\n```C [sol2-C]\ntypedef struct {\n    int key;\n    UT_hash_handle hh;\n} HashItem; \n\ntypedef struct Tuple {\n    int val[3];\n} Tuple;\n\nHashItem *hashFindItem(HashItem **obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nbool hashAddItem(HashItem **obj, int key) {\n    if (hashFindItem(obj, key)) {\n        return false;\n    }\n    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = key;\n    HASH_ADD_INT(*obj, key, pEntry);\n    return true;\n}\n\nvoid hashFree(HashItem **obj) {\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);             \n    }\n}\n\nstatic inline int cmp1(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nstatic inline int cmp2(const void *pa, const void *pb) {\n    Tuple *a = (Tuple *)pa, *b = (Tuple *)pb;\n    if (a->val[0] != b->val[0]) {\n        return a->val[0] - b->val[0];\n    } else if (a->val[1] != b->val[1]) {\n        return a->val[1] - b->val[1];\n    } else {\n        return a->val[2] - b->val[2];\n    }\n}\n\ntypedef struct Segtree {\n    int cover;\n    int length;\n    int max_length;\n} Segtree;\n\nvoid pushup(int idx, int l, int r, Segtree *tree) {\n    if (tree[idx].cover > 0) {\n        tree[idx].length = tree[idx].max_length;\n    }\n    else if (l == r) {\n        tree[idx].length = 0;\n    }\n    else {\n        tree[idx].length = tree[idx * 2].length + tree[idx * 2 + 1].length;\n    }\n}\n\nvoid init(int idx, int l, int r, Segtree *tree, int *hbound) {\n    tree[idx].cover = tree[idx].length = 0;\n    if (l == r) {\n        tree[idx].max_length = hbound[l] - hbound[l - 1];\n        return;\n    }\n    int mid = (l + r) / 2;\n    init(idx * 2, l, mid, tree, hbound);\n    init(idx * 2 + 1, mid + 1, r, tree, hbound);\n    tree[idx].max_length = tree[idx * 2].max_length + tree[idx * 2 + 1].max_length;\n}\n\nvoid update(int idx, int l, int r, int ul, int ur, int diff, Segtree *tree) {\n    if (l > ur || r < ul) {\n        return;\n    }\n    if (ul <= l && r <= ur) {\n        tree[idx].cover += diff;\n        pushup(idx, l, r, tree);\n        return;\n    }\n    int mid = (l + r) / 2;\n    update(idx * 2, l, mid, ul, ur, diff, tree);\n    update(idx * 2 + 1, mid + 1, r, ul, ur, diff, tree);\n    pushup(idx, l, r, tree);\n}\n\nint lowerBound(int *hbound, int hboundSize, int target) {\n    int left = 0, right = hboundSize - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (hbound[mid] >= target) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n\nint rectangleArea(int** rectangles, int rectanglesSize, int* rectanglesColSize){\n    int n = rectanglesSize;\n    HashItem *set = NULL;\n    for (int i = 0; i < n; i++) {\n        // 下边界\n        hashAddItem(&set, rectangles[i][1]);\n        // 上边界\n        hashAddItem(&set, rectangles[i][3]);\n    }\n    int hboundSize = HASH_COUNT(set);\n    int hbound[hboundSize], pos = 0;\n    for (HashItem *pEntry = set; pEntry != NULL; pEntry = pEntry->hh.next) {\n        hbound[pos++] = pEntry->key;\n    }\n    hashFree(&set);\n    qsort(hbound, hboundSize, sizeof(int), cmp1);\n    // 「思路与算法部分」的 length 数组并不需要显式地存储下来\n    // length[i] 可以通过 hbound[i+1] - hbound[i] 得到\n    int m = hboundSize;\n    // 线段树有 m-1 个叶子节点，对应着 m-1 个会被完整覆盖的线段，需要开辟 ~4m 大小的空间\n    Segtree tree[m * 4 + 1];\n    init(1, 1, m - 1, tree, hbound);\n\n    int sweepSize = n * 2;\n    Tuple sweep[sweepSize];\n    pos = 0;\n    for (int i = 0; i < n; ++i) {\n        // 左边界\n        sweep[pos].val[0] = rectangles[i][0];\n        sweep[pos].val[1] = i;\n        sweep[pos].val[2] = 1;\n        pos++;\n        // 右边界\n        sweep[pos].val[0] = rectangles[i][2];\n        sweep[pos].val[1] = i;\n        sweep[pos].val[2] = -1;\n        pos++;\n    }\n    qsort(sweep, sweepSize, sizeof(Tuple), cmp2);\n    \n    long long ans = 0;\n    for (int i = 0; i < sweepSize; ++i) {\n        int j = i;\n        while (j + 1 < sweepSize && sweep[i].val[0] == sweep[j + 1].val[0]) {\n            ++j;\n        }\n        if (j + 1 == sweepSize) {\n            break;\n        }\n        // 一次性地处理掉一批横坐标相同的左右边界\n        for (int k = i; k <= j; ++k) {\n            int idx = sweep[k].val[1], diff = sweep[k].val[2];\n            // 使用二分查找得到完整覆盖的线段的编号范围\n            int left = lowerBound(hbound, hboundSize, rectangles[idx][1]) + 1;\n            int right = lowerBound(hbound, hboundSize, rectangles[idx][3]);\n            update(1, 1, m - 1, left, right, diff, tree);\n        }\n        ans += (long long)(tree[1].length) * (sweep[j + 1].val[0] - sweep[j].val[0]);\n        i = j;\n    }\n    return ans % (long long)(1e9 + 7);\n}\n```\n\n```go [sol2-Golang]\ntype seg []struct{ cover, len, maxLen int }\n\nfunc (t seg) init(hBound []int, idx, l, r int) {\n    if l == r {\n        t[idx].maxLen = hBound[l] - hBound[l-1]\n        return\n    }\n    mid := (l + r) / 2\n    t.init(hBound, idx*2, l, mid)\n    t.init(hBound, idx*2+1, mid+1, r)\n    t[idx].maxLen = t[idx*2].maxLen + t[idx*2+1].maxLen\n}\n\nfunc (t seg) update(idx, l, r, ul, ur, diff int) {\n    if l > ur || r < ul {\n        return\n    }\n    if ul <= l && r <= ur {\n        t[idx].cover += diff\n        t.pushUp(idx, l, r)\n        return\n    }\n    mid := (l + r) / 2\n    t.update(idx*2, l, mid, ul, ur, diff)\n    t.update(idx*2+1, mid+1, r, ul, ur, diff)\n    t.pushUp(idx, l, r)\n}\n\nfunc (t seg) pushUp(idx, l, r int) {\n    if t[idx].cover > 0 {\n        t[idx].len = t[idx].maxLen\n    } else if l == r {\n        t[idx].len = 0\n    } else {\n        t[idx].len = t[idx*2].len + t[idx*2+1].len\n    }\n}\n\nfunc rectangleArea(rectangles [][]int) (ans int) {\n    n := len(rectangles) * 2\n    hBound := make([]int, 0, n)\n    for _, r := range rectangles {\n        hBound = append(hBound, r[1], r[3])\n    }\n    // 排序，方便下面去重\n    sort.Ints(hBound)\n    m := 0\n    for _, b := range hBound[1:] {\n        if hBound[m] != b {\n            m++\n            hBound[m] = b\n        }\n    }\n    hBound = hBound[:m+1]\n    t := make(seg, m*4)\n    t.init(hBound, 1, 1, m)\n\n    type tuple struct{ x, i, d int }\n    sweep := make([]tuple, 0, n)\n    for i, r := range rectangles {\n        sweep = append(sweep, tuple{r[0], i, 1}, tuple{r[2], i, -1})\n    }\n    sort.Slice(sweep, func(i, j int) bool { return sweep[i].x < sweep[j].x })\n\n    for i := 0; i < n; i++ {\n        j := i\n        for j+1 < n && sweep[j+1].x == sweep[i].x {\n            j++\n        }\n        if j+1 == n {\n            break\n        }\n        // 一次性地处理掉一批横坐标相同的左右边界\n        for k := i; k <= j; k++ {\n            idx, diff := sweep[k].i, sweep[k].d\n            // 使用二分查找得到完整覆盖的线段的编号范围\n            left := sort.SearchInts(hBound, rectangles[idx][1]) + 1\n            right := sort.SearchInts(hBound, rectangles[idx][3])\n            t.update(1, 1, m, left, right, diff)\n        }\n        ans += t[1].len * (sweep[j+1].x - sweep[j].x)\n        i = j\n    }\n    return ans % (1e9 + 7)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是矩形的个数。\n\n- 空间复杂度：$O(n)$，即为线段树需要使用的空间。"
}