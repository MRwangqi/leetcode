{
	"titleSlug": "subtree-of-another-tree",
	"slug": "ling-yi-ge-shu-de-zi-shu-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![572. å¦ä¸€ä¸ªæ ‘çš„å­æ ‘ ä»²è€€æ™–.mp4](5283b7d4-d346-4570-bbdb-fa07221139e9)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n\n#### æ–¹æ³•ä¸€ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢æš´åŠ›åŒ¹é…\n\n**æ€è·¯å’Œç®—æ³•**\n\nè¿™æ˜¯ä¸€ç§æœ€æœ´ç´ çš„æ–¹æ³•â€”â€”æ·±åº¦ä¼˜å…ˆæœç´¢æšä¸¾ $s$ ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ¤æ–­è¿™ä¸ªç‚¹çš„å­æ ‘æ˜¯å¦å’Œ $t$ ç›¸ç­‰ã€‚å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªèŠ‚ç‚¹çš„å­æ ‘æ˜¯å¦å’Œ $t$ ç›¸ç­‰å‘¢ï¼Œæˆ‘ä»¬åˆéœ€è¦åšä¸€æ¬¡æ·±åº¦ä¼˜å…ˆæœç´¢æ¥æ£€æŸ¥ï¼Œå³è®©ä¸¤ä¸ªæŒ‡é’ˆä¸€å¼€å§‹å…ˆæŒ‡å‘è¯¥èŠ‚ç‚¹å’Œ $t$ çš„æ ¹ï¼Œç„¶åã€ŒåŒæ­¥ç§»åŠ¨ã€ä¸¤æ ¹æŒ‡é’ˆæ¥ã€ŒåŒæ­¥éå†ã€è¿™ä¸¤æ£µæ ‘ï¼Œåˆ¤æ–­å¯¹åº”ä½ç½®æ˜¯å¦ç›¸ç­‰ã€‚\n\n<![fig1](https://assets.leetcode-cn.com/solution-static/572/1.PNG),![fig2](https://assets.leetcode-cn.com/solution-static/572/2.PNG),![fig3](https://assets.leetcode-cn.com/solution-static/572/3.PNG),![fig4](https://assets.leetcode-cn.com/solution-static/572/4.PNG),![fig5](https://assets.leetcode-cn.com/solution-static/572/5.PNG),![fig6](https://assets.leetcode-cn.com/solution-static/572/6.PNG)>\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool check(TreeNode *o, TreeNode *t) {\n        if (!o && !t) {\n            return true;\n        }\n        if ((o && !t) || (!o && t) || (o->val != t->val)) {\n            return false;\n        }\n        return check(o->left, t->left) && check(o->right, t->right);\n    }\n\n    bool dfs(TreeNode *o, TreeNode *t) {\n        if (!o) {\n            return false;\n        }\n        return check(o, t) || dfs(o->left, t) || dfs(o->right, t);\n    }\n\n    bool isSubtree(TreeNode *s, TreeNode *t) {\n        return dfs(s, t);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean isSubtree(TreeNode s, TreeNode t) {\n        return dfs(s, t);\n    }\n\n    public boolean dfs(TreeNode s, TreeNode t) {\n        if (s == null) {\n            return false;\n        }\n        return check(s, t) || dfs(s.left, t) || dfs(s.right, t);\n    }\n\n    public boolean check(TreeNode s, TreeNode t) {\n        if (s == null && t == null) {\n            return true;\n        }\n        if (s == null || t == null || s.val != t.val) {\n            return false;\n        }\n        return check(s.left, t.left) && check(s.right, t.right);\n    }\n}\n```\n\n```golang [sol1-Golang]\nfunc isSubtree(s *TreeNode, t *TreeNode) bool {\n    if s == nil {\n        return false\n    }\n    return check(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)\n}\n\nfunc check(a, b *TreeNode) bool {\n    if a == nil && b == nil {\n        return true\n    }\n    if a == nil || b == nil {\n        return false\n    }\n    if a.Val == b.Val {\n        return check(a.Left, b.Left) && check(a.Right, b.Right)\n    }\n    return false\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n+ æ—¶é—´å¤æ‚åº¦ï¼šå¯¹äºæ¯ä¸€ä¸ª $s$ ä¸Šçš„ç‚¹ï¼Œéƒ½éœ€è¦åšä¸€æ¬¡æ·±åº¦ä¼˜å…ˆæœç´¢æ¥å’Œ $t$ åŒ¹é…ï¼ŒåŒ¹é…ä¸€æ¬¡çš„æ—¶é—´ä»£ä»·æ˜¯ $O(|t|)$ï¼Œé‚£ä¹ˆæ€»çš„æ—¶é—´ä»£ä»·å°±æ˜¯ $O(|s| \\times |t|)$ã€‚æ•…æ¸è¿›æ—¶é—´å¤æ‚åº¦ä¸º $O(|s| \\times |t|)$ã€‚\n+ ç©ºé—´å¤æ‚åº¦ï¼šå‡è®¾ $s$ æ·±åº¦ä¸º $d_s$ï¼Œ$t$ çš„æ·±åº¦ä¸º $d_t$ï¼Œä»»æ„æ—¶åˆ»æ ˆç©ºé—´çš„æœ€å¤§ä½¿ç”¨ä»£ä»·æ˜¯ $O(\\max \\{ d_s, d_t \\})$ã€‚æ•…æ¸è¿›ç©ºé—´å¤æ‚åº¦ä¸º $O(\\max \\{ d_s, d_t \\})$ã€‚\n\n#### æ–¹æ³•äºŒï¼šæ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ä¸Šåšä¸²åŒ¹é…\n\n**æ€è·¯å’Œç®—æ³•**\n\nè¿™ä¸ªæ–¹æ³•éœ€è¦æˆ‘ä»¬å…ˆäº†è§£ä¸€ä¸ªã€Œå°å¥—è·¯ã€ï¼šä¸€æ£µå­æ ‘ä¸Šçš„ç‚¹åœ¨æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ï¼ˆå³å…ˆåºéå†ï¼‰ä¸­æ˜¯è¿ç»­çš„ã€‚äº†è§£äº†è¿™ä¸ªã€Œå°å¥—è·¯ã€ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šè§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹å‘å°±æ˜¯ï¼šæŠŠ $s$ å’Œ $t$ å…ˆè½¬æ¢æˆæ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ï¼Œç„¶åçœ‹ $t$ çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—æ˜¯å¦æ˜¯ $s$ çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—çš„ã€Œå­ä¸²ã€ã€‚\n\n**è¿™æ ·åšæ­£ç¡®å—ï¼Ÿ** å‡è®¾ $s$ ç”±ä¸¤ä¸ªç‚¹ç»„æˆï¼Œ$1$ æ˜¯æ ¹ï¼Œ$2$ æ˜¯ $1$ çš„å·¦å­©å­ï¼›$t$ ä¹Ÿç”±ä¸¤ä¸ªç‚¹ç»„æˆï¼Œ$1$ æ˜¯æ ¹ï¼Œ$2$ æ˜¯ $1$ çš„å³å­©å­ã€‚è¿™æ ·ä¸€æ¥ $s$ å’Œ $t$ çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ç›¸åŒï¼Œå¯æ˜¯ $t$ å¹¶ä¸æ˜¯ $s$ çš„æŸä¸€æ£µå­æ ‘ã€‚ç”±æ­¤å¯è§ã€Œ$s$ çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—åŒ…å« $t$ çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ã€æ˜¯ã€Œ$t$ æ˜¯ $s$ å­æ ‘ã€çš„**å¿…è¦ä¸å……åˆ†æ¡ä»¶**ï¼Œæ‰€ä»¥å•çº¯è¿™æ ·åšæ˜¯ä¸æ­£ç¡®çš„ã€‚\n\nä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥å¼•å…¥ä¸¤ä¸ªç©ºå€¼ `lNull` å’Œ `rNull`ï¼Œå½“ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­©å­æˆ–è€…å³å­©å­ä¸ºç©ºçš„æ—¶å€™ï¼Œå°±æ’å…¥è¿™ä¸¤ä¸ªç©ºå€¼ï¼Œè¿™æ ·æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—å°±å”¯ä¸€å¯¹åº”ä¸€æ£µæ ‘ã€‚å¤„ç†å®Œä¹‹åï¼Œå°±å¯ä»¥é€šè¿‡åˆ¤æ–­ã€Œ$s$ çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—åŒ…å« $t$ çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ã€æ¥åˆ¤æ–­ç­”æ¡ˆã€‚\n\n![fig1](https://assets.leetcode-cn.com/solution-static/572/572_fig1.png)\n\nåœ¨åˆ¤æ–­ã€Œ$s$ çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—åŒ…å« $t$ çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ã€çš„æ—¶å€™ï¼Œå¯ä»¥æš´åŠ›åŒ¹é…ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ $\\text{KMP}$ æˆ–è€… $\\text{Rabin-Karp}$ ç®—æ³•ï¼Œåœ¨ä½¿ç”¨ $\\text{Rabin-Karp}$ ç®—æ³•çš„æ—¶å€™ï¼Œè¦æ³¨æ„ä¸²ä¸­å¯èƒ½æœ‰è´Ÿå€¼ã€‚\n\nè¿™é‡Œç»™å‡ºç”¨ $\\text{KMP}$ åˆ¤æ–­çš„ä»£ç å®ç°ã€‚\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector <int> sOrder, tOrder;\n    int maxElement, lNull, rNull;\n\n    void getMaxElement(TreeNode *o) {\n        if (!o) {\n            return;\n        }\n        maxElement = max(maxElement, o->val);\n        getMaxElement(o->left);\n        getMaxElement(o->right);\n    }\n\n    void getDfsOrder(TreeNode *o, vector <int> &tar) {\n        if (!o) {\n            return;\n        }\n        tar.push_back(o->val);\n        if (o->left) {\n            getDfsOrder(o->left, tar);\n        } else {\n            tar.push_back(lNull);\n        }\n        if (o->right) {\n            getDfsOrder(o->right, tar);\n        } else {\n            tar.push_back(rNull);\n        }\n    }\n\n    bool kmp() {\n        int sLen = sOrder.size(), tLen = tOrder.size();\n        vector <int> fail(tOrder.size(), -1);\n        for (int i = 1, j = -1; i < tLen; ++i) {\n            while (j != -1 && tOrder[i] != tOrder[j + 1]) {\n                j = fail[j];\n            }\n            if (tOrder[i] == tOrder[j + 1]) {\n                ++j;\n            }\n            fail[i] = j;\n        }\n        for (int i = 0, j = -1; i < sLen; ++i) {\n            while (j != -1 && sOrder[i] != tOrder[j + 1]) {\n                j = fail[j];\n            }\n            if (sOrder[i] == tOrder[j + 1]) {\n                ++j;\n            }\n            if (j == tLen - 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    bool isSubtree(TreeNode* s, TreeNode* t) {\n        maxElement = INT_MIN;\n        getMaxElement(s);\n        getMaxElement(t);\n        lNull = maxElement + 1;\n        rNull = maxElement + 2;\n\n        getDfsOrder(s, sOrder);\n        getDfsOrder(t, tOrder);\n\n        return kmp();\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    List<Integer> sOrder = new ArrayList<Integer>();\n    List<Integer> tOrder = new ArrayList<Integer>();\n    int maxElement, lNull, rNull;\n\n    public boolean isSubtree(TreeNode s, TreeNode t) {\n        maxElement = Integer.MIN_VALUE;\n        getMaxElement(s);\n        getMaxElement(t);\n        lNull = maxElement + 1;\n        rNull = maxElement + 2;\n\n        getDfsOrder(s, sOrder);\n        getDfsOrder(t, tOrder);\n\n        return kmp();\n    }\n\n    public void getMaxElement(TreeNode t) {\n        if (t == null) {\n            return;\n        }\n        maxElement = Math.max(maxElement, t.val);\n        getMaxElement(t.left);\n        getMaxElement(t.right);\n    }\n\n    public void getDfsOrder(TreeNode t, List<Integer> tar) {\n        if (t == null) {\n            return;\n        }\n        tar.add(t.val);\n        if (t.left != null) {\n            getDfsOrder(t.left, tar);\n        } else {\n            tar.add(lNull);\n        }\n        if (t.right != null) {\n            getDfsOrder(t.right, tar);\n        } else {\n            tar.add(rNull);\n        }\n    }\n\n    public boolean kmp() {\n        int sLen = sOrder.size(), tLen = tOrder.size();\n        int[] fail = new int[tOrder.size()];\n        Arrays.fill(fail, -1);\n        for (int i = 1, j = -1; i < tLen; ++i) {\n            while (j != -1 && !(tOrder.get(i).equals(tOrder.get(j + 1)))) {\n                j = fail[j];\n            }\n            if (tOrder.get(i).equals(tOrder.get(j + 1))) {\n                ++j;\n            }\n            fail[i] = j;\n        }\n        for (int i = 0, j = -1; i < sLen; ++i) {\n            while (j != -1 && !(sOrder.get(i).equals(tOrder.get(j + 1)))) {\n                j = fail[j];\n            }\n            if (sOrder.get(i).equals(tOrder.get(j + 1))) {\n                ++j;\n            }\n            if (j == tLen - 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```golang [sol2-Golang]\nfunc isSubtree(s *TreeNode, t *TreeNode) bool {\n    maxEle := math.MinInt32\n    getMaxElement(s, &maxEle)\n    getMaxElement(t, &maxEle)\n    lNull := maxEle + 1;\n    rNull := maxEle + 2;\n\n    sl, tl := getDfsOrder(s, []int{}, lNull, rNull), getDfsOrder(t, []int{}, lNull, rNull)\n    return kmp(sl, tl)\n}\n\nfunc kmp(s, t []int) bool {\n    sLen, tLen := len(s), len(t)\n    fail := make([]int, sLen)\n    for i := 0; i < sLen; i++ {\n        fail[i] = -1\n    }\n    for i, j := 1, -1; i < tLen; i++ {\n        for j != -1 && t[i] != t[j+1] {\n            j = fail[j]\n        }\n        if t[i] == t[j+1] {\n            j++\n        }\n        fail[i] = j\n    }\n\n    for i, j := 0, -1; i < sLen; i++ {\n        for j != -1 && s[i] != t[j+1] {\n            j = fail[j]\n        }\n        if s[i] == t[j+1] {\n            j++\n        }\n        if j == tLen - 1 {\n            return true\n        }\n    }\n    return false\n}\n\nfunc getDfsOrder(t *TreeNode, list []int, lNull, rNull int) []int {\n    if t == nil {\n        return list\n    }\n    list = append(list, t.Val)\n    if t.Left != nil {\n        list = getDfsOrder(t.Left, list, lNull, rNull)\n    } else {\n        list = append(list, lNull)\n    }\n\n    if t.Right != nil {\n        list = getDfsOrder(t.Right, list, lNull, rNull)\n    } else {\n        list = append(list, rNull)\n    }\n    return list\n} \n\nfunc getMaxElement(t *TreeNode, maxEle *int) {\n    if t == nil {\n        return\n    }\n    if t.Val > *maxEle {\n        *maxEle = t.Val\n    }\n    getMaxElement(t.Left, maxEle)\n    getMaxElement(t.Right, maxEle)\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n+ æ—¶é—´å¤æ‚åº¦ï¼šéå†ä¸¤æ£µæ ‘å¾—åˆ°æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—çš„æ—¶é—´ä»£ä»·æ˜¯ $O(|s| + |t|)$ï¼Œåœ¨åŒ¹é…çš„æ—¶å€™ï¼Œå¦‚æœä½¿ç”¨æš´åŠ›åŒ¹é…ï¼Œæ—¶é—´ä»£ä»·ä¸º $O(|s| \\times |t|)$ï¼Œä½¿ç”¨ $\\text{KMP}$ æˆ– $\\text{Rabin-Karp}$ è¿›è¡Œä¸²åŒ¹é…çš„æ—¶é—´ä»£ä»·éƒ½æ˜¯ $O(|s| + |t|)$ã€‚ç”±äºè¿™é‡Œçš„ä»£ç ä½¿ç”¨ $\\text{KMP}$ å®ç°çš„ï¼Œæ‰€ä»¥æ¸è¿›æ—¶é—´å¤æ‚åº¦ä¸º $O(|s| + |t|)$ã€‚\n+ ç©ºé—´å¤æ‚åº¦ï¼šè¿™é‡Œä¿å­˜äº†ä¸¤ä¸ªæ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ï¼Œè¿˜è®¡ç®—äº† $|t|$ é•¿åº¦çš„ `fail` æ•°ç»„ï¼Œè¾…åŠ©ç©ºé—´çš„æ€»ä»£ä»·ä¸º $O(|s| + |t|)$ï¼Œä»»æ„æ—¶åˆ»æ ˆç©ºé—´çš„æœ€å¤§ä½¿ç”¨ä»£ä»·æ˜¯ $O(\\max \\{ d_s, d_t \\})$ï¼Œç”±äº $\\max \\{ d_s, d_t \\} = O(|s| + |t|)$ï¼Œæ•…æ¸è¿›ç©ºé—´å¤æ‚åº¦ä¸º $O(|s| + |t|)$ã€‚\n\n\n#### æ–¹æ³•ä¸‰ï¼šæ ‘å“ˆå¸Œ\n\n**æ€è·¯å’Œç®—æ³•**\n\nè€ƒè™‘æŠŠæ¯ä¸ªå­æ ‘éƒ½æ˜ å°„æˆä¸€ä¸ªå”¯ä¸€çš„æ•°ï¼Œå¦‚æœ $t$ å¯¹åº”çš„æ•°å­—å’Œ $s$ ä¸­ä»»æ„ä¸€ä¸ªå­æ ‘æ˜ å°„çš„æ•°å­—ç›¸ç­‰ï¼Œåˆ™ $t$ æ˜¯ $s$ çš„æŸä¸€æ£µå­æ ‘ã€‚å¦‚ä½•æ˜ å°„å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥å®šä¹‰è¿™æ ·çš„å“ˆå¸Œå‡½æ•°ï¼š\n\n$$ f_o = v_o + 31 \\cdot f_l \\cdot p(s_l) + 179 \\cdot f_r \\cdot p(s_r) $$\n\nè¿™é‡Œ $f_x$ è¡¨ç¤ºèŠ‚ç‚¹ $x$ çš„å“ˆå¸Œå€¼ï¼Œ$s_x$ è¡¨ç¤ºèŠ‚ç‚¹ $x$ å¯¹åº”çš„å­æ ‘å¤§å°ï¼Œ$v_x$ ä»£è¡¨èŠ‚ç‚¹ $x$ çš„ `val`ï¼Œ$p(n)$ è¡¨ç¤ºç¬¬ $n$ ä¸ªç´ æ•°ï¼Œ$o$ è¡¨ç¤ºå½“å‰èŠ‚ç‚¹ï¼Œ$l$ å’Œ $r$ åˆ†åˆ«è¡¨ç¤ºå·¦å³å­©å­ã€‚è¿™ä¸ªå¼å­çš„æ„æ€æ˜¯ï¼šå½“å‰èŠ‚ç‚¹ $o$ çš„å“ˆå¸Œå€¼ç­‰äºè¿™ä¸ªç‚¹çš„ `val` åŠ ä¸Š $31$ å€å·¦å­æ ‘çš„å“ˆå¸Œå€¼ä¹˜ä»¥ç¬¬ $s_l$ ä¸ªç´ æ•°ï¼Œå†åŠ ä¸Š $179$ å€å³å­æ ‘çš„å“ˆå¸Œå€¼ä¹˜ä»¥ç¬¬ $s_r$ ä¸ªç´ æ•°ã€‚è¿™é‡Œçš„ $31$ å’Œ $179$ è¿™ä¸¤ä¸ªæ•°å­—åªæ˜¯ä¸ºäº†åŒºåˆ†å·¦å³å­æ ‘ï¼Œä½ å¯ä»¥è‡ªå·±é€‰æ‹©ä½ å–œæ¬¢çš„æƒå€¼ã€‚\n\n**è¿™æ ·åšä¸ºä»€ä¹ˆå¯è¡Œå‘¢ï¼Ÿ** å›åˆ°æˆ‘ä»¬çš„åˆè¡·ï¼Œæˆ‘ä»¬å¸Œæœ›æŠŠæ¯ä¸ªå­æ ‘éƒ½æ˜ å°„æˆä¸€ä¸ªå”¯ä¸€çš„æ•°ï¼Œè¿™æ ·çœŸçš„èƒ½å¤Ÿç¡®ä¿å”¯ä¸€å—ï¼Ÿå®é™…ä¸Šæœªå¿…ã€‚ä½†æ˜¯æˆ‘ä»¬åœ¨è¿™ä¸ªå“ˆå¸Œå‡½æ•°ä¸­è€ƒè™‘åˆ°æ¯ä¸ªç‚¹çš„ `val`ã€å­æ ‘å“ˆå¸Œå€¼ã€å­æ ‘å¤§å°ä»¥åŠå·¦å³å­æ ‘çš„ä¸åŒæƒå€¼ï¼Œæ‰€ä»¥è¿™äº›å› ç´ å…±åŒå½±å“ä¸€ä¸ªç‚¹çš„å“ˆå¸Œå€¼ï¼Œæ‰€ä»¥å‡ºç°å†²çªçš„å‡ ç‡è¾ƒå°ï¼Œä¸€èˆ¬æˆ‘ä»¬å¯ä»¥å¿½ç•¥ã€‚å½“ç„¶ä½ ä¹Ÿå¯ä»¥è®¾è®¡ä½ è‡ªå·±çš„å“ˆå¸Œå‡½æ•°ï¼Œåªè¦è€ƒè™‘åˆ°è¿™äº›å› ç´ ï¼Œå°±å¯ä»¥æŠŠå†²çªçš„å¯èƒ½æ€§è®¾è®¡å¾—æ¯”è¾ƒå°ã€‚**å¯æ˜¯å¦‚æœè¿˜æ˜¯å‡ºç°äº†å†²çªæ€ä¹ˆåŠå‘¢ï¼Ÿ** æˆ‘ä»¬å¯ä»¥è®¾è®¡ä¸¤ä¸ªå“ˆå¸Œå‡½æ•° $f_1$ å’Œ $f_2$ï¼Œç”¨è¿™ä¸¤ä¸ªå“ˆå¸Œå‡½æ•°ç”Ÿæˆç¬¬ä¸‰ä¸ªå“ˆå¸Œå‡½æ•°ï¼Œæ¯”å¦‚ $f = f_1 + f_2$ã€$f = f_1 \\times f_2$ ç­‰ç­‰ï¼Œè¿™æ ·å¯ä»¥è¿›ä¸€æ­¥ç¼©å°å†²çªï¼Œå¦‚æœ $f_1$ çš„å†²çªæ¦‚ç‡æ˜¯ $P_1$ï¼Œ$f_2$ çš„å†²çªæ¦‚ç‡æ˜¯ $P_2$ï¼Œé‚£ä¹ˆ $f$ çš„å†²çªæ¦‚ç‡å°±æ˜¯ $P_1 \\times P_2$ï¼Œç†è®ºä¸Šå·²ç»éå¸¸å°äº†ï¼Œè¿™å°±æ˜¯ã€ŒåŒå“ˆå¸Œã€ã€‚å½“ç„¶ï¼Œä¸ºäº†å‡å°‘å†²çªï¼Œä½ ä¹Ÿå¯ä»¥è®¾è®¡ã€Œä¸‰å“ˆå¸Œã€ã€ã€Œå››å“ˆå¸Œã€ç­‰ï¼Œå¯æ˜¯è¿™æ ·ç¼–ç¨‹çš„å¤æ‚åº¦å°±ä¼šå¢åŠ ã€‚å®é™…ä¸Šï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œåªè¦è¿æ°”ä¸æ˜¯å¤ªå·®ï¼Œä¸€ä¸ªå“ˆå¸Œå‡½æ•°å°±è¶³å¤Ÿäº†ã€‚\n\næˆ‘ä»¬å¯ä»¥ç”¨ã€ŒåŸƒæ°ç­›æ³•ã€æˆ–è€…ã€Œæ¬§æ‹‰ç­›æ³•ã€æ±‚å‡ºå‰ $\\arg \\pi (\\max \\{ |s|, |t| \\})$ ä¸ªç´ æ•°ï¼ˆå…¶ä¸­ $\\pi (x)$ è¡¨ç¤º $x$ ä»¥å†…ç´ æ•°ä¸ªæ•°ï¼Œ$\\arg \\pi (x)$ ä¸ºå®ƒçš„åå‡½æ•°ï¼Œè¡¨ç¤ºæœ‰å¤šå°‘ä»¥å†…åŒ…å« $x$ ä¸ªç´ æ•°ï¼Œè¿™ä¸ªæ˜ å°„æ˜¯ä¸å”¯ä¸€çš„ï¼Œæˆ‘ä»¬å–æœ€å°å€¼ï¼‰ï¼Œç„¶åæ·±åº¦ä¼˜å…ˆæœç´¢è®¡ç®—å“ˆå¸Œå€¼ï¼Œæœ€åæ¯”è¾ƒ $s$ çš„æ‰€æœ‰å­æ ‘æ˜¯å¦æœ‰å’Œ $t$ ç›¸åŒçš„å“ˆå¸Œå€¼å³å¯ã€‚\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    static constexpr int MAX_N = 1000 + 5;\n    static constexpr int MOD = int(1E9) + 7;\n\n    bool vis[MAX_N];\n    int p[MAX_N], tot;\n    void getPrime() {\n        vis[0] = vis[1] = 1; tot = 0;\n        for (int i = 2; i < MAX_N; ++i) {\n            if (!vis[i]) p[++tot] = i;\n            for (int j = 1; j <= tot && i * p[j] < MAX_N; ++j) {\n                vis[i * p[j]] = 1;\n                if (i % p[j] == 0) break;\n            }\n        }\n    }\n\n    struct Status {\n        int f, s; // f ä¸ºå“ˆå¸Œå€¼ | s ä¸ºå­æ ‘å¤§å°\n        Status(int f_ = 0, int s_ = 0) \n            : f(f_), s(s_) {}\n    };\n\n    unordered_map <TreeNode *, Status> hS, hT;\n\n    void dfs(TreeNode *o, unordered_map <TreeNode *, Status> &h) {\n        h[o] = Status(o->val, 1);\n        if (!o->left && !o->right) return;\n        if (o->left) {\n            dfs(o->left, h);\n            h[o].s += h[o->left].s;\n            h[o].f = (h[o].f + (31LL * h[o->left].f * p[h[o->left].s]) % MOD) % MOD;\n        }\n        if (o->right) {\n            dfs(o->right, h);\n            h[o].s += h[o->right].s;\n            h[o].f = (h[o].f + (179LL * h[o->right].f * p[h[o->right].s]) % MOD) % MOD;\n        }\n    }\n\n    bool isSubtree(TreeNode* s, TreeNode* t) {\n        getPrime();\n        dfs(s, hS);\n        dfs(t, hT);\n\n        int tHash = hT[t].f;\n        for (const auto &[k, v]: hS) {\n            if (v.f == tHash) {\n                return true;\n            }\n        } \n\n        return false;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    static final int MAX_N = 1005;\n    static final int MOD = 1000000007;\n    boolean[] vis = new boolean[MAX_N];\n    int[] p = new int[MAX_N];\n    int tot;\n    Map<TreeNode, int[]> hS = new HashMap<TreeNode, int[]>();\n    Map<TreeNode, int[]> hT = new HashMap<TreeNode, int[]>();\n\n    public boolean isSubtree(TreeNode s, TreeNode t) {\n        getPrime();\n        dfs(s, hS);\n        dfs(t, hT);\n\n        int tHash = hT.get(t)[0];\n        for (Map.Entry<TreeNode, int[]> entry : hS.entrySet()) {\n            if (entry.getValue()[0] == tHash) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public void getPrime() {\n        vis[0] = vis[1] = true;\n        tot = 0;\n        for (int i = 2; i < MAX_N; ++i) {\n            if (!vis[i]) {\n                p[++tot] = i;\n            }\n            for (int j = 1; j <= tot && i * p[j] < MAX_N; ++j) {\n                vis[i * p[j]] = true;\n                if (i % p[j] == 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    public void dfs(TreeNode o, Map<TreeNode, int[]> h) {\n        h.put(o, new int[]{o.val, 1});\n        if (o.left == null && o.right == null) {\n            return;\n        }\n        if (o.left != null) {\n            dfs(o.left, h);\n            int[] val = h.get(o);\n            val[1] += h.get(o.left)[1];\n            val[0] = (int) ((val[0] + (31L * h.get(o.left)[0] * p[h.get(o.left)[1]]) % MOD) % MOD);\n        }\n        if (o.right != null) {\n            dfs(o.right, h);\n            int[] val = h.get(o);\n            val[1] += h.get(o.right)[1];\n            val[0] = (int) ((val[0] + (179L * h.get(o.right)[0] * p[h.get(o.right)[1]]) % MOD) % MOD);\n        }\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n+ æ—¶é—´å¤æ‚åº¦ï¼šç­›é€‰ç´ æ•°ï¼ˆæ­¤å¤„ä¸ºæ¬§æ‹‰ç­›ï¼‰çš„æ—¶é—´ä»£ä»·æ˜¯ $O(\\arg \\pi (\\max \\{ |s|, |t| \\}))$ï¼Œå¯¹äº $10^6$ ä»¥ä¸‹çš„ $x$ï¼Œä¸€èˆ¬æœ‰ $\\arg \\pi (x) < 15 x$ï¼Œä¹Ÿå°±æ˜¯åœ¨ $15 x$ ä¸ªè‡ªç„¶æ•°é‡Œä¸€å®šèƒ½æ‰¾åˆ° $x$ ä¸ªç´ æ•°ï¼Œæ‰€ä»¥è¿™é‡Œå¯ä»¥è®¤ä¸ºå®ƒæ¯”çº¿æ€§ç¨å¾®æ…¢ä¸€ç‚¹ã€‚æ·±åº¦ä¼˜å…ˆæœç´¢æ±‚è§£å’Œå¾ªç¯æ¯”è¾ƒçš„æ—¶é—´ä»£ä»·æ˜¯ $O(|s| + |t|)$ã€‚æ•…æ¸è¿›æ—¶é—´å¤æ‚åº¦ä¸º $O(\\arg \\pi (\\max \\{ |s|, |t| \\}) + |s| + |t|) = O(\\arg \\pi (\\max \\{ |s|, |t| \\}))$ã€‚\n+ ç©ºé—´å¤æ‚åº¦ï¼šè¿™é‡Œç”¨äº†å“ˆå¸Œè¡¨æ¥è®°å½•æ¯ä¸ªç‚¹çš„å“ˆå¸Œå€¼å’Œå­æ ‘å¤§å°ï¼Œç©ºé—´ä»£ä»·æ˜¯ $O(|s| + |t|)$ï¼Œç­›é€‰ç´ æ•°çš„ `vis` æ•°ç»„çš„ç©ºé—´ä»£ä»·ä¸º $O(\\arg \\pi (\\max \\{ |s|, |t| \\}))$ï¼Œä»»æ„æ—¶åˆ»æ ˆç©ºé—´çš„æœ€å¤§ä½¿ç”¨ä»£ä»·æ˜¯ $O(\\max \\{ d_s, d_t \\})$ï¼Œæ•…æ¸è¿›ç©ºé—´å¤æ‚åº¦ä¸º $O(\\arg \\pi (\\max \\{ |s|, |t| \\}))$ã€‚"
}