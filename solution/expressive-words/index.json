{
	"titleSlug": "expressive-words",
	"slug": "qing-gan-feng-fu-de-wen-zi-by-leetcode",
	"url": "https://leetcode-cn.com/problems/expressive-words/solution/qing-gan-feng-fu-de-wen-zi-by-leetcode/",
	"content": "#### 比较相同字母组的长度：\n\n我们首先将 `S` 拆分成若干组相同的字母，并存储每组字母的长度。例如当 `S` 为 `abbcccddddaaaaa` 时，可以得到 `5` 组字母，它们分别为 `abcda`，长度为 `[1, 2, 3, 4, 5]`。\n\n对于 `words` 中的每个单词 `word`，如果它可以扩张得到 `S`，那么它必须和 `S` 有相同的字母组。对于每一组字母，假设 `S` 中有 `c1` 个，`word` 中有 `c2` 个，那么会有下面几种情况：\n\n- 如果 `c1 < c2`，那么 `word` 不能扩张得到 `S`；\n\n- 如果 `c1 >= 3`，那么只要添加 `c1 - c2` 个字母即可；\n\n- 如果 `c1 < 3`，由于在扩张时至少需要添加到 `3` 个字母，所以此时不能添加字母，必须有 `c1 == c2`。\n\n如果 `word` 的包含的字母组中的每个字母都满足上述情况，那么 `word` 可以扩张得到 `S`。\n\n```Java [sol1]\nclass Solution {\n    public int expressiveWords(String S, String[] words) {\n        RLE R = new RLE(S);\n        int ans = 0;\n\n        search: for (String word: words) {\n            RLE R2 = new RLE(word);\n            if (!R.key.equals(R2.key)) continue;\n            for (int i = 0; i < R.counts.size(); ++i) {\n                int c1 = R.counts.get(i);\n                int c2 = R2.counts.get(i);\n                if (c1 < 3 && c1 != c2 || c1 < c2)\n                    continue search;\n            }\n            ans++;\n        }\n        return ans;\n    }\n}\n\nclass RLE {\n    String key;\n    List<Integer> counts;\n\n    public RLE(String S) {\n        StringBuilder sb = new StringBuilder();\n        counts = new ArrayList();\n\n        char[] ca = S.toCharArray();\n        int N = ca.length;\n        int prev = -1;\n        for (int i = 0; i < N; ++i) {\n            if (i == N-1 || ca[i] != ca[i+1]) {\n                sb.append(ca[i]);\n                counts.add(i - prev);\n                prev = i;\n            }\n        }\n\n        key = sb.toString();\n    }\n}\n```\n\n```Python [sol1]\nclass Solution(object):\n    def expressiveWords(self, S, words):\n        def RLE(S):\n            return zip(*[(k, len(list(grp)))\n                         for k, grp in itertools.groupby(S)])\n\n        R, count = RLE(S)\n        ans = 0\n        for word in words:\n            R2, count2 = RLE(word)\n            if R2 != R: continue\n            ans += all(c1 >= max(c2, 3) or c1 == c2\n                       for c1, c2 in zip(count, count2))\n\n        return ans\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(N + \\sum k_i)$，其中 $N$ 是字符串 `S` 的长度，$\\sum k_i$ 是数组 `words` 中所有单词的长度之和。\n\n* 空间复杂度：$O(N + K)$，其中 `K` 是数组 `word` 中最长的单词的长度。"
}