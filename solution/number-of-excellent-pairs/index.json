{
	"titleSlug": "number-of-excellent-pairs",
	"slug": "deng-jie-zhuan-huan-pythonjavacgo-by-end-2qzs",
	"url": "https://leetcode-cn.com/problems/number-of-excellent-pairs/solution/deng-jie-zhuan-huan-pythonjavacgo-by-end-2qzs/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV14a411U7QZ?t=11m) 已出炉，额外讲解了**如何用集合论来思考二进制**。欢迎点赞三连，在评论区分享你对这场周赛的看法~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n对于 $x|y$ 和 $x\\&y$，在同一个比特位上，如果都有 $1$，那这个 $1$ 会被统计两次；如果一个为 $1$ 另一个为 $0$，那这个 $1$ 会被统计一次。\r\n\r\n#### 提示 2\r\n\r\n例如 $x=110$，$y=011$，只统计一次的部分为 $x'=100$，$y'=001$，统计了两次的部分为 $x\\&y=010$。我们可以直接把 $010$ 重新分配到 $x'$ 和 $y'$ 上，这样又得到了 $x$ 和 $y$。\r\n\r\n记 $c(x)$ 为 $x$ 的二进制表示中的 $1$ 的个数，则有如下等式：\r\n\r\n$$\r\nc(x|y)+c(x\\&y)=c(x)+c(y)\r\n$$\r\n\r\n另外一种思路是把二进制数看成集合，根据容斥原理 $|A \\cup B| = |A| + |B| - |A \\cap B|$，得\r\n\r\n$$\r\n|A \\cup B| + |A \\cap B| = |A| + |B|\r\n$$\r\n\r\n再转换到二进制上，同样可以得到上面的等式。\r\n\r\n#### 提示 3\r\n\r\n遍历去重后的 $\\textit{nums}$，统计 $c(\\textit{nums}[i])$ 的个数，记录在 $\\textit{cnt}$ 中，然后写一个二重循环遍历 $\\textit{cnt}$，对于所有的 $c(x)+c(y)\\ge k$，累加 $\\textit{cnt}[c(x)]\\cdot\\textit{cnt}[c(y)]$，表示从这两组中各选一个 $x$ 和 $y$ 组成优质数对的个数（乘法原理）。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n+U^2)$，其中 $n$ 为 $\\textit{nums}$ 的长度，$U$ 为不同的 $c(\\textit{nums}[i])$ 的个数，不超过 $30$。\r\n- 空间复杂度：$O(n+U)$。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\r\n        cnt = Counter(x.bit_count() for x in set(nums))\r\n        ans = 0\r\n        for cx, ccx in cnt.items():\r\n            for cy, ccy in cnt.items():\r\n                if cx + cy >= k:  # (x,y) 是优质数对\r\n                    ans += ccx * ccy\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public long countExcellentPairs(int[] nums, int k) {\r\n        var vis = new HashSet<Integer>();\r\n        var cnt = new HashMap<Integer, Integer>();\r\n        for (var x : nums)\r\n            if (vis.add(x)) {\r\n                var c = Integer.bitCount(x);\r\n                cnt.put(c, cnt.getOrDefault(c, 0) + 1);\r\n            }\r\n        var ans = 0L;\r\n        for (var x : cnt.entrySet())\r\n            for (var y : cnt.entrySet())\r\n                if (x.getKey() + y.getKey() >= k)\r\n                    ans += (long) x.getValue() * y.getValue();\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    long long countExcellentPairs(vector<int> &nums, int k) {\r\n        unordered_map<int, int> cnt;\r\n        for (int x : unordered_set<int>(nums.begin(), nums.end())) // 去重\r\n            ++cnt[__builtin_popcount(x)];\r\n        long ans = 0L;\r\n        for (auto &[cx, ccx] : cnt)\r\n            for (auto &[cy, ccy] : cnt)\r\n                if (cx + cy >= k) // (x,y) 是优质数对\r\n                    ans += (long) ccx * ccy;\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc countExcellentPairs(nums []int, k int) (ans int64) {\r\n\tvis := map[int]bool{}\r\n\tcnt := map[int]int{}\r\n\tfor _, x := range nums {\r\n\t\tif !vis[x] {\r\n\t\t\tvis[x] = true\r\n\t\t\tcnt[bits.OnesCount(uint(x))]++\r\n\t\t}\r\n\t}\r\n\tfor cx, ccx := range cnt {\r\n\t\tfor cy, ccy := range cnt {\r\n\t\t\tif cx+cy >= k { // (x,y) 是优质数对\r\n\t\t\t\tans += int64(ccx) * int64(ccy)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n```\r\n\r\n进一步地，二重循环可以用前缀和（或者后缀和）来优化。\r\n\r\n我们可以从小到大遍历 $\\textit{cnt}[c(x)]$，由于 $c(y)\\ge k-c(x)$，$c(y)$ 也会从大到小减小，我们可以用后缀和维护这些 $\\textit{cnt}[c(y)]$ 的和。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n+U)$，其中 $n$ 为 $\\textit{nums}$ 的长度，$U=30$。\r\n- 空间复杂度：$O(n+U)$。\r\n\r\n```py [sol2-Python3]\r\nclass Solution:\r\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\r\n        cnt = [0] * 30\r\n        for x in set(nums):\r\n            cnt[x.bit_count()] += 1\r\n        ans = 0\r\n        s = sum(cnt[k:])\r\n        for cx, ccx in enumerate(cnt):\r\n            ans += ccx * s\r\n            if 0 <= k - 1 - cx < 30:\r\n                s += cnt[k - 1 - cx]\r\n        return ans\r\n```\r\n\r\n```java [sol2-Java]\r\nclass Solution {\r\n    static final int U = 30;\r\n\r\n    public long countExcellentPairs(int[] nums, int k) {\r\n        var vis = new HashSet<Integer>();\r\n        var cnt = new int[U];\r\n        for (var x : nums)\r\n            if (vis.add(x)) ++cnt[Integer.bitCount(x)];\r\n        var ans = 0L;\r\n        var s = 0;\r\n        for (var i = k; i < U; ++i)\r\n            s += cnt[i];\r\n        for (var cx = 0; cx < U; ++cx) {\r\n            ans += (long) cnt[cx] * s;\r\n            var cy = k - 1 - cx;\r\n            if (0 <= cy && cy < U) s += cnt[cy];\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol2-C++]\r\nclass Solution {\r\n    static constexpr int U = 30;\r\npublic:\r\n    long long countExcellentPairs(vector<int> &nums, int k) {\r\n        int cnt[U] = {};\r\n        for (int x : unordered_set<int>(nums.begin(), nums.end())) // 去重\r\n            ++cnt[__builtin_popcount(x)];\r\n        long ans = 0L;\r\n        int s = 0;\r\n        for (int i = k; i < U; ++i)\r\n            s += cnt[i];\r\n        for (int cx = 0; cx < U; ++cx) {\r\n            ans += (long) cnt[cx] * s;\r\n            int cy = k - 1 - cx;\r\n            if (0 <= cy && cy < U) s += cnt[cy];\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\nfunc countExcellentPairs(nums []int, k int) (ans int64) {\r\n\tconst U = 30\r\n\tvis := map[int]bool{}\r\n\tcnt := [U]int{}\r\n\tfor _, x := range nums {\r\n\t\tif !vis[x] {\r\n\t\t\tvis[x] = true\r\n\t\t\tcnt[bits.OnesCount(uint(x))]++\r\n\t\t}\r\n\t}\r\n\ts := 0\r\n\tfor i := k; i < U; i++ {\r\n\t\ts += cnt[i]\r\n\t}\r\n\tfor cx, ccx := range cnt {\r\n\t\tans += int64(ccx) * int64(s)\r\n\t\tcy := k - 1 - cx\r\n\t\tif 0 <= cy && cy < U {\r\n\t\t\ts += cnt[cy]\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n```\r\n"
}