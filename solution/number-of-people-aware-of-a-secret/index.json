{
	"titleSlug": "number-of-people-aware-of-a-secret",
	"slug": "by-endlesscheng-2x0z",
	"url": "https://leetcode-cn.com/problems/number-of-people-aware-of-a-secret/solution/by-endlesscheng-2x0z/",
	"content": "## 方法一：刷表法（用当前状态更新其它状态）\r\n\r\n转换一下题目背景：有某个神奇的银行，你在第一天存入一块钱，银行会在 $\\textit{delay}$ 天后给你发利息（存多少发多少），直到 $\\textit{forget}$ 天后停止。发出的利息可以立刻作为本金存入银行，在未来产生利息（复利）。\r\n\r\n根据题意，任意一天你在银行的资产都可以分为：\r\n\r\n- A 类：可以产生利息的钱；\r\n- B 类：尚不能产生利息的钱；\r\n- C 类：停止产生利息的钱（不参与计算）。\r\n\r\n定义 $f[i]$ 表示第 $i$ 天的 A 类钱数，这也**等价于**第 $i$ 天产生了 $f[i]$ 的利息，这些利息又可以在第 $[i+\\textit{delay}, i+\\textit{forget})$ 天产生新的利息。因此，我们可以用 $f[i]$ 去更新后续的 $f[j]$，把 $j$ 在区间 $[i+\\textit{delay}, i+\\textit{forget})$ 内的 $f[j]$ 都加上 $f[i]$。\r\n\r\n此外，如果 $i+\\textit{delay}\\ge n$，则可以把第 $n$ 天的 B 类钱数（记作 $\\textit{cntB}$）也加上 $f[i]$。\r\n\r\n答案为第 $n$ 天的 A 类和 B 类的钱数之和，即 $f[n]+\\textit{cntB}$。\r\n\r\n代码实现时，为了方便计算 $f$ 的初始值，不妨将一开始存入的钱当作第一天产生的利息，将 $f[1]$ 初始化为 $1$。\r\n\r\n此外，下标可以从 $0$ 开始，从而优化掉一些 `+1` 的逻辑。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\r\n        MOD = 10 ** 9 + 7\r\n        f = [0] * n\r\n        f[0] = 1\r\n        cnt_b = 0\r\n        for i, v in enumerate(f):\r\n            if i + delay >= n:\r\n                cnt_b += v\r\n            for j in range(i + delay, min(i + forget, n)):\r\n                f[j] = (f[j] + v) % MOD\r\n        return (f[-1] + cnt_b) % MOD\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    static final int MOD = (int) 1e9 + 7;\r\n\r\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\r\n        var f = new int[n];\r\n        f[0] = 1;\r\n        var cntB = 0;\r\n        for (var i = 0; i < n; ++i) {\r\n            if (i + delay >= n) cntB = (cntB + f[i]) % MOD;\r\n            for (int j = i + delay; j < Math.min(i + forget, n); ++j)\r\n                f[j] = (f[j] + f[i]) % MOD;\r\n        }\r\n        return (f[n - 1] + cntB) % MOD;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\n    const int MOD = 1e9 + 7;\r\npublic:\r\n    int peopleAwareOfSecret(int n, int delay, int forget) {\r\n        int f[n]; memset(f, 0, sizeof(f));\r\n        f[0] = 1;\r\n        int cnt_b = 0;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (i + delay >= n) cnt_b = (cnt_b + f[i]) % MOD;\r\n            for (int j = i + delay; j < min(i + forget, n); ++j)\r\n                f[j] = (f[j] + f[i]) % MOD;\r\n        }\r\n        return (f[n - 1] + cnt_b) % MOD;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc peopleAwareOfSecret(n, delay, forget int) int {\r\n\tconst mod int = 1e9 + 7\r\n\tf := make([]int, n)\r\n\tf[0] = 1\r\n\tcntB := 0\r\n\tfor i, v := range f {\r\n\t\tif i+delay >= n {\r\n\t\t\tcntB = (cntB + v) % mod\r\n\t\t}\r\n\t\tfor j := i + delay; j < i+forget && j < n; j++ {\r\n\t\t\tf[j] = (f[j] + v) % mod\r\n\t\t}\r\n\t}\r\n\treturn (f[n-1] + cntB) % mod\r\n}\r\n```\r\n\r\n上述代码我们有一个「把一段区间的元素都加上同一个数」的操作，这还可以用 [差分](https://oi-wiki.org/basic/prefix-sum/#_6) 数组实现。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$。\r\n- 空间复杂度：$O(n)$。\r\n\r\n```py [sol12-Python3]\r\nclass Solution:\r\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\r\n        MOD = 10 ** 9 + 7\r\n        diff = [0] * n\r\n        diff[0] = 1  # f[0] = 1，相当于 diff[0] = 1, diff[1] = -1\r\n        diff[1] = -1\r\n        f = cnt_b = 0\r\n        for i, d in enumerate(diff):\r\n            f = (f + d) % MOD\r\n            if i + delay >= n:\r\n                cnt_b += f\r\n            else:\r\n                diff[i + delay] += f\r\n                if i + forget < n:\r\n                    diff[i + forget] -= f\r\n        return (f + cnt_b) % MOD\r\n```\r\n\r\n```java [sol12-Java]\r\nclass Solution {\r\n    static final int MOD = (int) 1e9 + 7;\r\n\r\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\r\n        var diff = new int[n];\r\n        diff[0] = 1; // f[0] = 1，相当于 diff[0] = 1, diff[1] = -1\r\n        diff[1] = MOD - 1;\r\n        int f = 0, cntB = 0;\r\n        for (var i = 0; i < n; ++i) {\r\n            f = (f + diff[i]) % MOD;\r\n            if (i + delay >= n) cntB = (cntB + f) % MOD;\r\n            else {\r\n                diff[i + delay] = (diff[i + delay] + f) % MOD;\r\n                if (i + forget < n) diff[i + forget] = (diff[i + forget] - f + MOD) % MOD; // +MOD 是为了保证结果不会出现负数\r\n            }\r\n        }\r\n        return (f + cntB) % MOD;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol12-C++]\r\nclass Solution {\r\n    const int MOD = 1e9 + 7;\r\npublic:\r\n    int peopleAwareOfSecret(int n, int delay, int forget) {\r\n        int diff[n]; memset(diff, 0, sizeof(diff));\r\n        diff[0] = 1; // f[0] = 1，相当于 diff[0] = 1, diff[1] = -1\r\n        diff[1] = MOD - 1;\r\n        int f = 0, cnt_b = 0;\r\n        for (int i = 0; i < n; ++i) {\r\n            f = (f + diff[i]) % MOD;\r\n            if (i + delay >= n) cnt_b = (cnt_b + f) % MOD;\r\n            else {\r\n                diff[i + delay] = (diff[i + delay] + f) % MOD;\r\n                if (i + forget < n) diff[i + forget] = (diff[i + forget] - f + MOD) % MOD; // +MOD 是为了保证结果不会出现负数\r\n            }\r\n        }\r\n        return (f + cnt_b) % MOD;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol12-Go]\r\nfunc peopleAwareOfSecret(n, delay, forget int) int {\r\n\tconst mod int = 1e9 + 7\r\n\tdiff := make([]int, n)\r\n\tdiff[0] = 1 // f[0] = 1，相当于 diff[0] = 1, diff[1] = -1\r\n\tdiff[1] = mod - 1\r\n\tf, cntB := 0, 0\r\n\tfor i, d := range diff {\r\n\t\tf = (f + d) % mod\r\n\t\tif i+delay >= n {\r\n\t\t\tcntB = (cntB + f) % mod\r\n\t\t} else {\r\n\t\t\tdiff[i+delay] = (diff[i+delay] + f) % mod\r\n\t\t\tif i+forget < n {\r\n\t\t\t\tdiff[i+forget] = (diff[i+forget] - f + mod) % mod // +mod 是为了保证结果不会出现负数\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn (f + cntB) % mod\r\n}\r\n```\r\n\r\n## 方法二：填表法（用其它状态计算当前状态）\r\n\r\n另一种方法是把 $f[i]$ 定义成第 $i$ 天**新增**的利息。同方法一，把一开始的钱当作利息，$f[1]$ 初始化为 $1$。\r\n\r\n根据题意，我们可以从 $j$ 在 $[i-\\textit{forget}+1, i-\\textit{delay}]$ 内的 $f[j]$ 转移过来，这些利息会在第 $i$ 天产生新的利息，则有\r\n\r\n$$\r\nf[i] = \\sum_{j=i-\\textit{forget}+1}^{i-\\textit{delay}} f[j]\r\n$$\r\n\r\n答案为第 $[n-\\textit{forget}+1, n]$ 天新增的利息之和，即\r\n\r\n$$\r\n\\sum_{i=n-\\textit{forget}+1}^{n} f[i]\r\n$$\r\n\r\n代码实现时，和式可以用前缀和优化，即定义前缀和 $\\textit{sum}[i] = \\sum\\limits_{j=1}^{j}f[j]$，这样上面的和式就可以变成两个前缀和的差。进一步地，有了前缀和，$f$ 数组也可以省略。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$。\r\n- 空间复杂度：$O(n)$。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\r\n        MOD = 10 ** 9 + 7\r\n        sum = [0] * (n + 1)\r\n        sum[1] = 1\r\n        for i in range(2, n + 1):\r\n            f = sum[max(i - delay, 0)] - sum[max(i - forget, 0)]\r\n            sum[i] = (sum[i - 1] + f) % MOD\r\n        return (sum[n] - sum[max(n - forget, 0)]) % MOD\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    static final int MOD = (int) 1e9 + 7;\r\n\r\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\r\n        var sum = new int[n + 1];\r\n        sum[1] = 1;\r\n        for (var i = 2; i <= n; i++) {\r\n            var f = (sum[Math.max(i - delay, 0)] - sum[Math.max(i - forget, 0)]) % MOD;\r\n            sum[i] = (sum[i - 1] + f) % MOD;\r\n        }\r\n        return ((sum[n] - sum[Math.max(n - forget, 0)]) % MOD + MOD) % MOD; // 防止结果为负数\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\n    const int MOD = 1e9 + 7;\r\npublic:\r\n    int peopleAwareOfSecret(int n, int delay, int forget) {\r\n        int sum[n + 1];\r\n        sum[0] = 0, sum[1] = 1;\r\n        for (int i = 2; i <= n; ++i) {\r\n            int f = (sum[max(i - delay, 0)] - sum[max(i - forget, 0)]) % MOD;\r\n            sum[i] = (sum[i - 1] + f) % MOD;\r\n        }\r\n        return ((sum[n] - sum[max(n - forget, 0)]) % MOD + MOD) % MOD; // 防止结果为负数\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc peopleAwareOfSecret(n, delay, forget int) int {\r\n\tconst mod int = 1e9 + 7\r\n\tsum := make([]int, n+1)\r\n\tsum[1] = 1\r\n\tfor i := 2; i <= n; i++ {\r\n\t\tf := (sum[max(i-delay, 0)] - sum[max(i-forget, 0)]) % mod\r\n\t\tsum[i] = (sum[i-1] + f) % mod\r\n\t}\r\n\treturn ((sum[n]-sum[max(n-forget, 0)])%mod + mod) % mod // 防止结果为负数\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n\r\n\r\n"
}