{
	"titleSlug": "advantage-shuffle",
	"slug": "you-shi-xi-pai-by-leetcode-solution-sqsf",
	"url": "https://leetcode-cn.com/problems/advantage-shuffle/solution/you-shi-xi-pai-by-leetcode-solution-sqsf/",
	"content": "#### 方法一：贪心算法\n\n**思路与算法**\n\n我们首先分别将数组 $\\textit{nums}_1$ 和 $\\textit{nums}_2$ 进行排序，随后只需要不断考虑这两个数组的首个元素：\n\n- 如果 $\\textit{nums}_1$ 的首个元素大于 $\\textit{nums}_2$ 的首个元素，那么就将它们在答案中对应起来，同时从数组中移除这两个元素，并增加一点「优势」；\n\n- 如果 $\\textit{nums}_1$ 的首个元素小于等于 $\\textit{nums}_2$ 的首个元素，那么移除 $\\textit{nums}_1$ 的首个元素。\n\n当 $\\textit{nums}_1$ 中没有元素时，遍历结束。\n\n这样做的正确性在于：\n\n- 对于第一种情况，由于 $\\textit{nums}_1$ 是有序的，那么 $\\textit{nums}_1$ 的任意元素大于 $\\textit{nums}_2$ 的首个元素：\n\n    - 如果我们不与 $\\textit{nums}_2$ 的首个元素配对，由于 $\\textit{nums}_2$ 是有序的，之后的元素会更大，这样并不划算；\n    \n    - 如果我们与 $\\textit{nums}_2$ 的首个元素配对，我们使用 $\\textit{nums}_1$ 的首个元素，可以使得剩余的元素尽可能大，之后可以获得更多「优势」。\n\n- 对于第二种情况，由于 $\\textit{nums}_2$ 是有序的，那么 $\\textit{nums}_1$ 的首个元素小于等于 $\\textit{nums}_2$ 中的任意元素，因此 $\\textit{nums}_1$ 的首个元素无法增加任何「优势」，可以直接移除。\n\n在本题中，由于 $\\textit{nums}_1$ 中的每一个元素都要与 $\\textit{nums}_2$ 中的元素配对，而我们是按照顺序考虑 $\\textit{nums}_2$ 中的元素的。因此在遍历结束后，$\\textit{nums}_2$ 中剩余的元素实际上是原先 $\\textit{nums}_2$ 的一个后缀。因此当 $\\textit{nums}_1$ 的首个元素无法配对时，我们给它配对一个 $\\textit{nums}_2$ 的尾元素即可，并将该尾元素移除。\n\n在实际的代码编写中，我们无需真正地「移除」元素。对于 $\\textit{nums}_1$，我们使用一个循环依次遍历其中的每个元素；对于 $\\textit{nums}_2$，我们可以使用双指针 $\\textit{left}$ 和 $\\textit{right}$。如果 $\\textit{nums}_1$ 的首个元素可以增加「优势」，就配对 $\\textit{left}$ 对应的元素并向右移动一个位置；如果无法配对，就配对 $\\textit{right}$ 对应的元素并向左移动一个位置。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size();\n        vector<int> idx1(n), idx2(n);\n        iota(idx1.begin(), idx1.end(), 0);\n        iota(idx2.begin(), idx2.end(), 0);\n        sort(idx1.begin(), idx1.end(), [&](int i, int j) { return nums1[i] < nums1[j]; });\n        sort(idx2.begin(), idx2.end(), [&](int i, int j) { return nums2[i] < nums2[j]; });\n        \n        vector<int> ans(n);\n        int left = 0, right = n - 1;\n        for (int i = 0; i < n; ++i) {\n            if (nums1[idx1[i]] > nums2[idx2[left]]) {\n                ans[idx2[left]] = nums1[idx1[i]];\n                ++left;\n            }\n            else {\n                ans[idx2[right]] = nums1[idx1[i]];\n                --right;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] advantageCount(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        Integer[] idx1 = new Integer[n];\n        Integer[] idx2 = new Integer[n];\n        for (int i = 0; i < n; ++i) {\n            idx1[i] = i;\n            idx2[i] = i;\n        }\n        Arrays.sort(idx1, (i, j) -> nums1[i] - nums1[j]);\n        Arrays.sort(idx2, (i, j) -> nums2[i] - nums2[j]);\n\n        int[] ans = new int[n];\n        int left = 0, right = n - 1;\n        for (int i = 0; i < n; ++i) {\n            if (nums1[idx1[i]] > nums2[idx2[left]]) {\n                ans[idx2[left]] = nums1[idx1[i]];\n                ++left;\n            } else {\n                ans[idx2[right]] = nums1[idx1[i]];\n                --right;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] AdvantageCount(int[] nums1, int[] nums2) {\n        int n = nums1.Length;\n        int[] idx1 = new int[n];\n        int[] idx2 = new int[n];\n        for (int i = 0; i < n; ++i) {\n            idx1[i] = i;\n            idx2[i] = i;\n        }\n        Array.Sort(idx1, (i, j) => nums1[i] - nums1[j]);\n        Array.Sort(idx2, (i, j) => nums2[i] - nums2[j]);\n\n        int[] ans = new int[n];\n        int left = 0, right = n - 1;\n        for (int i = 0; i < n; ++i) {\n            if (nums1[idx1[i]] > nums2[idx2[left]]) {\n                ans[idx2[left]] = nums1[idx1[i]];\n                ++left;\n            } else {\n                ans[idx2[right]] = nums1[idx1[i]];\n                --right;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        n = len(nums1)\n        idx1, idx2 = list(range(n)), list(range(n))\n        idx1.sort(key=lambda x: nums1[x])\n        idx2.sort(key=lambda x: nums2[x])\n\n        ans = [0] * n\n        left, right = 0, n - 1\n        for i in range(n):\n            if nums1[idx1[i]] > nums2[idx2[left]]:\n                ans[idx2[left]] = nums1[idx1[i]]\n                left += 1\n            else:\n                ans[idx2[right]] = nums1[idx1[i]]\n                right -= 1\n        \n        return ans\n```\n\n```C [sol1-C]\nstatic int cmp(const void *pa, const void *pb) {\n    int *a = (int *)pa;\n    int *b = (int *)pb;\n    return a[1] - b[1];\n}\n\nint* advantageCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\n    int n = nums1Size;\n    int idx1[n][2], idx2[n][2];\n    for (int i = 0; i < n; i++) {\n        idx1[i][0] = i, idx1[i][1] = nums1[i];\n        idx2[i][0] = i, idx2[i][1] = nums2[i];\n    }\n    qsort(idx1, n, sizeof(idx1[0]), cmp);\n    qsort(idx2, n, sizeof(idx2[0]), cmp);\n    int *ans = (int *)malloc(sizeof(int) * n);\n    int left = 0, right = n - 1;\n    for (int i = 0; i < n; ++i) {\n        if (nums1[idx1[i][0]] > nums2[idx2[left][0]]) {\n            ans[idx2[left][0]] = nums1[idx1[i][0]];\n            ++left;\n        }\n        else {\n            ans[idx2[right][0]] = nums1[idx1[i][0]];\n            --right;\n        }\n    }\n    *returnSize = n;\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar advantageCount = function(nums1, nums2) {\n    const n = nums1.length;\n    const idx1 = new Array(n).fill(0);\n    const idx2 = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        idx1[i] = i;\n        idx2[i] = i;\n    }\n    idx1.sort((i, j) => nums1[i] - nums1[j]);\n    idx2.sort((i, j) => nums2[i] - nums2[j]);\n\n    const ans = new Array(n).fill(0);\n    let left = 0, right = n - 1;\n    for (let i = 0; i < n; ++i) {\n        if (nums1[idx1[i]] > nums2[idx2[left]]) {\n            ans[idx2[left]] = nums1[idx1[i]];\n            ++left;\n        } else {\n            ans[idx2[right]] = nums1[idx1[i]];\n            --right;\n        }\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc advantageCount(nums1 []int, nums2 []int) []int {\n    n := len(nums1)\n    idx1 := make([]int, n)\n    idx2 := make([]int, n)\n    for i := 1; i < n; i++ {\n        idx1[i] = i\n        idx2[i] = i\n    }\n    sort.Slice(idx1, func(i, j int) bool { return nums1[idx1[i]] < nums1[idx1[j]] })\n    sort.Slice(idx2, func(i, j int) bool { return nums2[idx2[i]] < nums2[idx2[j]] })\n\n    ans := make([]int, n)\n    left, right := 0, n-1\n    for i := 0; i < n; i++ {\n        if nums1[idx1[i]] > nums2[idx2[left]] {\n            ans[idx2[left]] = nums1[idx1[i]]\n            left++\n        } else {\n            ans[idx2[right]] = nums1[idx1[i]]\n            right--\n        }\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{nums}_1$ 和 $\\textit{nums}_2$ 的长度，即为排序需要的时间。\n\n- 空间复杂度：$O(n)$，即为排序时存储下标需要的空间。"
}