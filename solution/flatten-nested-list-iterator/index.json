{
	"titleSlug": "flatten-nested-list-iterator",
	"slug": "fu-xue-ming-zhu-xiang-jie-ti-yi-shu-li-d-n4qa",
	"url": "https://leetcode-cn.com/problems/flatten-nested-list-iterator/solution/fu-xue-ming-zhu-xiang-jie-ti-yi-shu-li-d-n4qa/",
	"content": "各位题友大家好！ 今天是 **[@负雪明烛](/u/fuxuemingzhu/)** 坚持日更的第 58 天。今天力扣上的每日一题是「[341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)」。\n\n# 题意解析\n\n今天的题意略难理解，需要我翻译一下，理解题意的朋友请跳过。\n\n\n本题定义了一个类 `NestedInteger` ，这个类可以存储 `int`  或 `List<NestedInteger>` ；所以称它是一个「嵌套列表」。类似于一棵多叉树，每个节点都可以有很多子节点。\n\n\n它有三个方法：\n\n\n- `isInteger()` ，判断当前存储的对象是否为 int；\n- `getInteger()` , 如果当前存储的元素是 int 型的，那么返回当前的结果 int，否则调用会失败；\n- `getList()` ，如果当前存储的元素是 `List<NestedInteger>`  型的，那么返回该 List，否则调用会失败。\n\n\n\n而「扁平化嵌套列表迭代器」说的是，我们需要设计一个迭代器，这个迭代器是把「嵌套列表」铺平（拆包）成各个 int，然后每次调用 `hasNext()` 来判断是否有下一个**整数**，通过 `next()` 返回下一个**整数**。\n\n\n注意迭代器是一种按照特定顺序对数据结构遍历的方式，它的调用方式是：\n\n\n```python\ni, v = NestedIterator(nestedList), []\nwhile i.hasNext():\n\tv.append(i.next())\n```\n\n# 解题思路\n\n\n本文有两种主要的思路：\n\n1. 在构造函数中提前「扁平化」整个嵌套列表；\n2. 在调用 `hasNext()` 或者 `next()` 方法的时候扁平化当前的**嵌套的子列表**。\n\n## 一、递归：构造函数中提前「扁平化」整个嵌套列表\n\n\n这是最简单的方法，但是我认为这不是面试官想要的方法。\n\n在构造函数中提前扁平化整个嵌套列表。那么在 `hasNext()` 或者 `next()` 可以很简单地返回迭代器位置的 int。\n\n\n因为这个嵌套的数据结构有点类似于多叉树，所以我们可以按照类似地遍历思路：**递归**。\n\n\n承载遍历结果的数据结构可以使用**数组**，那么另外需要一个整数标记当前的迭代器指向的位置；也可以使用一个**队列**，每次调用 `next()` 方法的时候从队列的开头弹出一个元素。\n\n\n递归的思路比较简单，我用的是队列：\n\n- 遍历输入的「嵌套列表」所有的元素，判断每个元素是 int 还是 list；\n  - 如果当前元素是 int，放入队列尾部；\n  - 如果当前元素是 list，那么需要对当前 子list 继续递归；\n\n\n\n其余代码比较简单，不作赘述。\n\n```Python []\nclass NestedIterator(object):\n    def dfs(self, nests):\n        for nest in nests:\n            if nest.isInteger():\n                self.queue.append(nest.getInteger())\n            else:\n                self.dfs(nest.getList())\n                    \n    def __init__(self, nestedList):\n        self.queue = collections.deque()\n        self.dfs(nestedList)\n\n    def next(self):\n        return self.queue.popleft()\n\n    def hasNext(self):\n        return len(self.queue)\n```\n\n\n- 时间复杂度：构造函数的时间复杂度是 $O(N)$； `next()` 和 `hasNext()` 的时间复杂度是 $O(1)$。\n- 空间复杂度：$O(N)$。\n\n\n\n## 二、迭代：调用 `hasNext()` 或者 `next()` 方法的时候扁平化当前的嵌套的子列表\n\n\n这个方法更加有挑战性，也是这个题最正确的解法。因为对于大部分情况，我们希望迭代器能够一边迭代一边获取当前的结果，而不是提前初始化好。\n\n\n把递归方法 转 迭代方法，我们需要用到「栈」。\n\n\n在**递归方法**中，我们在遍历时如果遇到一个嵌套的 子list，就立即处理该 子list，直到全部展开；\n在**迭代方法**中，我们不需要全部展开，只需要把 当前list 的所有元素放入 list 中。\n\n\n由于「栈」的先进后出的特性，我们需要**逆序**在栈里放入各个元素。\n\n\n处理流程分为两步：\n\n1. 在构造函数中应该初始化，把当前列表的各个元素（不用摊平）**逆序**放入栈中。\n2. 在 `hasNext()` 方法中，访问（不弹出）栈顶元素，判断是否为 int：\n\n- 如果是 int 那么说明有下一个元素，返回 true；然后 `next()` 就会被调用，把栈顶的 int 弹出；\n- 如果是 list 需要把当前列表的各个元素（不用摊平）**逆序**放入栈中。\n- 如果栈为空，那么说明原始的嵌套列表已经访问结束了，返回 false。\n\n\n\n算法整体的流程，通过举例说明。假如输入 `[1, [2,3]]` 。\n\n\n\n    1. 在构造函数中：栈里面放的应该是 stack = [[2, 3], 1]\n    2. 在调用 hasNext() 方法时，访问栈顶元素是 1，为 int，那么直接返回 true;\n    3. 然后调用 next() 方法，弹出栈顶元素 1；\n    4. 再调用 hasNext() 方法时，访问栈顶元素是 [2,3]，为 list，那么需要摊平，继续放到栈中。\n            当前的栈是 stack = [3, 2]\n    5. 然后调用 next() 方法，弹出栈顶元素 2；\n    6. 然后调用 next() 方法，弹出栈顶元素 3；\n    7. 再调用 hasNext() 方法时，栈为空，因此返回 false，迭代器运行结束。\n\n\n\n这里需要说一下为什么在 `hasNext()` 方法中摊平 list，而不是在 `next()` 方法中。比如对于 `[[]]` 的输入， `hasNext()`  方法是判断其中是否有 int 元素了，则必须把内层的 list 摊平来看，发现是空的，返回 false。\n\n\n\n\n代码如下：\n\n\n```Python []\nclass NestedIterator(object):\n\n    def __init__(self, nestedList):\n        self.stack = []\n        for i in range(len(nestedList) - 1, -1, -1):\n            self.stack.append(nestedList[i])\n        \n\n    def next(self):\n        cur = self.stack.pop()\n        return cur.getInteger()\n\n    def hasNext(self):\n        while self.stack:\n            cur = self.stack[-1]\n            if cur.isInteger():\n                return True\n            self.stack.pop()\n            for i in range(len(cur.getList()) - 1, -1, -1):\n                self.stack.append(cur.getList()[i])\n        return False\n```\n\n\n```C++ []\nclass NestedIterator {\npublic:\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        for (int i = nestedList.size() - 1; i >= 0; --i) {\n            st.push(nestedList[i]);\n        }\n    }\n\n    int next() {\n        NestedInteger cur = st.top(); st.pop();\n        return cur.getInteger();\n    }\n\n    bool hasNext() {\n        while (!st.empty()) {\n            NestedInteger cur = st.top();\n            if (cur.isInteger()) {\n                return true;\n            }\n            st.pop();\n            for (int i = cur.getList().size() - 1; i >= 0; --i) {\n                st.push(cur.getList()[i]);\n            }\n        }\n        return false;\n    }\nprivate:\n    stack<NestedInteger> st;\n};\n\n```\n\n\n- 时间复杂度：构造函数的最坏时间复杂度是 $O(N)$； `next()` 和 `hasNext()` 的最坏时间复杂度是 $O(N)$。\n- 空间复杂度：$O(N)$。\n\n\n\n# 刷题心得\n\n\n面试的时候需要写出方法二，今天的题目很好，请务必掌握呀。\n\n参考资料：\n[力扣官方题解](https://leetcode-cn.com/problems/flatten-nested-list-iterator/solution/bian-ping-hua-qian-tao-lie-biao-die-dai-ipjzq/)\n[341. Flatten Nested List Iterator](https://www.youtube.com/watch?v=R2dohSHOWXQ)\n\n\n-----\n\n\nOK，以上就是 [@负雪明烛](https://leetcode-cn.com/u/fuxuemingzhu/) 写的今天题解的全部内容了，如果你觉得有帮助的话，**求赞、求关注、求收藏**。如果有疑问的话，请在下面评论，我会及时解答。\n\n\n**关注我**，你将不会错过我的精彩动画题解、面试题分享、组队刷题活动，进入主页 [@负雪明烛](https://leetcode-cn.com/u/fuxuemingzhu/) 右侧有刷题组织，从此刷题不再孤单。\n\n\n祝大家牛年大吉！AC 多多，Offer 多多！我们明天再见！"
}