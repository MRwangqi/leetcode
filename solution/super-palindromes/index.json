{
	"titleSlug": "super-palindromes",
	"slug": "chao-ji-hui-wen-shu-by-leetcode",
	"url": "https://leetcode-cn.com/problems/super-palindromes/solution/chao-ji-hui-wen-shu-by-leetcode/",
	"content": "#### 方法 1：数学\n\n**想法**\n\n假设 $P = R^2$ 是超级回文数。\n\n因为 $R$ 是一个回文数，$R$ 的前一半数字决定了两种可能。我们可以枚举这些数字，让 $k$ 为前一半数字，假如 $k = 1234$ 那么 $R = 1234321$ 或者 $R = 12344321$。\n\n注意到 $P < 10^{18}$，$R < (10^{18})^{\\frac{1}{2}} = 10^9$，同时 $R = k \\| k'$（两串数字连接），其中 $k'$ 是 $k$ 的反序（也有可能截掉了中间数字），所以 $k < 10^5 = \\small\\text{MAGIC}$，我们的神奇常数。\n\n**算法**\n\n对于每个 $1 \\leq k < \\small\\text{MAGIC}$，构造回文串 $R$ 并且检验 $R^2$ 是否为回文串。\n\n我们需要将奇数和偶数长度分开考虑，这样当长度超出时就可以提前停止循环。\n\n检验一个整数是否为回文数，只需要检查它是否等于它的逆。构造一个整数的逆，可以按位处理。\n\n```Java []\nclass Solution {\n    public int superpalindromesInRange(String sL, String sR) {\n        long L = Long.valueOf(sL);\n        long R = Long.valueOf(sR);\n        int MAGIC = 100000;\n        int ans = 0;\n\n        // count odd length;\n        for (int k = 1; k < MAGIC; ++k) {\n            StringBuilder sb = new StringBuilder(Integer.toString(k));\n            for (int i = sb.length() - 2; i >= 0; --i)\n                sb.append(sb.charAt(i));\n            long v = Long.valueOf(sb.toString());\n            v *= v;\n            if (v > R) break;\n            if (v >= L && isPalindrome(v)) ans++;\n        }\n\n        // count even length;\n        for (int k = 1; k < MAGIC; ++k) {\n            StringBuilder sb = new StringBuilder(Integer.toString(k));\n            for (int i = sb.length() - 1; i >= 0; --i)\n                sb.append(sb.charAt(i));\n            long v = Long.valueOf(sb.toString());\n            v *= v;\n            if (v > R) break;\n            if (v >= L && isPalindrome(v)) ans++;\n        }\n\n        return ans;\n    }\n\n    public boolean isPalindrome(long x) {\n        return x == reverse(x);\n    }\n\n    public long reverse(long x) {\n        long ans = 0;\n        while (x > 0) {\n            ans = 10 * ans + x % 10;\n            x /= 10;\n        }\n\n        return ans;\n    }\n}\n```\n\n```Python []\nclass Solution(object):\n    def superpalindromesInRange(self, L, R):\n        L, R = int(L), int(R)\n        MAGIC = 100000\n\n        def reverse(x):\n            ans = 0\n            while x:\n                ans = 10 * ans + x % 10\n                x /= 10\n            return ans\n\n        def is_palindrome(x):\n            return x == reverse(x)\n\n        ans = 0\n\n        # count odd length\n        for k in xrange(MAGIC):\n            s = str(k)  # Eg. s = '1234'\n            t = s + s[-2::-1]  # t = '1234321'\n            v = int(t) ** 2\n            if v > R: break\n            if v >= L and is_palindrome(v):\n                ans += 1\n\n        # count even length\n        for k in xrange(MAGIC):\n            s = str(k)  # Eg. s = '1234'\n            t = s + s[::-1]  # t = '12344321'\n            v = int(t) ** 2\n            if v > R: break\n            if v >= L and is_palindrome(v):\n                ans += 1\n\n        return ans\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(W^{\\frac{1}{4}} * \\log W)$，其中 $W = 10^{18}$ 是 $R$ 的上界。$\\log W$ 是用来检验每个候选数字是否为回文数。\n* 空间复杂度：$O(\\log W)$，用于构造回文串。"
}