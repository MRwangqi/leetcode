{
	"titleSlug": "minimum-cost-to-move-chips-to-the-same-position",
	"slug": "wan-chou-ma-by-leetcode-solution-swnp",
	"url": "https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position/solution/wan-chou-ma-by-leetcode-solution-swnp/",
	"content": "#### 方法一：贪心\n\n**思路与算法**\n\n首先很容易得出：\n\n1. 从某一个偶（奇）数位置 $p_i$ 改变到另一个偶（奇）数位置 $p_j$，不妨设 $p_i < p_j$，那么一定 $\\exists k \\in \\mathbb{N}^*$ 使得 $p_i + 2k = p_j$ 成立，即此时的最小开销为 $0$。\n2. 从某一个偶（奇）数位置 $p_i$ 改变到另一个奇（偶）数位置 $p_j$，不妨设 $p_i < p_j$，那么一定 $\\exists k \\in \\mathbb{N}$ 使得 $p_i + 2k + 1 = p_j$ 成立，即此时的最小开销为 $1$。\n\n那么我们可以把初始每一个偶数位置的「筹码」看作一个整体，每一个奇数位置的「筹码」看作一个整体。因为我们的目标是最后将全部的「筹码」移动到同一个位置，那么最后的位置只有两种情况：\n\n1. 移动到某一个偶数位置，此时的开销最小值就是初始奇数位置「筹码」的数量。\n2. 移动到某一个奇数位置，此时的开销最小值就是初始偶数位置「筹码」的数量。\n\n那么这两种情况中的最小值就是最后将所有筹码移动到同一位置上所需要的最小代价。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def minCostToMoveChips(self, position: List[int]) -> int:\n        cnt = Counter(p % 2 for p in position)  # 根据模 2 后的余数来统计奇偶个数\n        return min(cnt[0], cnt[1])\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minCostToMoveChips(vector<int>& position) {\n        int even = 0, odd = 0;\n        for (int pos : position) {\n            if (pos % 2) {\n                odd++;\n            } else {\n                even++;\n            }\n        }\n        return min(odd, even);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minCostToMoveChips(int[] position) {\n        int even = 0, odd = 0;\n        for (int pos : position) {\n            if ((pos & 1) != 0) {\n                odd++;\n            } else {\n                even++;\n            }\n        }\n        return Math.min(odd, even);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinCostToMoveChips(int[] position) {\n        int even = 0, odd = 0;\n        foreach (int pos in position) {\n            if ((pos & 1) != 0) {\n                odd++;\n            } else {\n                even++;\n            }\n        }\n        return Math.Min(odd, even);\n    }\n}\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint minCostToMoveChips(int* position, int positionSize){\n    int even = 0, odd = 0;\n    for (int i = 0; i < positionSize; i++) {\n        if (position[i] & 1) {\n            odd++;\n        } else {\n            even++;\n        }\n    }\n    return MIN(odd, even);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minCostToMoveChips = function(position) {\n    let even = 0, odd = 0;\n    for (const pos of position) {\n        if ((pos & 1) !== 0) {\n            odd++;\n        } else {\n            even++;\n        }\n    }\n    return Math.min(odd, even);\n};\n```\n\n```go [sol1-Golang]\nfunc minCostToMoveChips(position []int) int {\n    cnt := [2]int{}\n    for _, p := range position {\n        cnt[p%2]++\n    }\n    return min(cnt[0], cnt[1])\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{position}$ 的长度，只对数组进行了一次遍历。\n\n- 空间复杂度：$O(1)$，仅使用常数变量。"
}