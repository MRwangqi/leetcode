{
	"titleSlug": "maximum-xor-after-operations",
	"slug": "yi-bu-bu-tis-by-endlesscheng-89kw",
	"url": "https://leetcode-cn.com/problems/maximum-xor-after-operations/solution/yi-bu-bu-tis-by-endlesscheng-89kw/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV143411w7Wx) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n$\\textit{nums}[i]$ 逐位**异或**任意非负整数，相当于把 $\\textit{nums}[i]$ 修改为任意非负整数。\r\n\r\n#### 提示 2\r\n\r\n$\\textit{nums}[i]$ 逐位**与**任意非负整数，相当于把 $\\textit{nums}[i]$ 的某些比特位的值，由 $1$ 修改为 $0$，但是不能由 $0$ 修改为 $1$。\r\n\r\n#### 提示 3\r\n\r\n考虑逐位构造出 $\\textit{nums}$ 的最大逐位异或和。如果 $\\textit{nums}$ 在某个比特位上有奇数个 $1$，那么这个比特位异或和的结果就是 $1$。根据提示 2，只需要保证 $\\textit{nums}$ 在这个比特位上有至少一个 $1$ 即可，在这个比特位上我们可以只保留一个 $1$，其余修改为 $0$。\r\n\r\n#### 提示 4\r\n\r\n通过逐位**或**运算可以求出 $\\textit{nums}$ 在哪些比特位上有 $1$。\r\n\r\n其结果亦是答案。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def maximumXOR(self, nums: List[int]) -> int:\r\n        return reduce(or_, nums)\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int maximumXOR(int[] nums) {\r\n        var ans = 0;\r\n        for (var num : nums) ans |= num;\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int maximumXOR(vector<int> &nums) {\r\n        int ans = 0;\r\n        for (int num : nums) ans |= num;\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc maximumXOR(nums []int) (ans int) {\r\n\tfor _, num := range nums {\r\n\t\tans |= num\r\n\t}\r\n\treturn\r\n}\r\n```\r\n"
}