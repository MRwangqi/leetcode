{
	"titleSlug": "count-of-range-sum",
	"slug": "qu-jian-he-de-ge-shu-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/count-of-range-sum/solution/qu-jian-he-de-ge-shu-by-leetcode-solution/",
	"content": "#### 前言\n\n本题目的方法二至方法五均用到了较高级的数据结构，读者一般只需掌握方法一即可，感兴趣的读者可以学习其他四种解法。\n\n在某些方法的 C++ 代码中，我们没有将开辟的堆空间进行释放。维护树型结构的动态内存较为困难，而这些方法的重点在于算法和数据结构本身。\n\n#### 方法一：归并排序\n\n**思路与算法**\n\n设前缀和数组为 $\\textit{preSum}$，则问题等价于求所有的下标对 $(i,j)$，满足\n$$\n\\textit{preSum}[j] - \\textit{preSum}[i] \\in [\\textit{lower}, \\textit{upper}]\n$$\n\n我们先考虑如下的问题：给定两个**升序排列**的数组 $n_1, n_2$，试找出所有的下标对 $(i,j)$，满足\n$$\nn_2[j] - n_1[i] \\in [\\textit{lower}, \\textit{upper}]\n$$\n\n在已知两个数组均为升序的情况下，这一问题是相对简单的：我们在 $n_2$ 中维护两个指针 $l,r$。起初，它们都指向 $n_2$ 的起始位置。\n\n随后，我们考察 $n_1$ 的第一个元素。首先，不断地将指针 $l$ 向右移动，直到 $n_2[l] \\ge n_1[0] + \\textit{lower}$ 为止，此时， $l$ 及其右边的元素均大于或等于 $n_1[0] + \\textit{lower}$；随后，再不断地将指针 $r$ 向右移动，直到 $n_2[r] > n_1[0] + \\textit{upper}$ 为止，则 $r$ 左边的元素均小于或等于 $n_1[0] + \\textit{upper}$。故区间 $[l,r)$ 中的所有下标 $j$，都满足 \n$$\nn_2[j] - n_1[0] \\in [\\textit{lower}, \\textit{upper}]\n$$\n\n接下来，我们考察 $n_1$ 的第二个元素。由于 $n_1$ 是递增的，不难发现 $l,r$ 只可能向右移动。因此，我们不断地进行上述过程，并对于 $n_1$ 中的每一个下标，都记录相应的区间 $[l,r)$ 的大小。最终，我们就统计得到了满足条件的下标对 $(i,j)$ 的数量。\n\n在解决这一问题后，原问题就迎刃而解了：我们采用归并排序的方式，能够得到左右两个数组排序后的形式，以及对应的下标对数量。对于原数组而言，若要找出全部的下标对数量，只需要再额外找出左端点在左侧数组，同时右端点在右侧数组的下标对数量，而这正是我们此前讨论的问题。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int countRangeSumRecursive(vector<long>& sum, int lower, int upper, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = countRangeSumRecursive(sum, lower, upper, left, mid);\n            int n2 = countRangeSumRecursive(sum, lower, upper, mid + 1, right);\n            int ret = n1 + n2;\n\n            // 首先统计下标对的数量\n            int i = left;\n            int l = mid + 1;\n            int r = mid + 1;\n            while (i <= mid) {\n                while (l <= right && sum[l] - sum[i] < lower) l++;\n                while (r <= right && sum[r] - sum[i] <= upper) r++;\n                ret += (r - l);\n                i++;\n            }\n\n            // 随后合并两个排序数组\n            vector<long> sorted(right - left + 1);\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = sum[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = sum[p1++];\n                } else {\n                    if (sum[p1] < sum[p2]) {\n                        sorted[p++] = sum[p1++];\n                    } else {\n                        sorted[p++] = sum[p2++];\n                    }\n                }\n            }\n            for (int i = 0; i < sorted.size(); i++) {\n                sum[left + i] = sorted[i];\n            }\n            return ret;\n        }\n    }\n\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        long s = 0;\n        vector<long> sum{0};\n        for(auto& v: nums) {\n            s += v;\n            sum.push_back(s);\n        }\n        return countRangeSumRecursive(sum, lower, upper, 0, sum.size() - 1);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        long s = 0;\n        long[] sum = new long[nums.length + 1];\n        for (int i = 0; i < nums.length; ++i) {\n            s += nums[i];\n            sum[i + 1] = s;\n        }\n        return countRangeSumRecursive(sum, lower, upper, 0, sum.length - 1);\n    }\n\n    public int countRangeSumRecursive(long[] sum, int lower, int upper, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = countRangeSumRecursive(sum, lower, upper, left, mid);\n            int n2 = countRangeSumRecursive(sum, lower, upper, mid + 1, right);\n            int ret = n1 + n2;\n\n            // 首先统计下标对的数量\n            int i = left;\n            int l = mid + 1;\n            int r = mid + 1;\n            while (i <= mid) {\n                while (l <= right && sum[l] - sum[i] < lower) {\n                    l++;\n                }\n                while (r <= right && sum[r] - sum[i] <= upper) {\n                    r++;\n                }\n                ret += r - l;\n                i++;\n            }\n\n            // 随后合并两个排序数组\n            long[] sorted = new long[right - left + 1];\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = sum[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = sum[p1++];\n                } else {\n                    if (sum[p1] < sum[p2]) {\n                        sorted[p++] = sum[p1++];\n                    } else {\n                        sorted[p++] = sum[p2++];\n                    }\n                }\n            }\n            for (int j = 0; j < sorted.length; j++) {\n                sum[left + j] = sorted[j];\n            }\n            return ret;\n        }\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst countRangeSumRecursive = (sum, lower, upper, left, right) => {\n    if (left === right) {\n        return 0;\n    } else {\n        const mid = Math.floor((left + right) / 2);\n        const n1 = countRangeSumRecursive(sum, lower, upper, left, mid);\n        const n2 = countRangeSumRecursive(sum, lower, upper, mid + 1, right);\n        let ret = n1 + n2;\n\n        // 首先统计下标对的数量\n        let i = left;\n        let l = mid + 1;\n        let r = mid + 1;\n        while (i <= mid) {\n            while (l <= right && sum[l] - sum[i] < lower) l++;\n            while (r <= right && sum[r] - sum[i] <= upper) r++;\n            ret += (r - l);\n            i++;\n        }\n\n        // 随后合并两个排序数组\n        const sorted = new Array(right - left + 1);\n        let p1 = left, p2 = mid + 1;\n        let p = 0;\n        while (p1 <= mid || p2 <= right) {\n            if (p1 > mid) {\n                sorted[p++] = sum[p2++];\n            } else if (p2 > right) {\n                sorted[p++] = sum[p1++];\n            } else {\n                if (sum[p1] < sum[p2]) {\n                    sorted[p++] = sum[p1++];\n                } else {\n                    sorted[p++] = sum[p2++];\n                }\n            }\n        }\n        for (let i = 0; i < sorted.length; i++) {\n            sum[left + i] = sorted[i];\n        }\n        return ret;\n    }\n}\nvar countRangeSum = function(nums, lower, upper) {\n    let s = 0;\n    const sum = [0];\n    for(const v of nums) {\n        s += v;\n        sum.push(s);\n    }\n    return countRangeSumRecursive(sum, lower, upper, 0, sum.length - 1);\n};\n```\n\n```C [sol1-C]\nint countRangeSumRecursive(long long* sum, int lower, int upper, int left, int right) {\n    if (left == right) {\n        return 0;\n    } else {\n        int mid = (left + right) / 2;\n        int n1 = countRangeSumRecursive(sum, lower, upper, left, mid);\n        int n2 = countRangeSumRecursive(sum, lower, upper, mid + 1, right);\n        int ret = n1 + n2;\n\n        // 首先统计下标对的数量\n        int i = left;\n        int l = mid + 1;\n        int r = mid + 1;\n        while (i <= mid) {\n            while (l <= right && sum[l] - sum[i] < lower) l++;\n            while (r <= right && sum[r] - sum[i] <= upper) r++;\n            ret += (r - l);\n            i++;\n        }\n\n        // 随后合并两个排序数组\n        long sorted[right - left + 1];\n        memset(sorted, 0, sizeof(sorted));\n        int p1 = left, p2 = mid + 1;\n        int p = 0;\n        while (p1 <= mid || p2 <= right) {\n            if (p1 > mid) {\n                sorted[p++] = sum[p2++];\n            } else if (p2 > right) {\n                sorted[p++] = sum[p1++];\n            } else {\n                if (sum[p1] < sum[p2]) {\n                    sorted[p++] = sum[p1++];\n                } else {\n                    sorted[p++] = sum[p2++];\n                }\n            }\n        }\n        for (int i = 0; i < right - left + 1; i++) {\n            sum[left + i] = sorted[i];\n        }\n        return ret;\n    }\n}\n\nint countRangeSum(int* nums, int numsSize, int lower, int upper) {\n    long long s = 0;\n    long long sum[numsSize + 1];\n    sum[0] = 0;\n    for (int i = 1; i <= numsSize; i++) {\n        sum[i] = sum[i - 1] + nums[i - 1];\n    }\n    return countRangeSumRecursive(sum, lower, upper, 0, numsSize);\n}\n```\n\n```Golang [sol1-Golang]\nfunc countRangeSum(nums []int, lower, upper int) int {\n    var mergeCount func([]int) int\n    mergeCount = func(arr []int) int {\n        n := len(arr)\n        if n <= 1 {\n            return 0\n        }\n\n        n1 := append([]int(nil), arr[:n/2]...)\n        n2 := append([]int(nil), arr[n/2:]...)\n        cnt := mergeCount(n1) + mergeCount(n2) // 递归完毕后，n1 和 n2 均为有序\n\n        // 统计下标对的数量\n        l, r := 0, 0\n        for _, v := range n1 {\n            for l < len(n2) && n2[l]-v < lower {\n                l++\n            }\n            for r < len(n2) && n2[r]-v <= upper {\n                r++\n            }\n            cnt += r - l\n        }\n\n        // n1 和 n2 归并填入 arr\n        p1, p2 := 0, 0\n        for i := range arr {\n            if p1 < len(n1) && (p2 == len(n2) || n1[p1] <= n2[p2]) {\n                arr[i] = n1[p1]\n                p1++\n            } else {\n                arr[i] = n2[p2]\n                p2++\n            }\n        }\n        return cnt\n    }\n\n    prefixSum := make([]int, len(nums)+1)\n    for i, v := range nums {\n        prefixSum[i+1] = prefixSum[i] + v\n    }\n    return mergeCount(prefixSum)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N\\log N)$，其中 $N$ 为数组的长度。设执行时间为 $T(N)$，则两次递归调用的时间均为 $T(N/2)$，最后需要 $O(N)$ 的时间求出下标对数量以及合并数组，故有\n    $$\n    T(N) = 2 \\cdot T(N/2) + O(N)\n    $$\n    根据主定理，有 $T(N) = O(N\\log N)$。\n\n- 空间复杂度：$O(N)$。设空间占用为 $M(N)$，递归调用所需空间为 $M(N/2)$，而合并数组所需空间为 $O(N)$，故\n    $$\n    M(N) = \\max\\big\\{M(N/2), O(N)\\big\\} = M(N/2) + O(N)\n    $$\n    根据主定理，有 $M(N) = O(N)$。\n\n#### 方法二：线段树\n\n**思路与算法**\n\n依然考虑前缀和数组 $\\textit{preSum}$。\n\n对于每个下标 $j$，以 $j$ 为右端点的下标对的数量，就等于数组 $\\textit{preSum}[0..j-1]$ 中的所有整数，出现在区间 $[\\textit{preSum}[j]-\\textit{upper}, \\textit{preSum}[j]-\\textit{lower}]$ 的次数。故很容易想到基于线段树的解法。\n\n我们从左到右扫描前缀和数组。每遇到一个数 $\\textit{preSum}[j]$，我们就在线段树中查询区间 $[\\textit{preSum}[j]-\\textit{upper}, \\textit{preSum}[j]-\\textit{lower}]$ 内的整数数量，随后，将 $\\textit{preSum}[j]$ 插入到线段树当中。\n\n注意到整数的范围可能很大，故需要利用哈希表将所有可能出现的整数，映射到连续的整数区间内。\n\n**代码**\n\n```C++ [sol2-C++]\nstruct SegNode {\n    int lo, hi, add;\n    SegNode* lchild, *rchild;\n    SegNode(int left, int right): lo(left), hi(right), add(0), lchild(nullptr), rchild(nullptr) {}\n};\n\nclass Solution {\npublic:\n    SegNode* build(int left, int right) {\n        SegNode* node = new SegNode(left, right);\n        if (left == right) {\n            return node;\n        }\n        int mid = (left + right) / 2;\n        node->lchild = build(left, mid);\n        node->rchild = build(mid + 1, right);\n        return node;\n    }\n\n    void insert(SegNode* root, int val) {\n        root->add++;\n        if (root->lo == root->hi) {\n            return;\n        }\n        int mid = (root->lo + root->hi) / 2;\n        if (val <= mid) {\n            insert(root->lchild, val);\n        }\n        else {\n            insert(root->rchild, val);\n        }\n    }\n\n    int count(SegNode* root, int left, int right) const {\n        if (left > root->hi || right < root->lo) {\n            return 0;\n        }\n        if (left <= root->lo && root->hi <= right) {\n            return root->add;\n        }\n        return count(root->lchild, left, right) + count(root->rchild, left, right);\n    }\n\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        long long sum = 0;\n        vector<long long> preSum = {0};\n        for (int v: nums) {\n            sum += v;\n            preSum.push_back(sum);\n        }\n        \n        set<long long> allNumbers;\n        for (long long x: preSum) {\n            allNumbers.insert(x);\n            allNumbers.insert(x - lower);\n            allNumbers.insert(x - upper);\n        }\n        // 利用哈希表进行离散化\n        unordered_map<long long, int> values;\n        int idx = 0;\n        for (long long x: allNumbers) {\n            values[x] = idx;\n            idx++;\n        }\n\n        SegNode* root = build(0, values.size() - 1);\n        int ret = 0;\n        for (long long x: preSum) {\n            int left = values[x - upper], right = values[x - lower];\n            ret += count(root, left, right);\n            insert(root, values[x]);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        long sum = 0;\n        long[] preSum = new long[nums.length + 1];\n        for (int i = 0; i < nums.length; ++i) {\n            sum += nums[i];\n            preSum[i + 1] = sum;\n        }\n        \n        Set<Long> allNumbers = new TreeSet<Long>();\n        for (long x : preSum) {\n            allNumbers.add(x);\n            allNumbers.add(x - lower);\n            allNumbers.add(x - upper);\n        }\n        // 利用哈希表进行离散化\n        Map<Long, Integer> values = new HashMap<Long, Integer>();\n        int idx = 0;\n        for (long x : allNumbers) {\n            values.put(x, idx);\n            idx++;\n        }\n\n        SegNode root = build(0, values.size() - 1);\n        int ret = 0;\n        for (long x : preSum) {\n            int left = values.get(x - upper), right = values.get(x - lower);\n            ret += count(root, left, right);\n            insert(root, values.get(x));\n        }\n        return ret;\n    }\n\n    public SegNode build(int left, int right) {\n        SegNode node = new SegNode(left, right);\n        if (left == right) {\n            return node;\n        }\n        int mid = (left + right) / 2;\n        node.lchild = build(left, mid);\n        node.rchild = build(mid + 1, right);\n        return node;\n    }\n\n    public int count(SegNode root, int left, int right) {\n        if (left > root.hi || right < root.lo) {\n            return 0;\n        }\n        if (left <= root.lo && root.hi <= right) {\n            return root.add;\n        }\n        return count(root.lchild, left, right) + count(root.rchild, left, right);\n    }\n\n    public void insert(SegNode root, int val) {\n        root.add++;\n        if (root.lo == root.hi) {\n            return;\n        }\n        int mid = (root.lo + root.hi) / 2;\n        if (val <= mid) {\n            insert(root.lchild, val);\n        } else {\n            insert(root.rchild, val);\n        }\n    }\n}\n\nclass SegNode {\n    int lo, hi, add;\n    SegNode lchild, rchild;\n\n    public SegNode(int left, int right) {\n        lo = left;\n        hi = right;\n        add = 0;\n        lchild = null;\n        rchild = null;\n    }\n}\n```\n\n```Golang [sol2-Golang]\ntype segTree []struct {\n    l, r, val int\n}\n\nfunc (t segTree) build(o, l, r int) {\n    t[o].l, t[o].r = l, r\n    if l == r {\n        return\n    }\n    m := (l + r) >> 1\n    t.build(o<<1, l, m)\n    t.build(o<<1|1, m+1, r)\n}\n\nfunc (t segTree) inc(o, i int) {\n    if t[o].l == t[o].r {\n        t[o].val++\n        return\n    }\n    if i <= (t[o].l+t[o].r)>>1 {\n        t.inc(o<<1, i)\n    } else {\n        t.inc(o<<1|1, i)\n    }\n    t[o].val = t[o<<1].val + t[o<<1|1].val\n}\n\nfunc (t segTree) query(o, l, r int) (res int) {\n    if l <= t[o].l && t[o].r <= r {\n        return t[o].val\n    }\n    m := (t[o].l + t[o].r) >> 1\n    if r <= m {\n        return t.query(o<<1, l, r)\n    }\n    if l > m {\n        return t.query(o<<1|1, l, r)\n    }\n    return t.query(o<<1, l, r) + t.query(o<<1|1, l, r)\n}\n\nfunc countRangeSum(nums []int, lower, upper int) (cnt int) {\n    n := len(nums)\n\n    // 计算前缀和 preSum，以及后面统计时会用到的所有数字 allNums\n    allNums := make([]int, 1, 3*n+1)\n    preSum := make([]int, n+1)\n    for i, v := range nums {\n        preSum[i+1] = preSum[i] + v\n        allNums = append(allNums, preSum[i+1], preSum[i+1]-lower, preSum[i+1]-upper)\n    }\n\n    // 将 allNums 离散化\n    sort.Ints(allNums)\n    k := 1\n    kth := map[int]int{allNums[0]: k}\n    for i := 1; i <= 3*n; i++ {\n        if allNums[i] != allNums[i-1] {\n            k++\n            kth[allNums[i]] = k\n        }\n    }\n\n    // 遍历 preSum，利用线段树计算每个前缀和对应的合法区间数\n    t := make(segTree, 4*k)\n    t.build(1, 1, k)\n    t.inc(1, kth[0])\n    for _, sum := range preSum[1:] {\n        left, right := kth[sum-upper], kth[sum-lower]\n        cnt += t.query(1, left, right)\n        t.inc(1, kth[sum])\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N\\log N)$。使用哈希离散化之后，线段树维护的区间大小为 $O(N)$，故其深度、单次查询或插入的时间复杂度均为 $O(\\log N)$。而离散化本身的复杂度也为 $O(N\\log N)$。\n\n- 空间复杂度：$O(N)$。线段树的深度为 $O(N)$，而第 $i$ 层拥有的节点数量为 $2^{i-1}$，故线段树总的节点数量为 $2^{O(\\log N)} = O(N)$。\n\n#### 方法三：动态增加节点的线段树\n\n**思路与算法**\n\n与方法二类似，但我们可以不实用哈希表进行映射，而是只在线段树的插入操作过程中**动态地**增加树中的节点。而当我们进行查询操作时，如果到达一个空节点，那么说明对应的区间中暂时还没有值，就可以直接返回 $0$。\n\n**代码**\n\n```C++ [sol3-C++]\nstruct SegNode {\n    long long lo, hi;\n    int add;\n    SegNode* lchild, *rchild;\n    SegNode(long long left, long long right): lo(left), hi(right), add(0), lchild(nullptr), rchild(nullptr) {}\n};\n\nclass Solution {\npublic:\n    void insert(SegNode* root, long long val) {\n        root->add++;\n        if (root->lo == root->hi) {\n            return;\n        }\n        long long mid = (root->lo + root->hi) >> 1;\n        if (val <= mid) {\n            if (!root->lchild) {\n                root->lchild = new SegNode(root->lo, mid);\n            }\n            insert(root->lchild, val);\n        }\n        else {\n            if (!root->rchild) {\n                root->rchild = new SegNode(mid + 1, root->hi);\n            }\n            insert(root->rchild, val);\n        }\n    }\n\n    int count(SegNode* root, long long left, long long right) const {\n        if (!root) {\n            return 0;\n        }\n        if (left > root->hi || right < root->lo) {\n            return 0;\n        }\n        if (left <= root->lo && root->hi <= right) {\n            return root->add;\n        }\n        return count(root->lchild, left, right) + count(root->rchild, left, right);\n    }\n\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        long long sum = 0;\n        vector<long long> preSum = {0};\n        for(int v: nums) {\n            sum += v;\n            preSum.push_back(sum);\n        }\n        \n        long long lbound = LLONG_MAX, rbound = LLONG_MIN;\n        for (long long x: preSum) {\n            lbound = min({lbound, x, x - lower, x - upper});\n            rbound = max({rbound, x, x - lower, x - upper});\n        }\n        \n        SegNode* root = new SegNode(lbound, rbound);\n        int ret = 0;\n        for (long long x: preSum) {\n            ret += count(root, x - upper, x - lower);\n            insert(root, x);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        long sum = 0;\n        long[] preSum = new long[nums.length + 1];\n        for (int i = 0; i < nums.length; ++i) {\n            sum += nums[i];\n            preSum[i + 1] = sum;\n        }\n        \n        long lbound = Long.MAX_VALUE, rbound = Long.MIN_VALUE;\n        for (long x : preSum) {\n            lbound = Math.min(Math.min(lbound, x), Math.min(x - lower, x - upper));\n            rbound = Math.max(Math.max(rbound, x), Math.max(x - lower, x - upper));\n        }\n        \n        SegNode root = new SegNode(lbound, rbound);\n        int ret = 0;\n        for (long x : preSum) {\n            ret += count(root, x - upper, x - lower);\n            insert(root, x);\n        }\n        return ret;\n    }\n\n    public int count(SegNode root, long left, long right) {\n        if (root == null) {\n            return 0;\n        }\n        if (left > root.hi || right < root.lo) {\n            return 0;\n        }\n        if (left <= root.lo && root.hi <= right) {\n            return root.add;\n        }\n        return count(root.lchild, left, right) + count(root.rchild, left, right);\n    }\n\n    public void insert(SegNode root, long val) {\n        root.add++;\n        if (root.lo == root.hi) {\n            return;\n        }\n        long mid = (root.lo + root.hi) >> 1;\n        if (val <= mid) {\n            if (root.lchild == null) {\n                root.lchild = new SegNode(root.lo, mid);\n            }\n            insert(root.lchild, val);\n        } else {\n            if (root.rchild == null) {\n                root.rchild = new SegNode(mid + 1, root.hi);\n            }\n            insert(root.rchild, val);\n        }\n    }\n}\n\nclass SegNode {\n    long lo, hi;\n    int add;\n    SegNode lchild, rchild;\n\n    public SegNode(long left, long right) {\n        lo = left;\n        hi = right;\n        add = 0;\n        lchild = null;\n        rchild = null;\n    }\n}\n```\n\n```Golang [sol3-Golang]\ntype node struct {\n    l, r, val int\n    lo, ro    *node\n}\n\nfunc (o *node) insert(val int) {\n    o.val++\n    if o.l == o.r {\n        return\n    }\n    m := (o.l + o.r) >> 1\n    if val <= m {\n        if o.lo == nil {\n            o.lo = &node{l: o.l, r: m}\n        }\n        o.lo.insert(val)\n    } else {\n        if o.ro == nil {\n            o.ro = &node{l: m + 1, r: o.r}\n        }\n        o.ro.insert(val)\n    }\n}\n\nfunc (o *node) query(l, r int) (res int) {\n    if o == nil || l > o.r || r < o.l {\n        return\n    }\n    if l <= o.l && o.r <= r {\n        return o.val\n    }\n    return o.lo.query(l, r) + o.ro.query(l, r)\n}\n\nfunc countRangeSum(nums []int, lower, upper int) (cnt int) {\n    preSum := make([]int, len(nums)+1)\n    for i, v := range nums {\n        preSum[i+1] = preSum[i] + v\n    }\n\n    lbound, rbound := math.MaxInt64, -math.MaxInt64\n    for _, sum := range preSum {\n        lbound = min(lbound, sum, sum-lower, sum-upper)\n        rbound = max(rbound, sum, sum-lower, sum-upper)\n    }\n\n    root := &node{l: lbound, r: rbound}\n    for _, sum := range preSum {\n        left, right := sum-upper, sum-lower\n        cnt += root.query(left, right)\n        root.insert(sum)\n    }\n    return\n}\n\nfunc min(a ...int) int {\n    res := a[0]\n    for _, v := range a[1:] {\n        if v < res {\n            res = v\n        }\n    }\n    return res\n}\n\nfunc max(a ...int) int {\n    res := a[0]\n    for _, v := range a[1:] {\n        if v > res {\n            res = v\n        }\n    }\n    return res\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N \\log C)$，其中 $C$ 是线段树根节点对应的区间长度。由于我们使用 $64$ 位整数类型进行存储，因此 $\\log C$ 不会超过 $64$。使用动态增加节点的线段树，单次查询或插入的时间复杂度均为 $O(\\log C)$。\n- 空间复杂度：$O(N \\log C)$。需要进行 $N$ 次线段树的插入操作，每次会添加不超过 $\\log C$ 个新节点。\n\n#### 方法四：树状数组\n\n**思路与算法**\n\n树状数组与线段树基于类似的思想，不过树状数组支持的基本查询为求出 $[0, \\textit{val}]$ 之间的整数数量。为了查询区间 $[\\textit{preSum}[j]-\\textit{upper}, \\textit{preSum}[j]-\\textit{lower}]$ 内的整数数量，需要执行两次查询，即分别查询 $[0, \\textit{preSum}[j]-\\textit{upper}-1]$ 区间的整数数量 $L$ 和$[0,\\textit{preSum}[j]-\\textit{lower}]$ 区间的整数数量 $R$，答案即为两者作差 $R-L$。\n\n**代码**\n\n```C++ [sol4-C++]\nclass BIT {\nprivate:\n    vector<int> tree;\n    int n;\n\npublic:\n    BIT(int _n): n(_n), tree(_n + 1) {}\n\n    static constexpr int lowbit(int x) {\n        return x & (-x);\n    }\n\n    void update(int x, int d) {\n        while (x <= n) {\n            tree[x] += d;\n            x += lowbit(x);\n        }\n    }\n\n    int query(int x) const {\n        int ans = 0;\n        while (x) {\n            ans += tree[x];\n            x -= lowbit(x);\n        }\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        long long sum = 0;\n        vector<long long> preSum = {0};\n        for (int v: nums) {\n            sum += v;\n            preSum.push_back(sum);\n        }\n        \n        set<long long> allNumbers;\n        for (long long x: preSum) {\n            allNumbers.insert(x);\n            allNumbers.insert(x - lower);\n            allNumbers.insert(x - upper);\n        }\n        // 利用哈希表进行离散化\n        unordered_map<long long, int> values;\n        int idx = 0;\n        for (long long x: allNumbers) {\n            values[x] = idx;\n            idx++;\n        }\n\n        int ret = 0;\n        BIT bit(values.size());\n        for (int i = 0; i < preSum.size(); i++) {\n            int left = values[preSum[i] - upper], right = values[preSum[i] - lower];\n            ret += bit.query(right + 1) - bit.query(left);\n            bit.update(values[preSum[i]] + 1, 1);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol4-Java]\nclass Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        long sum = 0;\n        long[] preSum = new long[nums.length + 1];\n        for (int i = 0; i < nums.length; ++i) {\n            sum += nums[i];\n            preSum[i + 1] = sum;\n        }\n        \n        Set<Long> allNumbers = new TreeSet<Long>();\n        for (long x : preSum) {\n            allNumbers.add(x);\n            allNumbers.add(x - lower);\n            allNumbers.add(x - upper);\n        }\n        // 利用哈希表进行离散化\n        Map<Long, Integer> values = new HashMap<Long, Integer>();\n        int idx = 0;\n        for (long x: allNumbers) {\n            values.put(x, idx);\n            idx++;\n        }\n\n        int ret = 0;\n        BIT bit = new BIT(values.size());\n        for (int i = 0; i < preSum.length; i++) {\n            int left = values.get(preSum[i] - upper), right = values.get(preSum[i] - lower);\n            ret += bit.query(right + 1) - bit.query(left);\n            bit.update(values.get(preSum[i]) + 1, 1);\n        }\n        return ret;\n    }\n}\n\nclass BIT {\n    int[] tree;\n    int n;\n\n    public BIT(int n) {\n        this.n = n;\n        this.tree = new int[n + 1];\n    }\n\n    public static int lowbit(int x) {\n        return x & (-x);\n    }\n\n    public void update(int x, int d) {\n        while (x <= n) {\n            tree[x] += d;\n            x += lowbit(x);\n        }\n    }\n\n    public int query(int x) {\n        int ans = 0;\n        while (x != 0) {\n            ans += tree[x];\n            x -= lowbit(x);\n        }\n        return ans;\n    }\n}\n```\n\n```Golang [sol4-Golang]\ntype fenwick struct {\n    tree []int\n}\n\nfunc (f fenwick) inc(i int) {\n    for ; i < len(f.tree); i += i & -i {\n        f.tree[i]++\n    }\n}\n\nfunc (f fenwick) sum(i int) (res int) {\n    for ; i > 0; i &= i - 1 {\n        res += f.tree[i]\n    }\n    return\n}\n\nfunc (f fenwick) query(l, r int) (res int) {\n    return f.sum(r) - f.sum(l-1)\n}\n\nfunc countRangeSum(nums []int, lower, upper int) (cnt int) {\n    n := len(nums)\n\n    // 计算前缀和 preSum，以及后面统计时会用到的所有数字 allNums\n    allNums := make([]int, 1, 3*n+1)\n    preSum := make([]int, n+1)\n    for i, v := range nums {\n        preSum[i+1] = preSum[i] + v\n        allNums = append(allNums, preSum[i+1], preSum[i+1]-lower, preSum[i+1]-upper)\n    }\n\n    // 将 allNums 离散化\n    sort.Ints(allNums)\n    k := 1\n    kth := map[int]int{allNums[0]: k}\n    for i := 1; i <= 3*n; i++ {\n        if allNums[i] != allNums[i-1] {\n            k++\n            kth[allNums[i]] = k\n        }\n    }\n\n    // 遍历 preSum，利用树状数组计算每个前缀和对应的合法区间数\n    t := fenwick{make([]int, k+1)}\n    t.inc(kth[0])\n    for _, sum := range preSum[1:] {\n        left, right := kth[sum-upper], kth[sum-lower]\n        cnt += t.query(left, right)\n        t.inc(kth[sum])\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N\\log N)$。离散化本身的复杂度为 $O(N\\log N)$，而树状数组单次更新或查询的复杂度为 $O(\\log N)$。\n\n- 空间复杂度：$O(N)$。\n\n#### 方法五：平衡二叉搜索树\n\n**思路与算法**\n\n考虑一棵平衡二叉搜索树。若其节点数量为 $N$，则深度为 $O(\\log N)$。二叉搜索树能够在 $O(\\log N)$ 的时间内，对任意给定的值 $\\textit{val}$，查询树中所有小于或等于该值的数量。\n\n因此，我们可以从左到右扫描前缀和数组。对于 $\\textit{preSum}[j]$ 而言，首先进行两次查询，得到区间 $[\\textit{preSum}[j]-\\textit{upper}, \\textit{preSum}[j]-\\textit{lower}]$ 内的整数数量；随后再将 $\\textit{preSum}[j]$ 插入到平衡树中。\n\n平衡二叉搜索树有多种不同的实现，最经典的为 AVL 树与红黑树。此外，在算法竞赛中，还包括 Treap、SBT 等数据结构。\n\n下面给出基于 Treap 的实现。\n\n**代码**\n\n```C++ [sol5-C++]\nclass BalancedTree {\nprivate:\n    struct BalancedNode {\n        long long val;\n        long long seed;\n        int count;\n        int size;\n        BalancedNode* left;\n        BalancedNode* right;\n\n        BalancedNode(long long _val, long long _seed): val(_val), seed(_seed), count(1), size(1), left(nullptr), right(nullptr) {}\n\n        BalancedNode* left_rotate() {\n            int prev_size = size;\n            int curr_size = (left ? left->size : 0) + (right->left ? right->left->size : 0) + count;\n            BalancedNode* root = right;\n            right = root->left;\n            root->left = this;\n            root->size = prev_size;\n            size = curr_size;\n            return root;\n        }\n\n        BalancedNode* right_rotate() {\n            int prev_size = size;\n            int curr_size = (right ? right->size : 0) + (left->right ? left->right->size : 0) + count;\n            BalancedNode* root = left;\n            left = root->right;\n            root->right = this;\n            root->size = prev_size;\n            size = curr_size;\n            return root;\n        }\n    };\n\nprivate:\n    BalancedNode* root;\n    int size;\n    mt19937 gen;\n    uniform_int_distribution<long long> dis;\n\nprivate:\n    BalancedNode* insert(BalancedNode* node, long long x) {\n        if (!node) {\n            return new BalancedNode(x, dis(gen));\n        }\n        ++node->size;\n        if (x < node->val) {\n            node->left = insert(node->left, x);\n            if (node->left->seed > node->seed) {\n                node = node->right_rotate();\n            }\n        }\n        else if (x > node->val) {\n            node->right = insert(node->right, x);\n            if (node->right->seed > node->seed) {\n                node = node->left_rotate();\n            }\n        }\n        else {\n            ++node->count;\n        }\n        return node;\n    }\n\npublic:\n    BalancedTree(): root(nullptr), size(0), gen(random_device{}()), dis(LLONG_MIN, LLONG_MAX) {}\n\n    long long get_size() const {\n        return size;\n    }\n\n    void insert(long long x) {\n        ++size;\n        root = insert(root, x);\n    }\n\n    long long lower_bound(long long x) const {\n        BalancedNode* node = root;\n        long long ans = LLONG_MAX;\n        while (node) {\n            if (x == node->val) {\n                return x;\n            }\n            if (x < node->val) {\n                ans = node->val;\n                node = node->left;\n            }\n            else {\n                node = node->right;\n            }\n        }\n        return ans;\n    }\n\n    long long upper_bound(long long x) const {\n        BalancedNode* node = root;\n        long long ans = LLONG_MAX;\n        while (node) {\n            if (x < node->val) {\n                ans = node->val;\n                node = node->left;\n            }\n            else {\n                node = node->right;\n            }\n        }\n        return ans;\n    }\n\n    pair<int, int> rank(long long x) const {\n        BalancedNode* node = root;\n        int ans = 0;\n        while (node) {\n            if (x < node->val) {\n                node = node->left;\n            }\n            else {\n                ans += (node->left ? node->left->size : 0) + node->count;\n                if (x == node->val) {\n                    return {ans - node->count + 1, ans};\n                }\n                node = node->right;\n            }\n        }\n        return {INT_MIN, INT_MAX};\n    }\n};\n\nclass Solution {\npublic:\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        long long sum = 0;\n        vector<long long> preSum = {0};\n        for (int v: nums) {\n            sum += v;\n            preSum.push_back(sum);\n        }\n        \n        BalancedTree* treap = new BalancedTree();\n        int ret = 0;\n        for (long long x: preSum) {\n            long long numLeft = treap->lower_bound(x - upper);\n            int rankLeft = (numLeft == LLONG_MAX ? treap->get_size() + 1 : treap->rank(numLeft).first);\n            long long numRight = treap->upper_bound(x - lower);\n            int rankRight = (numRight == LLONG_MAX ? treap->get_size() : treap->rank(numRight).first - 1);\n            ret += (rankRight - rankLeft + 1);\n            treap->insert(x);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol5-Java]\nclass Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        long sum = 0;\n        long[] preSum = new long[nums.length + 1];\n        for (int i = 0; i < nums.length; ++i) {\n            sum += nums[i];\n            preSum[i + 1] = sum;\n        }\n        \n        BalancedTree treap = new BalancedTree();\n        int ret = 0;\n        for (long x : preSum) {\n            long numLeft = treap.lowerBound(x - upper);\n            int rankLeft = (numLeft == Long.MAX_VALUE ? (int) (treap.getSize() + 1) : treap.rank(numLeft)[0]);\n            long numRight = treap.upperBound(x - lower);\n            int rankRight = (numRight == Long.MAX_VALUE ? (int) treap.getSize() : treap.rank(numRight)[0] - 1);\n            ret += rankRight - rankLeft + 1;\n            treap.insert(x);\n        }\n        return ret;\n    }\n}\n\nclass BalancedTree {\n    private class BalancedNode {\n        long val;\n        long seed;\n        int count;\n        int size;\n        BalancedNode left;\n        BalancedNode right;\n\n        BalancedNode(long val, long seed) {\n            this.val = val;\n            this.seed = seed;\n            this.count = 1;\n            this.size = 1;\n            this.left = null;\n            this.right = null;\n        }\n\n        BalancedNode leftRotate() {\n            int prevSize = size;\n            int currSize = (left != null ? left.size : 0) + (right.left != null ? right.left.size : 0) + count;\n            BalancedNode root = right;\n            right = root.left;\n            root.left = this;\n            root.size = prevSize;\n            size = currSize;\n            return root;\n        }\n\n        BalancedNode rightRotate() {\n            int prevSize = size;\n            int currSize = (right != null ? right.size : 0) + (left.right != null ? left.right.size : 0) + count;\n            BalancedNode root = left;\n            left = root.right;\n            root.right = this;\n            root.size = prevSize;\n            size = currSize;\n            return root;\n        }\n    }\n\n    private BalancedNode root;\n    private int size;\n    private Random rand;\n\n    public BalancedTree() {\n        this.root = null;\n        this.size = 0;\n        this.rand = new Random();\n    }\n\n    public long getSize() {\n        return size;\n    }\n\n    public void insert(long x) {\n        ++size;\n        root = insert(root, x);\n    }\n\n    public long lowerBound(long x) {\n        BalancedNode node = root;\n        long ans = Long.MAX_VALUE;\n        while (node != null) {\n            if (x == node.val) {\n                return x;\n            }\n            if (x < node.val) {\n                ans = node.val;\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        }\n        return ans;\n    }\n\n    public long upperBound(long x) {\n        BalancedNode node = root;\n        long ans = Long.MAX_VALUE;\n        while (node != null) {\n            if (x < node.val) {\n                ans = node.val;\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        }\n        return ans;\n    }\n\n    public int[] rank(long x) {\n        BalancedNode node = root;\n        int ans = 0;\n        while (node != null) {\n            if (x < node.val) {\n                node = node.left;\n            } else {\n                ans += (node.left != null ? node.left.size : 0) + node.count;\n                if (x == node.val) {\n                    return new int[]{ans - node.count + 1, ans};\n                }\n                node = node.right;\n            }\n        }\n        return new int[]{Integer.MIN_VALUE, Integer.MAX_VALUE};\n    }\n\n    private BalancedNode insert(BalancedNode node, long x) {\n        if (node == null) {\n            return new BalancedNode(x, rand.nextInt());\n        }\n        ++node.size;\n        if (x < node.val) {\n            node.left = insert(node.left, x);\n            if (node.left.seed > node.seed) {\n                node = node.rightRotate();\n            }\n        } else if (x > node.val) {\n            node.right = insert(node.right, x);\n            if (node.right.seed > node.seed) {\n                node = node.leftRotate();\n            }\n        } else {\n            ++node.count;\n        }\n        return node;\n    }\n}\n```\n\n```Golang [sol5-Golang]\nimport \"math/rand\" // 默认导入的 rand 不是这个库，需要显式指明\n\ntype node struct {\n    ch       [2]*node\n    priority int\n    key      int\n    dupCnt   int\n    sz       int\n}\n\nfunc (o *node) cmp(b int) int {\n    switch {\n    case b < o.key:\n        return 0\n    case b > o.key:\n        return 1\n    default:\n        return -1\n    }\n}\n\nfunc (o *node) size() int {\n    if o != nil {\n        return o.sz\n    }\n    return 0\n}\n\nfunc (o *node) maintain() {\n    o.sz = o.dupCnt + o.ch[0].size() + o.ch[1].size()\n}\n\nfunc (o *node) rotate(d int) *node {\n    x := o.ch[d^1]\n    o.ch[d^1] = x.ch[d]\n    x.ch[d] = o\n    o.maintain()\n    x.maintain()\n    return x\n}\n\ntype treap struct {\n    root *node\n}\n\nfunc (t *treap) _insert(o *node, key int) *node {\n    if o == nil {\n        return &node{priority: rand.Int(), key: key, dupCnt: 1, sz: 1}\n    }\n    if d := o.cmp(key); d >= 0 {\n        o.ch[d] = t._insert(o.ch[d], key)\n        if o.ch[d].priority > o.priority {\n            o = o.rotate(d ^ 1)\n        }\n    } else {\n        o.dupCnt++\n    }\n    o.maintain()\n    return o\n}\n\nfunc (t *treap) insert(key int) {\n    t.root = t._insert(t.root, key)\n}\n\n// equal=false: 小于 key 的元素个数\n// equal=true: 小于或等于 key 的元素个数\nfunc (t *treap) rank(key int, equal bool) (cnt int) {\n    for o := t.root; o != nil; {\n        switch c := o.cmp(key); {\n        case c == 0:\n            o = o.ch[0]\n        case c > 0:\n            cnt += o.dupCnt + o.ch[0].size()\n            o = o.ch[1]\n        default:\n            cnt += o.ch[0].size()\n            if equal {\n                cnt += o.dupCnt\n            }\n            return\n        }\n    }\n    return\n}\n\nfunc countRangeSum(nums []int, lower, upper int) (cnt int) {\n    preSum := make([]int, len(nums)+1)\n    for i, v := range nums {\n        preSum[i+1] = preSum[i] + v\n    }\n\n    t := &treap{}\n    for _, sum := range preSum {\n        left, right := sum-upper, sum-lower\n        cnt += t.rank(right, true) - t.rank(left, false)\n        t.insert(sum)\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N\\log N)$。\n\n- 空间复杂度：$O(N)$。"
}