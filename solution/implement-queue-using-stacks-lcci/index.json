{
	"titleSlug": "implement-queue-using-stacks-lcci",
	"slug": "hua-zhan-wei-dui-by-leetcode-solution-kq35",
	"url": "https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/solution/hua-zhan-wei-dui-by-leetcode-solution-kq35/",
	"content": "#### 方法一：双栈\n\n**思路**\n\n将一个栈当作输入栈，用于压入 $\\texttt{push}$ 传入的数据；另一个栈当作输出栈，用于 $\\texttt{pop}$ 和 $\\texttt{peek}$ 操作。\n\n每次 $\\texttt{pop}$ 或 $\\texttt{peek}$ 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\n\n**代码**\n\n```C++ [sol1-C++]\nclass MyQueue {\nprivate:\n    stack<int> inStack, outStack;\n\n    void in2out() {\n        while (!inStack.empty()) {\n            outStack.push(inStack.top());\n            inStack.pop();\n        }\n    }\n\npublic:\n    MyQueue() {}\n\n    void push(int x) {\n        inStack.push(x);\n    }\n\n    int pop() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        int x = outStack.top();\n        outStack.pop();\n        return x;\n    }\n\n    int peek() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        return outStack.top();\n    }\n\n    bool empty() {\n        return inStack.empty() && outStack.empty();\n    }\n};\n```\n\n```Java [sol1-Java]\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class MyQueue {\n    Stack<int> inStack;\n    Stack<int> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<int>();\n        outStack = new Stack<int>();\n    }\n\n    public void Push(int x) {\n        inStack.Push(x);\n    }\n\n    public int Pop() {\n        if (outStack.Count == 0) {\n            In2Out();\n        }\n        return outStack.Pop();\n    }\n\n    public int Peek() {\n        if (outStack.Count == 0) {\n            In2Out();\n        }\n        return outStack.Peek();\n    }\n\n    public bool Empty() {\n        return inStack.Count == 0 && outStack.Count == 0;\n    }\n\n    private void In2Out() {\n        while (inStack.Count > 0) {\n            outStack.Push(inStack.Pop());\n        }\n    }\n}\n```\n\n```go [sol1-Golang]\ntype MyQueue struct {\n    inStack, outStack []int\n}\n\nfunc Constructor() MyQueue {\n    return MyQueue{}\n}\n\nfunc (q *MyQueue) Push(x int) {\n    q.inStack = append(q.inStack, x)\n}\n\nfunc (q *MyQueue) in2out() {\n    for len(q.inStack) > 0 {\n        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])\n        q.inStack = q.inStack[:len(q.inStack)-1]\n    }\n}\n\nfunc (q *MyQueue) Pop() int {\n    if len(q.outStack) == 0 {\n        q.in2out()\n    }\n    x := q.outStack[len(q.outStack)-1]\n    q.outStack = q.outStack[:len(q.outStack)-1]\n    return x\n}\n\nfunc (q *MyQueue) Peek() int {\n    if len(q.outStack) == 0 {\n        q.in2out()\n    }\n    return q.outStack[len(q.outStack)-1]\n}\n\nfunc (q *MyQueue) Empty() bool {\n    return len(q.inStack) == 0 && len(q.outStack) == 0\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int* stk;\n    int stkSize;\n    int stkCapacity;\n} Stack;\n\nStack* stackCreate(int cpacity) {\n    Stack* ret = malloc(sizeof(Stack));\n    ret->stk = malloc(sizeof(int) * cpacity);\n    ret->stkSize = 0;\n    ret->stkCapacity = cpacity;\n    return ret;\n}\n\nvoid stackPush(Stack* obj, int x) {\n    obj->stk[obj->stkSize++] = x;\n}\n\nvoid stackPop(Stack* obj) {\n    obj->stkSize--;\n}\n\nint stackTop(Stack* obj) {\n    return obj->stk[obj->stkSize - 1];\n}\n\nbool stackEmpty(Stack* obj) {\n    return obj->stkSize == 0;\n}\n\nvoid stackFree(Stack* obj) {\n    free(obj->stk);\n}\n\ntypedef struct {\n    Stack* inStack;\n    Stack* outStack;\n} MyQueue;\n\nMyQueue* myQueueCreate() {\n    MyQueue* ret = malloc(sizeof(MyQueue));\n    ret->inStack = stackCreate(100);\n    ret->outStack = stackCreate(100);\n    return ret;\n}\n\nvoid in2out(MyQueue* obj) {\n    while (!stackEmpty(obj->inStack)) {\n        stackPush(obj->outStack, stackTop(obj->inStack));\n        stackPop(obj->inStack);\n    }\n}\n\nvoid myQueuePush(MyQueue* obj, int x) {\n    stackPush(obj->inStack, x);\n}\n\nint myQueuePop(MyQueue* obj) {\n    if (stackEmpty(obj->outStack)) {\n        in2out(obj);\n    }\n    int x = stackTop(obj->outStack);\n    stackPop(obj->outStack);\n    return x;\n}\n\nint myQueuePeek(MyQueue* obj) {\n    if (stackEmpty(obj->outStack)) {\n        in2out(obj);\n    }\n    return stackTop(obj->outStack);\n}\n\nbool myQueueEmpty(MyQueue* obj) {\n    return stackEmpty(obj->inStack) && stackEmpty(obj->outStack);\n}\n\nvoid myQueueFree(MyQueue* obj) {\n    stackFree(obj->inStack);\n    stackFree(obj->outStack);\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$\\texttt{push}$ 和 $\\texttt{empty}$ 为 $O(1)$，$\\texttt{pop}$ 和 $\\texttt{peek}$ 为均摊 $O(1)$。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 $O(1)$。\n\n- 空间复杂度：$O(n)$。其中 $n$ 是操作总数。对于有 $n$ 次 $\\texttt{push}$ 操作的情况，队列中会有 $n$ 个元素，故空间复杂度为 $O(n)$。"
}