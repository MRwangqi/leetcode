{
	"titleSlug": "exclusive-time-of-functions",
	"slug": "han-shu-de-du-zhan-shi-jian-by-leetcode-d54e2",
	"url": "https://leetcode-cn.com/problems/exclusive-time-of-functions/solution/han-shu-de-du-zhan-shi-jian-by-leetcode-d54e2/",
	"content": "#### 方法一：栈\n\n**思路与算法**\n\n我们可以用**栈**来模拟函数调用的过程，栈顶的元素为当前正在执行函数：\n\n- 当函数调用开始时，如果当前有函数正在运行，则当前正在运行函数应当停止，此时计算其的执行时间，然后将调用函数入栈。\n- 当函数调用结束时，将栈顶元素弹出，并计算相应的执行时间，如果此时栈顶有被暂停的函数，则开始运行该函数。\n\n由于每一个函数都有一个对应的 $\\textit{start}$ 和 $\\textit{end}$ 日志，且当遇到一个 $end$ 日志时，栈顶元素一定为其对应的 $\\textit{start}$ 日志。那么我们对于每一个函数记录它的函数标识符和上次开始运行的时间戳，此时我们只需要在每次函数暂停运行的时候来计算执行时间和开始运行的时候更新时间戳即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\n        ans = [0] * n\n        st = []\n        for log in logs:\n            idx, tp, timestamp = log.split(':')\n            idx, timestamp = int(idx), int(timestamp)\n            if tp[0] == 's':\n                if st:\n                    ans[st[-1][0]] += timestamp - st[-1][1]\n                    st[-1][1] = timestamp\n                st.append([idx, timestamp])\n            else:\n                i, t = st.pop()\n                ans[i] += timestamp - t + 1\n                if st:\n                    st[-1][1] = timestamp + 1\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\n        stack<pair<int, int>> st; // {idx, 开始运行的时间}\n        vector<int> res(n, 0);\n        for (auto& log : logs) {\n            char type[10];\n            int idx, timestamp;\n            sscanf(log.c_str(), \"%d:%[^:]:%d\", &idx, type, &timestamp);\n            if (type[0] == 's') {\n                if (!st.empty()) {\n                    res[st.top().first] += timestamp - st.top().second;\n                    st.top().second = timestamp;\n                }\n                st.emplace(idx, timestamp);\n            } else {\n                auto t = st.top();\n                st.pop();\n                res[t.first] += timestamp - t.second + 1;\n                if (!st.empty()) {\n                    st.top().second = timestamp + 1;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] exclusiveTime(int n, List<String> logs) {\n        Deque<int[]> stack = new ArrayDeque<int[]>(); // {idx, 开始运行的时间}\n        int[] res = new int[n];\n        for (String log : logs) {\n            int idx = Integer.parseInt(log.substring(0, log.indexOf(':')));\n            String type = log.substring(log.indexOf(':') + 1, log.lastIndexOf(':'));\n            int timestamp = Integer.parseInt(log.substring(log.lastIndexOf(':') + 1));\n            if (\"start\".equals(type)) {\n                if (!stack.isEmpty()) {\n                    res[stack.peek()[0]] += timestamp - stack.peek()[1];\n                    stack.peek()[1] = timestamp;\n                }\n                stack.push(new int[]{idx, timestamp});\n            } else {\n                int[] t = stack.pop();\n                res[t[0]] += timestamp - t[1] + 1;\n                if (!stack.isEmpty()) {\n                    stack.peek()[1] = timestamp + 1;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] ExclusiveTime(int n, IList<string> logs) {\n        Stack<int[]> stack = new Stack<int[]>(); // {idx, 开始运行的时间}\n        int[] res = new int[n];\n        foreach (string log in logs) {\n            int idx = int.Parse(log.Substring(0, log.IndexOf(':')));\n            string type = log.Substring(log.IndexOf(':') + 1, log.LastIndexOf(':') - log.IndexOf(':') - 1);\n            int timestamp = int.Parse(log.Substring(log.LastIndexOf(':') + 1));\n            if (\"start\".Equals(type)) {\n                if (stack.Count > 0) {\n                    res[stack.Peek()[0]] += timestamp - stack.Peek()[1];\n                    stack.Peek()[1] = timestamp;\n                }\n                stack.Push(new int[]{idx, timestamp});\n            } else {\n                int[] t = stack.Pop();\n                res[t[0]] += timestamp - t[1] + 1;\n                if (stack.Count > 0) {\n                    stack.Peek()[1] = timestamp + 1;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int idx;\n    int timestamp;\n} Pair;\n\nint* exclusiveTime(int n, char ** logs, int logsSize, int* returnSize) {\n    Pair *stack = (Pair *)malloc(sizeof(Pair)* logsSize); // {idx, 开始运行的时间}\n    int *res = (int *)malloc(sizeof(int) * n);\n    memset(res, 0, sizeof(int) * n);\n    int top = 0;\n    for (int i = 0; i < logsSize; i++) {\n        char type[10];\n        int idx, timestamp;\n        sscanf(logs[i], \"%d:%[^:]:%d\", &idx, type, &timestamp);\n        if (type[0] == 's') {\n            if (top > 0) {\n                res[stack[top - 1].idx] += timestamp - stack[top - 1].timestamp;\n                stack[top - 1].timestamp = timestamp;\n            }\n            stack[top].idx = idx;\n            stack[top].timestamp = timestamp;\n            top++;\n        } else {\n            res[stack[top - 1].idx] += timestamp - stack[top - 1].timestamp + 1;\n            top--;\n            if (top > 0) {\n                stack[top - 1].timestamp = timestamp + 1;\n            }\n        }\n    }\n    free(stack);\n    *returnSize = n;\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar exclusiveTime = function(n, logs) {\n    const stack = []; // {idx, 开始运行的时间}\n    const res = new Array(n).fill(0);\n    for (const log of logs) {\n        const idx = parseInt(log.substring(0, log.indexOf(':')));\n        const type = log.substring(log.indexOf(':') + 1, log.lastIndexOf(':'));\n        const timestamp = parseInt(log.substring(log.lastIndexOf(':') + 1));\n        if (\"start\" === type) {\n            if (stack.length) {\n                res[stack[stack.length - 1][0]] += timestamp - stack[stack.length - 1][1];\n                stack[stack.length - 1][1] = timestamp;\n            }\n            stack.push([idx, timestamp]);\n        } else {\n            const t = stack.pop();\n            res[t[0]] += timestamp - t[1] + 1;\n            if (stack.length) {\n                stack[stack.length - 1][1] = timestamp + 1;\n            }\n        }\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc exclusiveTime(n int, logs []string) []int {\n    ans := make([]int, n)\n    type pair struct{ idx, timestamp int }\n    st := []pair{}\n    for _, log := range logs {\n        sp := strings.Split(log, \":\")\n        idx, _ := strconv.Atoi(sp[0])\n        timestamp, _ := strconv.Atoi(sp[2])\n        if sp[1][0] == 's' {\n            if len(st) > 0 {\n                ans[st[len(st)-1].idx] += timestamp - st[len(st)-1].timestamp\n                st[len(st)-1].timestamp = timestamp\n            }\n            st = append(st, pair{idx, timestamp})\n        } else {\n            p := st[len(st)-1]\n            st = st[:len(st)-1]\n            ans[p.idx] += timestamp - p.timestamp + 1\n            if len(st) > 0 {\n                st[len(st)-1].timestamp = timestamp + 1\n            }\n        }\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为全部日志 $\\textit{logs}$ 的数量，$n$ 条日志信息对应总共 $n$ 次入栈和出栈操作。\n- 空间复杂度：$O(n)$，其中 $n$ 为全部日志 $\\textit{logs}$ 的数量，$n$ 条日志信息对应 $\\frac{n}{2}$ 次入栈操作，最坏的情况下全部 $\\frac{n}{2}$ 条日志入栈后才会依次弹栈。"
}