{
	"titleSlug": "bst-sequences-lcci",
	"slug": "mei-yi-ge-jie-dian-du-bi-xu-pai-zai-ta-d-n679",
	"url": "https://leetcode-cn.com/problems/bst-sequences-lcci/solution/mei-yi-ge-jie-dian-du-bi-xu-pai-zai-ta-d-n679/",
	"content": "### 解题思路\n这个题翻译成人话就只有这一句：\n## 「每一个节点都必须排在它的子孙结点前面」\n比如针对这棵二叉树，数组第一个元素一定是 [12] ，然后因为「每一个节点都必须排在它的子孙结点前面」，所以前两个元素只有两种情况 [12,5]、[12,19]。\n同理，如果前两个元素是 [12,5] ，那么第三个元素一定是 2 或者 9 或者 19（注意这里 19 的情况不要忘了），当然 19 的子树是不能取的，因为根节点 19 还没加入数组；\n如果前两个元素是[12,19]，那么第三个元素一定是 5 或者 15 \n所以数组前三个元素可以确定只有 [12,5,2],[12,5,9],[12,5,19],[12,19,5],[12,19,15]……\n![image.png](https://pic.leetcode-cn.com/1626346850-vldzyn-image.png)\n## 那么这个思路用代码怎么写呢？\n对于这种找出所有情况的题目，回溯法是最容易想到的方法之一了，这道题也可以用回溯法，可以发现刚才选元素的过程和层序遍历的过程其实是一致的：\n- 最开始 queue 中只有 12 ，只能选12，将 12 出队并将它的两个子节点入队，得到 [12]；\n- 选了12之后 queue 中剩下 5、19 ，就从 5 和 19 中选一个，得到 [12,5],[12,19]；\n    - 如果选了 5 ，将 5 出队并将它的两个子节点入队，那么此时 queue 中剩下 19、2、9，得到 [12,5,2],[12,5,9],[12,5,19]；\n    - 如果选了 19 ，将 19 出队并将它的子节点入队，那么此时 queue 中剩下 5、15，得到 [12,19,5],[12,19,15]；\n后续同理。\n\n\n### 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private List<List<Integer>> ans;\n\n    public List<List<Integer>> BSTSequences(TreeNode root) {\n        ans = new ArrayList<>();\n        List<Integer> path = new ArrayList<>();\n        // 如果 root==null 返回 [[]]\n        if (root == null) {\n            ans.add(path);\n            return ans;\n        }\n        List<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        // 开始进行回溯\n        bfs(queue, path);\n        return ans;\n    }\n\n    /**\n     * 回溯法+广度优先遍历.\n     */\n    private void bfs(List<TreeNode> queue, List<Integer> path) {\n        // queue 为空说明遍历完了，可以返回了\n        if (queue.isEmpty()) {\n            ans.add(new ArrayList<>(path));\n            return;\n        }\n        // 将 queue 拷贝一份，用于稍后回溯\n        List<TreeNode> copy = new ArrayList<>(queue);\n        // 对 queue 进行循环，每循环考虑 “是否 「将当前 cur 节点从 queue 中取出并将其左右子\n        // 节点加入 queue ，然后将 cur.val 加入到 path 末尾」 ” 的情况进行回溯\n        for (int i = 0; i < queue.size(); i++) {\n            TreeNode cur = queue.get(i);\n            path.add(cur.val);\n            queue.remove(i);\n            // 将左右子节点加入队列\n            if (cur.left != null) queue.add(cur.left);\n            if (cur.right != null) queue.add(cur.right);\n            bfs(queue, path);\n            // 恢复 path 和 queue ，进行回溯\n            path.remove(path.size() - 1);\n            queue = new ArrayList<>(copy);\n        }\n    }\n}\n```"
}