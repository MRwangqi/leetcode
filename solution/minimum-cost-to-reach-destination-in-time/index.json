{
	"titleSlug": "minimum-cost-to-reach-destination-in-time",
	"slug": "gui-ding-shi-jian-nei-dao-da-zhong-dian-n3ews",
	"url": "https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time/solution/gui-ding-shi-jian-nei-dao-da-zhong-dian-n3ews/",
	"content": "#### 方法一：动态规划\n\n**思路与算法**\n\n我们用 $f[t][i]$ 表示**使用恰好** $t$ 分钟到达城市 $i$ 需要的**最少**通行费总和。\n\n在状态转移时，我们考虑最后一次通行是从城市 $j$ 到达城市 $i$ 的，那么有状态转移方程：\n\n$$\nf[t][i] = \\min_{(j, i) \\in E} \\big\\{ f[t-\\textit{cost}(j, i)][j] + \\textit{passingFees}[i] \\big\\}\n$$\n\n其中 $(j, i) \\in E$ 表示城市 $j$ 与 $i$ 存在一条道路，$\\textit{cost}(j, i)$ 表示这条道路的耗费时间。\n\n最终的答案即为 $f[1][n-1], f[2][n-1], \\cdots, f[\\textit{maxTime}][n-1]$ 中的最小值。\n\n**细节**\n\n初始状态为 $f[0][0] = \\textit{passingFees}[0]$，即我们一开始位于 $0$ 号城市，需要交 $\\textit{passingFees}[0]$ 的通行费。\n\n由于我们的状态转移方程中的目标的最小值，因此对于其它的状态，我们可以在一开始赋予它们一个极大值 $\\infty$。如果最终的答案为 $\\infty$，说明无法在 $\\textit{maxTime}$ 及以内完成旅行，返回 $-1$。\n\n此外，本题中的道路是以数组 $\\textit{edges}$ 的形式给定的，在动态规划的过程中，如果我们使用两重循环枚举 $t$ 和 $i$，就不能利用 $\\textit{edges}$，而需要使用额外的数据结构存储以 $i$ 为端点的所有道路。一种合理的解决方法是，我们使用一重循环枚举 $t$，另一重循环枚举 $\\textit{edges}$ 中的每一条边 $(i, j, \\textit{cost})$，通过这条边更新 $f[t][i]$ 以及 $f[t][j]$ 的值。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    // 极大值\n    static constexpr int INFTY = INT_MAX / 2;\n\npublic:\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\n        int n = passingFees.size();\n        vector<vector<int>> f(maxTime + 1, vector<int>(n, INFTY));\n        f[0][0] = passingFees[0];\n        for (int t = 1; t <= maxTime; ++t) {\n            for (const auto& edge: edges) {\n                int i = edge[0], j = edge[1], cost = edge[2];\n                if (cost <= t) {\n                    f[t][i] = min(f[t][i], f[t - cost][j] + passingFees[i]);\n                    f[t][j] = min(f[t][j], f[t - cost][i] + passingFees[j]);\n                }\n            }\n        }\n\n        int ans = INFTY;\n        for (int t = 1; t <= maxTime; ++t) {\n            ans = min(ans, f[t][n - 1]);\n        }\n        return ans == INFTY ? -1 : ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n        n = len(passingFees)\n        f = [[float(\"inf\")] * n for _ in range(maxTime + 1)]\n        f[0][0] = passingFees[0]\n        for t in range(1, maxTime + 1):\n            for i, j, cost in edges:\n                if cost <= t:\n                    f[t][i] = min(f[t][i], f[t - cost][j] + passingFees[i])\n                    f[t][j] = min(f[t][j], f[t - cost][i] + passingFees[j])\n\n        ans = min(f[t][n - 1] for t in range(1, maxTime + 1))\n        return -1 if ans == float(\"inf\") else ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O((n+m) \\cdot \\textit{maxTimes})$，其中 $m$ 是数组 $\\textit{edges}$ 的长度。\n\n    - 我们需要 $O(n \\cdot \\textit{maxTimes})$ 的时间初始化数组 $f$；\n\n    - 动态规划需要的时间为 $O(m \\cdot \\textit{maxTimes})$。\n\n- 空间复杂度：$O(n \\cdot \\textit{maxTimes})$。"
}