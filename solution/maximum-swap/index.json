{
	"titleSlug": "maximum-swap",
	"slug": "zui-da-jiao-huan-by-leetcode-solution-lnd5",
	"url": "https://leetcode-cn.com/problems/maximum-swap/solution/zui-da-jiao-huan-by-leetcode-solution-lnd5/",
	"content": "#### 方法一：直接遍历\n\n由于对于整数 $\\textit{num}$ 的十进制数字位长最长为 $8$ 位，任意两个数字交换一次最多有 $28$ 种不同的交换方法，因此我们可以尝试遍历所有可能的数字交换方法即可，并找到交换后的最大数字即可。\n+ 我们将数字存储为长度为 $n$ 的列表，其中 $n$ 为整数 $\\textit{num}$ 的十进制位数的长度。对于位置为 $\\text{(i, j)}$ 的每个候选交换，我们交换数字并记录组成的新数字是否大于当前答案；\n+ 对于前导零的问题，我们也不需要特殊处理。\n+ 由于数字只有 $8$ 位，所以我们不必考虑交换后溢出的风险；\n\n```Python [sol1-Python3]\nclass Solution:\n    def maximumSwap(self, num: int) -> int:\n        ans = num\n        s = list(str(num))\n        for i in range(len(s)):\n            for j in range(i):\n                s[i], s[j] = s[j], s[i]\n                ans = max(ans, int(''.join(s)))\n                s[i], s[j] = s[j], s[i]\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maximumSwap(int num) {\n        string charArray = to_string(num);\n        int n = charArray.size();\n        int maxNum = num;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                swap(charArray[i], charArray[j]);\n                maxNum = max(maxNum, stoi(charArray));\n                swap(charArray[i], charArray[j]);\n            }\n        }\n        return maxNum;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maximumSwap(int num) {\n        char[] charArray = String.valueOf(num).toCharArray();\n        int n = charArray.length;\n        int maxNum = num;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                swap(charArray, i, j);\n                maxNum = Math.max(maxNum, Integer.parseInt(new String(charArray)));\n                swap(charArray, i, j);\n            }\n        }\n        return maxNum;\n    }\n\n    public void swap(char[] charArray, int i, int j) {\n        char temp = charArray[i];\n        charArray[i] = charArray[j];\n        charArray[j] = temp;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MaximumSwap(int num) {\n        char[] charArray = num.ToString().ToCharArray();\n        int n = charArray.Length;\n        int maxNum = num;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                Swap(charArray, i, j);\n                maxNum = Math.Max(maxNum, int.Parse(new string(charArray)));\n                Swap(charArray, i, j);\n            }\n        }\n        return maxNum;\n    }\n\n    public void Swap(char[] charArray, int i, int j) {\n        char temp = charArray[i];\n        charArray[i] = charArray[j];\n        charArray[j] = temp;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MAX_LEN 32\n\nstatic inline void swap(char* a, char* b) {\n    char c = *a;\n    *a = *b;\n    *b = c;\n}\n\nint maximumSwap(int num) {\n    char charArray[MAX_LEN];\n    sprintf(charArray, \"%d\", num);\n    int n = strlen(charArray);\n    int maxNum = num;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            swap(&charArray[i], &charArray[j]);\n            maxNum = MAX(maxNum, atoi(charArray));\n            swap(&charArray[i], &charArray[j]);\n        }\n    }\n    return maxNum;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maximumSwap = function(num) {\n    const charArray = [...'' + num];\n    const n = charArray.length;\n    let maxNum = num;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            swap(charArray, i, j);\n            maxNum = Math.max(maxNum, parseInt(charArray.join('')));\n            swap(charArray, i, j);\n        }\n    }\n    return maxNum;\n}\n\nconst swap = (charArray, i, j) => {\n    const temp = charArray[i];\n    charArray[i] = charArray[j];\n    charArray[j] = temp;\n};\n```\n\n```go [sol1-Golang]\nfunc maximumSwap(num int) int {\n    ans := num\n    s := []byte(strconv.Itoa(num))\n    for i := range s {\n        for j := range s[:i] {\n            s[i], s[j] = s[j], s[i]\n            v, _ := strconv.Atoi(string(s))\n            ans = max(ans, v)\n            s[i], s[j] = s[j], s[i]\n        }\n    }\n    return ans\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log^3 \\textit{num})$，其中整数 $\\textit{num}$ 为给定的数字。$\\textit{num}$ 转换为十进制数，有 $O(\\log \\textit{num})$ 个数字，一共有 $O(\\log^2 \\textit{num})$ 种不同的交换方法，每种方法需要重新构造一个新的整数，需要的时间为 $O(\\log \\textit{num})$，因此总的时间复杂度为 $O(\\log^3 \\textit{num})$。\n\n- 空间复杂度：$O(\\log \\textit{num})$，其中整数 $\\textit{num}$ 为给定的数字。$\\textit{num}$ 转换为十进制数，有 $O(\\log \\textit{num})$ 个数字，需要保存 $\\textit{num}$ 所有的数字。\n\n#### 方法二：贪心\n\n设整数 $\\text{num}$ 从右向左的数字分别为 $(d_0, d_1, d_2, \\cdots, d_{n-1})$，则此时我们可以知道: $\\textit{num} = \\sum_{i=0}^{n-1} d_{i} \\times 10^{i}$，假设我们对位于 $j, k$ 位上的数字进行交换，其中满足 $0 \\le j < k < n$，则可以知道交换后的值 $\\text{val}$ 如下:\n$$\n\\text{val} = \\sum_{i=0}^{n-1} (d_{i} \\times 10^{i}) + (d_j - d_k) \\times 10 ^ k - (d_j - d_k) \\times 10 ^ j \\\\\n= \\sum_{i=0}^{n-1} (d_{i} \\times 10^{i}) + (d_j - d_k) \\times (10 ^ k  - 10 ^ j)\n$$\n根据以上等式我们可以看出，若使得 $\\textit{val}$ 的值最大，应依次满足如下条件：\n+ 最优的交换一定需要满足 $d_j > d_k$；\n+ 在满足 $d_j > d_k$ 时，应该保证索引 $k$ 越大从而使得数字 $\\textit{val}$ 越大；\n+ 在同样大小的数字 $d_k$ 时，应使得数字 $d_j$ 越大从而使得 $\\textit{val}$ 越大；\n+ 在同样大小的数字 $d_j$ 时，应使得索引 $j$ 越小从而使得 $\\textit{val}$ 越大；\n\n通过以上可以观察到右边越大的数字与左边较小的数字进行交换，这样产生的整数才能保证越大。因此我们可以利用贪心法则，尝试将数字中右边较大的数字与左边较小的数字进行交换，这样即可保证得到的整数值最大。具体做法如下：\n+ 我们将从右向左扫描数字数组，并记录当前已经扫描过的数字的最大值的索引为 $\\textit{maxId}$ 且保证 $\\textit{maxId}$ 越靠近数字的右侧，此时则说明 $\\textit{charArray}[\\textit{maxId}]$ 则为当前已经扫描过的最大值。\n+ 如果检测到当前数字 $\\textit{charArray}[i] < \\textit{charArray}[\\textit{maxId}]$，此时则说明索引 $i$ 的右侧的数字最大值为 $\\textit{charArray}[\\textit{maxId}]$，此时我们可以尝试将 $\\textit{charArray}[i]$ 与 $\\textit{charArray}[\\textit{maxId}]$ 进行交换即可得到一个比 $\\textit{num}$ 更大的值。我们尝试记录当前可以交换的数对 $(i, \\textit{maxId})$，根据贪心法则，此时最左边的 $i$ 构成的可交换的数对进行交换后形成的整数值最大。\n\n```Python [sol2-Python3]\nclass Solution:\n    def maximumSwap(self, num: int) -> int:\n        s = list(str(num))\n        n = len(s)\n        maxIdx = n - 1\n        idx1 = idx2 = -1\n        for i in range(n - 1, -1, -1):\n            if s[i] > s[maxIdx]:\n                maxIdx = i\n            elif s[i] < s[maxIdx]:\n                idx1, idx2 = i, maxIdx\n        if idx1 < 0:\n            return num\n        s[idx1], s[idx2] = s[idx2], s[idx1]\n        return int(''.join(s))\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int maximumSwap(int num) {\n        string charArray = to_string(num);\n        int n = charArray.size();\n        int maxIdx = n - 1;\n        int idx1 = -1, idx2 = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (charArray[i] > charArray[maxIdx]) {\n                maxIdx = i;\n            } else if (charArray[i] < charArray[maxIdx]) {\n                idx1 = i;\n                idx2 = maxIdx;\n            }\n        }\n        if (idx1 >= 0) {\n            swap(charArray[idx1], charArray[idx2]);\n            return stoi(charArray);\n        } else {\n            return num;\n        }\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int maximumSwap(int num) {\n        char[] charArray = String.valueOf(num).toCharArray();\n        int n = charArray.length;\n        int maxIdx = n - 1;\n        int idx1 = -1, idx2 = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (charArray[i] > charArray[maxIdx]) {\n                maxIdx = i;\n            } else if (charArray[i] < charArray[maxIdx]) {\n                idx1 = i;\n                idx2 = maxIdx;\n            }\n        }\n        if (idx1 >= 0) {\n            swap(charArray, idx1, idx2);\n            return Integer.parseInt(new String(charArray));\n        } else {\n            return num;\n        }\n    }\n\n    public void swap(char[] charArray, int i, int j) {\n        char temp = charArray[i];\n        charArray[i] = charArray[j];\n        charArray[j] = temp;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int MaximumSwap(int num) {\n        char[] charArray = num.ToString().ToCharArray();\n        int n = charArray.Length;\n        int maxIdx = n - 1;\n        int idx1 = -1, idx2 = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (charArray[i] > charArray[maxIdx]) {\n                maxIdx = i;\n            } else if (charArray[i] < charArray[maxIdx]) {\n                idx1 = i;\n                idx2 = maxIdx;\n            }\n        }\n        if (idx1 >= 0) {\n            Swap(charArray, idx1, idx2);\n            return int.Parse(new string(charArray));\n        } else {\n            return num;\n        }\n    }\n\n    public void Swap(char[] charArray, int i, int j) {\n        char temp = charArray[i];\n        charArray[i] = charArray[j];\n        charArray[j] = temp;\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX_LEN 32\n\nstatic inline void swap(char* a, char* b) {\n    char c = *a;\n    *a = *b;\n    *b = c;\n}\n\nint maximumSwap(int num) {\n    char charArray[MAX_LEN];\n    sprintf(charArray, \"%d\", num);\n    int n = strlen(charArray);\n    char maxIdx = n - 1;\n    int idx1 = -1, idx2 = -1;\n    for (int i = n - 1; i >= 0; i--) {\n        if (charArray[i] > charArray[maxIdx]) {\n            maxIdx = i;\n        } else if (charArray[i] < charArray[maxIdx]) {\n            idx1 = i;\n            idx2 = maxIdx;\n        }\n    }\n    if (idx1 >= 0) {\n        swap(&charArray[idx1], &charArray[idx2]);\n        return atoi(charArray);\n    } else {\n        return num;\n    }\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar maximumSwap = function(num) {\n    const charArray = [...'' + num];\n    const n = charArray.length;\n    let maxIdx = n - 1;\n    let idx1 = -1, idx2 = -1;\n    for (let i = n - 1; i >= 0; i--) {\n        if (charArray[i] > charArray[maxIdx]) {\n            maxIdx = i;\n        } else if (charArray[i] < charArray[maxIdx]) {\n            idx1 = i;\n            idx2 = maxIdx;\n        }\n    }\n    if (idx1 >= 0) {\n        swap(charArray, idx1, idx2);\n        return parseInt(charArray.join(''));\n    } else {\n        return num;\n    }\n}\n\nconst swap = (charArray, i, j) => {\n    const temp = charArray[i];\n    charArray[i] = charArray[j];\n    charArray[j] = temp;\n};\n```\n\n```go [sol2-Golang]\nfunc maximumSwap(num int) int {\n    s := []byte(strconv.Itoa(num))\n    n := len(s)\n    maxIdx, idx1, idx2 := n-1, -1, -1\n    for i := n - 1; i >= 0; i-- {\n        if s[i] > s[maxIdx] {\n            maxIdx = i\n        } else if s[i] < s[maxIdx] {\n            idx1, idx2 = i, maxIdx\n        }\n    }\n    if idx1 < 0 {\n        return num\n    }\n    s[idx1], s[idx2] = s[idx2], s[idx1]\n    v, _ := strconv.Atoi(string(s))\n    return v\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log \\textit{num})$，其中整数 $\\textit{num}$ 为给定的数字。$\\textit{num}$ 转换为十进制数，有 $O(\\log \\textit{num})$ 个数字，需要遍历一次所有的数字即可。\n\n- 空间复杂度：$O(\\log \\textit{num})$，其中整数 $\\textit{num}$ 为给定的数字。$\\textit{num}$ 转换为十进制数，有 $O(\\log \\textit{num})$ 个数字，需要保存 $\\textit{num}$ 所有的数字。"
}