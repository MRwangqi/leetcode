{
	"titleSlug": "number-of-ways-to-split-array",
	"slug": "fen-ge-shu-zu-de-fang-an-shu-by-leetcode-3ygv",
	"url": "https://leetcode-cn.com/problems/number-of-ways-to-split-array/solution/fen-ge-shu-zu-de-fang-an-shu-by-leetcode-3ygv/",
	"content": "#### 方法一：枚举 + 前缀和\n\n**思路与算法**\n\n我们只需要枚举所有的分割位置，并找出其中的合法分割即可。\n\n具体地，我们用 $\\textit{left}$ 和 $\\textit{right}$ 分别表示分割左侧和右侧的所有元素之和。初始时，$\\textit{left} = 0$，$\\textit{right}$ 的值为给定数组 $\\textit{nums}$ 的所有元素之和。我们从小到大依次枚举每一个分割位置，当枚举到位置 $i$ 时，我们将 $\\textit{left}$ 加上 $\\textit{nums}[i]$，并将 $\\textit{right}$ 减去 $\\textit{nums}[i]$，这样就可以实时正确地维护分割左侧和右侧的元素之和。如果 $\\textit{left} \\geq \\textit{right}$，那么就找出了一个合法分割。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int waysToSplitArray(vector<int>& nums) {\n        int n = nums.size();\n        long long left = 0, right = accumulate(nums.begin(), nums.end(), 0LL);\n        int ans = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            left += nums[i];\n            right -= nums[i];\n            if (left >= right) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n, left, right = len(nums), 0, sum(nums)\n        ans = 0\n        for i in range(n - 1):\n            left += nums[i]\n            right -= nums[i]\n            if left >= right:\n                ans += 1\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。\n\n- 空间复杂度：$O(1)$。"
}