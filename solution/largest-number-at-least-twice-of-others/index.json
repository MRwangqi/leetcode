{
	"titleSlug": "largest-number-at-least-twice-of-others",
	"slug": "zhi-shao-shi-qi-ta-shu-zi-liang-bei-de-z-985m",
	"url": "https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/solution/zhi-shao-shi-qi-ta-shu-zi-liang-bei-de-z-985m/",
	"content": "#### 方法一：遍历\n\n**思路与算法**\n\n遍历数组分别找到数组的最大值 $m_1$ 和次大值 $m_2$。如果 $m_1 \\ge m_2 \\times 2$ 成立，则最大值至少是数组其余数字的两倍，此时返回最大值的下标，否则返回 $-1$。\n\n为了返回最大值的下标，我们需要在计算最大值的同时记录最大值的下标。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int dominantIndex(vector<int>& nums) {\n        int m1 = -1, m2 = -1;\n        int index = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] > m1) {\n                m2 = m1;\n                m1 = nums[i];\n                index = i;\n            } else if (nums[i] > m2) {\n                m2 = nums[i];\n            }\n        }\n        return m1 >= m2 * 2 ? index : -1;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int dominantIndex(int[] nums) {\n        int m1 = -1, m2 = -1;\n        int index = -1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > m1) {\n                m2 = m1;\n                m1 = nums[i];\n                index = i;\n            } else if (nums[i] > m2) {\n                m2 = nums[i];\n            }\n        }\n        return m1 >= m2 * 2 ? index : -1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int DominantIndex(int[] nums) {\n        int m1 = -1, m2 = -1;\n        int index = -1;\n        for (int i = 0; i < nums.Length; i++) {\n            if (nums[i] > m1) {\n                m2 = m1;\n                m1 = nums[i];\n                index = i;\n            } else if (nums[i] > m2) {\n                m2 = nums[i];\n            }\n        }\n        return m1 >= m2 * 2 ? index : -1;\n    }\n}\n```\n\n```C [sol1-C]\nint dominantIndex(int* nums, int numsSize) {\n    int m1 = -1, m2 = -1;\n    int index = -1;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] > m1) {\n            m2 = m1;\n            m1 = nums[i];\n            index = i;\n        } else if (nums[i] > m2) {\n            m2 = nums[i];\n        }\n    }\n    return m1 >= m2 * 2 ? index : -1;\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def dominantIndex(self, nums: List[int]) -> int:\n        m1, m2, idx = -1, -1, 0\n        for i, num in enumerate(nums):\n            if num > m1:\n                m1, m2, idx = num, m1, i\n            elif num > m2:\n                m2 = num\n        return idx if m1 >= m2 * 2 else -1\n```\n\n```go [sol1-Golang]\nfunc dominantIndex(nums []int) int {\n    m1, m2, idx := -1, -1, 0\n    for i, num := range nums {\n        if num > m1 {\n            m1, m2, idx = num, m1, i\n        } else if num > m2 {\n            m2 = num\n        }\n    }\n    if m1 >= m2*2 {\n        return idx\n    }\n    return -1\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar dominantIndex = function(nums) {\n    let m1 = -1, m2 = -1;\n    let index = -1;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > m1) {\n            m2 = m1;\n            m1 = nums[i];\n            index = i;\n        } else if (nums[i] > m2) {\n            m2 = nums[i];\n        }\n    }\n    return m1 >= m2 * 2 ? index : -1;\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(N)$，其中 $N$ 是数组的长度。遍历整个数组需要 $O(N)$。\n\n+ 空间复杂度：$O(1)$。"
}