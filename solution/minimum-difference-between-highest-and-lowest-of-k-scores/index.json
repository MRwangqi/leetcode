{
	"titleSlug": "minimum-difference-between-highest-and-lowest-of-k-scores",
	"slug": "xue-sheng-fen-shu-de-zui-xiao-chai-zhi-b-oodu",
	"url": "https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/solution/xue-sheng-fen-shu-de-zui-xiao-chai-zhi-b-oodu/",
	"content": "#### 方法一：排序\n\n**思路与算法**\n\n要想**最小化**选择的 $k$ 名学生中最高分和最低分的差值，我们一定是在排好序后的数组中**连续**地进行选择。这是因为在选择时，如果跳过了某个下标 $i$，那么在选择完毕后，将其中的最高分替换成 $\\textit{nums}[i]$，最高分一定不会变大，与最低分的差值同样也不会变大。因此，一定存在有一种最优的选择方案，是连续选择了有序数组中的 $k$ 个连续的元素。\n\n这样一来，我们首先对数组 $\\textit{nums}$ 进行升序排序，随后使用一个大小固定为 $k$ 的滑动窗口在 $\\textit{nums}$ 上进行遍历。记滑动窗口的左边界为 $i$，那么右边界即为 $i+k-1$，窗口中的 $k$ 名学生最高分和最低分的差值即为 $\\textit{nums}[i+k-1] - \\textit{nums}[i]$。\n\n最终的答案即为所有 $\\textit{nums}[i+k-1] - \\textit{nums}[i]$ 中的最小值。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        int ans = INT_MAX;\n        for (int i = 0; i + k - 1 < n; ++i) {\n            ans = min(ans, nums[i + k - 1] - nums[i]);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minimumDifference(int[] nums, int k) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i + k - 1 < n; ++i) {\n            ans = Math.min(ans, nums[i + k - 1] - nums[i]);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinimumDifference(int[] nums, int k) {\n        int n = nums.Length;\n        Array.Sort(nums);\n        int ans = int.MaxValue;\n        for (int i = 0; i + k - 1 < n; ++i) {\n            ans = Math.Min(ans, nums[i + k - 1] - nums[i]);\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        return min(nums[i + k - 1] - nums[i] for i in range(len(nums) - k + 1))\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint cmp(const void * pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint minimumDifference(int* nums, int numsSize, int k){\n    qsort(nums, numsSize, sizeof(int), cmp);\n    int ans = INT_MAX;\n    for (int i = 0; i + k - 1 < numsSize; ++i) {\n        ans = MIN(ans, nums[i + k - 1] - nums[i]);\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minimumDifference = function(nums, k) {\n    const n = nums.length;\n    nums.sort((a, b) => a - b);\n    let ans = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < n - k + 1; i++) {\n        ans = Math.min(ans, nums[i + k - 1] - nums[i]);\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc minimumDifference(nums []int, k int) int {\n    sort.Ints(nums)\n    ans := math.MaxInt32\n    for i, num := range nums[:len(nums)-k+1] {\n        ans = min(ans, nums[i+k-1]-num)\n    }\n    return ans\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。排序需要的时间为 $O(n \\log n)$，后续遍历需要的时间为 $O(n)$。\n\n- 空间复杂度：$O(\\log n)$，即为排序需要使用的栈空间。"
}