{
	"titleSlug": "numbers-at-most-n-given-digit-set",
	"slug": "zui-da-wei-n-de-shu-zi-zu-he-by-leetcode-f3yi",
	"url": "https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set/solution/zui-da-wei-n-de-shu-zi-zu-he-by-leetcode-f3yi/",
	"content": "#### 方法一：数位动态规划\n\n本题为典型的数位动态规划题目，可以阅读「[数位 DP](https://oi-wiki.org/dp/number/)」详细了解。我们称满足 $x \\le n$ 且仅包含 $\\textit{digits}$ 中出现的数字的 $x$ 为合法的，则本题需要找出所有合法的 $x$ 的个数。\n\n设 $n$ 是一个十进制的 $k$ 位数，所有数字位数小于 $k$ 且由 $\\textit{digits}$ 组成的数字则一定是小于 $n$ 的。我们用 $\\textit{dp}[i][0]$ 表示由 $\\textit{digits}$ 构成且 $n$ 的前 $i$ 位的数字的个数，$dp[i][1]$ 表示由 $\\textit{digits}$ 构成且等于 $n$ 的前 $i$ 位的数字的个数，可知 $\\textit{dp}[i][1]$ 的取值只能为 $0$ 和 $1$。\n\n例如：$n = 2345, \\textit{digits} = \\text{[``1\",``2\",``3\",``4\"]}$。\n\n则 $\\textit{dp}[1][0], \\textit{dp}[2][0], \\textit{dp}[3][0], \\textit{dp}[4][0]$ 分别表示小于 $2, 23, 234, 2345$ 的合法数的个数，$\\textit{dp}[1][1], \\textit{dp}[2][1], \\textit{dp}[3][1], \\textit{dp}[4][1]$ 分别表示等于 $2, 23, 234, 2345$ 的合法数的个数。\n\n设 $\\textit{digits}$ 中的字符数目为 $m$ 个，数字 $n$ 的前 $j$ 位构成的数字为 $\\textit{num}[j]$，数字 $n$ 的第 $j$ 个字符为 $s[j]$，当遍历到 $n$ 的第 $i$ 位时：\n\n+ 当满足 $i > 1$ 时，此时任意数字 $d$ 构成的数字一定满足 $d < \\textit{num}[i]$；\n\n+ 设数字 $a < \\textit{num}[i-1]$，则此时在 $a$ 的末尾追加一个数字 $d$ 构成的数为 $a \\times 10 + d$，此时可以知道 $d$ 取 $0,1,\\cdots,9$ 中任意数字均满足小于 $a \\times 10 + d < \\textit{num}[i] = \\textit{num}[i-1] \\times 10 + s[i]$；\n\n+ 设数字 $a = \\textit{num}[i-1]$，则此时在 $a$ 的末尾追加一个数字 $d$ 构成的数为 $a \\times 10 + d$，此时可以知道 $d < s[i]$ 时，才能满足 $a \\times 10 + d < \\textit{num}[i] = \\textit{num}[i-1] \\times 10 + s[i]$；\n\n+ 初始化时令 $\\textit{dp}[0][1] = 1$，如果前 $i$ 位中存在某一位 $j$ ，对于任意数字 $d$ 均不能满足 $d = s[j]$，则此时 $\\textit{dp}[i][1] = 0$；\n \n根据上述描述从小到到计算 $dp$，设 $C[i]$ 表示数组 $\\textit{digits}$ 中小于 $n$ 的第 $i$ 位数字的元素个数，则状态转移方程为：\n\n$$\ndp[i][0] =\n\\begin{cases}\nC[i], & i = 1 \\\\\nm + dp[i-1][0] \\times m + dp[i-1][1] \\times C[i], & i > 1 \\\\\n\\end{cases}\n$$\n\n我们计算出前 $k$ 位小于 $n$ 的数字的个数 $\\textit{dp}[k][0]$，前 $k$ 位等于 $n$ 的数字的个数 $\\textit{dp}[k][1]$，最终的答案为 $\\textit{dp}[k][0] + \\textit{dp}[k][1]$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        m = len(digits)\n        s = str(n)\n        k = len(s)\n        dp = [[0, 0] for _ in range(k + 1)]\n        dp[0][1] = 1\n        for i in range(1, k + 1):\n            for d in digits:\n                if d == s[i - 1]:\n                    dp[i][1] = dp[i - 1][1]\n                elif d < s[i - 1]:\n                    dp[i][0] += dp[i - 1][1]\n                else:\n                    break\n            if i > 1:\n                dp[i][0] += m + dp[i - 1][0] * m\n        return sum(dp[k])\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int atMostNGivenDigitSet(vector<string>& digits, int n) {\n        string s = to_string(n);\n        int m = digits.size(), k = s.size();\n        vector<vector<int>> dp(k + 1, vector<int>(2));\n        dp[0][1] = 1;\n        for (int i = 1; i <= k; i++) {\n            for (int j = 0; j < m; j++) {\n                if (digits[j][0] == s[i - 1]) {\n                    dp[i][1] = dp[i - 1][1];\n                } else if (digits[j][0] < s[i - 1]) {\n                    dp[i][0] += dp[i - 1][1];\n                } else {\n                    break;\n                }\n            }\n            if (i > 1) {\n                dp[i][0] += m + dp[i - 1][0] * m;\n            }\n        }\n        return dp[k][0] + dp[k][1];\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int atMostNGivenDigitSet(String[] digits, int n) {\n        String s = Integer.toString(n);\n        int m = digits.length, k = s.length();\n        int[][] dp = new int[k + 1][2];\n        dp[0][1] = 1;\n        for (int i = 1; i <= k; i++) {\n            for (int j = 0; j < m; j++) {\n                if (digits[j].charAt(0) == s.charAt(i - 1)) {\n                    dp[i][1] = dp[i - 1][1];\n                } else if (digits[j].charAt(0) < s.charAt(i - 1)) {\n                    dp[i][0] += dp[i - 1][1];\n                } else {\n                    break;\n                }\n            }\n            if (i > 1) {\n                dp[i][0] += m + dp[i - 1][0] * m;\n            }\n        }\n        return dp[k][0] + dp[k][1];\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int AtMostNGivenDigitSet(string[] digits, int n) {\n        string s = n.ToString();\n        int m = digits.Length, k = s.Length;\n        int[][] dp = new int[k + 1][];\n        for (int i = 0; i <= k; i++) {\n            dp[i] = new int[2];\n        }\n        dp[0][1] = 1;\n        for (int i = 1; i <= k; i++) {\n            for (int j = 0; j < m; j++) {\n                if (digits[j][0] == s[i - 1]) {\n                    dp[i][1] = dp[i - 1][1];\n                } else if (digits[j][0] < s[i - 1]) {\n                    dp[i][0] += dp[i - 1][1];\n                } else {\n                    break;\n                }\n            }\n            if (i > 1) {\n                dp[i][0] += m + dp[i - 1][0] * m;\n            }\n        }\n        return dp[k][0] + dp[k][1];\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX_STR_LEN 32\n\nint atMostNGivenDigitSet(char ** digits, int digitsSize, int n) {\n    char s[MAX_STR_LEN];\n    sprintf(s, \"%d\", n);\n    int m = digitsSize, k = strlen(s);\n    int dp[MAX_STR_LEN][2];\n    memset(dp, 0, sizeof(dp));\n    dp[0][1] = 1;\n    for (int i = 1; i <= k; i++) {\n        for (int j = 0; j < m; j++) {\n            if (digits[j][0] == s[i - 1]) {\n                dp[i][1] = dp[i - 1][1];\n            } else if (digits[j][0] < s[i - 1]) {\n                dp[i][0] += dp[i - 1][1];\n            } else {\n                break;\n            }\n        }\n        if (i > 1) {\n            dp[i][0] += m + dp[i - 1][0] * m;\n        }\n    }\n    return dp[k][0] + dp[k][1];\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar atMostNGivenDigitSet = function(digits, n) {\n    const s = '' + n;\n    const m = digits.length, k = s.length;\n    const dp = new Array(k + 1).fill(0).map(() => new Array(2).fill(0));\n    dp[0][1] = 1;\n    for (let i = 1; i <= k; i++) {\n        for (let j = 0; j < m; j++) {\n            if (digits[j][0] === s[i - 1]) {\n                dp[i][1] = dp[i - 1][1];\n            } else if (digits[j][0] < s[i - 1]) {\n                dp[i][0] += dp[i - 1][1];\n            } else {\n                break;\n            }\n        }\n        if (i > 1) {\n            dp[i][0] += m + dp[i - 1][0] * m;\n        }\n    }\n    return dp[k][0] + dp[k][1];\n};\n```\n\n```go [sol1-Golang]\nfunc atMostNGivenDigitSet(digits []string, n int) int {\n    m := len(digits)\n    s := strconv.Itoa(n)\n    k := len(s)\n    dp := make([][2]int, k+1)\n    dp[0][1] = 1\n    for i := 1; i <= k; i++ {\n        for _, d := range digits {\n            if d[0] == s[i-1] {\n                dp[i][1] = dp[i-1][1]\n            } else if d[0] < s[i-1] {\n                dp[i][0] += dp[i-1][1]\n            } else {\n                break\n            }\n        }\n        if i > 1 {\n            dp[i][0] += m + dp[i-1][0]*m\n        }\n    }\n    return dp[k][0] + dp[k][1]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n \\times k)$，其中 $n$ 为给定数字，$k$ 表示给定的数字的种类。需要遍历 $n$ 的所有数位的数字，$n$ 含有的数字个数为 $\\log_{10}n$，检测每一位时都需要遍历一遍给定的数字，因此总的时间复杂度为 $O(\\log n \\times k)$。\n\n- 空间复杂度：$O(\\log n)$，其中 $n$ 为给定数字。需要需要保存每一位上可能数字的组合数目，因此需要的空间复杂度为 $O(\\log n)$。\n\n#### 方法二：数学\n\n**细节**\n\n我们令 $m = |\\textit{digits}|$，根据题意可知一个合法的数仅包含 $\\textit{digits}$ 中的数字，如果我们把 $\\textit{digits}$ 中数字从小到大映射为 $[1,2,\\cdots,m]$，此时我们可以很方便的进行计算。例如，当 $\\textit{digits}$ 包含 $[1, 3, 5, 7]$ 时，我们将它映射为 $[1, 2, 3, 4]$，那么合法的数也从 $[1, 3, 5, 7, 11, 13, 15, 17, 31, \\cdots]$ 映射为 $[1, 2, 3, 4, 11, 12, 13, 14, 21, \\cdots]$。这样映射完成后，对于任何一个映射后的数我们可以用类似进制转换的方式计算出所有小于等于它的合法数的数目，例如 $34$ 就是从小到大第 $3 \\times m + 4 = 3 \\times 4 + 4 = 16$ 个合法的数，此时小于等于 $34$ 就有 $16$ 个。\n\n根据上述结论，我们可以先求出小于等于 $n$ 的最大合法数 $C$，随后对它按照进制的方式进行映射，小于等于 $C$ 的合法数的个数即为小于等于 $n$ 的合法数的个数。\n\n**算法**\n\n如果求出了小于等于 $n$ 的最大的合法的数 $C$，后面的两步（映射，进制转换）的方法就都比较简单，在此我们重点说明求出 $C$ 的方法。\n\n我们从 $n$ 的最高位开始遍历，每次参考 $n$ 中每一位对应的数字，写入当前数位对应的数字。设数字 $n$ 的前 $i$ 位构成的数字为 $\\textit{num}[i]$，数字 $n$ 的第 $i$ 位对应的数字为 $s[i]$。设标志位 $\\textit{isLimit}$ 用来标识当前已经写入的 $C$ 与数字 $n$ 的前 $i$ 的关系，如果当前的 $C = \\textit{num}[i]$，则此时 $\\textit{isLimit} = \\text{true}$；如果当前的 $C < \\textit{num}[i]$，则此时 $\\textit{isLimit} = \\text{false}$。我们在遍历 $n$ 的第 $i$ 位时需进行分类讨论：\n\n+ 如果 $\\textit{isLimit}$ 为 $\\text{false}$，表示当前已经写入的数 $C$ 小于 $n$ 的前 $i-1$ 位构成的数字，则此时我们应当贪心直接在 $C$ 的末尾追加 $\\textit{digits}$ 中最大的数字，此时构成的数字最大且小于等于 $n$；\n\n+ 如果 $\\textit{isLimit}$ 为 $\\text{true}$，表示当前已经写入的数 $C$ 等于 $n$ 的前 $i-1$ 位构成的数字，此时需要分类讨论：\n\n    + 如果此时 $\\textit{digits}$ 中存在数字 $d$ 满足 $d \\le s[i]$，此时我们应该直接在 $C$ 的末尾添加满足上述条件下的最大数字 $d$。如果选中的数字满足 $d < s[i]$，此时构造的 $C$ 一定满足 $C < \\textit{num}[i]$，$\\textit{isLimit}$ 应标记为 $\\text{false}$。\n\n    + 如果此时 $\\textit{digits}$ 中所有的数字 $d$ 均满足 $d > s[i]$，则此时我们应该将 $C$ 中已经压入的数字进行缩小，此时我们应该找到第一个可以缩小的数字，我们依次将已经写入的数字弹出找到第一个可以进行缩小的数字。如果可以找到进行缩小的数字，则我们将其缩小为比该数字小的数，接着依次贪心地将所有的数位填充为 $\\textit{digits}$ 中最大的数；如果无法找到进行缩小的数字，则此时我们需要将 $C$ 的位数减少 $1$ 位，接着依次贪心地将所有的数位填充为 $\\textit{digits}$ 中最大的数。此时构造的 $C$ 一定满足 $C < \\textit{num}[i]$，$\\textit{isLimit}$ 应标记为 $\\text{false}$。\n\n下面给出一个更加具体的例子：$n = 11000, digits = \\text{[``1\",``3\",``5\",``7\"]}$。\n\n+ 初始化 $C = 0$，当我们遍历第 $1$ 位时，此时 $s[1] = 1$，我们找到满足小于等于 $s[1]$ 的数字 $1$，此时 $C = 1$；\n\n+ 当我们遍历第 $2$ 位时，此时 $s[2] = 1$，我们找到满足小于等于 $s[2]$ 的数字 $1$，此时 $C = 11$；\n\n+ 当我们遍历第 $3$ 位时，此时 $s[3] = 0$，我们无法找到满足小于等于 $s[3]$ 的数字，此时我们需要 $C$ 弹出数字，由于不存在比 $1$ 更小的数字，因此此时 $C$ 只能减少位数，并贪心地压入数字 $7$，此时 $C = 77$，设标志位 $\\textit{isLimit} = \\text{false}$；\n\n+ 当我们遍历第 $4$ 位时，由于标志位 $\\textit{isLimit} = \\text{false}$，此时贪心地压入数字 $7$，此时 $C = 777$；\n\n+ 当我们遍历第 $5$ 位时，由于标志位 $\\textit{isLimit} = \\text{false}$，此时贪心地压入数字 $7$，此时 $C = 7777$；\n\n因此最终构造满足小于等于 $11000$ 的最大数字为 $7777$。\n\n```Python [sol2-Python3]\nclass Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        m = len(digits)\n        s = str(n)\n        bits = []\n        is_limit = True\n        for c in s:\n            if not is_limit:\n                bits.append(m - 1)\n                continue\n            select_index = -1\n            for j, d in enumerate(digits):\n                if d > c:\n                    break\n                select_index = j\n            if select_index >= 0:\n                bits.append(select_index)\n                if digits[select_index] < c:\n                    is_limit = False\n            else:\n                sz = len(bits)\n                while bits and bits[-1] == 0:\n                    bits.pop()\n                if bits:\n                    bits[-1] -= 1\n                else:\n                    sz -= 1\n                while len(bits) <= sz:\n                    bits.append(m - 1)\n                is_limit = False\n        ans = 0\n        for b in bits:\n            ans = ans * m + b + 1\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int atMostNGivenDigitSet(vector<string>& digits, int n) {\n        string s = to_string(n);\n        int m = digits.size(), k = s.size();\n        vector<int> bits;\n        bool isLimit = true;\n        for (int i = 0; i < k; i++) {\n            if (!isLimit) {\n                bits.emplace_back(m - 1);\n            } else {\n                int selectIndex = -1;\n                for (int j = 0; j < m; j++) {\n                    if (digits[j][0] <= s[i]) {\n                        selectIndex = j;\n                    } else {\n                        break;\n                    }\n                }\n                if (selectIndex >= 0) {\n                    bits.emplace_back(selectIndex);\n                    if (digits[selectIndex][0] < s[i]) {\n                        isLimit = false;\n                    }\n                } else {\n                    int len = bits.size();\n                    while (!bits.empty() && bits.back() == 0) {\n                        bits.pop_back();\n                    }\n                    if (!bits.empty()) {\n                        bits.back() -= 1;\n                    } else {\n                        len--;\n                    }\n                    while ((int)bits.size() <= len) {\n                        bits.emplace_back(m - 1);\n                    }\n                    isLimit = false;\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < bits.size(); i++) {\n            ans = ans * m + (bits[i] + 1);\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int atMostNGivenDigitSet(String[] digits, int n) {\n        String s = Integer.toString(n);\n        int m = digits.length, k = s.length();\n        List<Integer> bits = new ArrayList<Integer>();\n        boolean isLimit = true;\n        for (int i = 0; i < k; i++) {\n            if (!isLimit) {\n                bits.add(m - 1);\n            } else {\n                int selectIndex = -1;\n                for (int j = 0; j < m; j++) {\n                    if (digits[j].charAt(0) <= s.charAt(i)) {\n                        selectIndex = j;\n                    } else {\n                        break;\n                    }\n                }\n                if (selectIndex >= 0) {\n                    bits.add(selectIndex);\n                    if (digits[selectIndex].charAt(0) < s.charAt(i)) {\n                        isLimit = false;\n                    }\n                } else {\n                    int len = bits.size();\n                    while (!bits.isEmpty() && bits.get(bits.size() - 1) == 0) {\n                        bits.remove(bits.size() - 1);\n                    }\n                    if (!bits.isEmpty()) {\n                        bits.set(bits.size() - 1, bits.get(bits.size() - 1) - 1);\n                    } else {\n                        len--;\n                    }\n                    while (bits.size() <= len) {\n                        bits.add(m - 1);\n                    }\n                    isLimit = false;\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < bits.size(); i++) {\n            ans = ans * m + (bits.get(i) + 1);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int AtMostNGivenDigitSet(string[] digits, int n) {\n        string s = n.ToString();\n        int m = digits.Length, k = s.Length;\n        IList<int> bits = new List<int>();\n        bool isLimit = true;\n        for (int i = 0; i < k; i++) {\n            if (!isLimit) {\n                bits.Add(m - 1);\n            } else {\n                int selectIndex = -1;\n                for (int j = 0; j < m; j++) {\n                    if (digits[j][0] <= s[i]) {\n                        selectIndex = j;\n                    } else {\n                        break;\n                    }\n                }\n                if (selectIndex >= 0) {\n                    bits.Add(selectIndex);\n                    if (digits[selectIndex][0] < s[i]) {\n                        isLimit = false;\n                    }\n                } else {\n                    int len = bits.Count;\n                    while (bits.Count > 0 && bits[bits.Count - 1] == 0) {\n                        bits.RemoveAt(bits.Count - 1);\n                    }\n                    if (bits.Count > 0) {\n                        bits[bits.Count - 1]--;\n                    } else {\n                        len--;\n                    }\n                    while (bits.Count <= len) {\n                        bits.Add(m - 1);\n                    }\n                    isLimit = false;\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < bits.Count; i++) {\n            ans = ans * m + (bits[i] + 1);\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX_STR_LEN 32\n\nint atMostNGivenDigitSet(char ** digits, int digitsSize, int n){\n    char s[MAX_STR_LEN];\n    sprintf(s, \"%d\", n);\n    int m = digitsSize, k = strlen(s);\n    int bits[MAX_STR_LEN], pos = 0;\n    bool isLimit = true;\n    for (int i = 0; i < k; i++) {\n        if (!isLimit) {\n            bits[pos++] = m - 1;\n        } else {\n            int selectIndex = -1;\n            for (int j = 0; j < m; j++) {\n                if (digits[j][0] <= s[i]) {\n                    selectIndex = j;\n                } else {\n                    break;\n                }\n            }\n            if (selectIndex >= 0) {\n                bits[pos++] = selectIndex;\n                if (digits[selectIndex][0] < s[i]) {\n                    isLimit = false;\n                }\n            } else {\n                int len = pos;\n                while (pos > 0 && bits[pos - 1] == 0) {\n                    pos--;\n                }\n                if (pos > 0) {\n                    bits[pos - 1] -= 1;\n                } else {\n                    len--;\n                }\n                while (pos <= len) {\n                    bits[pos++] = m - 1;\n                }\n                isLimit = false;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < pos; i++) {\n        ans = ans * m + (bits[i] + 1);\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar atMostNGivenDigitSet = function(digits, n) {\n    const s = '' + n;\n    const m = digits.length, k = s.length;\n    const bits = [];\n    let isLimit = true;\n    for (let i = 0; i < k; i++) {\n        if (!isLimit) {\n            bits.push(m - 1);\n        } else {\n            let selectIndex = -1;\n            for (let j = 0; j < m; j++) {\n                if (digits[j][0] <= s[i]) {\n                    selectIndex = j;\n                } else {\n                    break;\n                }\n            }\n            if (selectIndex >= 0) {\n                bits.push(selectIndex);\n                if (digits[selectIndex][0] < s[i]) {\n                    isLimit = false;\n                }\n            } else {\n                let len = bits.length;\n                while (bits.length !== 0 && bits[bits.length - 1] === 0) {\n                    bits.pop();\n                }\n                if (bits.length !== 0) {\n                    const n = bits.length;\n                    bits.splice(n - 1, 1, bits[n - 1] - 1);\n                } else {\n                    len--;\n                }\n                while (bits.length <= len) {\n                    bits.push(m - 1);\n                }\n                isLimit = false;\n            }\n        }\n    }\n    let ans = 0;\n    for (let i = 0; i < bits.length; i++) {\n        ans = ans * m + (bits[i] + 1);\n    }\n    return ans;\n};\n```\n\n```go [sol2-Golang]\nfunc atMostNGivenDigitSet(digits []string, n int) (ans int) {\n    m := len(digits)\n    s := strconv.Itoa(n)\n    bits := []int{}\n    isLimit := true\n    for _, c := range s {\n        if !isLimit {\n            bits = append(bits, m-1)\n            continue\n        }\n        selectIndex := -1\n        for j, d := range digits {\n            if d[0] > byte(c) {\n                break\n            }\n            selectIndex = j\n        }\n        if selectIndex >= 0 {\n            bits = append(bits, selectIndex)\n            if digits[selectIndex][0] < byte(c) {\n                isLimit = false\n            }\n        } else {\n            sz := len(bits)\n            for len(bits) > 0 && bits[len(bits)-1] == 0 {\n                bits = bits[:len(bits)-1]\n            }\n            if len(bits) > 0 {\n                bits[len(bits)-1]--\n            } else {\n                sz--\n            }\n            for len(bits) <= sz {\n                bits = append(bits, m-1)\n            }\n            isLimit = false\n        }\n    }\n    for _, b := range bits {\n        ans = ans*m + b + 1\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n \\times k)$，其中 $n$ 为给定数字，$k$ 表示给定的数字的种类。需要遍历 $n$ 的所有数位的数字，$n$ 含有的数字个数为 $\\log_{10}n$，检测每一位时都需要遍历一遍给定的数字，因此总的时间复杂度为 $O(\\log n \\times k)$。\n\n- 空间复杂度：$O(\\log n)$，其中 $n$ 为给定数字。需要需要保存每一位上可能数字的组合数目，因此需要的空间复杂度为 $O(\\log n)$。"
}