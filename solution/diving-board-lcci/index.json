{
	"titleSlug": "diving-board-lcci",
	"slug": "tiao-shui-ban-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/diving-board-lcci/solution/tiao-shui-ban-by-leetcode-solution/",
	"content": "### 📺 视频题解  \n![...序员面试金典》16.11.跳水板.mp4](18529af6-3cff-4c4e-a88f-2443659e044a)\n\n### 📖 文字题解\n#### 前言\n\n这道题是《程序员面试金典》上的题，书上给出了三种解法，分别是递归解法、记忆化解法和最优解法。\n\n递归解法的时间复杂度是 $O(2^k)$，记忆化解法的时间复杂度是 $O(k^2)$，都会超出时间限制，因此这里只给出最优解法。\n\n#### 方法一：数学\n\n首先考虑两种边界情况。\n\n- 如果 $k=0$，则不能建造任何跳水板，因此返回空数组。\n\n- 如果 $\\textit{shorter}$ 和 $\\textit{longer}$ 相等，则建造的跳水板的长度是唯一的，都等于 $\\textit{shorter} \\times k$，因此返回长度为 $1$ 的数组，数组中的元素为 $\\textit{shorter} \\times k$。\n\n然后考虑一般情况，即 $\\textit{shorter}<\\textit{longer}$ 且 $k>0$。由于短木板和长木板一共使用 $k$ 块，因此一共有 $k+1$ 种组合，每种组合下建造的跳水板长度都是不一样的，一共有 $k+1$ 种不同的长度。\n\n为什么每种组合下建造的跳水板长度都是不一样的？考虑以下两种不同的组合：第一种组合，有 $i$ 块长木板，则跳水板的长度是 $\\textit{shorter} \\times (k-i)+\\textit{longer} \\times i$；第二种组合，有 $j$ 块长木板，则跳水板的长度是 $\\textit{shorter} \\times (k-j)+\\textit{longer} \\times j$。其中 $0 \\leq i<j \\leq k$。则两种不同的组合下的跳水板长度之差为：\n\n$$\n(\\textit{shorter} \\times (k-i)+\\textit{longer} \\times i)-(\\textit{shorter} \\times (k-j)+\\textit{longer} \\times j)=(\\textit{longer}-\\textit{shorter}) \\times (i-j)\n$$\n\n由于 $\\textit{longer}>\\textit{shorter}$ 且 $i<j$，因此上式的值小于 $0$。由此可见，任意两种不同的组合下的跳水板长度都是不一样的，而且使用的长木板越多，跳水板的长度越大。\n\n因此创建长度为 $k+1$ 的数组 $\\textit{lengths}$，对于 $0 \\leq i \\leq k$，令 $\\textit{lengths}[i]=\\textit{shorter} \\times (k-i)+\\textit{longer} \\times i$，则 $\\textit{lengths}$ 包含跳水板所有可能的长度，且长度为升序排序。\n\n![fig1](https://assets.leetcode-cn.com/solution-static/jindian_16.11/jindian_16.11_fig1.gif){:width=\"80%\"}\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] divingBoard(int shorter, int longer, int k) {\n        if (k == 0) {\n            return new int[0];\n        }\n        if (shorter == longer) {\n            return new int[]{shorter * k};\n        }\n        int[] lengths = new int[k + 1];\n        for (int i = 0; i <= k; i++) {\n            lengths[i] = shorter * (k - i) + longer * i;\n        }\n        return lengths;\n    }\n}\n```\n\n```cpp [sol1-C++]\nclass Solution {\npublic:\n    vector<int> divingBoard(int shorter, int longer, int k) {\n        if (k == 0) {\n            return vector <int> ();\n        }\n\n        if (shorter == longer) {\n            return vector <int> (1, shorter * k);\n        }\n\n        vector <int> lengths(k + 1);\n        for (int i = 0; i <= k; ++i) {\n            lengths[i] = shorter * (k - i) + longer * i;\n        }\n\n        return lengths;\n    }\n};\n```\n\n```csharp [sol1-C#]\npublic class Solution \n{\n    public int[] DivingBoard(int shorter, int longer, int k) \n    {\n        if (k == 0)\n        {\n            return new int[0];\n        }\n\n        if (shorter == longer) \n        {\n            return new int[]{shorter * k};\n        }\n\n        int[] lengths = new int[k + 1];\n        for (int i = 0; i <= k; i++) \n        {\n            lengths[i] = shorter * (k - i) + longer * i;\n        }\n        \n        return lengths;\n    }\n}\n```\n\n```C [sol1-C]\nint* divingBoard(int shorter, int longer, int k, int* returnSize) {\n    if (k == 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (shorter == longer) {\n        int* p = (int*)malloc(sizeof(int));\n        *p = shorter * k;\n        *returnSize = 1;\n        return p;\n    }\n    *returnSize = k + 1;\n    int* lengths = (int*)malloc(sizeof(int) * (k + 1));\n    for (int i = 0; i <= k; ++i) {\n        lengths[i] = shorter * (k - i) + longer * i;\n    }\n    return lengths;\n}\n```\n\n```golang [sol1-Golang]\nfunc divingBoard(shorter int, longer int, k int) []int {\n    if k == 0 {\n        return []int{}\n    }\n    if shorter == longer {\n        return []int{shorter * k}\n    }\n    lengths := make([]int, k + 1)\n    for i := 0; i <= k; i++ {\n        lengths[i] = shorter * (k - i) + longer * i\n    }\n    return lengths\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(k)$，其中 $k$ 是木板数量。短木板和长木板一共使用 $k$ 块，一共有 $k+1$ 种组合，对于每种组合都要计算跳水板的长度。\n\n- 空间复杂度：$O(1)$。除了返回值以外，额外使用的空间复杂度为常数。"
}