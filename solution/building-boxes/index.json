{
	"titleSlug": "building-boxes",
	"slug": "by-stormsunshine-awhw",
	"url": "https://leetcode-cn.com/problems/building-boxes/solution/by-stormsunshine-awhw/",
	"content": "# 解法一\r\n\r\n## 思路和算法\r\n\r\n为了使接触地面的盒子最少，最底层的盒子数量应该最少，因此放置的盒子高度应该最大，每一层的盒子数量之差应该最小。为了实现这一点，盒子应该放置在角落中，每个放置在角落的盒子有两面与墙相邻，可以使每一层的盒子数量最少。\r\n\r\n将每一层盒子按从上到下的顺序编号，顶部的盒子位于第 $1$ 层，则第 $1$ 层至少有 $1$ 个盒子。当每一层的盒子数量最少时，为了遵循放置规则，第 $i + 1$ 层应该比第 $i$ 层多 $i + 1$ 个盒子，因此第 $i$ 层有 $\\dfrac{i \\times (i + 1)}{2}$ 个盒子。如果 $n$ 个盒子放置了 $\\textit{level}$ 层，记 $\\textit{sum} = \\sum\\limits_{i = 1}^{\\textit{level}} \\dfrac{i \\times (i + 1)}{2}$，则 $\\textit{level}$ 为满足 $\\textit{sum} \\le n$ 的最大正整数。\r\n\r\n放置了 $\\textit{level}$ 层的 $\\textit{sum}$ 个盒子之后，剩余的盒子个数是 $\\textit{remain} = n - \\textit{sum}$，剩余的盒子无法放在新的一层，必须放在已有的层。如果剩余的盒子中接触地面的盒子有 $\\textit{increase}$ 个，则 $\\textit{increase}$ 是满足 $\\dfrac{\\textit{increase} \\times (\\textit{increase} + 1)}{2} \\ge \\textit{remain}$ 的最小整数，当等号成立时，剩余的盒子一共放 $\\textit{increase}$ 层，每一层比上一层多一个。\r\n\r\n由于一共放置 $\\textit{level}$ 层，$\\textit{sum}$ 个盒子中接触地面的盒子有 $\\dfrac{\\textit{level} \\times (\\textit{level} + 1)}{2}$ 个，因此接触地面的盒子的最少可能数量是 $\\dfrac{\\textit{level} \\times (\\textit{level} + 1)}{2} + \\textit{increase}$。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public int minimumBoxes(int n) {\r\n        int level = 0;\r\n        int sum = 0;\r\n        while (sum + (level + 1) * (level + 2) / 2 <= n) {\r\n            level++;\r\n            sum += level * (level + 1) / 2;\r\n        }\r\n        int remain = n - sum;\r\n        int increase = 0;\r\n        while (remain > 0) {\r\n            increase++;\r\n            remain -= increase;\r\n        }\r\n        return level * (level + 1) / 2 + increase;\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public int MinimumBoxes(int n) {\r\n        int level = 0;\r\n        int sum = 0;\r\n        while (sum + (level + 1) * (level + 2) / 2 <= n) {\r\n            level++;\r\n            sum += level * (level + 1) / 2;\r\n        }\r\n        int remain = n - sum;\r\n        int increase = 0;\r\n        while (remain > 0) {\r\n            increase++;\r\n            remain -= increase;\r\n        }\r\n        return level * (level + 1) / 2 + increase;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(\\sqrt[3]{n})$，其中 $n$ 是盒子数。需要遍历每一层计算盒子数，层数 $\\textit{level}$ 与盒子数 $n$ 的关系是 $\\textit{level} = O(\\sqrt[3]{n})$。\r\n\r\n- 空间复杂度：$O(1)$。\r\n\r\n# 解法二\r\n\r\n## 思路和算法\r\n\r\n如果每一层的盒子数量最少，则第 $i$ 层有 $\\dfrac{i \\times (i + 1)}{2}$ 个盒子，$\\textit{level}$ 层共有 $\\dfrac{\\textit{level} \\times (\\textit{level} + 1) \\times (\\textit{level} + 2)}{6}$ 个盒子。剩余的 $\\textit{remain}$ 个盒子中如果接触地面的盒子有 $\\textit{increase}$ 个，则 $\\textit{remain}$ 的最大值为 $\\dfrac{\\textit{increase} \\times (\\textit{increase} + 1)}{2}$。\r\n\r\n为了得到符合要求的 $\\textit{level}$ 的最大值和 $\\textit{increase}$ 的最小值，可以使用二分查找实现。以下用 $\\textit{low}$ 和 $\\textit{high}$ 分别表示二分查找的下界和上界。\r\n\r\n计算 $\\textit{level}$ 的最大值时，将 $\\textit{low}$ 的初始值设为 $1$，$\\textit{high}$ 的初始值设为 $\\min(n, 10^5)$，因为 $n$ 的最大值是 $10^9$，$\\textit{level}$ 不可能超过 $10^5$，将 $\\textit{high}$ 的初始值设为 $\\min(n, 10^5)$ 可以确保得到正确的 $\\textit{level}$ 且使用 $64$ 位整数计算时不会溢出。\r\n\r\n每次查找时，取 $\\textit{mid}$ 为 $\\textit{low}$ 和 $\\textit{high}$ 的平均数向上取整，将 $\\textit{mid}$ 作为层数，比较 $\\dfrac{\\textit{mid} \\times (\\textit{mid} + 1) \\times (\\textit{mid} + 2)}{6}$ 和 $n$ 的大小，执行如下操作。\r\n\r\n- 如果 $\\dfrac{\\textit{mid} \\times (\\textit{mid} + 1) \\times (\\textit{mid} + 2)}{6} \\le n$，则层数大于等于 $\\textit{mid}$，因此在 $[\\textit{mid}, \\textit{high}]$ 中继续查找。\r\n\r\n- 如果 $\\dfrac{\\textit{mid} \\times (\\textit{mid} + 1) \\times (\\textit{mid} + 2)}{6} > n$，则层数小于 $\\textit{mid}$，因此在 $[\\textit{low}, \\textit{mid} - 1]$ 中继续查找。\r\n\r\n当 $\\textit{low} = \\textit{high}$ 时，查找结束，此时 $\\textit{low}$ 即为 $\\textit{level}$ 的最大值。\r\n\r\n计算 $\\textit{increase}$ 的最小值时，将 $\\textit{low}$ 的初始值设为 $0$，$\\textit{high}$ 的初始值设为 $\\textit{remain}$。\r\n\r\n每次查找时，取 $\\textit{mid}$ 为 $\\textit{low}$ 和 $\\textit{high}$ 的平均数向下取整，将 $\\textit{mid}$ 作为 $\\textit{increase}$，比较 $\\dfrac{\\textit{mid} \\times (\\textit{mid} + 1)}{2}$ 和 $\\textit{remain}$ 的大小，执行如下操作。\r\n\r\n- 如果 $\\dfrac{\\textit{mid} \\times (\\textit{mid} + 1)}{2} \\ge \\textit{remain}$，则 $\\textit{increase}$ 小于等于 $\\textit{mid}$，因此在 $[\\textit{low}, \\textit{mid}]$ 中继续查找。\r\n\r\n- 如果 $\\dfrac{\\textit{mid} \\times (\\textit{mid} + 1)}{2} < \\textit{remain}$，则 $\\textit{increase}$ 大于 $\\textit{mid}$，因此在 $[\\textit{mid} + 1, \\textit{high}]$ 中继续查找。\r\n\r\n当 $\\textit{low} = \\textit{high}$ 时，查找结束，此时 $\\textit{low}$ 即为 $\\textit{increase}$ 的最小值。\r\n\r\n得到 $\\textit{level}$ 的最大值和 $\\textit{increase}$ 的最小值之后，接触地面的盒子的最少可能数量是 $\\dfrac{\\textit{level} \\times (\\textit{level} + 1)}{2} + \\textit{increase}$。\r\n\r\n## 代码\r\n\r\n```Java [sol2-Java]\r\nclass Solution {\r\n    public int minimumBoxes(int n) {\r\n        int level = getLevel(n);\r\n        int remain = (int) (n - (long) level * (level + 1) * (level + 2) / 6);\r\n        int increase = getIncrease(remain);\r\n        return level * (level + 1) / 2 + increase;\r\n    }\r\n\r\n    public int getLevel(int n) {\r\n        int low = 1, high = Math.min(n, 100000);\r\n        while (low < high) {\r\n            int mid = low + (high - low + 1) / 2;\r\n            long sum = (long) mid * (mid + 1) * (mid + 2) / 6;\r\n            if (sum <= n) {\r\n                low = mid;\r\n            } else {\r\n                high = mid - 1;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n\r\n    public int getIncrease(int remain) {\r\n        int low = 0, high = remain;\r\n        while (low < high) {\r\n            int mid = low + (high - low) / 2;\r\n            long sum = (long) mid * (mid + 1) / 2;\r\n            if (sum >= remain) {\r\n                high = mid;\r\n            } else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol2-C#]\r\npublic class Solution {\r\n    public int MinimumBoxes(int n) {\r\n        int level = GetLevel(n);\r\n        int remain = (int) (n - (long) level * (level + 1) * (level + 2) / 6);\r\n        int increase = GetIncrease(remain);\r\n        return level * (level + 1) / 2 + increase;\r\n    }\r\n\r\n    public int GetLevel(int n) {\r\n        int low = 1, high = Math.Min(n, 100000);\r\n        while (low < high) {\r\n            int mid = low + (high - low + 1) / 2;\r\n            long sum = (long) mid * (mid + 1) * (mid + 2) / 6;\r\n            if (sum <= n) {\r\n                low = mid;\r\n            } else {\r\n                high = mid - 1;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n\r\n    public int GetIncrease(int remain) {\r\n        int low = 0, high = remain;\r\n        while (low < high) {\r\n            int mid = low + (high - low) / 2;\r\n            long sum = (long) mid * (mid + 1) / 2;\r\n            if (sum >= remain) {\r\n                high = mid;\r\n            } else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(\\log n)$，其中 $n$ 是盒子数。计算 $\\textit{level}$ 的最大值需要执行 $O(\\log n)$ 次二分查找，计算 $\\textit{increase}$ 的最小值需要执行 $O(\\log \\textit{remain})$ 次二分查找，每次二分查找需要 $O(1)$ 的时间，由于 $\\textit{remain} < n$，因此时间复杂度是 $O(\\log n)$。\r\n\r\n- 空间复杂度：$O(1)$。"
}