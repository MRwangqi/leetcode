{
	"titleSlug": "maximum-alternating-subsequence-sum",
	"slug": "zui-da-zi-xu-lie-jiao-ti-he-by-leetcode-epqrk",
	"url": "https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum/solution/zui-da-zi-xu-lie-jiao-ti-he-by-leetcode-epqrk/",
	"content": "#### 方法一：动态规划\n\n**思路与算法**\n\n记 $\\textit{odd}[i]$ 表示我们在数组 $\\textit{nums}$ 的前缀 $\\textit{nums}[0..i]$ 中选择元素组成子序列，且最后一个**选择的**元素的下标是奇数时，可以得到的最大交替和。\n\n同理，我们记 $\\textit{even}[i]$ 表示在 $\\textit{nums}[0..i]$ 中选择元素组成子序列，且最后一个**选择的**元素的下标是偶数时，可以得到的最大交替和。\n\n在进行状态转移时，我们可以考虑 $\\textit{nums}[i]$ 是否被选择。对于 $\\textit{odd}[i]$ 而言：\n\n- 如果我们选择了 $\\textit{nums}[i]$，那么倒数第二个选择的元素下标在 $[0..i-1]$ 中，并且它是一个偶数下标。因此有状态转移方程：\n\n    $$\n    \\textit{odd}[i] = \\textit{even}[i-1] - \\textit{nums}[i]\n    $$\n\n- 如果我们没有选择 $\\textit{nums}[i]$，那么有状态转移方程：\n\n    $$\n    \\textit{odd}[i] = \\textit{odd}[i-1]\n    $$\n\n由于我们希望求出**最大的**交替和，因此 $\\textit{odd}[i]$ 的状态转移方程即为：\n\n$$\n\\textit{odd}[i] = \\max \\{ \\textit{even}[i-1] - \\textit{nums}[i], \\textit{odd}[i-1] \\}\n$$\n\n同理我们可以得到 $\\textit{even}[i]$ 的状态转移方程：\n\n$$\n\\textit{even}[i] = \\max \\{ \\textit{odd}[i-1] + \\textit{nums}[i], \\textit{even}[i-1] \\}\n$$\n\n设数组 $\\textit{nums}$ 的长度为 $n$，那么最终的答案即为 $\\textit{odd}[n-1]$ 与 $\\textit{even}[n-1]$ 中的较大值。但我们可以注意到，拥有最大交替和的子序列的最后一个元素一定不可能位于奇数下标（因为奇数下标对应着减去该元素的值，我们完全可以不选择该元素，直接让子序列在倒数第二个偶数下标的位置结束），因此可以直接返回 $\\textit{even}[n-1]$ 作为答案。\n\n**细节**\n\n对于数组 $\\textit{nums}$ 的首个元素，我们可以将其选择为子序列的首个元素，对应偶数下标，因此有 $\\textit{even}[0] = \\textit{nums}[i]$。对于 $\\textit{odd}[0]$ 而言，我们将其置为 $0$（表示没有选择任何元素）即可。\n\n此外，我们发现在状态转移方程中，$\\textit{odd}[i]$ 和 $\\textit{even}[i]$ 都只会从 $\\textit{odd}[i-1]$ 和 $\\textit{even}[i-1]$ 转移而来，因此我们可以使用两个变量代替这两个二维数组进行状态转移。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    long long maxAlternatingSum(vector<int>& nums) {\n        int n = nums.size();\n        long long odd = 0, even = nums[0];\n        for (int i = 1; i < n; ++i) {\n            tie(odd, even) = tuple{max(even - nums[i], odd), max(odd + nums[i], even)};\n        }\n        return even;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxAlternatingSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        odd, even = 0, nums[0]\n        for i in range(1, n):\n            odd, even = max(even - nums[i], odd), max(odd + nums[i], even)\n        return even\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(1)$。"
}