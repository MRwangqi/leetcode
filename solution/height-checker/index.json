{
	"titleSlug": "height-checker",
	"slug": "gao-du-jian-cha-qi-by-leetcode-solution-jeb0",
	"url": "https://leetcode-cn.com/problems/height-checker/solution/gao-du-jian-cha-qi-by-leetcode-solution-jeb0/",
	"content": "#### 方法一：基于比较的排序\n\n**思路与算法**\n\n我们可以直接将数组 $\\textit{heights}$ 复制一份（记为 $\\textit{expected}$），并对数组 $\\textit{expected}$ 进行排序。\n\n待排序完成后，我们统计 $\\textit{heights}[i] \\neq \\textit{expected}[i]$ 的下标数量即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int heightChecker(vector<int>& heights) {\n        vector<int> expected(heights);\n        sort(expected.begin(), expected.end());\n        int n = heights.size(), ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (heights[i] != expected[i]) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int heightChecker(int[] heights) {\n        int n = heights.length, ans = 0;\n        int[] expected = new int[n];\n        System.arraycopy(heights, 0, expected, 0, n);\n        Arrays.sort(expected);\n        for (int i = 0; i < n; ++i) {\n            if (heights[i] != expected[i]) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int HeightChecker(int[] heights) {\n        int n = heights.Length, ans = 0;\n        int[] expected = new int[n];\n        Array.Copy(heights, 0, expected, 0, n);\n        Array.Sort(expected);\n        for (int i = 0; i < n; ++i) {\n            if (heights[i] != expected[i]) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def heightChecker(self, heights: List[int]) -> int:\n        expected = sorted(heights)\n        return sum(1 for x, y in zip(heights, expected) if x != y)\n```\n\n```C [sol1-C]\nstatic inline cmp(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint heightChecker(int* heights, int heightsSize) {\n    int *expected = (int *)malloc(sizeof(int) * heightsSize);\n    memcpy(expected, heights, sizeof(int) * heightsSize);\n    qsort(expected, heightsSize, sizeof(int), cmp);\n    int ans = 0;\n    for (int i = 0; i < heightsSize; ++i) {\n        if (heights[i] != expected[i]) {\n            ++ans;\n        }\n    }\n    free(expected);\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc heightChecker(heights []int) (ans int) {\n    sorted := append([]int{}, heights...)\n    sort.Ints(sorted)\n    for i, v := range heights {\n        if v != sorted[i] {\n            ans++\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar heightChecker = function(heights) {\n    let n = heights.length, ans = 0;\n    const expected = new Array(n).fill(0);\n    expected.splice(0, n, ...heights);\n    expected.sort((a, b) => a - b);\n    for (let i = 0; i < n; ++i) {\n        if (heights[i] !== expected[i]) {\n            ++ans;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{heights}$ 的长度。即为排序需要的时间。\n\n- 空间复杂度：$O(n)$，即为数组 $\\textit{expected}$ 需要的空间。\n\n#### 方法二：计数排序\n\n**思路与算法**\n\n注意到本题中学生的高度小于等于 $100$，因此可以使用计数排序。\n\n**细节**\n\n在进行计数排序时，我们可以直接使用一个长度为 $101$ 的数组，也可以先对数组 $\\textit{heights}$ 进行一次遍历，找出最大值 $m$，从而使用一个长度为 $m+1$ 的数组。\n\n当计数排序完成后，我们可以再使用一个长度为 $n$ 的数组，显式地存储排序后的结果。为了节省空间，我们也直接在计数排序的数组上进行遍历，具体可以参考下面的代码。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int heightChecker(vector<int>& heights) {\n        int m = *max_element(heights.begin(), heights.end());\n        vector<int> cnt(m + 1);\n        for (int h: heights) {\n            ++cnt[h];\n        }\n\n        int idx = 0, ans = 0;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= cnt[i]; ++j) {\n                if (heights[idx] != i) {\n                    ++ans;\n                }\n                ++idx;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int heightChecker(int[] heights) {\n        int m = Arrays.stream(heights).max().getAsInt();\n        int[] cnt = new int[m + 1];\n        for (int h : heights) {\n            ++cnt[h];\n        }\n\n        int idx = 0, ans = 0;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= cnt[i]; ++j) {\n                if (heights[idx] != i) {\n                    ++ans;\n                }\n                ++idx;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int HeightChecker(int[] heights) {\n        int m = heights.Max();\n        int[] cnt = new int[m + 1];\n        foreach (int h in heights) {\n            ++cnt[h];\n        }\n\n        int idx = 0, ans = 0;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= cnt[i]; ++j) {\n                if (heights[idx] != i) {\n                    ++ans;\n                }\n                ++idx;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def heightChecker(self, heights: List[int]) -> int:\n        m = max(heights)\n        cnt = [0] * (m + 1)\n\n        for h in heights:\n            cnt[h] += 1\n        \n        idx = ans = 0\n        for i in range(1, m + 1):\n            for j in range(cnt[i]):\n                if heights[idx] != i:\n                    ans += 1\n                idx += 1\n        \n        return ans\n```\n\n```C [sol2-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint heightChecker(int* heights, int heightsSize) {\n    int m = 0;\n    for (int i = 0; i < heightsSize; i++) {\n        m = MAX(m, heights[i]);\n    }\n    int *cnt = (int *)malloc(sizeof(int) * (m + 1));\n    memset(cnt, 0, sizeof(int) * (m + 1));\n    for (int i = 0; i < heightsSize; i++) {\n        ++cnt[heights[i]];\n    }\n    int idx = 0, ans = 0;\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= cnt[i]; ++j) {\n            if (heights[idx] != i) {\n                ++ans;\n            }\n            ++idx;\n        }\n    }\n    free(cnt);\n    return ans;\n}\n```\n\n```go [sol2-Golang]\nfunc heightChecker(heights []int) (ans int) {\n    cnt := [101]int{}\n    for _, v := range heights {\n        cnt[v]++\n    }\n\n    idx := 0\n    for i, c := range cnt {\n        for ; c > 0; c-- {\n            if heights[idx] != i {\n                ans++\n            }\n            idx++\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar heightChecker = function(heights) {\n    const m = parseInt(_.max(heights));\n    const cnt = new Array(m + 1).fill(0);\n    for (const h of heights) {\n        ++cnt[h];\n    }\n\n    let idx = 0, ans = 0;\n    for (let i = 1; i <= m; ++i) {\n        for (let j = 1; j <= cnt[i]; ++j) {\n            if (heights[idx] !== i) {\n                ++ans;\n            }\n            ++idx;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + C)$，其中 $n$ 是数组 $\\textit{heights}$ 的长度，$C$ 是数组 $\\textit{heights}$ 中的最大值。即为计数排序需要的时间。\n\n- 空间复杂度：$O(C)$，即为计数排序需要的空间。"
}