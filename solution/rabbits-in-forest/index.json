{
	"titleSlug": "rabbits-in-forest",
	"slug": "gong-shui-san-xie-noxiang-xin-ke-xue-xi-v17p5",
	"url": "https://leetcode-cn.com/problems/rabbits-in-forest/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-v17p5/",
	"content": "## 基本分析\n\n首先，兔子它不会说谎 (｀・ω・´)，因此我们可以得出以下结论：\n\n* **同一颜色的兔子回答的数值必然是一样的**\n* **但回答同样数值的，不一定就是同颜色兔子**\n\n举个🌰，假如有 3 只白兔，每只白兔的回答必然都是 2（对应结论 1）；但假如有兔子回答了数值 2，可能只是三只白兔，也可能是三只白兔和三只灰兔同时进行了回答（对应结论 2）。\n\n**答案要我们求最少的兔子数量。**\n\n不妨设有某种颜色的兔子 $m$ 只，它们回答的答案数值为 $cnt$，那么 $m$ 和 $cnt$ 满足什么关系？\n\n显然两者关系为 $m = cnt + 1$。\n\n但如果是在 $answers$ 数组里，回答 $cnt$ 的数量为 $t$ 的话呢？这时候我们需要分情况讨论：\n\n* $t \\leqslant cnt + 1$ : 为达到「最少的兔子数量」，我们可以假定这 $t$ 只兔子为同一颜色，这样能够满足题意，同时不会导致「额外」兔子数量增加（颜色数量最少）。\n* $t > cnt + 1$ : 我们知道回答 $cnt$ 的兔子应该有 $cnt + 1$ 只。这时候说明有数量相同的不同颜色的兔子进行了回答。为达到「最少的兔子数量」，我们应当将 $t$ 分为若干种颜色，并尽可能让某一种颜色的兔子为 $cnt + 1$ 只，这样能够满足题意，同时不会导致「额外」兔子数量增加（颜色数量最少）。\n\n**换句话说，我们应该让「同一颜色的兔子数量」尽量多，从而实现「总的兔子数量」最少。**\n\n***\n\n## 证明\n\n我们来证明一下，为什么这样的贪心思路是对的：\n\n基于上述分析，我们其实是在处理 $answers$ 数组中每一个 $cnt$ ，使得满足题意的前提下，数值 $cnt$ 带来的影响（总的兔子数量，或者说总的颜色数量）最小。\n\n首先 $answers$ 中的每个数都会导致我们总的兔子数量增加，**因此我们应该「让 $answers$ 的数字尽可能变少」，也就是我们需要去抵消掉 $answers$ 中的一些数字。**\n\n对于 $answers$ 中的某个 $cnt$ 而言（注意是某个 $cnt$，含义为一只兔子的回答），必然代表了有 $cnt + 1$ 只兔子，同时也代表了数值 $cnt$ 最多在 $answers$ 数组中出现 $cnt + 1$ 次（与其颜色相同的兔子都进行了回答）。\n\n这时候我们可以从数组中移走 $cnt + 1$ 个数值 $cnt$（如果有的话）。\n\n**当每次处理 $cnt$ 的时候，我们都执行这样的抵消操作。最后得到的 $answers$ 数值数量必然最少（而固定），抵消完成后的 $answers$ 中的每个 $cnt$ 对答案的影响也固定（增加 $cnt + 1$），从而实现「总的兔子数量」最少。**\n\n**相反，如果不执行这样的操作的话，得到的 $answers$ 数值数量必然会更多，「总的兔子数量」也必然会更多，也必然不会比这样做法更优。**\n\n***\n\n## 模拟解法\n\n按照上述思路，我们可以先对 $answers$ 进行排序，然后根据遍历到某个 $cnt$ 时，将其对答案的影响应用到 $ans$ 中（`ans += cnt + 1`），并将后面的 $cnt$ 个 $cnt$ 进行忽略。\n\n**代码（感谢 [@Qian](/u/qiank/)、[@宫水三叶的小迷妹](/u/san_ye_fen/) 和 [@007](/u/007-v8/) 三位同学提供的其他语言版本）：**\n```Java []\nclass Solution {\n    public int numRabbits(int[] cs) {\n        Arrays.sort(cs);\n        int n = cs.length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            int cnt = cs[i];\n            ans += cnt + 1;\n            // 跳过「数值 cnt」后面的 cnt 个「数值 cnt」 \n            int k = cnt;\n            while (k-- > 0 && i + 1 < n && cs[i] == cs[i + 1]) i++;\n        }\n        return ans;\n    }\n}\n```\n```C++ []\nclass Solution {\npublic:\n    int numRabbits(vector<int>& answers) {\n        sort(answers.begin(), answers.end());\n        int n = answers.size();\n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            int cnt = answers[i];\n            ans += cnt + 1;\n            // 跳过「数值 cnt」后面的 cnt 个「数值 cnt」\n            int k = cnt;\n            while (k-- && i+1 < n && answers[i] == answers[i+1])\n                i++;\n        }\n        return ans;\n    }\n};\n```\n```Python3 []\nclass Solution:\n    def numRabbits(self, answers: List[int]) -> int:\n        answers.sort()\n        i, ans, n = 0, 0, len(answers)\n        while i < n:\n            cur = answers[i]\n            ans += (cur + 1)\n            while cur > 0 and i + 1 < len(answers) and answers[i] == answers[i+1]:\n                cur -= 1\n                i += 1\n            i += 1\n        return ans\n```\n```Golang []\nfunc numRabbits(answers []int) int {\n\tsort.Ints(answers)\n\tn := len(answers)\n\tans := 0\n\tfor i := 0; i < n; i++ {\n\t\tcnt := answers[i]\n\t\tans += cnt + 1\n\t\t// 跳过「数值 cnt」后面的 cnt 个「数值 cnt」 \n\t\tk := cnt\n\t\tfor k > 0 && i+1 < n && answers[i] == answers[i+1] {\n\t\t\tk--\n\t\t\ti++\n\t\t}\n\t}\n\treturn ans\n}\n```\n* 时间复杂度：$O(n\\log{n})$\n* 空间复杂度：$O(1)$\n\n***\n\n## 统计分配\n\n我们也可以先对所有出现过的数字进行统计，然后再对数值进行（颜色）分配。\n\n**代码（感谢 [@Qian](/u/qiank/) 和 [@007](/u/007-v8/) 两位同学提供的其他语言版本）：**\n```Java []\nclass Solution {\n    int N = 1009;\n    int[] counts = new int[N];\n    public int numRabbits(int[] cs) {\n        // counts[x] = cnt 代表在 cs 中数值 x 的数量为 cnt\n        for (int i : cs) counts[i]++;\n        int ans = counts[0];\n        for (int i = 1; i < N; i++) {\n            int per = i + 1;\n            int cnt = counts[i];\n            int k = cnt / per;\n            if (k * per < cnt) k++;\n            ans += k * per;\n        }\n        return ans;\n    }\n}\n```\n```C++ []\nclass Solution {\npublic:\n    static constexpr int N = 1009;\n    int numRabbits(vector<int>& answers) {\n        vector<int> counts(N,0);\n        for(auto i : answers)\n            counts[i]++;\n        int ans = counts[0];\n        for(int i = 1; i < N; i++) {\n            int per = i + 1;\n            int cnt = counts[i];\n            int k = cnt/per;\n            if (k * per < cnt) k++;\n            ans += k * per;\n        }\n        return ans;\n    }\n};\n```\n```Golang []\nfunc numRabbits(answers []int) int {\n\tN := 1009\n\tcounts := make([]int, N)\n\tfor _, v := range answers {\n\t\tcounts[v]++\n\t}\n\t// counts[x] = cnt 代表在 cs 中数值 x 的数量为 cnt\n\tans := counts[0]\n\tfor i := 1; i < N; i++ {\n\t\tper := i + 1\n\t\tcnt := counts[i]\n\t\tk := cnt / per\n\t\tif k*per < cnt {\n\t\t\tk++\n\t\t}\n\t\tans += k * per\n\t}\n\treturn ans\n}\n```\n* 时间复杂度：$O(n)$\n* 空间复杂度：$O(n)$\n\n***\n\n## 拓展\n\n保持题目现有的条件不变，假定颜色相同的兔子至少有一只发声，问题改为「问兔子颜色数量可能有多少种」，又该如何求解呢？\n\n***\n\n## 最后\n\n**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ (\"▔□▔)/**\n\n也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解 \n"
}