{
	"titleSlug": "minimized-maximum-of-products-distributed-to-any-store",
	"slug": "fen-pei-gei-shang-dian-de-zui-duo-shang-g0nc2",
	"url": "https://leetcode-cn.com/problems/minimized-maximum-of-products-distributed-to-any-store/solution/fen-pei-gei-shang-dian-de-zui-duo-shang-g0nc2/",
	"content": "#### 方法一：二分查找\n\n**提示 $1$**\n\n随着分配给商店的最多商品数增加，至少需要的商店数会减小。\n\n**思路与算法**\n\n根据 **提示 $1$**，我们可以用二分的方法寻找在遵守规则的情况下，分配给商店的最多商品数的**最小值**。\n\n由于商品数一定非零，因此二分的下界为 $1$；同时由于一间商店至多只能有一种商品，因此二分的上界为 $\\textit{quantities}$ 数组的最大值。在二分查找的每一步中，我们需要解决一个**判定问题**，即：\n\n> 当分配给商店的最多商品数为 $x$ 时，能否根据规则将所有商品分配完？\n\n对于上述的判定问题，我们可以计算出按规则分配完所有商品**最少需要的商店数量**。对于某种数量为 $q$ 的商品，所需要的最少商店数量为 \n\n$$\n\\left\\lceil \\frac{q}{x} \\right\\rceil,\n$$\n\n其中 $\\lceil \\dots \\rceil$ 为向上取整。同理，分配完所有商品最少需要的商店数量即为：\n\n$$\n\\sum_i \\left\\lceil \\frac{q_i}{x} \\right\\rceil,\n$$\n\n其中 $q_i$ 为 $\\textit{quantities}$ 数组中下标为 $i$ 的元素，即第 $i$ 种商品的数目。如果该数量小于等于 $n$，那么根据题意，一定存在至少一种分法将所有商品按规则分配完（注意有的商店可以分配 $0$ 件商品）；反之，如果该数量大于 $n$，那么一定不存在分配完成的方法。\n\n我们用函数 $\\textit{check}(x)$ 来计算上述的判定问题，当该问题为真是返回 $\\texttt{true}$，反之返回 $\\texttt{false}$。同时，我们利用二分查找来确定使得判定问题为真的最小的 $x$，并返回该值作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minimizedMaximum(int n, vector<int>& quantities) {\n        // 判定问题\n        auto check = [&](int x) -> bool{\n            // 计算所需商店数量的最小值，并与商店数量进行比较\n            int cnt = 0;\n            for (int q: quantities){\n                cnt += (q - 1) / x + 1; \n            }\n            return cnt <= n;\n        };\n        \n        int l = 1, r = *max_element(quantities.begin(), quantities.end()) + 1;\n        // 二分查找寻找最小的使得判定问题为真的 x\n        while (l < r){\n            int mid = l + (r - l) / 2;\n            if (check(mid)){\n                r = mid;\n            }\n            else{\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\n        # 判定问题\n        def check(x: int) -> bool:\n            # 计算所需商店数量的最小值，并与商店数量进行比较\n            cnt = 0\n            for q in quantities:\n                cnt += (q - 1) // x + 1\n            return cnt <= n\n        \n        l, r = 1, max(quantities) + 1\n        # 二分查找寻找最小的使得判定问题为真的 x\n        while l < r:\n            mid = l + (r - l) // 2\n            if check(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(m\\log \\max_i q_i)$，其中 $m$ 为 $\\textit{quantities}$ 的长度， $\\max_i q_i$ 为 $\\textit{quantities}$ 中元素的最大值。每一次二分查找都需要 $O(m)$ 的时间计算需要的商店数的最小值。\n\n- 空间复杂度：$O(1)$。"
}