{
	"titleSlug": "n-ary-tree-preorder-traversal",
	"slug": "n-cha-shu-de-qian-xu-bian-li-by-leetcode-bg99",
	"url": "https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/solution/n-cha-shu-de-qian-xu-bian-li-by-leetcode-bg99/",
	"content": "#### 方法一：递归\n\n**思路**\n\n递归思路比较简单，$N$ 叉树的前序遍历与二叉树的前序遍历的思路和方法基本一致，可以参考「[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)」的方法，每次递归时，先访问根节点，然后依次递归访问每个孩子节点即可。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> preorder(Node root) {\n        List<Integer> res = new ArrayList<>();\n        helper(root, res);\n        return res;\n    }\n\n    public void helper(Node root, List<Integer> res) {\n        if (root == null) {\n            return;\n        }\n        res.add(root.val);\n        for (Node ch : root.children) {\n            helper(ch, res);\n        }\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    void helper(const Node* root, vector<int> & res) {\n        if (root == nullptr) {\n            return;\n        }\n        res.emplace_back(root->val);\n        for (auto & ch : root->children) {\n            helper(ch, res);\n        }\n    }\n\n    vector<int> preorder(Node* root) {\n        vector<int> res;\n        helper(root, res);\n        return res;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> Preorder(Node root) {\n        IList<int> res = new List<int>();\n        Helper(root, res);\n        return res;\n    }\n\n    public void Helper(Node root, IList<int> res) {\n        if (root == null) {\n            return;\n        }\n        res.Add(root.val);\n        foreach (Node ch in root.children) {\n            Helper(ch, res);\n        }\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX_NODE_SIZE 10000\n\nvoid helper(const struct Node* root, int* res, int* pos) {\n    if (NULL == root) {\n        return;\n    }\n    res[(*pos)++] = root->val;\n    for (int i = 0; i < root->numChildren; i++) {\n        helper(root->children[i], res, pos);\n    }\n}\n\nint* preorder(struct Node* root, int* returnSize) {\n    int * res = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    int pos = 0;\n    helper(root, res, &pos);\n    *returnSize = pos;\n    return res;\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def preorder(self, root: 'Node') -> List[int]:\n        ans = []\n        def dfs(node: 'Node'):\n            if node is None:\n                return\n            ans.append(node.val)\n            for ch in node.children:\n                dfs(ch)\n        dfs(root)\n        return ans\n```\n\n```go [sol1-Golang]\nfunc preorder(root *Node) (ans []int) {\n    var dfs func(*Node)\n    dfs = func(node *Node) {\n        if node == nil {\n            return\n        }\n        ans = append(ans, node.Val)\n        for _, ch := range node.Children {\n            dfs(ch)\n        }\n    }\n    dfs(root)\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar preorder = function(root) {\n    const res = [];\n    helper(root, res);\n    return res;\n}\n\nconst helper = (root, res) => {\n    if (root === null) {\n        return;\n    }\n    res.push(root.val);\n    for (const ch of root.children) {\n        helper(ch, res);\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。每个节点恰好被遍历一次。\n\n- 空间复杂度：$O(m)$，递归过程中需要调用栈的开销，平均情况下为 $O(\\log m)$，最坏情况下树的深度为 $m-1$，此时需要的空间复杂度为 $O(m)$。\n\n#### 方法二：迭代\n\n**思路**\n\n方法一中利用递归来遍历树，实际的递归中隐式调用了栈，在此我们可以直接模拟递归中栈的调用。在前序遍历中，我们会先遍历节点本身，然后从左向右依次先序遍历该每个以子节点为根的子树。\n\n在这里的栈模拟中比较难处理的在于从当前节点 $u$ 的子节点 $v_1$ 返回时，此时需要处理节点 $u$ 的下一个节点 $v_2$，此时需要记录当前已经遍历完成哪些子节点，才能找到下一个需要遍历的节点。在二叉树树中因为只有左右两个子节点，因此比较方便处理，在 $N$ 叉树中由于有多个子节点，因此使用哈希表记录当前节点 $u$ 已经访问过哪些子节点。\n+ 每次入栈时都将当前节点的 $u$ 的第一个子节点压入栈中，直到当前节点为空节点为止。\n+ 每次查看栈顶元素 $p$，如果节点 $p$ 的子节点已经全部访问过，则将节点 $p$ 的从栈中弹出，并从哈希表中移除，表示该以该节点的子树已经全部遍历过；如果当前节点 $p$ 的子节点还有未遍历的，则将当前节点的 $p$ 的下一个未访问的节点压入到栈中，重复上述的入栈操作。\n\n**代码**\n\n```Java [sol2-Java]\nclass Solution {\n    public List<Integer> preorder(Node root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (root == null) {\n            return res;\n        }\n        Map<Node, Integer> map = new HashMap<Node, Integer>();\n        Deque<Node> stack = new ArrayDeque<Node>();\n        Node node = root;\n        while (!stack.isEmpty() || node != null) {\n            while (node != null) {\n                res.add(node.val);\n                stack.push(node);\n                List<Node> children = node.children;\n                if (children != null && children.size() > 0) {\n                    map.put(node, 0);\n                    node = children.get(0);\n                } else {\n                    node = null;\n                }\n            }\n            node = stack.peek();\n            int index = map.getOrDefault(node, -1) + 1;\n            List<Node> children = node.children;\n            if (children != null && children.size() > index) {\n                map.put(node, index);\n                node = children.get(index);\n            } else {\n                stack.pop();\n                map.remove(node);\n                node = null;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> preorder(Node* root) {\n        vector<int> res;\n        if (root == nullptr) {\n            return res;\n        }\n        \n        unordered_map<Node *, int> cnt;\n        stack<Node *> st;\n        Node * node = root;\n        while (!st.empty() || node != nullptr) {\n            while (node != nullptr) {\n                res.emplace_back(node->val);\n                st.emplace(node);\n                if (node->children.size() > 0) {\n                    cnt[node] = 0;\n                    node = node->children[0];\n                } else {\n                    node = nullptr;\n                }         \n            }\n            node = st.top();\n            int index = (cnt.count(node) ? cnt[node] : -1) + 1;\n            if (index < node->children.size()) {\n                cnt[node] = index;\n                node = node->children[index];\n            } else {\n                st.pop();\n                cnt.erase(node);\n                node = nullptr;\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public IList<int> Preorder(Node root) {\n        IList<int> res = new List<int>();\n        if (root == null) {\n            return res;\n        }\n        Dictionary<Node, int> dictionary = new Dictionary<Node, int>();\n        Stack<Node> stack = new Stack<Node>();\n        Node node = root;\n        while (stack.Count > 0 || node != null) {\n            while (node != null) {\n                res.Add(node.val);\n                stack.Push(node);\n                IList<Node> childrenList = node.children;\n                if (childrenList != null && childrenList.Count > 0) {\n                    dictionary.Add(node, 0);\n                    node = childrenList[0];\n                } else {\n                    node = null;\n                }\n            }\n            node = stack.Peek();\n            int index = (dictionary.ContainsKey(node) ? dictionary[node] : -1) + 1;\n            IList<Node> children = node.children;\n            if (children != null && children.Count > index) {\n                dictionary[node] = index;\n                node = children[index];\n            } else {\n                stack.Pop();\n                dictionary.Remove(node);\n                node = null;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX_NODE_SIZE 10000\n\ntypedef struct {\n    void * key;\n    int val;\n    UT_hash_handle hh; \n} HashItem;\n\nvoid freeHash(HashItem ** obj) {\n    HashItem * curr = NULL, * next = NULL;\n    HASH_ITER(hh, *obj, curr, next) {\n        HASH_DEL(*obj, curr);\n        free(curr);\n    }\n}\n\nint* preorder(struct Node* root, int* returnSize) {\n    if (NULL == root) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int * res = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    struct Node ** stack = (struct Node **)malloc(sizeof(struct Node *) * MAX_NODE_SIZE);\n    int pos = 0, top = 0;  \n\n    const struct Node * node = root;\n    HashItem * cnt = NULL;\n    HashItem * pEntry = NULL;\n    while (top != 0 || node != NULL) {\n        while (node != NULL) {\n            res[pos++] = node->val;\n            stack[top++] = node;\n            if (node->numChildren > 0) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                pEntry->key = node;\n                pEntry->val = 0;\n                HASH_ADD_PTR(cnt, key, pEntry);\n                node = node->children[0];\n            } else {\n                node = NULL;\n            }\n        }\n        node = stack[top - 1];\n        int index = 0;\n        HASH_FIND_PTR(cnt, &node, pEntry);\n        if (pEntry != NULL) {\n            index = pEntry->val + 1;\n        }\n        if (index < node->numChildren) {\n            pEntry->val++;\n            node = node->children[index];\n        } else {\n            top--;\n            if (pEntry != NULL) {\n                HASH_DEL(cnt, pEntry);\n            }\n            node = NULL;\n        }\n    }\n    free(stack);\n    freeHash(&cnt);\n    *returnSize = pos;\n    return res;\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def preorder(self, root: 'Node') -> List[int]:\n        if root is None:\n            return []\n        ans = []\n        st = []\n        nextIndex = defaultdict(int)\n        node = root\n        while st or node:\n            while node:\n                ans.append(node.val)\n                st.append(node)\n                if not node.children:\n                    break\n                nextIndex[node] = 1\n                node = node.children[0]\n            node = st[-1]\n            i = nextIndex[node]\n            if i < len(node.children):\n                nextIndex[node] = i + 1\n                node = node.children[i]\n            else:\n                st.pop()\n                del nextIndex[node]\n                node = None\n        return ans\n```\n\n```go [sol2-Golang]\nfunc preorder(root *Node) (ans []int) {\n    if root == nil {\n        return\n    }\n    st := []*Node{}\n    nextIndex := map[*Node]int{}\n    node := root\n    for len(st) > 0 || node != nil {\n        for node != nil {\n            ans = append(ans, node.Val)\n            st = append(st, node)\n            if len(node.Children) == 0 {\n                break\n            }\n            nextIndex[node] = 1\n            node = node.Children[0]\n        }\n        node = st[len(st)-1]\n        i := nextIndex[node]\n        if i < len(node.Children) {\n            nextIndex[node] = i + 1\n            node = node.Children[i]\n        } else {\n            st = st[:len(st)-1]\n            delete(nextIndex, node)\n            node = nil\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar preorder = function(root) {\n    if (root == null) {\n        return [];\n    }\n    const ans = [];\n    const st = [];\n    const nextIndex = new Map();\n    let node = root;\n    while (st.length || node) {\n        while (node) {\n            ans.push(node.val);\n            st.push(node);\n            if (!node.children) {\n                break;\n            }\n            nextIndex.set(node, 1);\n            node = node.children[0];\n        }\n        node = st[st.length - 1];\n        const i = nextIndex.get(node);\n        if (i < node.children.length) {\n            nextIndex.set(node, i + 1);\n            node = node.children[i];\n        } else {\n            st.pop();\n            nextIndex.delete(node);\n            node = null;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。每个节点恰好被访问一次。\n\n- 空间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。题目中用到哈希表来记录节点的子节点访问记录，哈希表的存储空间等于树的深度，如果 $N$ 叉树的深度为 $1$ 则此时栈与哈希表的空间均为 $O(1)$，如果 $N$ 叉树的深度为 $m-1$ 则此时栈与哈希表的空间为 $O(m-1)$，平均情况下栈与哈希表的空间为 $O(\\log m)$，因此空间复杂度为 $O(m)$。\n\n#### 方法三：迭代优化\n\n**思路**\n\n在前序遍历中，我们会先遍历节点本身，然后从左向右依次先序遍历该每个以子节点为根的子树，此时利用栈先进后出的原理，依次从右向左将子节点入栈，这样出栈的时候即可保证从左向右依次遍历每个子树。参考方法二的原理，可以提前将后续需要访问的节点压入栈中，这样就可以避免记录每个节点的子节点访问数量。\n\n首先把根节点入栈，因为根节点是前序遍历中的第一个节点。随后每次我们从栈顶取出一个节点 $u$，它是我们当前遍历到的节点，并把 $u$ 的所有子节点从右向左逆序压入栈中，这样出栈的节点则是顺序从左向右的。例如 $u$ 的子节点从左到右为 $v_1, v_2, v_3$，那么入栈的顺序应当为 $v_3, v_2, v_1$，这样就保证了下一个遍历到的节点（即 $u$ 的左侧第一个孩子节点 $v_1$）出现在栈顶的位置。此时，访问第一个子节点 $v_1$ 时，仍然按照此方法则会先访问 $v_1$ 的左侧第一个孩子节点。\n\n**代码**\n\n```Java [sol3-Java]\nclass Solution {\n    public List<Integer> preorder(Node root) {\n        List<Integer> res = new ArrayList<>();\n        if (root == null) {\n            return res;\n        }\n\n        Deque<Node> stack = new ArrayDeque<Node>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            res.add(node.val);\n            for (int i = node.children.size() - 1; i >= 0; --i) {\n                stack.push(node.children.get(i));\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    vector<int> preorder(Node* root) {\n        vector<int> res;\n        if (root == nullptr) {\n            return res;\n        }\n\n        stack<Node *> st;\n        st.emplace(root);\n        while(!st.empty()) {\n            Node * node = st.top();\n            st.pop();\n            res.emplace_back(node->val);\n            for (auto it = node->children.rbegin(); it != node->children.rend(); it++) {\n                st.emplace(*it);\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public IList<int> Preorder(Node root) {\n        IList<int> res = new List<int>();\n        if (root == null) {\n            return res;\n        }\n\n        Stack<Node> stack = new Stack<Node>();\n        stack.Push(root);\n        while (stack.Count > 0) {\n            Node node = stack.Pop();\n            res.Add(node.val);\n            for (int i = node.children.Count - 1; i >= 0; i--) {\n                stack.Push(node.children[i]);\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol3-C]\n#define MAX_NODE_SIZE 10000\n\nint* preorder(const struct Node* root, int* returnSize) {\n    if (NULL == root) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int * res = (int *)malloc(sizeof(int) * MAX_NODE_SIZE);\n    struct Node ** stack = (struct Node **)malloc(sizeof(struct Node *) * MAX_NODE_SIZE);\n    int pos = 0, top = 0;  \n\n    stack[top++] = root;\n    while (top != 0) {\n        struct Node * node = stack[--top];\n        res[pos++] = node->val;\n        for (int i = node->numChildren - 1; i >= 0; i--) {\n            stack[top++] = node->children[i];\n        }\n    }\n    free(stack);\n    *returnSize = pos;\n    return res;\n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def preorder(self, root: 'Node') -> List[int]:\n        if root is None:\n            return []\n        ans = []\n        st = [root]\n        while st:\n            node = st.pop()\n            ans.append(node.val)\n            st.extend(reversed(node.children))\n        return ans\n```\n\n```go [sol3-Golang]\nfunc preorder(root *Node) (ans []int) {\n    if root == nil {\n        return\n    }\n    st := []*Node{root}\n    for len(st) > 0 {\n        node := st[len(st)-1]\n        st = st[:len(st)-1]\n        ans = append(ans, node.Val)\n        for i := len(node.Children) - 1; i >= 0; i-- {\n            st = append(st, node.Children[i])\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar preorder = function(root) {\n    const res = [];\n    if (root == null) {\n        return res;\n    }\n\n    const stack = [];\n    stack.push(root);\n    while (stack.length) {\n        const node = stack.pop();\n        res.push(node.val);\n        for (let i = node.children.length - 1; i >= 0; --i) {\n            stack.push(node.children[i]);\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。每个节点恰好被访问一次。\n\n- 空间复杂度：$O(m)$，其中 $m$ 为 $N$ 叉树的节点。如果 $N$ 叉树的深度为 $1$ 则此时栈的空间为 $O(m-1)$，如果 $N$ 叉树的深度为 $m-1$ 则此时栈的空间为 $O(1)$，平均情况下栈的空间为 $O(\\log m)$，因此空间复杂度为 $O(m)$。"
}