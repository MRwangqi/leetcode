{
	"titleSlug": "calculate-digit-sum-of-a-string",
	"slug": "ji-suan-zi-fu-chuan-de-shu-zi-he-by-leet-pfuh",
	"url": "https://leetcode-cn.com/problems/calculate-digit-sum-of-a-string/solution/ji-suan-zi-fu-chuan-de-shu-zi-he-by-leet-pfuh/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n我们可以模拟题目中的操作过程**更新**字符串 $s$，具体在每一轮操作中：\n\n我们用字符串（或数组，视不同语言字符串的实现方式而确定）$\\textit{tmp}$ 来维护该轮操作的结果。随后，我们遍历字符串 $s$，以每 $k$ 个字符为一组，计算该组的数字和 $\\textit{val}$，并转化为字符串添加至 $\\textit{tmp}$ 尾部。最终，我们将 $s$ 更新为 $\\textit{tmp}$ **所表示的字符串**。\n\n我们执行上述操作直到 $s$ 的长度小于等于 $k$ 为止，并最终返回 $s$ 作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string digitSum(string s, int k) {\n        while (s.size() > k) {\n            string tmp;   // 每次操作结束的字符串\n            int n = s.size();\n            for (int i = 0; i < n; i += k) {\n                int val = 0;\n                for (int j = i; j < min(i + k, n); ++j) {\n                    val += s[j] - '0';\n                }\n                tmp.append(to_string(val));\n            }\n            s = tmp;\n        }\n        return s;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def digitSum(self, s: str, k: int) -> str:\n        while len(s) > k:\n            tmp = []   # 每次操作结束的字符串对应数组\n            n = len(s)\n            for i in range(0, n, k):\n                val = 0\n                for j in range(i, min(i + k, n)):\n                    val += int(s[j])\n                tmp.append(str(val))\n            s = \"\".join(tmp)\n        return s\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为字符串 $s$ 的长度。即为所有操作的时间复杂度之和。可以证明，当 $k$ 增大时，操作的次数以及每次操作时当前字符串的长度都会减小；同时，当 $k = 2$ 时，每次操作开始字符串的长度总和仍为 $n$ 的常数倍。因此每次操作时字符串长度之和以及最终的时间复杂度都为 $O(n)$。\n\n- 空间复杂度：$O(n)$，即为辅助数组或字符串的空间开销。"
}