{
	"titleSlug": "smallest-integer-divisible-by-k",
	"slug": "javajie-fa-yi-ji-zheng-ming-de-si-lu-by-jiangzk",
	"url": "https://leetcode-cn.com/problems/smallest-integer-divisible-by-k/solution/javajie-fa-yi-ji-zheng-ming-de-si-lu-by-jiangzk/",
	"content": "### 正常思路\r\n\r\n通过以下代码，我们可以计算出的答案。首先我们检查`x`是否是`K`的倍数，如果不是，我们将其乘10加1。\r\n\r\n```java\r\nwhile (x % K != 0) {\r\n    x = x * 10 + 1;\r\n}\r\n```\r\n\r\n### 优化方案\r\n\r\n容易想到，反复乘10加1很快就会超出`int`能表示的范围。\r\n\r\n对于任意整数$x > 0$，存在非负整数$p$和$q$，使得$x = pK + q$。例如，$x = 2$，$K = 5$时，可以令$p = 0$，$q = 2$。又例如，$x = 29$，$K = 7$时，可以令$p = 4$，$q = 1$。\r\n\r\n我们在计算答案时，使用了以下公式：\r\n\r\n$$\r\nx_{i+1} = 10 x_i + 1\r\n$$\r\n\r\n请注意代码与公式的不同。代码中，我们把$x_{i+1}$的值又保存在了$x_i$的位置，覆盖了其原来的值。为了使得证明过程更加清晰明了，我们在公式中体现这种区别。\r\n\r\n我们将前一条公式代入，因此有了：\r\n\r\n$$\r\n10 x_i + 1 = 10 (pK + q) + 1 = 10 pK + 10 q + 1\r\n$$\r\n\r\n由于等号两边相等，那么在两边分别对$K$取余，其结果也应该相等。\r\n\r\n$$\r\n(10 x_i + 1) \\% K = (10 pK + 10 q + 1) \\% K\r\n$$\r\n\r\n观察等式右侧，有一项$10 pK$，由于它是$K$的倍数，因此无论$p$为何值，这一项都不会影响最终结果，因此将它去掉，得到：\r\n\r\n$$\r\n(10 x_i + 1) \\% K = (10 q + 1) \\% K\r\n$$\r\n\r\n由于$x = pK + q$，我们能够推出$x \\% K = q$，带入上式：\r\n\r\n$$\r\n(10 x_i + 1) \\% K = (10 (x_i \\% K) + 1) \\% K\r\n$$\r\n\r\n再看一眼上一节中的代码：\r\n\r\n```java\r\nwhile (x % K != 0) {\r\n    x = x * 10 + 1;\r\n}\r\n```\r\n\r\n最后的公式告诉我们，`x * 10 + 1`和`(x % K) * 10 + 1`在后续判断`x % K != 0`时是没有任何区别的。因此我们可以将代码改成：\r\n\r\n```java\r\nwhile (x % K != 0) {\r\n    x = x % K;\r\n    x = x * 10 + 1;\r\n}\r\n```\r\n\r\n这样就可以避免`x`超范围了。\r\n\r\n### 数学证明\r\n\r\n上述算法有没有什么漏洞呢？我们来分析一下。\r\n\r\n##### 必要性\r\n\r\n设上述程序执行完`x = x % K`这一句后，$x$的值（或者称为状态）为$S$。\r\n\r\n那么一共有多少种$S$呢？由于刚刚执行完`x = x % K`，所以$x$是不可能大于等于$K$的，因此$S$种类数不会超过$K$。\r\n\r\n那么求解答案的过程中，可不可以重复经过某个状态$S_i$呢？不可以，因为相同的$x$值必然在后续的`x = x * 10 + 1`等语句中产生相同的结果，程序则必然陷入死循环。\r\n\r\n那么，什么样的$K$会使程序重复经过某个状态$S_i$呢？\r\n\r\n程序求解过程中，设程序经历了如下状态序列：$S_1$，$S_2$，$S_3$，$\\dots$，$S_i$，$\\dots$，$S_j$，$\\dots$，$S_n$。\r\n\r\n假设，存在$S_i = S_j$，也就是：\r\n\r\n$$\r\n(10 S_{i-1} + 1) \\% K = (10 S_{j-1} + 1) \\% K\r\n$$\r\n\r\n让我们把取余操作去掉，于是等式变成了：\r\n\r\n$$\r\n10 S_{i-1} + 1 = 10 S_{j-1} + 1 + a K\r\n$$\r\n\r\n其中，$a$是一个能使等式成立的值，类似上面的$p$、$q$。我们整理一下这个等式（假设$S_{i-1} > S_{j-1}$）：\r\n\r\n$$\r\nS_{i-1} - S_{j-1} = \\frac{aK}{10}\r\n$$\r\n\r\n$a$的取值范围是多少呢？$S_{i-1}$和$S_{j-1}$都是小于$K$的（因为他们也刚经历了`x = x % K`语句），因此$0 < 10(S_{i-1} - S_{j-1}) < 10K$，所以$0 < a < 10$。\r\n\r\n使用一个大于0，小于10的整数，如何消除分母上的10，使得$\\frac{aK}{10}$成为一个整数呢？那就只有$2 \\times 5 = 10$这条路了。\r\n\r\n因此只有$K$是2或5的倍数时，我们才能找到一个$a$的值，使$\\frac{aK}{10}$成为一个整数，使$S_{i-1} - S_{j-1} = \\frac{aK}{10}$成立，使$S_i = S_j$成立，最终程序会死循环。此时我们可以得到结论：假设陷入了死循环，$K$只能是2或5的倍数。\r\n\r\n##### 充分性\r\n\r\n我们回到这个关键的式子：\r\n\r\n$$\r\n(10 S_{i-1} + 1) \\% K = (10 S_{j-1} + 1) \\% K\r\n$$\r\n\r\n忘记证明必要性时的那一大堆文字吧，回归最简单的思考。大家看看上面的式子，$K = 2$或者$K = 5$的时候上面的式子必然成立，因为此时$10 S_{i-1}$和$10 S_{j-1}$一定被$K$整除。充分性得证，如果$K$是2或5的倍数，则一定陷入死循环。\r\n\r\n##### Java代码\r\n\r\n结合必要性和充分性，我们可以得到结论：程序陷入死循环，当且仅当$K$是2或5的倍数。\r\n\r\n所以，最终的程序如下所示：\r\n\r\n```java\r\npublic static int smallestRepunitDivByK(int K) {\r\n    if (K % 2 == 0 || K % 5 == 0) {\r\n        return -1;\r\n    }\r\n    int temp = 1;\r\n    int len = 1;\r\n    while (temp % K != 0) {\r\n        temp = temp % K;\r\n        temp = temp * 10 + 1;\r\n        len += 1;\r\n    }\r\n    return len;\r\n}\r\n```\r\n\r\n感谢[@dan-huang-jiang-xing-ren](/u/dan-huang-jiang-xing-ren/)在评论中指出第一版题解的问题！\r\n"
}