{
	"titleSlug": "trim-a-binary-search-tree",
	"slug": "xiu-jian-er-cha-sou-suo-shu-by-leetcode-qe7q1",
	"url": "https://leetcode-cn.com/problems/trim-a-binary-search-tree/solution/xiu-jian-er-cha-sou-suo-shu-by-leetcode-qe7q1/",
	"content": "#### 方法一：递归\n\n对根结点 $\\textit{root}$ 进行深度优先遍历。对于当前访问的结点，如果结点为空结点，直接返回空结点；如果结点的值小于 $\\textit{low}$，那么说明该结点及它的左子树都不符合要求，我们返回对它的右结点进行修剪后的结果；如果结点的值大于 $\\textit{high}$，那么说明该结点及它的右子树都不符合要求，我们返回对它的左子树进行修剪后的结果；如果结点的值位于区间 $[\\textit{low}, \\textit{high}]$，我们将结点的左结点设为对它的左子树修剪后的结果，右结点设为对它的右子树进行修剪后的结果。\n\n```Python [sol1-Python3]\nclass Solution:\n    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:\n        if root is None:\n            return None\n        if root.val < low:\n            return self.trimBST(root.right, low, high)\n        if root.val > high:\n            return self.trimBST(root.left, low, high)\n        root.left = self.trimBST(root.left, low, high)\n        root.right = self.trimBST(root.right, low, high)\n        return root\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if (root == nullptr) {\n            return nullptr;\n        }\n        if (root->val < low) {\n            return trimBST(root->right, low, high);\n        } else if (root->val > high) {\n            return trimBST(root->left, low, high);\n        } else {\n            root->left = trimBST(root->left, low, high);\n            root->right = trimBST(root->right, low, high);\n            return root;\n        }\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        if (root == null) {\n            return null;\n        }\n        if (root.val < low) {\n            return trimBST(root.right, low, high);\n        } else if (root.val > high) {\n            return trimBST(root.left, low, high);\n        } else {\n            root.left = trimBST(root.left, low, high);\n            root.right = trimBST(root.right, low, high);\n            return root;\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public TreeNode TrimBST(TreeNode root, int low, int high) {\n        if (root == null) {\n            return null;\n        }\n        if (root.val < low) {\n            return TrimBST(root.right, low, high);\n        } else if (root.val > high) {\n            return TrimBST(root.left, low, high);\n        } else {\n            root.left = TrimBST(root.left, low, high);\n            root.right = TrimBST(root.right, low, high);\n            return root;\n        }\n    }\n}\n```\n\n```C [sol1-C]\nstruct TreeNode* trimBST(struct TreeNode* root, int low, int high){\n    if (root == NULL) {\n        return NULL;\n    }\n    if (root->val < low) {\n        return trimBST(root->right, low, high);\n    } else if (root->val > high) {\n        return trimBST(root->left, low, high);\n    } else {\n        root->left = trimBST(root->left, low, high);\n        root->right = trimBST(root->right, low, high);\n        return root;\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar trimBST = function(root, low, high) {\n    if (!root) {\n        return null;\n    }\n    if (root.val < low) {\n        return trimBST(root.right, low, high);\n    } else if (root.val > high) {\n        return trimBST(root.left, low, high);\n    } else {\n        root.left = trimBST(root.left, low, high);\n        root.right = trimBST(root.right, low, high);\n        return root;\n    }\n};\n```\n\n```go [sol1-Golang]\nfunc trimBST(root *TreeNode, low, high int) *TreeNode {\n    if root == nil {\n        return nil\n    }\n    if root.Val < low {\n        return trimBST(root.Right, low, high)\n    }\n    if root.Val > high {\n        return trimBST(root.Left, low, high)\n    }\n    root.Left = trimBST(root.Left, low, high)\n    root.Right = trimBST(root.Right, low, high)\n    return root\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数目。\n\n+ 空间复杂度：$O(n)$。递归栈最坏情况下需要 $O(n)$ 的空间。\n\n#### 方法二：迭代\n\n如果一个结点 $\\textit{node}$ 符合要求，即它的值位于区间 $[\\textit{low}, \\textit{high}]$，那么它的左子树与右子树应该如何修剪？\n\n我们先讨论左子树的修剪：\n\n+ $node$ 的左结点为空结点：不需要修剪\n\n+ $node$ 的左结点非空：\n\n    + 如果它的左结点 $\\textit{left}$ 的值小于 $\\textit{low}$，那么 $\\textit{left}$ 以及 $\\textit{left}$ 的左子树都不符合要求，我们将 $\\textit{node}$ 的左结点设为 $\\textit{left}$ 的右结点，然后再重新对 $\\textit{node}$ 的左子树进行修剪。\n    \n    + 如果它的左结点 $\\textit{left}$ 的值大于等于 $\\textit{low}$，又因为 $\\textit{node}$ 的值已经符合要求，所以 $\\textit{left}$ 的右子树一定符合要求。基于此，我们只需要对 $\\textit{left}$ 的左子树进行修剪。我们令 $\\textit{node}$ 等于 $\\textit{left}$ ，然后再重新对 $\\textit{node}$ 的左子树进行修剪。\n    \n以上过程可以迭代处理。对于右子树的修剪同理。\n\n我们对根结点进行判断，如果根结点不符合要求，我们将根结点设为对应的左结点或右结点，直到根结点符合要求，然后将根结点作为符合要求的结点，依次修剪它的左子树与右子树。\n\n```Python [sol2-Python3]\nclass Solution:\n    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:\n        while root and (root.val < low or root.val > high):\n            root = root.right if root.val < low else root.left\n        if root is None:\n            return None\n        node = root\n        while node.left:\n            if node.left.val < low:\n                node.left = node.left.right\n            else:\n                node = node.left\n        node = root\n        while node.right:\n            if node.right.val > high:\n                node.right = node.right.left\n            else:\n                node = node.right\n        return root\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        while (root && (root->val < low || root->val > high)) {\n            if (root->val < low) {\n                root = root->right;\n            } else {\n                root = root->left;\n            }\n        }\n        if (root == nullptr) {\n            return nullptr;\n        }\n        for (auto node = root; node->left; ) {\n            if (node->left->val < low) {\n                node->left = node->left->right;\n            } else {\n                node = node->left;\n            }\n        }\n        for (auto node = root; node->right; ) {\n            if (node->right->val > high) {\n                node->right = node->right->left;\n            } else {\n                node = node->right;\n            }\n        }\n        return root;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        while (root != null && (root.val < low || root.val > high)) {\n            if (root.val < low) {\n                root = root.right;\n            } else {\n                root = root.left;\n            }\n        }\n        if (root == null) {\n            return null;\n        }\n        for (TreeNode node = root; node.left != null; ) {\n            if (node.left.val < low) {\n                node.left = node.left.right;\n            } else {\n                node = node.left;\n            }\n        }\n        for (TreeNode node = root; node.right != null; ) {\n            if (node.right.val > high) {\n                node.right = node.right.left;\n            } else {\n                node = node.right;\n            }\n        }\n        return root;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public TreeNode TrimBST(TreeNode root, int low, int high) {\n        while (root != null && (root.val < low || root.val > high)) {\n            if (root.val < low) {\n                root = root.right;\n            } else {\n                root = root.left;\n            }\n        }\n        if (root == null) {\n            return null;\n        }\n        for (TreeNode node = root; node.left != null; ) {\n            if (node.left.val < low) {\n                node.left = node.left.right;\n            } else {\n                node = node.left;\n            }\n        }\n        for (TreeNode node = root; node.right != null; ) {\n            if (node.right.val > high) {\n                node.right = node.right.left;\n            } else {\n                node = node.right;\n            }\n        }\n        return root;\n    }\n}\n```\n\n```C [sol2-C]\nstruct TreeNode* trimBST(struct TreeNode* root, int low, int high){\n    while (root && (root->val < low || root->val > high)) {\n        if (root->val < low) {\n            root = root->right;\n        } else {\n            root = root->left;\n        }\n    }\n    if (root == NULL) {\n        return NULL;\n    }\n    for (struct TreeNode* node = root; node->left; ) {\n        if (node->left->val < low) {\n            node->left = node->left->right;\n        } else {\n            node = node->left;\n        }\n    }\n    for (struct TreeNode* node = root; node->right; ) {\n        if (node->right->val > high) {\n            node->right = node->right->left;\n        } else {\n            node = node->right;\n        }\n    }\n    return root;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar trimBST = function(root, low, high) {\n    while (root && (root.val < low || root.val > high)) {\n        if (root.val < low) {\n            root = root.right;\n        } else {\n            root = root.left;\n        }\n    }\n    if (!root) {\n        return null;\n    }\n    for (let node = root; node.left; ) {\n        if (node.left.val < low) {\n            node.left = node.left.right;\n        } else {\n            node = node.left;\n        }\n    }\n    for (let node = root; node.right; ) {\n        if (node.right.val > high) {\n            node.right = node.right.left;\n        } else {\n            node = node.right;\n        }\n    }\n    return root;\n};\n```\n\n```go [sol2-Golang]\nfunc trimBST(root *TreeNode, low, high int) *TreeNode {\n    for root != nil && (root.Val < low || root.Val > high) {\n        if root.Val < low {\n            root = root.Right\n        } else {\n            root = root.Left\n        }\n    }\n    if root == nil {\n        return nil\n    }\n    for node := root; node.Left != nil; {\n        if node.Left.Val < low {\n            node.Left = node.Left.Right\n        } else {\n            node = node.Left\n        }\n    }\n    for node := root; node.Right != nil; {\n        if node.Right.Val > high {\n            node.Right = node.Right.Left\n        } else {\n            node = node.Right\n        }\n    }\n    return root\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数目。最多访问 $n$ 个结点。\n\n+ 空间复杂度：$O(1)$。"
}