{
	"titleSlug": "find-k-pairs-with-smallest-sums",
	"slug": "cha-zhao-he-zui-xiao-de-kdui-shu-zi-by-l-z526",
	"url": "https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/solution/cha-zhao-he-zui-xiao-de-kdui-shu-zi-by-l-z526/",
	"content": "#### 方法一：优先队列\n\n**思路**\n\n本题与「[719. 找出第 k 小的距离对](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)」相似，可以参考该题的解法。对于已经按升序排列的两个数组 $\\textit{nums}_1,\\textit{nums}_2$，长度分别为 $\\textit{length}_1,\\textit{length}_2$，我们可以知道和最小的数对一定为 $(\\textit{nums}_1[0], \\textit{nums}_2[0])$，和最大的数对一定为 $(\\textit{nums}_1[\\textit{length}_1-1], \\textit{nums}_2[\\textit{length}_2-1])$。本题要求找到最小的 $k$ 个数对，最直接的办法是可以将所有的数对求出来，然后利用排序或者 $\\texttt{TopK}$ 解法求出最小的 $k$ 个数对即可。实际求解时可以不用求出所有的数对，只需从所有符合待选的数对中选出最小的即可，假设当前已选的前 $n$ 小数对的索引分别为 $(a_1,b_1),(a_2,b_2),(a_3,b_3),\\ldots,(a_n,b_n)$，由于两个数组都是按照升序进行排序的，则可以推出第 $n+1$ 小的数对的索引选择范围为 $(a_1+1,b_1),(a_1,b_1+1),(a_2+1,b_2),(a_2,b_2+1),(a_3+1,b_3),(a_3,b_3+1),\\ldots,(a_n+1,b_n),(a_n,b_n+1)$，假设我们利用堆的特性可以求出待选范围中最小数对的索引为 $(a_{i},b_{i})$，同时将新的待选的数对 $(a_{i}+1,b_{i}),(a_{i},b_{i}+1)$ 加入到堆中，直到我们选出 $k$ 个数对即可。\n+ 如果我们每次都将已选的数对 $(a_{i},b_{i})$ 的待选索引 $(a_{i}+1,b_{i}),(a_{i},b_{i}+1)$ 加入到堆中则可能出现重复的问题，一般需要设置标记位解决去重的问题。我们可以将 $\\textit{nums}_1$ 的前 $k$ 个索引数对 $(0,0),(1,0),\\ldots,(k-1,0)$ 加入到队列中，每次从队列中取出元素 $(x,y)$ 时，我们只需要将 $\\textit{nums}_2$ 的索引增加即可，这样避免了重复加入元素的问题。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>(k, (o1, o2)->{\n            return nums1[o1[0]] + nums2[o1[1]] - nums1[o2[0]] - nums2[o2[1]];\n        });\n        List<List<Integer>> ans = new ArrayList<>();\n        int m = nums1.length;\n        int n = nums2.length;\n        for (int i = 0; i < Math.min(m, k); i++) {\n            pq.offer(new int[]{i,0});\n        }\n        while (k-- > 0 && !pq.isEmpty()) {\n            int[] idxPair = pq.poll();\n            List<Integer> list = new ArrayList<>();\n            list.add(nums1[idxPair[0]]);\n            list.add(nums2[idxPair[1]]);\n            ans.add(list);\n            if (idxPair[1] + 1 < n) {\n                pq.offer(new int[]{idxPair[0], idxPair[1] + 1});\n            }\n        }\n        \n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        auto cmp = [&nums1, &nums2](const pair<int, int> & a, const pair<int, int> & b) {\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\n        };\n\n        int m = nums1.size();\n        int n = nums2.size();\n        vector<vector<int>> ans;   \n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);\n        for (int i = 0; i < min(k, m); i++) {\n            pq.emplace(i, 0);\n        }\n        while (k-- > 0 && !pq.empty()) {\n            auto [x, y] = pq.top(); \n            pq.pop();\n            ans.emplace_back(initializer_list<int>{nums1[x], nums2[y]});\n            if (y + 1 < n) {\n                pq.emplace(x, y + 1);\n            }\n        }\n\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        m, n = len(nums1), len(nums2)\n        ans = []\n        pq = [(nums1[i] + nums2[0], i, 0) for i in range(min(k, m))]\n        while pq and len(ans) < k:\n            _, i, j = heappop(pq)\n            ans.append([nums1[i], nums2[j]])\n            if j + 1 < n:\n                heappush(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n        return ans\n```\n\n```go [sol1-Golang]\nfunc kSmallestPairs(nums1, nums2 []int, k int) (ans [][]int) {\n    m, n := len(nums1), len(nums2)\n    h := hp{nil, nums1, nums2}\n    for i := 0; i < k && i < m; i++ {\n        h.data = append(h.data, pair{i, 0})\n    }\n    for h.Len() > 0 && len(ans) < k {\n        p := heap.Pop(&h).(pair)\n        i, j := p.i, p.j\n        ans = append(ans, []int{nums1[i], nums2[j]})\n        if j+1 < n {\n            heap.Push(&h, pair{i, j + 1})\n        }\n    }\n    return\n}\n\ntype pair struct{ i, j int }\ntype hp struct {\n    data         []pair\n    nums1, nums2 []int\n}\nfunc (h hp) Len() int            { return len(h.data) }\nfunc (h hp) Less(i, j int) bool  { a, b := h.data[i], h.data[j]; return h.nums1[a.i]+h.nums2[a.j] < h.nums1[b.i]+h.nums2[b.j] }\nfunc (h hp) Swap(i, j int)       { h.data[i], h.data[j] = h.data[j], h.data[i] }\nfunc (h *hp) Push(v interface{}) { h.data = append(h.data, v.(pair)) }\nfunc (h *hp) Pop() interface{}   { a := h.data; v := a[len(a)-1]; h.data = a[:len(a)-1]; return v }\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(k \\log k)$，其中 $k$ 是选择的数对的数目。优先队列中最多只保存 $k$ 个元素，每次压入新的元素队列进行调整的时间复杂度为 $\\log k$，入队操作一共有 $2k$ 次, 一共需要从队列中弹出 $k$ 个数据。\n\n- 空间复杂度：$O(k)$。优先队列中最多只保存 $k$ 个元素。\n\n#### 方法二：二分查找\n\n**思路**\n\n参考「[378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)」的二分查找的解法，我们利用二分查找找到第 $k$ 小的数对和为 $\\textit{pairSum}$。利用滑动窗口即可计算出两个数组中满足数对和小于等于目标值 $\\textit{target}$ 的数对有多少个，我们找到最小的 $\\textit{target}$ 且满足小于等于它的数对数目刚好大于等于 $k$ 即为目标值 $\\textit{pairSum}$，然后在数组中找到最小的 $k$ 个数对满足数对和小于等于 $\\textit{pairSum}$。\n+ 由于题目中数组 $\\textit{nums}_1,\\textit{nums}_2$ 中的元素存在重复，因此我们不能简单的利用滑动窗口找到所有满足小于等于 $\\textit{pairSum}$ 的数对。因为存在小于等于 $\\textit{pairSum}$ 的数对和的数目大于 $k$，因此数对和等于 $\\textit{pairSum}$ 的数对不一定就属于最小的 $k$ 个数对。\n+ 首先利用滑动窗口找到所有小于 $\\textit{pairSum}$ 的数对，假设数对和小于 $\\textit{pairSum}$ 的数目为 $x$ 个，然后再利用二分查找在数组中找到 $k-x$ 个和等于 $\\textit{pairSum}$ 的数对即可。\n\n**代码**\n\n```Java [sol2-Java]\nclass Solution {\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        int m = nums1.length;\n        int n = nums2.length;\n\n        /*二分查找第 k 小的数对和的大小*/\n        int left = nums1[0] + nums2[0];\n        int right = nums1[m - 1] + nums2[n - 1];\n        int pairSum = right;\n        while (left <= right) {\n            int mid = left + ((right - left) >> 1);\n            long cnt = 0;\n            int start = 0;\n            int end = n - 1;\n            while (start < m && end >= 0) {\n                if (nums1[start] + nums2[end] > mid) {\n                    end--;\n                } else {\n                    cnt += end + 1;\n                    start++;\n                }\n            }\n            if (cnt < k) {\n                left = mid + 1;\n            } else {\n                pairSum = mid;\n                right = mid - 1;\n            }\n        }\n\n        List<List<Integer>> ans = new ArrayList<>();\n        int pos = n - 1;\n        /*找到小于目标值 pairSum 的数对*/\n        for (int i = 0; i < m; i++) {\n            while (pos >= 0 && nums1[i] + nums2[pos] >= pairSum) {\n                pos--;\n            }\n            for (int j = 0; j <= pos && k > 0; j++, k--) {\n                List<Integer> list = new ArrayList<>();\n                list.add(nums1[i]);\n                list.add(nums2[j]);\n                ans.add(list);\n            }\n        }\n\n        /*找到等于目标值 pairSum 的数对*/\n        pos = n - 1;\n        for (int i = 0; i < m && k > 0; i++) {\n            int start1 = i;\n            while (i < m - 1 && nums1[i] == nums1[i + 1]) {\n                i++;\n            }\n            while (pos >= 0 && nums1[i] + nums2[pos] > pairSum) {\n                pos--;\n            }\n            int start2 = pos;\n            while (pos > 0 && nums2[pos] == nums2[pos - 1]) {\n                pos--;\n            }\n            if (nums1[i] + nums2[pos] != pairSum) {\n                continue;\n            }\n            int count = (int) Math.min(k, (long) (i - start1 + 1) * (start2 - pos + 1));\n            for (int j = 0; j < count && k > 0; j++, k--) {\n                List<Integer> list = new ArrayList<>();\n                list.add(nums1[i]);\n                list.add(nums2[pos]);\n                ans.add(list);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        int m = nums1.size();\n        int n = nums2.size();\n        auto count = [&](int target){\n            long long cnt = 0;\n            int start = 0;\n            int end = n - 1;\n            while (start < m && end >= 0) {\n                if (nums1[start] + nums2[end] > target) {\n                    end--;\n                } else {\n                    cnt += end + 1;\n                    start++;\n                }\n            }\n            return cnt;\n        };\n\n        /*二分查找第 k 小的数对和的大小*/\n        int left = nums1[0] + nums2[0];\n        int right = nums1.back() + nums2.back();\n        int pairSum = right;\n        while (left <= right) {\n            int mid = left + ((right - left) >> 1);\n            if (count(mid) < k) {\n                left = mid + 1;\n            } else {\n                pairSum = mid;\n                right = mid - 1;\n            }\n        }\n\n        vector<vector<int>> ans;\n        int pos = n - 1;\n        /*找到小于目标值 pairSum 的数对*/\n        for (int i = 0; i < m; i++) {\n            while (pos >= 0 && nums1[i] + nums2[pos] >= pairSum) {\n                pos--;\n            }\n            for (int j = 0; j <= pos && k > 0; j++, k--) {\n                ans.push_back({nums1[i], nums2[j]});\n            }\n        }\n        /*找到等于目标值 pairSum 的数对*/\n        pos = n - 1;\n        for (int i = 0; i < m && k > 0; i++) {\n            int start1 = i;\n            while (i < m - 1 && nums1[i] == nums1[i + 1]) {\n                i++;\n            }\n            while (pos >= 0 && nums1[i] + nums2[pos] > pairSum) {\n                pos--;\n            }\n            int start2 = pos;\n            while (pos > 0 && nums2[pos] == nums2[pos - 1]) {\n                pos--;\n            }\n            if (nums1[i] + nums2[pos] != pairSum) {\n                continue;\n            }\n            int count = (int) min((long) k, (long) (i - start1 + 1) * (start2 - pos + 1));\n            for (int j = 0; j < count && k > 0; j++, k--) {\n                ans.push_back({nums1[i], nums2[pos]});\n            }\n        }\n        return ans;\n    }\n\n    long min(long num1, long num2) {\n        return num1 <= num2 ? num1 : num2;\n    }\n};\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k) {\n        int m = nums1.Length;\n        int n = nums2.Length;\n\n        /*二分查找第 k 小的数对和的大小*/\n        int left = nums1[0] + nums2[0];\n        int right = nums1[m - 1] + nums2[n - 1];\n        int pairSum = right;\n        while (left <= right) {\n            int mid = left + ((right - left) >> 1);\n            long cnt = 0;\n            int start = 0;\n            int end = n - 1;\n            while (start < nums1.Length && end >= 0) {\n                if (nums1[start] + nums2[end] > mid) {\n                    end--;\n                } else {\n                    cnt += end + 1;\n                    start++;\n                }\n            }\n            if (cnt < k) {\n                left = mid + 1;\n            } else {\n                pairSum = mid;\n                right = mid - 1;\n            }\n        }\n\n        IList<IList<int>> ans = new List<IList<int>>();\n        int pos = n - 1;\n        /*找到小于目标值 pairSum 的数对*/\n        for (int i = 0; i < m; i++) {\n            while (pos >= 0 && nums1[i] + nums2[pos] >= pairSum) {\n                pos--;\n            }\n            for (int j = 0; j <= pos && k > 0; j++, k--) {\n                IList<int> list = new List<int>();\n                list.Add(nums1[i]);\n                list.Add(nums2[j]);\n                ans.Add(list);\n            }\n        }\n\n        /*找到等于目标值 pairSum 的数对*/\n        pos = n - 1;\n        for (int i = 0; i < m && k > 0; i++) {\n            int start1 = i;\n            while (i < m - 1 && nums1[i] == nums1[i + 1]) {\n                i++;\n            }\n            while (pos >= 0 && nums1[i] + nums2[pos] > pairSum) {\n                pos--;\n            }\n            int start2 = pos;\n            while (pos > 0 && nums2[pos] == nums2[pos - 1]) {\n                pos--;\n            }\n            if (nums1[i] + nums2[pos] != pairSum) {\n                continue;\n            }\n            int count = (int) Math.Min(k, (long) (i - start1 + 1) * (start2 - pos + 1));\n            for (int j = 0; j < count && k > 0; j++, k--) {\n                IList<int> list = new List<int>();\n                list.Add(nums1[i]);\n                list.Add(nums2[pos]);\n                ans.Add(list);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol2-C]\n#define MIN(a, b) ((a) > (b) ? (b) : (a))\n\nint** kSmallestPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize, int** returnColumnSizes) {\n    if (nums1Size == 0 || nums2Size == 0 || k <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n\n    /*二分查找第 k 小的数对和的大小*/\n    int left = nums1[0] + nums2[0];\n    int right = nums1[nums1Size - 1] + nums2[nums2Size - 1];\n    int pairSum = right;\n    while (left <= right) {\n        int mid = left + ((right - left) >> 1);\n        long long cnt = 0;\n        int start = 0;\n        int end = nums2Size - 1;\n        while (start < nums1Size && end >= 0) {\n            if (nums1[start] + nums2[end] > mid) {\n                end--;\n            } else {\n                cnt += end + 1;\n                start++;\n            }\n        }\n        if (cnt < k) {\n            left = mid + 1;\n        } else {\n            pairSum = mid;\n            right = mid - 1;\n        }\n    }\n\n    int ** ans = (int **)malloc(sizeof(int *) * k);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * k);\n    int currSize = 0;\n    int pos = nums2Size - 1;\n    /*找到小于目标值 pairSum 的数对*/\n    for (int i = 0; i < nums1Size; i++) {\n        while (pos >= 0 && nums1[i] + nums2[pos] >= pairSum) {\n            pos--;\n        }\n        for (int j = 0; j <= pos && k > 0; j++, k--) {\n            ans[currSize] = (int *)malloc(sizeof(int) * 2);\n            ans[currSize][0] = nums1[i];\n            ans[currSize][1] = nums2[j];\n            (*returnColumnSizes)[currSize] = 2;\n            currSize++;\n        }\n    }\n\n    /*找到等于目标值 pairSum 的数对*/\n    pos = nums2Size - 1;\n    for (int i = 0; i < nums1Size && k > 0; i++) {\n        int start1 = i;\n        while (i < nums1Size - 1 && nums1[i] == nums1[i + 1]) {\n            i++;\n        }\n        while (pos >= 0 && nums1[i] + nums2[pos] > pairSum) {\n            pos--;\n        }\n        int start2 = pos;\n        while (pos > 0 && nums2[pos] == nums2[pos - 1]) {\n            pos--;\n        }\n        if (nums1[i] + nums2[pos] != pairSum) {\n            continue;\n        }\n        int count = (int) MIN(k, (long) (i - start1 + 1) * (start2 - pos + 1));\n        for (int j = 0; j < count && k > 0; j++, k--) {\n            ans[currSize] = (int *)malloc(sizeof(int) * 2);\n            ans[currSize][0] = nums1[i];\n            ans[currSize][1] = nums2[pos];\n            (*returnColumnSizes)[currSize] = 2;\n            currSize++;\n        }\n    }\n    *returnSize = currSize;\n    return ans;\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        m, n = len(nums1), len(nums2)\n\n        # 二分查找第 k 小的数对和\n        left, right = nums1[0] + nums2[0], nums1[m - 1] + nums2[n - 1] + 1\n        while left < right:\n            mid = (left + right) // 2\n            cnt = 0\n            i, j = 0, n - 1\n            while i < m and j >= 0:\n                if nums1[i] + nums2[j] > mid:\n                    j -= 1\n                else:\n                    cnt += j + 1\n                    i += 1\n            if cnt < k:\n                left = mid + 1\n            else:\n                right = mid\n        pairSum = left\n\n        ans = []\n        # 找数对和小于 pairSum 的数对\n        i = n - 1\n        for num1 in nums1:\n            while i >= 0 and num1 + nums2[i] >= pairSum:\n                i -= 1\n            for j in range(i + 1):\n                ans.append([num1, nums2[j]])\n                if len(ans) == k:\n                    return ans\n\n        # 找数对和等于 pairSum 的数对\n        i = n - 1\n        for num1 in nums1:\n            while i >= 0 and num1 + nums2[i] > pairSum:\n                i -= 1\n            j = i\n            while j >= 0 and num1 + nums2[j] == pairSum:\n                ans.append([num1, nums2[j]])\n                if len(ans) == k:\n                    return ans\n                j -= 1\n        return ans\n```\n\n```go [sol2-Golang]\nfunc kSmallestPairs(nums1, nums2 []int, k int) (ans [][]int) {\n    m, n := len(nums1), len(nums2)\n\n    // 二分查找第 k 小的数对和\n    left, right := nums1[0]+nums2[0], nums1[m-1]+nums2[n-1]+1\n    pairSum := left + sort.Search(right-left, func(sum int) bool {\n        sum += left\n        cnt := 0\n        i, j := 0, n-1\n        for i < m && j >= 0 {\n            if nums1[i]+nums2[j] > sum {\n                j--\n            } else {\n                cnt += j + 1\n                i++\n            }\n        }\n        return cnt >= k\n    })\n\n    // 找数对和小于 pairSum 的数对\n    i := n - 1\n    for _, num1 := range nums1 {\n        for i >= 0 && num1+nums2[i] >= pairSum {\n            i--\n        }\n        for _, num2 := range nums2[:i+1] {\n            ans = append(ans, []int{num1, num2})\n            if len(ans) == k {\n                return\n            }\n        }\n    }\n\n    // 找数对和等于 pairSum 的数对\n    i = n - 1\n    for _, num1 := range nums1 {\n        for i >= 0 && num1+nums2[i] > pairSum {\n            i--\n        }\n        for j := i; j >= 0 && num1+nums2[j] == pairSum; j-- {\n            ans = append(ans, []int{num1, nums2[j]})\n            if len(ans) == k {\n                return\n            }\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar kSmallestPairs = function(nums1, nums2, k) {\n    m = nums1.length\n    n = nums2.length\n    /*二分查找第 k 小的数对和的大小*/\n    let left = nums1[0] + nums2[0];\n    let right = nums1[m - 1] + nums2[n - 1];\n    let pairSum = right;\n    while (left <= right) {\n        const mid = left + ((right - left) >> 1);\n        let cnt = 0;\n        let start = 0;\n        let end = n - 1;\n        while (start < m && end >= 0) {\n            if (nums1[start] + nums2[end] > mid) {\n                end--;\n            } else {\n                cnt += end + 1;\n                start++;\n            }\n        }\n        if (cnt < k) {\n            left = mid + 1;\n        } else {\n            pairSum = mid;\n            right = mid - 1;\n        }\n    }\n\n    const ans = [];\n    let pos = n - 1;\n    /*找到小于目标值 pairSum 的数对*/\n    for (let i = 0; i < m; i++) {\n        while (pos >= 0 && nums1[i] + nums2[pos] >= pairSum) {\n            pos--;\n        }\n        for (let j = 0; j <= pos && k > 0; j++, k--) {\n            const list = [];\n            list.push(nums1[i]);\n            list.push(nums2[j]);\n            ans.push(list);\n        }\n    }\n\n    /*找到等于目标值 pairSum 的数对*/\n    pos = n - 1;\n    for (let i = 0; i < m && k > 0; i++) {\n        let start1 = i;\n        while (i < m - 1 && nums1[i] == nums1[i + 1]) {\n            i++;\n        }\n        while (pos >= 0 && nums1[i] + nums2[pos] > pairSum) {\n            pos--;\n        }\n        let start2 = pos;\n        while (pos > 0 && nums2[pos] == nums2[pos - 1]) {\n            pos--;\n        }\n        if (nums1[i] + nums2[pos] != pairSum) {\n            continue;\n        }\n        let count = Math.min(k, (i - start1 + 1) * (start2 - pos + 1));\n        for (let j = 0; j < count && k > 0; j++, k--) {\n            const list = [];\n            list.push(nums1[i]);\n            list.push(nums2[pos]);\n            ans.push(list);\n        }\n    }\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(k + (m + n) \\times \\log(\\textit{diff}(\\textit{nums}_1) + \\textit{diff}(\\textit{nums}_2)))$，其中 $m, n$ 表示数组 $\\textit{nums}_1,\\textit{nums}_2$ 的长度，$\\textit{diff}(arr)$ 表示数组 $arr$ 中最大元素与最小元素之差，$\\textit{diff}(\\textit{nums}_1) = \\max(\\textit{nums}_1) - \\min(\\textit{nums}_1), \\textit{diff}(\\textit{nums}_2) = \\max(\\textit{nums}_2) - \\min(\\textit{nums}_2))$。我们利用二分查找找到满足要求的数对和的时间复杂度为 $(m + n) \\times \\log(\\textit{diff}(\\textit{nums}_1) + \\textit{diff}(\\textit{nums}_2))$，我们利用滑动窗口找到小于等于目标值的 $k$ 个数对的时间复杂度为 $O(2 \\times (k + m + n))$，所以总的时间复杂度 $O(2 \\times (k + m + n) + (m + n) \\times \\log(\\textit{diff}(\\textit{nums}_1) + \\textit{diff}(\\textit{nums}_2))) = k + (m + n) \\times \\log(\\textit{diff}(\\textit{nums}_1) + \\textit{diff}(\\textit{nums}_2))$。\n\n- 空间复杂度：$O(1)$，除了函数返回值以外，不需要额外的存储空间。"
}