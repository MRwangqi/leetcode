{
	"titleSlug": "determine-if-two-strings-are-close",
	"slug": "1657-que-ding-liang-ge-zi-fu-chuan-shi-f-r9on",
	"url": "https://leetcode-cn.com/problems/determine-if-two-strings-are-close/solution/1657-que-ding-liang-ge-zi-fu-chuan-shi-f-r9on/",
	"content": "### 解题思路\n\n像极了找充分必要条件。\n\n如果类型一致，数量也有匹配。\n\n交换排序，总能对上\n\n有贪心，有哈希，有排序，有双针。\n\n\n-----\n\n\n##### [简单] 1346. 检查整数及其两倍数是否存在【数组】【哈希表】【双指针】【二分查找】【排序】[[排序 + 哈希表](https://leetcode-cn.com/problems/check-if-n-and-its-double-exist/solution/1346-jian-cha-zheng-shu-ji-qi-liang-bei-jivzp/)] [[1346. 检查整数及其两倍数是否存在](https://leetcode-cn.com/problems/check-if-n-and-its-double-exist/)]\n\n##### [中等] 1657. 确定两个字符串是否接近【哈希表】【排序】[[哈希表 + 排序](https://leetcode.cn/problems/determine-if-two-strings-are-close/solution/1657-que-ding-liang-ge-zi-fu-chuan-shi-f-r9on/)] [[1657. 确定两个字符串是否接近](https://leetcode.cn/problems/determine-if-two-strings-are-close/)]\n\n### 代码\n\n\n执行用时：13 ms, 在所有 Java 提交中击败了33.64%的用户\n\n内存消耗：41.8 MB, 在所有 Java 提交中击败了92.73%的用户\n\n通过测试用例：152 / 152\n\n```java\nclass Solution {\n\tpublic boolean closeStrings(String word1, String word2) {\n\t\t// 不一样长，false\n\t\tif (word1.length() != word2.length()) {\n\t\t\treturn false;\n\t\t}\n\t\tint type1 = 0, type2 = 0;\n\t\tint[] cnt1 = new int[26], cnt2 = new int[26];\n\t\tfor (int i = 0; i < word1.length(); i++) {\n\t\t\tint c1 = word1.charAt(i) - 'a';\n\t\t\tint c2 = word2.charAt(i) - 'a';\n\t\t\ttype1 |= 1 << c1;\n\t\t\ttype2 |= 1 << c2;\n\t\t\tcnt1[c1]++;\n\t\t\tcnt2[c2]++;\n\t\t}\n\t\t// 类型不一样，false\n\t\tif (type1 != type2) {\n\t\t\treturn false;\n\t\t}\n\t\tArrays.sort(cnt1);\n\t\tArrays.sort(cnt2);\n\t\t// 没有类似数量，false\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (cnt1[i] != cnt2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n```\n执行用时：11 ms, 在所有 Java 提交中击败了55.45%的用户\n\n内存消耗：41.8 MB, 在所有 Java 提交中击败了94.55%的用户\n\n通过测试用例：152 / 152\n\n```java\nclass Solution {\n\tpublic boolean closeStrings(String word1, String word2) {\n\t\t// 不一样长，false\n\t\tif (word1.length() != word2.length()) {\n\t\t\treturn false;\n\t\t}\n\t\tint type1 = 0, type2 = 0;\n\t\tint[] cnt1 = new int[26], cnt2 = new int[26];\n\t\tchar[] cs1 = word1.toCharArray(), cs2 = word2.toCharArray();\n\t\tfor (int i = 0; i < word1.length(); i++) {\n\t\t\tint c1 = cs1[i] - 'a';\n\t\t\tint c2 = cs2[i] - 'a';\n\t\t\ttype1 |= 1 << c1;\n\t\t\ttype2 |= 1 << c2;\n\t\t\tcnt1[c1]++;\n\t\t\tcnt2[c2]++;\n\t\t}\n\t\t// 类型不一样，false\n\t\tif (type1 != type2) {\n\t\t\treturn false;\n\t\t}\n\t\tArrays.sort(cnt1);\n\t\tArrays.sort(cnt2);\n\t\t// 没有类似数量，false\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (cnt1[i] != cnt2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\n```"
}