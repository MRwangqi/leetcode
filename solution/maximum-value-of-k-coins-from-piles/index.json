{
	"titleSlug": "maximum-value-of-k-coins-from-piles",
	"slug": "by-hfhf-8-6la3",
	"url": "https://leetcode-cn.com/problems/maximum-value-of-k-coins-from-piles/solution/by-hfhf-8-6la3/",
	"content": "### 解题思路\n\n一个典型的多重背包问题,不同的点在于每个背包里物品的价值不一样,首先写出它的状态转移方程,从第一个栈开始取出*i*个元素(*i*<=*k*),那么下一个元素就取出*j*个元素(*j*<=*k*-*i*),依次类推,我们用dp\\[m]\\[n]来表示在m个栈内取n个元素之和的最大值,那么我们的转移方程为dp\\[i]\\[j]=dp\\[i-1]\\[j-t]+summary\\[i]\\[t],其中t表示在第i个栈内取了t个元素(*t*<=piles\\[i].size()),summary\\[i]\\[t]表示在这个栈内从顶部向下取出的这t个元素之和。\n在这里我们需实现summary\\[ ]\\[ ]的功能,我们应将它以vector\\<vector>的形式存储,求得每一种组合的和并放入数组中以方便拿取。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int f[1010][2010] ; \n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int Size = piles.size() ;\n        vector<vector<int>>summary(Size);//将每一种取法的和放入其中\n        for(int i=0;i<Size;i++)//第i个栈\n        {\n           int sum=0;\n           summary[i].push_back(sum);\n           for(int j=0;j<piles[i].size();j++)//栈中取j个硬币\n           {\n               sum=sum+piles[i][j];//从栈顶向下取\n               summary[i].push_back(sum);\n           }\n        }\n        for( int i = 0 ; i < Size ; i++){//前i个栈\n            for( int j = 0; j <= k; j++){//取j个硬币\n                for( int t = 0 ; t <= j && t <= piles[i].size(); t++){//在当前栈中取t个硬币\n                    f[i][j] = max(f[i][j],(i==0?0:f[i-1][j-t])+summary[i][t]) ;//注意若i=0时执行f[i-1][j-t]会越界,所以要判断一下\n                }\n            }\n        }\n        return f[Size-1][k] ;\n    }\n};\n```\n"
}