{
	"titleSlug": "smallest-subarrays-with-maximum-bitwise-or",
	"slug": "by-endlesscheng-zai1",
	"url": "https://leetcode-cn.com/problems/smallest-subarrays-with-maximum-bitwise-or/solution/by-endlesscheng-zai1/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1MT411u7fW) 已出炉，包括本题的末尾列出的部分题目，欢迎点赞三连，在评论区分享你对这场双周赛的看法~\r\n\r\n---\r\n\r\n## 方法一：利用或运算的性质\r\n\r\n首先，我们有如下 $O(n^2)$ 的暴力算法：\r\n\r\n> 从左到右正向遍历 $\\textit{nums}$，对于 $x=\\textit{nums}[i]$，从 $i-1$ 开始倒着遍历 $\\textit{nums}[j]$，更新 $\\textit{nums}[j]=\\textit{nums}[j]\\ |\\ x$，如果 $\\textit{nums}[j]$ 变大，则更新 $\\textit{ans}[j]=i-j+1$。\r\n\r\n下面来优化该算法。\r\n\r\n我们可以把二进制数看成集合，二进制数第 $i$ 位为 $1$ 表示 $i$ 在集合中。两个二进制数的或，就可以看成是两个集合的**并集**。\r\n\r\n对于两个二进制数 $a$ 和 $b$，如果 $a\\ |\\ b=a$，从集合的角度上看，$b$ 对应的集合是 $a$ 对应的集合的**子集**。\r\n\r\n据此我们可以提出如下改进后的算法：\r\n\r\n从左到右正向遍历 $\\textit{nums}$，对于 $x=\\textit{nums}[i]$，从 $i-1$ 开始倒着遍历 $\\textit{nums}[j]$：\r\n- 如果 $\\textit{nums}[j]\\ |\\ x\\ne\\textit{nums}[j]$，说明 $\\textit{nums}[j]$ 可以变大（集合元素增多），更新 $\\textit{nums}[j]=\\textit{nums}[j]\\ |\\ x$；\r\n- 如果 $\\textit{nums}[j]\\ |\\ x=\\textit{nums}[j]$，从集合的角度看，此时 $x$ 不仅是 $\\textit{nums}[j]$ 的子集，同时也是 $\\textit{nums}[k]\\ (k<j)$ 的子集（因为循环保证了每个集合都是其左侧相邻集合的子集），那么后续的循环都无法让元素变大，退出循环；\r\n- 在循环中，如果 $\\textit{nums}[j]$ 可以变大，则更新 $\\textit{ans}[j]=i-j+1$。\r\n\r\n```py [sol11-Python3]\r\nclass Solution:\r\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\r\n        ans = [0] * len(nums)\r\n        for i, x in enumerate(nums):\r\n            ans[i] = 1\r\n            for j in range(i - 1, -1, -1):\r\n                if (nums[j] | x) == nums[j]:\r\n                    break\r\n                nums[j] |= x\r\n                ans[j] = i - j + 1\r\n        return ans\r\n```\r\n\r\n```java [sol11-Java]\r\nclass Solution {\r\n    public int[] smallestSubarrays(int[] nums) {\r\n        var n = nums.length;\r\n        var ans = new int[n];\r\n        for (var i = 0; i < n; ++i) {\r\n            ans[i] = 1;\r\n            for (var j = i - 1; j >= 0 && (nums[j] | nums[i]) != nums[j]; --j) {\r\n                nums[j] |= nums[i];\r\n                ans[j] = i - j + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol11-C++]\r\nclass Solution {\r\npublic:\r\n    vector<int> smallestSubarrays(vector<int> &nums) {\r\n        int n = nums.size();\r\n        vector<int> ans(n);\r\n        for (int i = 0; i < n; ++i) {\r\n            ans[i] = 1;\r\n            for (int j = i - 1; j >= 0 && (nums[j] | nums[i]) != nums[j]; --j) {\r\n                nums[j] |= nums[i];\r\n                ans[j] = i - j + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol11-Go]\r\nfunc smallestSubarrays(nums []int) []int {\r\n    ans := make([]int, len(nums))\r\n    for i, x := range nums {\r\n        ans[i] = 1\r\n        for j := i - 1; j >= 0 && nums[j]|x != nums[j]; j-- {\r\n            nums[j] |= x\r\n            ans[j] = i - j + 1\r\n        }\r\n    }\r\n    return ans\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\log U)$，其中 $n$ 为 $\\textit{nums}$ 的长度，$U=max(\\textit{nums})$。由于 $2^{29}-1<10^9<2^{30}-1$，二进制数对应集合的大小不会超过 $29$，因此在或运算下，每个数字至多可以增大 $29$ 次。总体上看，二重循环的次数等于每个数字可以增大的次数之和，即 $O(n\\log U)$。\r\n- 空间复杂度：$O(1)$。返回值不计入。\r\n\r\n## 方法二：更加通用的模板\r\n\r\n该模板可以做到\r\n\r\n1. 求出**所有**子数组的按位或的结果，以及值等于该结果的子数组的个数。\r\n2. 求按位或结果等于**任意给定数字**的子数组的最短长度/最长长度。\r\n\r\n末尾列出了一些题目，均可以用该模板秒杀。\r\n\r\n思考：对于起始位置为 $i$ 的子数组的按位或，至多有多少种不同的结果？\r\n\r\n根据或运算的性质，我们可以从 $x=\\textit{nums}[i]$ 开始，不断往右扩展子数组，按位或的结果要么使 $x$ 不变，要么让 $x$ 的某些比特位的值由 $0$ 变 $1$。最坏情况下从 $x=0$ 出发，每次改变一个比特位，最终得到 $2^{29}-1<10^9$，因此至多有 $30$ 种不同的结果。这意味着我们可以递推计算所有按位或的结果。\r\n\r\n另一个结论是，相同的按位或对应的子数组右端点会形成一个连续的区间，从而保证下面去重逻辑的正确性（这一性质还可以用来统计按位或结果及其对应的子数组的个数）。\r\n\r\n据此，我们可以倒着遍历 $\\textit{nums}$，在遍历的同时，用一个数组 $\\textit{ors}$ 维护以 $i$ 为左端点的子数组的按位或的结果，及其对应的子数组右端点的最小值。继续遍历到 $\\textit{nums}[i-1]$ 时，我们可以把 $\\textit{nums}[i-1]$ 和 $\\textit{ors}$ 中的每个值按位或，合并值相同的结果。\r\n\r\n这样在遍历时，$\\textit{ors}$ 中值最大的元素对应的子数组右端点的最小值，就是要求的最短子数组的右端点。\r\n\r\n注：下面代码用到了**原地去重**的技巧，如果你对此并不熟悉，可以先做做 [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\r\n        n = len(nums)\r\n        ans = [0] * n\r\n        ors = []  # 按位或的值 + 对应子数组的右端点的最小值\r\n        for i in range(n - 1, -1, -1):\r\n            num = nums[i]\r\n            ors.append([0, i])\r\n            k = 0\r\n            for p in ors:\r\n                p[0] |= num\r\n                if ors[k][0] == p[0]:\r\n                    ors[k][1] = p[1]  # 合并相同值，下标取最小的\r\n                else:\r\n                    k += 1\r\n                    ors[k] = p\r\n            del ors[k + 1:]\r\n            # 本题只用到了 ors[0]，如果题目改成任意给定数值，可以在 ors 中查找\r\n            ans[i] = ors[0][1] - i + 1\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int[] smallestSubarrays(int[] nums) {\r\n        var n = nums.length;\r\n        var ans = new int[n];\r\n        var ors = new ArrayList<int[]>(); // 按位或的值 + 对应子数组的右端点的最小值\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            ors.add(new int[]{0, i});\r\n            var k = 0;\r\n            for (var or : ors) {\r\n                or[0] |= nums[i];\r\n                if (ors.get(k)[0] == or[0])\r\n                    ors.get(k)[1] = or[1]; // 合并相同值，下标取最小的\r\n                else ors.set(++k, or);\r\n            }\r\n            ors.subList(k + 1, ors.size()).clear();\r\n            // 本题只用到了 ors[0]，如果题目改成任意给定数值，可以在 ors 中查找\r\n            ans[i] = ors.get(0)[1] - i + 1;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    vector<int> smallestSubarrays(vector<int> &nums) {\r\n        int n = nums.size();\r\n        vector<int> ans(n);\r\n        vector<pair<int, int>> ors; // 按位或的值 + 对应子数组的右端点的最小值\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            ors.emplace_back(0, i);\r\n            ors[0].first |= nums[i];\r\n            int k = 0;\r\n            for (int j = 1; j < ors.size(); ++j) {\r\n                ors[j].first |= nums[i];\r\n                if (ors[k].first == ors[j].first)\r\n                    ors[k].second = ors[j].second; // 合并相同值，下标取最小的\r\n                else ors[++k] = ors[j];\r\n            }\r\n            ors.resize(k + 1);\r\n            // 本题只用到了 ors[0]，如果题目改成任意给定数字，可以在 ors 中查找\r\n            ans[i] = ors[0].second - i + 1;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc smallestSubarrays(nums []int) []int {\r\n\tn := len(nums)\r\n\tans := make([]int, n)\r\n\ttype pair struct{ or, i int }\r\n\tors := []pair{} // 按位或的值 + 对应子数组的右端点的最小值\r\n\tfor i := n - 1; i >= 0; i-- {\r\n\t\tnum := nums[i]\r\n\t\tors = append(ors, pair{0, i})\r\n\t\tors[0].or |= num\r\n\t\tk := 0\r\n\t\tfor _, p := range ors[1:] {\r\n\t\t\tp.or |= num\r\n\t\t\tif ors[k].or == p.or {\r\n\t\t\t\tors[k].i = p.i // 合并相同值，下标取最小的\r\n\t\t\t} else {\r\n\t\t\t\tk++\r\n\t\t\t\tors[k] = p\r\n\t\t\t}\r\n\t\t}\r\n\t\tors = ors[:k+1]\r\n        // 本题只用到了 ors[0]，如果题目改成任意给定数字，可以在 ors 中查找\r\n\t\tans[i] = ors[0].i - i + 1\r\n\t}\r\n\treturn ans\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\log U)$，其中 $n$ 为 $\\textit{nums}$ 的长度，$U=max(\\textit{nums})$。\r\n- 空间复杂度：$O(\\log U)$。返回值不计入。\r\n\r\n#### 可以用模板秒杀的题目\r\n\r\n按位或：\r\n\r\n- [898. 子数组按位或操作](https://leetcode.cn/problems/bitwise-ors-of-subarrays/)\r\n\r\n按位与：\r\n\r\n- [1521. 找到最接近目标值的函数值](https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/)\r\n\r\n最大公因数（GCD）：\r\n\r\n- [Codeforces 475D. CGCDSSQ](https://codeforces.com/problemset/problem/475/D)\r\n- [Codeforces 1632D. New Year Concert](https://codeforces.com/problemset/problem/1632/D)\r\n\r\n乘法：\r\n\r\n- [蓝桥杯2021年第十二届国赛真题-和与乘积](https://www.dotcpp.com/oj/problem2622.html)\r\n\r\n#### 思考题\r\n\r\n如果是**异或**要怎么做？\r\n\r\n依然是倒序遍历，求后缀异或和，然后可以用 [421. 数组中两个数的最大异或值](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/) 的字典树方法，需要额外存后缀异或和对应的下标，如果有多个相同的，存下标最小的。\r\n"
}