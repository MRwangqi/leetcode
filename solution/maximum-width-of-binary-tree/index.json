{
	"titleSlug": "maximum-width-of-binary-tree",
	"slug": "er-cha-shu-zui-da-kuan-du-by-leetcode-so-9zp3",
	"url": "https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/er-cha-shu-zui-da-kuan-du-by-leetcode-so-9zp3/",
	"content": "#### 方法一：广度优先搜索\n\n**思路**\n\n此题求二叉树所有层的最大宽度，比较直观的方法是求出每一层的宽度，然后求出最大值。求每一层的宽度时，因为两端点间的 $\\texttt{null}$ 节点也需要计入宽度，因此可以对节点进行编号。一个编号为 $\\textit{index}$ 的左子节点的编号记为 $2 \\times \\textit{index}$，右子节点的编号记为 $2 \\times \\textit{index} + 1$，计算每层宽度时，用每层节点的最大编号减去最小编号再加 $1$ 即为宽度。\n\n遍历节点时，可以用广度优先搜索来遍历每一层的节点，并求出最大值。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        res = 1\n        arr = [[root, 1]]\n        while arr:\n            tmp = []\n            for node, index in arr:\n                if node.left:\n                    tmp.append([node.left, index * 2])\n                if node.right:\n                    tmp.append([node.right, index * 2 + 1])\n            res = max(res, arr[-1][1] - arr[0][1] + 1)\n            arr = tmp\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int widthOfBinaryTree(TreeNode root) {\n        int res = 1;\n        List<Pair<TreeNode, Integer>> arr = new ArrayList<Pair<TreeNode, Integer>>();\n        arr.add(new Pair<TreeNode, Integer>(root, 1));\n        while (!arr.isEmpty()) {\n            List<Pair<TreeNode, Integer>> tmp = new ArrayList<Pair<TreeNode, Integer>>();\n            for (Pair<TreeNode, Integer> pair : arr) {\n                TreeNode node = pair.getKey();\n                int index = pair.getValue();\n                if (node.left != null) {\n                    tmp.add(new Pair<TreeNode, Integer>(node.left, index * 2));\n                }\n                if (node.right != null) {\n                    tmp.add(new Pair<TreeNode, Integer>(node.right, index * 2 + 1));\n                }\n            }\n            res = Math.max(res, arr.get(arr.size() - 1).getValue() - arr.get(0).getValue() + 1);\n            arr = tmp;\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int WidthOfBinaryTree(TreeNode root) {\n        int res = 1;\n        IList<Tuple<TreeNode, int>> arr = new List<Tuple<TreeNode, int>>();\n        arr.Add(new Tuple<TreeNode, int>(root, 1));\n        while (arr.Count > 0) {\n            IList<Tuple<TreeNode, int>> tmp = new List<Tuple<TreeNode, int>>();\n            foreach (Tuple<TreeNode, int> pair in arr) {\n                TreeNode node = pair.Item1;\n                int index = pair.Item2;\n                if (node.left != null) {\n                    tmp.Add(new Tuple<TreeNode, int>(node.left, index * 2));\n                }\n                if (node.right != null) {\n                    tmp.Add(new Tuple<TreeNode, int>(node.right, index * 2 + 1));\n                }\n            }\n            res = Math.Max(res, arr[arr.Count - 1].Item2 - arr[0].Item2 + 1);\n            arr = tmp;\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int widthOfBinaryTree(TreeNode* root) {\n        unsigned long long res = 1;\n        vector<pair<TreeNode *, unsigned long long>> arr;\n        arr.emplace_back(root, 1L);\n        while (!arr.empty()) {\n            vector<pair<TreeNode *, unsigned long long>> tmp;\n            for (auto &[node, index] : arr) {\n                if (node->left) {\n                    tmp.emplace_back(node->left, index * 2);\n                }\n                if (node->right) {\n                    tmp.emplace_back(node->right, index * 2 + 1);\n                }\n            }\n            res = max(res, arr.back().second - arr[0].second + 1);\n            arr = move(tmp);\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\n#define MAX_NODE_SIZE 3000\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\ntypedef struct {\n    struct TreeNode *node;\n    unsigned long long index;\n} Pair;\n\nint widthOfBinaryTree(struct TreeNode* root){\n    unsigned long long res = 1;\n    Pair * arr = (Pair *)malloc(sizeof(Pair) * MAX_NODE_SIZE);\n    Pair * tmp = (Pair *)malloc(sizeof(Pair) * MAX_NODE_SIZE);\n    int arrSize = 0, tmpSize = 0;\n    arr[arrSize].node = root;\n    arr[arrSize].index = 1LL;\n    arrSize++;\n    while (arrSize > 0) {\n        tmpSize = 0;\n        for (int i = 0; i < arrSize; i++) {\n            if (arr[i].node->left) {\n                tmp[tmpSize].node = arr[i].node->left;\n                tmp[tmpSize].index = arr[i].index * 2;\n                tmpSize++;\n            }\n            if (arr[i].node->right) {\n                tmp[tmpSize].node = arr[i].node->right;\n                tmp[tmpSize].index = arr[i].index * 2 + 1;\n                tmpSize++;\n            }\n        }\n        res = MAX(res, arr[arrSize - 1].index - arr[0].index + 1);\n        arrSize = tmpSize;\n        Pair * p = arr;\n        arr = tmp;\n        tmp = p;\n    }\n    return res;\n}\n```\n\n```go [sol1-Golang]\ntype pair struct {\n    node  *TreeNode\n    index int\n}\n\nfunc widthOfBinaryTree(root *TreeNode) int {\n    ans := 1\n    q := []pair{{root, 1}}\n    for q != nil {\n        ans = max(ans, q[len(q)-1].index-q[0].index+1)\n        tmp := q\n        q = nil\n        for _, p := range tmp {\n            if p.node.Left != nil {\n                q = append(q, pair{p.node.Left, p.index * 2})\n            }\n            if p.node.Right != nil {\n                q = append(q, pair{p.node.Right, p.index*2 + 1})\n            }\n        }\n    }\n    return ans\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点个数。需要遍历所有节点。\n\n- 空间复杂度：$O(n)$。广度优先搜索的空间复杂度最多为 $O(n)$。 \n\n#### 方法二：深度优先搜索\n\n**思路**\n\n仍然按照上述方法编号，可以用深度优先搜索来遍历。遍历时如果是先访问左子节点，再访问右子节点，每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值，需要记录下来进行后续的比较。一次深度优先搜索中，需要当前节点到当前行最左边节点的宽度，以及对子节点进行深度优先搜索，求出最大宽度，并返回最大宽度。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        levelMin = {}\n        def dfs(node: Optional[TreeNode], depth: int, index: int) -> int:\n            if node is None:\n                return 0\n            if depth not in levelMin:\n                levelMin[depth] = index  # 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值\n            return max(index - levelMin[depth] + 1,\n                       dfs(node.left, depth + 1, index * 2),\n                       dfs(node.right, depth + 1, index * 2 + 1))\n        return dfs(root, 1, 1)\n```\n\n```Java [sol2-Java]\nclass Solution {\n    Map<Integer, Integer> levelMin = new HashMap<Integer, Integer>();\n\n    public int widthOfBinaryTree(TreeNode root) {\n        return dfs(root, 1, 1);\n    }\n\n    public int dfs(TreeNode node, int depth, int index) {\n        if (node == null) {\n            return 0;\n        }\n        levelMin.putIfAbsent(depth, index); // 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值\n        return Math.max(index - levelMin.get(depth) + 1, Math.max(dfs(node.left, depth + 1, index * 2), dfs(node.right, depth + 1, index * 2 + 1)));\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    Dictionary<int, int> levelMin = new Dictionary<int, int>();\n\n    public int WidthOfBinaryTree(TreeNode root) {\n        return DFS(root, 1, 1);\n    }\n\n    public int DFS(TreeNode node, int depth, int index) {\n        if (node == null) {\n            return 0;\n        }\n        levelMin.TryAdd(depth, index); // 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值\n        return Math.Max(index - levelMin[depth] + 1, Math.Max(DFS(node.left, depth + 1, index * 2), DFS(node.right, depth + 1, index * 2 + 1)));\n    }\n}\n```\n\n```C++ [sol2-C++]\nusing ULL = unsigned long long;\n\nclass Solution {\npublic:\n    int widthOfBinaryTree(TreeNode* root) {\n        unordered_map<int, ULL> levelMin;\n        function<ULL(TreeNode*, int, ULL)> dfs = [&](TreeNode* node, int depth, ULL index)->ULL {\n            if (node == nullptr) {\n                return 0LL;\n            }\n            if (!levelMin.count(depth)) {\n                levelMin[depth] = index; // 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值\n            }\n            return max({index - levelMin[depth] + 1LL, dfs(node->left, depth + 1, index * 2), dfs(node->right, depth + 1, index * 2 + 1)});\n        };\n        return dfs(root, 1, 1LL);\n    }\n};\n```\n\n```C [sol2-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\ntypedef unsigned long long ULL;\n\ntypedef struct {\n    int key;\n    ULL val;\n    UT_hash_handle hh;\n} HashItem; \n\nHashItem *hashFindItem(HashItem **obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nHashItem *hashAddItem(HashItem **obj, int key, ULL val) {\n    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = key;\n    pEntry->val = val;\n    HASH_ADD_INT(*obj, key, pEntry);\n    return pEntry;\n}\n\nbool hashSetItem(HashItem **obj, int key, ULL val) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        hashAddItem(obj, key, val);\n    } else {\n        pEntry->val = val;\n    }\n    return true;\n}\n\nULL hashGetItem(HashItem **obj, int key, ULL defaultVal) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        return defaultVal;\n    }\n    return pEntry->val;\n}\n\nvoid hashFree(HashItem **obj) {\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);             \n    }\n}\n\nULL dfs(HashItem **levelMin, struct TreeNode* node, int depth, ULL index) {\n    if (node == NULL) {\n        return 0LL;\n    }\n    HashItem *pEntry = hashFindItem(levelMin, depth);\n    if (!pEntry) {\n        pEntry = hashAddItem(levelMin, depth, index); // 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值\n    }\n    ULL ret =  index - pEntry->val + 1;\n    if (node->left) {\n        ULL val = dfs(levelMin, node->left, depth + 1, index * 2);\n        ret = MAX(ret, val);\n    }\n    if (node->right) {\n        ULL val = dfs(levelMin, node->right, depth + 1, index * 2 + 1);\n        ret = MAX(ret, val);\n    }\n    return ret;\n}   \n\nint widthOfBinaryTree(struct TreeNode* root) {\n    HashItem *levelMin = NULL;\n    ULL ret = dfs(&levelMin, root, 1, 1LL);\n    hashFree(&levelMin);\n    return ret;\n}\n```\n\n```go [sol2-Golang]\nfunc widthOfBinaryTree(root *TreeNode) int {\n    levelMin := map[int]int{}\n    var dfs func(*TreeNode, int, int) int\n    dfs = func(node *TreeNode, depth, index int) int {\n        if node == nil {\n            return 0\n        }\n        if _, ok := levelMin[depth]; !ok {\n            levelMin[depth] = index // 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值\n        }\n        return max(index-levelMin[depth]+1, max(dfs(node.Left, depth+1, index*2), dfs(node.Right, depth+1, index*2+1)))\n    }\n    return dfs(root, 1, 1)\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点个数。需要遍历所有节点。\n\n- 空间复杂度：$O(n)$。递归的深度最多为 $O(n)$。"
}