{
	"titleSlug": "image-smoother",
	"slug": "tu-pian-ping-hua-qi-by-leetcode-solution-9oi5",
	"url": "https://leetcode-cn.com/problems/image-smoother/solution/tu-pian-ping-hua-qi-by-leetcode-solution-9oi5/",
	"content": "#### 方法一：遍历\n\n**思路和算法**\n\n按照题目的要求，我们直接依次计算每一个位置平滑处理后的结果即可。\n\n具体地，对于位置 $(i,j)$，我们枚举其周围的九个单元是否存在，对于存在的单元格，我们统计其数量 $\\textit{num}$ 与总和 $\\textit{sum}$，那么该位置平滑处理后的结果即为 $\\Big\\lfloor\\dfrac{\\textit{sum}}{\\textit{num}}\\Big\\rfloor$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> imageSmoother(vector<vector<int>>& img) {\n        int m = img.size(), n = img[0].size();\n        vector<vector<int>> ret(m, vector<int>(n));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int num = 0, sum = 0;\n                for (int x = i - 1; x <= i + 1; x++) {\n                    for (int y = j - 1; y <= j + 1; y++) {\n                        if (x >= 0 && x < m && y >= 0 && y < n) {\n                            num++;\n                            sum += img[x][y];\n                        }\n                    }\n                }\n                ret[i][j] = sum / num;\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[][] imageSmoother(int[][] img) {\n        int m = img.length, n = img[0].length;\n        int[][] ret = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int num = 0, sum = 0;\n                for (int x = i - 1; x <= i + 1; x++) {\n                    for (int y = j - 1; y <= j + 1; y++) {\n                        if (x >= 0 && x < m && y >= 0 && y < n) {\n                            num++;\n                            sum += img[x][y];\n                        }\n                    }\n                }\n                ret[i][j] = sum / num;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[][] ImageSmoother(int[][] img) {\n        int m = img.Length, n = img[0].Length;\n        int[][] ret = new int[m][];\n        for (int i = 0; i < m; i++) {\n            ret[i] = new int[n];\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int num = 0, sum = 0;\n                for (int x = i - 1; x <= i + 1; x++) {\n                    for (int y = j - 1; y <= j + 1; y++) {\n                        if (x >= 0 && x < m && y >= 0 && y < n) {\n                            num++;\n                            sum += img[x][y];\n                        }\n                    }\n                }\n                ret[i][j] = sum / num;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol1-C]\nint** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes){\n    int m = imgSize, n = imgColSize[0];\n    int ** ret = (int **)malloc(sizeof(int *) * m);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * m);\n    for (int i = 0; i < m; i ++) {\n        ret[i] = (int *)malloc(sizeof(int) * n);\n        memset(ret[i], 0, sizeof(int) * n);\n        (*returnColumnSizes)[i] = n;\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int num = 0, sum = 0;\n            for (int x = i - 1; x <= i + 1; x++) {\n                for (int y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        num++;\n                        sum += img[x][y];\n                    }\n                }\n            }\n            ret[i][j] = sum / num;\n        }\n    }\n    *returnSize = m;\n    return ret;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar imageSmoother = function(img) {\n    const m = img.length, n = img[0].length;\n    const ret = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let num = 0, sum = 0;\n            for (let x = i - 1; x <= i + 1; x++) {\n                for (let y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        num++;\n                        sum += img[x][y];\n                    }\n                }\n            }\n            ret[i][j] = Math.floor(sum / num);\n        }\n    }\n    return ret;\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:\n        m, n = len(img), len(img[0])\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                tot, num = 0, 0\n                for x in range(max(i - 1, 0), min(i + 2, m)):\n                    for y in range(max(j - 1, 0), min(j + 2, n)):\n                        tot += img[x][y]\n                        num += 1\n                ans[i][j] = tot // num\n        return ans\n```\n\n```go [sol1-Golang]\nfunc imageSmoother(img [][]int) [][]int {\n    m, n := len(img), len(img[0])\n    ans := make([][]int, m)\n    for i := range ans {\n        ans[i] = make([]int, n)\n        for j := range ans[i] {\n            sum, num := 0, 0\n            for _, row := range img[max(i-1, 0):min(i+2, m)] {\n                for _, v := range row[max(j-1, 0):min(j+2, n)] {\n                    sum += v\n                    num++\n                }\n            }\n            ans[i][j] = sum / num\n        }\n    }\n    return ans\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mnC^2)$，其中 $m$ 为给定矩阵的行数，$n$ 为给定矩阵的列数，$C=3$ 为过滤器的宽高。我们需要遍历整个矩阵以计算每个位置的值，计算单个位置的值的时间复杂度为 $O(C^2)$。\n\n- 空间复杂度：$O(1)$。注意返回值不计入空间复杂度。"
}