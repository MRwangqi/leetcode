{
	"titleSlug": "maximum-number-of-groups-getting-fresh-donuts",
	"slug": "cong-zui-zhi-jie-de-fang-fa-kai-shi-yi-b-x729",
	"url": "https://leetcode-cn.com/problems/maximum-number-of-groups-getting-fresh-donuts/solution/cong-zui-zhi-jie-de-fang-fa-kai-shi-yi-b-x729/",
	"content": "### 最直接的思路\r\n\r\n想象商店的顾客排队，我们一批一批地选择顾客加入到排队的队尾中，并记录之前的顾客所要购买的甜甜圈总数 $sum$，如果 $sum \\mod b = 0$，则当前批次的顾客就是高兴的。\r\n\r\n定义搜索函数 $f(mask, pre)$ ：\r\n\r\n- $mask$ 采用二进制位压缩的方式，其中的每一个二进制位 $bit[i]$ 记录了第 $i$ 批次的顾客是否尚未被选择，若未被选择则为 $0$，否则为 $1$。\r\n- $pre$ 代表之前顾客所要购买的甜甜圈总数再 $\\mod b$ 的值，即 $pre = sum \\mod b$。\r\n\r\n状态转移也很简单，我们枚举当前选择的顾客批次 $i$，如果 $bit[i] = 1$，则代表当前批次的顾客可选，直接进行转移即可：如果 $pre = 0$，则当前批次的顾客是满意的，否则是不满意的。\r\n\r\n不幸的是，由于题目中 $n$ 最大为 $30$，直接进行上面的状态压缩思路显然超出时间的。\r\n\r\n### 优化状态的表示\r\n\r\n考虑优化，但是从哪里入手？注意到 $b \\leq 9$，一个容易想到的思路是对所有的 $nums[i]$，统计 $nums[i] \\mod b$ 所出现的频次，得出频次数组 $freq$。\r\n\r\n那么我们可以将前面定义的函数 $f(mask, pre)$ 修改成 $f(freq, pre)$，其中 $freq$ 是一个不超过 $9$ 维的数组，而每个 $freq[i]$ 表示频次，不超过 $30$。\r\n\r\n等等，$30 ^ 9$ 甚至要比 $2 ^ {30}$ 还要大，因此直接这样用数组定义 $freq$ 是不行的！不过，我们可以采用另外一种思路。\r\n\r\n研究一下我们所采用的时间系统，一天有 $24$ 小时，一小时有 $60$ 分钟，一分钟有 $60$ 秒，一秒有 $1000$ 毫秒。我们可以用类似 $1:12:59:31.100$ 的格式来定义一个时间间隔，表示 $1$ 天 $12$ 小时 $59$ 分 $31$ 秒 $100$ 毫秒。我们可以把它 对应到一个数字 $133171100$，表示经过了 $133171100$ 毫秒。这两种表示方式是 **一一对应** 的。这是一种特殊的进位计数方式，最低的位（毫秒）采用 $1000$ 进一，然后是 $60$ 进一（秒 $\\rightarrow$ 分钟），然后分别是 $60, 24$ 进一。\r\n\r\n我们可以采用类似的思路来表示 $freq$ 数组。首先我们统计所有的 $nums[i]$，得出初始的 $freq$ 数组 $freq0$。注意到，我们每选取一个顾客加入队尾，$freq[i]$ 只会减小，因此 $freq[i] \\le freq0[i]$。因此，我们可以在最低的位（位 $0$) 采用每 $freq0[0] + 1$ 进一的方式，然后位 $1$ 采用每 $freq0[1] + 1$ 进一的方式，如此等等。通过这样的方式，我们可以把一个特定 $freq$ 数组映射成一个 **唯一的整数**。下面介绍正映射和逆映射的具体实现方式。\r\n\r\n- 首先计算 $w$ 数组。$w[0] = 1$; $w[i](i \\ge 1) = w[i-1] \\cdot (freq0[i-1] + 1)$。\r\n  > $w[i]$ 表示 $freq$ 数组中每一 “位” 的 **权重**。\r\n- 正映射（从 $freq$ 数组 映射到 整数 $fmask$ ）：\r\n\r\n  $fmask = freq[0] \\cdot w[0] + freq[1] \\cdot w[1] + ... + freq[b-1] \\cdot w[b-1]$。\r\n\r\n- 逆映射（从 $fmask$ 映射到 $freq$ 数组）：\r\n\r\n  $freq[i] = \\displaystyle{\\frac{fmask}{w[i]} \\mod (freq0[i] + 1)}$。\r\n\r\n这样状态转移的思路就很简单了，对于每个 $f(fmask, pre)$，我们先逆映射 $fmask \\rightarrow freq$，然后枚举选择的顾客批次，最后再将修改后的 $freq$ 数组正映射到 $fmask'$ 即可。\r\n\r\n#### 为什么不会超时\r\n\r\n我们观察一下，$fmask$ 可以取多少个值。根据前述映射关系，$freq[0]$ 的取值范围为 $0 \\sim freq0[0]$，共 $(freq[0] + 1)$ 个值；$freq[1]$ 可取 $(freq0[1] + 1)$ 个值；等等。因此 $fmask$ 可以取到 $(freq0[0] + 1) \\times(freq0[1] + 1) \\times...\\times(freq0[b-1]+1)$ 个值。注意到 $freq0[0] + freq0[1] + ... + freq0[b-1] = n$，因此问题转化为：将一个整数 $n$ 拆分成 $b$ 个整数 $x_0, x_1, ... x_{b-1}$（$x_i$ 可以为 $0$），使得 $(x_0 + 1) \\times(x_1 + 1) \\times... \\times(x_{b-1} + 1)$ 最大。\r\n\r\n采用类似 [343.整数拆分](https://leetcode-cn.com/problems/integer-break/) 的动态规划思路，定义 $dp[i][x]$ 为将 $x$ 拆分成 $i$ 个整数的最大乘积。经过计算可得，$dp[i][x] \\le dp[9][30] = 512000$。即 $fmask$ 最大约为 $5\\cdot 10^5$ 级别。\r\n\r\n则动态规划的总状态数 $\\le 5 \\cdot 10^5 \\cdot 9 = 4.5 \\cdot 10^6$，状态转移最多需要枚举 $9$ 次，因此总的计算次数 $\\le 4 \\cdot 10^7$ 次，可以通过本题。\r\n\r\n### 再优化\r\n\r\n- 对于函数 $f(fmask, pre)$，我们知道了 $fmask$，也就知道了 $freq$ 数组，因此也就知道了 还剩下多少顾客，我们可以用 总数 - 剩下的数 求出 前面的顾客数，也就是说 $pre$ 可以直接由 $freq$ 求出，故可省去。这样可以把计算次数减少到 $4.5 \\cdot 10^6$。\r\n- 另外，如果 $nums[i] \\mod b = 0$，那么将其安排到队首不会得到更差的结果，因此我们可以先把这些顾客安排完成后再执行动态规划，这样可以进一步减小计算次数到 $2.25 \\cdot 10^6$。\r\n\r\n![image.png](https://pic.leetcode-cn.com/1617524899-XyaLil-image.png)\r\n\r\n\r\n### 最终代码\r\n\r\n```c++\r\nint freq0[9], freq[9], w[9], f[300000];\r\nclass Solution {\r\npublic:\r\n    int maxHappyGroups(int b, vector<int>& groups) {\r\n        for(int i = 0; i < b; ++i) freq0[i] = 0;\r\n        for(int i : groups) freq0[i % b]++;\r\n        int msum = 1;\r\n        for(int i = 1; i < b; ++i) msum *= (freq0[i] + 1);\r\n        w[1] = 1;\r\n        for(int i = 2; i < b; ++i) w[i] = w[i-1] * (freq0[i-1] + 1);\r\n        for(int fmask = 0; fmask < msum; ++fmask) f[fmask] = 0;\r\n        for(int fmask = 1; fmask < msum; ++fmask) {\r\n            int last = 0;\r\n            for(int i = 1; i < b; ++i) {\r\n                freq[i] = (fmask / w[i]) % (freq0[i] + 1);\r\n                last = (last + (freq0[i] - freq[i]) * i) % b;\r\n            }\r\n            for(int c = 1; c < b; ++c) {\r\n                if(freq[c]) f[fmask] = max(f[fmask], f[fmask - w[c]] + (last == 0));\r\n            }\r\n        }\r\n        return f[msum-1] + freq0[0];\r\n    }\r\n};\r\n```\r\n\r\n"
}