{
	"titleSlug": "binary-gap",
	"slug": "er-jin-zhi-jian-ju-by-leetcode-solution-dh2q",
	"url": "https://leetcode-cn.com/problems/binary-gap/solution/er-jin-zhi-jian-ju-by-leetcode-solution-dh2q/",
	"content": "#### 方法一：位运算\n\n**思路与算法**\n\n我们可以使用一个循环从 $n$ 二进制表示的低位开始进行遍历，并找出所有的 $1$。我们用一个变量 $\\textit{last}$ 记录上一个找到的 $1$ 的位置。如果当前在第 $i$ 位找到了 $1$，那么就用 $i - \\textit{last}$ 更新答案，再将 $\\textit{last}$ 更新为 $i$ 即可。\n\n在循环的每一步中，我们可以使用位运算 $\\texttt{n \\& 1}$ 获取 $n$ 的最低位，判断其是否为 $1$。在这之后，我们将 $n$ 右移一位：$\\texttt{n = n >> 1}$，这样在第 $i$ 步时，$\\texttt{n \\& 1}$ 得到的就是初始 $n$ 的第 $i$ 个二进制位。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def binaryGap(self, n: int) -> int:\n        last, ans, i = -1, 0, 0\n        while n:\n            if n & 1:\n                if last != -1:\n                    ans = max(ans, i - last)\n                last = i\n            n >>= 1\n            i += 1\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int binaryGap(int n) {\n        int last = -1, ans = 0;\n        for (int i = 0; n; ++i) {\n            if (n & 1) {\n                if (last != -1) {\n                    ans = max(ans, i - last);\n                }\n                last = i;\n            }\n            n >>= 1;\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int binaryGap(int n) {\n        int last = -1, ans = 0;\n        for (int i = 0; n != 0; ++i) {\n            if ((n & 1) == 1) {\n                if (last != -1) {\n                    ans = Math.max(ans, i - last);\n                }\n                last = i;\n            }\n            n >>= 1;\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int BinaryGap(int n) {\n        int last = -1, ans = 0;\n        for (int i = 0; n != 0; ++i) {\n            if ((n & 1) == 1) {\n                if (last != -1) {\n                    ans = Math.Max(ans, i - last);\n                }\n                last = i;\n            }\n            n >>= 1;\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint binaryGap(int n) {\n    int last = -1, ans = 0;\n    for (int i = 0; n; ++i) {\n        if (n & 1) {\n            if (last != -1) {\n                ans = MAX(ans, i - last);\n            }\n            last = i;\n        }\n        n >>= 1;\n    }\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc binaryGap(n int) (ans int) {\n    for i, last := 0, -1; n > 0; i++ {\n        if n&1 == 1 {\n            if last != -1 {\n                ans = max(ans, i-last)\n            }\n            last = i\n        }\n        n >>= 1\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar binaryGap = function(n) {\n    let last = -1, ans = 0;\n    for (let i = 0; n != 0; ++i) {\n        if ((n & 1) === 1) {\n            if (last !== -1) {\n                ans = Math.max(ans, i - last);\n            }\n            last = i;\n        }\n        n >>= 1;\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$。循环中的每一步 $n$ 会减少一半，因此需要 $O(\\log n)$ 次循环。\n\n- 空间复杂度：$O(1)$。"
}