{
	"titleSlug": "replace-non-coprime-numbers-in-array",
	"slug": "ti-huan-shu-zu-zhong-de-fei-hu-zhi-shu-b-mnml",
	"url": "https://leetcode-cn.com/problems/replace-non-coprime-numbers-in-array/solution/ti-huan-shu-zu-zhong-de-fei-hu-zhi-shu-b-mnml/",
	"content": "#### 方法一：栈\n\n**思路与算法**\n\n由于题目不加证明地给出了「任意顺序替换相邻的非互质数都可以得到相同的结果」，因此我们可以从前往后进行替换。\n\n我们可以使用一个栈来进行替换操作。具体地，我们对数组 $\\textit{nums}$ 进行一次遍历。当遍历到 $\\textit{nums}[i]$ 时。在其被放入栈顶前，我们重复进行替换操作，直到 $\\textit{nums}[i]$ 和栈顶的元素互质，或者栈为空为止。此时，我们再将替换完成的 $\\textit{nums}[i]$ 放入栈顶。\n\n最终栈底到栈顶的元素序列即为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\n        vector<int> ans;\n        for (int num: nums) {\n            while (!ans.empty()) {\n                int g = gcd(ans.back(), num);\n                if (g > 1) {\n                    num = ans.back() / g * num;\n                    ans.pop_back();\n                }\n                else {\n                    break;\n                }\n            }\n            ans.push_back(num);\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\n        ans = list()\n        for num in nums:\n            while ans:\n                g = math.gcd(ans[-1], num)\n                if g > 1:\n                    num = ans[-1] // g * num\n                    ans.pop()\n                else:\n                    break\n            ans.append(num)\n        \n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log C)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度，$C$ 是数组 $\\textit{nums}$ 中的数据范围，$O(\\log C)$ 即为单次计算最大公约数需要的时间。\n\n- 空间复杂度：$O(1)$。这里不计入返回值需要使用的空间。"
}