{
	"titleSlug": "valid-tic-tac-toe-state",
	"slug": "you-xiao-de-jing-zi-you-xi-by-leetcode-s-c1j3",
	"url": "https://leetcode-cn.com/problems/valid-tic-tac-toe-state/solution/you-xiao-de-jing-zi-you-xi-by-leetcode-s-c1j3/",
	"content": "#### 方法一：分类讨论\n\n**思路**\n\n题目要求判断当前游戏板是否生效，我们思考游戏板生效的规则：\n- 玩家轮流将字符放入空位 $\\texttt{\" \"}$ 中。第一个玩家总是放字符 $\\texttt{\"X\"}$，且第二个玩家总是放字符 $\\texttt{\"O\"}$。因为第一个玩家总是先手，这就要求游戏板中字符 $\\texttt{\"X\"}$ 的数量一定是大于等于字符 $\\texttt{\"O\"}$ 的数量。\n- $\\texttt{\"X\"}$ 和 $\\texttt{\"O\"}$ 只允许放置在空位中，不允许对已放有字符的位置进行填充。\n- 当有 $3$ 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。当所有位置非空时，也算为游戏结束。如果游戏结束，玩家不允许再放置字符，不可能能出现二者同时获胜的情况，因此游戏板上不可能同时出现 $3$ 个 $\\texttt{\"X\"}$ 在一行和 $3$ 个 $\\texttt{\"O\"}$ 在另一行。\n- 获胜的玩家一定是在自己放棋后赢得比赛，赢得比赛后，立马停止放置字符。\n  - 如果第一个玩家获胜，由于第一个玩家是先手，则次数游戏板中 $\\texttt{\"X\"}$ 的数量比 $\\texttt{\"O\"}$ 的数量多 $1$。\n  - 如果第二个玩家获胜，则 $\\texttt{\"X\"}$ 的数量与 $\\texttt{\"O\"}$ 的数量相同。\n\n以上条件包含了游戏板生效的全部情况，可以通过反证法验证上面分类条件的正确性。在合法的游戏板，只能有 $3$ 种结果合法，要么没有任何玩家赢，要么玩家一赢，要么玩家二赢。我们可以通过检查两种棋的数量关系即可验证是否有效，同时我们要检测是否存在两个玩家同时赢这种非法情况。\n\n算法实现细节如下:\n- 首先统计游戏板上 $\\texttt{\"X\"}$ 和 $\\texttt{\"O\"}$ 的数量并记录在 $\\textit{xCount}$ 和 $\\textit{oCount}$ 中，如果不满足 $\\textit{xCount} \\ge \\textit{oCount}$，则此时为非法，直接返回 $\\texttt{false}$。\n- 然后我们检查是否有玩家是否获胜，我们检查在棋盘的 $3$ 行，$3$ 列和 $2$ 条对角线上是否有该玩家的连续 $3$ 枚棋子。我们首先检测玩家一是否获胜，如果玩家一获胜,则检查 $\\textit{xCount}$ 是否等于 $\\textit{oCount} + 1$；我们继续检测玩家二是否获胜，如果玩家二获胜，则检查 $\\textit{xCount}$ 是否等于 $\\textit{oCount}$。\n- 对于特殊情况如果两个玩家都获胜，是否可以检测出该非法情况？如果同时满足两个玩家都获胜，则 $\\texttt{\"X\"}$ 和 $\\texttt{\"O\"}$ 数量的合法的组合可能为 $(3,3),(4,3),(4,4),(5,4)$，对于 $(3,3),(4,4)$ 不满足玩家一获胜的检测条件，对于 $(4,3),(5,4)$ 满足玩家一获胜的检测条件但不满足玩家二的获胜条件。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean validTicTacToe(String[] board) {\n        int xCount = 0, oCount = 0;\n        for (String row : board) {\n            for (char c : row.toCharArray()) {\n                xCount = (c == 'X') ? (xCount + 1) : xCount;\n                oCount = (c == 'O') ? (oCount + 1) : oCount;\n            }\n        }\n        return !((oCount != xCount && oCount != xCount - 1) ||\n               (oCount != xCount - 1 && win(board, 'X')) ||\n               (oCount != xCount && win(board, 'O')));\n    }\n\n    public boolean win(String[] board, char p) {\n        for (int i = 0; i < 3; ++i) {\n            if ((p == board[0].charAt(i) && p == board[1].charAt(i) && p == board[2].charAt(i)) ||\n               (p == board[i].charAt(0) && p == board[i].charAt(1) && p == board[i].charAt(2))) {\n                return true;\n            }\n        }\n        return ((p == board[0].charAt(0) && p == board[1].charAt(1) && p == board[2].charAt(2)) ||\n                (p == board[0].charAt(2) && p == board[1].charAt(1) && p == board[2].charAt(0)));\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool validTicTacToe(vector<string>& board) {\n        int xCount = 0, oCount = 0;\n        for (string & row : board) {\n            for (char c : row) {\n                xCount = (c == 'X') ? (xCount + 1) : xCount;\n                oCount = (c == 'O') ? (oCount + 1) : oCount;\n            }\n        }\n        return !((oCount != xCount && oCount != xCount - 1) ||\n               (oCount != xCount - 1 && win(board, 'X')) ||\n               (oCount != xCount && win(board, 'O')));\n    }\n\n    bool win(vector<string>& board, char p) {\n        for (int i = 0; i < 3; ++i) {\n            if ((p == board[0][i] && p == board[1][i] && p == board[2][i]) ||\n               (p == board[i][0] && p == board[i][1] && p == board[i][2])) {\n                return true;\n            }\n        }\n        return ((p == board[0][0] && p == board[1][1] && p == board[2][2]) ||\n                (p == board[0][2] && p == board[1][1] && p == board[2][0]));\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool ValidTicTacToe(string[] board) {\n        int xCount = 0, oCount = 0;\n        foreach (string row in board) {\n            foreach (char c in row) {\n                xCount = (c == 'X') ? (xCount + 1) : xCount;\n                oCount = (c == 'O') ? (oCount + 1) : oCount;\n            }\n        }\n        return !((oCount != xCount && oCount != xCount - 1) ||\n               (oCount != xCount - 1 && win(board, 'X')) ||\n               (oCount != xCount && win(board, 'O')));\n    }\n\n    public bool win(string[] board, char p) {\n        for (int i = 0; i < 3; ++i) {\n            if ((p == board[0][i] && p == board[1][i] && p == board[2][i]) ||\n               (p == board[i][0] && p == board[i][1] && p == board[i][2])) {\n                return true;\n            }\n        }\n        return ((p == board[0][0] && p == board[1][1] && p == board[2][2]) ||\n                (p == board[0][2] && p == board[1][1] && p == board[2][0]));\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def win(self, board: List[str], p: str) -> bool:\n        return any(board[i][0] == p and board[i][1] == p and board[i][2] == p or\n                   board[0][i] == p and board[1][i] == p and board[2][i] == p for i in range(3)) or \\\n                   board[0][0] == p and board[1][1] == p and board[2][2] == p or \\\n                   board[0][2] == p and board[1][1] == p and board[2][0] == p\n\n    def validTicTacToe(self, board: List[str]) -> bool:\n        oCount = sum(row.count('O') for row in board)\n        xCount = sum(row.count('X') for row in board)\n        return not (oCount != xCount and oCount != xCount - 1 or\n                    oCount != xCount and self.win(board, 'O') or\n                    oCount != xCount - 1 and self.win(board, 'X'))\n```\n\n```go [sol1-Golang]\nfunc win(board []string, p byte) bool {\n    for i := 0; i < 3; i++ {\n        if board[i][0] == p && board[i][1] == p && board[i][2] == p ||\n            board[0][i] == p && board[1][i] == p && board[2][i] == p {\n            return true\n        }\n    }\n    return board[0][0] == p && board[1][1] == p && board[2][2] == p ||\n        board[0][2] == p && board[1][1] == p && board[2][0] == p\n}\n\nfunc validTicTacToe(board []string) bool {\n    oCount, xCount := 0, 0\n    for _, row := range board {\n        oCount += strings.Count(row, \"O\")\n        xCount += strings.Count(row, \"X\")\n    }\n    return !(oCount != xCount && oCount != xCount-1 ||\n        oCount != xCount && win(board, 'O') ||\n        oCount != xCount-1 && win(board, 'X'))\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar validTicTacToe = function(board) {\n    let xCount = 0, oCount = 0;\n    for (const row of board) {\n        for (const c of row) {\n            xCount = (c === 'X') ? (xCount + 1) : xCount;\n            oCount = (c === 'O') ? (oCount + 1) : oCount;\n        }\n    }\n    return !((oCount != xCount && oCount != xCount - 1) ||\n               (oCount != xCount - 1 && win(board, 'X')) ||\n               (oCount != xCount && win(board, 'O')));\n};\n\nconst win = (board, p) => {\n    for (let i = 0; i < 3; ++i) {\n        if ((p == board[0][i] && p == board[1][i] && p == board[2][i]) ||\n            (p == board[i][0] && p == board[i][1] && p == board[i][2])) {\n            return true;\n        }\n    }\n    return ((p == board[0][0] && p == board[1][1] && p == board[2][2]) ||\n            (p == board[0][2] && p == board[1][1] && p == board[2][0]));\n}\n```\n\n```C [sol1-C]\nbool win(const char ** board, char p) {\n    for (int i = 0; i < 3; ++i) {\n        if ((p == board[0][i] && p == board[1][i] && p == board[2][i]) ||\n            (p == board[i][0] && p == board[i][1] && p == board[i][2])) {\n            return true;\n        }\n    }\n    return ((p == board[0][0] && p == board[1][1] && p == board[2][2]) ||\n            (p == board[0][2] && p == board[1][1] && p == board[2][0]));\n}\n\nbool validTicTacToe(char ** board, int boardSize){\n    int xCount = 0, oCount = 0;\n    for (int i = 0; i < boardSize; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            xCount = (board[i][j] == 'X') ? (xCount + 1) : xCount;\n            oCount = (board[i][j] == 'O') ? (oCount + 1) : oCount;\n        }\n    }\n    return !((oCount != xCount && oCount != xCount - 1) ||\n            (oCount != xCount - 1 && win(board, 'X')) ||\n            (oCount != xCount && win(board, 'O')));\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(C)$，由于此题给定的棋盘大小为常数 $C = 9$，因此时间复杂度为常数。\n\n- 空间复杂度：$O(1)$。"
}