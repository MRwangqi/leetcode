{
	"titleSlug": "shu-zu-zhong-de-ni-xu-dui-lcof",
	"slug": "shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£\n\n![é¢è¯•é¢˜ 51. æ•°ç»„ä¸­çš„é€†åºå¯¹.mp4](0a3b59f0-4902-4b35-b605-cf2ded591a8b)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### æ–¹æ³•ä¸€ï¼šå½’å¹¶æ’åº\n\n**é¢„å¤‡çŸ¥è¯†**\n\nã€Œå½’å¹¶æ’åºã€æ˜¯åˆ†æ²»æ€æƒ³çš„å…¸å‹åº”ç”¨ï¼Œå®ƒåŒ…å«è¿™æ ·ä¸‰ä¸ªæ­¥éª¤ï¼š\n\n+ **åˆ†è§£ï¼š** å¾…æ’åºçš„åŒºé—´ä¸º $[l, r]$ï¼Œä»¤ $m = \\lfloor \\frac{l + r}{2} \\rfloor$ï¼Œæˆ‘ä»¬æŠŠ $[l, r]$ åˆ†æˆ $[l, m]$ å’Œ $[m + 1, r]$\n+ **è§£å†³ï¼š** ä½¿ç”¨å½’å¹¶æ’åºé€’å½’åœ°æ’åºä¸¤ä¸ªå­åºåˆ—\n+ **åˆå¹¶ï¼š** æŠŠä¸¤ä¸ªå·²ç»æ’å¥½åºçš„å­åºåˆ— $[l, m]$ å’Œ $[m + 1, r]$ åˆå¹¶èµ·æ¥\n\nåœ¨å¾…æ’åºåºåˆ—é•¿åº¦ä¸º $1$ çš„æ—¶å€™ï¼Œé€’å½’å¼€å§‹ã€Œå›å‡ã€ï¼Œå› ä¸ºæˆ‘ä»¬é»˜è®¤é•¿åº¦ä¸º $1$ çš„åºåˆ—æ˜¯æ’å¥½åºçš„ã€‚\n\n**æ€è·¯**\n\né‚£ä¹ˆæ±‚é€†åºå¯¹å’Œå½’å¹¶æ’åºåˆæœ‰ä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿå…³é”®å°±åœ¨äºã€Œå½’å¹¶ã€å½“ä¸­ã€Œå¹¶ã€çš„è¿‡ç¨‹ã€‚æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªå®ä¾‹æ¥çœ‹çœ‹ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸¤ä¸ªå·²æ’åºçš„åºåˆ—ç­‰å¾…åˆå¹¶ï¼Œåˆ†åˆ«æ˜¯ $L = \\{ 8, 12, 16, 22, 100 \\}$ å’Œ $R = \\{ 9, 26, 55, 64, 91 \\}$ã€‚ä¸€å¼€å§‹æˆ‘ä»¬ç”¨æŒ‡é’ˆ `lPtr = 0` æŒ‡å‘ $L$ çš„é¦–éƒ¨ï¼Œ`rPtr = 0` æŒ‡å‘ $R$ çš„å¤´éƒ¨ã€‚è®°å·²ç»åˆå¹¶å¥½çš„éƒ¨åˆ†ä¸º $M$ã€‚\n\n```\nL = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = []\n     |                          |\n   lPtr                       rPtr\n```\n\næˆ‘ä»¬å‘ç° `lPtr` æŒ‡å‘çš„å…ƒç´ å°äº `rPtr` æŒ‡å‘çš„å…ƒç´ ï¼Œäºæ˜¯æŠŠ `lPtr` æŒ‡å‘çš„å…ƒç´ æ”¾å…¥ç­”æ¡ˆï¼Œå¹¶æŠŠ `lPtr` åç§»ä¸€ä½ã€‚\n\n```\nL = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = [8]\n        |                       |\n      lPtr                     rPtr\n```\n\nè¿™ä¸ªæ—¶å€™æˆ‘ä»¬æŠŠå·¦è¾¹çš„ $8$ åŠ å…¥äº†ç­”æ¡ˆï¼Œæˆ‘ä»¬å‘ç°å³è¾¹æ²¡æœ‰æ•°æ¯” $8$ å°ï¼Œæ‰€ä»¥ $8$ å¯¹é€†åºå¯¹æ€»æ•°çš„ã€Œè´¡çŒ®ã€ä¸º $0$ã€‚\n\næ¥ç€æˆ‘ä»¬ç»§ç»­åˆå¹¶ï¼ŒæŠŠ $9$ åŠ å…¥äº†ç­”æ¡ˆï¼Œæ­¤æ—¶ `lPtr` æŒ‡å‘ $12$ï¼Œ`rPtr` æŒ‡å‘ $26$ã€‚\n\n```\nL = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = [8, 9]\n        |                          |\n       lPtr                       rPtr\n```\n\næ­¤æ—¶ `lPtr` æ¯” `rPtr` å°ï¼ŒæŠŠ `lPtr` å¯¹åº”çš„æ•°åŠ å…¥ç­”æ¡ˆï¼Œå¹¶è€ƒè™‘å®ƒå¯¹é€†åºå¯¹æ€»æ•°çš„è´¡çŒ®ä¸º `rPtr` ç›¸å¯¹ $R$ é¦–ä½ç½®çš„åç§» $1$ï¼ˆå³å³è¾¹åªæœ‰ä¸€ä¸ªæ•°æ¯” $12$ å°ï¼Œæ‰€ä»¥åªæœ‰å®ƒå’Œ $12$ æ„æˆé€†åºå¯¹ï¼‰ï¼Œä»¥æ­¤ç±»æ¨ã€‚\n\næˆ‘ä»¬å‘ç°ç”¨è¿™ç§ã€Œç®—è´¡çŒ®ã€çš„æ€æƒ³åœ¨åˆå¹¶çš„è¿‡ç¨‹ä¸­è®¡ç®—é€†åºå¯¹çš„æ•°é‡çš„æ—¶å€™ï¼Œåªåœ¨ `lPtr` å³ç§»çš„æ—¶å€™è®¡ç®—ï¼Œæ˜¯åŸºäºè¿™æ ·çš„äº‹å®ï¼šå½“å‰ `lPtr` æŒ‡å‘çš„æ•°å­—æ¯” `rPtr` å°ï¼Œä½†æ˜¯æ¯” $R$ ä¸­ `[0 ... rPtr - 1]` çš„å…¶ä»–æ•°å­—å¤§ï¼Œ`[0 ... rPtr - 1]` çš„å…¶ä»–æ•°å­—æœ¬åº”å½“æ’åœ¨ `lPtr` å¯¹åº”æ•°å­—çš„å·¦è¾¹ï¼Œä½†æ˜¯å®ƒæ’åœ¨äº†å³è¾¹ï¼Œæ‰€ä»¥è¿™é‡Œå°±è´¡çŒ®äº† `rPtr` ä¸ªé€†åºå¯¹ã€‚\n\nåˆ©ç”¨è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºå¦‚ä¸‹ä»£ç ã€‚\n\n**ä»£ç **\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r) {\n        if (l >= r) {\n            return 0;\n        }\n\n        int mid = (l + r) / 2;\n        int inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + 1, r);\n        int i = l, j = mid + 1, pos = l;\n        while (i <= mid && j <= r) {\n            if (nums[i] <= nums[j]) {\n                tmp[pos] = nums[i];\n                ++i;\n                inv_count += (j - (mid + 1));\n            }\n            else {\n                tmp[pos] = nums[j];\n                ++j;\n            }\n            ++pos;\n        }\n        for (int k = i; k <= mid; ++k) {\n            tmp[pos++] = nums[k];\n            inv_count += (j - (mid + 1));\n        }\n        for (int k = j; k <= r; ++k) {\n            tmp[pos++] = nums[k];\n        }\n        copy(tmp.begin() + l, tmp.begin() + r + 1, nums.begin() + l);\n        return inv_count;\n    }\n\n    int reversePairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> tmp(n);\n        return mergeSort(nums, tmp, 0, n - 1);\n    }\n};\n```\n\n```Java [sol1-Java]\npublic class Solution {\n    public int reversePairs(int[] nums) {\n        int len = nums.length;\n\n        if (len < 2) {\n            return 0;\n        }\n\n        int[] copy = new int[len];\n        for (int i = 0; i < len; i++) {\n            copy[i] = nums[i];\n        }\n\n        int[] temp = new int[len];\n        return reversePairs(copy, 0, len - 1, temp);\n    }\n\n    private int reversePairs(int[] nums, int left, int right, int[] temp) {\n        if (left == right) {\n            return 0;\n        }\n\n        int mid = left + (right - left) / 2;\n        int leftPairs = reversePairs(nums, left, mid, temp);\n        int rightPairs = reversePairs(nums, mid + 1, right, temp);\n\n        if (nums[mid] <= nums[mid + 1]) {\n            return leftPairs + rightPairs;\n        }\n\n        int crossPairs = mergeAndCount(nums, left, mid, right, temp);\n        return leftPairs + rightPairs + crossPairs;\n    }\n\n    private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) {\n        for (int i = left; i <= right; i++) {\n            temp[i] = nums[i];\n        }\n\n        int i = left;\n        int j = mid + 1;\n\n        int count = 0;\n        for (int k = left; k <= right; k++) {\n\n            if (i == mid + 1) {\n                nums[k] = temp[j];\n                j++;\n            } else if (j == right + 1) {\n                nums[k] = temp[i];\n                i++;\n            } else if (temp[i] <= temp[j]) {\n                nums[k] = temp[i];\n                i++;\n            } else {\n                nums[k] = temp[j];\n                j++;\n                count += (mid - i + 1);\n            }\n        }\n        return count;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def mergeSort(self, nums, tmp, l, r):\n        if l >= r:\n            return 0\n\n        mid = (l + r) // 2\n        inv_count = self.mergeSort(nums, tmp, l, mid) + self.mergeSort(nums, tmp, mid + 1, r)\n        i, j, pos = l, mid + 1, l\n        while i <= mid and j <= r:\n            if nums[i] <= nums[j]:\n                tmp[pos] = nums[i]\n                i += 1\n                inv_count += (j - (mid + 1))\n            else:\n                tmp[pos] = nums[j]\n                j += 1\n            pos += 1\n        for k in range(i, mid + 1):\n            tmp[pos] = nums[k]\n            inv_count += (j - (mid + 1))\n            pos += 1\n        for k in range(j, r + 1):\n            tmp[pos] = nums[k]\n            pos += 1\n        nums[l:r+1] = tmp[l:r+1]\n        return inv_count\n\n    def reversePairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        tmp = [0] * n\n        return self.mergeSort(nums, tmp, 0, n - 1)\n```\n\n```Golang [sol1-Golang]\nfunc reversePairs(nums []int) int {\n    return mergeSort(nums, 0, len(nums)-1)\n}\n\nfunc mergeSort(nums []int, start, end int) int {\n    if start >= end {\n        return 0\n    }\n    mid := start + (end - start)/2\n    cnt := mergeSort(nums, start, mid) + mergeSort(nums, mid + 1, end)\n    tmp := []int{}\n    i, j := start, mid + 1\n    for i <= mid && j <= end {\n        if nums[i] <= nums[j] {\n            tmp = append(tmp, nums[i])\n            cnt += j - (mid + 1)\n            i++\n        } else {\n            tmp = append(tmp, nums[j])\n            j++\n        }\n    }\n    for ; i <= mid; i++ {\n        tmp = append(tmp, nums[i])\n        cnt += end - (mid + 1) + 1\n    }\n    for ; j <= end; j++ {\n        tmp = append(tmp, nums[j])\n    }\n    for i := start; i <= end; i++ {\n        nums[i] = tmp[i - start]\n    }\n    return cnt\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\nè®°åºåˆ—é•¿åº¦ä¸º $n$ã€‚\n\n- æ—¶é—´å¤æ‚åº¦ï¼šåŒå½’å¹¶æ’åº $O(n \\log n)$ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šåŒå½’å¹¶æ’åº $O(n)$ï¼Œå› ä¸ºå½’å¹¶æ’åºéœ€è¦ç”¨åˆ°ä¸€ä¸ªä¸´æ—¶æ•°ç»„ã€‚\n\n#### æ–¹æ³•äºŒï¼šç¦»æ•£åŒ–æ ‘çŠ¶æ•°ç»„\n\n**é¢„å¤‡çŸ¥è¯†**\n\nã€Œæ ‘çŠ¶æ•°ç»„ã€æ˜¯ä¸€ç§å¯ä»¥åŠ¨æ€ç»´æŠ¤åºåˆ—å‰ç¼€å’Œçš„æ•°æ®ç»“æ„ï¼Œå®ƒçš„åŠŸèƒ½æ˜¯ï¼š\n\n+ **å•ç‚¹æ›´æ–° `update(i, v)`ï¼š** æŠŠåºåˆ— $i$ ä½ç½®çš„æ•°åŠ ä¸Šä¸€ä¸ªå€¼ $v$ï¼Œè¿™é¢˜ $v = 1$\n+ **åŒºé—´æŸ¥è¯¢ `query(i)`ï¼š** æŸ¥è¯¢åºåˆ— $[1 \\cdots i]$ åŒºé—´çš„åŒºé—´å’Œï¼Œå³ $i$ ä½ç½®çš„å‰ç¼€å’Œ\n\nä¿®æ”¹å’ŒæŸ¥è¯¢çš„æ—¶é—´ä»£ä»·éƒ½æ˜¯ $O(\\log n)$ï¼Œå…¶ä¸­ $n$ ä¸ºéœ€è¦ç»´æŠ¤å‰ç¼€å’Œçš„åºåˆ—çš„é•¿åº¦ã€‚\n\n\n**æ€è·¯**\n\nè®°é¢˜ç›®ç»™å®šçš„åºåˆ—ä¸º $a$ï¼Œæˆ‘ä»¬è§„å®š $a_i$ çš„å–å€¼é›†åˆä¸º $a$ çš„ã€Œå€¼åŸŸã€ã€‚æˆ‘ä»¬ç”¨æ¡¶æ¥è¡¨ç¤ºå€¼åŸŸä¸­çš„æ¯ä¸€ä¸ªæ•°ï¼Œæ¡¶ä¸­è®°å½•è¿™äº›æ•°å­—å‡ºç°çš„æ¬¡æ•°ã€‚å‡è®¾$a = \\{5, 5, 2, 3, 6\\}$ï¼Œé‚£ä¹ˆéå†è¿™ä¸ªåºåˆ—å¾—åˆ°çš„æ¡¶æ˜¯è¿™æ ·çš„ï¼š\n\n```\nindex  ->  1 2 3 4 5 6 7 8 9\nvalue  ->  0 1 1 0 2 1 0 0 0\n```\n\næˆ‘ä»¬å¯ä»¥çœ‹å‡ºå®ƒç¬¬ $i - 1$ ä½çš„å‰ç¼€å’Œè¡¨ç¤ºã€Œæœ‰å¤šå°‘ä¸ªæ•°æ¯” $i$ å°ã€ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä»åå¾€å‰éå†åºåˆ— $a$ï¼Œè®°å½“å‰éå†åˆ°çš„å…ƒç´ ä¸º $a_i$ï¼Œæˆ‘ä»¬æŠŠ $a_i$ å¯¹åº”çš„æ¡¶çš„å€¼è‡ªå¢ $1$ï¼ŒæŠŠ $i - 1$ ä½ç½®çš„å‰ç¼€å’ŒåŠ å…¥åˆ°ç­”æ¡ˆä¸­ç®—è´¡çŒ®ã€‚ä¸ºä»€ä¹ˆè¿™ä¹ˆåšæ˜¯å¯¹çš„å‘¢ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨å¾ªç¯çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬æŠŠåŸåºåˆ—åˆ†æˆäº†ä¸¤éƒ¨åˆ†ï¼ŒååŠéƒ¨éƒ¨åˆ†å·²ç»éå†è¿‡ï¼ˆå·²å…¥æ¡¶ï¼‰ï¼Œå‰åŠéƒ¨åˆ†æ˜¯å¾…éå†çš„ï¼ˆæœªå…¥æ¡¶ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ±‚åˆ°çš„ $i - 1$ ä½ç½®çš„å‰ç¼€å’Œå°±æ˜¯ã€Œå·²å…¥æ¡¶ã€çš„å…ƒç´ ä¸­æ¯” $a_i$ å¤§çš„å…ƒç´ çš„æ€»å’Œï¼Œè€Œè¿™äº›å…ƒç´ åœ¨åŸåºåˆ—ä¸­æ’åœ¨ $a_i$ çš„åé¢ï¼Œä½†å®ƒä»¬æœ¬åº”è¯¥æ’åœ¨ $a_i$ çš„å‰é¢ï¼Œè¿™æ ·å°±å½¢æˆäº†é€†åºå¯¹ã€‚\n\næˆ‘ä»¬æ˜¾ç„¶å¯ä»¥ç”¨æ•°ç»„æ¥å®ç°è¿™ä¸ªæ¡¶ï¼Œå¯é—®é¢˜æ˜¯å¦‚æœ $a_i$ ä¸­æœ‰å¾ˆå¤§çš„å…ƒç´ ï¼Œæ¯”å¦‚ $10^9$ï¼Œæˆ‘ä»¬å°±è¦å¼€ä¸€ä¸ªå¤§å°ä¸º $10^9$ çš„æ¡¶ï¼Œå†…å­˜ä¸­æ˜¯å­˜ä¸ä¸‹çš„ã€‚è¿™ä¸ªæ¡¶æ•°ç»„ä¸­å¾ˆå¤šä½ç½®æ˜¯ $0$ï¼Œæœ‰æ•ˆä½ç½®æ˜¯ç¨€ç–çš„ï¼Œæˆ‘ä»¬è¦æƒ³ä¸€ä¸ªåŠæ³•è®©æœ‰æ•ˆçš„ä½ç½®å…¨èšé›†åˆ°ä¸€èµ·ï¼Œå‡å°‘æ— æ•ˆä½ç½®çš„å‡ºç°ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å°±éœ€è¦ç”¨åˆ°ä¸€ä¸ªæ–¹æ³•â€”â€”ç¦»æ•£åŒ–ã€‚\n\nç¦»æ•£åŒ–ä¸€ä¸ªåºåˆ—çš„å‰ææ˜¯æˆ‘ä»¬åªå…³å¿ƒè¿™ä¸ªåºåˆ—é‡Œé¢å…ƒç´ çš„ç›¸å¯¹å¤§å°ï¼Œè€Œä¸å…³å¿ƒç»å¯¹å¤§å°ï¼ˆå³åªå…³å¿ƒå…ƒç´ åœ¨åºåˆ—ä¸­çš„æ’åï¼‰ï¼›ç¦»æ•£åŒ–çš„ç›®çš„æ˜¯è®©åŸæ¥åˆ†å¸ƒé›¶æ•£çš„å€¼èšé›†åˆ°ä¸€èµ·ï¼Œå‡å°‘ç©ºé—´æµªè´¹ã€‚é‚£ä¹ˆå¦‚ä½•è·å¾—å…ƒç´ æ’åå‘¢ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹åŸåºåˆ—æ’åºåå»é‡ï¼Œå¯¹äºæ¯ä¸€ä¸ª $a_i$ é€šè¿‡äºŒåˆ†æŸ¥æ‰¾çš„æ–¹å¼è®¡ç®—æ’åä½œä¸ºç¦»æ•£åŒ–ä¹‹åçš„å€¼ã€‚å½“ç„¶è¿™é‡Œä¹Ÿå¯ä»¥ä¸å»é‡ï¼Œä¸å½±å“æ’åã€‚\n\n**ä»£ç **\n\n```C++ [sol2-C++]\nclass BIT {\nprivate:\n    vector<int> tree;\n    int n;\n\npublic:\n    BIT(int _n): n(_n), tree(_n + 1) {}\n\n    static int lowbit(int x) {\n        return x & (-x);\n    }\n\n    int query(int x) {\n        int ret = 0;\n        while (x) {\n            ret += tree[x];\n            x -= lowbit(x);\n        }\n        return ret;\n    }\n\n    void update(int x) {\n        while (x <= n) {\n            ++tree[x];\n            x += lowbit(x);\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int reversePairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> tmp = nums;\n        // ç¦»æ•£åŒ–\n        sort(tmp.begin(), tmp.end());\n        for (int& num: nums) {\n            num = lower_bound(tmp.begin(), tmp.end(), num) - tmp.begin() + 1;\n        }\n        // æ ‘çŠ¶æ•°ç»„ç»Ÿè®¡é€†åºå¯¹\n        BIT bit(n);\n        int ans = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            ans += bit.query(nums[i] - 1);\n            bit.update(nums[i]);\n        }\n        return ans;\n    }\n};\n```\n```Java [sol2-Java]\nclass Solution {\n    public int reversePairs(int[] nums) {\n        int n = nums.length;\n        int[] tmp = new int[n];\n        System.arraycopy(nums, 0, tmp, 0, n);\n        // ç¦»æ•£åŒ–\n        Arrays.sort(tmp);\n        for (int i = 0; i < n; ++i) {\n            nums[i] = Arrays.binarySearch(tmp, nums[i]) + 1;\n        }\n        // æ ‘çŠ¶æ•°ç»„ç»Ÿè®¡é€†åºå¯¹\n        BIT bit = new BIT(n);\n        int ans = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            ans += bit.query(nums[i] - 1);\n            bit.update(nums[i]);\n        }\n        return ans;\n    }\n}\n\nclass BIT {\n    private int[] tree;\n    private int n;\n\n    public BIT(int n) {\n        this.n = n;\n        this.tree = new int[n + 1];\n    }\n\n    public static int lowbit(int x) {\n        return x & (-x);\n    }\n\n    public int query(int x) {\n        int ret = 0;\n        while (x != 0) {\n            ret += tree[x];\n            x -= lowbit(x);\n        }\n        return ret;\n    }\n\n    public void update(int x) {\n        while (x <= n) {\n            ++tree[x];\n            x += lowbit(x);\n        }\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    @staticmethod\n    def lowbit(x):\n        return x & (-x)\n    \n    def query(self, x):\n        ret = 0\n        while x > 0:\n            ret += self.tree[x]\n            x -= BIT.lowbit(x)\n        return ret\n\n    def update(self, x):\n        while x <= self.n:\n            self.tree[x] += 1\n            x += BIT.lowbit(x)\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        # ç¦»æ•£åŒ–\n        tmp = sorted(nums)\n        for i in range(n):\n            nums[i] = bisect.bisect_left(tmp, nums[i]) + 1\n        # æ ‘çŠ¶æ•°ç»„ç»Ÿè®¡é€†åºå¯¹\n        bit = BIT(n)\n        ans = 0\n        for i in range(n - 1, -1, -1):\n            ans += bit.query(nums[i] - 1)\n            bit.update(nums[i])\n        return ans\n```\n\n```Golang [sol2-Golang]\nfunc reversePairs(nums []int) int {\n     n := len(nums)\n     tmp := make([]int, n)\n     copy(tmp, nums)\n     sort.Ints(tmp)\n\n     for i := 0; i < n; i++ {\n         nums[i] = sort.SearchInts(tmp, nums[i]) + 1\n     }\n\n     bit := BIT{\n         n: n,\n         tree: make([]int, n + 1),\n     }\n\n     ans := 0\n     for i := n - 1; i >= 0; i-- {\n         ans += bit.query(nums[i] - 1)\n         bit.update(nums[i])\n     }\n     return ans\n}\n\ntype BIT struct {\n    n int\n    tree []int\n}\n\nfunc (b BIT) lowbit(x int) int { return x & (-x) }\n\nfunc (b BIT) query(x int) int {\n    ret := 0\n    for x > 0 {\n        ret += b.tree[x]\n        x -= b.lowbit(x)\n    }\n    return ret\n}\n\nfunc (b BIT) update(x int) {\n    for x <= b.n {\n        b.tree[x]++\n        x += b.lowbit(x)\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šç¦»æ•£åŒ–çš„è¿‡ç¨‹ä¸­ä½¿ç”¨äº†æ—¶é—´ä»£ä»·ä¸º $O(n \\log n)$ çš„æ’åºï¼Œå•æ¬¡äºŒåˆ†çš„æ—¶é—´ä»£ä»·ä¸º $O(\\log n)$ï¼Œä¸€å…±æœ‰ $n$ æ¬¡ï¼Œæ€»æ—¶é—´ä»£ä»·ä¸º $O(n \\log n)$ï¼›å¾ªç¯æ‰§è¡Œ $n$ æ¬¡ï¼Œæ¯æ¬¡è¿›è¡Œ $O(\\log n)$ çš„ä¿®æ”¹å’Œ $O(\\log n)$ çš„æŸ¥æ‰¾ï¼Œæ€»æ—¶é—´ä»£ä»·ä¸º $O(n \\log n)$ã€‚æ•…æ¸è¿›æ—¶é—´å¤æ‚åº¦ä¸º $O(n \\log n)$ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šæ ‘çŠ¶æ•°ç»„éœ€è¦ä½¿ç”¨é•¿åº¦ä¸º $n$ çš„æ•°ç»„ä½œä¸ºè¾…åŠ©ç©ºé—´ï¼Œæ•…æ¸è¿›ç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ã€‚"
}