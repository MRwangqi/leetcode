{
	"titleSlug": "number-of-good-paths",
	"slug": "bing-cha-ji-by-endlesscheng-tbz8",
	"url": "https://leetcode-cn.com/problems/number-of-good-paths/solution/bing-cha-ji-by-endlesscheng-tbz8/",
	"content": "[视频讲解](https://www.bilibili.com/video/BV1ve411K7P5) 已出炉，欢迎点赞三连，在评论区分享你对这场周赛的看法~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n当涉及到最大/最小的约束时，往往要按照节点值的顺序思考。\r\n\r\n应该从大到小，还是从小到大呢？\r\n\r\n#### 提示 2\r\n\r\n一种比较暴力的思路是，先考虑节点值最大的这些点，设有 $x$ 个，那么会形成 $C(x,2) = \\dfrac{x(x-1)}{2}$ 条长度大于 $1$ 的好路径。\r\n\r\n然后从树中删去这些点，再递归考虑剩下的各个连通块内的好路径个数。\r\n\r\n但这样每个节点会被多次统计，最坏情况下时间复杂度为 $O(n^2)$。\r\n\r\n#### 提示 3\r\n\r\n倒着思考这一过程，把删除改为合并，你想到了哪个数据结构？\r\n\r\n#### 提示 4\r\n\r\n并查集。\r\n\r\n#### 提示 5\r\n\r\n按节点值从小到大考虑，同时用并查集合并时，**总是从节点值小的点往节点值大的点合并**，这样可以保证连通块的代表元的节点值是最大的。\r\n\r\n对于节点 $x$ 及其邻居 $y$，如果 $y$ 所处的连通分量的最大节点值不超过 $\\textit{vals}[x]$，那么可以把 $y$ 所处的连通块合并到 $x$ 所处的连通块中。\r\n\r\n如果此时这两个连通块的最大节点值相同，那么可以根据乘法原理，把这两个连通块内的等于最大节点值的节点个数相乘，加到答案中。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\r\n        n = len(vals)\r\n        g = [[] for _ in range(n)]\r\n        for x, y in edges:\r\n            g[x].append(y)\r\n            g[y].append(x)  # 建图\r\n\r\n        # 并查集模板\r\n        fa = list(range(n))\r\n        # size[x] 表示节点值等于 vals[x] 的节点个数，如果按照节点值从小到大合并，size[x] 也是连通块内的等于最大节点值的节点个数\r\n        size = [1] * n\r\n        def find(x: int) -> int:\r\n            if fa[x] != x:\r\n                fa[x] = find(fa[x])\r\n            return fa[x]\r\n\r\n        ans = n\r\n        for vx, x in sorted(zip(vals, range(n))):\r\n            fx = find(x)\r\n            for y in g[x]:\r\n                y = find(y)\r\n                if y == fx or vals[y] > vx: continue  # 只考虑最大节点值比 vx 小的连通块\r\n                if vals[y] == vx:  # 可以构成好路径\r\n                    ans += size[fx] * size[y]  # 乘法原理\r\n                    size[fx] += size[y]  # 统计连通块内节点值等于 vx 的节点个数\r\n                fa[y] = fx  # 把小的节点值合并到大的节点值上\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    int[] fa;\r\n\r\n    public int numberOfGoodPaths(int[] vals, int[][] edges) {\r\n        var n = vals.length;\r\n        List<Integer>[] g = new ArrayList[n];\r\n        Arrays.setAll(g, e -> new ArrayList<>());\r\n        for (var e : edges) {\r\n            int x = e[0], y = e[1];\r\n            g[x].add(y);\r\n            g[y].add(x); // 建图\r\n        }\r\n\r\n        fa = new int[n];\r\n        for (var i = 0; i < n; i++) fa[i] = i;\r\n        // size[x] 表示节点值等于 vals[x] 的节点个数，如果按照节点值从小到大合并，size[x] 也是连通块内的等于最大节点值的节点个数\r\n        var size = new int[n];\r\n        Arrays.fill(size, 1);\r\n        var id = IntStream.range(0, n).boxed().toArray(Integer[]::new);\r\n        Arrays.sort(id, (i, j) -> vals[i] - vals[j]);\r\n\r\n        var ans = n;\r\n        for (var x : id) {\r\n            int vx = vals[x], fx = find(x);\r\n            for (var y : g[x]) {\r\n                y = find(y);\r\n                if (y == fx || vals[y] > vx) continue; // 只考虑最大节点值比 vx 小的连通块\r\n                if (vals[y] == vx) { // 可以构成好路径\r\n                    ans += size[fx] * size[y]; // 乘法原理\r\n                    size[fx] += size[y]; // 统计连通块内节点值等于 vx 的节点个数\r\n                }\r\n                fa[y] = fx; // 把小的节点值合并到大的节点值上\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    int find(int x) {\r\n        if (fa[x] != x) fa[x] = find(fa[x]);\r\n        return fa[x];\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int numberOfGoodPaths(vector<int> &vals, vector<vector<int>> &edges) {\r\n        int n = vals.size();\r\n        vector<vector<int>> g(n);\r\n        for (auto &e : edges) {\r\n            int x = e[0], y = e[1];\r\n            g[x].push_back(y);\r\n            g[y].push_back(x); // 建图\r\n        }\r\n\r\n        // 并查集模板\r\n        // size[x] 表示节点值等于 vals[x] 的节点个数，如果按照节点值从小到大合并，size[x] 也是连通块内的等于最大节点值的节点个数\r\n        int id[n], fa[n], size[n]; // id 后面排序用\r\n        iota(id, id + n, 0);\r\n        iota(fa, fa + n, 0);\r\n        fill(size, size + n, 1);\r\n        function<int(int)> find = [&](int x) -> int { return fa[x] == x ? x : fa[x] = find(fa[x]); };\r\n\r\n        int ans = n;\r\n        sort(id, id + n, [&](int i, int j) { return vals[i] < vals[j]; });\r\n        for (int x : id) {\r\n            int vx = vals[x], fx = find(x);\r\n            for (int y : g[x]) {\r\n                y = find(y);\r\n                if (y == fx || vals[y] > vx) continue; // 只考虑最大节点值比 vx 小的连通块\r\n                if (vals[y] == vx) { // 可以构成好路径\r\n                    ans += size[fx] * size[y]; // 乘法原理\r\n                    size[fx] += size[y]; // 统计连通块内节点值等于 vx 的节点个数\r\n                }\r\n                fa[y] = fx; // 把小的节点值合并到大的节点值上\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc numberOfGoodPaths(vals []int, edges [][]int) int {\r\n\tn := len(vals)\r\n\tg := make([][]int, n)\r\n\tfor _, e := range edges {\r\n\t\tx, y := e[0], e[1]\r\n\t\tg[x] = append(g[x], y)\r\n\t\tg[y] = append(g[y], x) // 建图\r\n\t}\r\n\r\n\t// 并查集模板\r\n\tfa := make([]int, n)\r\n\t// size[x] 表示节点值等于 vals[x] 的节点个数，如果按照节点值从小到大合并，size[x] 也是连通块内的等于最大节点值的节点个数\r\n\tsize := make([]int, n) \r\n\tid := make([]int, n) // 后面排序用\r\n\tfor i := range fa {\r\n\t\tfa[i] = i\r\n\t\tsize[i] = 1\r\n\t\tid[i] = i\r\n\t}\r\n\tvar find func(int) int\r\n\tfind = func(x int) int {\r\n\t\tif fa[x] != x {\r\n\t\t\tfa[x] = find(fa[x])\r\n\t\t}\r\n\t\treturn fa[x]\r\n\t}\r\n\r\n\tans := n\r\n\tsort.Slice(id, func(i, j int) bool { return vals[id[i]] < vals[id[j]] })\r\n\tfor _, x := range id {\r\n\t\tvx := vals[x]\r\n\t\tfx := find(x)\r\n\t\tfor _, y := range g[x] {\r\n\t\t\ty = find(y)\r\n\t\t\tif y == fx || vals[y] > vx { // 只考虑最大节点值比 vx 小的连通块\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif vals[y] == vx { // 可以构成好路径\r\n\t\t\t\tans += size[fx] * size[y] // 乘法原理\r\n\t\t\t\tsize[fx] += size[y] // 统计连通块内节点值等于 vx 的节点个数\r\n\t\t\t}\r\n\t\t\tfa[y] = fx // 把小的节点值合并到大的节点值上\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\log n)$，其中 $n$ 为 $\\textit{vals}$ 的长度。\r\n- 空间复杂度：$O(n)$。\r\n"
}