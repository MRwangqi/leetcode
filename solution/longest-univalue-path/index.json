{
	"titleSlug": "longest-univalue-path",
	"slug": "zui-chang-tong-zhi-lu-jing-by-leetcode-s-hgfk",
	"url": "https://leetcode-cn.com/problems/longest-univalue-path/solution/zui-chang-tong-zhi-lu-jing-by-leetcode-s-hgfk/",
	"content": "#### 方法一：深度优先搜索\n\n我们将二叉树看成一个有向图（从父结点指向子结点的边），定义同值有向路径为从某一结点出发，到达它的某一后代节点的路径，且经过的结点的值相同。最长同值路径长度必定为某一节点的左最长同值有向路径长度与右最长同值有向路径长度之和。\n\n使用变量 $\\textit{res}$ 保存最长同值路径长度。我们对根结点进行深度优先搜索，对于当前搜索的结点 $\\textit{root}$，我们分别获取它左结点的最长同值有向路径长度 $\\textit{left}$，右结点的最长同值有向路径长度 $\\textit{right}$。如果结点 $\\textit{root}$ 的左结点非空且结点 $\\textit{root}$ 的值与它的左结点的值相等，那么结点 $\\textit{root}$ 的左最长同值有向路径长度 $\\textit{left}_1 = \\textit{left} + 1$，否则 $\\textit{left}_1 = 0$；如果结点 $\\textit{root}$ 的右结点非空且结点 $\\textit{root}$ 的值与它的右结点的值相等，那么结点 $\\textit{root}$ 的右最长同值有向路径长度 $\\textit{right}_1 = \\textit{right} + 1$，否则 $\\textit{right}_1 = 0$。令 $\\textit{res} = \\max (res, \\textit{left}_1 + \\textit{right}_1)$，并且返回结点 $\\textit{root}$ 对应的最长同值有向路径长度 $\\max (\\textit{left}_1, \\textit{right}_1)$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:\n        ans = 0\n        def dfs(node: Optional[TreeNode]) -> int:\n            if node is None:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            left1 = left + 1 if node.left and node.left.val == node.val else 0\n            right1 = right + 1 if node.right and node.right.val == node.val else 0\n            nonlocal ans\n            ans = max(ans, left1 + right1)\n            return max(left1, right1)\n        dfs(root)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    int res;\n\npublic:\n    int longestUnivaluePath(TreeNode* root) {\n        res = 0;\n        dfs(root);\n        return res;\n    }\n\n    int dfs(TreeNode *root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        int left = dfs(root->left), right = dfs(root->right);\n        int left1 = 0, right1 = 0;\n        if (root->left && root->left->val == root->val) {\n            left1 = left + 1;\n        }\n        if (root->right && root->right->val == root->val) {\n            right1 = right + 1;\n        }\n        res = max(res, left1 + right1);\n        return max(left1, right1);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    int res;\n\n    public int longestUnivaluePath(TreeNode root) {\n        res = 0;\n        dfs(root);\n        return res;\n    }\n\n    public int dfs(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = dfs(root.left), right = dfs(root.right);\n        int left1 = 0, right1 = 0;\n        if (root.left != null && root.left.val == root.val) {\n            left1 = left + 1;\n        }\n        if (root.right != null && root.right.val == root.val) {\n            right1 = right + 1;\n        }\n        res = Math.max(res, left1 + right1);\n        return Math.max(left1, right1);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    int res;\n\n    public int LongestUnivaluePath(TreeNode root) {\n        res = 0;\n        DFS(root);\n        return res;\n    }\n\n    public int DFS(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = DFS(root.left), right = DFS(root.right);\n        int left1 = 0, right1 = 0;\n        if (root.left != null && root.left.val == root.val) {\n            left1 = left + 1;\n        }\n        if (root.right != null && root.right.val == root.val) {\n            right1 = right + 1;\n        }\n        res = Math.Max(res, left1 + right1);\n        return Math.Max(left1, right1);\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint dfs(struct TreeNode *root, int *res) {\n    if (root == NULL) {\n        return 0;\n    }\n    int left = dfs(root->left, res), right = dfs(root->right, res);\n    int left1 = 0, right1 = 0;\n    if (root->left && root->left->val == root->val) {\n        left1 = left + 1;\n    }\n    if (root->right && root->right->val == root->val) {\n        right1 = right + 1;\n    }\n    *res = MAX(*res, left1 + right1);\n    return MAX(left1, right1);\n}\n\nint longestUnivaluePath(struct TreeNode* root){\n    int res = 0;\n    dfs(root, &res);\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar longestUnivaluePath = function(root) {\n    let res = 0;\n    const dfs = (root) => {\n        if (!root) {\n            return 0;\n        }\n        let left = dfs(root.left), right = dfs(root.right);\n        let left1 = 0, right1 = 0;\n        if (root.left && root.left.val === root.val) {\n            left1 = left + 1;\n        }\n        if (root.right && root.right.val === root.val) {\n            right1 = right + 1;\n        }\n        res = Math.max(res, left1 + right1);\n        return Math.max(left1, right1);\n    }\n    dfs(root);\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc longestUnivaluePath(root *TreeNode) (ans int) {\n    var dfs func(*TreeNode) int\n    dfs = func(node *TreeNode) int {\n        if node == nil {\n            return 0\n        }\n        left := dfs(node.Left)\n        right := dfs(node.Right)\n        left1, right1 := 0, 0\n        if node.Left != nil && node.Left.Val == node.Val {\n            left1 = left + 1\n        }\n        if node.Right != nil && node.Right.Val == node.Val {\n            right1 = right + 1\n        }\n        ans = max(ans, left1+right1)\n        return max(left1, right1)\n    }\n    dfs(root)\n    return ans\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 为树的结点数目。\n\n+ 空间复杂度：$O(n)$。递归栈最坏情况下需要 $O(n)$ 的空间。"
}