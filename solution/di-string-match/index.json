{
	"titleSlug": "di-string-match",
	"slug": "zeng-jian-zi-fu-chuan-pi-pei-by-leetcode-jzm2",
	"url": "https://leetcode-cn.com/problems/di-string-match/solution/zeng-jian-zi-fu-chuan-pi-pei-by-leetcode-jzm2/",
	"content": "#### 方法一：贪心\n\n考虑 $\\textit{perm}[0]$ 的值，根据题意：\n\n- 如果 $s[0]=\\texttt{`I'}$，那么令 $\\textit{perm}[0]=0$，则无论 $\\textit{perm}[1]$ 为何值都满足 $\\textit{perm}[0] < \\textit{perm}[1]$；\n- 如果 $s[0]=\\texttt{`D'}$，那么令 $\\textit{perm}[0]=n$，则无论 $\\textit{perm}[1]$ 为何值都满足 $\\textit{perm}[0] > \\textit{perm}[1]$；\n\n确定好 $\\textit{perm}[0]$ 后，剩余的 $n-1$ 个字符和 $n$ 个待确定的数就变成了一个和原问题相同，但规模为 $n-1$ 的问题。因此我们可以继续按照上述方法确定 $\\textit{perm}[1]$：如果 $s[1]=\\texttt{`I'}$，那么令 $\\textit{perm}[1]$ 为剩余数字中的最小数；如果 $s[1]=\\texttt{`D'}$，那么令 $\\textit{perm}[1]$ 为剩余数字中的最大数。如此循环直至剩下一个数，填入 $\\textit{perm}[n]$ 中。\n\n代码实现时，由于每次都选择的是最小数和最大数，我们可以用两个变量 $\\textit{lo}$ 和 $\\textit{hi}$ 表示当前剩余数字中的最小数和最大数。\n\n```Python [sol1-Python3]\nclass Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        lo = 0\n        hi = n = len(s)\n        perm = [0] * (n + 1)\n        for i, ch in enumerate(s):\n            if ch == 'I':\n                perm[i] = lo\n                lo += 1\n            else:\n                perm[i] = hi\n                hi -= 1\n        perm[n] = lo  # 最后剩下一个数，此时 lo == hi\n        return perm\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> diStringMatch(string s) {\n        int n = s.length(), lo = 0, hi = n;\n        vector<int> perm(n + 1);\n        for (int i = 0; i < n; ++i) {\n            perm[i] = s[i] == 'I' ? lo++ : hi--;\n        }\n        perm[n] = lo; // 最后剩下一个数，此时 lo == hi\n        return perm;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] diStringMatch(String s) {\n        int n = s.length(), lo = 0, hi = n;\n        int[] perm = new int[n + 1];\n        for (int i = 0; i < n; ++i) {\n            perm[i] = s.charAt(i) == 'I' ? lo++ : hi--;\n        }\n        perm[n] = lo; // 最后剩下一个数，此时 lo == hi\n        return perm;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] DiStringMatch(string s) {\n        int n = s.Length, lo = 0, hi = n;\n        int[] perm = new int[n + 1];\n        for (int i = 0; i < n; ++i) {\n            perm[i] = s[i] == 'I' ? lo++ : hi--;\n        }\n        perm[n] = lo; // 最后剩下一个数，此时 lo == hi\n        return perm;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc diStringMatch(s string) []int {\n    n := len(s)\n    perm := make([]int, n+1)\n    lo, hi := 0, n\n    for i, ch := range s {\n        if ch == 'I' {\n            perm[i] = lo\n            lo++\n        } else {\n            perm[i] = hi\n            hi--\n        }\n    }\n    perm[n] = lo // 最后剩下一个数，此时 lo == hi\n    return perm\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar diStringMatch = function(s) {\n    let n = s.length, lo = 0, hi = n;\n    const perm = new Array(n + 1).fill(0);\n    for (let i = 0; i < n; ++i) {\n        perm[i] = s[i] === 'I' ? lo++ : hi--;\n    }\n    perm[n] = lo; // 最后剩下一个数，此时 lo == hi\n    return perm;\n};\n```\n\n```C [sol1-C]\nint* diStringMatch(char * s, int* returnSize) {\n    int n = strlen(s), lo = 0, hi = n;\n    int *perm = (int *)malloc(sizeof(int) * (n + 1));\n    for (int i = 0; i < n; ++i) {\n        perm[i] = s[i] == 'I' ? lo++ : hi--;\n    }\n    perm[n] = lo; // 最后剩下一个数，此时 lo == hi\n    *returnSize = n + 1;\n    return perm;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。\n\n- 空间复杂度：$O(1)$，返回值不计入空间复杂度。"
}