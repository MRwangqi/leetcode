{
	"titleSlug": "simplified-fractions",
	"slug": "zui-jian-fen-shu-by-leetcode-solution-98zy",
	"url": "https://leetcode-cn.com/problems/simplified-fractions/solution/zui-jian-fen-shu-by-leetcode-solution-98zy/",
	"content": "#### 方法一：数学\n\n由于要保证分数在 $(0,1)$ 范围内，我们可以枚举分母 $\\textit{denominator}\\in [2,n]$ 和分子 $\\textit{numerator}\\in [1,\\textit{denominator})$，若分子分母的最大公约数为 $1$，则我们找到了一个最简分数。\n\n```Python [sol1-Python3]\nclass Solution:\n    def simplifiedFractions(self, n: int) -> List[str]:\n        return [f\"{numerator}/{denominator}\" for denominator in range(2, n + 1) for numerator in range(1, denominator) if gcd(denominator, numerator) == 1]\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> simplifiedFractions(int n) {\n        vector<string> ans;\n        for (int denominator = 2; denominator <= n; ++denominator) {\n            for (int numerator = 1; numerator < denominator; ++numerator) {\n                if (__gcd(numerator, denominator) == 1) {\n                    ans.emplace_back(to_string(numerator) + \"/\" + to_string(denominator));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<String> simplifiedFractions(int n) {\n        List<String> ans = new ArrayList<String>();\n        for (int denominator = 2; denominator <= n; ++denominator) {\n            for (int numerator = 1; numerator < denominator; ++numerator) {\n                if (gcd(numerator, denominator) == 1) {\n                    ans.add(numerator + \"/\" + denominator);\n                }\n            }\n        }\n        return ans;\n    }\n\n    public int gcd(int a, int b) {\n        return b != 0 ? gcd(b, a % b) : a;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<string> SimplifiedFractions(int n) {\n        IList<string> ans = new List<string>();\n        for (int denominator = 2; denominator <= n; ++denominator) {\n            for (int numerator = 1; numerator < denominator; ++numerator) {\n                if (GCD(numerator, denominator) == 1) {\n                    ans.Add(numerator + \"/\" + denominator);\n                }\n            }\n        }\n        return ans;\n    }\n\n    public int GCD(int a, int b) {\n        return b != 0 ? GCD(b, a % b) : a;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc simplifiedFractions(n int) (ans []string) {\n    for denominator := 2; denominator <= n; denominator++ {\n        for numerator := 1; numerator < denominator; numerator++ {\n            if gcd(numerator, denominator) == 1 {\n                ans = append(ans, strconv.Itoa(numerator)+\"/\"+strconv.Itoa(denominator))\n            }\n        }\n    }\n    return\n}\n\nfunc gcd(a, b int) int {\n    for a != 0 {\n        a, b = b%a, a\n    }\n    return b\n}\n```\n\n```C [sol1-C]\n#define MAX_FRACTION_LEN 10\n\nint gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nchar ** simplifiedFractions(int n, int* returnSize) {\n    char ** ans = (char **)malloc(sizeof(char *) * n * (n - 1) / 2 );\n    int pos = 0;\n    for (int denominator = 2; denominator <= n; denominator++) {\n        for (int numerator = 1; numerator < denominator; numerator++) {\n            if (gcd(numerator, denominator) == 1) {\n                ans[pos] = (char *)malloc(sizeof(char) * MAX_FRACTION_LEN);\n                snprintf(ans[pos++], MAX_FRACTION_LEN, \"%d%c%d\", numerator, '/', denominator);\n            }\n        }\n    }\n    *returnSize = pos;\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar simplifiedFractions = function(n) {\n    const ans = [];\n    for (let denominator = 2; denominator <= n; ++denominator) {\n        for (let numerator = 1; numerator < denominator; ++numerator) {\n            if (gcd(numerator, denominator) == 1) {\n                ans.push(numerator + \"/\" + denominator);\n            }\n        }\n    }\n    return ans;\n};\n\nconst gcd = (a, b) => {\n    if (b === 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2\\log n)$。需要枚举 $O(n^2)$ 对分子分母的组合，每对分子分母计算最大公因数和生成字符串的复杂度均为 $O(\\log n)$。\n\n- 空间复杂度：$O(1)$。除答案数组外，我们只需要常数个变量。"
}