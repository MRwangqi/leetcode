{
	"titleSlug": "count-unreachable-pairs-of-nodes-in-an-undirected-graph",
	"slug": "by-endlesscheng-7l50",
	"url": "https://leetcode-cn.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/solution/by-endlesscheng-7l50/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV143411w7Wx) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n建图后，用 DFS 可以求出每个连通块的大小。\r\n\r\n求连通块的大小的同时，用一个变量 $\\textit{tot}$ 维护前面求出的连通块的大小之和。设当前连通块的大小为 $\\textit{size}$，那么它对答案的贡献就是 $\\textit{size}\\cdot\\textit{tot}$。\r\n\r\n累加所有贡献，即为答案。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def countPairs(self, n: int, edges: List[List[int]]) -> int:\r\n        g = [[] for _ in range(n)]\r\n        for x, y in edges:\r\n            g[x].append(y)\r\n            g[y].append(x)\r\n\r\n        vis, ans, tot, size = [False] * n, 0, 0, 0\r\n        def dfs(x: int) -> None:\r\n            nonlocal size\r\n            vis[x] = True\r\n            size += 1\r\n            for y in g[x]:\r\n                if not vis[y]:\r\n                    dfs(y)\r\n        for i in range(n):\r\n            if not vis[i]:\r\n                size = 0\r\n                dfs(i)\r\n                ans += size * tot\r\n                tot += size\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    List<Integer>[] g;\r\n    boolean[] vis;\r\n    int cnt;\r\n\r\n    public long countPairs(int n, int[][] edges) {\r\n        g = new ArrayList[n];\r\n        Arrays.setAll(g, e -> new ArrayList<>());\r\n        for (var e : edges) {\r\n            int x = e[0], y = e[1];\r\n            g[x].add(y);\r\n            g[y].add(x);\r\n        }\r\n        vis = new boolean[n];\r\n        var ans = 0L;\r\n        for (int i = 0, tot = 0; i < n; ++i)\r\n            if (!vis[i]) {\r\n                cnt = 0;\r\n                dfs(i);\r\n                ans += (long) cnt * tot;\r\n                tot += cnt;\r\n            }\r\n        return ans;\r\n    }\r\n\r\n    void dfs(int x) {\r\n        vis[x] = true;\r\n        ++cnt;\r\n        for (var y : g[x]) if (!vis[y]) dfs(y);\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    long long countPairs(int n, vector<vector<int>> &edges) {\r\n        vector<vector<int>> g(n);\r\n        for (auto &e : edges) {\r\n            int x = e[0], y = e[1];\r\n            g[x].push_back(y);\r\n            g[y].push_back(x);\r\n        }\r\n\r\n        bool vis[n]; memset(vis, 0, sizeof(vis));\r\n        long ans = 0L;\r\n        int cnt = 0;\r\n        function<void(int)> dfs = [&](int x) {\r\n            vis[x] = true;\r\n            ++cnt;\r\n            for (int y: g[x]) if (!vis[y]) dfs(y);\r\n        };\r\n        for (int i = 0, tot = 0; i < n; ++i)\r\n            if (!vis[i]) {\r\n                cnt = 0;\r\n                dfs(i);\r\n                ans += (long) cnt * tot;\r\n                tot += cnt;\r\n            }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc countPairs(n int, edges [][]int) (ans int64) {\r\n\tg := make([][]int, n)\r\n\tfor _, e := range edges {\r\n\t\tx, y := e[0], e[1]\r\n\t\tg[x] = append(g[x], y)\r\n\t\tg[y] = append(g[y], x)\r\n\t}\r\n\r\n\tvis := make([]bool, n)\r\n\ttot, size := 0, 0\r\n\tvar dfs func(int)\r\n\tdfs = func(x int) {\r\n\t\tvis[x] = true\r\n\t\tsize++\r\n\t\tfor _, y := range g[x] {\r\n\t\t\tif !vis[y] {\r\n\t\t\t\tdfs(y)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor i, b := range vis {\r\n\t\tif !b {\r\n\t\t\tsize = 0\r\n\t\t\tdfs(i)\r\n\t\t\tans += int64(size) * int64(tot)\r\n\t\t\ttot += size\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n```\r\n"
}