{
	"titleSlug": "maximum-difference-between-increasing-elements",
	"slug": "zeng-liang-yuan-su-zhi-jian-de-zui-da-ch-i0wk",
	"url": "https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/solution/zeng-liang-yuan-su-zhi-jian-de-zui-da-ch-i0wk/",
	"content": "#### 方法一：前缀最小值\n\n**思路与算法**\n\n当我们固定 $j$ 时，选择的下标 $i$ 一定是满足 $0 \\leq i < j$ 并且 $\\textit{nums}[i]$ 最小的那个 $i$。因此我们可以使用循环对 $j$ 进行遍历，同时维护 $\\textit{nums}[0..j-1]$ 的**前缀最小值**，记为 $\\textit{premin}$。这样一来：\n\n- 如果 $\\textit{nums}[i] > \\textit{premin}$，那么就用 $\\textit{nums}[i] - \\textit{premin}$ 对答案进行更新；\n\n- 否则，用 $\\textit{nums}[i]$ 来更新前缀最小值 $\\textit{premin}$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maximumDifference(vector<int>& nums) {\n        int n = nums.size();\n        int ans = -1, premin = nums[0];\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] > premin) {\n                ans = max(ans, nums[i] - premin);\n            } else {\n                premin = nums[i];\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maximumDifference(int[] nums) {\n        int n = nums.length;\n        int ans = -1, premin = nums[0];\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] > premin) {\n                ans = Math.max(ans, nums[i] - premin);\n            } else {\n                premin = nums[i];\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MaximumDifference(int[] nums) {\n        int n = nums.Length;\n        int ans = -1, premin = nums[0];\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] > premin) {\n                ans = Math.Max(ans, nums[i] - premin);\n            } else {\n                premin = nums[i];\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def maximumDifference(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans, premin = -1, nums[0]\n\n        for i in range(1, n):\n            if nums[i] > premin:\n                ans = max(ans, nums[i] - premin)\n            else:\n                premin = nums[i]\n        \n        return ans\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint maximumDifference(int* nums, int numsSize){\n    int ans = -1, premin = nums[0];\n    for (int i = 1; i < numsSize; ++i) {\n        if (nums[i] > premin) {\n            ans = MAX(ans, nums[i] - premin);\n        } else {\n            premin = nums[i];\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maximumDifference = function(nums) {\n    const n = nums.length;\n    let ans = -1, premin = nums[0];\n    for (let i = 1; i < n; ++i) {\n        if (nums[i] > premin) {\n            ans = Math.max(ans, nums[i] - premin);\n        } else {\n            premin = nums[i];\n        }\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc maximumDifference(nums []int) int {\n    ans := -1\n    for i, preMin := 1, nums[0]; i < len(nums); i++ {\n        if nums[i] > preMin {\n            ans = max(ans, nums[i]-preMin)\n        } else {\n            preMin = nums[i]\n        }\n    }\n    return ans\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。我们只需要对数组 $\\textit{nums}$ 进行一次遍历。\n\n- 空间复杂度：$O(1)$。"
}