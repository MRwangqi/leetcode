{
	"titleSlug": "minimum-jumps-to-reach-home",
	"slug": "by-liupengsay-6km3",
	"url": "https://leetcode-cn.com/problems/minimum-jumps-to-reach-home/solution/by-liupengsay-6km3/",
	"content": "# 【儿须成名酒须醉】Python3+广度优先搜索\r\n***\r\n## 提交结果\r\n- 执行用时： 68 ms , 在所有 Python3 提交中击败了 84.33% 的用户\r\n- 内存消耗： 15.7 MB , 在所有 Python3 提交中击败了 82.95% 的用户\r\n- 通过测试用例： 95 / 95\r\n## 解题思路\r\n\r\n1. 从起点开始，使用广度优先搜索，并记录访问过的节点状态不再再次访问\r\n2. 本题的关键在于确定最远能到达的右边界，超出这个范围则中止\r\n3. 参见题解[到家的最少跳跃次数（最短路+证明）]可以得出最远达到的位置$n$有$n=max(f+a+b, x+b)$，其中$f$为$forbidden$的最大值\r\n\r\n## 性能优化\r\n\r\n- 无\r\n\r\n## 复杂度分析\r\n\r\n- 设最远达到的位置为$n$，则有\r\n    - 时间复杂度：$O(n)$\r\n    - 空间复杂度：$O(n)$\r\n    \r\n## 代码\r\n\r\n```Python3\r\nclass Solution:\r\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\r\n        if x == 0:\r\n            return 0\r\n        \r\n        visit = set()\r\n        for f in forbidden:\r\n            visit.add((f, -1))\r\n            visit.add((f, 1))\r\n        far = max(max(forbidden) + a + b, x + b)\r\n        \r\n        step = 1\r\n        stack = [(0, 0)]\r\n        while stack:\r\n            nex = []\r\n            for i, d in stack:\r\n                nodes = [(i + a, 1)]\r\n                if d != -1:\r\n                    nodes.append((i - b, -1))\r\n                for j, e in nodes:\r\n                    if 0 <= j <= far and (j, e) not in visit:\r\n                        if j == x:\r\n                            return step\r\n                        visit.add((j, e))\r\n                        nex.append((j, e))\r\n            stack = nex\r\n            step += 1\r\n        return -1\r\n```\r\n\r\n\r\n[到家的最少跳跃次数（最短路+证明）]: https://leetcode.cn/problems/minimum-jumps-to-reach-home/solution/dao-jia-de-zui-shao-tiao-yue-ci-shu-zui-duan-lu-zh/\r\n"
}