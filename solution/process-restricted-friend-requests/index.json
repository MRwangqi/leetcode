{
	"titleSlug": "process-restricted-friend-requests",
	"slug": "chu-li-han-xian-zhi-tiao-jian-de-hao-you-jj2q",
	"url": "https://leetcode-cn.com/problems/process-restricted-friend-requests/solution/chu-li-han-xian-zhi-tiao-jian-de-hao-you-jj2q/",
	"content": "#### 方法一：并查集\n\n**思路与算法**\n\n我们可以使用并查集维护朋友关系。\n\n我们依次处理每一条好友请求。对于请求 $[x_i, y_i]$，记 $x_i$ 和 $y_i$ 在并查集中的代表元素为 $x$ 和 $y$，那么：\n\n- 如果 $x = y$，那么它们 $x_i$ 和 $y_i$ 在之前已经是朋友了，这条好友请求也一定会成功；\n\n- 如果 $x \\neq y$，那么我们需要判断这条好友请求是否会违反规则，因此还需要枚举所有的限制。\n\n    对于限制 $[u_j, v_j]$，记 $u_j$ 和 $v_j$ 在并查集中的代表元素为 $u$ 和 $v$。在当前好友请求前，一定有 $u \\neq v$，并且我们希望如果当前好友请求成功，$u \\neq v$ 仍然成立，所以我们不能将 **$u$ 和 $v$ 所在的连通分量**合并起来。由于当前好友请求会合并 $x$ 和 $y$ 所在的连通分量，并且 $x, y, u, v$ 均为对应连通分量的代表元素，因此 $(x, y) = (u, v)$ 以及 $(y, x) = (v, u)$ 二者均不能成立，否则合并 $x$ 和 $y$ 所在的连通分量即为合并 $u$ 和 $v$ 所在的连通分量。\n    \n    如果所有的限制都满足，那么这条好友请求成功，否则失败。\n\n对于每一条成功的好友请求，我们需要在并查集中将对应的连通分量进行合并。\n\n**代码**\n\n```C++ [sol1-C++]\n// 并查集模板\nclass UnionFind {\npublic:\n    vector<int> parent;\n    vector<int> size;\n    int n;\n    // 当前连通分量数目\n    int setCount;\n    \npublic:\n    UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n    \n    int findset(int x) {\n        return parent[x] == x ? x : parent[x] = findset(parent[x]);\n    }\n    \n    bool unite(int x, int y) {\n        x = findset(x);\n        y = findset(y);\n        if (x == y) {\n            return false;\n        }\n        if (size[x] < size[y]) {\n            swap(x, y);\n        }\n        parent[y] = x;\n        size[x] += size[y];\n        --setCount;\n        return true;\n    }\n    \n    bool connected(int x, int y) {\n        x = findset(x);\n        y = findset(y);\n        return x == y;\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\n        UnionFind uf(n);\n        vector<bool> ans;\n        for (const auto& req: requests) {\n            int x = uf.findset(req[0]), y = uf.findset(req[1]);\n            if (x != y) {\n                bool check = true;\n                for (const auto& res: restrictions) {\n                    int u = uf.findset(res[0]), v = uf.findset(res[1]);\n                    if ((x == u && y == v) || (x == v && y == u)) {\n                        check = false;\n                        break;\n                    }\n                }\n                if (check) {\n                    ans.push_back(true);\n                    uf.unite(x, y);\n                }\n                else {\n                    ans.push_back(false);\n                }\n            }\n            else {\n                ans.push_back(true);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\n# 并查集模板\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.n = n\n        # 当前连通分量数目\n        self.setCount = n\n    \n    def findset(self, x: int) -> int:\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.findset(self.parent[x])\n        return self.parent[x]\n    \n    def unite(self, x: int, y: int) -> bool:\n        x, y = self.findset(x), self.findset(y)\n        if x == y:\n            return False\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.parent[y] = x\n        self.size[x] += self.size[y]\n        self.setCount -= 1\n        return True\n    \n    def connected(self, x: int, y: int) -> bool:\n        x, y = self.findset(x), self.findset(y)\n        return x == y\n\nclass Solution:\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n        uf = UnionFind(n)\n        ans = list()\n\n        for req in requests:\n            x, y = uf.findset(req[0]), uf.findset(req[1])\n            if x != y:\n                check = True\n                for res in restrictions:\n                    u, v = uf.findset(res[0]), uf.findset(res[1])\n                    if (x == u and y == v) or (x == v and y == u):\n                        check = False\n                        break\n                if check:\n                    ans.append(True)\n                    uf.unite(x, y)\n                else:\n                    ans.append(False)\n            else:\n                ans.append(True)\n        \n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn \\cdot \\alpha(n))$，其中 $m$ 是数组 $\\textit{restrictions}$ 的长度，$\\alpha(\\cdot)$ 是反阿克曼函数，表示在路径压缩和按秩合并优化下的并查集的单次操作时间复杂度。\n\n- 空间复杂度：$O(n)$，即为并查集需要使用的空间。"
}