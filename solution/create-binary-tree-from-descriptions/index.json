{
	"titleSlug": "create-binary-tree-from-descriptions",
	"slug": "gen-ju-miao-shu-chuang-jian-er-cha-shu-b-sqrk",
	"url": "https://leetcode-cn.com/problems/create-binary-tree-from-descriptions/solution/gen-ju-miao-shu-chuang-jian-er-cha-shu-b-sqrk/",
	"content": "#### 方法一：哈希表\n\n**思路与算法**\n\n由于数组 $\\textit{descriptions}$ 中用节点的数值表示对应节点，因此为了方便查找，我们用哈希表 $\\textit{nodes}$ 来维护数值到对应节点的映射。\n\n我们可以遍历数组 $\\textit{descriptions}$ 来创建二叉树。具体地，当我们遍历到三元组 $[p, c, \\textit{left}]$ 时，我们首先判断 $\\textit{nodes}$ 中是否存在 $p$ 与 $c$ 对应的树节点，如果没有则我们新建一个数值为对应值的节点。随后，我们根据 $\\textit{left}$ 的真假将 $p$ 对应的节点的左或右子节点设为 $c$ 对应的节点。当遍历完成后，我们就重建出了目标二叉树。\n\n除此之外，我们还需要寻找二叉树的根节点。这个过程也可以在遍历和建树的过程中完成。我们可以同样用一个哈希表 $\\textit{isRoot}$ 维护数值与是否为根节点的映射。在遍历时，我们需要将 $\\textit{isRoot}[c]$ 设为 $\\texttt{false}$（因为该节点有父节点）；而如果 $p$ 在 $\\textit{isRoot}$ 中不存在，则说明 $p$ **暂时**没有父节点，我们可以将 $\\textit{isRoot}[c]$ 设为 $\\texttt{true}$。最终在遍历完成后，一定**有且仅有一个**元素 $\\textit{root}$ 在 $\\textit{isRoot}$ 中的数值为 $\\texttt{true}$，此时对应的 $\\textit{node}[i]$ 为二叉树的根节点，我们返回该节点作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\n        unordered_map<int, bool> isRoot;   // 数值对应的节点是否为根节点的哈希表\n        unordered_map<int, TreeNode*> nodes;   // 数值与对应节点的哈希表\n        for (const auto& d: descriptions) {\n            int p = d[0];\n            int c = d[1];\n            bool left = d[2];\n            if (!isRoot.count(p)) {\n                isRoot[p] = true;\n            }\n            isRoot[c] = false;\n            // 创建或更新节点\n            if (!nodes.count(p)) {\n                nodes[p] = new TreeNode(p);\n            }\n            if (!nodes.count(c)) {\n                nodes[c] = new TreeNode(c);\n            }\n            if (left) {\n                nodes[p]->left = nodes[c];\n            } else {\n                nodes[p]->right = nodes[c];\n            }\n        }\n        // 寻找根节点\n        int root = -1;\n        for (const auto& [val, r]: isRoot) {\n            if (r) {\n                root = val;\n                break;\n            }\n        }\n        return nodes[root];\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\n        isRoot = {}   # 数值对应的节点是否为根节点的哈希表\n        nodes = {}   # 数值与对应节点的哈希表\n        for p, c, left in descriptions:\n            if p not in isRoot:\n                isRoot[p] = True\n            isRoot[c] = False\n            # 创建或更新节点\n            if p not in nodes:\n                nodes[p] = TreeNode(p)\n            if c not in nodes:\n                nodes[c] = TreeNode(c)\n            if left:\n                nodes[p].left = nodes[c]\n            else:\n                nodes[p].right = nodes[c]\n        # 寻找根节点\n        root = -1\n        for val, r in isRoot.items():\n            if r:\n                root = val\n                break\n        return nodes[root]\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{descriptions}$ 的长度。即为遍历构造二叉树并寻找根节点的时间复杂度。\n\n- 空间复杂度：$O(n)$，即为哈希表的空间开销。"
}