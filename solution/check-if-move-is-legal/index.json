{
	"titleSlug": "check-if-move-is-legal",
	"slug": "jian-cha-cao-zuo-shi-fou-he-fa-by-leetco-gqwz",
	"url": "https://leetcode-cn.com/problems/check-if-move-is-legal/solution/jian-cha-cao-zuo-shi-fou-he-fa-by-leetco-gqwz/",
	"content": "#### 方法一：枚举每个方向验证\n\n**思路与算法**\n\n由题意可知，当前操作合法当且仅当从该点开始的 $8$ 个方向（上下左右与对角线）中，至少有一个方向存在一个以该点为起点的好线段。\n\n那么，我们可以枚举这 $8$ 个方向，并对于每个方向验证是否存在以该点为起点的好线段。如果该点与对应方向**下一个相同颜色**的格点之间的所有格点（至少一个）均为另一种颜色，那么它们构成一个好线段。\n\n我们用数对 $(\\textit{dx}, \\textit{dy})$ 来表示每个方向下一个格点相对于当前格点的行列下标变化量，并用函数 $\\textit{check}(\\textit{dx}, \\textit{dy})$ 来判断该方向是否存在以操作位置为起点的好线段。如果我们寻找到了符合要求的好线段，则返回 $\\texttt{true}$；反之亦然。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool checkMove(vector<vector<char>>& board, int rMove, int cMove, char color) {\n        // 判断每个方向是否存在以操作位置为起点的好线段\n        auto check = [&](int dx, int dy) -> bool{\n            int x = rMove + dx;\n            int y = cMove + dy;\n            int step = 1;   // 当前遍历到的节点序号\n            while (x >= 0 && x < 8 && y >= 0 && y < 8){\n                if (step == 1){\n                    // 第一个点必须为相反颜色\n                    if (board[x][y] == '.' || board[x][y] == color){\n                        return false;\n                    }\n                }\n                else{\n                    // 好线段中不应存在空格子\n                    if (board[x][y] == '.'){\n                        return false;\n                    }\n                    // 遍历到好线段的终点，返回 true\n                    if (board[x][y] == color){\n                        return true;\n                    }\n                }\n                ++step;\n                x += dx;\n                y += dy;\n            }\n            // 不存在符合要求的好线段\n            return false;\n        };\n        \n        // 从 x 轴正方向开始逆时针枚举 8 个方向\n        vector<int> dx = {1, 1, 0, -1, -1, -1, 0, 1};   // 行改变量\n        vector<int> dy = {0, 1, 1, 1, 0, -1, -1, -1};   // 列改变量\n        for (int k = 0; k < 8; ++k){\n            if (check(dx[k], dy[k])){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:\n        # 判断每个方向是否存在以操作位置为起点的好线段\n        def check(dx: int, dy: int) -> bool:\n            x, y = rMove + dx, cMove + dy\n            step = 1   # 当前遍历到的节点序号\n            while 0 <= x < 8 and 0 <= y < 8:\n                if step == 1:\n                    # 第一个点必须为相反颜色\n                    if board[x][y] == \".\" or board[x][y] == color:\n                        return False\n                else:\n                    # 好线段中不应存在空格子\n                    if board[x][y] == \".\":\n                        return False\n                    # 遍历到好线段的终点，返回 true\n                    if board[x][y] == color:\n                        return True\n                step += 1\n                x += dx\n                y += dy\n            # 不存在符合要求的好线段\n            return False\n        \n        # 从 x 轴正方向开始逆时针枚举 8 个方向\n        dx = [1, 1, 0, -1, -1, -1, 0, 1]   # 行改变量\n        dy = [0, 1, 1, 1, 0, -1, -1, -1]   # 列改变量\n        for k in range(8):\n            if check(dx[k], dy[k]):\n                return True\n        return False\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\max(r, c))$，其中 $r, c$ 为 $\\textit{board}$ 的行数与列数。验证每个方向的时间复杂度为 $O(\\max(r, c))$，我们最多需要验证 $8$ 个方向。\n\n- 空间复杂度：$O(1)$。"
}