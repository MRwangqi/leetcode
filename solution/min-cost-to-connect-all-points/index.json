{
	"titleSlug": "min-cost-to-connect-all-points",
	"slug": "lian-jie-suo-you-dian-de-zui-xiao-fei-yo-kcx7",
	"url": "https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/lian-jie-suo-you-dian-de-zui-xiao-fei-yo-kcx7/",
	"content": "#### 写在前面\n\n根据题意，我们得到了一张 $n$ 个节点的完全图，任意两点之间的距离均为它们的曼哈顿距离。现在我们需要在这个图中取得一个子图，恰满足子图的任意两点之间有且仅有一条简单路径，且这个子图的所有边的总权值之和尽可能小。\n\n能够满足任意两点之间有且仅有一条简单路径只有树，且这棵树包含 $n$ 个节点。我们称这棵树为给定的图的生成树，其中总权值最小的生成树，我们称其为最小生成树。\n\n最小生成树有一个非常经典的解法：$\\text{Kruskal}$。\n\n#### 方法一：$\\text{Kruskal}$ 算法\n\n**思路及解法**\n\n$\\text{Kruskal}$ 算法是一种常见并且好写的最小生成树算法，由 $\\text{Kruskal}$ 发明。该算法的基本思想是从小到大加入边，是一个贪心算法。\n\n其算法流程为：\n\n1. 将图 $G=\\{V,E\\}$ 中的所有边按照长度由小到大进行排序，等长的边可以按任意顺序。\n\n2. 初始化图 $G'$ 为 $\\{V,\\varnothing\\}$，从前向后扫描排序后的边，如果扫描到的边 $e$ 在 $G'$ 中连接了两个相异的连通块,则将它插入 $G'$ 中。\n\n3. 最后得到的图 $G'$ 就是图 $G$ 的最小生成树。\n\n在实际代码中，我们首先将这张完全图中的边全部提取到边集数组中，然后对所有边进行排序，从小到大进行枚举，每次贪心选边加入答案。使用并查集维护连通性，若当前边两端不连通即可选择这条边。\n\n**代码**\n\n```C++ [sol1-C++]\nclass DisjointSetUnion {\nprivate:\n    vector<int> f, rank;\n    int n;\n\npublic:\n    DisjointSetUnion(int _n) {\n        n = _n;\n        rank.resize(n, 1);\n        f.resize(n);\n        for (int i = 0; i < n; i++) {\n            f[i] = i;\n        }\n    }\n\n    int find(int x) {\n        return f[x] == x ? x : f[x] = find(f[x]);\n    }\n\n    int unionSet(int x, int y) {\n        int fx = find(x), fy = find(y);\n        if (fx == fy) {\n            return false;\n        }\n        if (rank[fx] < rank[fy]) {\n            swap(fx, fy);\n        }\n        rank[fx] += rank[fy];\n        f[fy] = fx;\n        return true;\n    }\n};\n\nstruct Edge {\n    int len, x, y;\n    Edge(int len, int x, int y) : len(len), x(x), y(y) {\n    }\n};\n\nclass Solution {\npublic:\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        auto dist = [&](int x, int y) -> int {\n            return abs(points[x][0] - points[y][0]) + abs(points[x][1] - points[y][1]);\n        };\n        int n = points.size();\n        DisjointSetUnion dsu(n);\n        vector<Edge> edges;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                edges.emplace_back(dist(i, j), i, j);\n            }\n        }\n        sort(edges.begin(), edges.end(), [](Edge a, Edge b) -> int { return a.len < b.len; });\n        int ret = 0, num = 1;\n        for (auto& [len, x, y] : edges) {\n            if (dsu.unionSet(x, y)) {\n                ret += len;\n                num++;\n                if (num == n) {\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minCostConnectPoints(int[][] points) {\n        int n = points.length;\n        DisjointSetUnion dsu = new DisjointSetUnion(n);\n        List<Edge> edges = new ArrayList<Edge>();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                edges.add(new Edge(dist(points, i, j), i, j));\n            }\n        }\n        Collections.sort(edges, new Comparator<Edge>() {\n            public int compare(Edge edge1, Edge edge2) {\n                return edge1.len - edge2.len;\n            }\n        });\n        int ret = 0, num = 1;\n        for (Edge edge : edges) {\n            int len = edge.len, x = edge.x, y = edge.y;\n            if (dsu.unionSet(x, y)) {\n                ret += len;\n                num++;\n                if (num == n) {\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n\n    public int dist(int[][] points, int x, int y) {\n        return Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);\n    }\n}\n\nclass DisjointSetUnion {\n    int[] f;\n    int[] rank;\n    int n;\n\n    public DisjointSetUnion(int n) {\n        this.n = n;\n        this.rank = new int[n];\n        Arrays.fill(this.rank, 1);\n        this.f = new int[n];\n        for (int i = 0; i < n; i++) {\n            this.f[i] = i;\n        }\n    }\n\n    public int find(int x) {\n        return f[x] == x ? x : (f[x] = find(f[x]));\n    }\n\n    public boolean unionSet(int x, int y) {\n        int fx = find(x), fy = find(y);\n        if (fx == fy) {\n            return false;\n        }\n        if (rank[fx] < rank[fy]) {\n            int temp = fx;\n            fx = fy;\n            fy = temp;\n        }\n        rank[fx] += rank[fy];\n        f[fy] = fx;\n        return true;\n    }\n}\n\nclass Edge {\n    int len, x, y;\n\n    public Edge(int len, int x, int y) {\n        this.len = len;\n        this.x = x;\n        this.y = y;\n    }\n}\n```\n\n```go [sol1-Golang]\ntype unionFind struct {\n    parent, rank []int\n}\n\nfunc newUnionFind(n int) *unionFind {\n    parent := make([]int, n)\n    rank := make([]int, n)\n    for i := range parent {\n        parent[i] = i\n        rank[i] = 1\n    }\n    return &unionFind{parent, rank}\n}\n\nfunc (uf *unionFind) find(x int) int {\n    if uf.parent[x] != x {\n        uf.parent[x] = uf.find(uf.parent[x])\n    }\n    return uf.parent[x]\n}\n\nfunc (uf *unionFind) union(x, y int) bool {\n    fx, fy := uf.find(x), uf.find(y)\n    if fx == fy {\n        return false\n    }\n    if uf.rank[fx] < uf.rank[fy] {\n        fx, fy = fy, fx\n    }\n    uf.rank[fx] += uf.rank[fy]\n    uf.parent[fy] = fx\n    return true\n}\n\nfunc dist(p, q []int) int {\n    return abs(p[0]-q[0]) + abs(p[1]-q[1])\n}\n\nfunc minCostConnectPoints(points [][]int) (ans int) {\n    n := len(points)\n    type edge struct{ v, w, dis int }\n    edges := []edge{}\n    for i, p := range points {\n        for j := i + 1; j < n; j++ {\n            edges = append(edges, edge{i, j, dist(p, points[j])})\n        }\n    }\n\n    sort.Slice(edges, func(i, j int) bool { return edges[i].dis < edges[j].dis })\n\n    uf := newUnionFind(n)\n    left := n - 1\n    for _, e := range edges {\n        if uf.union(e.v, e.w) {\n            ans += e.dis\n            left--\n            if left == 0 {\n                break\n            }\n        }\n    }\n    return\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n```Python [sol1-Python3]\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.n = n\n        self.rank = [1] * n\n        self.f = list(range(n))\n    \n    def find(self, x: int) -> int:\n        if self.f[x] == x:\n            return x\n        self.f[x] = self.find(self.f[x])\n        return self.f[x]\n    \n    def unionSet(self, x: int, y: int) -> bool:\n        fx, fy = self.find(x), self.find(y)\n        if fx == fy:\n            return False\n\n        if self.rank[fx] < self.rank[fy]:\n            fx, fy = fy, fx\n        \n        self.rank[fx] += self.rank[fy]\n        self.f[fy] = fx\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = lambda x, y: abs(points[x][0] - points[y][0]) + abs(points[x][1] - points[y][1])\n\n        n = len(points)\n        dsu = DisjointSetUnion(n)\n        edges = list()\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append((dist(i, j), i, j))\n        \n        edges.sort()\n        \n        ret, num = 0, 1\n        for length, x, y in edges:\n            if dsu.unionSet(x, y):\n                ret += length\n                num += 1\n                if num == n:\n                    break\n        \n        return ret\n```\n\n```JavaScript [sol1-JavaScript]\nvar minCostConnectPoints = function(points) {\n    const dist = (x, y) => {\n        return Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);\n    }\n\n    const n = points.length;\n    const dsu = new DisjointSetUnion(n);\n    const edges = [];\n\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            edges.push([dist(i, j), i, j]);\n        }\n    }\n    edges.sort((a, b) => a[0] - b[0]);\n\n    let ret = 0, num = 1;\n    for (const [length, x, y] of edges) {\n        if (dsu.unionSet(x, y)) {\n            ret += length;\n            num += 1;\n            if (num === n) {\n                break;\n            }\n        }\n    }\n    return ret;\n};\n\nclass DisjointSetUnion {\n    constructor(n) {\n        this.n = n;\n        this.rank = new Array(n).fill(1);\n        this.f = new Array(n).fill(0).map((element, index) => index);\n    }\n\n    find(x) {\n        if (this.f[x] === x) {\n            return x;\n        }\n        this.f[x] = this.find(this.f[x]);\n        return this.f[x];\n    }\n\n    unionSet(x, y) {\n        let fx = this.find(x), fy = this.find(y);\n        if (fx === fy) {\n            return false;\n        }\n\n        if (this.rank[fx] < this.rank[fy]) {\n            [fx, fy] = [fy, fx];\n        }\n        this.rank[fx] += this.rank[fy];\n        this.f[fy] = fx;\n        return true;\n    }\n}\n```\n\n```C [sol1-C]\nvoid swap(int* a, int* b) {\n    int tmp = *a;\n    *a = *b, *b = tmp;\n}\n\nstruct Edge {\n    int len, x, y;\n};\n\nint cmp(struct Edge* a, struct Edge* b) {\n    return a->len - b->len;\n}\n\nint find(int* f, int x) {\n    return f[x] == x ? x : (f[x] = find(f, f[x]));\n}\n\nint unionSet(int* f, int* rank, int x, int y) {\n    int fx = find(f, x), fy = find(f, y);\n    if (fx == fy) {\n        return false;\n    }\n    if (rank[fx] < rank[fy]) {\n        swap(&fx, &fy);\n    }\n    rank[fx] += rank[fy];\n    f[fy] = fx;\n    return true;\n}\n\nint minCostConnectPoints(int** points, int pointsSize, int* pointsColSize) {\n    int n = pointsSize;\n    struct Edge edges[(n + 1) * n / 2];\n    int edgesSize = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            edges[edgesSize].x = i;\n            edges[edgesSize].y = j;\n            edges[edgesSize++].len = fabs(points[i][0] - points[j][0]) + fabs(points[i][1] - points[j][1]);\n        }\n    }\n    qsort(edges, edgesSize, sizeof(struct Edge), cmp);\n    int f[n], rank[n];\n    for (int i = 0; i < n; i++) {\n        f[i] = i;\n        rank[i] = 1;\n    }\n    int ret = 0, num = 1;\n    for (int i = 0; i < edgesSize; i++) {\n        if (unionSet(f, rank, edges[i].x, edges[i].y)) {\n            ret += edges[i].len;\n            num++;\n            if (num == n) {\n                break;\n            }\n        }\n    }\n    return ret;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2\\log(n))$，其中 $n$ 是节点数。一般 $\\text{Kruskal}$ 是 $O(m\\log m)$ 的算法，但本题中 $m=n^2$，因此总时间复杂度为 $O(n^2\\log(n))$。\n\n- 空间复杂度：$O(n^2)$，其中 $n$ 是节点数。并查集使用 $O(n)$ 的空间，边集数组需要使用 $O(n^2)$ 的空间。\n\n#### 方法二：建图优化的 $\\text{Kruskal}$\n\n**思路及解法**\n\n方法一中，虽然使用了 $\\text{Kruskal}$ 算法，但时间复杂度仍然较高，因为本题中的边数是 $O(n^2)$ 的，所以我们需要想办法将减少边数。为此，我们提出几个结论：\n\n**结论一**：对于图中的任意三点 $A,B,C$，假设边 $AB,AC,BC$ 中 $AB$ 为最长边，那么最终答案中必然不包含边 $AB$。\n\n我们利用反证法证明：假设最后答案中包含 $AB$，那么此时 $AC$ 与 $BC$ 两边中至少有一条边是没有被选用的，我们总可以在保证连通性的情况下，将 $AB$ 边替换为 $AC$ 与 $BC$ 两边中的某一个，使最小生成树的总权值变得更小。\n\n**结论二**：对于下图中同属同一个区块的任意两点 $B,C$，$A$ 为原点，那么 $BC$ 不可能为三边中最长边。\n\n![fig1](https://assets.leetcode-cn.com/solution-static/1584/1.png){:width=\"80%\"}\n\n图中任意一个区块的两分割线的夹角均为 $45^\\circ$。\n\n我们以 $P1$ 区块为例，假设 $B(x_B,y_B),C(x_C,y_C)$，不失一般性，假设 $x_B + y_B \\leq x_C + y_C$。\n\n因为处于 $P1$ 区域，所以有 $0 \\leq x_B \\leq y_B$，$0 \\leq x_C \\leq y_C$。所以 $BC = |x_B - x_C| + |y_B - y_C|$。\n\n下面我们尝试分类讨论：\n\n1. 当 $x_B > x_C, y_B > y_C$，这与 $x_B + y_B \\leq x_C + y_C$ 矛盾。\n\n2. 当 $x_B \\leq x_C, y_B > y_C$，此时有 $|BC| = x_C - x_B + y_B - y_C$，$|AC| - |BC| = x_C + y_C - x_C + x_B - y_B + y_C = x_B - y_B + 2 \\times y_C$。由前面各种关系可得 $y_B > y_C > x_C > x_B$。假设 $|AC| < |BC|$，即 $y_B > 2 \\times y_C + x_B$，那么 $|AB| = x_B + y_B > 2 \\times x_B + 2 \\times y_C$，$|AC| = x_C + y_C < 2 \\times y_C < |AB|$ 与前提矛盾，故 $|AC| \\geq |BC|$；\n\n3. $x_B > x_C$ 且 $y_B \\leq y_C$。与 $2$ 同理；\n\n4. $x_B \\leq x_C$ 且 $y_B \\leq y_C$。此时显然有 $|AB| + |BC| = |AC|$，即有 $|AC| > |BC|$。\n\n综上有 $|AC| \\geq |BC|$，这个性质可以从 $P1$ 区域推导到其他七个区域。\n\n**结论三**：假设存在一点 $A$ 在原点处，那么对于图中的任意一个 $45^\\circ$ 区域，我们都至多只选择其中的一个点与 $A$ 相连，且该点必然为该区域中距离 $A$ 最近的点。\n\n我们首先利用反证法证明：假设最后答案中包含 $AB$ 与 $AC$，且 $B$ 与 $C$ 均位于同一个 $45^\\circ$ 区域中。那么由结论二可知，$BC$ 必不为三边中的最长边。即最长边必然为 $AB$ 或 $AC$。由结论一可知，$AB$ 与 $AC$ 中必然有一个不包含在答案中，这与假设相悖，因此我们最多仅会选择一个点与 $A$ 相连。\n\n我们进一步思考，既然最多仅会选择一个点与 $A$ 相连，且三边中的最长边不为 $A$ 的对边，那么仅有距离 $A$ 最近的点与 $A$ 所连的边可能出现在答案中。证毕。\n\n依据结论三我们可以知道，一个点至多连八条边，因此我们至多只需要连出 $O(n)$ 条边。\n\n**细节**\n\n为防止重复连边，我们对每一个点只考虑对 $P1,P2,P3,P4$ 连边的情况，假设 $A$ 点坐标为 $(x,y)$，对于这四个点，我们可以概括为：\n\n- 对于 $P1$ 区域的 $(x_1,y_1)$，有 $x_1 \\geq x, y_1 - x_1 \\geq y - x$，其中最近点的 $x_1 + y_1$ 最小。\n\n- 对于 $P2$ 区域的 $(x_2,y_2)$，有 $y_2 \\geq y, y_2 - x_2 \\leq y - x$，其中最近点的 $x_2 + y_2$ 最小。\n\n- 对于 $P3$ 区域的 $(x_3,y_3)$，有 $y_3 \\leq y, y_3 + x_3 \\geq y + x$，其中最近点的 $y_3 - x_3$ 最小。\n\n- 对于 $P4$ 区域的 $(x_4,y_4)$，有 $x_4 \\geq x, y_4 + x_4 \\leq y + x$，其中最近点的 $y_4 - x_4$ 最小。\n\n这样，我们分别处理每一个区域即可，以 $P1$ 区域为例，我们先通过排序使得所有点按照横坐标从大到小排列，然后将每一个点的 $y_i - x_i$ 信息记录，将离散化后记录在数组的下标为 $y_i - x_i$ 的位置中，并利用树状数组维护该数组的前缀最小值。这样我们就可以动态地、单次 $O(\\log n)$ 地计算每个点的 $P1$ 区域所选择的点。\n\n为了提升编码效率，实际代码中我们只实现了 $P1$ 区域的算法，对于其它三个区域，我们通过巧妙的坐标变化使其条件变为 $P1$ 区域，使得代码能够更加高效地复用。\n\n**代码**\n\n下面代码中的 $\\texttt{Python}$ 代码中需要 $\\texttt{import}$ 类型标注中的 $\\texttt{Tuple}$，当然删去对应部分也可以成功运行。\n\n```C++ [sol2-C++]\nclass DisjointSetUnion {\nprivate:\n    vector<int> f, rank;\n    int n;\n\npublic:\n    DisjointSetUnion(int _n) {\n        n = _n;\n        rank.resize(n, 1);\n        f.resize(n);\n        for (int i = 0; i < n; i++) {\n            f[i] = i;\n        }\n    }\n\n    int find(int x) {\n        return f[x] == x ? x : f[x] = find(f[x]);\n    }\n\n    int unionSet(int x, int y) {\n        int fx = find(x), fy = find(y);\n        if (fx == fy) {\n            return false;\n        }\n        if (rank[fx] < rank[fy]) {\n            swap(fx, fy);\n        }\n        rank[fx] += rank[fy];\n        f[fy] = fx;\n        return true;\n    }\n};\n\nclass BIT {\npublic:\n    vector<int> tree, idRec;\n    int n;\n\n    BIT(int _n) {\n        n = _n;\n        tree.resize(n, INT_MAX);\n        idRec.resize(n, -1);\n    }\n\n    int lowbit(int k) {\n        return k & (-k);\n    }\n\n    void update(int pos, int val, int id) {\n        while (pos > 0) {\n            if (tree[pos] > val) {\n                tree[pos] = val;\n                idRec[pos] = id;\n            }\n            pos -= lowbit(pos);\n        }\n    }\n\n    int query(int pos) {\n        int minval = INT_MAX;\n        int j = -1;\n        while (pos < n) {\n            if (minval > tree[pos]) {\n                minval = tree[pos];\n                j = idRec[pos];\n            }\n            pos += lowbit(pos);\n        }\n        return j;\n    }\n};\n\nstruct Edge {\n    int len, x, y;\n    Edge(int len, int x, int y) : len(len), x(x), y(y) {\n    }\n    bool operator<(const Edge& a) const {\n        return len < a.len;\n    }\n};\n\nstruct Pos {\n    int id, x, y;\n    bool operator<(const Pos& a) const {\n        return x == a.x ? y < a.y : x < a.x;\n    }\n};\n\nclass Solution {\npublic:\n    vector<Edge> edges;\n    vector<Pos> pos;\n\n    void build(int n) {\n        sort(pos.begin(), pos.end());\n        vector<int> a(n), b(n);\n        for (int i = 0; i < n; i++) {\n            a[i] = pos[i].y - pos[i].x;\n            b[i] = pos[i].y - pos[i].x;\n        }\n        sort(b.begin(), b.end());\n        b.erase(unique(b.begin(), b.end()), b.end());\n        int num = b.size();\n        BIT bit(num + 1);\n        for (int i = n - 1; i >= 0; i--) {\n            int poss = lower_bound(b.begin(), b.end(), a[i]) - b.begin() + 1;\n            int j = bit.query(poss);\n            if (j != -1) {\n                int dis = abs(pos[i].x - pos[j].x) + abs(pos[i].y - pos[j].y);\n                edges.emplace_back(dis, pos[i].id, pos[j].id);\n            }\n            bit.update(poss, pos[i].x + pos[i].y, i);\n        }\n    }\n\n    void solve(vector<vector<int>>& points, int n) {\n        pos.resize(n);\n        for (int i = 0; i < n; i++) {\n            pos[i].x = points[i][0];\n            pos[i].y = points[i][1];\n            pos[i].id = i;\n        }\n        build(n);\n        for (int i = 0; i < n; i++) {\n            swap(pos[i].x, pos[i].y);\n        }\n        build(n);\n        for (int i = 0; i < n; i++) {\n            pos[i].x = -pos[i].x;\n        }\n        build(n);\n        for (int i = 0; i < n; i++) {\n            swap(pos[i].x, pos[i].y);\n        }\n        build(n);\n    }\n\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        int n = points.size();\n        solve(points, n);\n\n        DisjointSetUnion dsu(n);\n        sort(edges.begin(), edges.end());\n        int ret = 0, num = 1;\n        for (auto& [len, x, y] : edges) {\n            if (dsu.unionSet(x, y)) {\n                ret += len;\n                num++;\n                if (num == n) {\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    List<Edge> edges = new ArrayList<Edge>();\n    Pos[] pos;\n\n    public int minCostConnectPoints(int[][] points) {\n        int n = points.length;\n        solve(points, n);\n\n        DisjointSetUnion dsu = new DisjointSetUnion(n);\n        Collections.sort(edges, new Comparator<Edge>() {\n            public int compare(Edge edge1, Edge edge2) {\n                return edge1.len - edge2.len;\n            }\n        });\n        int ret = 0, num = 1;\n        for (Edge edge : edges) {\n            int len = edge.len, x = edge.x, y = edge.y;\n            if (dsu.unionSet(x, y)) {\n                ret += len;\n                num++;\n                if (num == n) {\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n\n    public void solve(int[][] points, int n) {\n        pos = new Pos[n];\n        for (int i = 0; i < n; i++) {\n            pos[i] = new Pos(i, points[i][0], points[i][1]);\n        }\n        build(n);\n        for (int i = 0; i < n; i++) {\n            int temp = pos[i].x;\n            pos[i].x = pos[i].y;\n            pos[i].y = temp;\n        }\n        build(n);\n        for (int i = 0; i < n; i++) {\n            pos[i].x = -pos[i].x;\n        }\n        build(n);\n        for (int i = 0; i < n; i++) {\n            int temp = pos[i].x;\n            pos[i].x = pos[i].y;\n            pos[i].y = temp;\n        }\n        build(n);\n    }\n\n    public void build(int n) {\n        Arrays.sort(pos, new Comparator<Pos>() {\n            public int compare(Pos pos1, Pos pos2) {\n                return pos1.x == pos2.x ? pos1.y - pos2.y : pos1.x - pos2.x;\n            }\n        });\n        int[] a = new int[n];\n        Set<Integer> set = new HashSet<Integer>();\n        for (int i = 0; i < n; i++) {\n            a[i] = pos[i].y - pos[i].x;\n            set.add(pos[i].y - pos[i].x);\n        }\n        int num = set.size();\n        int[] b = new int[num];\n        int index = 0;\n        for (int element : set) {\n            b[index++] = element;\n        }\n        Arrays.sort(b);\n        BIT bit = new BIT(num + 1);\n        for (int i = n - 1; i >= 0; i--) {\n            int poss = binarySearch(b, a[i]) + 1;\n            int j = bit.query(poss);\n            if (j != -1) {\n                int dis = Math.abs(pos[i].x - pos[j].x) + Math.abs(pos[i].y - pos[j].y);\n                edges.add(new Edge(dis, pos[i].id, pos[j].id));\n            }\n            bit.update(poss, pos[i].x + pos[i].y, i);\n        }\n    }\n\n    public int binarySearch(int[] array, int target) {\n        int low = 0, high = array.length - 1;\n        while (low < high) {\n            int mid = (high - low) / 2 + low;\n            int num = array[mid];\n            if (num < target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n}\n\nclass DisjointSetUnion {\n    int[] f;\n    int[] rank;\n    int n;\n\n    public DisjointSetUnion(int n) {\n        this.n = n;\n        this.rank = new int[n];\n        Arrays.fill(this.rank, 1);\n        this.f = new int[n];\n        for (int i = 0; i < n; i++) {\n            this.f[i] = i;\n        }\n    }\n\n    public int find(int x) {\n        return f[x] == x ? x : (f[x] = find(f[x]));\n    }\n\n    public boolean unionSet(int x, int y) {\n        int fx = find(x), fy = find(y);\n        if (fx == fy) {\n            return false;\n        }\n        if (rank[fx] < rank[fy]) {\n            int temp = fx;\n            fx = fy;\n            fy = temp;\n        }\n        rank[fx] += rank[fy];\n        f[fy] = fx;\n        return true;\n    }\n}\n\nclass BIT {\n    int[] tree;\n    int[] idRec;\n    int n;\n\n    public BIT(int n) {\n        this.n = n;\n        this.tree = new int[n];\n        Arrays.fill(this.tree, Integer.MAX_VALUE);\n        this.idRec = new int[n];\n        Arrays.fill(this.idRec, -1);\n    }\n\n    public int lowbit(int k) {\n        return k & (-k);\n    }\n\n    public void update(int pos, int val, int id) {\n        while (pos > 0) {\n            if (tree[pos] > val) {\n                tree[pos] = val;\n                idRec[pos] = id;\n            }\n            pos -= lowbit(pos);\n        }\n    }\n\n    public int query(int pos) {\n        int minval = Integer.MAX_VALUE;\n        int j = -1;\n        while (pos < n) {\n            if (minval > tree[pos]) {\n                minval = tree[pos];\n                j = idRec[pos];\n            }\n            pos += lowbit(pos);\n        }\n        return j;\n    }\n}\n\nclass Edge {\n    int len, x, y;\n\n    public Edge(int len, int x, int y) {\n        this.len = len;\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Pos {\n    int id, x, y;\n\n    public Pos(int id, int x, int y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n    }\n}\n```\n\n```go [sol2-Golang]\ntype unionFind struct {\n    parent, rank []int\n}\n\nfunc newUnionFind(n int) *unionFind {\n    parent := make([]int, n)\n    rank := make([]int, n)\n    for i := range parent {\n        parent[i] = i\n        rank[i] = 1\n    }\n    return &unionFind{parent, rank}\n}\n\nfunc (uf *unionFind) find(x int) int {\n    if uf.parent[x] != x {\n        uf.parent[x] = uf.find(uf.parent[x])\n    }\n    return uf.parent[x]\n}\n\nfunc (uf *unionFind) union(x, y int) bool {\n    fx, fy := uf.find(x), uf.find(y)\n    if fx == fy {\n        return false\n    }\n    if uf.rank[fx] < uf.rank[fy] {\n        fx, fy = fy, fx\n    }\n    uf.rank[fx] += uf.rank[fy]\n    uf.parent[fy] = fx\n    return true\n}\n\ntype fenwickTree struct {\n    tree, idRec []int\n}\n\nfunc newFenwickTree(n int) *fenwickTree {\n    tree := make([]int, n)\n    idRec := make([]int, n)\n    for i := range tree {\n        tree[i], idRec[i] = math.MaxInt64, -1\n    }\n    return &fenwickTree{tree, idRec}\n}\n\nfunc (f *fenwickTree) update(pos, val, id int) {\n    for ; pos > 0; pos &= pos - 1 {\n        if val < f.tree[pos] {\n            f.tree[pos], f.idRec[pos] = val, id\n        }\n    }\n}\n\nfunc (f *fenwickTree) query(pos int) int {\n    minVal, minID := math.MaxInt64, -1\n    for ; pos < len(f.tree); pos += pos & -pos {\n        if f.tree[pos] < minVal {\n            minVal, minID = f.tree[pos], f.idRec[pos]\n        }\n    }\n    return minID\n}\n\nfunc dist(p, q []int) int {\n    return abs(p[0]-q[0]) + abs(p[1]-q[1])\n}\n\nfunc minCostConnectPoints(points [][]int) (ans int) {\n    n := len(points)\n    for i, p := range points {\n        points[i] = append(p, i)\n    }\n    type edge struct{ v, w, dis int }\n    edges := []edge{}\n\n    build := func() {\n        sort.Slice(points, func(i, j int) bool { a, b := points[i], points[j]; return a[0] < b[0] || a[0] == b[0] && a[1] < b[1] })\n\n        // 离散化 y-x\n        type pair struct{ v, i int }\n        ps := make([]pair, n)\n        for i, p := range points {\n            ps[i] = pair{p[1] - p[0], i}\n        }\n        sort.Slice(ps, func(i, j int) bool { return ps[i].v < ps[j].v })\n        kth := make([]int, n)\n        k := 1\n        kth[ps[0].i] = k\n        for i := 1; i < n; i++ {\n            if ps[i].v != ps[i-1].v {\n                k++\n            }\n            kth[ps[i].i] = k\n        }\n\n        t := newFenwickTree(k + 1)\n        for i := n - 1; i >= 0; i-- {\n            p := points[i]\n            pos := kth[i]\n            if j := t.query(pos); j != -1 {\n                q := points[j]\n                edges = append(edges, edge{p[2], q[2], dist(p, q)})\n            }\n            t.update(pos, p[0]+p[1], i)\n        }\n    }\n\n    build()\n    for _, p := range points {\n        p[0], p[1] = p[1], p[0]\n    }\n    build()\n    for _, p := range points {\n        p[0] = -p[0]\n    }\n    build()\n    for _, p := range points {\n        p[0], p[1] = p[1], p[0]\n    }\n    build()\n\n    sort.Slice(edges, func(i, j int) bool { return edges[i].dis < edges[j].dis })\n\n    uf := newUnionFind(n)\n    left := n - 1\n    for _, e := range edges {\n        if uf.union(e.v, e.w) {\n            ans += e.dis\n            left--\n            if left == 0 {\n                break\n            }\n        }\n    }\n    return\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n```Python [sol2-Python3]\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.n = n\n        self.rank = [1] * n\n        self.f = list(range(n))\n    \n    def find(self, x: int) -> int:\n        if self.f[x] == x:\n            return x\n        self.f[x] = self.find(self.f[x])\n        return self.f[x]\n    \n    def unionSet(self, x: int, y: int) -> bool:\n        fx, fy = self.find(x), self.find(y)\n        if fx == fy:\n            return False\n\n        if self.rank[fx] < self.rank[fy]:\n            fx, fy = fy, fx\n        \n        self.rank[fx] += self.rank[fy]\n        self.f[fy] = fx\n        return True\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [float(\"inf\")] * n\n        self.idRec = [-1] * n\n        self.lowbit = lambda x: x & (-x)\n    \n    def update(self, pos: int, val: int, identity: int):\n        while pos > 0:\n            if self.tree[pos] > val:\n                self.tree[pos] = val\n                self.idRec[pos] = identity\n            pos -= self.lowbit(pos)\n\n    def query(self, pos: int) -> int:\n        minval, j = float(\"inf\"), -1\n        while pos < self.n:\n            if minval > self.tree[pos]:\n                minval = self.tree[pos]\n                j = self.idRec[pos]\n            pos += self.lowbit(pos)\n        return j\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = list()\n\n        def build(pos: List[Tuple[int, int, int]]):\n            pos.sort()\n            a = [y - x for (x, y, _) in pos]\n            b = sorted(set(a))\n            num = len(b)\n\n            bit = BIT(num + 1)\n            for i in range(n - 1, -1, -1):\n                poss = bisect.bisect(b, a[i])\n                j = bit.query(poss)\n                if j != -1:\n                    dis = abs(pos[i][0] - pos[j][0]) + abs(pos[i][1] - pos[j][1])\n                    edges.append((dis, pos[i][2], pos[j][2]))\n                bit.update(poss, pos[i][0] + pos[i][1], i)\n        \n        def solve():\n            pos = [(x, y, i) for i, (x, y) in enumerate(points)]\n            build(pos)\n            pos = [(y, x, i) for i, (x, y) in enumerate(points)]\n            build(pos)\n            pos = [(-y, x, i) for i, (x, y) in enumerate(points)]\n            build(pos)\n            pos = [(x, -y, i) for i, (x, y) in enumerate(points)]\n            build(pos)\n        \n        solve()\n        dsu = DisjointSetUnion(n)\n        edges.sort()\n        \n        ret, num = 0, 1\n        for length, x, y in edges:\n            if dsu.unionSet(x, y):\n                ret += length\n                num += 1\n                if num == n:\n                    break\n        \n        return ret\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是节点数。预处理建边的时间复杂度为 $O(n \\log n)$，因为需要排序，以及使用树状数组维护。在只有 $O(n)$ 条边的情况下，$\\text{Kruskal}$ 的时间复杂度为 $O(n\\log n)$，因此总时间复杂度为 $O(n \\log n)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是节点数。树状数组，并查集、离散化以及边集数组都只使用 $O(n)$ 的空间。"
}