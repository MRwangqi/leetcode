{
	"titleSlug": "steps-to-make-array-non-decreasing",
	"slug": "by-endlesscheng-s2yc",
	"url": "https://leetcode-cn.com/problems/steps-to-make-array-non-decreasing/solution/by-endlesscheng-s2yc/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1iF41157dG/) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n元素 $x$ 会被左边某个比他大的元素 $y$ 给删除（如果存在的话）。\r\n\r\n我们需要计算在删除 $x$ 之前，删除了多少个比 $y$ 小的元素，从而算出删除 $x$ 的时刻（第几步操作）。\r\n\r\n答案可以转换成所有（能被删除的）元素被删除的时刻的最大值。\r\n\r\n#### 提示 2\r\n\r\n以 $[20,1,9,1,2,3]$ 为例。\r\n\r\n- 时刻一 $20$ 删掉 $1$，$9$ 删掉 $1$；\r\n- 时刻二 $20$ 删掉 $9$，$9$ 删掉 $2$;\r\n- 时刻三 $20$ 接替了 $9$ 的任务，来删除数字 $3$。\r\n\r\n虽然说数字 $3$ 是被 $20$ 删除的，但是由于 $20$ 立马接替了 $9$，我们可以**等价转换**看作 $3$ 是被 $9$ 删除的，也就是它左边离它最近且比它大的那个数。\r\n\r\n**该等价转换不会影响数字被删除的时刻。**\r\n\r\n#### 提示 3\r\n\r\n再考虑这个例子 $[9,1,2,3,4,1,5]$。\r\n\r\n$5$ 应该被 $9$ 删除。根据题目要求，在删除 $5$ 之前，需要把 $5$ 前面不超过 $5$ 的元素都删除，然后才能删除 $5$。所以在删除 $5$ 之前，我们需要知道 $9$ 到 $5$ 之间的所有元素被删除的时刻的最大值，这个时刻加一就是删除 $5$ 的时刻。\r\n\r\n这可以用单调栈 + 线段树来做，单调栈求左边最近更大元素位置，线段树维护区间最大值。（[评论区](https://leetcode.cn/problems/steps-to-make-array-non-decreasing/comments/1587279)有人实现了这一思路）\r\n\r\n但还有更巧妙的做法。\r\n\r\n#### 提示 4\r\n\r\n对于一串非降的序列，该序列的每个元素被删除的时刻是单调递增的。（假设序列左侧有个更大的元素去删除序列中的元素）\r\n\r\n利用这一单调性，我们只需要存储这串非降序列的**最后一个元素**被删除的时刻。\r\n\r\n某一段区间会包含若干个非降序列，也就包含了若干个最后一个元素被删除的时刻，提示 3 中所需要计算的最大值必然在这些时刻中。\r\n\r\n#### 提示 5\r\n\r\n我们可以用一个**单调递减栈**存储元素及其被删除的时刻，当遇到一个不小于栈顶的元素 $x$ 时，就不断弹出栈顶元素，并取弹出元素被删除时刻的最大值，这样就得到了提示 3 中所需要计算的时刻的最大值 $\\textit{maxT}$。\r\n\r\n然后将 $x$ 及 $\\textit{maxT}+1$ 入栈。注意如果此时栈为空，说明前面没有比 $x$ 大的元素，$x$ 无法被删除，即 $\\textit{maxT}=0$，这种情况需要将 $x$ 及 $0$ 入栈。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$。每个元素至多入栈出栈各一次。\r\n- 空间复杂度：$O(n)$。最坏情况下栈中有 $n$ 个元素。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def totalSteps(self, nums: List[int]) -> int:\r\n        ans, st = 0, []\r\n        for num in nums:\r\n            max_t = 0\r\n            while st and st[-1][0] <= num:\r\n                max_t = max(max_t, st.pop()[1])\r\n            max_t = max_t + 1 if st else 0\r\n            ans = max(ans, max_t)\r\n            st.append((num, max_t))\r\n        return ans\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int totalSteps(int[] nums) {\r\n        var ans = 0;\r\n        var st = new ArrayDeque<int[]>();\r\n        for (var num : nums) {\r\n            var maxT = 0;\r\n            while (!st.isEmpty() && st.peek()[0] <= num)\r\n                maxT = Math.max(maxT, st.pop()[1]);\r\n            maxT = st.isEmpty() ? 0 : maxT + 1;\r\n            ans = Math.max(ans, maxT);\r\n            st.push(new int[]{num, maxT});\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int totalSteps(vector<int> &nums) {\r\n        int ans = 0;\r\n        stack<pair<int, int>> st;\r\n        for (int num : nums) {\r\n            int maxT = 0;\r\n            while (!st.empty() && st.top().first <= num) {\r\n                maxT = max(maxT, st.top().second);\r\n                st.pop();\r\n            }\r\n            maxT = st.empty() ? 0 : maxT + 1;\r\n            ans = max(ans, maxT);\r\n            st.emplace(num, maxT);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc totalSteps(nums []int) (ans int) {\r\n\ttype pair struct{ v, t int }\r\n\tst := []pair{}\r\n\tfor _, num := range nums {\r\n\t\tmaxT := 0\r\n\t\tfor len(st) > 0 && st[len(st)-1].v <= num {\r\n\t\t\tmaxT = max(maxT, st[len(st)-1].t)\r\n\t\t\tst = st[:len(st)-1]\r\n\t\t}\r\n\t\tif len(st) > 0 {\r\n\t\t\tmaxT++\r\n\t\t\tans = max(ans, maxT)\r\n\t\t} else {\r\n\t\t\tmaxT = 0\r\n\t\t}\r\n\t\tst = append(st, pair{num, maxT})\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc max(a, b int) int { if b > a { return b }; return a }\r\n```\r\n"
}