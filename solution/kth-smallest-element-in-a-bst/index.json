{
	"titleSlug": "kth-smallest-element-in-a-bst",
	"slug": "er-cha-sou-suo-shu-zhong-di-kxiao-de-yua-8o07",
	"url": "https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/er-cha-sou-suo-shu-zhong-di-kxiao-de-yua-8o07/",
	"content": "#### 方法一：中序遍历\n\n**预备知识**\n\n二叉搜索树具有如下性质：\n\n- 结点的左子树只包含**小于**当前结点的数。\n\n- 结点的右子树只包含**大于**当前结点的数。\n\n- 所有左子树和右子树自身必须也是二叉搜索树。\n\n二叉树的中序遍历即按照访问左子树——根结点——右子树的方式遍历二叉树；在访问其左子树和右子树时，我们也按照同样的方式遍历；直到遍历完整棵树。\n\n**思路和算法**\n\n因为二叉搜索树和中序遍历的性质，所以二叉搜索树的中序遍历是按照键增加的顺序进行的。于是，我们可以通过中序遍历找到第 $k$ 个最小元素。\n\n「二叉树的中序遍历」可以参考「[94. 二叉树的中序遍历的官方题解](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/)」，具体地，我们使用迭代方法，这样可以在找到答案后停止，不需要遍历整棵树。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\n        stack = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if k == 0:\n                return root.val\n            root = root.right\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();\n        while (root != null || !stack.isEmpty()) {\n            while (root != null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            --k;\n            if (k == 0) {\n                break;\n            }\n            root = root.right;\n        }\n        return root.val;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int KthSmallest(TreeNode root, int k) {\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        while (root != null || stack.Count > 0) {\n            while (root != null) {\n                stack.Push(root);\n                root = root.left;\n            }\n            root = stack.Pop();\n            --k;\n            if (k == 0) {\n                break;\n            }\n            root = root.right;\n        }\n        return root.val;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc kthSmallest(root *TreeNode, k int) int {\n    stack := []*TreeNode{}\n    for {\n        for root != nil {\n            stack = append(stack, root)\n            root = root.Left\n        }\n        stack, root = stack[:len(stack)-1], stack[len(stack)-1]\n        k--\n        if k == 0 {\n            return root.Val\n        }\n        root = root.Right\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        stack<TreeNode *> stack;\n        while (root != nullptr || stack.size() > 0) {\n            while (root != nullptr) {\n                stack.push(root);\n                root = root->left;\n            }\n            root = stack.top();\n            stack.pop();\n            --k;\n            if (k == 0) {\n                break;\n            }\n            root = root->right;\n        }\n        return root->val;\n    }\n};\n```\n\n```JavaScript [sol1-JavaScript]\nvar kthSmallest = function(root, k) {\n    const stack = [];\n    while (root != null || stack.length) {\n        while (root != null) {\n            stack.push(root);\n            root = root.left;\n        }\n        root = stack.pop();\n        --k;\n        if (k === 0) {\n            break;\n        }\n        root = root.right;\n    }\n    return root.val;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(H+k)$，其中 $H$ 是树的高度。在开始遍历之前，我们需要 $O(H)$ 到达叶结点。当树是平衡树时，时间复杂度取得最小值 $O(\\log N + k)$；当树是线性树（树中每个结点都只有一个子结点或没有子结点）时，时间复杂度取得最大值 $O(N+k)$。\n\n- 空间复杂度：$O(H)$，栈中最多需要存储 $H$ 个元素。当树是平衡树时，空间复杂度取得最小值 $O(\\log N)$；当树是线性树时，空间复杂度取得最大值 $O(N)$。\n\n#### 方法二：记录子树的结点数\n\n> 如果你需要频繁地查找第 $k$ 小的值，你将如何优化算法？\n\n**思路和算法**\n\n在方法一中，我们之所以需要中序遍历前 $k$ 个元素，是因为我们不知道子树的结点数量，不得不通过遍历子树的方式来获知。\n\n因此，我们可以记录下以每个结点为根结点的子树的结点数，并在查找第 $k$ 小的值时，使用如下方法搜索：\n\n- 令 $\\textit{node}$ 等于根结点，开始搜索。\n\n- 对当前结点 $\\textit{node}$ 进行如下操作：\n  - 如果 $\\textit{node}$ 的左子树的结点数 $\\textit{left}$ 小于 $k-1$，则第 $k$ 小的元素一定在 $\\textit{node}$ 的右子树中，令 $\\textit{node}$ 等于其的右子结点，$k$ 等于 $k - \\textit{left} - 1$，并继续搜索；\n  - 如果 $\\textit{node}$ 的左子树的结点数 $\\textit{left}$ 等于 $k-1$，则第 $k$ 小的元素即为 $node$ ，结束搜索并返回 $\\textit{node}$ 即可；\n  - 如果 $\\textit{node}$ 的左子树的结点数 $\\textit{left}$ 大于 $k-1$，则第 $k$ 小的元素一定在 $\\textit{node}$ 的左子树中，令 $\\textit{node}$ 等于其左子结点，并继续搜索。\n\n在实现中，我们既可以将以每个结点为根结点的子树的结点数存储在结点中，也可以将其记录在哈希表中。\n\n**代码**\n\n```Python [sol2-Python3]\nclass MyBst:\n    def __init__(self, root: TreeNode):\n        self.root = root\n\n        # 统计以每个结点为根结点的子树的结点数，并存储在哈希表中\n        self._node_num = {}\n        self._count_node_num(root)\n\n    def kth_smallest(self, k: int):\n        \"\"\"返回二叉搜索树中第k小的元素\"\"\"\n        node = self.root\n        while node:\n            left = self._get_node_num(node.left)\n            if left < k - 1:\n                node = node.right\n                k -= left + 1\n            elif left == k - 1:\n                return node.val\n            else:\n                node = node.left\n\n    def _count_node_num(self, node) -> int:\n        \"\"\"统计以node为根结点的子树的结点数\"\"\"\n        if not node:\n            return 0\n        self._node_num[node] = 1 + self._count_node_num(node.left) + self._count_node_num(node.right)\n        return self._node_num[node]\n\n    def _get_node_num(self, node) -> int:\n        \"\"\"获取以node为根结点的子树的结点数\"\"\"\n        return self._node_num[node] if node is not None else 0\n\n\nclass Solution:\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\n        bst = MyBst(root)\n        return bst.kth_smallest(k)\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        MyBst bst = new MyBst(root);\n        return bst.kthSmallest(k);\n    }\n}\n\nclass MyBst {\n    TreeNode root;\n    Map<TreeNode, Integer> nodeNum;\n\n    public MyBst(TreeNode root) {\n        this.root = root;\n        this.nodeNum = new HashMap<TreeNode, Integer>();\n        countNodeNum(root);\n    }\n\n    // 返回二叉搜索树中第k小的元素\n    public int kthSmallest(int k) {\n        TreeNode node = root;\n        while (node != null) {\n            int left = getNodeNum(node.left);\n            if (left < k - 1) {\n                node = node.right;\n                k -= left + 1;\n            } else if (left == k - 1) {\n                break;\n            } else {\n                node = node.left;\n            }\n        }\n        return node.val;\n    }\n\n    // 统计以node为根结点的子树的结点数\n    private int countNodeNum(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        nodeNum.put(node, 1 + countNodeNum(node.left) + countNodeNum(node.right));\n        return nodeNum.get(node);\n    }\n\n    // 获取以node为根结点的子树的结点数\n    private int getNodeNum(TreeNode node) {\n        return nodeNum.getOrDefault(node, 0);\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int KthSmallest(TreeNode root, int k) {\n        MyBst bst = new MyBst(root);\n        return bst.KthSmallest(k);\n    }\n}\n\nclass MyBst {\n    TreeNode root;\n    Dictionary<TreeNode, int> nodeNum;\n\n    public MyBst(TreeNode root) {\n        this.root = root;\n        this.nodeNum = new Dictionary<TreeNode, int>();\n        CountNodeNum(root);\n    }\n\n    // 返回二叉搜索树中第k小的元素\n    public int KthSmallest(int k) {\n        TreeNode node = root;\n        while (node != null) {\n            int left = GetNodeNum(node.left);\n            if (left < k - 1) {\n                node = node.right;\n                k -= left + 1;\n            } else if (left == k - 1) {\n                break;\n            } else {\n                node = node.left;\n            }\n        }\n        return node.val;\n    }\n\n    // 统计以node为根结点的子树的结点数\n    private int CountNodeNum(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        nodeNum.Add(node, 1 + CountNodeNum(node.left) + CountNodeNum(node.right));\n        return nodeNum[node];\n    }\n\n    // 获取以node为根结点的子树的结点数\n    private int GetNodeNum(TreeNode node) {\n        return node != null && nodeNum.ContainsKey(node) ? nodeNum[node] : 0;\n    }\n}\n```\n\n```go [sol2-Golang]\ntype MyBst struct {\n    root    *TreeNode\n    nodeNum map[*TreeNode]int // 统计以每个结点为根结点的子树的结点数，并存储在哈希表中\n}\n\n// 统计以 node 为根结点的子树的结点数\nfunc (t *MyBst) countNodeNum(node *TreeNode) int {\n    if node == nil {\n        return 0\n    }\n    t.nodeNum[node] = 1 + t.countNodeNum(node.Left) + t.countNodeNum(node.Right)\n    return t.nodeNum[node]\n}\n\n// 返回二叉搜索树中第 k 小的元素\nfunc (t *MyBst) kthSmallest(k int) int {\n    node := t.root\n    for {\n        leftNodeNum := t.nodeNum[node.Left]\n        if leftNodeNum < k-1 {\n            node = node.Right\n            k -= leftNodeNum + 1\n        } else if leftNodeNum == k-1 {\n            return node.Val\n        } else {\n            node = node.Left\n        }\n    }\n}\n\nfunc kthSmallest(root *TreeNode, k int) int {\n    t := &MyBst{root, map[*TreeNode]int{}}\n    t.countNodeNum(root)\n    return t.kthSmallest(k)\n}\n```\n\n```C++ [sol2-C++]\nclass MyBst {\npublic:\n    MyBst(TreeNode *root) {\n        this->root = root;\n        countNodeNum(root);\n    }\n\n    // 返回二叉搜索树中第k小的元素\n    int kthSmallest(int k) {\n        TreeNode *node = root;\n        while (node != nullptr) {\n            int left = getNodeNum(node->left);\n            if (left < k - 1) {\n                node = node->right;\n                k -= left + 1;\n            } else if (left == k - 1) {\n                break;\n            } else {\n                node = node->left;\n            }\n        }\n        return node->val;\n    }\n\nprivate:\n    TreeNode *root;\n    unordered_map<TreeNode *, int> nodeNum;\n\n    // 统计以node为根结点的子树的结点数\n    int countNodeNum(TreeNode * node) {\n        if (node == nullptr) {\n            return 0;\n        }\n        nodeNum[node] = 1 + countNodeNum(node->left) + countNodeNum(node->right);\n        return nodeNum[node];\n    }\n\n    // 获取以node为根结点的子树的结点数\n    int getNodeNum(TreeNode * node) {\n        if (node != nullptr && nodeNum.count(node)) {\n            return nodeNum[node];\n        }else{\n            return 0;\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        MyBst bst(root);\n        return bst.kthSmallest(k);\n    }\n};\n```\n\n```JavaScript [sol2-JavaScript]\nvar kthSmallest = function(root, k) {\n    const bst = new MyBst(root);\n    return bst.kthSmallest(k);\n};\n\nclass MyBst {\n    constructor(root) {\n        this.root = root;\n        this.nodeNum = new Map();\n        this.countNodeNum(root);\n    }\n\n    // 返回二叉搜索树中第k小的元素\n    kthSmallest(k) {\n        let node = this.root;\n        while (node != null) {\n            const left = this.getNodeNum(node.left);\n            if (left < k - 1) {\n                node = node.right;\n                k -= left + 1;\n            } else if (left === k - 1) {\n                break;\n            } else {\n                node = node.left;\n            }\n        }\n        return node.val;\n    }\n\n    // 统计以node为根结点的子树的结点数\n    countNodeNum(node) {\n        if (node == null) {\n            return 0;\n        }\n        this.nodeNum.set(node, 1 + this.countNodeNum(node.left) + this.countNodeNum(node.right));\n        return this.nodeNum.get(node);\n    }\n\n    // 获取以node为根结点的子树的结点数\n    getNodeNum(node) {\n        return this.nodeNum.get(node) || 0;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：预处理的时间复杂度为 $O(N)$，其中 $N$ 是树中结点的总数；我们需要遍历树中所有结点来统计以每个结点为根结点的子树的结点数。搜索的时间复杂度为 $O(H)$，其中 $H$ 是树的高度；当树是平衡树时，时间复杂度取得最小值 $O(\\log N)$；当树是线性树时，时间复杂度取得最大值 $O(N)$。\n\n- 空间复杂度：$O(N)$，用于存储以每个结点为根结点的子树的结点数。\n\n#### 方法三：平衡二叉搜索树\n\n> 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 $k$ 小的值，你将如何优化算法？\n\n**预备知识**\n\n方法三需要先掌握 **平衡二叉搜索树（AVL树）** 的知识。平衡二叉搜索树具有如下性质：\n\n- 平衡二叉搜索树中每个结点的左子树和右子树的高度最多相差 $1$；\n\n- 平衡二叉搜索树的子树也是平衡二叉搜索树；\n\n- 一棵存有 $n$ 个结点的平衡二叉搜索树的高度是 $O(\\log n)$。\n\n**思路和算法**\n\n我们注意到在方法二中搜索二叉搜索树的时间复杂度为 $O(H)$，其中 $H$ 是树的高度；当树是平衡树时，时间复杂度取得最小值 $O(\\log N)$。因此，我们在记录子树的结点数的基础上，将二叉搜索树转换为平衡二叉搜索树，并在插入和删除操作中维护它的平衡状态。\n\n其中，将二叉搜索树转换为平衡二叉搜索树，可以参考「[1382. 将二叉搜索树变平衡的官方题解](https://leetcode-cn.com/problems/balance-a-binary-search-tree/solution/jiang-er-cha-sou-suo-shu-bian-ping-heng-by-leetcod/)」。在插入和删除操作中维护平衡状态相对复杂，读者可以阅读下面的代码和注释，理解如何通过旋转和重组实现它。\n\n**代码**\n\n```Python [sol3-Python3]\nclass AVL:\n    \"\"\"平衡二叉搜索树（AVL树）：允许重复值\"\"\"\n\n    class Node:\n        \"\"\"平衡二叉搜索树结点\"\"\"\n        __slots__ = (\"val\", \"parent\", \"left\", \"right\", \"size\", \"height\")\n\n        def __init__(self, val, parent=None, left=None, right=None):\n            self.val = val\n            self.parent = parent\n            self.left = left\n            self.right = right\n            self.height = 0  # 结点高度：以node为根节点的子树的高度（高度定义：叶结点的高度是0）\n            self.size = 1  # 结点元素数：以node为根节点的子树的节点总数\n\n    def __init__(self, vals):\n        self.root = self._build(vals, 0, len(vals) - 1, None) if vals else None\n\n    def _build(self, vals, l, r, parent):\n        \"\"\"根据vals[l:r]构造平衡二叉搜索树 -> 返回根结点\"\"\"\n        m = (l + r) // 2\n        node = self.Node(vals[m], parent=parent)\n        if l <= m - 1:\n            node.left = self._build(vals, l, m - 1, parent=node)\n        if m + 1 <= r:\n            node.right = self._build(vals, m + 1, r, parent=node)\n        self._recompute(node)\n        return node\n\n    def kth_smallest(self, k: int) -> int:\n        \"\"\"返回二叉搜索树中第k小的元素\"\"\"\n        node = self.root\n        while node:\n            left = self._get_size(node.left)\n            if left < k - 1:\n                node = node.right\n                k -= left + 1\n            elif left == k - 1:\n                return node.val\n            else:\n                node = node.left\n\n    def insert(self, v):\n        \"\"\"插入值为v的新结点\"\"\"\n        if self.root is None:\n            self.root = self.Node(v)\n        else:\n            # 计算新结点的添加位置\n            node = self._subtree_search(self.root, v)\n            is_add_left = (v <= node.val)  # 是否将新结点添加到node的左子结点\n            if node.val == v:  # 如果值为v的结点已存在\n                if node.left:  # 值为v的结点存在左子结点，则添加到其左子树的最右侧\n                    node = self._subtree_last(node.left)\n                    is_add_left = False\n                else:  # 值为v的结点不存在左子结点，则添加到其左子结点\n                    is_add_left = True\n\n            # 添加新结点\n            leaf = self.Node(v, parent=node)\n            if is_add_left:\n                node.left = leaf\n            else:\n                node.right = leaf\n\n            self._rebalance(leaf)\n\n    def delete(self, v) -> bool:\n        \"\"\"删除值为v的结点 -> 返回是否成功删除结点\"\"\"\n        if self.root is None:\n            return False\n\n        node = self._subtree_search(self.root, v)\n        if node.val != v:  # 没有找到需要删除的结点\n            return False\n\n        # 处理当前结点既有左子树也有右子树的情况\n        # 若左子树比右子树高度低，则将当前结点替换为右子树最左侧的结点，并移除右子树最左侧的结点\n        # 若右子树比左子树高度低，则将当前结点替换为左子树最右侧的结点，并移除左子树最右侧的结点\n        if node.left and node.right:\n            if node.left.height <= node.right.height:\n                replacement = self._subtree_first(node.right)\n            else:\n                replacement = self._subtree_last(node.left)\n            node.val = replacement.val\n            node = replacement\n\n        parent = node.parent\n        self._delete(node)\n        self._rebalance(parent)\n        return True\n\n    def _delete(self, node):\n        \"\"\"删除结点p并用它的子结点代替它，结点p至多只能有1个子结点\"\"\"\n        if node.left and node.right:\n            raise ValueError('node has two children')\n        child = node.left if node.left else node.right\n        if child is not None:\n            child.parent = node.parent\n        if node is self.root:\n            self.root = child\n        else:\n            parent = node.parent\n            if node is parent.left:\n                parent.left = child\n            else:\n                parent.right = child\n        node.parent = node\n\n    def _subtree_search(self, node, v):\n        \"\"\"在以node为根结点的子树中搜索值为v的结点，如果没有值为v的结点，则返回值为v的结点应该在的位置的父结点\"\"\"\n        if node.val < v and node.right is not None:\n            return self._subtree_search(node.right, v)\n        elif node.val > v and node.left is not None:\n            return self._subtree_search(node.left, v)\n        else:\n            return node\n\n    def _recompute(self, node):\n        \"\"\"重新计算node结点的高度和元素数\"\"\"\n        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))\n        node.size = 1 + self._get_size(node.left) + self._get_size(node.right)\n\n    def _rebalance(self, node):\n        \"\"\"从node结点开始（含node结点）逐个向上重新平衡二叉树，并更新结点高度和元素数\"\"\"\n        while node is not None:\n            old_height, old_size = node.height, node.size\n            if not self._is_balanced(node):\n                node = self._restructure(self._tall_grandchild(node))\n                self._recompute(node.left)\n                self._recompute(node.right)\n            self._recompute(node)\n            if node.height == old_height and node.size == old_size:\n                node = None  # 如果结点高度和元素数都没有变化则不需要再继续向上调整\n            else:\n                node = node.parent\n\n    def _is_balanced(self, node):\n        \"\"\"判断node结点是否平衡\"\"\"\n        return abs(self._get_height(node.left) - self._get_height(node.right)) <= 1\n\n    def _tall_child(self, node):\n        \"\"\"获取node结点更高的子树\"\"\"\n        if self._get_height(node.left) > self._get_height(node.right):\n            return node.left\n        else:\n            return node.right\n\n    def _tall_grandchild(self, node):\n        \"\"\"获取node结点更高的子树中的更高的子树\"\"\"\n        child = self._tall_child(node)\n        return self._tall_child(child)\n\n    @staticmethod\n    def _relink(parent, child, is_left):\n        \"\"\"重新连接父结点和子结点（子结点允许为空）\"\"\"\n        if is_left:\n            parent.left = child\n        else:\n            parent.right = child\n        if child is not None:\n            child.parent = parent\n\n    def _rotate(self, node):\n        \"\"\"旋转操作\"\"\"\n        parent = node.parent\n        grandparent = parent.parent\n        if grandparent is None:\n            self.root = node\n            node.parent = None\n        else:\n            self._relink(grandparent, node, parent == grandparent.left)\n\n        if node == parent.left:\n            self._relink(parent, node.right, True)\n            self._relink(node, parent, False)\n        else:\n            self._relink(parent, node.left, False)\n            self._relink(node, parent, True)\n\n    def _restructure(self, node):\n        \"\"\"trinode操作\"\"\"\n        parent = node.parent\n        grandparent = parent.parent\n\n        if (node == parent.right) == (parent == grandparent.right):  # 处理需要一次旋转的情况\n            self._rotate(parent)\n            return parent\n        else:  # 处理需要两次旋转的情况：第1次旋转后即成为需要一次旋转的情况\n            self._rotate(node)\n            self._rotate(node)\n            return node\n\n    @staticmethod\n    def _subtree_first(node):\n        \"\"\"返回以node为根结点的子树的第1个元素\"\"\"\n        while node.left is not None:\n            node = node.left\n        return node\n\n    @staticmethod\n    def _subtree_last(node):\n        \"\"\"返回以node为根结点的子树的最后1个元素\"\"\"\n        while node.right is not None:\n            node = node.right\n        return node\n\n    @staticmethod\n    def _get_height(node) -> int:\n        \"\"\"获取以node为根结点的子树的高度\"\"\"\n        return node.height if node is not None else 0\n\n    @staticmethod\n    def _get_size(node) -> int:\n        \"\"\"获取以node为根结点的子树的结点数\"\"\"\n        return node.size if node is not None else 0\n\n\nclass Solution:\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\n        def inorder(node):\n            if node.left:\n                inorder(node.left)\n            inorder_lst.append(node.val)\n            if node.right:\n                inorder(node.right)\n\n        # 中序遍历生成数值列表\n        inorder_lst = []\n        inorder(root)\n\n        # 构造平衡二叉搜索树\n        avl = AVL(inorder_lst)\n\n        # 模拟1000次插入和删除操作\n        random_nums = [random.randint(0, 10001) for _ in range(1000)]\n        for num in random_nums:\n            avl.insert(num)\n        random.shuffle(random_nums)  # 列表乱序\n        for num in random_nums:\n            avl.delete(num)\n\n        return avl.kth_smallest(k)\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        // 中序遍历生成数值列表\n        List<Integer> inorderList = new ArrayList<Integer>();\n        inorder(root, inorderList);\n\n        // 构造平衡二叉搜索树\n        AVL avl = new AVL(inorderList);\n\n        // 模拟1000次插入和删除操作\n        int[] randomNums = new int[1000];\n        Random random = new Random();\n        for (int i = 0; i < 1000; ++i) {\n            randomNums[i] = random.nextInt(10001);\n            avl.insert(randomNums[i]);\n        }\n        shuffle(randomNums); // 列表乱序\n        for (int i = 0; i < 1000; ++i) {\n            avl.delete(randomNums[i]);\n        }\n\n        return avl.kthSmallest(k);\n    }\n\n    private void inorder(TreeNode node, List<Integer> inorderList) {\n        if (node.left != null) {\n            inorder(node.left, inorderList);\n        }\n        inorderList.add(node.val);\n        if (node.right != null) {\n            inorder(node.right, inorderList);\n        }\n    }\n\n    private void shuffle(int[] arr) {\n        Random random = new Random();\n        int length = arr.length;\n        for (int i = 0; i < length; i++) {\n            int randIndex = random.nextInt(length);\n            int temp = arr[i];\n            arr[i] = arr[randIndex];\n            arr[randIndex] = temp;\n        }\n    }\n}\n\n// 平衡二叉搜索树（AVL树）：允许重复值\nclass AVL {\n    Node root;\n\n    // 平衡二叉搜索树结点\n    class Node {\n        int val;\n        Node parent;\n        Node left;\n        Node right;\n        int size;\n        int height;\n\n        public Node(int val) {\n            this(val, null);\n        }\n\n        public Node(int val, Node parent) {\n            this(val, parent, null, null);\n        }\n\n        public Node(int val, Node parent, Node left, Node right) {\n            this.val = val;\n            this.parent = parent;\n            this.left = left;\n            this.right = right;\n            this.height = 0; // 结点高度：以node为根节点的子树的高度（高度定义：叶结点的高度是0）\n            this.size = 1; // 结点元素数：以node为根节点的子树的节点总数\n        }\n    }\n\n    public AVL(List<Integer> vals) {\n        if (vals != null) {\n            this.root = build(vals, 0, vals.size() - 1, null);\n        }\n    }\n\n    // 根据vals[l:r]构造平衡二叉搜索树 -> 返回根结点\n    private Node build(List<Integer> vals, int l, int r, Node parent) {\n        int m = (l + r) >> 1;\n        Node node = new Node(vals.get(m), parent);\n        if (l <= m - 1) {\n            node.left = build(vals, l, m - 1, node);\n        }\n        if (m + 1 <= r) {\n            node.right = build(vals, m + 1, r, node);\n        }\n        recompute(node);\n        return node;\n    }\n\n    // 返回二叉搜索树中第k小的元素\n    public int kthSmallest(int k) {\n        Node node = root;\n        while (node != null) {\n            int left = getSize(node.left);\n            if (left < k - 1) {\n                node = node.right;\n                k -= left + 1;\n            } else if (left == k - 1) {\n                break;\n            } else {\n                node = node.left;\n            }\n        }\n        return node.val;\n    }\n\n    public void insert(int v) {\n        if (root == null) {\n            root = new Node(v);\n        } else {\n            // 计算新结点的添加位置\n            Node node = subtreeSearch(root, v);\n            boolean isAddLeft = v <= node.val; // 是否将新结点添加到node的左子结点\n            if (node.val == v) { // 如果值为v的结点已存在\n                if (node.left != null) { // 值为v的结点存在左子结点，则添加到其左子树的最右侧\n                    node = subtreeLast(node.left);\n                    isAddLeft = false;\n                } else { // 值为v的结点不存在左子结点，则添加到其左子结点\n                    isAddLeft = true;\n                }\n            }\n\n            // 添加新结点\n            Node leaf = new Node(v, node);\n            if (isAddLeft) {\n                node.left = leaf;\n            } else {\n                node.right = leaf;\n            }\n\n            rebalance(leaf);\n        }\n    }\n\n    // 删除值为v的结点 -> 返回是否成功删除结点\n    public boolean delete(int v) {\n        if (root == null) {\n            return false;\n        }\n\n        Node node = subtreeSearch(root, v);\n        if (node.val != v) { // 没有找到需要删除的结点\n            return false;\n        }\n\n        // 处理当前结点既有左子树也有右子树的情况\n        // 若左子树比右子树高度低，则将当前结点替换为右子树最左侧的结点，并移除右子树最左侧的结点\n        // 若右子树比左子树高度低，则将当前结点替换为左子树最右侧的结点，并移除左子树最右侧的结点\n        if (node.left != null && node.right != null) {\n            Node replacement = null;\n            if (node.left.height <= node.right.height) {\n                replacement = subtreeFirst(node.right);\n            } else {\n                replacement = subtreeLast(node.left);\n            }\n            node.val = replacement.val;\n            node = replacement;\n        }\n\n        Node parent = node.parent;\n        delete(node);\n        rebalance(parent);\n        return true;\n    }\n\n    // 删除结点p并用它的子结点代替它，结点p至多只能有1个子结点\n    private void delete(Node node) {\n        if (node.left != null && node.right != null) {\n            return;\n            // throw new Exception(\"Node has two children\");\n        }\n        Node child = node.left != null ? node.left : node.right;\n        if (child != null) {\n            child.parent = node.parent;\n        }\n        if (node == root) {\n            root = child;\n        } else {\n            Node parent = node.parent;\n            if (node == parent.left) {\n                parent.left = child;\n            } else {\n                parent.right = child;\n            }\n        }\n        node.parent = node;\n    }\n\n    // 在以node为根结点的子树中搜索值为v的结点，如果没有值为v的结点，则返回值为v的结点应该在的位置的父结点\n    private Node subtreeSearch(Node node, int v) {\n        if (node.val < v && node.right != null) {\n            return subtreeSearch(node.right, v);\n        } else if (node.val > v && node.left != null) {\n            return subtreeSearch(node.left, v);\n        } else {\n            return node;\n        }\n    }\n\n    // 重新计算node结点的高度和元素数\n    private void recompute(Node node) {\n        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));\n        node.size = 1 + getSize(node.left) + getSize(node.right);\n    }\n\n    // 从node结点开始（含node结点）逐个向上重新平衡二叉树，并更新结点高度和元素数\n    private void rebalance(Node node) {\n        while (node != null) {\n            int oldHeight = node.height, oldSize = node.size;\n            if (!isBalanced(node)) {\n                node = restructure(tallGrandchild(node));\n                recompute(node.left);\n                recompute(node.right);\n            }\n            recompute(node);\n            if (node.height == oldHeight && node.size == oldSize) {\n                node = null; // 如果结点高度和元素数都没有变化则不需要再继续向上调整\n            } else {\n                node = node.parent;\n            }\n        }\n    }\n\n    // 判断node结点是否平衡\n    private boolean isBalanced(Node node) {\n        return Math.abs(getHeight(node.left) - getHeight(node.right)) <= 1;\n    }\n\n    // 获取node结点更高的子树\n    private Node tallChild(Node node) {\n        if (getHeight(node.left) > getHeight(node.right)) {\n            return node.left;\n        } else {\n            return node.right;\n        }\n    }\n\n    // 获取node结点更高的子树中的更高的子树\n    private Node tallGrandchild(Node node) {\n        Node child = tallChild(node);\n        return tallChild(child);\n    }\n\n    // 重新连接父结点和子结点（子结点允许为空）\n    private static void relink(Node parent, Node child, boolean isLeft) {\n        if (isLeft) {\n            parent.left = child;\n        } else {\n            parent.right = child;\n        }\n        if (child != null) {\n            child.parent = parent;\n        }\n    }\n\n    // 旋转操作\n    private void rotate(Node node) {\n        Node parent = node.parent;\n        Node grandparent = parent.parent;\n        if (grandparent == null) {\n            root = node;\n            node.parent = null;\n        } else {\n            relink(grandparent, node, parent == grandparent.left);\n        }\n\n        if (node == parent.left) {\n            relink(parent, node.right, true);\n            relink(node, parent, false);\n        } else {\n            relink(parent, node.left, false);\n            relink(node, parent, true);\n        }\n    }\n\n    // trinode操作\n    private Node restructure(Node node) {\n        Node parent = node.parent;\n        Node grandparent = parent.parent;\n\n        if ((node == parent.right) == (parent == grandparent.right)) { // 处理需要一次旋转的情况\n            rotate(parent);\n            return parent;\n        } else { // 处理需要两次旋转的情况：第1次旋转后即成为需要一次旋转的情况\n            rotate(node);\n            rotate(node);\n            return node;\n        }\n    }\n\n    // 返回以node为根结点的子树的第1个元素\n    private static Node subtreeFirst(Node node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node;\n    }\n\n    // 返回以node为根结点的子树的最后1个元素\n    private static Node subtreeLast(Node node) {\n        while (node.right != null) {\n            node = node.right;\n        }\n        return node;\n    }\n\n    // 获取以node为根结点的子树的高度\n    private static int getHeight(Node node) {\n        return node != null ? node.height : 0;\n    }\n\n    // 获取以node为根结点的子树的结点数\n    private static int getSize(Node node) {\n        return node != null ? node.size : 0;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int KthSmallest(TreeNode root, int k) {\n        // 中序遍历生成数值列表\n        IList<int> inorderList = new List<int>();\n        Inorder(root, inorderList);\n\n        // 构造平衡二叉搜索树\n        AVL avl = new AVL(inorderList);\n\n        // 模拟1000次插入和删除操作\n        int[] randomNums = new int[1000];\n        Random random = new Random();\n        for (int i = 0; i < 1000; ++i) {\n            randomNums[i] = random.Next(10001);\n            avl.Insert(randomNums[i]);\n        }\n        Shuffle(randomNums); // 列表乱序\n        for (int i = 0; i < 1000; ++i) {\n            avl.Delete(randomNums[i]);\n        }\n\n        return avl.KthSmallest(k);\n    }\n\n    private void Inorder(TreeNode node, IList<int> inorderList) {\n        if (node.left != null) {\n            Inorder(node.left, inorderList);\n        }\n        inorderList.Add(node.val);\n        if (node.right != null) {\n            Inorder(node.right, inorderList);\n        }\n    }\n\n    private void Shuffle(int[] arr) {\n        Random random = new Random();\n        int length = arr.Length;\n        for (int i = 0; i < length; i++) {\n            int randIndex = random.Next(length);\n            int temp = arr[i];\n            arr[i] = arr[randIndex];\n            arr[randIndex] = temp;\n        }\n    }\n}\n\n// 平衡二叉搜索树（AVL树）：允许重复值\nclass AVL {\n    Node root;\n\n    // 平衡二叉搜索树结点\n    class Node {\n        public int val;\n        public Node parent;\n        public Node left;\n        public Node right;\n        public int size;\n        public int height;\n\n        public Node(int val) : this(val, null) {\n        }\n\n        public Node(int val, Node parent) : this(val, parent, null, null) {\n        }\n\n        public Node(int val, Node parent, Node left, Node right) {\n            this.val = val;\n            this.parent = parent;\n            this.left = left;\n            this.right = right;\n            this.height = 0; // 结点高度：以node为根节点的子树的高度（高度定义：叶结点的高度是0）\n            this.size = 1; // 结点元素数：以node为根节点的子树的节点总数\n        }\n    }\n\n    public AVL(IList<int> vals) {\n        if (vals != null) {\n            this.root = Build(vals, 0, vals.Count - 1, null);\n        }\n    }\n\n    // 根据vals[l:r]构造平衡二叉搜索树 -> 返回根结点\n    private Node Build(IList<int> vals, int l, int r, Node parent) {\n        int m = (l + r) >> 1;\n        Node node = new Node(vals[m], parent);\n        if (l <= m - 1) {\n            node.left = Build(vals, l, m - 1, node);\n        }\n        if (m + 1 <= r) {\n            node.right = Build(vals, m + 1, r, node);\n        }\n        Recompute(node);\n        return node;\n    }\n\n    // 返回二叉搜索树中第k小的元素\n    public int KthSmallest(int k) {\n        Node node = root;\n        while (node != null) {\n            int left = GetSize(node.left);\n            if (left < k - 1) {\n                node = node.right;\n                k -= left + 1;\n            } else if (left == k - 1) {\n                break;\n            } else {\n                node = node.left;\n            }\n        }\n        return node.val;\n    }\n\n    public void Insert(int v) {\n        if (root == null) {\n            root = new Node(v);\n        } else {\n            // 计算新结点的添加位置\n            Node node = SubtreeSearch(root, v);\n            bool isAddLeft = v <= node.val; // 是否将新结点添加到node的左子结点\n            if (node.val == v) { // 如果值为v的结点已存在\n                if (node.left != null) { // 值为v的结点存在左子结点，则添加到其左子树的最右侧\n                    node = SubtreeLast(node.left);\n                    isAddLeft = false;\n                } else { // 值为v的结点不存在左子结点，则添加到其左子结点\n                    isAddLeft = true;\n                }\n            }\n\n            // 添加新结点\n            Node leaf = new Node(v, node);\n            if (isAddLeft) {\n                node.left = leaf;\n            } else {\n                node.right = leaf;\n            }\n\n            Rebalance(leaf);\n        }\n    }\n\n    // 删除值为v的结点 -> 返回是否成功删除结点\n    public bool Delete(int v) {\n        if (root == null) {\n            return false;\n        }\n\n        Node node = SubtreeSearch(root, v);\n        if (node.val != v) { // 没有找到需要删除的结点\n            return false;\n        }\n\n        // 处理当前结点既有左子树也有右子树的情况\n        // 若左子树比右子树高度低，则将当前结点替换为右子树最左侧的结点，并移除右子树最左侧的结点\n        // 若右子树比左子树高度低，则将当前结点替换为左子树最右侧的结点，并移除左子树最右侧的结点\n        if (node.left != null && node.right != null) {\n            Node replacement = null;\n            if (node.left.height <= node.right.height) {\n                replacement = SubtreeFirst(node.right);\n            } else {\n                replacement = SubtreeLast(node.left);\n            }\n            node.val = replacement.val;\n            node = replacement;\n        }\n\n        Node parent = node.parent;\n        Delete(node);\n        Rebalance(parent);\n        return true;\n    }\n\n    // 删除结点p并用它的子结点代替它，结点p至多只能有1个子结点\n    private void Delete(Node node) {\n        if (node.left != null && node.right != null) {\n            return;\n            // throw new Exception(\"Node has two children\");\n        }\n        Node child = node.left != null ? node.left : node.right;\n        if (child != null) {\n            child.parent = node.parent;\n        }\n        if (node == root) {\n            root = child;\n        } else {\n            Node parent = node.parent;\n            if (node == parent.left) {\n                parent.left = child;\n            } else {\n                parent.right = child;\n            }\n        }\n        node.parent = node;\n    }\n\n    // 在以node为根结点的子树中搜索值为v的结点，如果没有值为v的结点，则返回值为v的结点应该在的位置的父结点\n    private Node SubtreeSearch(Node node, int v) {\n        if (node.val < v && node.right != null) {\n            return SubtreeSearch(node.right, v);\n        } else if (node.val > v && node.left != null) {\n            return SubtreeSearch(node.left, v);\n        } else {\n            return node;\n        }\n    }\n\n    // 重新计算node结点的高度和元素数\n    private void Recompute(Node node) {\n        node.height = 1 + Math.Max(GetHeight(node.left), GetHeight(node.right));\n        node.size = 1 + GetSize(node.left) + GetSize(node.right);\n    }\n\n    // 从node结点开始（含node结点）逐个向上重新平衡二叉树，并更新结点高度和元素数\n    private void Rebalance(Node node) {\n        while (node != null) {\n            int oldHeight = node.height, oldSize = node.size;\n            if (!IsBalanced(node)) {\n                node = Restructure(TallGrandchild(node));\n                Recompute(node.left);\n                Recompute(node.right);\n            }\n            Recompute(node);\n            if (node.height == oldHeight && node.size == oldSize) {\n                node = null; // 如果结点高度和元素数都没有变化则不需要再继续向上调整\n            } else {\n                node = node.parent;\n            }\n        }\n    }\n\n    // 判断node结点是否平衡\n    private bool IsBalanced(Node node) {\n        return Math.Abs(GetHeight(node.left) - GetHeight(node.right)) <= 1;\n    }\n\n    // 获取node结点更高的子树\n    private Node TallChild(Node node) {\n        if (GetHeight(node.left) > GetHeight(node.right)) {\n            return node.left;\n        } else {\n            return node.right;\n        }\n    }\n\n    // 获取node结点更高的子树中的更高的子树\n    private Node TallGrandchild(Node node) {\n        Node child = TallChild(node);\n        return TallChild(child);\n    }\n\n    // 重新连接父结点和子结点（子结点允许为空）\n    private static void Relink(Node parent, Node child, bool isLeft) {\n        if (isLeft) {\n            parent.left = child;\n        } else {\n            parent.right = child;\n        }\n        if (child != null) {\n            child.parent = parent;\n        }\n    }\n\n    // 旋转操作\n    private void Rotate(Node node) {\n        Node parent = node.parent;\n        Node grandparent = parent.parent;\n        if (grandparent == null) {\n            root = node;\n            node.parent = null;\n        } else {\n            Relink(grandparent, node, parent == grandparent.left);\n        }\n\n        if (node == parent.left) {\n            Relink(parent, node.right, true);\n            Relink(node, parent, false);\n        } else {\n            Relink(parent, node.left, false);\n            Relink(node, parent, true);\n        }\n    }\n\n    // trinode操作\n    private Node Restructure(Node node) {\n        Node parent = node.parent;\n        Node grandparent = parent.parent;\n\n        if ((node == parent.right) == (parent == grandparent.right)) { // 处理需要一次旋转的情况\n            Rotate(parent);\n            return parent;\n        } else { // 处理需要两次旋转的情况：第1次旋转后即成为需要一次旋转的情况\n            Rotate(node);\n            Rotate(node);\n            return node;\n        }\n    }\n\n    // 返回以node为根结点的子树的第1个元素\n    private static Node SubtreeFirst(Node node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node;\n    }\n\n    // 返回以node为根结点的子树的最后1个元素\n    private static Node SubtreeLast(Node node) {\n        while (node.right != null) {\n            node = node.right;\n        }\n        return node;\n    }\n\n    // 获取以node为根结点的子树的高度\n    private static int GetHeight(Node node) {\n        return node != null ? node.height : 0;\n    }\n\n    // 获取以node为根结点的子树的结点数\n    private static int GetSize(Node node) {\n        return node != null ? node.size : 0;\n    }\n}\n```\n\n```C++ [sol3-C++]\n// 平衡二叉搜索树结点\nstruct Node {\n    int val;\n    Node * parent;\n    Node * left;\n    Node * right;\n    int size;\n    int height;\n\n    Node(int val) {\n        this->val = val;\n        this->parent = nullptr;\n        this->left = nullptr;\n        this->right = nullptr;\n        this->height = 0; // 结点高度：以node为根节点的子树的高度（高度定义：叶结点的高度是0）\n        this->size = 1; // 结点元素数：以node为根节点的子树的节点总数\n    }\n\n    Node(int val, Node * parent) {\n        this->val = val;\n        this->parent = parent;\n        this->left = nullptr;\n        this->right = nullptr;\n        this->height = 0; // 结点高度：以node为根节点的子树的高度（高度定义：叶结点的高度是0）\n        this->size = 1; // 结点元素数：以node为根节点的子树的节点总数\n    }\n\n    Node(int val, Node * parent, Node * left, Node * right) {\n        this->val = val;\n        this->parent = parent;\n        this->left = left;\n        this->right = right;\n        this->height = 0; // 结点高度：以node为根节点的子树的高度（高度定义：叶结点的高度是0）\n        this->size = 1; // 结点元素数：以node为根节点的子树的节点总数\n    }\n};\n\n\n// 平衡二叉搜索树（AVL树）：允许重复值\nclass AVL {\npublic:\n    AVL(vector<int> & vals) {\n        if (!vals.empty()) {\n            root = build(vals, 0, vals.size() - 1, nullptr);\n        }\n    }\n\n    // 根据vals[l:r]构造平衡二叉搜索树 -> 返回根结点\n    Node * build(vector<int> & vals, int l, int r, Node * parent) {\n        int m = (l + r) >> 1;\n        Node * node = new Node(vals[m], parent);\n        if (l <= m - 1) {\n            node->left = build(vals, l, m - 1, node);\n        }\n        if (m + 1 <= r) {\n            node->right = build(vals, m + 1, r, node);\n        }\n        recompute(node);\n        return node;\n    }\n\n    // 返回二叉搜索树中第k小的元素\n    int kthSmallest(int k) {\n        Node * node = root;\n        while (node != nullptr) {\n            int left = getSize(node->left);\n            if (left < k - 1) {\n                node = node->right;\n                k -= left + 1;\n            } else if (left == k - 1) {\n                break;\n            } else {\n                node = node->left;\n            }\n        }\n        return node->val;\n    }\n\n    void insert(int v) {\n        if (root == nullptr) {\n            root = new Node(v);\n        } else {\n            // 计算新结点的添加位置\n            Node * node = subtreeSearch(root, v);\n            bool isAddLeft = v <= node->val; // 是否将新结点添加到node的左子结点\n            if (node->val == v) { // 如果值为v的结点已存在\n                if (node->left != nullptr) { // 值为v的结点存在左子结点，则添加到其左子树的最右侧\n                    node = subtreeLast(node->left);\n                    isAddLeft = false;\n                } else { // 值为v的结点不存在左子结点，则添加到其左子结点\n                    isAddLeft = true;\n                }\n            }\n\n            // 添加新结点\n            Node * leaf = new Node(v, node);\n            if (isAddLeft) {\n                node->left = leaf;\n            } else {\n                node->right = leaf;\n            }\n\n            rebalance(leaf);\n        }\n    }\n\n    // 删除值为v的结点 -> 返回是否成功删除结点\n    bool Delete(int v) {\n        if (root == nullptr) {\n            return false;\n        }\n\n        Node * node = subtreeSearch(root, v);\n        if (node->val != v) { // 没有找到需要删除的结点\n            return false;\n        }\n\n        // 处理当前结点既有左子树也有右子树的情况\n        // 若左子树比右子树高度低，则将当前结点替换为右子树最左侧的结点，并移除右子树最左侧的结点\n        // 若右子树比左子树高度低，则将当前结点替换为左子树最右侧的结点，并移除左子树最右侧的结点\n        if (node->left != nullptr && node->right != nullptr) {\n            Node * replacement = nullptr;\n            if (node->left->height <= node->right->height) {\n                replacement = subtreeFirst(node->right);\n            } else {\n                replacement = subtreeLast(node->left);\n            }\n            node->val = replacement->val;\n            node = replacement;\n        }\n\n        Node * parent = node->parent;\n        Delete(node);\n        rebalance(parent);\n        return true;\n    }\n\nprivate:\n    Node * root;\n\n    // 删除结点p并用它的子结点代替它，结点p至多只能有1个子结点\n    void Delete(Node * node) {\n        if (node->left != nullptr && node->right != nullptr) {\n            return;\n            // throw new Exception(\"Node has two children\");\n        }\n        Node * child = node->left != nullptr ? node->left : node->right;\n        if (child != nullptr) {\n            child->parent = node->parent;\n        }\n        if (node == root) {\n            root = child;\n        } else {\n            Node * parent = node->parent;\n            if (node == parent->left) {\n                parent->left = child;\n            } else {\n                parent->right = child;\n            }\n        }\n        node->parent = node;\n    }\n\n    // 在以node为根结点的子树中搜索值为v的结点，如果没有值为v的结点，则返回值为v的结点应该在的位置的父结点\n    Node * subtreeSearch(Node * node, int v) {\n        if (node->val < v && node->right != nullptr) {\n            return subtreeSearch(node->right, v);\n        } else if (node->val > v && node->left != nullptr) {\n            return subtreeSearch(node->left, v);\n        } else {\n            return node;\n        }\n    }\n\n    // 重新计算node结点的高度和元素数\n    void recompute(Node * node) {\n        node->height = 1 + max(getHeight(node->left), getHeight(node->right));\n        node->size = 1 + getSize(node->left) + getSize(node->right);\n    }\n\n    // 从node结点开始（含node结点）逐个向上重新平衡二叉树，并更新结点高度和元素数\n    void rebalance(Node * node) {\n        while (node != nullptr) {\n            int oldHeight = node->height, oldSize = node->size;\n            if (!isBalanced(node)) {\n                node = restructure(tallGrandchild(node));\n                recompute(node->left);\n                recompute(node->right);\n            }\n            recompute(node);\n            if (node->height == oldHeight && node->size == oldSize) {\n                node = nullptr; // 如果结点高度和元素数都没有变化则不需要再继续向上调整\n            } else {\n                node = node->parent;\n            }\n        }\n    }\n\n    // 判断node结点是否平衡\n    bool isBalanced(Node * node) {\n        return abs(getHeight(node->left) - getHeight(node->right)) <= 1;\n    }\n\n    // 获取node结点更高的子树\n    Node * tallChild(Node * node) {\n        if (getHeight(node->left) > getHeight(node->right)) {\n            return node->left;\n        } else {\n            return node->right;\n        }\n    }\n\n    // 获取node结点更高的子树中的更高的子树\n    Node * tallGrandchild(Node * node) {\n        Node * child = tallChild(node);\n        return tallChild(child);\n    }\n\n    // 重新连接父结点和子结点（子结点允许为空）\n    static void relink(Node * parent, Node * child, bool isLeft) {\n        if (isLeft) {\n            parent->left = child;\n        } else {\n            parent->right = child;\n        }\n        if (child != nullptr) {\n            child->parent = parent;\n        }\n    }\n\n    // 旋转操作\n    void rotate(Node * node) {\n        Node * parent = node->parent;\n        Node * grandparent = parent->parent;\n        if (grandparent == nullptr) {\n            root = node;\n            node->parent = nullptr;\n        } else {\n            relink(grandparent, node, parent == grandparent->left);\n        }\n\n        if (node == parent->left) {\n            relink(parent, node->right, true);\n            relink(node, parent, false);\n        } else {\n            relink(parent, node->left, false);\n            relink(node, parent, true);\n        }\n    }\n\n    // trinode操作\n    Node * restructure(Node * node) {\n        Node * parent = node->parent;\n        Node * grandparent = parent->parent;\n\n        if ((node == parent->right) == (parent == grandparent->right)) { // 处理需要一次旋转的情况\n            rotate(parent);\n            return parent;\n        } else { // 处理需要两次旋转的情况：第1次旋转后即成为需要一次旋转的情况\n            rotate(node);\n            rotate(node);\n            return node;\n        }\n    }\n\n    // 返回以node为根结点的子树的第1个元素\n    static Node * subtreeFirst(Node * node) {\n        while (node->left != nullptr) {\n            node = node->left;\n        }\n        return node;\n    }\n\n    // 返回以node为根结点的子树的最后1个元素\n    static Node * subtreeLast(Node * node) {\n        while (node->right != nullptr) {\n            node = node->right;\n        }\n        return node;\n    }\n\n    // 获取以node为根结点的子树的高度\n    static int getHeight(Node * node) {\n        return node != nullptr ? node->height : 0;\n    }\n\n    // 获取以node为根结点的子树的结点数\n    static int getSize(Node * node) {\n        return node != nullptr ? node->size : 0;\n    }\n};\n\nclass Solution {\npublic:\n    int kthSmallest(TreeNode * root, int k) {\n        // 中序遍历生成数值列表\n        vector<int> inorderList;\n        inorder(root, inorderList);\n        // 构造平衡二叉搜索树\n        AVL avl(inorderList);\n\n        // 模拟1000次插入和删除操作\n        vector<int> randomNums(1000);\n        std::random_device rd;\n        for (int i = 0; i < 1000; ++i) {\n            randomNums[i] = rd()%(10001);\n            avl.insert(randomNums[i]);\n        }\n        shuffle(randomNums); // 列表乱序\n        for (int i = 0; i < 1000; ++i) {\n            avl.Delete(randomNums[i]);\n        }\n\n        return avl.kthSmallest(k);\n    }\n\nprivate:\n    void inorder(TreeNode * node, vector<int> & inorderList) {\n        if (node->left != nullptr) {\n            inorder(node->left, inorderList);\n        }\n        inorderList.push_back(node->val);\n        if (node->right != nullptr) {\n            inorder(node->right, inorderList);\n        }\n    }\n\n    void shuffle(vector<int> & arr) {\n        std::random_device rd;\n        int length = arr.size();\n        for (int i = 0; i < length; i++) {\n            int randIndex = rd()%length;\n            swap(arr[i],arr[randIndex]);\n        }\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：预处理的时间复杂度为 $O(N)$，其中 $N$ 是树中结点的总数。插入、删除和搜索的时间复杂度均为 $O(\\log N)$。\n\n- 空间复杂度：$O(N)$，用于存储平衡二叉搜索树。"
}