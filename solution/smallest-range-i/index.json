{
	"titleSlug": "smallest-range-i",
	"slug": "zui-xiao-chai-zhi-i-by-leetcode-solution-7lcl",
	"url": "https://leetcode-cn.com/problems/smallest-range-i/solution/zui-xiao-chai-zhi-i-by-leetcode-solution-7lcl/",
	"content": "#### 方法一：数学\n\n**思路与算法**\n\n假设整数数组 $\\textit{nums}$ 的最小值为 $\\textit{minNum}$，最大值为 $\\textit{maxNum}$。\n\n+ 如果 $\\textit{maxNum} - \\textit{minNum} \\le 2k$，那么我们总可以将整数数组 $\\textit{nums}$ 的所有元素都改为同一个整数，因此更改后的整数数组 $\\textit{nums}$ 的最低分数为 $0$。\n\n    > 证明：因为 $\\textit{maxNum} - \\textit{minNum} \\le 2k$，所以存在整数 $x \\in [\\textit{minNum}, \\textit{maxNum}]$，使得 $x - \\textit{minNum} \\le k$ 且 $\\textit{maxNum} - x \\le k$。那么整数数组 $\\textit{nums}$ 的所有元素与整数 $x$ 的绝对差值都不超过 $k$，即所有元素都可以改为 $x$。\n\n+ 如果 $\\textit{maxNum} - \\textit{minNum} \\gt 2k$，那么更改后的整数数组 $\\textit{nums}$ 的最低分数为 $\\textit{maxNum} - \\textit{minNum} - 2k$。\n\n    > 证明：对于 $\\textit{minNum}$ 和 $\\textit{maxNum}$ 两个元素，我们将 $\\textit{minNum}$ 改为 $\\textit{minNum} + k$，$\\textit{maxNum}$ 改为 $\\textit{maxNum} - k$，此时两个元素的绝对差值最小。因此更改后的整数数组 $\\textit{nums}$ 的最低分数大于等于 $\\textit{maxNum} - \\textit{minNum} - 2k$。\n    > 对于整数数组 $\\textit{nums}$ 中的元素 $x$，如果 $x \\lt \\textit{minNum} + k$，那么 $x$ 可以更改为 $\\textit{minNum} + k$，如果 $x \\gt \\textit{maxNum} - k$，那么 $x$ 可以更改为 $\\textit{maxNum} - k$，因此整数数组 $\\textit{nums}$ 的所有元素都可以改为区间 $[\\textit{minNum} + k, \\textit{maxNum} - k]$ 的整数，所以更改后的整数数组 $\\textit{nums}$ 的最低分数小于等于 $\\textit{maxNum} - \\textit{minNum} - 2k$。\n    > 综上所述，更改后的整数数组 $\\textit{nums}$ 的最低分数为 $\\textit{maxNum} - \\textit{minNum} - 2k$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def smallestRangeI(self, nums: List[int], k: int) -> int:\n        return max(0, max(nums) - min(nums) - 2 * k)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int smallestRangeI(vector<int>& nums, int k) {\n        int minNum = *min_element(nums.begin(), nums.end());\n        int maxNum = *max_element(nums.begin(), nums.end());\n        return maxNum - minNum <= 2 * k ? 0 : maxNum - minNum - 2 * k;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int smallestRangeI(int[] nums, int k) {\n        int minNum = Arrays.stream(nums).min().getAsInt();\n        int maxNum = Arrays.stream(nums).max().getAsInt();\n        return maxNum - minNum <= 2 * k ? 0 : maxNum - minNum - 2 * k;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int SmallestRangeI(int[] nums, int k) {\n        int minNum = nums.Min();\n        int maxNum = nums.Max();\n        return maxNum - minNum <= 2 * k ? 0 : maxNum - minNum - 2 * k;\n    }\n}\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint smallestRangeI(int* nums, int numsSize, int k) {\n    int minNum = INT_MAX, maxNum = INT_MIN;\n    for (int i = 0; i < numsSize; i++) {\n        minNum = MIN(minNum, nums[i]);\n        maxNum = MAX(maxNum, nums[i]);\n    }\n    return maxNum - minNum <= 2 * k ? 0 : maxNum - minNum - 2 * k;\n}\n```\n\n```go [sol1-Golang]\nfunc smallestRangeI(nums []int, k int) int {\n    minNum, maxNum := nums[0], nums[0]\n    for _, num := range nums[1:] {\n        if num < minNum {\n            minNum = num\n        } else if num > maxNum {\n            maxNum = num\n        }\n    }\n    ans := maxNum - minNum - 2*k\n    if ans > 0 {\n        return ans\n    }\n    return 0\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar smallestRangeI = function(nums, k) {\n    const minNum = _.min(nums);\n    const maxNum = _.max(nums);\n    return maxNum - minNum <= 2 * k ? 0 : maxNum - minNum - 2 * k;\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是整数数组 $\\textit{nums}$ 的长度。需要 $O(n)$ 的时间遍历数组 $\\textit{nums}$ 得到最小值和最大值，然后需要 $O(1)$ 的时间计算最低分数。\n\n+ 空间复杂度：$O(1)$。"
}