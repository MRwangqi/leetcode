{
	"titleSlug": "smallest-value-of-the-rearranged-number",
	"slug": "zhong-pai-shu-zi-de-zui-xiao-zhi-by-leet-p06c",
	"url": "https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/solution/zhong-pai-shu-zi-de-zui-xiao-zhi-by-leet-p06c/",
	"content": "#### 方法一：排序\n\n**思路与算法**\n\n如果 $\\textit{num} = 0$，那么答案就是 $0$。\n\n如果 $\\textit{num}$ 是负数，那么最小化就是将它的相反数最大化，也就是将 $\\textit{num}$ 的数字部分按照降序排序，再组合成一个新的数即可。\n\n如果 $\\textit{num}$ 是正数，那么同样地，将 $\\textit{num}$ 的数字部分按照升序排序，再组合成一个新的数即可。需要注意的是，再升序排序后，首位可能为 $0$，而题目规定重排数字不能有前导 $0$，因此我们需要找到一个除了 $0$ 以外的最小数字，将其和 $0$ 进行交换。由于 $\\textit{num}$ 本身不为 $0$，因此这样的数字是一定能找到的。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    long long smallestNumber(long long num) {\n        if (num == 0) {\n            return 0;\n        }\n        \n        bool negative = (num < 0);\n        num = abs(num);\n        vector<int> digits;\n\n        long long dummy = num;\n        while (dummy) {\n            digits.push_back(dummy % 10);\n            dummy /= 10;\n        }\n        sort(digits.begin(), digits.end());\n        if (negative) {\n            reverse(digits.begin(), digits.end());\n        }\n        else {\n            if (digits[0] == 0) {\n                for (int i = 1;; ++i) {\n                    if (digits[i] != 0) {\n                        swap(digits[0], digits[i]);\n                        break;\n                    }\n                }\n            }\n        }\n\n        long long ans = 0;\n        for (int digit: digits) {\n            ans = ans * 10 + digit;\n        }\n        return negative ? -ans : ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def smallestNumber(self, num: int) -> int:\n        if num == 0:\n            return 0\n        \n        negative = (num) < 0\n        num = abs(num)\n        digits = sorted(int(digit) for digit in str(num))\n        \n        if negative:\n            digits = digits[::-1]\n        else:\n            if digits[0] == 0:\n                i = 1\n                while digits[i] == 0:\n                    i += 1\n                digits[0], digits[i] = digits[i], digits[0]\n\n        ans = int(\"\".join(str(digit) for digit in digits))\n        return -ans if negative else ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log \\textit{num} \\log\\log \\textit{num})$，即为排序需要的时间。$\\textit{num}$ 包含的数字个数为 $O(\\log \\textit{num})$。\n\n- 空间复杂度：$O(\\log \\textit{num})$，即为存储 $\\textit{num}$ 包含的数字需要使用的空间。"
}