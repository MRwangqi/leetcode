{
	"titleSlug": "asteroid-collision",
	"slug": "xing-xing-peng-zhuang-by-leetcode-soluti-u3k0",
	"url": "https://leetcode-cn.com/problems/asteroid-collision/solution/xing-xing-peng-zhuang-by-leetcode-soluti-u3k0/",
	"content": "#### 方法一：栈模拟\n\n使用栈 $\\textit{st}$ 模拟行星碰撞，从左往右遍历行星数组 $\\textit{asteroids}$，当我们遍历到行星 $\\textit{aster}$ 时，使用变量 $\\textit{alive}$ 记录行星 $\\textit{aster}$ 是否还存在（即未爆炸）。\n\n当行星 $\\textit{aster}$ 存在且 $\\textit{aster} < 0$，栈顶元素非空且大于 $0$ 时，说明两个行星相互向对方移动：如果栈顶元素大于等于 $-\\textit{aster}$，则行星 $\\textit{aster}$ 发生爆炸，将 $\\textit{alive}$ 置为 $\\text{false}$；如果栈顶元素小于等于 $-\\textit{aster}$，则栈顶元素表示的行星发生爆炸，执行出栈操作。重复以上判断直到不满足条件，如果最后 $\\textit{alive}$ 为真，说明行星 $\\textit{aster}$ 不会爆炸，则将 $\\textit{aster}$ 入栈。\n\n> 为了代码简洁性，我们使用变长数组模拟栈。\n\n```Python [sol1-Python3]\nclass Solution:\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n        st = []\n        for aster in asteroids:\n            alive = True\n            while alive and aster < 0 and st and st[-1] > 0:\n                alive = st[-1] < -aster\n                if st[-1] <= -aster:\n                    st.pop()\n            if alive:\n                st.append(aster)\n        return st\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> asteroidCollision(vector<int>& asteroids) {\n        vector<int> st;\n        for (auto aster : asteroids) {\n            bool alive = true;\n            while (alive && aster < 0 && !st.empty() && st.back() > 0) {\n                alive = st.back() < -aster; // aster 是否存在\n                if (st.back() <= -aster) {  // 栈顶行星爆炸\n                    st.pop_back();\n                }\n            }\n            if (alive) {\n                st.push_back(aster);\n            }\n        }\n        return st;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] asteroidCollision(int[] asteroids) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int aster : asteroids) {\n            boolean alive = true;\n            while (alive && aster < 0 && !stack.isEmpty() && stack.peek() > 0) {\n                alive = stack.peek() < -aster; // aster 是否存在\n                if (stack.peek() <= -aster) {  // 栈顶行星爆炸\n                    stack.pop();\n                }\n            }\n            if (alive) {\n                stack.push(aster);\n            }\n        }\n        int size = stack.size();\n        int[] ans = new int[size];\n        for (int i = size - 1; i >= 0; i--) {\n            ans[i] = stack.pop();\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] AsteroidCollision(int[] asteroids) {\n        Stack<int> stack = new Stack<int>();\n        foreach (int aster in asteroids) {\n            bool alive = true;\n            while (alive && aster < 0 && stack.Count > 0 && stack.Peek() > 0) {\n                alive = stack.Peek() < -aster; // aster 是否存在\n                if (stack.Peek() <= -aster) {  // 栈顶行星爆炸\n                    stack.Pop();\n                }\n            }\n            if (alive) {\n                stack.Push(aster);\n            }\n        }\n        int count = stack.Count;\n        int[] ans = new int[count];\n        for (int i = count - 1; i >= 0; i--) {\n            ans[i] = stack.Pop();\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\nint* asteroidCollision(int* asteroids, int asteroidsSize, int* returnSize){\n    int *st = (int *)malloc(sizeof(int) * asteroidsSize);\n    int pos = 0;\n    for (int i = 0; i < asteroidsSize; i++) {\n        bool alive = true;\n        while (alive && asteroids[i] < 0 && pos > 0 && st[pos - 1] > 0) {\n            alive = st[pos - 1] < -asteroids[i]; // aster 是否存在\n            if (st[pos - 1] <= -asteroids[i]) {  // 栈顶行星爆炸\n                pos--;\n            }\n        }\n        if (alive) {\n            st[pos++] = asteroids[i];\n        }\n    }\n    *returnSize = pos;\n    return st;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar asteroidCollision = function(asteroids) {\n    const stack = [];\n    for (const aster of asteroids) {\n        let alive = true;\n        while (alive && aster < 0 && stack.length > 0 && stack[stack.length - 1] > 0) {\n            alive = stack[stack.length - 1] < -aster; // aster 是否存在\n            if (stack[stack.length - 1] <= -aster) {  // 栈顶行星爆炸\n                stack.pop();\n            }\n        }\n        if (alive) {\n            stack.push(aster);\n        }\n    }\n    const size = stack.length;\n    const ans = new Array(size).fill(0);\n    for (let i = size - 1; i >= 0; i--) {\n        ans[i] = stack.pop();\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc asteroidCollision(asteroids []int) (st []int) {\n    for _, aster := range asteroids {\n        alive := true\n        for alive && aster < 0 && len(st) > 0 && st[len(st)-1] > 0 {\n            alive = st[len(st)-1] < -aster // aster 是否存在\n            if st[len(st)-1] <= -aster {   // 栈顶行星爆炸\n                st = st[:len(st)-1]\n            }\n        }\n        if alive {\n            st = append(st, aster)\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{asteroids}$ 的大小。出入栈次数均不超过 $n$ 次。\n\n+ 空间复杂度：$O(1)$。返回值不计入空间复杂度。"
}