{
	"titleSlug": "find-the-closest-palindrome",
	"slug": "xun-zhao-zui-jin-de-hui-wen-shu-by-leetc-biyt",
	"url": "https://leetcode-cn.com/problems/find-the-closest-palindrome/solution/xun-zhao-zui-jin-de-hui-wen-shu-by-leetc-biyt/",
	"content": "#### 方法一：模拟\n\n**思路和算法**\n\n构造回文整数有一个直观的方法：用原数的较高位的数字替换其对应的较低位。例如，对于数 $12345$，我们可以用 $1$ 替换 $5$，用 $2$ 替换 $4$，这样原数即变为回文整数 $12321$。\n\n在这种方案中，我们修改的都是较低位的数字，因此构造出的新的整数与原数较为接近。大部分情况下，这种方案是最优解，但还有部分情况我们没有考虑到。\n\n1. 构造的回文整数大于原数时，我们可以减小该回文整数的中间部分来缩小回文整数和原数的差距。例如，对于数 $99321$，我们将构造出回文整数 $99399$，实际上 $99299$ 更接近原数。\n   - 当我们减小构造的回文整数时，可能导致回文整数的位数变化。例如，对于数 $100$，我们将构造出回文整数 $101$，减小其中间部分将导致位数减少。得到的回文整数形如 $999\\dots 999$（$10^{\\textit{len}}-1$）。\n\n2. 构造的回文整数小于原数时，我们可以增大该回文整数的中间部分来缩小回文整数和原数的差距。例如，对于数 $12399$，我们将构造出回文整数 $12321$，实际上 $12421$ 更接近原数。\n   - 当我们增大构造的回文整数时，可能导致回文整数的位数变化。例如，对于数 $998$，我们将构造出回文整数 $999$，增大其中间部分将导致位数增加。得到的回文整数形如 $100\\dots 001$（$10^{\\textit{len}}+1$）。\n\n3. 构造的回文整数等于原数时，由于题目约定，我们需要排除该回文整数，在其他的可能情况中寻找最近的回文整数。\n\n考虑到以上所有的可能，我们可以给出最终的方案：分别计算出以下每一种可能的方案对应的回文整数，在其中找到与原数最近且不等于原数的数即为答案。\n\n1. 用原数的前半部分替换后半部分得到的回文整数。\n\n2. 用原数的前半部分加一后的结果替换后半部分得到的回文整数。\n\n3. 用原数的前半部分减一后的结果替换后半部分得到的回文整数。\n   \n4. 为防止位数变化导致构造的回文整数错误，因此直接构造 $999\\dots 999$ 和 $100\\dots 001$ 作为备选答案。\n\n**代码**\n\n```C++ [sol1-C++]\nusing ULL = unsigned long long;\n\nclass Solution {\npublic:\n    vector<ULL> getCandidates(const string& n) {\n        int len = n.length();\n        vector<ULL> candidates = {\n            (ULL)pow(10, len - 1) - 1,\n            (ULL)pow(10, len) + 1,\n        };\n        ULL selfPrefix = stoull(n.substr(0, (len + 1) / 2));\n        for (int i : {selfPrefix - 1, selfPrefix, selfPrefix + 1}) {\n            string prefix = to_string(i);\n            string candidate = prefix + string(prefix.rbegin() + (len & 1), prefix.rend());\n            candidates.push_back(stoull(candidate));\n        }\n        return candidates;\n    }\n\n    string nearestPalindromic(string n) {\n        ULL selfNumber = stoull(n), ans = -1;\n        const vector<ULL>& candidates = getCandidates(n);\n        for (auto& candidate : candidates) {\n            if (candidate != selfNumber) {\n                if (ans == -1 ||\n                    llabs(candidate - selfNumber) < llabs(ans - selfNumber) ||\n                    llabs(candidate - selfNumber) == llabs(ans - selfNumber) && candidate < ans) {\n                    ans = candidate;\n                }\n            }\n        }\n        return to_string(ans);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String nearestPalindromic(String n) {\n        long selfNumber = Long.parseLong(n), ans = -1;\n        List<Long> candidates = getCandidates(n);\n        for (long candidate : candidates) {\n            if (candidate != selfNumber) {\n                if (ans == -1 ||\n                    Math.abs(candidate - selfNumber) < Math.abs(ans - selfNumber) ||\n                    Math.abs(candidate - selfNumber) == Math.abs(ans - selfNumber) && candidate < ans) {\n                    ans = candidate;\n                }\n            }\n        }\n        return Long.toString(ans);\n    }\n\n    public List<Long> getCandidates(String n) {\n        int len = n.length();\n        List<Long> candidates = new ArrayList<Long>() {{\n            add((long) Math.pow(10, len - 1) - 1);\n            add((long) Math.pow(10, len) + 1);\n        }};\n        long selfPrefix = Long.parseLong(n.substring(0, (len + 1) / 2));\n        for (long i = selfPrefix - 1; i <= selfPrefix + 1; i++) {\n            StringBuffer sb = new StringBuffer();\n            String prefix = String.valueOf(i);\n            sb.append(prefix);\n            StringBuffer suffix = new StringBuffer(prefix).reverse();\n            sb.append(suffix.substring(len & 1));\n            String candidate = sb.toString();\n            try {\n                candidates.add(Long.parseLong(candidate));\n            } catch (NumberFormatException ex) {\n                continue;\n            }\n        }\n        return candidates;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string NearestPalindromic(string n) {\n        long selfNumber = long.Parse(n), ans = -1;\n        IList<long> candidates = GetCandidates(n);\n        foreach (long candidate in candidates) {\n            if (candidate != selfNumber) {\n                if (ans == -1 ||\n                    Math.Abs(candidate - selfNumber) < Math.Abs(ans - selfNumber) ||\n                    Math.Abs(candidate - selfNumber) == Math.Abs(ans - selfNumber) && candidate < ans) {\n                    ans = candidate;\n                }\n            }\n        }\n        return ans.ToString();\n    }\n\n    public IList<long> GetCandidates(String n) {\n        int len = n.Length;\n        IList<long> candidates = new List<long>();\n        candidates.Add((long) Math.Pow(10, len - 1) - 1);\n        candidates.Add((long) Math.Pow(10, len) + 1);\n        long selfPrefix = long.Parse(n.Substring(0, (len + 1) / 2));\n        for (long i = selfPrefix - 1; i <= selfPrefix + 1; i++) {\n            StringBuilder sb = new StringBuilder();\n            string prefix = i.ToString();\n            sb.Append(prefix);\n            StringBuilder suffix = new StringBuilder();\n            for (int j = prefix.Length - 1 - (len & 1); j >= 0; j--) {\n                suffix.Append(prefix[j]);\n            }\n            sb.Append(suffix);\n            string candidate = sb.ToString();\n            try {\n                candidates.Add(long.Parse(candidate));\n            } catch (OverflowException ex) {\n                continue;\n            }\n        }\n        return candidates;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX_STR_LEN 32\ntypedef unsigned long long ULL;\n\nvoid reverseStr(char * str) {\n    int n = strlen(str);\n    for (int l = 0, r = n-1; l < r; l++, r--) {\n        char c = str[l];\n        str[l] = str[r];\n        str[r] = c;\n    }\n}\n\nULL * getCandidates(const char * n, int * returnSize) {\n    int len = strlen(n);\n    int pos = 0;\n    ULL * candidates = (ULL *)malloc(sizeof(ULL) * 5);\n    candidates[pos++] = (ULL)pow(10, len) + 1;\n    candidates[pos++] = (ULL)pow(10, len - 1) - 1;\n    char str[MAX_STR_LEN], prefix[MAX_STR_LEN];\n    char candidate[MAX_STR_LEN];\n    snprintf(str, (len + 1) / 2 + 1, \"%s\", n);\n    ULL selfPrefix = atol(str);    \n    for (ULL i = selfPrefix - 1; i <= selfPrefix + 1; i++) {\n        sprintf(prefix, \"%ld\", i);\n        sprintf(candidate, \"%s\", prefix);\n        reverseStr(prefix);\n        sprintf(candidate + strlen(candidate), \"%s\", prefix + (len & 1));\n        candidates[pos++] = atoll(candidate);\n    }\n    *returnSize = pos;\n    return candidates;\n}\n\nchar * nearestPalindromic(char * n){\n    ULL selfNumber = atoll(n), ans = -1;\n    int candidatesSize = 0;\n    const ULL * candidates = getCandidates(n, &candidatesSize);\n    for (int i = 0; i < candidatesSize; i++) {\n        if (candidates[i] != selfNumber) {\n            if (ans == -1 ||\n                labs(candidates[i] - selfNumber) < labs(ans - selfNumber) ||\n                labs(candidates[i] - selfNumber) == labs(ans - selfNumber) && candidates[i] < ans) {\n                ans = candidates[i];\n            }\n        }\n    }\n    char * str = (char *)malloc(sizeof(char) * MAX_STR_LEN);\n    sprintf(str, \"%ld\", ans);\n    free(candidates);\n    return str;\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        m = len(n)\n        candidates = [10 ** (m - 1) - 1, 10 ** m + 1]\n        selfPrefix = int(n[:(m + 1) // 2])\n        for x in range(selfPrefix - 1, selfPrefix + 2):\n            y = x if m % 2 == 0 else x // 10\n            while y:\n                x = x * 10 + y % 10\n                y //= 10\n            candidates.append(x)\n\n        ans = -1\n        selfNumber = int(n)\n        for candidate in candidates:\n            if candidate != selfNumber:\n                if ans == -1 or \\\n                        abs(candidate - selfNumber) < abs(ans - selfNumber) or \\\n                        abs(candidate - selfNumber) == abs(ans - selfNumber) and candidate < ans:\n                    ans = candidate\n        return str(ans)\n```\n\n```go [sol1-Golang]\nfunc nearestPalindromic(n string) string {\n    m := len(n)\n    candidates := []int{int(math.Pow10(m-1)) - 1, int(math.Pow10(m)) + 1}\n    selfPrefix, _ := strconv.Atoi(n[:(m+1)/2])\n    for _, x := range []int{selfPrefix - 1, selfPrefix, selfPrefix + 1} {\n        y := x\n        if m&1 == 1 {\n            y /= 10\n        }\n        for ; y > 0; y /= 10 {\n            x = x*10 + y%10\n        }\n        candidates = append(candidates, x)\n    }\n\n    ans := -1\n    selfNumber, _ := strconv.Atoi(n)\n    for _, candidate := range candidates {\n        if candidate != selfNumber {\n            if ans == -1 ||\n                abs(candidate-selfNumber) < abs(ans-selfNumber) ||\n                abs(candidate-selfNumber) == abs(ans-selfNumber) && candidate < ans {\n                ans = candidate\n            }\n        }\n    }\n    return strconv.Itoa(ans)\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$，其中 $n$ 为给定整数的大小。我们需要 $O(\\log n)$ 的时间构造所有的可能情况。\n\n- 空间复杂度：$O(\\log n)$，其中 $n$ 为给定整数的大小。我们需要 $O(\\log n)$ 的空间保存所有的可能情况。"
}