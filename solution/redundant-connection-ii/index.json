{
	"titleSlug": "redundant-connection-ii",
	"slug": "rong-yu-lian-jie-ii-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/redundant-connection-ii/solution/rong-yu-lian-jie-ii-by-leetcode-solution/",
	"content": "#### 方法一：并查集\n\n**思路与算法**\n\n在一棵树中，边的数量比节点的数量少 $1$。如果一棵树有 $n$ 个节点，则这棵树有 $n-1$ 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 $n$。\n\n树中的每个节点都有一个父节点，除了根节点没有父节点。在多了一条附加的边之后，可能有以下两种情况：\n\n- 附加的边指向根节点，则包括根节点在内的每个节点都有一个父节点，此时图中一定有环路；\n\n- 附加的边指向非根节点，则恰好有一个节点（即被附加的边指向的节点）有两个父节点，此时图中可能有环路也可能没有环路。\n\n要找到附加的边，需要遍历图中的所有的边构建出一棵树，在构建树的过程中寻找导致冲突（即导致一个节点有两个父节点）的边以及导致环路出现的边。\n\n具体做法是，使用数组 $\\textit{parent}$ 记录每个节点的父节点，初始时对于任何 $1 \\le i \\le n$ 都有 $\\textit{parent}[i]=i$，另外创建并查集，初始时并查集中的每个节点都是一个连通分支，该连通分支的根节点就是该节点本身。遍历每条边的过程中，维护导致冲突的边和导致环路出现的边，由于只有一条附加的边，因此最多有一条导致冲突的边和一条导致环路出现的边。\n\n当访问到边 $[u,v]$ 时，进行如下操作：\n\n- 如果此时已经有 $\\textit{parent}[v] \\ne v$，说明 $v$ 有两个父节点，将当前的边 $[u,v]$ 记为导致冲突的边；\n\n- 否则，令 $\\textit{parent}[v] = u$，然后在并查集中分别找到 $u$ 和 $v$ 的祖先（即各自的连通分支中的根节点），如果祖先相同，说明这条边导致环路出现，将当前的边 $[u,v]$ 记为导致环路出现的边，如果祖先不同，则在并查集中将 $u$ 和 $v$ 进行合并。\n\n根据上述操作，同一条边不可能同时被记为导致冲突的边和导致环路出现的边。如果访问到的边确实同时导致冲突和环路出现，则这条边被记为导致冲突的边。\n\n在遍历图中的所有边之后，根据是否存在导致冲突的边和导致环路出现的边，得到附加的边。\n\n如果没有导致冲突的边，说明附加的边一定导致环路出现，而且是在环路中的最后一条被访问到的边，因此附加的边即为导致环路出现的边。\n\n如果有导致冲突的边，记这条边为 $[u,v]$，则有两条边指向 $v$，另一条边为 $[\\textit{parent}[v],v]$，需要通过判断是否有导致环路的边决定哪条边是附加的边。\n\n- 如果有导致环路的边，则附加的边不可能是 $[u,v]$（因为 $[u,v]$ 已经被记为导致冲突的边，不可能被记为导致环路出现的边），因此附加的边是 $[\\textit{parent}[v],v]$。\n\n- 如果没有导致环路的边，则附加的边是后被访问到的指向 $v$ 的边，因此附加的边是 $[u,v]$。\n\n**代码**\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] findRedundantDirectedConnection(int[][] edges) {\n        int n = edges.length;\n        UnionFind uf = new UnionFind(n + 1);\n        int[] parent = new int[n + 1];\n        for (int i = 1; i <= n; ++i) {\n            parent[i] = i;\n        }\n        int conflict = -1;\n        int cycle = -1;\n        for (int i = 0; i < n; ++i) {\n            int[] edge = edges[i];\n            int node1 = edge[0], node2 = edge[1];\n            if (parent[node2] != node2) {\n                conflict = i;\n            } else {\n                parent[node2] = node1;\n                if (uf.find(node1) == uf.find(node2)) {\n                    cycle = i;\n                } else {\n                    uf.union(node1, node2);\n                }\n            }\n        }\n        if (conflict < 0) {\n            int[] redundant = {edges[cycle][0], edges[cycle][1]};\n            return redundant;\n        } else {\n            int[] conflictEdge = edges[conflict];\n            if (cycle >= 0) {\n                int[] redundant = {parent[conflictEdge[1]], conflictEdge[1]};\n                return redundant;\n            } else {\n                int[] redundant = {conflictEdge[0], conflictEdge[1]};\n                return redundant;\n            }\n        }\n    }\n}\n\nclass UnionFind {\n    int[] ancestor;\n\n    public UnionFind(int n) {\n        ancestor = new int[n];\n        for (int i = 0; i < n; ++i) {\n            ancestor[i] = i;\n        }\n    }\n\n    public void union(int index1, int index2) {\n        ancestor[find(index1)] = find(index2);\n    }\n\n    public int find(int index) {\n        if (ancestor[index] != index) {\n            ancestor[index] = find(ancestor[index]);\n        }\n        return ancestor[index];\n    }\n}\n```\n\n```Golang [sol1-Golang]\nfunc findRedundantDirectedConnection(edges [][]int) (redundantEdge []int) {\n    n := len(edges)\n    uf := newUnionFind(n + 1)\n    parent := make([]int, n+1) // parent[i] 表示 i 的父节点\n    for i := range parent {\n        parent[i] = i\n    }\n\n    var conflictEdge, cycleEdge []int\n    for _, edge := range edges {\n        from, to := edge[0], edge[1]\n        if parent[to] != to { // to 有两个父节点\n            conflictEdge = edge\n        } else {\n            parent[to] = from\n            if uf.find(from) == uf.find(to) { // from 和 to 已连接\n                cycleEdge = edge\n            } else {\n                uf.union(from, to)\n            }\n        }\n    }\n\n    // 若不存在一个节点有两个父节点的情况，则附加的边一定导致环路出现\n    if conflictEdge == nil {\n        return cycleEdge\n    }\n    // conflictEdge[1] 有两个父节点，其中之一与其构成附加的边\n    // 由于我们是按照 edges 的顺序连接的，若在访问到 conflictEdge 之前已经形成了环路，则附加的边在环上\n    // 否则附加的边就是 conflictEdge\n    if cycleEdge != nil {\n        return []int{parent[conflictEdge[1]], conflictEdge[1]}\n    }\n    return conflictEdge\n}\n\ntype unionFind struct {\n    ancestor []int\n}\n\nfunc newUnionFind(n int) unionFind {\n    ancestor := make([]int, n)\n    for i := 0; i < n; i++ {\n        ancestor[i] = i\n    }\n    return unionFind{ancestor}\n}\n\nfunc (uf unionFind) find(x int) int {\n    if uf.ancestor[x] != x {\n        uf.ancestor[x] = uf.find(uf.ancestor[x])\n    }\n    return uf.ancestor[x]\n}\n\nfunc (uf unionFind) union(from, to int) {\n    uf.ancestor[uf.find(from)] = uf.find(to)\n}\n```\n\n```cpp [sol1-C++]\nstruct UnionFind {\n    vector <int> ancestor;\n\n    UnionFind(int n) {\n        ancestor.resize(n);\n        for (int i = 0; i < n; ++i) {\n            ancestor[i] = i;\n        }\n    }\n\n    int find(int index) {\n        return index == ancestor[index] ? index : ancestor[index] = find(ancestor[index]);\n    }\n\n    void merge(int u, int v) {\n        ancestor[find(u)] = find(v);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n        int n = edges.size();\n        UnionFind uf = UnionFind(n + 1);\n        auto parent = vector<int>(n + 1);\n        for (int i = 1; i <= n; ++i) {\n            parent[i] = i;\n        }\n        int conflict = -1;\n        int cycle = -1;\n        for (int i = 0; i < n; ++i) {\n            auto edge = edges[i];\n            int node1 = edge[0], node2 = edge[1];\n            if (parent[node2] != node2) {\n                conflict = i;\n            } else {\n                parent[node2] = node1;\n                if (uf.find(node1) == uf.find(node2)) {\n                    cycle = i;\n                } else {\n                    uf.merge(node1, node2);\n                }\n            }\n        }\n        if (conflict < 0) {\n            auto redundant = vector<int> {edges[cycle][0], edges[cycle][1]};\n            return redundant;\n        } else {\n            auto conflictEdge = edges[conflict];\n            if (cycle >= 0) {\n                auto redundant = vector<int> {parent[conflictEdge[1]], conflictEdge[1]};\n                return redundant;\n            } else {\n                auto redundant = vector<int> {conflictEdge[0], conflictEdge[1]};\n                return redundant;\n            }\n        }\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass UnionFind:\n    def __init__(self, n):\n        self.ancestor = list(range(n))\n    \n    def union(self, index1: int, index2: int):\n        self.ancestor[self.find(index1)] = self.find(index2)\n    \n    def find(self, index: int) -> int:\n        if self.ancestor[index] != index:\n            self.ancestor[index] = self.find(self.ancestor[index])\n        return self.ancestor[index]\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        uf = UnionFind(n + 1)\n        parent = list(range(n + 1))\n        conflict = -1\n        cycle = -1\n        for i, (node1, node2) in enumerate(edges):\n            if parent[node2] != node2:\n                conflict = i\n            else:\n                parent[node2] = node1\n                if uf.find(node1) == uf.find(node2):\n                    cycle = i\n                else:\n                    uf.union(node1, node2)\n\n        if conflict < 0:\n            return [edges[cycle][0], edges[cycle][1]]\n        else:\n            conflictEdge = edges[conflict]\n            if cycle >= 0:\n                return [parent[conflictEdge[1]], conflictEdge[1]]\n            else:\n                return [conflictEdge[0], conflictEdge[1]]\n```\n\n```C [sol1-C]\nint* ancestor;\n\nint find(int index) {\n    return index == ancestor[index] ? index : (ancestor[index] = find(ancestor[index]));\n}\n\nvoid merge(int u, int v) {\n    ancestor[find(u)] = find(v);\n}\n\nint* findRedundantDirectedConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize) {\n    int n = edgesSize;\n    ancestor = malloc(sizeof(int) * (n + 1));\n    for (int i = 1; i <= n; ++i) {\n        ancestor[i] = i;\n    }\n    int parent[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n    int conflict = -1;\n    int cycle = -1;\n    for (int i = 0; i < n; ++i) {\n        int node1 = edges[i][0], node2 = edges[i][1];\n        if (parent[node2] != node2) {\n            conflict = i;\n        } else {\n            parent[node2] = node1;\n            if (find(node1) == find(node2)) {\n                cycle = i;\n            } else {\n                merge(node1, node2);\n            }\n        }\n    }\n    int* redundant = malloc(sizeof(int) * 2);\n    *returnSize = 2;\n    if (conflict < 0) {\n        redundant[0] = edges[cycle][0], redundant[1] = edges[cycle][1];\n        return redundant;\n    } else {\n        int* conflictEdge = edges[conflict];\n        if (cycle >= 0) {\n            redundant[0] = parent[conflictEdge[1]], redundant[1] = conflictEdge[1];\n            return redundant;\n        } else {\n            redundant[0] = conflictEdge[0], redundant[1] = conflictEdge[1];\n            return redundant;\n        }\n    }\n    return redundant;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是图中的节点个数。需要遍历图中的 $n$ 条边，对于每条边，需要对两个节点查找祖先，如果两个节点的祖先不同则需要进行合并，需要进行 $2$ 次查找和最多 $1$ 次合并。一共需要进行 $2n$ 次查找和最多 $n$ 次合并，因此总时间复杂度是 $O(2n \\log n)=O(n \\log n)$。这里的并查集使用了路径压缩，但是没有使用按秩合并，最坏情况下的时间复杂度是 $O(n \\log n)$，平均情况下的时间复杂度依然是 $O(n \\alpha (n))$，其中 $\\alpha$ 为阿克曼函数的反函数，$\\alpha (n)$ 可以认为是一个很小的常数。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是图中的节点个数。使用数组 $\\textit{parent}$ 记录每个节点的父节点，并查集使用数组记录每个节点的祖先。"
}