{
	"titleSlug": "find-missing-observations",
	"slug": "zhao-chu-que-shi-de-guan-ce-shu-ju-by-le-0z7j",
	"url": "https://leetcode-cn.com/problems/find-missing-observations/solution/zhao-chu-que-shi-de-guan-ce-shu-ju-by-le-0z7j/",
	"content": "#### 方法一：模拟构造\n\n根据题目描述，数组 $\\textit{rolls}$ 的长度为 $m$，记录了 $m$ 个观测数据，还有 $n$ 个观测数据缺失，共有 $n + m$ 个观测数据。由于所有观测数据的平均值为 $\\textit{mean}$，因此所有观测数据之和为 $\\textit{mean} \\times (n + m)$。\n\n根据所有观测数据之和与数组 $\\textit{rolls}$ 中的 $m$ 个观测数据，可知缺失的 $n$ 个观测数据之和。将缺失的 $n$ 个观测数据之和记为 $\\textit{missingSum}$。\n\n由于每次观测数据的范围是 $1$ 到 $6$，因此如果存在符合要求的答案，则一定有 $n \\le \\textit{missingSum} \\le 6 \\times n$。如果 $\\textit{missingSum}$ 不在上述范围内，则不存在符合要求的答案，返回空数组。\n\n当 $\\textit{missingSum}$ 满足 $n \\le \\textit{missingSum} \\le 6 \\times n$ 时，一定存在一种符合要求的答案，由 $n$ 个在 $[1, 6]$ 范围内的整数组成且这 $n$ 个整数之和为 $\\textit{missingSum}$。记 $\\textit{quotient} = \\Big\\lfloor \\dfrac{\\textit{missingSum}}{n} \\Big\\rfloor$，$\\textit{remainder} = \\textit{missingSum} \\bmod n$，则可以构造一种符合要求的答案：在缺失的 $n$ 个观测数据中，有 $\\textit{remainder}$ 个观测数据是 $\\textit{quotient} + 1$，其余观测数据都是 $\\textit{quotient}$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\n        missingSum = mean * (n + len(rolls)) - sum(rolls)\n        if not n <= missingSum <= n * 6:\n            return []\n        quotient, remainder = divmod(missingSum, n)\n        return [quotient + 1] * remainder + [quotient] * (n - remainder)\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] missingRolls(int[] rolls, int mean, int n) {\n        int m = rolls.length;\n        int sum = mean * (n + m);\n        int missingSum = sum;\n        for (int roll : rolls) {\n            missingSum -= roll;\n        }\n        if (missingSum < n || missingSum > 6 * n) {\n            return new int[0];\n        }\n        int quotient = missingSum / n, remainder = missingSum % n;\n        int[] missing = new int[n];\n        for (int i = 0; i < n; i++) {\n            missing[i] = quotient + (i < remainder ? 1 : 0);\n        }\n        return missing;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] MissingRolls(int[] rolls, int mean, int n) {\n        int m = rolls.Length;\n        int sum = mean * (n + m);\n        int missingSum = sum;\n        foreach (int roll in rolls) {\n            missingSum -= roll;\n        }\n        if (missingSum < n || missingSum > 6 * n) {\n            return new int[0];\n        }\n        int quotient = missingSum / n, remainder = missingSum % n;\n        int[] missing = new int[n];\n        for (int i = 0; i < n; i++) {\n            missing[i] = quotient + (i < remainder ? 1 : 0);\n        }\n        return missing;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\n        int m = rolls.size();\n        int sum = mean * (n + m);\n        int missingSum = sum;\n        for (int & roll : rolls) {\n            missingSum -= roll;\n        }\n        if (missingSum < n || missingSum > 6 * n) {\n            return {};\n        }\n        int quotient = missingSum / n, remainder = missingSum % n;\n        vector<int> missing(n);\n        for (int i = 0; i < n; i++) {\n            missing[i] = quotient + (i < remainder ? 1 : 0);\n        }\n        return missing;\n    }\n};\n```\n\n```C [sol1-C]\nint* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\n    int m = rollsSize;\n    int sum = mean * (n + m);\n    int missingSum = sum;\n    for (int i = 0; i < m; i++) {\n        missingSum -= rolls[i];\n    }\n    if (missingSum < n || missingSum > 6 * n) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int quotient = missingSum / n, remainder = missingSum % n;\n    int * missing = (int *)malloc(sizeof(int) * n);\n    for (int i = 0; i < n; i++) {\n        missing[i] = quotient + (i < remainder ? 1 : 0);\n    }\n    *returnSize = n;\n    return missing;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar missingRolls = function(rolls, mean, n) {\n    const m = rolls.length;\n    const sum = mean * (n + m);\n    let missingSum = sum;\n    for (const roll of rolls) {\n        missingSum -= roll;\n    }\n    if (missingSum < n || missingSum > 6 * n) {\n        return [];\n    }\n    const quotient = Math.floor(missingSum / n), remainder = missingSum % n;\n    const missing = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        missing[i] = quotient + (i < remainder ? 1 : 0);\n    }\n    return missing;\n};\n```\n\n```go [sol1-Golang]\nfunc missingRolls(rolls []int, mean, n int) []int {\n    missingSum := mean * (n + len(rolls))\n    for _, roll := range rolls {\n        missingSum -= roll\n    }\n    if missingSum < n || missingSum > n*6 {\n        return nil\n    }\n\n    quotient, remainder := missingSum/n, missingSum%n\n    ans := make([]int, n)\n    for i := range ans {\n        ans[i] = quotient\n        if i < remainder {\n            ans[i]++\n        }\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + m)$，其中 $n$ 是缺失的观测数据个数，$m$ 是数组 $\\textit{rolls}$ 的长度，即已知的观测数据个数。需要 $O(m)$ 的时间计算缺失的观测数据之和，需要 $O(n)$ 的时间构造答案。\n\n- 空间复杂度：$O(1)$。除了返回值以外，使用的额外空间为 $O(1)$。"
}