{
	"titleSlug": "remove-outermost-parentheses",
	"slug": "shan-chu-zui-wai-ceng-de-gua-hao-by-leet-sux0",
	"url": "https://leetcode-cn.com/problems/remove-outermost-parentheses/solution/shan-chu-zui-wai-ceng-de-gua-hao-by-leet-sux0/",
	"content": "#### 方法一：栈\n\n**思路**\n\n遍历 $s$，并用一个栈来表示括号的深度。遇到 $\\text{`(’}$ 则将字符入栈，遇到 $\\text{`)’}$ 则将栈顶字符出栈。栈从空到下一次空的过程，则是扫描了一个原语的过程。一个原语中，首字符和尾字符应该舍去，其他字符需放入结果字符串中。因此，在遇到 $\\text{`(’}$ 并将字符入栈后，如果栈的深度为 $1$，则不把字符放入结果；在遇到 $\\text{`)’}$ 并将栈顶字符出栈后，如果栈为空，则不把字符放入结果。其他情况下，需要把字符放入结果。代码对流程进行了部分优化，减少了判断语句。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def removeOuterParentheses(self, s: str) -> str:\n        res, stack = \"\", []\n        for c in s:\n            if c == ')':\n                stack.pop()\n            if stack:\n                res += c\n            if c == '(':\n                stack.append(c)\n        return res\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        string res;\n        stack<char> st;\n        for (auto c : s) {\n            if (c == ')') {\n                st.pop();\n            }\n            if (!st.empty()) {\n                res.push_back(c);\n            }\n            if (c == '(') {\n                st.emplace(c);\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String removeOuterParentheses(String s) {\n        StringBuffer res = new StringBuffer();\n        Deque<Character> stack = new ArrayDeque<Character>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == ')') {\n                stack.pop();\n            }\n            if (!stack.isEmpty()) {\n                res.append(c);\n            }\n            if (c == '(') {\n                stack.push(c);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string RemoveOuterParentheses(string s) {\n        StringBuilder res = new StringBuilder();\n        Stack<char> stack = new Stack<char>();\n        foreach (char c in s) {\n            if (c == ')') {\n                stack.Pop();\n            }\n            if (stack.Count > 0) {\n                res.Append(c);\n            }\n            if (c == '(') {\n                stack.Push(c);\n            }\n        }\n        return res.ToString();\n    }\n}\n```\n\n```C [sol1-C]\nchar * removeOuterParentheses(char * s) {\n    int len = strlen(s);\n    char *res = (char *)malloc(sizeof(char) * len);\n    char *stack = (char *)malloc(sizeof(char) * (len / 2));\n    int pos = 0, top = 0;\n    for (int i = 0; i < len; i++) {\n        char c = s[i];\n        if (c == ')') {\n            top--;\n        }\n        if (top > 0) {\n            res[pos++] = c;\n        }\n        if (c == '(') {\n            stack[top++] = c;\n        }\n    }\n    free(stack);\n    res[pos] = '\\0';\n    return res;\n}\n```\n\n```go [sol1-Golang]\nfunc removeOuterParentheses(s string) string {\n    var ans, st []rune\n    for _, c := range s {\n        if c == ')' {\n            st = st[:len(st)-1]\n        }\n        if len(st) > 0 {\n            ans = append(ans, c)\n        }\n        if c == '(' {\n            st = append(st, c)\n        }\n    }\n    return string(ans)\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar removeOuterParentheses = function(s) {\n    let res = '';\n    const stack = [];\n    for (let i = 0; i < s.length; i++) {\n        const c = s[i];\n        if (c === ')') {\n            stack.pop();\n        }\n        if (stack.length) {\n            res += c;\n        }\n        if (c === '(') {\n            stack.push(c);\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是输入 $s$ 的长度。仅需遍历 $s$ 一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是输入 $s$ 的长度。需要使用栈，长度最大为 $O(n)$。\n\n#### 方法二：计数\n\n**思路**\n\n从 $s$ 开始位置计算子数组的和，遇到 $\\text{`(’}$ 则加 $1$，遇到 $\\text{`)’}$ 则减 $1$，第一次和为 $0$ 时则为第一个原语。从上一个原语的结束位置的下一个位置开始继续求子数组的和，和首次为 $0$ 时则是另一个新的原语，直到遇到 $s$ 的结尾。保存结果时，忽略每个原语的开始字符和结尾字符，其他字符均保存下来生成新的字符串。代码对流程进行了部分优化，减少了判断语句。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def removeOuterParentheses(self, s: str) -> str:\n        res, level = \"\", 0\n        for c in s:\n            if c == ')':\n                level -= 1\n            if level:\n                res += c\n            if c == '(':\n                level += 1\n        return res\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        int level = 0;\n        string res;\n        for (auto c : s) {\n            if (c == ')') {\n                level--;\n            }\n            if (level) {\n                res.push_back(c);\n            }\n            if (c == '(') {\n                level++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public String removeOuterParentheses(String s) {\n        int level = 0;\n        StringBuffer res = new StringBuffer();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == ')') {\n                level--;\n            }\n            if (level > 0) {\n                res.append(c);\n            }\n            if (c == '(') {\n                level++;\n            }\n        }\n        return res.toString();\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public string RemoveOuterParentheses(string s) {\n        int level = 0;\n        StringBuilder res = new StringBuilder();\n        foreach (char c in s) {\n            if (c == ')') {\n                level--;\n            }\n            if (level > 0) {\n                res.Append(c);\n            }\n            if (c == '(') {\n                level++;\n            }\n        }\n        return res.ToString();\n    }\n}\n```\n\n```C [sol2-C]\nchar * removeOuterParentheses(char * s) {\n    int len = strlen(s);\n    int level = 0;\n    char *res = (char *)malloc(sizeof(char) * (len + 1));\n    int pos = 0;\n    for (int i = 0; i < len; i++) {\n        char c = s[i];\n        if (c == ')') {\n            level++;\n        }\n        if (level) {\n            res[pos++] = c;\n        }\n        if (c == '(') {\n            level--;\n        }\n    }\n    res[pos] = '\\0';    \n    return res;\n}\n```\n\n```go [sol2-Golang]\nfunc removeOuterParentheses(s string) string {\n    ans := []rune{}\n    level := 0\n    for _, c := range s {\n        if c == ')' {\n            level--\n        }\n        if level > 0 {\n            ans = append(ans, c)\n        }\n        if c == '(' {\n            level++\n        }\n    }\n    return string(ans)\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar removeOuterParentheses = function(s) {\n    let level = 0;\n    let res = '';\n    for (let i = 0; i < s.length; i++) {\n        const c = s[i];\n        if (c === ')') {\n            level--;\n        }\n        if (level > 0) {\n            res += c;\n        }\n        if (c === '(') {\n            level++;\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是输入 $s$ 的长度。仅需遍历 $s$ 一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是输入 $s$ 的长度。需要用数组暂时保存结果，并转换为字符串。部分语言支持字符串的修改，可以做到 $O(1)$ 空间复杂度。"
}