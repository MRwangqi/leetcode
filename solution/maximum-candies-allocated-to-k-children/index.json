{
	"titleSlug": "maximum-candies-allocated-to-k-children",
	"slug": "mei-ge-xiao-hai-zui-duo-neng-fen-dao-duo-2717",
	"url": "https://leetcode-cn.com/problems/maximum-candies-allocated-to-k-children/solution/mei-ge-xiao-hai-zui-duo-neng-fen-dao-duo-2717/",
	"content": "#### 方法一：二分查找转化为判定问题\n\n**提示 $1$**\n\n当每个小孩拿走的糖果数目增大时，现有糖果可以满足的小孩数目**不会增大**。\n\n**思路与算法**\n\n根据 **提示 $1$**，如果 $k$ 个小孩每人可以按要求拿到 $i$ 个糖果，那么它们一定可以按要求拿到闭区间 $[0, i]$ 内任一整数数量的糖果。这也就说明「$k$ 个小孩每人能否按要求拿到 $i$ 个糖果」这一**判定问题**对于 $i$ 具有**二值性**。因此我们可以通过二分查找确定使得该判定问题成立的**最大**的 $i$。\n\n我们可以引入辅助函数 $\\textit{check}(i)$ 来判断对应的判定问题是否成立。具体地，我们用 $\\textit{res}$ 来维护最多可以按要求拿到 $i$ 个糖果的小孩数目。我们遍历 $\\textit{candies}$ 数组，对于数组的每个元素 $c$，对应数量该堆糖果最多可以分给 $\\lfloor c / i \\rfloor$ 个小孩（其中 $\\lfloor \\dots \\rfloor$ 代表向下取整），则我们将 $\\textit{res}$ 加上该数值。最终，我们通过判断 $\\textit{res}$ 是否大于等于 $k$ 来判断对应的判定问题是否成立。\n\n而对于二分查找的上界，我们可以通过糖果数量进行估计。具体地，由于每个小孩至多可以拿走一堆糖果，因此每个小孩可以拿走的糖果数目不会超过最多一堆糖果的数量。\n\n**细节**\n\n对于二分查找的下界，如果设置为 $0$，则在上文的未经修改的 $\\textit{check}(i)$ 函数中，会出现除数为零的问题。此时我们有两种解决方案：\n\n1. 将二分查找下界设置为 $1$，通过二分查找计算**最小的无法满足需求**的 $i$，此时每个小孩可分到的最大糖果数目即为 $i - 1$；\n\n2. 由于 $i = 0$ 时一定可以满足 $k$ 个小孩的要求，因此我们直接对于此种情况返回 $\\texttt{true}$ 即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maximumCandies(vector<int>& candies, long long k) {\n        // 判断每个小孩分到 i 个糖果时是否可以满足要求\n        auto check = [&](int i) -> bool {\n            long long res = 0;\n            for (int c: candies) {\n                res += c / i;\n            }\n            return res >= k;\n        };\n\n        // 二分查找\n        int l = 1;\n        int r = 1 + *max_element(candies.begin(), candies.end());\n        while (l < r) {\n            int mid = l + (r - l) / 2;\n            if (check(mid)) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return l - 1;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def maximumCandies(self, candies: List[int], k: int) -> int:\n        # 判断每个小孩分到 i 个糖果时是否可以满足要求\n        def check(i: int) -> bool:\n            res = 0\n            for c in candies:\n                res += c // i\n            return res >= k\n\n        # 二分查找\n        l = 1\n        r = max(candies) + 1\n        while l < r:\n            mid = l + (r - l) // 2\n            if check(mid):\n                l = mid + 1\n            else:\n                r = mid\n        return l - 1\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log M)$，其中 $n$ 为数组 $\\textit{candies}$ 的长度，$M = \\max(\\textit{candies})$，即二分查找的上界。我们总共需要 $O(\\log M)$ 次二分查找，每次需要 $O(n)$ 的时间计算每人的糖果数量是否符合要求。\n\n- 空间复杂度：$O(1)$。"
}