{
	"titleSlug": "find-k-th-smallest-pair-distance",
	"slug": "zhao-chu-di-k-xiao-de-shu-dui-ju-chi-by-xwfgf",
	"url": "https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/solution/zhao-chu-di-k-xiao-de-shu-dui-ju-chi-by-xwfgf/",
	"content": "#### 方法一：排序 + 二分查找\n\n先将数组 $\\textit{nums}$ 从小到大进行排序。因为第 $k$ 小的数对距离必然在区间 $[0, \\max (\\textit{nums}) - \\min(\\textit{nums})]$ 内，令 $\\textit{left} = 0$，$\\textit{right} = \\max (\\textit{nums}) - \\min(\\textit{nums})$，我们在区间 $[\\textit{left}, \\textit{right}]$ 上进行二分。\n\n对于当前搜索的距离 $\\textit{mid}$，计算所有距离小于等于 $\\textit{mid}$ 的数对数目 $\\textit{cnt}$，如果 $\\textit{cnt} \\ge k$，那么 $\\textit{right} = \\textit{mid} - 1$，否则 $\\textit{left} = \\textit{mid} + 1$。当 $\\textit{left} \\gt \\textit{right}$ 时，终止搜索，那么第 $k$ 小的数对距离为 $\\textit{left}$。\n\n给定距离 $\\textit{mid}$，计算所有距离小于等于 $\\textit{mid}$ 的数对数目 $\\textit{cnt}$ 可以使用二分查找：枚举所有数对的右端点 $j$，二分查找大于等于 $\\textit{nums}[j] - \\textit{mid}$ 的最小值的下标 $i$，那么右端点为 $j$ 且距离小于等于 $\\textit{mid}$ 的数对数目为 $j - i$，计算这些数目之和。\n\n```Python [sol1-Python3]\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def count(mid: int) -> int:\n            cnt = 0\n            for j, num in enumerate(nums):\n                i = bisect_left(nums, num - mid, 0, j)\n                cnt += j - i\n            return cnt\n\n        nums.sort()\n        return bisect_left(range(nums[-1] - nums[0]), k, key=count)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), left = 0, right = nums.back() - nums.front();\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                int i = lower_bound(nums.begin(), nums.begin() + j, nums[j] - mid) - nums.begin();\n                cnt += j - i;\n            }\n            if (cnt >= k) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length, left = 0, right = nums[n - 1] - nums[0];\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                int i = binarySearch(nums, j, nums[j] - mid);\n                cnt += j - i;\n            }\n            if (cnt >= k) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    public int binarySearch(int[] nums, int end, int target) {\n        int left = 0, right = end;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int SmallestDistancePair(int[] nums, int k) {\n        Array.Sort(nums);\n        int n = nums.Length, left = 0, right = nums[n - 1] - nums[0];\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                int i = BinarySearch(nums, j, nums[j] - mid);\n                cnt += j - i;\n            }\n            if (cnt >= k) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    public int BinarySearch(int[] nums, int end, int target) {\n        int left = 0, right = end;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n```\n\n```C [sol1-C]\nint cmp(const void* pa, const void* pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint binarySearch(int* nums, int end, int target) {\n    int left = 0, right = end - 1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return left;\n}\n\nint smallestDistancePair(int* nums, int numsSize, int k) {\n    qsort(nums, numsSize, sizeof(int), cmp);\n    int left = 0, right = nums[numsSize - 1] - nums[0];\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        int cnt = 0;\n        for (int j = 0; j < numsSize; j++) {\n            int i = binarySearch(nums, j, nums[j] - mid);\n            cnt += j - i;\n        }\n        if (cnt >= k) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n```go [sol1-Golang]\nfunc smallestDistancePair(nums []int, k int) int {\n    sort.Ints(nums)\n    return sort.Search(nums[len(nums)-1]-nums[0], func(mid int) bool {\n        cnt := 0\n        for j, num := range nums {\n            i := sort.SearchInts(nums[:j], num-mid)\n            cnt += j - i\n        }\n        return cnt >= k\n    })\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar smallestDistancePair = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let n = nums.length, left = 0, right = nums[n - 1] - nums[0];\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        let cnt = 0;\n        for (let j = 0; j < n; j++) {\n            const i = binarySearch(nums, j, nums[j] - mid);\n            cnt += j - i;\n        }\n        if (cnt >= k) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n};\n\nconst binarySearch = (nums, end, target) => {\n    let left = 0, right = end;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n \\log n \\times \\log D)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度，$D = \\max(\\textit{nums}) - \\min(\\textit{nums})$。外层二分查找需要 $O(\\log D)$，内层二分查找需要 $O(n \\log n)$。\n\n+ 空间复杂度：$O(\\log n)$。排序的平均空间复杂度为 $O(\\log n)$。\n\n#### 方法二：排序 + 二分查找 + 双指针\n\n给定距离 $\\textit{mid}$，计算所有距离小于等于 $\\textit{mid}$ 的数对数目 $\\textit{cnt}$ 可以使用双指针：初始左端点 $i = 0$，我们从小到大枚举所有数对的右端点 $j$，移动左端点直到 $\\textit{nums}[j] - \\textit{nums}[i] \\le \\textit{mid}$，那么右端点为 $j$ 且距离小于等于 $\\textit{mid}$ 的数对数目为 $j - i$，计算这些数目之和。\n\n```Python [sol2-Python3]\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def count(mid: int) -> int:\n            cnt = i = 0\n            for j, num in enumerate(nums):\n                while num - nums[i] > mid:\n                    i += 1\n                cnt += j - i\n            return cnt\n\n        nums.sort()\n        return bisect_left(range(nums[-1] - nums[0]), k, key=count)\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), left = 0, right = nums.back() - nums.front();\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for (int i = 0, j = 0; j < n; j++) {\n                while (nums[j] - nums[i] > mid) {\n                    i++;\n                }\n                cnt += j - i;\n            }\n            if (cnt >= k) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length, left = 0, right = nums[n - 1] - nums[0];\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for (int i = 0, j = 0; j < n; j++) {\n                while (nums[j] - nums[i] > mid) {\n                    i++;\n                }\n                cnt += j - i;\n            }\n            if (cnt >= k) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int SmallestDistancePair(int[] nums, int k) {\n        Array.Sort(nums);\n        int n = nums.Length, left = 0, right = nums[n - 1] - nums[0];\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for (int i = 0, j = 0; j < n; j++) {\n                while (nums[j] - nums[i] > mid) {\n                    i++;\n                }\n                cnt += j - i;\n            }\n            if (cnt >= k) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```\n\n```C [sol2-C]\nint cmp(const void* pa, const void* pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint smallestDistancePair(int* nums, int numsSize, int k) {\n    qsort(nums, numsSize, sizeof(int), cmp);\n    int left = 0, right = nums[numsSize - 1] - nums[0];\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        int cnt = 0;\n        for (int i = 0, j = 0; j < numsSize; j++) {\n            while (nums[j] - nums[i] > mid) {\n                i++;\n            }\n            cnt += j - i;\n        }\n        if (cnt >= k) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n```go [sol2-Golang]\nfunc smallestDistancePair(nums []int, k int) int {\n    sort.Ints(nums)\n    return sort.Search(nums[len(nums)-1]-nums[0], func(mid int) bool {\n        cnt, i := 0, 0\n        for j, num := range nums {\n            for num-nums[i] > mid {\n                i++\n            }\n            cnt += j - i\n        }\n        return cnt >= k\n    })\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar smallestDistancePair = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let n = nums.length, left = 0, right = nums[n - 1] - nums[0];\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        let cnt = 0;\n        for (let i = 0, j = 0; j < n; j++) {\n            while (nums[j] - nums[i] > mid) {\n                i++;\n            }\n            cnt += j - i;\n        }\n        if (cnt >= k) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n \\times (\\log n + \\log D))$，其中 $n$ 是数组 $\\textit{nums}$ 的长度，$D = \\max(\\textit{nums}) - \\min(\\textit{nums})$。外层二分查找需要 $O(\\log D)$，内层双指针需要 $O(n)$，排序的平均时间复杂度为 $O(n \\log n)$。\n\n+ 空间复杂度：$O(\\log n)$。排序的平均空间复杂度为 $O(\\log n)$。"
}