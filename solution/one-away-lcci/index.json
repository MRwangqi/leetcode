{
	"titleSlug": "one-away-lcci",
	"slug": "yi-ci-bian-ji-by-leetcode-solution-2xkr",
	"url": "https://leetcode-cn.com/problems/one-away-lcci/solution/yi-ci-bian-ji-by-leetcode-solution-2xkr/",
	"content": "#### 方法一：分情况讨论\n\n假设字符串 $\\textit{first}$ 和 $\\textit{second}$ 的长度分别是 $m$ 和 $n$。\n\n如果 $\\textit{first}$ 和 $\\textit{second}$ 需要一次编辑，则可能有三种情况：\n\n- 往 $\\textit{first}$ 中插入一个字符得到 $\\textit{second}$，此时 $n - m = 1$，$\\textit{second}$ 比 $\\textit{first}$ 多一个字符，其余字符都相同；\n\n- 从 $\\textit{first}$ 中删除一个字符得到 $\\textit{second}$，此时 $m - n = 1$，$\\textit{first}$ 比 $\\textit{second}$ 多一个字符，其余字符都相同；\n\n- 将 $\\textit{first}$ 中的一个字符替换成不同的字符得到 $\\textit{second}$，此时 $m = n$，$\\textit{first}$ 和 $\\textit{second}$ 恰好有一个字符不同。\n\n如果 $\\textit{first}$ 和 $\\textit{second}$ 需要零次编辑，则 $m = n$ 且 $\\textit{first}$ 和 $\\textit{second}$ 相等。\n\n根据上述分析，当符合一次编辑时，$\\textit{first}$ 和 $\\textit{second}$ 的长度关系可能有三种情况，分别是 $n - m = 1$、$m - n = 1$ 和 $m = n$。首先计算 $\\textit{first}$ 和 $\\textit{second}$ 的长度关系，在可能的三种情况中找到对应的一种情况，然后遍历字符串判断是否符合一次编辑或零次编辑。特别地，只有当 $m = n$ 时才需要判断是否符合零次编辑。\n\n如果长度关系不符合上述三种情况，即 $|m - n| > 1$，则不符合一次编辑或零次编辑。\n\n具体实现方法如下。\n\n当 $n - m = 1$ 或 $m - n = 1$ 时，由于两种情况具有对称性，因此可以定义一个函数统一计算这两种情况。用 $\\textit{longer}$ 表示较长的字符串，$\\textit{shorter}$ 表示较短的字符串，同时遍历两个字符串，比较对应下标处的字符是否相同，如果字符相同则将两个字符串的下标同时加 $1$，如果字符不同则只将 $\\textit{longer}$ 的下标加 $1$。遍历过程中如果出现两个字符串的下标之差大于 $1$ 则不符合一次编辑，遍历结束时如果两个字符串的下标之差不大于 $1$ 则符合一次编辑。\n\n当 $m = n$ 时，同时遍历 $\\textit{first}$ 和 $\\textit{second}$，比较相同下标处的字符是否相同。如果字符不同的下标个数不超过 $1$，则符合一次编辑或零次编辑。\n\n```Python [sol1-Python3]\nclass Solution:\n    def oneEditAway(self, first: str, second: str) -> bool:\n        m, n = len(first), len(second)\n        if m < n:\n            return self.oneEditAway(second, first)\n        if m - n > 1:\n            return False\n        for i, (x, y) in enumerate(zip(first, second)):\n            if x != y:\n                return first[i + 1:] == second[i + 1:] if m == n else first[i + 1:] == second[i:]  # 注：改用下标枚举可达到 O(1) 空间复杂度\n        return True\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean oneEditAway(String first, String second) {\n        int m = first.length(), n = second.length();\n        if (n - m == 1) {\n            return oneInsert(first, second);\n        } else if (m - n == 1) {\n            return oneInsert(second, first);\n        } else if (m == n) {\n            boolean foundDifference = false;\n            for (int i = 0; i < m; i++) {\n                if (first.charAt(i) != second.charAt(i)) {\n                    if (!foundDifference) {\n                        foundDifference = true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public boolean oneInsert(String shorter, String longer) {\n        int length1 = shorter.length(), length2 = longer.length();\n        int index1 = 0, index2 = 0;\n        while (index1 < length1 && index2 < length2) {\n            if (shorter.charAt(index1) == longer.charAt(index2)) {\n                index1++;\n            }\n            index2++;\n            if (index2 - index1 > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool OneEditAway(string first, string second) {\n        int m = first.Length, n = second.Length;\n        if (n - m == 1) {\n            return OneInsert(first, second);\n        } else if (m - n == 1) {\n            return OneInsert(second, first);\n        } else if (m == n) {\n            bool foundDifference = false;\n            for (int i = 0; i < m; i++) {\n                if (first[i] != second[i]) {\n                    if (!foundDifference) {\n                        foundDifference = true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public bool OneInsert(string shorter, string longer) {\n        int length1 = shorter.Length, length2 = longer.Length;\n        int index1 = 0, index2 = 0;\n        while (index1 < length1 && index2 < length2) {\n            if (shorter[index1] == longer[index2]) {\n                index1++;\n            }\n            index2++;\n            if (index2 - index1 > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool oneEditAway(string first, string second) {\n        int m = first.size(), n = second.size();\n        if (n - m == 1) {\n            return oneInsert(first, second);\n        } else if (m - n == 1) {\n            return oneInsert(second, first);\n        } else if (m == n) {\n            bool foundDifference = false;\n            for (int i = 0; i < m; i++) {\n                if (first[i] != second[i]) {\n                    if (!foundDifference) {\n                        foundDifference = true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    bool oneInsert(string shorter, string longer) {\n        int length1 = shorter.size(), length2 = longer.size();\n        int index1 = 0, index2 = 0;\n        while (index1 < length1 && index2 < length2) {\n            if (shorter[index1] == longer[index2]) {\n                index1++;\n            }\n            index2++;\n            if (index2 - index1 > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n```C [sol1-C]\nbool oneInsert(const char * shorter, const char * longer) {\n    int length1 = strlen(shorter), length2 = strlen(longer);\n    int index1 = 0, index2 = 0;\n    while (index1 < length1 && index2 < length2) {\n        if (shorter[index1] == longer[index2]) {\n            index1++;\n        }\n        index2++;\n        if (index2 - index1 > 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool oneEditAway(char* first, char* second) {\n    int m = strlen(first), n = strlen(second);\n    if (n - m == 1) {\n        return oneInsert(first, second);\n    } else if (m - n == 1) {\n        return oneInsert(second, first);\n    } else if (m == n) {\n        bool foundDifference = false;\n        for (int i = 0; i < m; i++) {\n            if (first[i] != second[i]) {\n                if (!foundDifference) {\n                    foundDifference = true;\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc oneEditAway(first, second string) bool {\n    m, n := len(first), len(second)\n    if m < n {\n        return oneEditAway(second, first)\n    }\n    if m-n > 1 {\n        return false\n    }\n    for i, ch := range second {\n        if first[i] != byte(ch) {\n            if m == n {\n                return first[i+1:] == second[i+1:]\n            }\n            return first[i+1:] == second[i:]\n        }\n    }\n    return true\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar oneEditAway = function(first, second) {\n    const m = first.length, n = second.length;\n    if (n - m === 1) {\n        return oneInsert(first, second);\n    } else if (m - n === 1) {\n        return oneInsert(second, first);\n    } else if (m === n) {\n        let foundDifference = false;\n        for (let i = 0; i < m; i++) {\n            if (first[i] != second[i]) {\n                if (!foundDifference) {\n                    foundDifference = true;\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\nconst oneInsert = (shorter, longer) => {\n    const length1 = shorter.length, length2 = longer.length;\n    let index1 = 0, index2 = 0;\n    while (index1 < length1 && index2 < length2) {\n        if (shorter[index1] == longer[index2]) {\n            index1++;\n        }\n        index2++;\n        if (index2 - index1 > 1) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m + n)$，其中 $m$ 和 $n$ 分别是字符串 $\\textit{first}$ 和 $\\textit{second}$ 的长度。当 $|m - n| \\le 1$ 时，需要遍历两个字符串各一次。\n\n- 空间复杂度：$O(1)$。"
}