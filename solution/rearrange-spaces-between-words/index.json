{
	"titleSlug": "rearrange-spaces-between-words",
	"slug": "zhong-xin-pai-lie-dan-ci-jian-de-kong-ge-5kln",
	"url": "https://leetcode-cn.com/problems/rearrange-spaces-between-words/solution/zhong-xin-pai-lie-dan-ci-jian-de-kong-ge-5kln/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n题目给定字符串 $\\textit{text}$，首先我们按照空格分割，得到单词集合，并统计空格数。\n\n1. 如果单词数为 $1$，则将全部的空格拼接到这个单词后面即可。\n2. 否则先计算出单词间的间隔，并按照单词及间隔来进行拼接，若拼接后仍有多余的空格，则将剩下的空格拼接在末尾即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def reorderSpaces(self, text: str) -> str:\n        words = text.split()\n        space = text.count(' ')\n        if len(words) == 1:\n            return words[0] + ' ' * space\n        per_space, rest_space = divmod(space, len(words) - 1)\n        return (' ' * per_space).join(words) + ' ' * rest_space\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String reorderSpaces(String text) {\n        int length = text.length();\n        String[] words = text.trim().split(\"\\\\s+\");\n        int cntSpace = length;\n        for (String word : words) {\n            cntSpace -= word.length();\n        }\n        StringBuilder sb = new StringBuilder();\n        if (words.length == 1) {\n            sb.append(words[0]);\n            for (int i = 0; i < cntSpace; i++) {\n                sb.append(' ');\n            }\n            return sb.toString();\n        }\n        int perSpace = cntSpace / (words.length - 1);\n        int restSpace = cntSpace % (words.length - 1);\n        for (int i = 0; i < words.length; i++) {\n            if (i > 0) {\n                for (int j = 0; j < perSpace; j++) {\n                    sb.append(' ');\n                }\n            }\n            sb.append(words[i]);\n        }\n        for (int i = 0; i < restSpace; i++) {\n            sb.append(' ');\n        }\n        return sb.toString();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string ReorderSpaces(string text) {\n        int length = text.Length;\n        string[] words = text.Trim().Split(\" \");\n        int cntSpace = length;\n        int wordCount = 0;\n        foreach (string word in words) {\n            if (word.Length > 0) {\n                cntSpace -= word.Length;\n                wordCount++;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        if (words.Length == 1) {\n            sb.Append(words[0]);\n            for (int i = 0; i < cntSpace; i++) {\n                sb.Append(' ');\n            }\n            return sb.ToString();\n        }\n        int perSpace = cntSpace / (wordCount - 1);\n        int restSpace = cntSpace % (wordCount - 1);\n        for (int i = 0; i < words.Length; i++) {\n            if (words[i].Length == 0) {\n                continue;\n            }\n            if (sb.Length > 0) {\n                for (int j = 0; j < perSpace; j++) {\n                    sb.Append(' ');\n                }\n            }\n            sb.Append(words[i]);\n        }\n        for (int i = 0; i < restSpace; i++) {\n            sb.Append(' ');\n        }\n        return sb.ToString();\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string_view> split(const string_view &str, char trim) {\n        int n = str.size();\n        vector<string_view> res;\n        int pos = 0;\n        while (pos < n) {\n            while(pos < n && str[pos] == trim) {\n                pos++;\n            }\n            if (pos < n) {\n                int curr = pos;\n                while(pos < n && str[pos] != trim) {\n                    pos++;\n                }\n                res.emplace_back(str.substr(curr, pos - curr));\n            }\n        }\n        return res;\n    }\n\n    string reorderSpaces(string text) {\n        int length = text.size();\n        vector<string_view> words = split(text, ' ');\n        int cntSpace = length;\n        int wordCount = 0;\n        for (auto &word : words) {\n            if (word.size() > 0) {\n                cntSpace -= word.size();\n                wordCount++;\n            }\n        }\n\n        string ans;\n        if (words.size() == 1) {\n            ans.append(words[0]);\n            for (int i = 0; i < cntSpace; i++) {\n                ans.push_back(' ');\n            }\n            return ans;\n        }\n        int perSpace = cntSpace / (wordCount - 1);\n        int restSpace = cntSpace % (wordCount - 1);\n        for (int i = 0; i < words.size(); i++) {\n            if (words[i].size() == 0) {\n                continue;\n            }\n            if (ans.size() > 0) {\n                for (int j = 0; j < perSpace; j++) {\n                    ans.push_back(' ');\n                }\n            }\n            ans.append(words[i]);\n        }\n        for (int i = 0; i < restSpace; i++) {\n            ans.push_back(' ');\n        }\n        return ans;\n    }\n};\n```\n\n```C [sol1-C]\nchar** split(const char *str, char trim, int *returnSize) {\n    int n = strlen(str);\n    char **words = (char **)malloc(sizeof(char *) * n);\n    int wordsSize = 0, pos = 0;\n    while (pos < n) {\n        while(pos < n && str[pos] == trim) {\n            pos++;\n        }\n        if (pos < n) {\n            int curr = pos;\n            while(pos < n && str[pos] != trim) {\n                pos++;\n            }\n            words[wordsSize] = (char *)malloc(sizeof(char) * (pos - curr + 1));\n            strncpy(words[wordsSize], str + curr, pos - curr);\n            words[wordsSize++][pos - curr] = '\\0';\n        }\n    }\n    *returnSize = wordsSize;\n    return words;\n}\n\n\nchar * reorderSpaces(char * text){\n    int length = strlen(text);\n    int wordsSize = 0;\n    char **words = split(text, ' ', &wordsSize);\n    int cntSpace = length;\n    int wordCount = 0;\n    for (int i = 0; i < wordsSize; i++) {\n        int len = strlen(words[i]);\n        if (len > 0) {\n            cntSpace -= len;\n            wordCount++;\n        }\n    }\n\n    char *ans = (char *)malloc(sizeof(char) * (length + 1));\n    int pos = 0;\n    if (wordsSize == 1) {\n        pos += sprintf(ans + pos, \"%s\", words[0]);\n        for (int i = 0; i < cntSpace; i++) {\n            ans[pos++] = ' ';\n        }\n        ans[pos] = '\\0';\n        free(words[0]);\n        free(words);\n        return ans;\n    }\n    int perSpace = cntSpace / (wordCount - 1);\n    int restSpace = cntSpace % (wordCount - 1);\n    for (int i = 0; i < wordsSize; i++) {\n        if (strlen(words[i]) == 0) {\n            continue;\n        }\n        if (pos > 0) {\n            for (int j = 0; j < perSpace; j++) {\n                ans[pos++] = ' ';\n            }\n        }\n        pos += sprintf(ans + pos, \"%s\", words[i]);\n    }\n    for (int i = 0; i < restSpace; i++) {\n        ans[pos++] = ' ';\n    }\n    ans[pos] = '\\0';\n    for (int i = 0; i < wordsSize; i++) {\n        free(words[i]);\n    }\n    free(words);\n    return ans;  \n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar reorderSpaces = function(text) {\n    const length = text.length;\n    const words = [];\n    text.split(' ').forEach(e => {\n        if (e.length > 0) {\n            words.push(e);\n        }\n    });\n    let cntSpace = length;\n    for (const word of words) {\n        if (word.length) {\n            cntSpace -= word.length;\n        }\n    }\n    let sb = '';\n    if (words.length === 1) {\n        sb += words[0];\n        for (let i = 0; i < cntSpace; i++) {\n            sb += ' ';\n        }\n        return sb;\n    }\n    const perSpace = Math.floor(cntSpace / (words.length - 1));\n    const restSpace = cntSpace % (words.length - 1);\n    for (let i = 0; i < words.length; i++) {\n        if (i > 0) {\n            for (let j = 0; j < perSpace; j++) {\n                sb += ' ';\n            }\n        }\n        sb += words[i];\n    }\n    for (let i = 0; i < restSpace; i++) {\n        sb += ' ';\n    }\n    return sb;\n};\n```\n\n```go [sol1-Golang]\nfunc reorderSpaces(s string) (ans string) {\n    words := strings.Fields(s)\n    space := strings.Count(s, \" \")\n    lw := len(words) - 1\n    if lw == 0 {\n        return words[0] + strings.Repeat(\" \", space)\n    }\n    return strings.Join(words, strings.Repeat(\" \", space/lw)) + strings.Repeat(\" \", space%lw)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为字符串 $\\textit{text}$ 的长度。\n- 空间复杂度：$O(n)$，其中 $n$ 为字符串 $\\textit{text}$ 的长度，主要为返回的字符串空间开销。"
}