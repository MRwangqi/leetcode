{
	"titleSlug": "maximum-profit-in-job-scheduling",
	"slug": "by-sao-hei-chu-e-wei-dang-yu-min-w5rc",
	"url": "https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/solution/by-sao-hei-chu-e-wei-dang-yu-min-w5rc/",
	"content": "# 二分查找\r\n> **借用了yukiyama的图**\r\n[]()![image.png](https://pic.leetcode-cn.com/1665548328-KtZhCm-image.png)\r\n\r\n我们这里选择的是模板二的左开右闭\r\n**应当注意的是我们定义的dp从1开始算，所以l和r都要加上1**\r\n所以二分的形式为\r\n```cpp\r\nint l = 0, r = n;\r\n    while(l<r){\r\n        int m = ((r-l+1)>>1)+l;\r\n        //结束时间大于上一次的时间\r\n        if(sum[m-1][1]>sum[i-1][0]){\r\n            r = m-1;\r\n        }\r\n        else\r\n            l = m;\r\n    }\r\n```\r\n# 合并和dp处理\r\n- 同时我们要对endtimes数组进行排序，但是为了保证其他数组能和他匹配，需要一个二维数组来进行合并\r\n```cpp\r\nfor(int i = 0; i < n;++i){\r\n    sum[i][0] = startTime[i];\r\n    sum[i][1] = endTime[i];\r\n    sum[i][2] = profit[i];\r\n}\r\n```\r\n***\r\n**这里我们需要一个一维数组dp来获取答案，它的含义是前i个元素满足条件的最大和值**\r\n- 这里需要分情况进行讨论\r\n    1.如果选择第i个工作那么dp[i]=dp[l]+sum[i][2];(这里的l表示结束冷冻期能够选择i的最大值的下标(**我们通过二分获得**)\r\n    2.如果不选择第i个工作那么, dp[i] = dp[i-1];\r\n# 源代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\r\n        int n = startTime.size();\r\n        vector<vector<int> >sum(n,vector<int>(3,0));\r\n        for(int i = 0; i < n;++i){\r\n            sum[i][0] = startTime[i];\r\n            sum[i][1] = endTime[i];\r\n            sum[i][2] = profit[i];\r\n        }\r\n        sort(sum.begin(),sum.end(),[&](auto& p1, auto& p2){\r\n            return p1[1]<p2[1];\r\n        });\r\n        vector<int>dp(n+1);\r\n        //前i个工作获得的最大收益\r\n        for(int i = 1; i <= n;++i){\r\n            int l = 0, r = n;\r\n            while(l<r){\r\n                int m = ((r-l+1)>>1)+l;\r\n                //结束时间大于上一次的时间\r\n                if(sum[m-1][1]>sum[i-1][0]){\r\n                    r = m-1;\r\n                }\r\n                else\r\n                    l = m;\r\n            }\r\n            if(dp[i-1]>dp[r]+sum[i-1][2]){\r\n                dp[i] = dp[i-1];\r\n            }\r\n            else{\r\n                dp[i] = dp[r] + sum[i-1][2];\r\n            }\r\n          ///  cout<<dp[i]<<endl;\r\n        }\r\n        return dp[n];\r\n    }\r\n};\r\n```\r\n最后还有一道相似的题目:[最多可以参加的会议数目2](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/)   感兴趣的可以做一下"
}