{
	"titleSlug": "ur2n8P",
	"slug": "zhong-jian-xu-lie-by-leetcode-solution-urxc",
	"url": "https://leetcode-cn.com/problems/ur2n8P/solution/zhong-jian-xu-lie-by-leetcode-solution-urxc/",
	"content": "#### 方法一：拓扑排序\n\n**思路和算法**\n\n由于 $\\textit{sequences}$ 中的每个序列都是 $\\textit{nums}$ 的子序列，因此每个序列中的数字顺序都和 $\\textit{nums}$ 中的数字顺序一致。为了判断 $\\textit{nums}$ 是不是序列的唯一最短超序列，只需要判断根据 $\\textit{sequences}$ 中的每个序列构造超序列的结果是否唯一。\n\n可以将 $\\textit{sequences}$ 中的所有序列看成有向图，数字 $1$ 到 $n$ 分别表示图中的 $n$ 个结点，每个序列中的相邻数字表示的结点之间存在一条有向边。根据给定的序列构造超序列等价于有向图的拓扑排序。\n\n首先根据有向边计算每个结点的入度，然后将所有入度为 $0$ 的结点添加到队列中，进行拓扑排序。每一轮拓扑排序时，队列中的元素个数表示可以作为超序列下一个数字的元素个数，根据队列中的元素个数，执行如下操作。\n\n- 如果队列中的元素个数大于 $1$，则超序列的下一个数字不唯一，因此 $\\textit{nums}$ 不是唯一的最短超序列，返回 $\\text{false}$。\n\n- 如果队列中的元素个数等于 $1$，则超序列的下一个数字是队列中唯一的数字。将该数字从队列中取出，将该数字指向的每个数字的入度减 $1$，并将入度变成 $0$ 的数字添加到队列中。\n\n重复上述过程，直到出现队列中的元素个数不等于 $1$ 的情况。\n\n- 如果队列中的元素个数大于 $1$，则 $\\textit{nums}$ 不是唯一的最短超序列，返回 $\\text{false}$。\n\n- 如果队列为空，则完整的拓扑排序结束，$\\textit{nums}$ 是唯一的最短超序列，返回 $\\text{true}$。\n\n**证明**\n\n如果拓扑排序的过程中，有一轮的队列中的元素个数大于 $1$，则由于超序列的下一个数字有多种可能，因此 $\\textit{nums}$ 不是唯一的最短超序列，这一点颇为直观。需要证明的是：当队列为空时，完整的拓扑排序结束，$\\textit{nums}$ 是唯一的最短超序列。\n\n证明一：只有当 $\\textit{nums}$ 中的所有数字都在至少一个序列中出现时，才可能执行完整的拓扑排序。\n\n由于 $\\textit{sequences}$ 中的每个序列都是 $\\textit{nums}$ 的子序列，因此序列中不存在环，对于所有在至少一个序列中出现的数字，这些数字中一定存在入度为 $0$ 的数字。\n\n如果一个数字没有在任何序列中出现，则该数字的入度为 $0$，即初始时就有多个数字的入度为 $0$，超序列的第一个数字就不唯一，此时会提前返回 $\\text{false}$。因此如果执行完整的拓扑排序，则 $\\textit{nums}$ 中的所有数字都在至少一个序列中出现。\n\n证明二：当执行完整的拓扑排序时，得到的超序列的长度为 $n$。\n\n由于序列中不存在环，因此当完整的拓扑排序结束时，所有在至少一个序列中出现过的数字都在超序列中。由于执行完整的拓扑排序意味着 $\\textit{nums}$ 中的所有数字都在至少一个序列中出现，因此 $\\textit{nums}$ 中的所有数字都在超序列中，即超序列的长度为 $n$。\n\n综上所述，当完整的拓扑排序结束时，$\\textit{nums}$ 是唯一的最短超序列。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def sequenceReconstruction(self, nums: List[int], sequences: List[List[int]]) -> bool:\n        n = len(nums)\n        g = [[] for _ in range(n)]\n        inDeg = [0] * n\n        for sequence in sequences:\n            for x, y in pairwise(sequence):\n                g[x - 1].append(y - 1)\n                inDeg[y - 1] += 1\n\n        q = deque([i for i, d in enumerate(inDeg) if d == 0])\n        while q:\n            if len(q) > 1:\n                return False\n            x = q.popleft()\n            for y in g[x]:\n                inDeg[y] -= 1\n                if inDeg[y] == 0:\n                    q.append(y)\n        return True\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean sequenceReconstruction(int[] nums, int[][] sequences) {\n        int n = nums.length;\n        int[] indegrees = new int[n + 1];\n        Set<Integer>[] graph = new Set[n + 1];\n        for (int i = 1; i <= n; i++) {\n            graph[i] = new HashSet<Integer>();\n        }\n        for (int[] sequence : sequences) {\n            int size = sequence.length;\n            for (int i = 1; i < size; i++) {\n                int prev = sequence[i - 1], next = sequence[i];\n                if (graph[prev].add(next)) {\n                    indegrees[next]++;\n                }\n            }\n        }\n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        for (int i = 1; i <= n; i++) {\n            if (indegrees[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        while (!queue.isEmpty()) {\n            if (queue.size() > 1) {\n                return false;\n            }\n            int num = queue.poll();\n            Set<Integer> set = graph[num];\n            for (int next : set) {\n                indegrees[next]--;\n                if (indegrees[next] == 0) {\n                    queue.offer(next);\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool SequenceReconstruction(int[] nums, int[][] sequences) {\n        int n = nums.Length;\n        int[] indegrees = new int[n + 1];\n        ISet<int>[] graph = new ISet<int>[n + 1];\n        for (int i = 1; i <= n; i++) {\n            graph[i] = new HashSet<int>();\n        }\n        foreach (int[] sequence in sequences) {\n            int size = sequence.Length;\n            for (int i = 1; i < size; i++) {\n                int prev = sequence[i - 1], next = sequence[i];\n                if (graph[prev].Add(next)) {\n                    indegrees[next]++;\n                }\n            }\n        }\n        Queue<int> queue = new Queue<int>();\n        for (int i = 1; i <= n; i++) {\n            if (indegrees[i] == 0) {\n                queue.Enqueue(i);\n            }\n        }\n        while (queue.Count > 0) {\n            if (queue.Count > 1) {\n                return false;\n            }\n            int num = queue.Dequeue();\n            ISet<int> set = graph[num];\n            foreach (int next in set) {\n                indegrees[next]--;\n                if (indegrees[next] == 0) {\n                    queue.Enqueue(next);\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool sequenceReconstruction(vector<int>& nums, vector<vector<int>>& sequences) {\n        int n = nums.size();\n        vector<int> indegrees(n + 1);\n        vector<unordered_set<int>> graph(n + 1);\n        for (auto &sequence : sequences) {\n            for (int i = 1; i < sequence.size(); i++) {\n                int prev = sequence[i - 1], next = sequence[i];\n                if (!graph[prev].count(next)) {\n                    graph[prev].emplace(next);\n                    indegrees[next]++;\n                }\n            }\n        }\n        queue<int> qu;\n        for (int i = 1; i <= n; i++) {\n            if (indegrees[i] == 0) {\n                qu.emplace(i);\n            }\n        }\n        while (!qu.empty()) {\n            if (qu.size() > 1) {\n                return false;\n            }\n            int num = qu.front();\n            qu.pop();\n            for (int next : graph[num]) {\n                indegrees[next]--;\n                if (indegrees[next] == 0) {\n                    qu.emplace(next);\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    UT_hash_handle hh;\n} HashItem;\n\nbool sequenceReconstruction(int* nums, int numsSize, int** sequences, int sequencesSize, int* sequencesColSize){\n    int n = numsSize;\n    int *indegrees = (int *)malloc(sizeof(int) * (n + 1));\n    HashItem **graph = (HashItem **)malloc(sizeof(HashItem *) * (n + 1));\n    memset(indegrees, 0, sizeof(int) * (n + 1));\n    for (int i = 0; i <= n; i++) {\n        graph[i] = NULL;\n    }\n    for (int j = 0; j < sequencesSize; j++) {\n        for (int i = 1; i < sequencesColSize[j]; i++) {\n            int prev = sequences[j][i - 1], next = sequences[j][i];\n            HashItem *pEntry = NULL;\n            HASH_FIND_INT(graph[prev], &next, pEntry);\n            if (NULL == pEntry) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                pEntry->key = next;\n                HASH_ADD_INT(graph[prev], key, pEntry);\n                indegrees[next]++;\n            }\n        }\n    }\n    int *queue = (int *)malloc(sizeof(int) * n);\n    int head = 0, tail = 0;\n    for (int i = 1; i <= n; i++) {\n        if (indegrees[i] == 0) {\n            queue[tail++] = i;\n        }\n    }\n    while (head != tail) {\n        if ((tail - head) > 1) {\n            free(queue);\n            return false;\n        }\n        int num = queue[head++];\n        for (HashItem *pEntry = graph[num]; pEntry != NULL; pEntry = pEntry->hh.next) {\n            int next = pEntry->key;\n            indegrees[next]--;\n            if (indegrees[next] == 0) {\n                queue[tail++] = next;\n            }\n        }\n    }\n    free(queue);\n    return true;\n}\n```\n\n```go [sol1-Golang]\nfunc sequenceReconstruction(nums []int, sequences [][]int) bool {\n    n := len(nums)\n    g := make([][]int, n+1)\n    inDeg := make([]int, n+1)\n    for _, sequence := range sequences {\n        for i := 1; i < len(sequence); i++ {\n            x, y := sequence[i-1], sequence[i]\n            g[x] = append(g[x], y)\n            inDeg[y]++\n        }\n    }\n\n    q := []int{}\n    for i := 1; i <= n; i++ {\n        if inDeg[i] == 0 {\n            q = append(q, i)\n        }\n    }\n    for len(q) > 0 {\n        if len(q) > 1 {\n            return false\n        }\n        x := q[0]\n        q = q[1:]\n        for _, y := range g[x] {\n            if inDeg[y]--; inDeg[y] == 0 {\n                q = append(q, y)\n            }\n        }\n    }\n    return true\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar sequenceReconstruction = function(nums, sequences) {\n    const n = nums.length;\n    const indegrees = new Array(n + 1).fill(0);\n    const graph = new Array(n + 1).fill(0).map(() => new Set());\n    for (const sequence of sequences) {\n        const size = sequence.length;\n        for (let i = 1; i < size; i++) {\n            const prev = sequence[i - 1], next = sequence[i];\n            if (graph[prev].add(next)) {\n                indegrees[next]++;\n            }\n        }\n    }\n    const queue = [];\n    for (let i = 1; i <= n; i++) {\n        if (indegrees[i] === 0) {\n            queue.push(i);\n        }\n    }\n    while (queue.length) {\n        if (queue.length > 1) {\n            return false;\n        }\n        const num = queue.shift();\n        const set = graph[num];\n        for (const next of set) {\n            indegrees[next]--;\n            if (indegrees[next] === 0) {\n                queue.push(next);\n            }\n        }\n    }\n    return true;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + m)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度，$m$ 是 $\\textit{sequences}$ 中的所有序列长度之和。建图和拓扑排序都需要 $O(n + m)$ 的时间。\n\n- 空间复杂度：$O(n + m)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度，$m$ 是 $\\textit{sequences}$ 中的所有序列长度之和。需要 $O(n + m)$ 的空间存储图信息，需要 $O(n)$ 的空间存储每个结点的入度，拓扑排序过程中队列空间是 $O(n)$。"
}