{
	"titleSlug": "watering-plants-ii",
	"slug": "gei-zhi-wu-jiao-shui-ii-by-leetcode-solu-5cki",
	"url": "https://leetcode-cn.com/problems/watering-plants-ii/solution/gei-zhi-wu-jiao-shui-ii-by-leetcode-solu-5cki/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n我们可以模拟 $\\textit{Alice}$ 与 $\\textit{Bob}$ 浇水的过程，并在模拟的过程中统计重新灌满水罐的次数。\n\n我们用 $\\textit{pos}_a, \\textit{pos}_b$ 分别表示 $\\textit{Alice}$ 与 $\\textit{Bob}$ 当前所在植物的下标，并用 $\\textit{val}_a, \\textit{val}_b$ 分别表示两人水罐中的剩余水量。我们用 $n$ 表示植物的数量，当模拟开始时，$\\textit{Alice}$ 与 $\\textit{Bob}$ 的位置满足 $\\textit{pos}_a = 0, \\textit{pos}_b = n - 1$；剩余水量满足 $\\textit{val}_a = \\textit{capacity}_a, \\textit{val}_b = \\textit{capacity}_b$。\n\n当 $\\textit{Alice}$ 与 $\\textit{Bob}$ **相遇前**的每一个时刻，我们需要模拟两人对当前位置植物浇水的过程。以 $\\textit{Alice}$ 为例，我们比较当前剩余水量 $\\textit{val}_a$ 与植物所需水量 $\\textit{plants}[\\textit{pos}_a]$ 的大小，此时会有两种情况：\n\n- 如果剩余水量大于等于植物所需水量，即 $\\textit{val}_a \\ge \\textit{plants}[\\textit{pos}_a]$，此时不需要重新灌满水罐，浇水后剩余水量变为 $\\textit{val}_a - \\textit{plants}[\\textit{pos}_a]$；\n\n- 如果剩余水量小于等于植物所需水量，即 $\\textit{val}_a < \\textit{plants}[\\textit{pos}_a]$，此时需要先重新灌满水罐，**我们需要将重新灌满水罐的次数加上 $1$**，浇水后剩余水量等于水罐容积减去植物所需水量，即 $\\textit{capacity}_a - \\textit{plants}[\\textit{pos}_a]$。\n\n在浇水操作后，我们需要将 $\\textit{Alice}$ 与 $\\textit{Bob}$ 分别移动至下一株植物的位置，即 $\\textit{pos}_a$ 变为 $\\textit{pos}_a + 1$， $\\textit{pos}_b$ 变为 $\\textit{pos}_b - 1$。\n\n当 $\\textit{Alice}$ 与 $\\textit{Bob}$ **相遇后**，此时根据 $n$ 的奇偶性会有两种情况：\n\n- $n$ 为偶数，相遇后两人所在位置都被浇过水，因此无需任何操作；\n\n- $n$ 为奇数，两人位置重合，且该位置植物未被浇水，此时需要先比较两人的剩余水量，再进行上文的浇水操作并维护重新灌满次数：如果 $\\textit{val}_a \\ge \\textit{val}_b$，则 $\\textit{Alice}$ 浇水，反之则 $\\textit{Bob}$ 浇水。\n\n事实上，对于可能的最后一步操作，我们只需要判断是否需要重新灌满水罐并维护对应次数即可。\n\n模拟结束后，我们返回统计的重新灌满水罐次数作为答案。\n\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\n        int res = 0;   // 灌满水罐次数\n        int n = plants.size();   // 两人位置\n        int posa = 0, posb = n - 1;   // 两人剩余水量\n        int vala = capacityA, valb = capacityB;\n        // 模拟相遇前的浇水过程\n        while (posa < posb) {\n            if (vala < plants[posa]) {\n                ++res;\n                vala = capacityA - plants[posa];\n            }\n            else {\n                vala -= plants[posa];\n            }\n            ++posa;\n            if (valb < plants[posb]) {\n                ++res;\n                valb = capacityB - plants[posb];\n            }\n            else {\n                valb -= plants[posb];\n            }\n            --posb;\n        }\n        // 模拟相遇后可能的浇水过程\n        if (posa == posb) {\n            if (vala >= valb && vala < plants[posa]) {\n                ++res;\n            }\n            if (vala < valb && valb < plants[posb]) {\n                ++res;\n            }\n        }\n        return res;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        res = 0   # 灌满水罐次数\n        n = len(plants)\n        posa, posb = 0, n - 1   # 两人位置\n        vala, valb = capacityA, capacityB   # 两人剩余水量\n        # 模拟相遇前的浇水过程\n        while posa < posb:\n            if vala < plants[posa]:\n                res += 1\n                vala = capacityA - plants[posa]\n            else:\n                vala -= plants[posa]\n            posa += 1\n            if valb < plants[posb]:\n                res += 1\n                valb = capacityB - plants[posb]\n            else:\n                valb -= plants[posb]\n            posb -= 1\n        # 模拟相遇后可能的浇水过程\n        if posa == posb:\n            if vala >= valb and vala < plants[posa]:\n                res += 1\n            elif vala < valb and valb < plants[posb]:\n                res += 1\n        return res\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{plants}$ 的长度。模拟浇水过程并统计重新灌满水罐次数的时间复杂度为 $O(n)$。\n\n- 空间复杂度：$O(1)$。"
}