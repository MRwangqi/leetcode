{
	"titleSlug": "maximum-good-people-based-on-statements",
	"slug": "ji-yu-chen-shu-tong-ji-zui-duo-hao-ren-s-lfn9",
	"url": "https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/solution/ji-yu-chen-shu-tong-ji-zui-duo-hao-ren-s-lfn9/",
	"content": "#### 方法一：使用状态压缩枚举所有可能的情况\n\n**思路与算法**\n\n由于本题中 $n \\leq 15$，因此我们可以使用 $O(2^n)$ 的时间枚举每一种情况：即每个人是好人或坏人有 $2$ 种情况，一共有 $n$ 个人。\n\n我们可以使用状态压缩的方法进行枚举。具体地，我们遍历 $[0, 2^n)$ 中的每一个数 $\\textit{mask}$，$\\textit{mask}$ 的第 $i$ 位为 $1$ 就表示第 $i$ 个人是好人，如果为 $0$ 就表示第 $i$ 个人是坏人。这样我们就可以不重复不遗漏地枚举所有的情况。\n\n在枚举 $\\textit{mask}$ 后，我们可以根据给定的数组 $\\textit{statements}$ 来判断合法性：具体地：\n\n- 如果 $\\textit{statements}[i][j] = 0$，那么 $i$ 认为 $j$ 是坏人，这说明要么 $j$ 是坏人，要么 $i$ 是坏人。因此如果 $i$ 和 $j$ 都是好人，即 $\\textit{mask}$ 的第 $i$ 位和第 $j$ 位都是 $1$，那么就是不合法的；\n\n- 如果 $\\textit{statements}[i][j] = 1$，那么 $i$ 认为 $j$ 是好人，这说明要么 $j$ 是好人，要么 $i$ 是坏人。因此如果 $i$ 是好人并且 $j$ 是坏人，即 $\\textit{mask}$ 的第 $i$ 位是 $1$ 并且第 $j$ 位是 $0$，那么就是不合法的；\n\n- 如果 $\\textit{statements}[i][j] = 2$，那么可以忽略。\n\n因此我们可以在 $O(n^2)$ 的时间内判断 $\\textit{mask}$ 的合法性：如果其合法，我们再统计出其包含的 $1$ 的个数，并更新答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maximumGood(vector<vector<int>>& statements) {\n        int n = statements.size();\n        int ans = 0;\n        for (int mask = 1; mask < (1 << n); ++mask) {\n            bool check = [&]() {\n                for (int i = 0; i < n; ++i) {\n                    for (int j = 0; j < n; ++j) {\n                        if (i == j) {\n                            continue;\n                        }\n                        if (statements[i][j] == 0) {\n                            if ((mask & (1 << i)) && (mask & (1 << j))) {\n                                return false;\n                            }\n                        }\n                        else if (statements[i][j] == 1) {\n                            if ((mask & (1 << i)) && !(mask & (1 << j))) {\n                                return false;\n                            }\n                        }\n                    }\n                }\n                return true;\n            }();\n            if (check) {\n                ans = max(ans, __builtin_popcount(mask));\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def maximumGood(self, statements: List[List[int]]) -> int:\n        n = len(statements)\n        ans = 0\n        for mask in range(1, 1 << n):\n            def check() -> bool:\n                for i in range(n):\n                    for j in range(n):\n                        if i == j:\n                            continue\n                        if statements[i][j] == 0:\n                            if mask & (1 << i) and mask & (1 << j):\n                                return False\n                        elif statements[i][j] == 1:\n                            if mask & (1 << i) and not mask & (1 << j):\n                                return False\n                return True\n            \n            if check():\n                ans = max(ans, bin(mask).count(\"1\"))\n        return ans\n```\n\n```Golang [sol1-Golang]\nfunc maximumGood(statements [][]int) int {\n\tn := len(statements)\n\tans := 0\n\tfor mask := 1; mask < (1 << n); mask++ {\n\t\tcheck := func() bool {\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\tfor j := 0; j < n; j++ {\n\t\t\t\t\tif i == j {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif statements[i][j] == 0 {\n\t\t\t\t\t\tif ((mask & (1 << i)) > 0) && ((mask & (1 << j)) > 0) {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if statements[i][j] == 1 {\n\t\t\t\t\t\tif ((mask & (1 << i)) > 0) && ((mask & (1 << j)) == 0) {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\tif check() {\n\t\t\tans = max(ans, bits.OnesCount(uint(mask)))\n\t\t}\n\t}\n\treturn ans\n}\n\nfunc max(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(2^n \\cdot n^2)$。\n\n- 空间复杂度：$O(1)$。"
}