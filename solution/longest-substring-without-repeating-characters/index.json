{
	"titleSlug": "longest-substring-without-repeating-characters",
	"slug": "hua-dong-chuang-kou-by-powcai",
	"url": "https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/",
	"content": "## 思路：\n\n这道题主要用到思路是：滑动窗口\n\n什么是滑动窗口？\n\n其实就是一个队列,比如例题中的 `abcabcbb`，进入这个队列（**窗口**）为 `abc` 满足题目要求，当再进入 `a`，队列变成了 `abca`，这时候不满足要求。所以，我们要移动这个队列！\n\n如何移动？\n\n我们只要把队列的左边的元素移出就行了，直到满足题目要求！\n\n一直维持这样的队列，找出队列出现最长的长度时候，求出解！\n\n时间复杂度：$O(n)$\n\n\n## 代码：\n\n```Python [1]\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:return 0\n        left = 0\n        lookup = set()\n        n = len(s)\n        max_len = 0\n        cur_len = 0\n        for i in range(n):\n            cur_len += 1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left += 1\n                cur_len -= 1\n            if cur_len > max_len:max_len = cur_len\n            lookup.add(s[i])\n        return max_len\n```\n```C++ [1]\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.size() == 0) return 0;\n        unordered_set<char> lookup;\n        int maxStr = 0;\n        int left = 0;\n        for(int i = 0; i < s.size(); i++){\n            while (lookup.find(s[i]) != lookup.end()){\n                lookup.erase(s[left]);\n                left ++;\n            }\n            maxStr = max(maxStr,i-left+1);\n            lookup.insert(s[i]);\n    }\n        return maxStr;\n        \n    }\n};\n```\n```Java [1]\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s.length()==0) return 0;\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\n        int max = 0;\n        int left = 0;\n        for(int i = 0; i < s.length(); i ++){\n            if(map.containsKey(s.charAt(i))){\n                left = Math.max(left,map.get(s.charAt(i)) + 1);\n            }\n            map.put(s.charAt(i),i);\n            max = Math.max(max,i-left+1);\n        }\n        return max;\n        \n    }\n}\n```\n---------\n\n下面介绍关于滑动窗口的**万能模板**,可以解决相关问题,相信一定可以对滑动窗口有一定了解!\n\n模板虽好,还是少套为好!多思考!更重要!\n\n还有类似题目有:\n\n[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        from collections import defaultdict\n        lookup = defaultdict(int)\n        start = 0\n        end = 0\n        max_len = 0\n        counter = 0\n        while end < len(s):\n            if lookup[s[end]] > 0:\n                counter += 1\n            lookup[s[end]] += 1\n            end += 1\n            while counter > 0:\n                if lookup[s[start]] > 1:\n                    counter -= 1\n                lookup[s[start]] -= 1\n                start += 1\n            max_len = max(max_len, end - start)\n        return max_len\n```\n\n\n\n [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)\n\n```python\nclass Solution:\n    def minWindow(self, s: 'str', t: 'str') -> 'str':\n        from collections import defaultdict\n        lookup = defaultdict(int)\n        for c in t:\n            lookup[c] += 1\n        start = 0\n        end = 0\n        min_len = float(\"inf\")\n        counter = len(t)\n        res = \"\"\n        while end < len(s):\n            if lookup[s[end]] > 0:\n                counter -= 1\n            lookup[s[end]] -= 1\n            end += 1\n            while counter == 0:\n                if min_len > end - start:\n                    min_len = end - start\n                    res = s[start:end]\n                if lookup[s[start]] == 0:\n                    counter += 1\n                lookup[s[start]] += 1\n                start += 1\n        return res\n```\n\n[159. 至多包含两个不同字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/)\n\n```python\nclass Solution:\n    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:\n        from collections import defaultdict\n        lookup = defaultdict(int)\n        start = 0\n        end = 0\n        max_len = 0\n        counter = 0\n        while end < len(s):\n            if lookup[s[end]] == 0:\n                counter += 1\n            lookup[s[end]] += 1\n            end +=1\n            while counter > 2:\n                if lookup[s[start]] == 1:\n                    counter -= 1\n                lookup[s[start]] -= 1\n                start += 1\n            max_len = max(max_len, end - start)\n        return max_len\n```\n\n [340. 至多包含 K 个不同字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/)\n\n```python\nclass Solution:\n    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:\n        from collections import defaultdict\n        lookup = defaultdict(int)\n        start = 0\n        end = 0\n        max_len = 0\n        counter = 0\n        while end < len(s):\n            if lookup[s[end]] == 0:\n                counter += 1\n            lookup[s[end]] += 1\n            end += 1\n            while counter > k:\n                if lookup[s[start]] == 1:\n                    counter -= 1\n                lookup[s[start]] -= 1\n                start += 1\n            max_len = max(max_len, end - start)\n        return max_len\n```\n\n-------------\n滑动窗口题目:\n\n[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n [30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)\n\n [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)\n\n[159. 至多包含两个不同字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/)\n\n [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)\n\n[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)\n\n[567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)\n\n [632. 最小区间](https://leetcode-cn.com/problems/smallest-range/)\n\n [727. 最小窗口子序列](https://leetcode-cn.com/problems/minimum-window-subsequence/)\n\n\n\n\n\n\n\n"
}