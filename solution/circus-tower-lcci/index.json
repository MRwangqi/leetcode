{
	"titleSlug": "circus-tower-lcci",
	"slug": "xian-gen-ju-shen-gao-pai-xu-ruo-shen-gao-yi-yang-z",
	"url": "https://leetcode-cn.com/problems/circus-tower-lcci/solution/xian-gen-ju-shen-gao-pai-xu-ruo-shen-gao-yi-yang-z/",
	"content": "**温馨提示：**\r\n题目要求是“矮一点 且 轻一点”，是严格要求`<`而不是`<=`。\r\n\r\n[官方测试用例](https://leetcode-cn.com/submissions/detail/47937341/testcase/)\r\n\r\n自己可以用来小测的测试用例(答案为`3`而不是`5`)：\r\n```\r\n[1, 2, 2, 2, 3]\r\n[4, 5, 6, 7, 8]\r\n```\r\n\r\n# 思路\r\n题目要求在`2`个维度上(即身高 + 体重)同时保持严格递增。\r\n\r\n那么我们可以先将其中一个维度排好序，以保证在一个维度上保持递增（此时并非严格递增）；\r\n之后就可以专注于处理另一个维度。\r\n\r\n具体而言：\r\n先根据**身高**  **升序排序**，若身高一样则根据**体重**  **降序排序**。\r\n身高排序好之后，剩余待处理的就是体重。\r\n处理体重的问题就是处理[最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)的问题。\r\n\r\n\r\n那么仔细想想为什么身高相同时，**体重**需要**降序排序**呢？\r\n\r\n其实很简单的道理，将**身高相同**的人看成`1`个集合，若他们都按照**体重升序**来排序，则之后的二分法处理中，**有一定的概率**会在这集合中取 **`>= 2` 个人**作为最终结果。\r\n为什么说是“**有一定的概率**会在这集合中取 **`>= 2` 个人**作为最终结果”呢？\r\n比如: \r\n身高:`[1, 2, 2, 3, 4]`\r\n体重:`[1, 3, 4, 5, 7]`\r\n显然，在身高升序排序，且身高相同则体重**升序排序**的**预处理**后，对体重进行二分查找得到的最长递增子序列的结果是`[1, 3, 4, 5, 7]`，而体重为3、4的那2个人身高相同，不符合题意。\r\n比如: \r\n身高:`[1, 2, 2, 3, 4]`\r\n体重:`[4, 1, 2, 5, 7]`\r\n显然，在身高升序排序，且身高相同则体重升序排序的预处理后，对体重进行二分查找得到的最长递增子序列的结果是`[4, 5, 7]`，这其中并没有包含身高为`2`的那`2`个人。(简单说就是运气好罢了，结果刚好符合题意)。\r\n\r\n\r\n因为是**体重升序**，二分法处理时(从左往右遍历)，身高相同的人的集合 **自己本身**也**有可能**构成上升子序列，就使得最终答案内可能包含 身高相同，体重递增的结果。\r\n\r\n\r\n\r\n同样，将**身高相同**的人看成`1`个集合，若他们都按照**体重降序**来排序，在二分法顺序遍历的过程中，是**无法**在这个集合中取 **`>= 2`个人**作为最终结果(即，要么取只能取1人，要么不取)。\r\n因为是**体重降序**，二分法处理时(从左往右遍历)，身高相同的人的集合 **自己本身**是**无法构成**上升子序列，也就**不会出现**最终答案内包含 身高相同，体重递增的情况。\r\n\r\n# 3种写法:\r\n```java [-二分查找法(AC)]\r\nclass Solution {\r\n    public int bestSeqAtIndex(int[] height, int[] weight) {\r\n        int len = height.length;\r\n        int[][] person = new int[len][2];\r\n        for (int i = 0; i < len; ++i)\r\n            person[i] = new int[]{height[i], weight[i]};\r\n        Arrays.sort(person, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\r\n        int[] dp = new int[len];\r\n        int res = 0;\r\n        for (int[] pair : person) {\r\n            int i = Arrays.binarySearch(dp, 0, res, pair[1]);\r\n            if (i < 0)\r\n                i = -(i + 1);\r\n            dp[i] = pair[1];\r\n            if (i == res)\r\n                ++res;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n```java [-记忆+DFS(超时/超内存)]\r\nclass Solution {\r\n    private int[][] person, memo;\r\n    private int len;\r\n\r\n    public int bestSeqAtIndex(int[] height, int[] weight) {\r\n        len = height.length;\r\n        person = new int[len][2];\r\n        for (int i = 0; i < len; ++i)\r\n            person[i] = new int[]{height[i], weight[i]};\r\n\r\n        Arrays.sort(person, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\r\n        memo = new int[len + 1][len];\r\n        for (int[] l : memo)\r\n            Arrays.fill(l, -1);\r\n        return dfs(-1, 0, 0);\r\n    }\r\n\r\n    private int dfs(int pre_idx, int cur_idx, int weight_bound) {\r\n        if (cur_idx == len)\r\n            return 0;\r\n\r\n        if (memo[pre_idx + 1][cur_idx] >= 0)\r\n            return memo[pre_idx + 1][cur_idx];\r\n\r\n        int taken = 0;\r\n        if (pre_idx < 0 || person[cur_idx][1] > weight_bound)\r\n            taken = 1 + dfs(cur_idx, cur_idx + 1, person[cur_idx][1]);\r\n        int not_taken = dfs(pre_idx, cur_idx + 1, weight_bound);\r\n        return memo[pre_idx + 1][cur_idx] = Math.max(taken, not_taken);\r\n    }\r\n}\r\n```\r\n```java [-动态规划(超时)]\r\nclass Solution {\r\n    public int bestSeqAtIndex(int[] height, int[] weight) {\r\n        int len = height.length;\r\n        int[][] person = new int[len][2];\r\n        for (int i = 0; i < len; ++i)\r\n            person[i] = new int[]{height[i], weight[i]};\r\n\r\n        Arrays.sort(person, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\r\n        int[] dp = new int[len];\r\n        dp[0] = 1;\r\n        int res = 1;\r\n        for (int i = 1; i < len; ++i) {\r\n            int max_val = 0, base_weight = person[i][1];\r\n            for (int j = 0; j < i; ++j)\r\n                if (base_weight > person[j][1])\r\n                    max_val = Math.max(max_val, dp[j]);\r\n            dp[i] = max_val + 1;\r\n            res = Math.max(res, dp[i]);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```"
}