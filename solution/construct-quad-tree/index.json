{
	"titleSlug": "construct-quad-tree",
	"slug": "jian-li-si-cha-shu-by-leetcode-solution-gcru",
	"url": "https://leetcode-cn.com/problems/construct-quad-tree/solution/jian-li-si-cha-shu-by-leetcode-solution-gcru/",
	"content": "#### 方法一：递归\n\n**思路与算法**\n\n我们可以使用递归的方法构建出四叉树。\n\n具体地，我们用递归函数 $\\text{dfs}(r_0, c_0, r_1, c_1)$ 处理给定的矩阵 $\\textit{grid}$ 从 $r_0$ 行开始到 $r_1-1$ 行，从 $c_0$ 和 $c_1-1$ 列的部分。我们首先判定这一部分是否均为 $0$ 或 $1$，如果是，那么这一部分对应的是一个叶节点，我们构造出对应的叶节点并结束递归；如果不是，那么这一部分对应的是一个非叶节点，我们需要将其分成四个部分：行的分界线为 $\\dfrac{r_0+r_1}{2}$，列的分界线为 $\\dfrac{c_0+c_1}{2}$，根据这两条分界线递归地调用 $\\text{dfs}$ 函数得到四个部分对应的树，再将它们对应地挂在非叶节点的四个子节点上。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        def dfs(r0: int, c0: int, r1: int, c1: int) -> 'Node':\n            if all(grid[i][j] == grid[r0][c0] for i in range(r0, r1) for j in range(c0, c1)):\n                return Node(grid[r0][c0] == 1, True)\n            return Node(\n                True,\n                False,\n                dfs(r0, c0, (r0 + r1) // 2, (c0 + c1) // 2),\n                dfs(r0, (c0 + c1) // 2, (r0 + r1) // 2, c1),\n                dfs((r0 + r1) // 2, c0, r1, (c0 + c1) // 2),\n                dfs((r0 + r1) // 2, (c0 + c1) // 2, r1, c1),\n            )\n        return dfs(0, 0, len(grid), len(grid))\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    Node *construct(vector<vector<int>> &grid) {\n        function<Node*(int, int, int, int)> dfs = [&](int r0, int c0, int r1, int c1) {\n            for (int i = r0; i < r1; ++i) {\n                for (int j = c0; j < c1; ++j) {\n                    if (grid[i][j] != grid[r0][c0]) { // 不是叶节点\n                        return new Node(\n                                true,\n                                false,\n                                dfs(r0, c0, (r0 + r1) / 2, (c0 + c1) / 2),\n                                dfs(r0, (c0 + c1) / 2, (r0 + r1) / 2, c1),\n                                dfs((r0 + r1) / 2, c0, r1, (c0 + c1) / 2),\n                                dfs((r0 + r1) / 2, (c0 + c1) / 2, r1, c1)\n                        );\n                    }\n                }\n            }\n            // 是叶节点\n            return new Node(grid[r0][c0], true);\n        };\n        return dfs(0, 0, grid.size(), grid.size());\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public Node construct(int[][] grid) {\n        return dfs(grid, 0, 0, grid.length, grid.length);\n    }\n\n    public Node dfs(int[][] grid, int r0, int c0, int r1, int c1) {\n        boolean same = true;\n        for (int i = r0; i < r1; ++i) {\n            for (int j = c0; j < c1; ++j) {\n                if (grid[i][j] != grid[r0][c0]) {\n                    same = false;\n                    break;\n                }\n            }\n            if (!same) {\n                break;\n            }\n        }\n\n        if (same) {\n            return new Node(grid[r0][c0] == 1, true);\n        }\n\n        Node ret = new Node(\n            true,\n            false,\n            dfs(grid, r0, c0, (r0 + r1) / 2, (c0 + c1) / 2),\n            dfs(grid, r0, (c0 + c1) / 2, (r0 + r1) / 2, c1),\n            dfs(grid, (r0 + r1) / 2, c0, r1, (c0 + c1) / 2),\n            dfs(grid, (r0 + r1) / 2, (c0 + c1) / 2, r1, c1)\n        );\n        return ret;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public Node Construct(int[][] grid) {\n        return DFS(grid, 0, 0, grid.Length, grid.Length);\n    }\n\n    public Node DFS(int[][] grid, int r0, int c0, int r1, int c1) {\n        bool same = true;\n        for (int i = r0; i < r1; ++i) {\n            for (int j = c0; j < c1; ++j) {\n                if (grid[i][j] != grid[r0][c0]) {\n                    same = false;\n                    break;\n                }\n            }\n            if (!same) {\n                break;\n            }\n        }\n\n        if (same) {\n            return new Node(grid[r0][c0] == 1, true);\n        }\n\n        Node ret = new Node(\n            true,\n            false,\n            DFS(grid, r0, c0, (r0 + r1) / 2, (c0 + c1) / 2),\n            DFS(grid, r0, (c0 + c1) / 2, (r0 + r1) / 2, c1),\n            DFS(grid, (r0 + r1) / 2, c0, r1, (c0 + c1) / 2),\n            DFS(grid, (r0 + r1) / 2, (c0 + c1) / 2, r1, c1)\n        );\n        return ret;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc construct(grid [][]int) *Node {\n    var dfs func([][]int, int, int) *Node\n    dfs = func(rows [][]int, c0, c1 int) *Node {\n        for _, row := range rows {\n            for _, v := range row[c0:c1] {\n                if v != rows[0][c0] { // 不是叶节点\n                    rMid, cMid := len(rows)/2, (c0+c1)/2\n                    return &Node{\n                        true,\n                        false,\n                        dfs(rows[:rMid], c0, cMid),\n                        dfs(rows[:rMid], cMid, c1),\n                        dfs(rows[rMid:], c0, cMid),\n                        dfs(rows[rMid:], cMid, c1),\n                    }\n                }\n            }\n        }\n        // 是叶节点\n        return &Node{Val: rows[0][c0] == 1, IsLeaf: true}\n    }\n    return dfs(grid, 0, len(grid))\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar construct = function(grid) {\n    return dfs(grid, 0, 0, grid.length, grid.length);\n};\n\nconst dfs = (grid, r0, c0, r1, c1) => {\n    let same = true;\n    for (let i = r0; i < r1; ++i) {\n        for (let j = c0; j < c1; ++j) {\n            if (grid[i][j] !== grid[r0][c0]) {\n                same = false;\n                break;\n            }\n        }\n        if (!same) {\n            break;\n        }\n    }\n\n    if (same) {\n        return new Node(grid[r0][c0] === 1, true);\n    }\n\n    const ret = new Node(\n        true,\n        false,\n        dfs(grid, r0, c0, Math.floor((r0 + r1) / 2), Math.floor((c0 + c1) / 2)),\n        dfs(grid, r0, Math.floor((c0 + c1) / 2), Math.floor((r0 + r1) / 2), c1),\n        dfs(grid, Math.floor((r0 + r1) / 2), c0, r1, Math.floor((c0 + c1) / 2)),\n        dfs(grid, Math.floor((r0 + r1) / 2), Math.floor((c0 + c1) / 2), r1, c1)\n    );\n    return ret;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2 \\log n)$。这里给出一个较为宽松的时间复杂度上界。记 $T(n)$ 为边长为 $n$ 的数组需要的时间复杂度，那么「判定这一部分是否均为 $0$ 或 $1$」需要的时间为 $O(n^2)$，在这之后会递归调用 $4$ 规模为 $n/2$ 的子问题，那么有：\n\n    $$\n    T(n) = 4T(n/2) + O(n^2)\n    $$\n\n    以及：\n\n    $$\n    T(1) = O(1)\n    $$\n\n    根据主定理，可以得到 $T(n) = O(n^2 \\log n)$。但如果判定需要的时间达到了渐近紧界 $\\Theta(n^2)$，那么说明这一部分包含的元素大部分都是相同的，也就是说，有很大概率在深入递归时遇到元素完全相同的一部分，从而提前结束递归。因此 $O(n^2 \\log n)$ 的时间复杂度是很宽松的，实际运行过程中可以跑出与方法二 $O(n^2)$ 时间复杂度代码相似的速度。\n\n- 空间复杂度：$O(\\log n)$，即为递归需要使用的栈空间。\n\n#### 方法二：递归 + 二维前缀和优化\n\n**思路与算法**\n\n我们可以对方法一中暴力判定某一部分是否均为 $0$ 或 $1$ 的代码进行优化。\n\n具体地，当某一部分均为 $0$ 时，它的和为 $0$；某一部分均为 $1$ 时，它的和为这一部分的面积大小。因此我们可以使用二维前缀和（参考[「304. 二维区域和检索 - 矩阵不可变」](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)）进行优化。我们可以与处理出数组 $\\textit{grid}$ 的二维前缀和，这样一来，当我们需要判定某一部分是否均为 $0$ 或 $1$ 时，可以在 $O(1)$ 的时间内得到这一部分的和，从而快速地进行判断。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        n = len(grid)\n        pre = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + grid[i - 1][j - 1]\n\n        def getSum(r0: int, c0: int, r1: int, c1: int) -> int:\n            return pre[r1][c1] - pre[r1][c0] - pre[r0][c1] + pre[r0][c0]\n\n        def dfs(r0: int, c0: int, r1: int, c1: int) -> 'Node':\n            total = getSum(r0, c0, r1, c1)\n            if total == 0:\n                return Node(False, True)\n            if total == (r1 - r0) * (c1 - c0):\n                return Node(True, True)\n            return Node(\n                True,\n                False,\n                dfs(r0, c0, (r0 + r1) // 2, (c0 + c1) // 2),\n                dfs(r0, (c0 + c1) // 2, (r0 + r1) // 2, c1),\n                dfs((r0 + r1) // 2, c0, r1, (c0 + c1) // 2),\n                dfs((r0 + r1) // 2, (c0 + c1) // 2, r1, c1),\n            )\n\n        return dfs(0, 0, n, n)\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    Node *construct(vector<vector<int>> &grid) {\n        int n = grid.size();\n        vector<vector<int>> pre(n + 1, vector<int>(n + 1));\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n\n        auto getSum = [&](int r0, int c0, int r1, int c1) {\n            return pre[r1][c1] - pre[r1][c0] - pre[r0][c1] + pre[r0][c0];\n        };\n\n        function<Node *(int, int, int, int)> dfs = [&](int r0, int c0, int r1, int c1) {\n            int total = getSum(r0, c0, r1, c1);\n            if (total == 0) {\n                return new Node(false, true);\n            }\n            if (total == (r1 - r0) * (c1 - c0)) {\n                return new Node(true, true);\n            }\n            return new Node(\n                    true,\n                    false,\n                    dfs(r0, c0, (r0 + r1) / 2, (c0 + c1) / 2),\n                    dfs(r0, (c0 + c1) / 2, (r0 + r1) / 2, c1),\n                    dfs((r0 + r1) / 2, c0, r1, (c0 + c1) / 2),\n                    dfs((r0 + r1) / 2, (c0 + c1) / 2, r1, c1)\n            );\n        };\n\n        return dfs(0, 0, n, n);\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public Node construct(int[][] grid) {\n        int n = grid.length;\n        int[][] pre = new int[n + 1][n + 1];\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        return dfs(grid, pre, 0, 0, n, n);\n    }\n\n    public Node dfs(int[][] grid, int[][] pre, int r0, int c0, int r1, int c1) {\n        int total = getSum(pre, r0, c0, r1, c1);\n        if (total == 0) {\n            return new Node(false, true);\n        } else if (total == (r1 - r0) * (c1 - c0)) {\n            return new Node(true, true);\n        }\n\n        Node ret = new Node(\n            true,\n            false,\n            dfs(grid, pre, r0, c0, (r0 + r1) / 2, (c0 + c1) / 2),\n            dfs(grid, pre, r0, (c0 + c1) / 2, (r0 + r1) / 2, c1),\n            dfs(grid, pre, (r0 + r1) / 2, c0, r1, (c0 + c1) / 2),\n            dfs(grid, pre, (r0 + r1) / 2, (c0 + c1) / 2, r1, c1)\n        );\n        return ret;\n    }\n\n    public int getSum(int[][] pre, int r0, int c0, int r1, int c1) {\n        return pre[r1][c1] - pre[r1][c0] - pre[r0][c1] + pre[r0][c0];\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public Node Construct(int[][] grid) {\n        int n = grid.Length;\n        int[][] pre = new int[n + 1][];\n        for (int i = 0; i <= n; ++i) {\n            pre[i] = new int[n + 1];\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        return DFS(grid, pre, 0, 0, n, n);\n    }\n\n    public Node DFS(int[][] grid, int[][] pre, int r0, int c0, int r1, int c1) {\n        int total = GetSum(pre, r0, c0, r1, c1);\n        if (total == 0) {\n            return new Node(false, true);\n        } else if (total == (r1 - r0) * (c1 - c0)) {\n            return new Node(true, true);\n        }\n\n        Node ret = new Node(\n            true,\n            false,\n            DFS(grid, pre, r0, c0, (r0 + r1) / 2, (c0 + c1) / 2),\n            DFS(grid, pre, r0, (c0 + c1) / 2, (r0 + r1) / 2, c1),\n            DFS(grid, pre, (r0 + r1) / 2, c0, r1, (c0 + c1) / 2),\n            DFS(grid, pre, (r0 + r1) / 2, (c0 + c1) / 2, r1, c1)\n        );\n        return ret;\n    }\n\n    public int GetSum(int[][] pre, int r0, int c0, int r1, int c1) {\n        return pre[r1][c1] - pre[r1][c0] - pre[r0][c1] + pre[r0][c0];\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc construct(grid [][]int) *Node {\n    n := len(grid)\n    pre := make([][]int, n+1)\n    pre[0] = make([]int, n+1)\n    for i, row := range grid {\n        pre[i+1] = make([]int, n+1)\n        for j, v := range row {\n            pre[i+1][j+1] = pre[i+1][j] + pre[i][j+1] - pre[i][j] + v\n        }\n    }\n\n    var dfs func(r0, c0, r1, c1 int) *Node\n    dfs = func(r0, c0, r1, c1 int) *Node {\n        total := pre[r1][c1] - pre[r1][c0] - pre[r0][c1] + pre[r0][c0]\n        if total == 0 {\n            return &Node{Val: false, IsLeaf: true}\n        }\n        if total == (r1-r0)*(c1-c0) {\n            return &Node{Val: true, IsLeaf: true}\n        }\n        rMid, cMid := (r0+r1)/2, (c0+c1)/2\n        return &Node{\n            true,\n            false,\n            dfs(r0, c0, rMid, cMid),\n            dfs(r0, cMid, rMid, c1),\n            dfs(rMid, c0, r1, cMid),\n            dfs(rMid, cMid, r1, c1),\n        }\n    }\n    return dfs(0, 0, n, n)\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar construct = function(grid) {\n    const n = grid.length;\n    const pre = new Array(n + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 1; j <= n; ++j) {\n            pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + grid[i - 1][j - 1];\n        }\n    }\n    return dfs(grid, pre, 0, 0, n, n);\n};\n\nconst dfs = (grid, pre, r0, c0, r1, c1) => {\n    const total = getSum(pre, r0, c0, r1, c1);\n    if (total === 0) {\n        return new Node(false, true);\n    } else if (total === (r1 - r0) * (c1 - c0)) {\n        return new Node(true, true);\n    }\n\n    const ret = new Node(\n        true,\n        false,\n        dfs(grid, pre, r0, c0, Math.floor((r0 + r1) / 2), Math.floor((c0 + c1) / 2)),\n        dfs(grid, pre, r0, Math.floor((c0 + c1) / 2), Math.floor((r0 + r1) / 2), c1),\n        dfs(grid, pre, Math.floor((r0 + r1) / 2), c0, r1, Math.floor((c0 + c1) / 2)),\n        dfs(grid, pre, Math.floor((r0 + r1) / 2), Math.floor((c0 + c1) / 2), r1, c1)\n    );\n    return ret;\n}\n\nconst getSum = (pre, r0, c0, r1, c1) => {\n    return pre[r1][c1] - pre[r1][c0] - pre[r0][c1] + pre[r0][c0];\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$。在最坏情况下，数组 $\\textit{grid}$ 中交替出现 $0$ 和 $1$，此时每一个叶节点对应着 $1 \\times 1$ 的区域。记 $T(n)$ 为边长为 $n$ 的数组需要的时间复杂度，那么有： \n\n    $$\n    T(n) = 4T(n/2) + O(1)\n    $$\n\n    以及：\n\n    $$\n    T(1) = O(1)\n    $$\n\n    根据主定理，可以得到 $T(n) = O(n^2)$。预处理二维前缀和需要的时间也为 $O(n^2)$，因此总时间复杂度为 $O(n^2)$。\n\n- 空间复杂度：$O(n^2)$，即为二维前缀和需要使用的空间。"
}