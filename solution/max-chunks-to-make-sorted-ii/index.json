{
	"titleSlug": "max-chunks-to-make-sorted-ii",
	"slug": "zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-w5c6",
	"url": "https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-w5c6/",
	"content": "#### 方法一：排序 + 哈希表\n\n**思路**\n\n记数组 $\\textit{arr}$ 长度为 $n$，排完序的数组为 $\\textit{sortedArr}$。首先，将原数组分为一块，肯定是可行的。原数组直接排序，和将它分为一块后再排序，得到的数组是相同的。那么，如何判断一个数组是否能分为符合题意的两块呢？如果一个数组能分为两块，那么一定能找到一个下标 $k$，这个下标将数组分为两个非空子数组 $arr[0, \\ldots, k]$ 和 $arr[k+1, \\ldots, n-1]$，使得 $arr[0, \\ldots, k]$ 和 $sortedArr[0, \\ldots, k]$ 的元素频次相同，$arr[k+1, \\ldots, n-1]$ 和 $sortedArr[k+1, \\ldots, n-1]$ 的元素频次相同。判断能否分为更多的块时同理。这个判断过程可以从左至右同时遍历 $\\textit{arr}$ 和 $\\textit{sortedArr}$，并用一个哈希表 $\\textit{cnt}$ 来记录两个数组元素频次之差。当遍历到某个下标时，如果 $\\textit{cnt}$ 内所有键的值均为 $0$，则表示划分出了一个新的块，最后记录有多少下标可以使得 $\\textit{cnt}$ 内所有键的值均为 $0$ 即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        cnt = Counter()\n        res = 0\n        for x, y in zip(arr, sorted(arr)):\n            cnt[x] += 1\n            if cnt[x] == 0:\n                del cnt[x]\n            cnt[y] -= 1\n            if cnt[y] == 0:\n                del cnt[y]\n            if len(cnt) == 0:\n                res += 1\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        int res = 0;\n        int[] sortedArr = new int[arr.length];\n        System.arraycopy(arr, 0, sortedArr, 0, arr.length);\n        Arrays.sort(sortedArr);\n        for (int i = 0; i < sortedArr.length; i++) {\n            int x = arr[i], y = sortedArr[i];\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n            if (cnt.get(x) == 0) {\n                cnt.remove(x);\n            }\n            cnt.put(y, cnt.getOrDefault(y, 0) - 1);\n            if (cnt.get(y) == 0) {\n                cnt.remove(y);\n            }\n            if (cnt.isEmpty()) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MaxChunksToSorted(int[] arr) {\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        int res = 0;\n        int[] sortedArr = new int[arr.Length];\n        Array.Copy(arr, 0, sortedArr, 0, arr.Length);\n        Array.Sort(sortedArr);\n        for (int i = 0; i < sortedArr.Length; i++) {\n            int x = arr[i], y = sortedArr[i];\n            if (!cnt.ContainsKey(x)) {\n                cnt.Add(x, 0);\n            }\n            cnt[x]++;\n            if (cnt[x] == 0) {\n                cnt.Remove(x);\n            }\n            if (!cnt.ContainsKey(y)) {\n                cnt.Add(y, 0);\n            }\n            cnt[y]--;\n            if (cnt[y] == 0) {\n                cnt.Remove(y);\n            }\n            if (cnt.Count == 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        unordered_map<int, int> cnt;\n        int res = 0;\n        vector<int> sortedArr = arr;\n        sort(sortedArr.begin(), sortedArr.end());\n        for (int i = 0; i < sortedArr.size(); i++) {\n            int x = arr[i], y = sortedArr[i];\n            cnt[x]++;\n            if (cnt[x] == 0) {\n                cnt.erase(x);\n            }\n            cnt[y]--;\n            if (cnt[y] == 0) {\n                cnt.erase(y);\n            }\n            if (cnt.size() == 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} HashItem;\n\nstatic inline int cmp(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint maxChunksToSorted(int* arr, int arrSize){\n    HashItem *cnt = NULL;\n    int res = 0;\n    int *sortedArr = (int *)malloc(sizeof(int) * arrSize);\n    memcpy(sortedArr, arr, sizeof(int) * arrSize);\n    qsort(sortedArr, arrSize, sizeof(int), cmp);\n    for (int i = 0; i < arrSize; i++) {\n        int x = arr[i], y = sortedArr[i];\n        HashItem *pEntry = NULL;\n        HASH_FIND_INT(cnt, &x, pEntry);\n        if (pEntry == NULL) {\n            pEntry = (HashItem *)malloc(sizeof(HashItem));\n            pEntry->key = x;\n            pEntry->val = 0;\n            HASH_ADD_INT(cnt, key, pEntry);\n        }\n        pEntry->val++;\n        if (pEntry->val == 0) {\n            HASH_DEL(cnt, pEntry);\n            free(pEntry);\n        }\n        pEntry = NULL;\n        HASH_FIND_INT(cnt, &y, pEntry);\n        if (pEntry == NULL) {\n            pEntry = (HashItem *)malloc(sizeof(HashItem));\n            pEntry->key = y;\n            pEntry->val = 0;\n            HASH_ADD_INT(cnt, key, pEntry);\n        }\n        pEntry->val--;\n        if (pEntry->val == 0) {\n            HASH_DEL(cnt, pEntry);\n            free(pEntry);\n        }\n        if (HASH_COUNT(cnt) == 0) {\n            res++;\n        }\n    }\n    HashItem *cur = NULL, *tmp = NULL;\n    HASH_ITER(hh, cnt, cur, tmp) {\n        HASH_DEL(cnt, cur);  \n        free(cur);  \n    }\n    return res;\n}\n```\n\n```go [sol1-Golang]\nfunc maxChunksToSorted(arr []int) (ans int) {\n    cnt := map[int]int{}\n    b := append([]int{}, arr...)\n    sort.Ints(b)\n    for i, x := range arr {\n        cnt[x]++\n        if cnt[x] == 0 {\n            delete(cnt, x)\n        }\n        y := b[i]\n        cnt[y]--\n        if cnt[y] == 0 {\n            delete(cnt, y)\n        }\n        if len(cnt) == 0 {\n            ans++\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maxChunksToSorted = function(arr) {\n    const cnt = new Map();\n    let res = 0;\n    const sortedArr = new Array(arr.length).fill(0);\n    sortedArr.splice(0, arr.length, ...arr);\n    sortedArr.sort((a, b) => a - b);\n    for (let i = 0; i < sortedArr.length; i++) {\n        const x = arr[i], y = sortedArr[i];\n        cnt.set(x, (cnt.get(x) || 0) + 1);\n        if (cnt.get(x) === 0) {\n            cnt.delete(x);\n        }\n        cnt.set(y, (cnt.get(y) || 0) - 1);\n        if (cnt.get(y) === 0) {\n            cnt.delete(y);\n        }\n        if (cnt.size === 0) {\n            res++;\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是输入数组 $\\textit{arr}$ 的长度。排序需要消耗 $O(n \\log n)$ 的时间复杂度，遍历一遍消耗 $O(n)$ 的时间复杂度。\n\n- 空间复杂度：$O(n)$。排序完的数组和哈希表均需要消耗 $O(n)$ 的空间复杂度。\n\n#### 方法二：单调栈\n\n**思路**\n\n对于已经分好块的数组，若块数大于 $1$，则可以得到以下结论：右边的块的所有数字均大于或等于左边的块的所有数字。考虑这个问题：对于已经分好块的数组，若在其末尾添加一个数字，如何求得新数组的分块方式？\n\n新添加的数字可能会改变原数组的分块方式。如果新添加的数字大于或等于原数组最后一个块的最大值，则这个新添加的数字可以自己形成一个块。如果新添加的数字小于原数组最后一个块的最大值，则它必须融入最后一个块。如果它大于或等于原数组倒数第二个块（如果有）的最大值，那么这个过程可以停止，新数组的分块方式已经求得。否则，它将继续融合原数组倒数第二个块，直到遇到一个块，使得该块的最大值小于或等于这个新添加的数，或者这个数字已经融合了所有块。\n\n上述分析过程中，我们只用到了块的最大值来进行比较，比较过程又是从右到左，符合栈的思想，因此可以用类似单调栈的数据结构来存储块的最大值。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for a in arr:\n            if len(stack) == 0 or a >= stack[-1]:\n                stack.append(a)\n            else:\n                mx = stack.pop()\n                while stack and stack[-1] > a:\n                    stack.pop()\n                stack.append(mx)\n        return len(stack)\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int MaxChunksToSorted(int[] arr) {\n        Stack<int> stack = new Stack<int>();\n        foreach (int num in arr) {\n            if (stack.Count == 0 || num >= stack.Peek()) {\n                stack.Push(num);\n            } else {\n                int mx = stack.Pop();\n                while (stack.Count > 0 && stack.Peek() > num) {\n                    stack.Pop();\n                }\n                stack.Push(mx);\n            }\n        }\n        return stack.Count;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> st;\n        for (auto &num : arr) {\n            if (st.empty() || num >= st.top()) {\n                st.emplace(num);\n            } else {\n                int mx = st.top();\n                st.pop();\n                while (!st.empty() && st.top() > num) {\n                    st.pop();\n                }\n                st.emplace(mx);\n            }\n        }\n        return st.size();\n    }\n};\n```\n\n```C [sol2-C]\nint maxChunksToSorted(int* arr, int arrSize){\n    int *stack = (int *)malloc(sizeof(int) * arrSize);\n    int top = 0;\n    for (int i = 0; i < arrSize; i++) {\n        int num = arr[i];\n        if (top == 0 || num >= stack[top - 1]) {\n            stack[top++] = num;\n        } else {\n            int mx = stack[top - 1];\n            top--;\n            while (top > 0 && stack[top - 1] > num) {\n                top--;\n            }\n            stack[top++] = mx;\n        }\n    }\n    free(stack);\n    return top;\n}\n```\n\n```go [sol2-Golang]\nfunc maxChunksToSorted(arr []int) int {\n    st := []int{}\n    for _, x := range arr {\n        if len(st) == 0 || x >= st[len(st)-1] {\n            st = append(st, x)\n        } else {\n            mx := st[len(st)-1]\n            st = st[:len(st)-1]\n            for len(st) > 0 && st[len(st)-1] > x {\n                st = st[:len(st)-1]\n            }\n            st = append(st, mx)\n        }\n    }\n    return len(st)\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n    for (const num of arr) {\n        if (stack.length === 0 || num >= stack[stack.length - 1]) {\n            stack.push(num);\n        } else {\n            const mx = stack.pop();\n            while (stack.length && stack[stack.length - 1] > num) {\n                stack.pop();\n            }\n            stack.push(mx);\n        }\n    }\n    return stack.length;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是输入数组 $\\textit{arr}$ 的长度。需要遍历一遍数组，入栈的操作最多为 $n$ 次。\n\n- 空间复杂度：$O(n)$。栈的长度最多为 $n$。"
}