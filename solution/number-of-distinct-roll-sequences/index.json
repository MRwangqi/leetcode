{
	"titleSlug": "number-of-distinct-roll-sequences",
	"slug": "by-endlesscheng-tgkn",
	"url": "https://leetcode-cn.com/problems/number-of-distinct-roll-sequences/solution/by-endlesscheng-tgkn/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV143411w7Wx) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n## 方法一：三维 DP\r\n\r\n#### 提示 1\r\n\r\n序列计数问题，先往 DP 上想。\r\n\r\n#### 提示 2\r\n\r\n只定义 $f[i]$ 一个维度够吗（$i$ 表示序列长度）？\r\n\r\n不够，没法准确统计满足题目第二个要求的序列个数。\r\n\r\n注意到序列的元素只有 $1$ 到 $6$，我们可以把元素值也作为状态。\r\n\r\n#### 提示 3\r\n\r\n定义 $f[i][\\textit{last}][\\textit{last}_2]$ 表示序列长度为 $i$，最后一个元素是 $\\textit{last}$，倒数第二个元素是 $\\textit{last}_2$ 的序列数目。\r\n\r\n通过枚举 $\\textit{last}$ 和 $\\textit{last}_2$，我们可以计算出 $f[i+1][j][\\textit{last}]$，需满足\r\n\r\n- $\\text{GCD}(\\textit{last},j)=1$（也可以写成 $\\textit{last}\\perp j$）\r\n- $\\textit{last}\\ne j$\r\n- $\\textit{last}_2\\ne j$\r\n\r\n累加这些 $f[i][\\textit{last}][\\textit{last}_2]$，即得到 $f[i+1][j][\\textit{last}]$。\r\n\r\n答案为 $\\sum\\limits_{i}\\sum\\limits_{j} f[n][i][j]$。\r\n\r\n代码实现时，可以将这些值在外部预计算出来，避免每次都重复计算一遍。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(nm^3)$，这里 $m=6$。求 $\\text{GCD}$ 的时间忽略不计（也可以打表预处理出互质的数字）。\r\n- 空间复杂度：$O(nm^2)$。\r\n\r\n```Python [sol1-Python3]\r\nMOD, MX = 10 ** 9 + 7, 10 ** 4\r\nf = [[[0] * 6 for _ in range(6)] for _ in range(MX + 1)]\r\nf[2] = [[int(j != i and gcd(j + 1, i + 1) == 1) for j in range(6)] for i in range(6)]\r\nfor i in range(2, MX):\r\n    for j in range(6):\r\n        for last in range(6):\r\n            if last != j and gcd(last + 1, j + 1) == 1:\r\n                f[i + 1][j][last] = sum(f[i][last][last2] for last2 in range(6) if last2 != j) % MOD\r\n\r\nclass Solution:\r\n    def distinctSequences(self, n: int) -> int:\r\n        return sum(sum(row) for row in f[n]) % MOD if n > 1 else 6\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    static final int MOD = (int) 1e9 + 7, MX = (int) 1e4;\r\n    static final int[][][] f = new int[MX + 1][6][6];\r\n\r\n    static {\r\n        for (var i = 0; i < 6; ++i)\r\n            for (var j = 0; j < 6; ++j)\r\n                if (j != i && gcd(j + 1, i + 1) == 1)\r\n                    f[2][i][j] = 1;\r\n        for (var i = 2; i < MX; ++i)\r\n            for (var j = 0; j < 6; ++j)\r\n                for (var last = 0; last < 6; ++last)\r\n                    if (last != j && gcd(last + 1, j + 1) == 1)\r\n                        for (var last2 = 0; last2 < 6; ++last2)\r\n                            if (last2 != j)\r\n                                f[i + 1][j][last] = (f[i + 1][j][last] + f[i][last][last2]) % MOD;\r\n    }\r\n\r\n    public int distinctSequences(int n) {\r\n        if (n == 1) return 6;\r\n        var ans = 0;\r\n        for (var i = 0; i < 6; ++i)\r\n            for (var j = 0; j < 6; ++j)\r\n                ans = (ans + f[n][i][j]) % MOD;\r\n        return ans;\r\n    }\r\n\r\n    static int gcd(int a, int b) {\r\n        return b == 0 ? a : gcd(b, a % b);\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nconst int MOD = 1e9 + 7, MX = 1e4;\r\nint f[MX + 1][6][6];\r\nint init = []() {\r\n    for (int i = 0; i < 6; ++i)\r\n        for (int j = 0; j < 6; ++j)\r\n            f[2][i][j] = j != i && gcd(j + 1, i + 1) == 1;\r\n    for (int i = 2; i < MX; ++i)\r\n        for (int j = 0; j < 6; ++j)\r\n            for (int last = 0; last < 6; ++last)\r\n                if (last != j && gcd(last + 1, j + 1) == 1)\r\n                    for (int last2 = 0; last2 < 6; ++last2)\r\n                        if (last2 != j)\r\n                            f[i + 1][j][last] = (f[i + 1][j][last] + f[i][last][last2]) % MOD;\r\n    return 0;\r\n}();\r\n\r\nclass Solution {\r\npublic:\r\n    int distinctSequences(int n) {\r\n        if (n == 1) return 6;\r\n        int ans = 0;\r\n        for (int i = 0; i < 6; ++i)\r\n            for (int j = 0; j < 6; ++j)\r\n                ans = (ans + f[n][i][j]) % MOD;\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nconst mod int = 1e9 + 7\r\nvar f = [1e4 + 1][6][6]int{}\r\n\r\nfunc init() {\r\n\tfor last := 0; last < 6; last++ {\r\n\t\tfor last2 := 0; last2 < 6; last2++ {\r\n\t\t\tif last2 != last && gcd(last2+1, last+1) == 1 {\r\n\t\t\t\tf[2][last][last2] = 1\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor i := 2; i < 1e4; i++ {\r\n\t\tfor j := 0; j < 6; j++ {\r\n\t\t\tfor last := 0; last < 6; last++ {\r\n\t\t\t\tif last != j && gcd(last+1, j+1) == 1 {\r\n\t\t\t\t\tfor last2 := 0; last2 < 6; last2++ {\r\n\t\t\t\t\t\tif last2 != j {\r\n\t\t\t\t\t\t\tf[i+1][j][last] = (f[i+1][j][last] + f[i][last][last2]) % mod\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc distinctSequences(n int) (ans int) {\r\n\tif n == 1 {\r\n\t\treturn 6\r\n\t}\r\n\tfor _, row := range f[n] {\r\n\t\tfor _, v := range row {\r\n\t\t\tans = (ans + v) % mod\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc gcd(a, b int) int {\r\n\tfor a != 0 {\r\n\t\ta, b = b%a, a\r\n\t}\r\n\treturn b\r\n}\r\n```\r\n\r\n附：Python 记忆化写法\r\n\r\n```py\r\n@cache\r\ndef f(n: int, last: int, last2: int) -> int:\r\n    if n == 0: return 1\r\n    res = 0\r\n    for j in range(1, 7):\r\n        if j != last and j != last2 and gcd(j, last) == 1:\r\n            res += f(n - 1, j, last)\r\n    return res % (10 ** 9 + 7)\r\n\r\nclass Solution:\r\n    def distinctSequences(self, n: int) -> int:\r\n        return f(n, 7, 7)  # 7 与 [1,6] 内的数字都不同且互质\r\n```\r\n\r\n## 方法二：二维 DP\r\n\r\n定义 $f[i][j]$ 表示序列长度为 $i$，最后一个元素是 $j$ 时的序列个数。\r\n\r\n类似方法一，我们可以枚举前一个元素 $k$，需满足\r\n\r\n- $k\\ne j$\r\n- $k\\perp j$\r\n\r\n以 $f[i][4]$ 为例，$k$ 为 $1$、$3$ 和 $5$，如果直接把这些 $f[i-1][1/3/5]$ 转移到 $f[i][4]$ 上，我们会得到一个错误的转移方程\r\n\r\n$$\r\nf[i][4] = \\sum\r\n\\begin{cases}\r\nf[i-1][1]\\\\\r\nf[i-1][3]\\\\\r\nf[i-1][5]\r\n\\end{cases}\r\n$$\r\n\r\n原因在于**前前**一个元素不能为 $4$，而我们在计算 $f[i-1][1/3/5]$ 时，它的前一个元素是可以为 $4$ 的。\r\n\r\n顺着这个思路，如果把 $f[i-2][4]$ 都减掉，我们仍然会得到一个错误的转移方程\r\n\r\n$$\r\nf[i][4] = \\sum\r\n\\begin{cases}\r\nf[i-1][1]-f[i-2][4]\\\\\r\nf[i-1][3]-f[i-2][4]\\\\\r\nf[i-1][5]-f[i-2][4]\r\n\\end{cases}\r\n$$\r\n\r\n这是因为：\r\n\r\n- $f[i-1][1]$ 对应的序列，不包含第 $i-3$ 个数为 $1$ 的情况；\r\n- $f[i-1][3]$ 对应的序列，不包含第 $i-3$ 个数为 $3$ 的情况；\r\n- $f[i-1][5]$ 对应的序列，不包含第 $i-3$ 个数为 $5$ 的情况；\r\n- $f[i-2][4]$ 对应的序列，**包含第 $i-3$ 个数为 $1/3/5$ 的情况**。\r\n\r\n如果照这样计算，又要把这些多减去的部分重新加回来，那岂不是要一直加减加减下去？\r\n\r\n仔细想想，上面加粗的文字所对应的序列，又恰好组成了一个 $f[i-2][4]$，所以只需要再多加一个 $f[i-2][4]$，就能得到正确的转移方程\r\n\r\n$$\r\nf[i][4] = \\left(\\sum\r\n\\begin{cases}\r\nf[i-1][1]-f[i-2][4]\\\\\r\nf[i-1][3]-f[i-2][4]\\\\\r\nf[i-1][5]-f[i-2][4]\r\n\\end{cases}\\right) + f[i-2][4]\r\n$$\r\n\r\n一般地，转移方程为\r\n\r\n$$\r\nf[i][j] = \\left(\\sum_{\\substack{k\\ne j\\\\ k\\perp j}} (f[i-1][k]-f[i-2][j])\\right) + f[i-2][j]\r\n$$\r\n\r\n一个特殊的边界是当 $i=3$ 时，$i-3$ 不存在，故不需要再多加一个 $f[i-2][j]$。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(nm^2)$，这里 $m=6$。求 $\\text{GCD}$ 的时间忽略不计（也可以打表预处理出互质的数字）。\r\n- 空间复杂度：$O(nm)$。\r\n\r\n```py [sol2-Python3]\r\nMOD, MX = 10 ** 9 + 7, 10 ** 4 + 1\r\nf = [[0] * 6 for _ in range(MX + 1)]\r\nf[1] = [1] * 6\r\nfor i in range(2, MX):\r\n    for j in range(6):\r\n        for k in range(6):\r\n            if k != j and gcd(k + 1, j + 1) == 1:\r\n                f[i][j] += f[i - 1][k] - f[i - 2][j]\r\n        if i > 3: f[i][j] += f[i - 2][j]\r\n        f[i][j] %= MOD\r\n\r\nclass Solution:\r\n    def distinctSequences(self, n: int) -> int:\r\n        return sum(f[n]) % MOD\r\n```\r\n\r\n```java [sol2-Java]\r\nclass Solution {\r\n    static final int MOD = (int) 1e9 + 7, MX = (int) 1e4;\r\n    static final int[][] f = new int[MX + 1][6];\r\n\r\n    static {\r\n        for (var i = 0; i < 6; ++i)\r\n            f[1][i] = 1;\r\n        for (var i = 2; i <= MX; ++i)\r\n            for (var j = 0; j < 6; ++j) {\r\n                var s = 0L;\r\n                for (var k = 0; k < 6; ++k)\r\n                    if (k != j && gcd(k + 1, j + 1) == 1)\r\n                        s += f[i - 1][k] - f[i - 2][j];\r\n                if (i > 3) s += f[i - 2][j];\r\n                f[i][j] = (int) (s % MOD);\r\n            }\r\n    }\r\n\r\n    public int distinctSequences(int n) {\r\n        var ans = 0L;\r\n        for (var v : f[n])\r\n            ans += v;\r\n        return (int) (ans % MOD + MOD) % MOD; // 保证结果非负\r\n    }\r\n\r\n    static int gcd(int a, int b) {\r\n        return b == 0 ? a : gcd(b, a % b);\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol2-C++]\r\nconst int MOD = 1e9 + 7, MX = 1e4;\r\nint f[MX + 1][6];\r\nint init = []() {\r\n    for (int i = 0; i < 6; ++i)\r\n        f[1][i] = 1;\r\n    for (int i = 2; i <= MX; ++i)\r\n        for (int j = 0; j < 6; ++j) {\r\n            long s = 0L;\r\n            for (int k = 0; k < 6; ++k)\r\n                if (k != j && gcd(k + 1, j + 1) == 1)\r\n                    s += f[i - 1][k] - f[i - 2][j];\r\n            if (i > 3) s += f[i - 2][j];\r\n            f[i][j] = s % MOD;\r\n        }\r\n    return 0;\r\n}();\r\n\r\nclass Solution {\r\npublic:\r\n    int distinctSequences(int n) {\r\n        long ans = 0L;\r\n        for (int v : f[n])\r\n            ans += v;\r\n        return (ans % MOD + MOD) % MOD; // 保证结果非负\r\n    }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\nconst mod int = 1e9 + 7\r\nvar f = [1e4 + 1][6]int{}\r\n\r\nfunc init() {\r\n\tfor i := 0; i < 6; i++ {\r\n\t\tf[1][i] = 1\r\n\t}\r\n\tfor i := 2; i <= 1e4; i++ {\r\n\t\tfor j := 0; j < 6; j++ {\r\n\t\t\tfor k := 0; k < 6; k++ {\r\n\t\t\t\tif k != j && gcd(k+1, j+1) == 1 {\r\n\t\t\t\t\tf[i][j] += f[i-1][k] - f[i-2][j]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif i > 3 {\r\n\t\t\t\tf[i][j] += f[i-2][j]\r\n\t\t\t}\r\n\t\t\tf[i][j] %= mod\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc distinctSequences(n int) (ans int) {\r\n\tfor _, v := range f[n] {\r\n\t\tans += v\r\n\t}\r\n\treturn (ans%mod + mod) % mod // 保证结果非负\r\n}\r\n\r\nfunc gcd(a, b int) int {\r\n\tfor a != 0 {\r\n\t\ta, b = b%a, a\r\n\t}\r\n\treturn b\r\n}\r\n```\r\n\r\n另一种写法是，注意到 $f[2][j]$ 实际上就是转移方程中求和的次数，因此我们可以将 $f[i-2][j]$ 提出来，得到\r\n\r\n$$\r\nf[i][j] = \\left(\\sum_{\\substack{k\\ne j\\\\ k\\perp j}} f[i-1][k]\\right) + (f[2][j]-1)\\cdot f[i-2][j]\r\n$$\r\n\r\n```py [sol3-Python3]\r\nMOD, MX = 10 ** 9 + 7, 10 ** 4 + 1\r\nf = [[0] * 6 for _ in range(MX + 1)]\r\nf[1] = [1] * 6\r\nfor i in range(2, MX):\r\n    for j in range(6):\r\n        f[i][j] = (sum(f[i - 1][k] for k in range(6) if k != j and gcd(k + 1, j + 1) == 1)\r\n                   - (f[2][j] - (i > 3)) * f[i - 2][j]) % MOD\r\n\r\nclass Solution:\r\n    def distinctSequences(self, n: int) -> int:\r\n        return sum(f[n]) % MOD\r\n```\r\n\r\n```java [sol3-Java]\r\nclass Solution {\r\n    static final int MOD = (int) 1e9 + 7, MX = (int) 1e4;\r\n    static final int[][] f = new int[MX + 1][6];\r\n\r\n    static {\r\n        for (var i = 0; i < 6; ++i)\r\n            f[1][i] = 1;\r\n        for (var i = 2; i <= MX; ++i)\r\n            for (var j = 0; j < 6; ++j) {\r\n                var s = 0L;\r\n                for (var k = 0; k < 6; ++k)\r\n                    if (k != j && gcd(k + 1, j + 1) == 1)\r\n                        s += f[i - 1][k];\r\n                s -= (long) (i > 3 ? f[2][j] - 1 : f[2][j]) * f[i - 2][j];\r\n                f[i][j] = (int) (s % MOD);\r\n            }\r\n    }\r\n\r\n    public int distinctSequences(int n) {\r\n        var ans = 0L;\r\n        for (var v : f[n])\r\n            ans += v;\r\n        return (int) (ans % MOD + MOD) % MOD; // 保证结果非负\r\n    }\r\n\r\n    static int gcd(int a, int b) {\r\n        return b == 0 ? a : gcd(b, a % b);\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol3-C++]\r\nconst int MOD = 1e9 + 7, MX = 1e4;\r\nint f[MX + 1][6];\r\nint init = []() {\r\n    for (int i = 0; i < 6; ++i)\r\n        f[1][i] = 1;\r\n    for (int i = 2; i <= MX; ++i)\r\n        for (int j = 0; j < 6; ++j) {\r\n            long s = 0L;\r\n            for (int k = 0; k < 6; ++k)\r\n                if (k != j && gcd(k + 1, j + 1) == 1)\r\n                    s += f[i - 1][k];\r\n            s -= (long) (f[2][j] - (i > 3)) * f[i - 2][j];\r\n            f[i][j] = s % MOD;\r\n        }\r\n    return 0;\r\n}();\r\n\r\nclass Solution {\r\npublic:\r\n    int distinctSequences(int n) {\r\n        long ans = 0L;\r\n        for (int v : f[n])\r\n            ans += v;\r\n        return (ans % MOD + MOD) % MOD; // 保证结果非负\r\n    }\r\n};\r\n```\r\n\r\n```go [sol3-Go]\r\nconst mod int = 1e9 + 7\r\nvar f = [1e4 + 1][6]int{}\r\n\r\nfunc init() {\r\n\tfor i := 0; i < 6; i++ {\r\n\t\tf[1][i] = 1\r\n\t}\r\n\tfor i := 2; i <= 1e4; i++ {\r\n\t\tfor j := 0; j < 6; j++ {\r\n\t\t\tfor k := 0; k < 6; k++ {\r\n\t\t\t\tif k != j && gcd(k+1, j+1) == 1 {\r\n\t\t\t\t\tf[i][j] += f[i-1][k]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tc := f[2][j]\r\n\t\t\tif i > 3 {\r\n\t\t\t\tc--\r\n\t\t\t}\r\n\t\t\tf[i][j] = (f[i][j] - c*f[i-2][j]) % mod\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc distinctSequences(n int) (ans int) {\r\n\tfor _, v := range f[n] {\r\n\t\tans += v\r\n\t}\r\n\treturn (ans%mod + mod) % mod // 保证结果非负\r\n}\r\n\r\nfunc gcd(a, b int) int {\r\n\tfor a != 0 {\r\n\t\ta, b = b%a, a\r\n\t}\r\n\treturn b\r\n}\r\n```\r\n"
}