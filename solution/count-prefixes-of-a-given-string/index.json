{
	"titleSlug": "count-prefixes-of-a-given-string",
	"slug": "tong-ji-shi-gei-ding-zi-fu-chuan-qian-zh-vpyg",
	"url": "https://leetcode-cn.com/problems/count-prefixes-of-a-given-string/solution/tong-ji-shi-gei-ding-zi-fu-chuan-qian-zh-vpyg/",
	"content": "#### 方法一：遍历判断\n\n**思路与算法**\n\n我们可以遍历 $\\textit{words}$ 数组，并判断每个字符串 $\\textit{word}$ 是否是 $s$ 的前缀。与此同时，我们用 $\\textit{res}$ 来维护包含前缀字符串的数量。如果 $\\textit{word}$ 是 $s$ 的前缀，则我们将 $\\textit{res}$ 加上 $1$。最终，我们返回 $\\textit{res}$ 作为答案。\n\n关于判断 $\\textit{word}$ 是否为 $\\textit{s}$ 的前缀，某些语言如 $\\texttt{Python}$ 有字符串对应的 $\\texttt{startswith()}$ 方法。对于没有类似方法的语言，我们也可以手动实现以达到相似的效果。\n\n具体地，我们用函数 $\\textit{isPrefix}(\\textit{word})$ 来实现这一判断。首先当 $s$ 的长度小于 $\\textit{word}$ 时，$\\textit{word}$ 一定不可能是 $s$ 的前缀，此时返回 $\\texttt{false}$。随后，我们从头开始逐字符判断 $\\textit{word}$ 和 $\\textit{s}$ 的对应字符是否相等。如果某个字符不相等，同样返回 $\\texttt{false}$。如果遍历完成 $\\textit{word}$ 后所有字符均相等，则返回 $\\texttt{true}$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int countPrefixes(vector<string>& words, string s) {\n        int res = 0;   // 符合要求字符串个数\n        // 判断 word 是否是 s 的前缀\n        auto isPrefix = [&](const string& word) -> bool {\n            if (s.size() < word.size()) {\n                return false;\n            }\n            for (int i = 0; i < word.size(); ++i) {\n                if (word[i] != s[i]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        \n        for (const string& word: words) {\n            if (isPrefix(word)) {\n                ++res;\n            }\n        }\n        return res;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def countPrefixes(self, words: List[str], s: str) -> int:\n        res = 0   # 符合要求字符串个数\n        for word in words:\n            if s.startswith(word):\n                res += 1\n        return res\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn)$，其中 $m$ 为 $\\textit{words}$ 数组的长度，$n$ 为字符串 $s$ 的长度。每判断 $\\textit{words}$ 中一个字符串的时间复杂度为 $O(n)$，我们总共需要判断 $m$ 次。\n\n- 空间复杂度：O(1)。"
}