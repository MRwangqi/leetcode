{
	"titleSlug": "booking-concert-tickets-in-groups",
	"slug": "by-endlesscheng-okcu",
	"url": "https://leetcode-cn.com/problems/booking-concert-tickets-in-groups/solution/by-endlesscheng-okcu/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV18t4y1p736?t=8m7s) 已出炉，包含线段树的入门讲解，欢迎三连~\r\n\r\n---\r\n\r\n本题有点超纲（算法竞赛难度），直接讲做法。\r\n\r\n关键在于如何高效求出前 $\\textit{maxRow}$ 排座位中，观众数不超过 $m-k$ 且下标最小的那一排座位。同时，我们还需要**动态**维护每一排的观众数，这可以用**线段树**来解决。\r\n\r\n对于 $\\texttt{gather}$ 操作，为了求出目标的那一排座位，我们可以**在线段树上二分**。\r\n\r\n具体来说，我们可以用线段树维护每个区间上的观众数的最小值 $\\textit{min}$：\r\n\r\n- 如果当前区间 $\\textit{min}>m-k$，则无法坐 $k$ 个人，返回 $0$；\r\n- 如果当前区间只包含一个元素，则返回该元素的下标；\r\n- 如果左半部分 $\\textit{min}\\le m-k$，则递归左半部分；（由于要计算最靠前的座位，应该优先递归左半）\r\n- 否则如果 $\\textit{maxRow}+1$ 在右半部分内，则递归右半部分；\r\n- 否则返回 $0$。\r\n\r\n由于每次要么递归左半，要么递归右半，因此线段树二分的复杂度为线段树的树高，即 $O(\\log n)$。\r\n\r\n对于 $\\texttt{scatter}$ 操作，为了判断能否坐 $k$ 个人，我们还需要用线段树维护区间的元素和 $\\textit{sum}$，从而计算出前 $\\textit{maxRow}$ 排座位中的人数。\r\n\r\n如果剩余座位不低于 $k$，我们可以**从第一个未坐满的排开始**占座，这同样可以在线段树上二分：找第一个小于 $m$ 的元素下标。另一种做法是维护一个全局变量，表示上次 $\\texttt{scatter}$ 操作结束时的排。\r\n\r\n更多有关线段树的资料整理和代码见我的 [算法竞赛模板库](https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/segment_tree.go)。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：\r\n   - 初始化为 $O(n)$。初始化线段树需要 $O(n)$。\r\n   - $\\texttt{gather}$ 为 $O(\\log n)$。\r\n   - $\\texttt{scatter}$ 可以从整体上来分析：我们要么在填充空排，要么在填充受之前操作影响的未填满的排，所以**所有 $\\texttt{scatter}$ 操作**的复杂度之和为 $O((n+q)\\log n)$，这里 $q$ 为 $\\texttt{gather}$ 和 $\\texttt{scatter}$ 的调用次数之和。注意上述题解中的「从第一个未坐满的排开始占座」保证了总体复杂度不会退化至 $O(nq)$。\r\n- 空间复杂度：$O(n)$。线段树需要 $O(n)$ 的空间。\r\n\r\n```Python [sol1-Python3]\r\nclass BookMyShow:\r\n    def __init__(self, n: int, m: int):\r\n        self.n = n\r\n        self.m = m\r\n        self.min = [0] * (n * 4)\r\n        self.sum = [0] * (n * 4)\r\n\r\n    # 将 idx 上的元素值增加 val\r\n    def add(self, o: int, l: int, r: int, idx: int, val: int) -> None:\r\n        if l == r:\r\n            self.min[o] += val\r\n            self.sum[o] += val\r\n            return\r\n        m = (l + r) // 2\r\n        if idx <= m: self.add(o * 2, l, m, idx, val)\r\n        else: self.add(o * 2 + 1, m + 1, r, idx, val)\r\n        self.min[o] = min(self.min[o * 2], self.min[o * 2 + 1])\r\n        self.sum[o] = self.sum[o * 2] + self.sum[o * 2 + 1]\r\n\r\n    # 返回区间 [L,R] 内的元素和\r\n    def query_sum(self, o: int, l: int, r: int, L: int, R: int) -> int:\r\n        if L <= l and r <= R: return self.sum[o]\r\n        sum = 0\r\n        m = (l + r) // 2\r\n        if L <= m: sum += self.query_sum(o * 2, l, m, L, R)\r\n        if R > m: sum += self.query_sum(o * 2 + 1, m + 1, r, L, R)\r\n        return sum\r\n\r\n    # 返回区间 [1,R] 中 <= val 的最靠左的位置，不存在时返回 0\r\n    def index(self, o: int, l: int, r: int, R: int, val: int) -> int:\r\n        if self.min[o] > val: return 0  # 说明整个区间的元素值都大于 val\r\n        if l == r: return l\r\n        m = (l + r) // 2\r\n        if self.min[o * 2] <= val: return self.index(o * 2, l, m, R, val)  # 看看左半部分\r\n        if m < R: return self.index(o * 2 + 1, m + 1, r, R, val)  # 看看右半部分\r\n        return 0\r\n\r\n    def gather(self, k: int, maxRow: int) -> List[int]:\r\n        i = self.index(1, 1, self.n, maxRow + 1, self.m - k)\r\n        if i == 0: return []\r\n        seats = self.query_sum(1, 1, self.n, i, i)\r\n        self.add(1, 1, self.n, i, k)  # 占据 k 个座位\r\n        return [i - 1, seats]\r\n\r\n    def scatter(self, k: int, maxRow: int) -> bool:\r\n        if (maxRow + 1) * self.m - self.query_sum(1, 1, self.n, 1, maxRow + 1) < k:\r\n            return False  # 剩余座位不足 k 个\r\n        i = self.index(1, 1, self.n, maxRow + 1, self.m - 1)  # 从第一个没有坐满的排开始占座\r\n        while True:\r\n            left_seats = self.m - self.query_sum(1, 1, self.n, i, i)\r\n            if k <= left_seats:  # 剩余人数不够坐后面的排\r\n                self.add(1, 1, self.n, i, k)\r\n                return True\r\n            k -= left_seats\r\n            self.add(1, 1, self.n, i, left_seats)\r\n            i += 1\r\n```\r\n\r\n```java [sol1-Java]\r\nclass BookMyShow {\r\n    int n, m;\r\n    int[] min;\r\n    long[] sum;\r\n\r\n    public BookMyShow(int n, int m) {\r\n        this.n = n;\r\n        this.m = m;\r\n        min = new int[n * 4];\r\n        sum = new long[n * 4];\r\n    }\r\n\r\n    public int[] gather(int k, int maxRow) {\r\n        int i = index(1, 1, n, maxRow + 1, m - k);\r\n        if (i == 0) return new int[]{}; // 不存在\r\n        var seats = (int) query_sum(1, 1, n, i, i);\r\n        add(1, 1, n, i, k); // 占据 k 个座位\r\n        return new int[]{i - 1, seats};\r\n    }\r\n\r\n    public boolean scatter(int k, int maxRow) {\r\n        if ((long) (maxRow + 1) * m - query_sum(1, 1, n, 1, maxRow + 1) < k) return false; // 剩余座位不足 k 个\r\n        // 从第一个没有坐满的排开始占座\r\n        for (var i = index(1, 1, n, maxRow + 1, m - 1); ; ++i) {\r\n            var left_seats = m - (int) query_sum(1, 1, n, i, i);\r\n            if (k <= left_seats) { // 剩余人数不够坐后面的排\r\n                add(1, 1, n, i, k);\r\n                return true;\r\n            }\r\n            k -= left_seats;\r\n            add(1, 1, n, i, left_seats);\r\n        }\r\n    }\r\n\r\n    // 将 idx 上的元素值增加 val\r\n    void add(int o, int l, int r, int idx, int val) {\r\n        if (l == r) {\r\n            min[o] += val;\r\n            sum[o] += val;\r\n            return;\r\n        }\r\n        var m = (l + r) / 2;\r\n        if (idx <= m) add(o * 2, l, m, idx, val);\r\n        else add(o * 2 + 1, m + 1, r, idx, val);\r\n        min[o] = Math.min(min[o * 2], min[o * 2 + 1]);\r\n        sum[o] = sum[o * 2] + sum[o * 2 + 1];\r\n    }\r\n\r\n    // 返回区间 [L,R] 内的元素和\r\n    long query_sum(int o, int l, int r, int L, int R) { // L 和 R 在整个递归过程中均不变，将其大写，视作常量\r\n        if (L <= l && r <= R) return sum[o];\r\n        var sum = 0L;\r\n        var m = (l + r) / 2;\r\n        if (L <= m) sum += query_sum(o * 2, l, m, L, R);\r\n        if (R > m) sum += query_sum(o * 2 + 1, m + 1, r, L, R);\r\n        return sum;\r\n    }\r\n\r\n    // 返回区间 [1,R] 中 <= val 的最靠左的位置，不存在时返回 0\r\n    int index(int o, int l, int r, int R, int val) { // R 在整个递归过程中均不变，将其大写，视作常量\r\n        if (min[o] > val) return 0; // 说明整个区间的元素值都大于 val\r\n        if (l == r) return l;\r\n        var m = (l + r) / 2;\r\n        if (min[o * 2] <= val) return index(o * 2, l, m, R, val); // 看看左半部分\r\n        if (m < R) return index(o * 2 + 1, m + 1, r, R, val); // 看看右半部分\r\n        return 0;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass BookMyShow {\r\n    int n, m;\r\n    vector<int> min;\r\n    vector<long> sum;\r\n\r\n    // 将 idx 上的元素值增加 val\r\n    void add(int o, int l, int r, int idx, int val) {\r\n        if (l == r) {\r\n            min[o] += val;\r\n            sum[o] += val;\r\n            return;\r\n        }\r\n        int m = (l + r) / 2;\r\n        if (idx <= m) add(o * 2, l, m, idx, val);\r\n        else add(o * 2 + 1, m + 1, r, idx, val);\r\n        min[o] = std::min(min[o * 2], min[o * 2 + 1]);\r\n        sum[o] = sum[o * 2] + sum[o * 2 + 1];\r\n    }\r\n\r\n    // 返回区间 [L,R] 内的元素和\r\n    long query_sum(int o, int l, int r, int L, int R) { // L 和 R 在整个递归过程中均不变，将其大写，视作常量\r\n        if (L <= l && r <= R) return sum[o];\r\n        long sum = 0L;\r\n        int m = (l + r) / 2;\r\n        if (L <= m) sum += query_sum(o * 2, l, m, L, R);\r\n        if (R > m) sum += query_sum(o * 2 + 1, m + 1, r, L, R);\r\n        return sum;\r\n    }\r\n\r\n    // 返回区间 [1,R] 中 <= val 的最靠左的位置，不存在时返回 0\r\n    int index(int o, int l, int r, int R, int val) { // R 在整个递归过程中均不变，将其大写，视作常量\r\n        if (min[o] > val) return 0; // 说明整个区间的元素值都大于 val\r\n        if (l == r) return l;\r\n        int m = (l + r) / 2;\r\n        if (min[o * 2] <= val) return index(o * 2, l, m, R, val); // 看看左半部分\r\n        if (m < R) return index(o * 2 + 1, m + 1, r, R, val); // 看看右半部分\r\n        return 0;\r\n    }\r\n\r\npublic:\r\n    BookMyShow(int n, int m) : n(n), m(m), min(n * 4), sum(n * 4) {}\r\n\r\n    vector<int> gather(int k, int maxRow) {\r\n        int i = index(1, 1, n, maxRow + 1, m - k);\r\n        if (i == 0) return {}; // 不存在\r\n        int seats = query_sum(1, 1, n, i, i);\r\n        add(1, 1, n, i, k); // 占据 k 个座位\r\n        return {i - 1, seats};\r\n    }\r\n\r\n    bool scatter(int k, int maxRow) {\r\n        if ((long) (maxRow + 1) * m - query_sum(1, 1, n, 1, maxRow + 1) < k) return false; // 剩余座位不足 k 个\r\n        // 从第一个没有坐满的排开始占座\r\n        for (int i = index(1, 1, n, maxRow + 1, m - 1);; ++i) {\r\n            int left_seats = m - query_sum(1, 1, n, i, i);\r\n            if (k <= left_seats) { // 剩余人数不够坐后面的排\r\n                add(1, 1, n, i, k);\r\n                return true;\r\n            }\r\n            k -= left_seats;\r\n            add(1, 1, n, i, left_seats);\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\ntype seg []struct{ l, r, min, sum int }\r\n\r\nfunc (t seg) build(o, l, r int) {\r\n\tt[o].l, t[o].r = l, r\r\n\tif l == r {\r\n\t\treturn\r\n\t}\r\n\tm := (l + r) >> 1\r\n\tt.build(o<<1, l, m)\r\n\tt.build(o<<1|1, m+1, r)\r\n}\r\n\r\n// 将 idx 上的元素值增加 val\r\nfunc (t seg) add(o, idx, val int) {\r\n\tif t[o].l == t[o].r {\r\n\t\tt[o].min += val\r\n\t\tt[o].sum += val\r\n\t\treturn\r\n\t}\r\n\tm := (t[o].l + t[o].r) >> 1\r\n\tif idx <= m {\r\n\t\tt.add(o<<1, idx, val)\r\n\t} else {\r\n\t\tt.add(o<<1|1, idx, val)\r\n\t}\r\n\tlo, ro := t[o<<1], t[o<<1|1]\r\n\tt[o].min = min(lo.min, ro.min)\r\n\tt[o].sum = lo.sum + ro.sum\r\n}\r\n\r\n// 返回区间 [l,r] 内的元素和\r\nfunc (t seg) querySum(o, l, r int) (sum int) {\r\n\tif l <= t[o].l && t[o].r <= r {\r\n\t\treturn t[o].sum\r\n\t}\r\n\tm := (t[o].l + t[o].r) >> 1\r\n\tif l <= m {\r\n\t\tsum += t.querySum(o<<1, l, r)\r\n\t}\r\n\tif r > m {\r\n\t\tsum += t.querySum(o<<1|1, l, r)\r\n\t}\r\n\treturn\r\n}\r\n\r\n// 返回区间 [1,R] 中 <= val 的最靠左的位置，不存在时返回 0\r\nfunc (t seg) index(o, r, val int) int {\r\n\tif t[o].min > val { // 说明整个区间的元素值都大于 val\r\n\t\treturn 0\r\n\t}\r\n\tif t[o].l == t[o].r {\r\n\t\treturn t[o].l\r\n\t}\r\n\tm := (t[o].l + t[o].r) >> 1\r\n\tif t[o<<1].min <= val { // 看看左半部分\r\n\t\treturn t.index(o<<1, r, val)\r\n\t}\r\n\tif m < r { // 看看右半部分\r\n\t\treturn t.index(o<<1|1, r, val)\r\n\t}\r\n\treturn 0\r\n}\r\n\r\ntype BookMyShow struct {\r\n\tseg\r\n\tm int\r\n}\r\n\r\nfunc Constructor(n, m int) BookMyShow {\r\n\tt := make(seg, n*4)\r\n\tt.build(1, 1, n)\r\n\treturn BookMyShow{t, m}\r\n}\r\n\r\nfunc (t BookMyShow) Gather(k, maxRow int) []int {\r\n\ti := t.index(1, maxRow+1, t.m-k)\r\n\tif i == 0 { // 不存在\r\n\t\treturn nil\r\n\t}\r\n\tseats := t.querySum(1, i, i)\r\n\tt.add(1, i, k) // 占据 k 个座位\r\n\treturn []int{i - 1, seats}\r\n}\r\n\r\nfunc (t BookMyShow) Scatter(k, maxRow int) bool {\r\n\tif (maxRow+1)*t.m-t.querySum(1, 1, maxRow+1) < k { // 剩余座位不足 k 个\r\n\t\treturn false\r\n\t}\r\n\t// 从第一个没有坐满的排开始占座\r\n\tfor i := t.index(1, maxRow+1, t.m-1); ; i++ {\r\n\t\tleftSeats := t.m - t.querySum(1, i, i)\r\n\t\tif k <= leftSeats { // 剩余人数不够坐后面的排\r\n\t\t\tt.add(1, i, k)\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tk -= leftSeats\r\n\t\tt.add(1, i, leftSeats)\r\n\t}\r\n}\r\n\r\nfunc min(a, b int) int { if a > b { return b }; return a }\r\n```\r\n\r\n"
}