{
	"titleSlug": "univalued-binary-tree",
	"slug": "dan-zhi-er-cha-shu-by-leetcode-solution-15bn",
	"url": "https://leetcode-cn.com/problems/univalued-binary-tree/solution/dan-zhi-er-cha-shu-by-leetcode-solution-15bn/",
	"content": "#### 方法一：深度优先搜索\n\n**思路与算法**\n\n一棵树的所有节点都有相同的值，当且仅当对于树上的每一条边的两个端点，它们都有相同的值（这样根据传递性，所有节点都有相同的值）。\n\n因此，我们可以对树进行一次深度优先搜索。当搜索到节点 $x$ 时，我们检查 $x$ 与 $x$ 的每一个子节点之间的边是否满足要求。例如对于左子节点而言，如果其存在并且值与 $x$ 相同，那么我们继续向下搜索该左子节点；如果值与 $x$ 不同，那么我们直接返回 $\\text{False}$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool isUnivalTree(TreeNode* root) {\n        if (!root) {\n            return true;\n        }\n        if (root->left) {\n            if (root->val != root->left->val || !isUnivalTree(root->left)) {\n                return false;\n            }\n        }\n        if (root->right) {\n            if (root->val != root->right->val || !isUnivalTree(root->right)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean isUnivalTree(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        if (root.left != null) {\n            if (root.val != root.left.val || !isUnivalTree(root.left)) {\n                return false;\n            }\n        }\n        if (root.right != null) {\n            if (root.val != root.right.val || !isUnivalTree(root.right)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool IsUnivalTree(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        if (root.left != null) {\n            if (root.val != root.left.val || !IsUnivalTree(root.left)) {\n                return false;\n            }\n        }\n        if (root.right != null) {\n            if (root.val != root.right.val || !IsUnivalTree(root.right)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def isUnivalTree(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        \n        if root.left:\n            if root.val != root.left.val or not self.isUnivalTree(root.left):\n                return False\n        \n        if root.right:\n            if root.val != root.right.val or not self.isUnivalTree(root.right):\n                return False\n        \n        return True\n```\n\n```C [sol1-C]\nbool isUnivalTree(struct TreeNode* root){\n    if (!root) {\n        return true;\n    }\n    if (root->left) {\n        if (root->val != root->left->val || !isUnivalTree(root->left)) {\n            return false;\n        }\n    }\n    if (root->right) {\n        if (root->val != root->right->val || !isUnivalTree(root->right)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar isUnivalTree = function(root) {\n    if (!root) {\n        return true;\n    }\n    if (root.left) {\n        if (root.val !== root.left.val || !isUnivalTree(root.left)) {\n            return false;\n        }\n    }\n    if (root.right) {\n        if (root.val !== root.right.val || !isUnivalTree(root.right)) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n\n```go [sol1-Golang]\nfunc isUnivalTree(root *TreeNode) bool {\n    return root == nil || (root.Left == nil || root.Val == root.Left.Val && isUnivalTree(root.Left)) &&\n                         (root.Right == nil || root.Val == root.Right.Val && isUnivalTree(root.Right))\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点个数。我们遍历二叉树的每个节点至多一次。\n\n- 空间复杂度：$O(n)$，即为深度优先搜索中需要使用的栈空间。"
}