{
	"titleSlug": "minimum-time-to-complete-trips",
	"slug": "wan-cheng-lu-tu-de-zui-shao-shi-jian-by-uxyrp",
	"url": "https://leetcode-cn.com/problems/minimum-time-to-complete-trips/solution/wan-cheng-lu-tu-de-zui-shao-shi-jian-by-uxyrp/",
	"content": "#### 方法一：二分查找转化为判定问题\n\n**提示 $1$**\n\n当时间增加时，所有公交车完成旅途的总数一定不会减少。\n\n**思路与算法**\n\n根据 **提示 $1$**，「花费 $t$ 时间能否完成 $\\textit{totalTrips}$ 趟旅途」这个**判定问题**如果对于某个 $t$ 成立，那么它对于 $[t, \\infty)$ 区间内的所有整数均成立。这也就说明这个判定问题对于花费时间 $t$ 具有**二值性**。因此我们可以通过二分查找确定使得该判定问题成立的**最小**的 $t$。\n\n由于我们至少需要 $1$ 时间来至少完成一趟旅途，因此二分查找的**下界**为 $1$。而对于二分查找的**上界**，出于方便计算的考虑，我们可以将「花费时间最长的公交车完成 $\\textit{totalTrips}$ 趟旅途的时间」作为二分查找的上界。\n\n对于花费 $t$ 时间对应的判定问题，我们引入辅助函数 $\\textit{check}(t)$ 来判断。\n\n在辅助函数 $\\textit{check}(t)$ 中，我们用 $\\textit{cnt}$ 统计所有公交车完成旅途数量的总和。随后，我们遍历 $\\textit{time}$ 数组的所有元素，对于其中花费为 $\\textit{period}$ 的公交车，它在 $t$ 时间内完成旅途的数目即为 $\\lfloor t / \\textit{period} \\rfloor$，其中 $\\lfloor x \\rfloor$ 表示对 $x$ 向下取整。最终，我们判断 $\\textit{cnt}$ 是否大于等于 $\\textit{totalTrips}$，并将该答案作为辅助函数的返回值。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    long long minimumTime(vector<int>& time, int totalTrips) {\n        // 判断 t 时间内是否可以完成 totalTrips 趟旅途\n        auto check = [&](long long t) -> bool {\n            long long cnt = 0;\n            for (int period: time) {\n                cnt += t / period;\n            }\n            return cnt >= totalTrips;\n        };\n        \n        // 二分查找下界与上界\n        long long l = 1;\n        long long r = (long long) totalTrips * *max_element(time.begin(), time.end());\n        // 二分查找寻找满足要求的最小的 t\n        while (l < r) {\n            long long mid = l + (r - l) / 2;\n            if (check(mid)) {\n                r = mid;\n            } else {\n              l = mid + 1;\n            }\n        }\n        return l;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        # 判断 t 时间内是否可以完成 totalTrips 趟旅途\n        def check(t: int) -> bool:\n            cnt = 0\n            for period in time:\n                cnt += t // period\n            return cnt >= totalTrips\n        \n        # 二分查找下界与上界\n        l = 1\n        r = totalTrips * max(time)\n        # 二分查找寻找满足要求的最小的 t\n        while l < r:\n            mid = l + (r - l) // 2\n            if check(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log(mk))$，其中 $n$ 为 $\\textit{time}$ 数组的长度，$m = \\textit{totalTrips}$，$k$ 为 $\\textit{time}$ 中元素的最大值。我们总共需要进行 $O(\\log(mk))$ 次二分查找，每次判断完成旅途数目是否达到要求的时间复杂度均为 $O(n)$。\n\n- 空间复杂度：$O(1)$。"
}