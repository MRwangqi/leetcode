{
	"titleSlug": "minimize-result-by-adding-parentheses-to-expression",
	"slug": "xiang-biao-da-shi-tian-jia-gua-hao-hou-d-5ox4",
	"url": "https://leetcode-cn.com/problems/minimize-result-by-adding-parentheses-to-expression/solution/xiang-biao-da-shi-tian-jia-gua-hao-hou-d-5ox4/",
	"content": "#### 方法一：枚举\n\n**思路与算法**\n\n我们可以使用枚举的方法得到所有满足要求的表达式，计算每一个表达式的结果并选出最小值。\n\n具体地，我们首先在给定的字符串 $\\textit{expression}$ 中定位到加号的位置，记为 $\\textit{mid}$。由于「左括号必须添加在加号的左侧，右括号必须添加在加号的右侧」，因此我们可以枚举两个位置 $i$ 和 $j$，将字符串分成五部分，即：\n\n- $[0, i)$，对应的数值记为 $p$；\n- $[i, \\textit{mid})$，对应的数值记为 $q$；\n- $\\textit{mid}$ 位置上的加号；\n- $(\\textit{mid}, j]$，对应的数值记为 $r$；\n- $(j, n)$，对应的数值记为 $s$，其中 $n$ 是字符串 $\\textit{expression}$ 的长度；\n\n那么表达式的值即为 $p \\times (q+r) \\times s$。特别地，如果 $i = 0$ 或者 $j = n-1$，那么 $[0, i)$ 或者 $(j, n)$ 是空串，我们可以特判其对应的数值为 $1$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string minimizeResult(string expression) {\n        int n = expression.size();\n        int mid = expression.find('+');\n        int best = INT_MAX;\n        string ans;\n\n        for (int i = 0; i < mid; ++i) {\n            for (int j = mid + 1; j < n; ++j) {\n                int p = (i == 0 ? 1 : stoi(expression.substr(0, i)));\n                int q = stoi(expression.substr(i, mid - i));\n                int r = stoi(expression.substr(mid + 1, j - mid));\n                int s = (j == n - 1 ? 1 : stoi(expression.substr(j + 1, n - j - 1)));\n                int result = p * (q + r) * s;\n                if (result <= best) {\n                    best = result;\n                    ans = expression.substr(0, i) + \"(\" + expression.substr(i, j - i + 1) + \")\" + expression.substr(j + 1, n - j - 1);\n                }\n            }\n        }\n\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimizeResult(self, expression: str) -> str:\n        n = len(expression)\n        mid = expression.index(\"+\")\n        best, ans = float(\"inf\"), \"\"\n        for i in range(mid):\n            for j in range(mid + 1, n):\n                result = int(expression[:i] or 1) * (int(expression[i:mid]) + int(expression[mid+1:j+1])) * int(expression[j+1:] or 1)\n                if result < best:\n                    best = result\n                    ans = expression[:i] + \"(\" + expression[i:j+1] + \")\" + expression[j+1:]\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^3)$，其中 $n$ 是字符串 $\\textit{expression}$ 的长度。枚举 $i$ 和 $j$ 的时间复杂度为 $O(n^2)$，我们还需要 $O(n)$ 的时间遍历整个字符串并计算表达式的值。\n\n- 空间复杂度：$O(n)$，即为计算表达式的值时，存储 $\\textit{expression}$ 的子串需要的空间。"
}