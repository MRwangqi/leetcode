{
	"titleSlug": "binary-trees-with-factors",
	"slug": "dai-yin-zi-de-er-cha-shu-by-leetcode",
	"url": "https://leetcode-cn.com/problems/binary-trees-with-factors/solution/dai-yin-zi-de-er-cha-shu-by-leetcode/",
	"content": "#### 方法 1：动态规划\n\n**想法**\n\n最大值 `v` 一定会被用在树的根节点上，设 `dp(v)` 是以 `v` 为根节点的树种类数。\n\n如果树根节点有孩子 `x` 和 `y` 满足 `x * y == v`，那么就有 `dp(x) * dp(y)` 种方法构造这棵树。\n\n总共会有 $\\sum_{x * y = v} \\text{dp}(x) * \\text{dp}(y)$ 种方法构造以 `v` 为根的树。\n\n**算法**\n\n实际上，令 `dp[i]` 表示已 `A[i]` 为树根的树的种类数。\n\n在上面的例子中我们知道 `x < v` 和 `y < v`，我们可以用动态规划的方法按照升序值计算 `dp[i]` 的值。\n\n对于树根值 `A[i]`，需要找到所有可能的孩子节点取值 `A[j]` 和 `A[i] / A[j]`（显然要有 `A[j] * (A[i] / A[j]) = A[i]`）。为了快速的计算，我们使用 `index` 数组快速查找：如果 `A[k] = A[i] / A[j]`，那么 `index[A[i] / A[j]] = k`。\n\n之后，我们将所有可能的值 `dp[j] * dp[k]`（其中 `j < i, k < i`）加入结果 `dp[i]` 中。在 Java 实现中，我们谨慎的使用了 `long` 类型避免溢出错误。\n\n```Java []\nclass Solution {\n    public int numFactoredBinaryTrees(int[] A) {\n        int MOD = 1_000_000_007;\n        int N = A.length;\n        Arrays.sort(A);\n        long[] dp = new long[N];\n        Arrays.fill(dp, 1);\n\n        Map<Integer, Integer> index = new HashMap();\n        for (int i = 0; i < N; ++i)\n            index.put(A[i], i);\n\n        for (int i = 0; i < N; ++i)\n            for (int j = 0; j < i; ++j) {\n                if (A[i] % A[j] == 0) { // A[j] is left child\n                    int right = A[i] / A[j];\n                    if (index.containsKey(right)) {\n                        dp[i] = (dp[i] + dp[j] * dp[index.get(right)]) % MOD;\n                    }\n                }\n            }\n\n        long ans = 0;\n        for (long x: dp) ans += x;\n        return (int) (ans % MOD);\n    }\n}\n```\n\n```Python []\nclass Solution(object):\n    def numFactoredBinaryTrees(self, A):\n        MOD = 10 ** 9 + 7\n        N = len(A)\n        A.sort()\n        dp = [1] * N\n        index = {x: i for i, x in enumerate(A)}\n        for i, x in enumerate(A):\n            for j in xrange(i):\n                if x % A[j] == 0: #A[j] will be left child\n                    right = x / A[j]\n                    if right in index:\n                        dp[i] += dp[j] * dp[index[right]]\n                        dp[i] %= MOD\n\n        return sum(dp) % MOD\n```\n\n\n**复杂度分析**\n\n* 时间复杂度：$O(N^2)$，其中 $N$ 是 `A` 的长度。这是由于两层循环 `i` 和 `j`。\n* 空间复杂度：$O(N)$，`dp` 和 `index` 使用的空间。"
}