{
	"titleSlug": "minimum-value-to-get-positive-step-by-step-sum",
	"slug": "zhu-bu-qiu-he-de-dao-zheng-shu-de-zui-xi-vyrt",
	"url": "https://leetcode-cn.com/problems/minimum-value-to-get-positive-step-by-step-sum/solution/zhu-bu-qiu-he-de-dao-zheng-shu-de-zui-xi-vyrt/",
	"content": "#### 方法一：贪心\n\n**思路**\n\n要保证所有的累加和 $\\textit{accSum}$ 满足 $\\textit{accSum} + \\textit{startValue} \\ge 1$，只需保证累加和的最小值 $\\textit{accSumMin}$ 满足 $\\textit{accSumMin} + \\textit{startValue} \\ge 1$，那么 $\\textit{startValue}$ 的最小值即可取 $-\\textit{accSumMin} + 1$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def minStartValue(self, nums: List[int]) -> int:\n        accSum, accSumMin = 0, 0\n        for num in nums:\n            accSum += num\n            accSumMin = min(accSumMin, accSum)\n        return -accSumMin + 1\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minStartValue(int[] nums) {\n        int accSum = 0, accSumMin = 0;\n        for (int num : nums) {\n            accSum += num;\n            accSumMin = Math.min(accSumMin, accSum);\n        }\n        return -accSumMin + 1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinStartValue(int[] nums) {\n        int accSum = 0, accSumMin = 0;\n        foreach (int num in nums) {\n            accSum += num;\n            accSumMin = Math.Min(accSumMin, accSum);\n        }\n        return -accSumMin + 1;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minStartValue(vector<int>& nums) {\n        int accSum = 0, accSumMin = 0;\n        for (int num : nums) {\n            accSum += num;\n            accSumMin = min(accSumMin, accSum);\n        }\n        return -accSumMin + 1;\n    }\n};\n```\n\n```C [sol1-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\nint minStartValue(int* nums, int numsSize){\n    int accSum = 0, accSumMin = 0;\n    for (int i = 0; i < numsSize; i++) {\n        accSum += nums[i];\n        accSumMin = MIN(accSumMin, accSum);\n    }\n    return -accSumMin + 1;\n}\n```\n\n```go [sol1-Golang]\nfunc minStartValue(nums []int) int {\n    accSum, accSumMin := 0, 0\n    for _, num := range nums {\n        accSum += num\n        accSumMin = min(accSumMin, accSum)\n    }\n    return -accSumMin + 1\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar minStartValue = function(nums) {\n    let accSum = 0, accSumMin = 0;\n    for (const num of nums) {\n        accSum += num;\n        accSumMin = Math.min(accSumMin, accSum);\n    }\n    return -accSumMin + 1;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。只需要遍历数组一次。\n\n- 空间复杂度：$O(1)$。只需要使用常量空间。\n\n#### 方法二：二分查找\n\n**思路**\n\n当 $\\textit{nums}$ 所有元素均为非负数时，可以直接返回 $1$。当有负数时，可以\n\n当某个数字满足 $\\textit{startValue}$ 的要求时，比它大的数字肯定也都满足，比它小的数字则不一定能满足，因此 $\\textit{startValue}$ 的性质具有单调性，此题可以用二分查找来解决。二分查找的左起始点为 $1$，右起始点可以设为 $\\textit{nums}$ 的最小值的相反数乘上长度后再加 $1$，这样可以保证右端点一定满足 $\\textit{startValue}$ 的要求。\n\n判断某个数字是否满足 $\\textit{startValue}$ 的要求时，可以将 $\\textit{nums}$ 的数字逐步加到这个数字上，判断是否一直为正即可。\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def minStartValue(self, nums: List[int]) -> int:\n        m = min(nums)\n        if m >= 0:\n            return 1\n        left, right = 1, -m * len(nums) + 1\n        while left < right:\n            medium = (left + right) // 2\n            if self.valid(medium, nums):\n                right = medium\n            else:\n                left = medium + 1\n        return left\n    \n    def valid(self, startValue: int, nums: List[int]) -> bool:\n        for num in nums:\n            startValue += num\n            if startValue <= 0:\n                return False\n        return True\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int minStartValue(int[] nums) {\n        int m = Arrays.stream(nums).min().getAsInt();\n        if (m >= 0) {\n            return 1;\n        }\n        int left = 1, right = -m * nums.length + 1;\n        while (left < right) {\n            int medium = (left + right) / 2;\n            if (valid(medium, nums)) {\n                right = medium;\n            } else {\n                left = medium + 1;\n            }\n        }\n        return left;\n    }\n\n    public boolean valid(int startValue, int[] nums) {\n        for (int num : nums) {\n            startValue += num;\n            if (startValue <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int MinStartValue(int[] nums) {\n        int m = nums.Min();\n        if (m >= 0) {\n            return 1;\n        }\n        int left = 1, right = -m * nums.Length + 1;\n        while (left < right) {\n            int medium = (left + right) / 2;\n            if (Valid(medium, nums)) {\n                right = medium;\n            } else {\n                left = medium + 1;\n            }\n        }\n        return left;\n    }\n\n    public bool Valid(int startValue, int[] nums) {\n        foreach (int num in nums) {\n            startValue += num;\n            if (startValue <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int minStartValue(vector<int>& nums) {\n        int m = *min_element(nums.begin(), nums.end());\n        if (m >= 0) {\n            return 1;\n        }\n        int left = 1, right = -m * nums.size() + 1;\n        while (left < right) {\n            int medium = (left + right) / 2;\n            if (valid(medium, nums)) {\n                right = medium;\n            } else {\n                left = medium + 1;\n            }\n        }\n        return left;\n    }\n\n    bool valid(int startValue, vector<int>& nums) {\n        for (int num : nums) {\n            startValue += num;\n            if (startValue <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n```C [sol2-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nbool valid(int startValue, const int* nums, int numsSize) {\n    for (int i = 0; i < numsSize; i++) {\n        startValue += nums[i];\n        if (startValue <= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint minStartValue(int* nums, int numsSize){\n    int m = nums[0];\n    for (int i = 1; i < numsSize; i++) {\n        m = MIN(m, nums[i]);\n    }\n    if (m >= 0) {\n        return 1;\n    }\n    int left = 1, right = -m * numsSize + 1;\n    while (left < right) {\n        int medium = (left + right) / 2;\n        if (valid(medium, nums, numsSize)) {\n            right = medium;\n        } else {\n            left = medium + 1;\n        }\n    }\n    return left;\n}\n```\n\n```go [sol2-Golang]\nfunc minStartValue(nums []int) int {\n    m := nums[0]\n    for _, num := range nums[1:] {\n        m = min(m, num)\n    }\n    return 1 + sort.Search(-m*len(nums), func(startValue int) bool {\n        startValue++\n        for _, num := range nums {\n            startValue += num\n            if startValue <= 0 {\n                return false\n            }\n        }\n        return true\n    })\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar minStartValue = function(nums) {\n    const m = _.min(nums);\n    if (m >= 0) {\n        return 1;\n    }\n    let left = 1, right = -m * nums.length + 1;\n    while (left < right) {\n        const medium = Math.floor((left + right) / 2);\n        if (valid(medium, nums)) {\n            right = medium;\n        } else {\n            left = medium + 1;\n        }\n    }\n    return left;\n};\n\nconst valid = (startValue, nums) => {\n    for (const num of nums) {\n        startValue += num;\n        if (startValue <= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times \\log (mn))$，其中 $n$ 是数组 $\\textit{nums}$ 的长度，$m$ 是数组最小值的绝对值。二分查找的次数是 $O(\\log (mn))$，每次消耗 $O(n)$。\n\n- 空间复杂度：$O(1)$。只需要使用常量空间。"
}