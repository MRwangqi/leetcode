{
	"titleSlug": "maximum-product-of-two-elements-in-an-array",
	"slug": "shu-zu-zhong-liang-yuan-su-de-zui-da-che-oqkf",
	"url": "https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/solution/shu-zu-zhong-liang-yuan-su-de-zui-da-che-oqkf/",
	"content": "#### 方法一：排序\n\n**思路与算法**\n\n题目给定字符串 $\\textit{nums}$，我们需要找到两个在数组不同位置的数减一后的乘积最大。因为 $\\textit{nums}$ 中的每一个元素都为正整数，所以为了使减一后的乘积最大，我们选择数组中的两个最大的元素即可。那么我们先对数组进行排序，然后选择两个最大的元素即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        nums.sort()\n        return (nums[-1] - 1) * (nums[-2] - 1)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        return (nums.back() - 1) * (nums[nums.size() - 2] - 1);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maxProduct(int[] nums) {\n        Arrays.sort(nums);\n        return (nums[nums.length - 1] - 1) * (nums[nums.length - 2] - 1);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MaxProduct(int[] nums) {\n        Array.Sort(nums);\n        return (nums[nums.Length - 1] - 1) * (nums[nums.Length - 2] - 1);\n    }\n}\n```\n\n```C [sol1-C]\nstatic inline int cmp(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint maxProduct(int* nums, int numsSize) {\n    qsort(nums, numsSize, sizeof(int), cmp);\n    return (nums[numsSize - 1] - 1) * (nums[numsSize - 2] - 1);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maxProduct = function(nums) {\n    nums.sort((a, b) => a - b);\n    console.log(nums)\n    return (nums[nums.length - 1] - 1) * (nums[nums.length - 2] - 1);\n};\n```\n\n```go [sol1-Golang]\nfunc maxProduct(nums []int) int {\n    sort.Ints(nums)\n    return (nums[len(nums)-1] - 1) * (nums[len(nums)-2] - 1)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度，主要为数组排序的时间复杂度。\n- 空间复杂度：$O(1)$，仅使用常量空间。\n\n#### 方法二：一次遍历，维护最大和次大值\n\n**思路与算法**\n\n因为我们只需要得到数组中两个最大的元素，我们可以在从左到右遍历的过程中维护两个变量 $a,b$ 来表示遍历过程中的最大和次大元素，那么一次遍历就可以得到数组中两个最大的元素。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        a, b = nums[0], nums[1]\n        if a < b:\n            a, b = b, a\n        for i in range(2, len(nums)):\n            num = nums[i]\n            if num > a:\n                a, b = num, a\n            elif num > b:\n                b = num\n        return (a - 1) * (b - 1)\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int a = nums[0], b = nums[1];\n        if (a < b) {\n            swap(a, b);\n        }\n        for (int i = 2; i < nums.size(); i++) {\n            if (nums[i] > a) {\n                b = a;\n                a = nums[i];\n            } else if (nums[i] > b) {\n                b = nums[i];\n            }\n        }\n        return (a - 1) * (b - 1);\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int a = nums[0], b = nums[1];\n        if (a < b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        for (int i = 2; i < nums.length; i++) {\n            if (nums[i] > a) {\n                b = a;\n                a = nums[i];\n            } else if (nums[i] > b) {\n                b = nums[i];\n            }\n        }\n        return (a - 1) * (b - 1);\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int MaxProduct(int[] nums) {\n        int a = nums[0], b = nums[1];\n        if (a < b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        for (int i = 2; i < nums.Length; i++) {\n            if (nums[i] > a) {\n                b = a;\n                a = nums[i];\n            } else if (nums[i] > b) {\n                b = nums[i];\n            }\n        }\n        return (a - 1) * (b - 1);\n    }\n}\n```\n\n```C [sol2-C]\nint maxProduct(int* nums, int numsSize){\n    int a = nums[0], b = nums[1];\n    if (a < b) {\n        int c = a;\n        a = b;\n        b = c;\n    }\n    for (int i = 2; i < numsSize; i++) {\n        if (nums[i] > a) {\n            b = a;\n            a = nums[i];\n        } else if (nums[i] > b) {\n            b = nums[i];\n        }\n    }\n    return (a - 1) * (b - 1);\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar maxProduct = function(nums) {\n    let a = nums[0], b = nums[1];\n    if (a < b) {\n        const temp = a;\n        a = b;\n        b = temp;\n    }\n    for (let i = 2; i < nums.length; i++) {\n        if (nums[i] > a) {\n            b = a;\n            a = nums[i];\n        } else if (nums[i] > b) {\n            b = nums[i];\n        }\n    }\n    return (a - 1) * (b - 1);\n};\n```\n\n```go [sol2-Golang]\nfunc maxProduct(nums []int) int {\n    a, b := nums[0], nums[1]\n    if a < b {\n        a, b = b, a\n    }\n    for _, num := range nums[2:] {\n        if num > a {\n            a, b = num, a\n        } else if num > b {\n            b = num\n        }\n    }\n    return (a - 1) * (b - 1)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度，需要遍历一遍数组。\n- 空间复杂度：$O(1)$，仅使用常量空间。"
}