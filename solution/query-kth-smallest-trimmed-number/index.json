{
	"titleSlug": "query-kth-smallest-trimmed-number",
	"slug": "by-tsreaper-hlt7",
	"url": "https://leetcode-cn.com/problems/query-kth-smallest-trimmed-number/solution/by-tsreaper-hlt7/",
	"content": "## 解法：基数排序\r\n询问其实问的就是基数排序第 `trim` 轮中的第 `k` 小值。复杂度就是基数排序的 $\\mathcal{O}(nm)$，其中 $m$ 是 `nums` 中每个字符串的长度。\r\n\r\n## 参考代码（c++）\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\r\n        int n = nums.size(), m = nums[0].size();\r\n        // vecs[i][j] 表示基数排序第 i 轮中第 j 小的数对应的下标\r\n        vector<vector<int>> vecs(m + 1);\r\n        for (int i = 0; i < n; i++) vecs[0].push_back(i);\r\n        for (int i = 1; i <= m; i++) {\r\n            vector<vector<int>> B(10);\r\n            // 把第 i - 1 轮的结果，根据 nums 中右数第 i 位数，依次放入桶中\r\n            for (int x : vecs[i - 1]) B[nums[x][m - i] - '0'].push_back(x);\r\n            // 把每个桶的结果连接起来，成为第 i 轮的结果\r\n            for (int j = 0; j < 10; j++) for (int x : B[j]) vecs[i].push_back(x);\r\n        }\r\n\r\n        vector<int> ans;\r\n        for (auto &q : queries) ans.push_back(vecs[q[1]][q[0] - 1]);\r\n        return ans;\r\n    }\r\n};\r\n```"
}