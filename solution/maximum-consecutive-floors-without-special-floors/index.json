{
	"titleSlug": "maximum-consecutive-floors-without-special-floors",
	"slug": "bu-han-te-shu-lou-ceng-de-zui-da-lian-xu-ktg1",
	"url": "https://leetcode-cn.com/problems/maximum-consecutive-floors-without-special-floors/solution/bu-han-te-shu-lou-ceng-de-zui-da-lian-xu-ktg1/",
	"content": "#### 方法一：排序\n\n**思路与算法**\n\n如果我们将给定的数组 $\\textit{special}$ 按照升序排序，那么相邻两个元素之间的楼层就都不是特殊楼层。如果相邻的两个元素分别为 $x, y$，那么非特殊楼层的数量即为 $y-x-1$。\n\n但这样会忽略最开始和结束的非特殊楼层，因此我们可以在排序前将 $\\textit{bottom}-1$ 和 $\\textit{top}+1$ 也放入数组中，一起进行排序。这样一来，所有 $y-x-1$ 中的最大值即为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxConsecutive(int bottom, int top, vector<int>& special) {\n        special.push_back(bottom - 1);\n        special.push_back(top + 1);\n        sort(special.begin(), special.end());\n\n        int n = special.size();\n        int ans = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            ans = max(ans, special[i + 1] - special[i] - 1);\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:\n        special.extend([bottom - 1, top + 1])\n        special.sort()\n        \n        n = len(special)\n        ans = 0\n        for i in range(n - 1):\n            ans = max(ans, special[i + 1] - special[i] - 1)\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{special}$ 的长度。\n\n- 空间复杂度：$O(\\log n)$，即为排序需要使用的栈空间。"
}