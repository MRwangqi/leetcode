{
	"titleSlug": "er-cha-shu-ran-se-UGC",
	"slug": "by-masx200-qdkh",
	"url": "https://leetcode-cn.com/problems/er-cha-shu-ran-se-UGC/solution/by-masx200-qdkh/",
	"content": "### 解题思路\n自底向上递归的动态规划\n考虑根节点染色和不染色两种情况\n### 代码\n\n```javascript []\nvar maxValue = function (root, k) {\n  return Math.max(...dfs(root, k));\n};\nfunction dfs(root, k) {\n  const ans = Array(k + 1).fill(0);\n  if (!root) return ans;\n\n  const left = dfs(root.left, k);\n  const right = dfs(root.right, k);\n\n  ans.fill(left[k] + right[k]);\n\n  for (let i = 1; i <= k; i++) {\n    let temp = -Infinity;\n    for (let j = 0; j <= i - 1; j++) {\n      temp = Math.max(temp, left[j] + right[i - 1 - j]);\n    }\n    ans[i] = Math.max(ans[i], temp + root.val);\n  }\n\n  return ans;\n}\n\n```\n```typescript []\n\nfunction maxValue(root: TreeNode | null, k: number) {\n    return Math.max(...dfs(root, k));\n}\nfunction dfs(root: TreeNode | null, k: number) {\n    const ans = Array<number>(k + 1).fill(0);\n    if (!root) return ans;\n\n    const left = dfs(root.left, k);\n    const right = dfs(root.right, k);\n\n    ans.fill(left[k] + right[k]);\n\n    for (let i = 1; i <= k; i++) {\n        let temp = -Infinity;\n        for (let j = 0; j <= i - 1; j++) {\n            temp = Math.max(temp, left[j] + right[i - 1 - j]);\n        }\n        ans[i] = Math.max(ans[i], temp + root.val);\n    }\n\n    return ans;\n}\n```\n```go []\n\nfunc maxValue(root *TreeNode, k int) int {\n\treturn Max(dfs(root, k)...)\n}\n\nfunc dfs(root *TreeNode, k int) []int {\n\tans := make([]int, k+1)\n\tif root == nil {\n\t\treturn ans\n\t}\n\n\tleft := dfs(root.Left, k)\n\tright := dfs(root.Right, k)\n\tfor i := range ans {\n\t\tans[i] = left[k] + right[k]\n\t}\n\n\tfor i := 1; i <= k; i++ {\n\t\ttemp := math.MinInt\n\t\tfor j := 0; j <= i-1; j++ {\n\t\t\ttemp = Max(temp, left[j]+right[i-1-j])\n\t\t}\n\t\tans[i] = Max(ans[i], temp+root.Val)\n\t}\n\treturn ans\n}\nfunc Max(values ...int) int {\n\n\tvalue := math.MinInt\n\n\tfor _, v := range values {\n\t\tif value < v {\n\t\t\tvalue = v\n\t\t}\n\t}\n\treturn value\n}\n\n```\n```kotlin []\n\nclass Solution {\n    fun maxValue(root: TreeNode?, k: Int): Int {\n        return dfs(root, k).max()?:Int.MIN_VALUE\n    }\n}\n\nfun dfs(root: TreeNode?, k: Int): IntArray {\n    val ans = IntArray(k + 1)\n\n    if (root == null) {\n        return ans\n    }\n    val left = dfs(root.left, k)\n    val right = dfs(root.right, k)\n\n    ans.fill(left[k] + right[k])\n\n    for (i in 1..k) {\n        var temp = Int.MIN_VALUE\n        for (\n        j in 0 until i\n        ) {\n            temp = Math.max(temp, left[j] + right[i - 1 - j])\n        }\n        ans[i] = Math.max(ans[i], temp + root.`val`)\n    }\n    return ans\n}\n```"
}