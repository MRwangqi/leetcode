{
	"titleSlug": "array-of-doubled-pairs",
	"slug": "er-bei-shu-dui-shu-zu-by-leetcode-soluti-2mqj",
	"url": "https://leetcode-cn.com/problems/array-of-doubled-pairs/solution/er-bei-shu-dui-shu-zu-by-leetcode-soluti-2mqj/",
	"content": "#### 方法一：哈希表 + 排序\n\n设 $\\textit{arr}$ 的长度为 $n$，题目本质上是问 $\\textit{arr}$ 能否分成 $\\dfrac{n}{2}$ 对元素，每对元素中一个数是另一个数的两倍。\n\n设 $\\textit{cnt}[x]$ 表示 $\\textit{arr}$ 中 $x$ 的个数。\n\n对于 $\\textit{arr}$ 中的 $0$，它只能与 $0$ 匹配。如果 $\\textit{cnt}[0]$ 是奇数，那么必然无法满足题目要求。\n\n去掉 $\\textit{arr}$ 中的 $0$。设 $x$ 为 $\\textit{arr}$ 中绝对值最小的元素，由于没有绝对值比 $x$ 更小的数，因此 $x$ 只能与 $2x$ 匹配。如果此时 $\\textit{cnt}[2x] < \\textit{cnt}[x]$，那么会有部分 $x$ 无法找到它的另一半，即无法满足题目要求；否则将所有 $x$ 和 $\\textit{cnt}[x]$ 个 $2x$ 从 $\\textit{arr}$ 中去掉，继续判断剩余元素是否满足题目要求。不断重复此操作，如果某个时刻 $\\textit{arr}$ 为空，则说明 $\\textit{arr}$ 可以满足题目要求。\n\n代码实现时，我们可以用一个哈希表来统计 $\\textit{cnt}$，并将其键值按绝对值从小到大排序，然后模拟上述操作，去掉元素的操作可以改为从 $\\textit{cnt}$ 中减去对应值。\n\n```Python [sol1-Python3]\nclass Solution:\n    def canReorderDoubled(self, arr: List[int]) -> bool:\n        cnt = Counter(arr)\n        if cnt[0] % 2:\n            return False\n        for x in sorted(cnt, key=abs):\n            if cnt[2 * x] < cnt[x]:  # 无法找到足够的 2x 与 x 配对\n                return False\n            cnt[2 * x] -= cnt[x]\n        return True\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool canReorderDoubled(vector<int> &arr) {\n        unordered_map<int, int> cnt;\n        for (int x : arr) {\n            ++cnt[x];\n        }\n        if (cnt[0] % 2) {\n            return false;\n        }\n\n        vector<int> vals;\n        vals.reserve(cnt.size());\n        for (auto &[x, _] : cnt) {\n            vals.push_back(x);\n        }\n        sort(vals.begin(), vals.end(), [](int a, int b) { return abs(a) < abs(b); });\n\n        for (int x : vals) {\n            if (cnt[2 * x] < cnt[x]) { // 无法找到足够的 2x 与 x 配对\n                return false;\n            }\n            cnt[2 * x] -= cnt[x];\n        }\n        return true;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean canReorderDoubled(int[] arr) {\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        for (int x : arr) {\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n        }\n        if (cnt.getOrDefault(0, 0) % 2 != 0) {\n            return false;\n        }\n\n        List<Integer> vals = new ArrayList<Integer>();\n        for (int x : cnt.keySet()) {\n            vals.add(x);\n        }\n        Collections.sort(vals, (a, b) -> Math.abs(a) - Math.abs(b));\n\n        for (int x : vals) {\n            if (cnt.getOrDefault(2 * x, 0) < cnt.get(x)) { // 无法找到足够的 2x 与 x 配对\n                return false;\n            }\n            cnt.put(2 * x, cnt.getOrDefault(2 * x, 0) - cnt.get(x));\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool CanReorderDoubled(int[] arr) {\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        foreach (int x in arr) {\n            if (!cnt.ContainsKey(x)) {\n                cnt.Add(x, 1);\n            } else {\n                ++cnt[x];\n            }\n        }\n        if (cnt.ContainsKey(0) && cnt[0] % 2 != 0) {\n            return false;\n        }\n\n        List<int> vals = new List<int>();\n        foreach (int x in cnt.Keys) {\n            vals.Add(x);\n        }\n        vals.Sort((a, b) => Math.Abs(a) - Math.Abs(b));\n\n        foreach (int x in vals) {\n            if ((cnt.ContainsKey(2 * x) ? cnt[2 * x] : 0) < cnt[x]) { // 无法找到足够的 2x 与 x 配对\n                return false;\n            }\n            if (cnt.ContainsKey(2 * x)) {\n                cnt[2 * x] -= cnt[x];\n            } else {\n                cnt.Add(2 * x, -cnt[x]);\n            }\n        }\n        return true;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc canReorderDoubled(arr []int) bool {\n    cnt := make(map[int]int, len(arr))\n    for _, x := range arr {\n        cnt[x]++\n    }\n    if cnt[0]%2 == 1 {\n        return false\n    }\n\n    vals := make([]int, 0, len(cnt))\n    for x := range cnt {\n        vals = append(vals, x)\n    }\n    sort.Slice(vals, func(i, j int) bool { return abs(vals[i]) < abs(vals[j]) })\n\n    for _, x := range vals {\n        if cnt[2*x] < cnt[x] { // 无法找到足够的 2x 与 x 配对\n            return false\n        }\n        cnt[2*x] -= cnt[x]\n    }\n    return true\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} HashItem;\n\nstatic int cmp(const int * pa, const int * pb) {\n    return abs(*pa) - abs(*pb);\n}\n\nbool canReorderDoubled(int* arr, int arrSize){\n    HashItem * cnt = NULL;\n    HashItem * pEntry = NULL;\n    for (int i = 0; i < arrSize; i++) {\n        pEntry = NULL;\n        HASH_FIND_INT(cnt, &arr[i], pEntry);\n        if (NULL == pEntry) {\n            pEntry = (HashItem *)malloc(sizeof(HashItem));\n            pEntry->key = arr[i];\n            pEntry->val = 1;\n            HASH_ADD_INT(cnt, key, pEntry);\n        } else {\n            pEntry->val++;\n        }\n    }\n    pEntry = NULL;\n    int key = 0;\n    HASH_FIND_INT(cnt, &key, pEntry);\n    if (pEntry != NULL && pEntry->val % 2) {\n        return false;\n    }\n \n    int cntSize = HASH_COUNT(cnt);\n    int * vals = (int *)malloc(sizeof(int) * cntSize);\n    int pos = 0;\n    HashItem * tmp;\n    HASH_ITER(hh, cnt, pEntry, tmp) {\n        vals[pos++] = pEntry->key; \n    }\n    qsort(vals, cntSize, sizeof(int), cmp);\n    for (int i = 0; i < cntSize; i++) {\n        int c1 = 0, c2 = 0;\n        int key = vals[i];\n        HashItem * pEntry1 = NULL;\n        HashItem * pEntry2 = NULL;\n        HASH_FIND_INT(cnt, &key, pEntry1);\n        if (pEntry1) {\n            c1 = pEntry1->val;\n        }\n        key = 2 * vals[i];\n        HASH_FIND_INT(cnt, &key, pEntry2);\n        if (pEntry2) {\n            c2 = pEntry2->val;\n        }\n        if (c2 < c1) {\n            return false;\n        }\n        if (pEntry2) {\n            pEntry2->val -= c1;\n        }\n    }\n    HASH_ITER(hh, cnt, pEntry, tmp) {\n        HASH_DEL(cnt, pEntry);\n        free(pEntry);\n    }\n    free(vals);\n    return true;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar canReorderDoubled = function(arr) {\n    const cnt = new Map();\n    for (const x of arr) {\n        cnt.set(x, (cnt.get(x) || 0) + 1);\n    }\n    if ((cnt.get(0) || 0) % 2 !== 0) {\n        return false;\n    }\n\n    const vals = [];\n    for (const x of cnt.keys()) {\n        vals.push(x);\n    }\n    vals.sort((a, b) => Math.abs(a) - Math.abs(b));\n\n    for (const x of vals) {\n        if ((cnt.get(2 * x) || 0) < cnt.get(x)) { // 无法找到足够的 2x 与 x 配对\n            return false;\n        }\n        cnt.set(2 * x, (cnt.get(2 * x) || 0) - cnt.get(x));\n    }\n    return true;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n\\log n)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度。最坏情况下哈希表中有 $n$ 个元素，对其排序需要 $O(n\\log n)$ 的时间。\n\n- 空间复杂度：$O(n)$。最坏情况下哈希表中有 $n$ 个元素，需要 $O(n)$ 的空间。"
}