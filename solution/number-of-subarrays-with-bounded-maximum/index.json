{
	"titleSlug": "number-of-subarrays-with-bounded-maximum",
	"slug": "qu-jian-zi-shu-zu-ge-shu-by-leetcode",
	"url": "https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/solution/qu-jian-zi-shu-zu-ge-shu-by-leetcode/",
	"content": "#### 方法一：计数【通过】\n\n**思想**\n\n根据以下步骤推导出解决方案：\n\n其实我们只关心数组中的元素是否小于 `L`，大于 `R`，或者位于 `[L, R]` 之间。假设一个元素小于 `L` 标记为 `0`，位于 `[L, R]` 之间标记为 `1`，大于 `R` 标记为 `2`。\n\n我们希望找出不包含 `2` 且至少包含一个 `1` 的子数组数量。因此可以看作是所有的 `2` 将数组拆分为仅包含 `0` 或 `1` 的子数组。例如在数组 `[0, 0, 1, 2, 2, 1, 0, 2, 0]`，`2` 将数组拆分为 `[0, 0, 1]`、`[1, 0]` 和 `[0]` 三个子数组。 \n\n接下来，需要计算每个只包含 `0` 或 `1` 的数组中，至少包含一个 `1` 的子数组数量。那么问题可以转换为先找出所有的子数组，再从中减去只包含 `0` 的子数组。\n\n例如，`[0, 0, 1]` 有 6 个子数组，其中 3 个子数组只包含 `0`，3 个子数组至少包含一个 `1`；`[1, 0]` 有 3 个子数组，其中 1 个子数组只包含 `0`，2 个子数组至少包含一个 `1`；`[0]` 只有 1 个子数组，且这个子数组只包含 `0`。因此数组 `A = [0, 0, 1, 2, 2, 1, 0, 2, 0]` 中不包含 `2`，且至少包含一个 `1` 的子数组的数量是 `3 + 2 + 0 = 5`。\n\n**算法**\n\n假设 `count(B)` 用于计算所有元素都小于等于 `B` 的子数组数量。根据上面分析，本题答案为 `count(R) - count(L-1)`。\n\n那么如何计算 `count(B)`？使用 `cur` 记录在 `B` 的左边，小于等于 `B` 的连续元素数量。当找到一个这样的元素时，在此位置上结束的有效子数组的数量为 `cur + 1`。当遇到一个元素大于 `B` 时，则在此位置结束的有效子数组的数量为 0。\n\n```java [solution1-Java]\nclass Solution {\n    public int numSubarrayBoundedMax(int[] A, int L, int R) {\n        return count(A, R) - count(A, L-1);\n    }\n\n    public int count(int[] A, int bound) {\n        int ans = 0, cur = 0;\n        for (int x: A) {\n            cur = x <= bound ? cur + 1 : 0;\n            ans += cur;\n        }\n        return ans;\n    }\n}\n```\n\n```python [solution1-Python]\nclass Solution(object):\n    def numSubarrayBoundedMax(self, A, L, R):\n        def count(bound):\n            ans = cur = 0\n            for x in A :\n                cur = cur + 1 if x <= bound else 0\n                ans += cur\n            return ans\n\n        return count(R) - count(L - 1)\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(N)$，其中 `N` 是 `A` 的长度。\n\n* 空间复杂度：$O(1)$。"
}