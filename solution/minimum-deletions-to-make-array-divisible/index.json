{
	"titleSlug": "minimum-deletions-to-make-array-divisible",
	"slug": "zhuan-huan-tan-xin-pythonjavacgo-by-endl-vdgw",
	"url": "https://leetcode-cn.com/problems/minimum-deletions-to-make-array-divisible/solution/zhuan-huan-tan-xin-pythonjavacgo-by-endl-vdgw/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1GV4y1J7kc) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n元素 $x$ 若能整除 $\\textit{numsDivide}$ 的所有元素，等价于 $x$ 是所有 $\\textit{numsDivide}[i]$ 的因子，这也等价于 $x$ 是 $\\textit{numsDivide}$ 所有元素的最大公因数 $g$ 的因子。\r\n\r\n#### 提示 2\r\n\r\n由于要求用 $\\textit{nums}$ 的最小元素去整除 $g$，不妨将 $\\textit{nums}$ 排序后，从小到大找到第一个能整除 $g$ 的元素 $x$，所有小于 $x$ 的元素都需要删除。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\r\n        g = gcd(*numsDivide)\r\n        nums.sort()\r\n        return next((i for i, x in enumerate(nums) if g % x == 0), -1)\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int minOperations(int[] nums, int[] numsDivide) {\r\n        var g = 0;\r\n        for (var x : numsDivide) g = gcd(g, x);\r\n        Arrays.sort(nums);\r\n        for (var i = 0; i < nums.length; i++) if (g % nums[i] == 0) return i;\r\n        return -1;\r\n    }\r\n\r\n    int gcd(int a, int b) {\r\n        return a == 0 ? b : gcd(b % a, a);\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int minOperations(vector<int> &nums, vector<int> &numsDivide) {\r\n        int g = 0;\r\n        for (int x : numsDivide) g = gcd(g, x);\r\n        sort(nums.begin(), nums.end());\r\n        for (int i = 0; i < nums.size(); i++) if (g % nums[i] == 0) return i;\r\n        return -1;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc minOperations(nums, numsDivide []int) int {\r\n\tg := 0\r\n\tfor _, x := range numsDivide {\r\n\t\tg = gcd(g, x)\r\n\t}\r\n\tsort.Ints(nums)\r\n\tfor i, x := range nums {\r\n\t\tif g%x == 0 {\r\n\t\t\treturn i\r\n\t\t}\r\n\t}\r\n\treturn -1\r\n}\r\n\r\nfunc gcd(a, b int) int {\r\n\tfor a != 0 {\r\n\t\ta, b = b%a, a\r\n\t}\r\n\treturn b\r\n}\r\n```\r\n\r\n也可以不用排序，通过两次遍历得到答案。\r\n\r\n```py [sol2-Python3]\r\nclass Solution:\r\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\r\n        g = gcd(*numsDivide)\r\n        mn = min((x for x in nums if g % x == 0), default=0)\r\n        return sum(x < mn for x in nums) if mn else -1\r\n```\r\n\r\n```java [sol2-Java]\r\nclass Solution {\r\n    public int minOperations(int[] nums, int[] numsDivide) {\r\n        var g = 0;\r\n        for (var x : numsDivide) g = gcd(g, x);\r\n        var min = Integer.MAX_VALUE;\r\n        for (var num : nums) if (g % num == 0) min = Math.min(min, num);\r\n        if (min == Integer.MAX_VALUE) return -1;\r\n        var ans = 0;\r\n        for (var x : nums) if (x < min) ++ans;\r\n        return ans;\r\n    }\r\n\r\n    int gcd(int a, int b) {\r\n        return a == 0 ? b : gcd(b % a, a);\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol2-C++]\r\nclass Solution {\r\npublic:\r\n    int minOperations(vector<int> &nums, vector<int> &numsDivide) {\r\n        int g = 0;\r\n        for (int x : numsDivide) g = gcd(g, x);\r\n        int mn = INT_MAX;\r\n        for (int x : nums) if (g % x == 0) mn = min(mn, x);\r\n        if (mn == INT_MAX) return -1;\r\n        int ans = 0;\r\n        for (int x : nums) if (x < mn) ++ans;\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\nfunc minOperations(nums, numsDivide []int) (ans int) {\r\n\tg := 0\r\n\tfor _, x := range numsDivide {\r\n\t\tg = gcd(g, x)\r\n\t}\r\n\tmin := math.MaxInt32\r\n\tfor _, x := range nums {\r\n\t\tif g%x == 0 && x < min {\r\n\t\t\tmin = x\r\n\t\t}\r\n\t}\r\n\tif min == math.MaxInt32 {\r\n\t\treturn -1\r\n\t}\r\n\tfor _, x := range nums {\r\n\t\tif x < min {\r\n\t\t\tans++\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc gcd(a, b int) int {\r\n\tfor a != 0 {\r\n\t\ta, b = b%a, a\r\n\t}\r\n\treturn b\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(m+\\log U + n)$，其中 $m$ 为数组 $\\textit{numsDivide}$ 的长度，$U=\\max(\\textit{numsDivide})$，$n$ 为数组 $\\textit{nums}$ 的长度。注意到求最大公因数 $g$ 的过程（设初始 $g=U$），要么使 $g$ 不变，要么使 $g$ 至少减半，而 $g$ 至多减半 $O(\\log U)$ 次，因此求最大公因数的迭代次数为 $O(m+\\log U)$ 次。总的时间复杂度为 $O(m+\\log U + n)$。\r\n- 空间复杂度：$O(1)$。仅需要几个额外的变量。\r\n"
}