{
	"titleSlug": "largest-values-from-labels",
	"slug": "by-dai-v3-356q",
	"url": "https://leetcode-cn.com/problems/largest-values-from-labels/solution/by-dai-v3-356q/",
	"content": "思路:\n- 首先使用哈系表存储相同标签的不同值\n- 其次先排序再取同标签的前`useLimit`个值,值少于`useLimit`的取其全部.将这些值存入`scratchpad`列表中\n- 最后再次排序`scratchpad`,取其前`numWanted`个值即可,如果`scratchpad`小与`numWanted`就取`scratchpad`列表的全部值\n-------------\n该方法有点慢,可以进行优化\n\n```Java []\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Solution {\n    public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {\n        Map<Integer, ArrayList<Integer>> map=new HashMap<>();\n\n        for(int i=0;i<values.length;i++){\n            ArrayList<Integer> arrayList;\n            if(map.containsKey(labels[i])){\n                arrayList=map.get(labels[i]);\n            }\n            else{\n                arrayList=new ArrayList<>();\n            }\n            arrayList.add(values[i]);\n            map.put(labels[i],arrayList);\n        }\n        List<Integer> scratchpad=new ArrayList<>();\n        for(ArrayList<Integer> array:map.values()){\n            array.sort((a,b)->b-a);\n            for(int i=0;i<useLimit && i<array.size();i++){\n                scratchpad.add(array.get(i));\n            }\n        }\n        int res=0;\n        scratchpad.sort((a,b)->b-a);\n        for(int i=0;i<scratchpad.size() && i<numWanted;i++){\n            res+=scratchpad.get(i);\n        }\n        return res;\n    }\n}\n```\n"
}