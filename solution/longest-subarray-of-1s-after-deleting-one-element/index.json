{
	"titleSlug": "longest-subarray-of-1s-after-deleting-one-element",
	"slug": "shan-diao-yi-ge-yuan-su-yi-hou-quan-wei-1-de-zui-c",
	"url": "https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/solution/shan-diao-yi-ge-yuan-su-yi-hou-quan-wei-1-de-zui-c/",
	"content": "#### 方法一：递推\n\n**思路**\n\n在删掉元素的结果数组中，最长的且只包含 $1$ 的非空子数组存在两种情况：\n\n+ 这个子数组在原数组中本身就是连续的，无论删或者不删其他的元素，它都是最长的且只包含 $1$ 的非空子数组；\n\n+ 这个子数组原本不连续，而是两个连续的全 $1$ 子数组，中间夹着一个 $0$，把这个 $0$ 删掉以后，左右两个子数组组合成一个最长的且只包含 $1$ 的非空子数组。\n\n我们可以枚举被删除的位置，假设下标为 $i$，我们希望知道「以第 $i - 1$ 位结尾的最长连续全 $1$ 子数组」和「以第 $i + 1$ 位开头的最长连续全 $1$ 子数组」的长度分别是多少，这两个量的和就是删除第 $i$ 位之后最长的且只包含 $1$ 的非空子数组的长度。假设我们可以得到这两个量，我们只要枚举所有的 $i$，就可以得到最终的答案。\n\n我们可以这样维护「以第 $i - 1$ 位结尾的最长连续全 $1$ 子数组」和「以第 $i + 1$ 位开头的最长连续全 $1$ 子数组」的长度：\n\n+ 记原数组为 $a$\n\n+ 记 ${\\rm pre}(i)$ 为「以第 $i$ 位结尾的最长连续全 $1$ 子数组」，那么\n  $$ {\\rm pre}(i) = \\left\\{ \\begin{aligned} \n    & 0 , & a_i = 0 \\\\\n    & {\\rm pre}(i - 1) + 1 , & a_i = 1 \n   \\end{aligned} \\right.$$\n\n+ 记 ${\\rm suf}(i)$ 为「以第 $i$ 位开头的最长连续全 $1$ 子数组」，那么\n  $$ {\\rm suf}(i) = \\left\\{ \\begin{aligned} \n    & 0 , & a_i = 0 \\\\\n    & {\\rm suf}(i + 1) + 1 , & a_i = 1 \n   \\end{aligned} \\right.$$\n\n我们可以对原数组做一次正向遍历，预处理出 $\\rm pre$，再做一次反向遍历，预处理出 $\\rm suf$。最后我们枚举所有的元素作为待删除的元素，计算出删除这些元素之后最长的且只包含 $1$ 的非空子数组的长度，比较并取最大值。\n\n代码如下。\n\n**算法**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        int n = nums.size();\n\n        vector<int> pre(n), suf(n);\n\n        pre[0] = nums[0];\n        for (int i = 1; i < n; ++i) {\n            pre[i] = nums[i] ? pre[i - 1] + 1 : 0; \n        }\n\n        suf[n - 1] = nums[n - 1];\n        for (int i = n - 2; i >= 0; --i) {\n            suf[i] = nums[i] ? suf[i + 1] + 1 : 0;\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            int preSum = i == 0 ? 0 : pre[i - 1];\n            int sufSum = i == n - 1 ? 0 : suf[i + 1];\n            ans = max(ans, preSum + sufSum);\n        }\n\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int longestSubarray(int[] nums) {\n        int n = nums.length;\n\n        int[] pre = new int[n];\n        int[] suf = new int[n];\n\n        pre[0] = nums[0];\n        for (int i = 1; i < n; ++i) {\n            pre[i] = nums[i] != 0 ? pre[i - 1] + 1 : 0; \n        }\n\n        suf[n - 1] = nums[n - 1];\n        for (int i = n - 2; i >= 0; --i) {\n            suf[i] = nums[i] != 0 ? suf[i + 1] + 1 : 0;\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            int preSum = i == 0 ? 0 : pre[i - 1];\n            int sufSum = i == n - 1 ? 0 : suf[i + 1];\n            ans = Math.max(ans, preSum + sufSum);\n        }\n\n        return ans;\n    }\n}\n```\n\n**复杂度**\n\n假设原数组长度为 $n$。\n\n+ 时间复杂度：$O(n)$。这里对原数组进行三次遍历，每次时间代价为 $O(n)$，故渐进时间复杂度为 $O(n)$。\n\n+ 空间复杂度：$O(n)$。这里预处理 $\\rm pre$ 和 $\\rm suf$ 需要两个长度为 $n$ 的数组。\n\n#### 方法二：递推优化\n\n**思路**\n\n我们也可以修改递推的方式使用一次就可以得到答案。\n\n记 $p_0(i)$ 为「以第 $i$ 位结尾的最长连续全 $1$ 子数组」，与方法一中的 ${\\rm pre}(i)$ 相同，递推式为：\n\n$$ p_0(i) = \\left\\{ \\begin{aligned} \n    & 0 , & a_i = 0 \\\\\n    & p_0(i - 1) + 1 , & a_i = 1 \n   \\end{aligned} \\right.\n$$\n\n同时，我们记 $p_1(i)$ 为「以第 $i$ 位结尾，并且可以在某个位置删除一个 $0$ 的最长连续全 $1$ 子数组」。注意这里我们规定了只删除 $0$，而不是任意一个元素，这是因为只要数组中的元素不全为 $1$，那么删除 $1$ 就没有任何意义。$p_1(i)$ 的递推式为：\n\n$$ p_1(i) = \\left\\{ \\begin{aligned} \n    & p_0(i - 1) , & a_i = 0 \\\\\n    & p_1(i - 1) + 1 , & a_i = 1 \n   \\end{aligned} \\right.\n$$\n\n当我们遇到 $1$ 时，$p_1(i)$ 的递推式与 $p_0(i)$ 相同；而当我们遇到 $0$ 时，由于 $p_1(i)$ 允许删除一个 $0$，那么我们可以把这个 $0$ 删除，将 $p_0(i-1)$ 的值赋予 $p_1(i)$。\n\n最后的答案即为 $p_1(i)$ 中的最大值。当遇到数组中的元素全为 $1$ 的特殊情况时，我们需要将答案减去 $1$，这是因为在这种情况下，我们不得不删除一个 $1$。注意到递推式中所有的 $p_0(i), p_1(i)$ 只和 $p_0(i-1), p_1(i-1)$ 相关，因此我们可以直接使用两个变量进行递推，减少空间复杂度。\n\n**算法**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        int ans = 0;\n        int p0 = 0, p1 = 0;\n        for (int num: nums) {\n            if (num == 0) {\n                p1 = p0;\n                p0 = 0;\n            }\n            else {\n                ++p0;\n                ++p1;\n            }\n            ans = max(ans, p1);\n        }\n        if (ans == nums.size()) {\n            --ans;\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int longestSubarray(int[] nums) {\n        int ans = 0;\n        int p0 = 0, p1 = 0;\n        for (int num : nums) {\n            if (num == 0) {\n                p1 = p0;\n                p0 = 0;\n            } else {\n                ++p0;\n                ++p1;\n            }\n            ans = Math.max(ans, p1);\n        }\n        if (ans == nums.length) {\n            --ans;\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        ans = 0\n        p0 = p1 = 0\n        for num in nums:\n            if num == 0:\n                p1, p0 = p0, 0\n            else:\n                p0 += 1\n                p1 += 1\n            ans = max(ans, p1)\n        if ans == len(nums):\n            ans -= 1\n        return ans\n```\n\n**复杂度**\n\n假设原数组长度为 $n$。\n\n+ 时间复杂度：$O(n)$。这里对原数组进行一次遍历，时间代价为 $O(n)$，故渐进时间复杂度为 $O(n)$。\n\n+ 空间复杂度：$O(1)$。"
}