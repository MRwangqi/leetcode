{
	"titleSlug": "find-right-interval",
	"slug": "xun-zhao-you-qu-jian-by-leetcode-solutio-w2ic",
	"url": "https://leetcode-cn.com/problems/find-right-interval/solution/xun-zhao-you-qu-jian-by-leetcode-solutio-w2ic/",
	"content": "#### 方法一：二分查找\n\n**思路与算法**\n\n最简单的解决方案是对于集合中的每个区间，我们扫描所有区间找到其起点大于当前区间的终点的区间（具有最小差值），时间复杂度为 $O(n^2)$，在此我们不详细描述。\n\n首先我们可以对区间 $\\textit{intervals}$ 的起始位置进行排序，并将每个起始位置  $\\textit{intervals}[i][0]$ 对应的索引 $i$ 存储在数组 $\\textit{startIntervals}$ 中，然后枚举每个区间 $i$ 的右端点 $\\textit{intervals}[i][1]$，利用二分查找来找到大于等于 $\\textit{intervals}[i][1]$ 的最小值 $\\textit{val}$ 即可，此时区间 $i$ 对应的右侧区间即为右端点 $\\textit{val}$ 对应的索引。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\n        for i, interval in enumerate(intervals):\n            interval.append(i)\n        intervals.sort()\n\n        n = len(intervals)\n        ans = [-1] * n\n        for _, end, id in intervals:\n            i = bisect_left(intervals, [end])\n            if i < n:\n                ans[id] = intervals[i][2]\n        return ans\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] findRightInterval(int[][] intervals) {\n        int n = intervals.length;\n        int[][] startIntervals = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            startIntervals[i][0] = intervals[i][0];\n            startIntervals[i][1] = i;\n        }\n        Arrays.sort(startIntervals, (o1, o2) -> o1[0] - o2[0]);\n\n        int[] ans = new int[n];\n        for (int i = 0; i < n; i++) {\n            int left = 0;\n            int right = n - 1;\n            int target = -1;\n            while (left <= right) {\n                int mid = (left + right) / 2;\n                if (startIntervals[mid][0] >= intervals[i][1]) {\n                    target = startIntervals[mid][1];\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            ans[i] = target;\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> findRightInterval(vector<vector<int>>& intervals) {\n        vector<pair<int, int>> startIntervals;\n        int n = intervals.size();\n        for (int i = 0; i < n; i++) {\n            startIntervals.emplace_back(intervals[i][0], i);\n        }\n        sort(startIntervals.begin(), startIntervals.end());\n\n        vector<int> ans(n, -1);\n        for (int i = 0; i < n; i++) {\n            auto it = lower_bound(startIntervals.begin(), startIntervals.end(), make_pair(intervals[i][1], 0));\n            if (it != startIntervals.end()) {\n                ans[i] = it->second;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] FindRightInterval(int[][] intervals) {\n        int n = intervals.Length;\n        int[][] startIntervals = new int[n][];\n        for (int i = 0; i < n; i++) {\n            startIntervals[i] = new int[2];\n            startIntervals[i][0] = intervals[i][0];\n            startIntervals[i][1] = i;\n        }\n        Array.Sort(startIntervals, (o1, o2) => o1[0] - o2[0]);\n\n        int[] ans = new int[n];\n        for (int i = 0; i < n; i++) {\n            int left = 0;\n            int right = n - 1;\n            int target = -1;\n            while (left <= right) {\n                int mid = (left + right) / 2;\n                if (startIntervals[mid][0] >= intervals[i][1]) {\n                    target = startIntervals[mid][1];\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            ans[i] = target;\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int start;\n    int index;\n} Node;\n\nint cmp(const void *pa, const void *pb) {\n    return ((Node *)pa)->start - ((Node *)pb)->start;\n}\n\nint* findRightInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize) {\n    Node * startIntervals = (Node *)malloc(sizeof(Node) * intervalsSize);\n    for (int i = 0; i < intervalsSize; i++) {\n        startIntervals[i].start = intervals[i][0];\n        startIntervals[i].index = i;\n    }\n    qsort(startIntervals, intervalsSize, sizeof(Node), cmp);\n\n    int * ans = (int *)malloc(sizeof(int) * intervalsSize);\n    for (int i = 0; i < intervalsSize; i++) {\n        int left = 0;\n        int right = intervalsSize - 1;\n        int target = -1;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (startIntervals[mid].start >= intervals[i][1]) {\n                target = startIntervals[mid].index;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        ans[i] = target;\n    }\n    *returnSize = intervalsSize;\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc findRightInterval(intervals [][]int) []int {\n    for i := range intervals {\n        intervals[i] = append(intervals[i], i)\n    }\n    sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\n\n    n := len(intervals)\n    ans := make([]int, n)\n    for _, p := range intervals {\n        i := sort.Search(n, func(i int) bool { return intervals[i][0] >= p[1] })\n        if i < n {\n            ans[p[2]] = intervals[i][2]\n        } else {\n            ans[p[2]] = -1\n        }\n    }\n    return ans\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findRightInterval = function(intervals) {\n    const n = intervals.length;\n    const startIntervals = new Array(n).fill(0).map(() => new Array(2).fill(0));\n    for (let i = 0; i < n; i++) {\n        startIntervals[i][0] = intervals[i][0];\n        startIntervals[i][1] = i;\n    }\n    startIntervals.sort((o1, o2) => o1[0] - o2[0]);\n\n    const ans = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        let left = 0;\n        let right = n - 1;\n        let target = -1;\n        while (left <= right) {\n            const mid = Math.floor((left + right) / 2);\n            if (startIntervals[mid][0] >= intervals[i][1]) {\n                target = startIntervals[mid][1];\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        ans[i] = target;\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 为区间数组的长度。排序的时间为 $O(n \\log n)$，每次进行二分查找花费的时间为 $O(\\log n)$，一共需要进行 $n$ 次二分查找，因此总的时间复杂度为 $O(n \\log n)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为区间数组的长度。$\\textit{startIntervals}$ 一共存储了 $n$ 个元素，因此空间复杂度为 $O(n)$。\n\n#### 方法二：双指针\n\n**思路与算法**\n\n我们可以开辟两个新的数组：\n+ $\\textit{startIntervals}$，基于所有区间的起始点从小到大排序。\n+ $\\textit{endIntervals}$，基于所有区间的结束点从小到大排序。\n\n我们从 $\\textit{endIntervals}$ 数组中取出第 $i$ 个区间，就可以从左到右扫描 $\\textit{startIntervals}$ 数组中的区间起点来找到满足右区间条件的区间。设 $\\textit{endIntervals}$ 数组中第 $i$ 个元素的右区间为 $\\textit{startIntervals}$ 数组中的第 $j$ 个元素，此时可以知道 $\\textit{startIntervals}[j-1][0] < \\textit{endIntervals}[i][0], \\textit{startIntervals}[j][0] \\ge \\textit{endIntervals}[i][0]$。当我们遍历 $\\textit{endIntervals}$ 数组中第 $i+1$ 个元素时，我们不需要从第一个索引开始扫描 $\\textit{startIntervals}$ 数组，可以直接从第 $j$ 个元素开始扫描 ${startIntervals}$ 数组。由于数组中所有的元素都是已排序，因此可以知道 $\\textit{startIntervals}[j-1][0] < \\textit{endIntervals}[i][0] \\le \\textit{endIntervals}[i+1][0]$，所以数组 $\\textit{startIntervals}$ 的前 $j-1$ 的元素的起始点都小于 $\\textit{endIntervals}[i+1][0]$，因此可以直接跳过前 $j-1$ 个元素，只需要从 $j$ 开始搜索即可。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\n        n = len(intervals)\n        starts, ends = list(zip(*intervals))\n        starts = sorted(zip(starts, range(n)))\n        ends = sorted(zip(ends, range(n)))\n\n        ans, j = [-1] * n, 0\n        for end, id in ends:\n            while j < n and starts[j][0] < end:\n                j += 1\n            if j < n:\n                ans[id] = starts[j][1]\n        return ans\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int[] findRightInterval(int[][] intervals) {\n        int n = intervals.length;\n        int[][] startIntervals = new int[n][2];\n        int[][] endIntervals = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            startIntervals[i][0] = intervals[i][0];\n            startIntervals[i][1] = i;\n            endIntervals[i][0] = intervals[i][1];\n            endIntervals[i][1] = i;\n        }\n        Arrays.sort(startIntervals, (o1, o2) -> o1[0] - o2[0]);\n        Arrays.sort(endIntervals, (o1, o2) -> o1[0] - o2[0]);\n\n        int[] ans = new int[n];\n        for (int i = 0, j = 0; i < n; i++) {\n            while (j < n && endIntervals[i][0] > startIntervals[j][0]) {\n                j++;\n            }\n            if (j < n) {\n                ans[endIntervals[i][1]] = startIntervals[j][1];\n            } else {\n                ans[endIntervals[i][1]] = -1;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> findRightInterval(vector<vector<int>>& intervals) {\n        vector<pair<int, int>> startIntervals;\n        vector<pair<int, int>> endIntervals;\n        int n = intervals.size();\n        for (int i = 0; i < n; i++) {\n            startIntervals.emplace_back(intervals[i][0], i);\n            endIntervals.emplace_back(intervals[i][1], i);\n        }\n        sort(startIntervals.begin(), startIntervals.end());\n        sort(endIntervals.begin(), endIntervals.end());\n\n        vector<int> ans(n, -1);\n        for (int i = 0, j = 0; i < n && j < n; i++) {\n            while (j < n && endIntervals[i].first > startIntervals[j].first) {\n                j++;\n            }\n            if (j < n) {\n                ans[endIntervals[i].second] = startIntervals[j].second;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int[] FindRightInterval(int[][] intervals) {\n        int n = intervals.Length;\n        int[][] startIntervals = new int[n][];\n        int[][] endIntervals = new int[n][];\n        for (int i = 0; i < n; i++) {\n            startIntervals[i] = new int[2];\n            startIntervals[i][0] = intervals[i][0];\n            startIntervals[i][1] = i;\n            endIntervals[i] = new int[2];\n            endIntervals[i][0] = intervals[i][1];\n            endIntervals[i][1] = i;\n        }\n        Array.Sort(startIntervals, (o1, o2) => o1[0] - o2[0]);\n        Array.Sort(endIntervals, (o1, o2) => o1[0] - o2[0]);\n\n        int[] ans = new int[n];\n        for (int i = 0, j = 0; i < n; i++) {\n            while (j < n && endIntervals[i][0] > startIntervals[j][0]) {\n                j++;\n            }\n            if (j < n) {\n                ans[endIntervals[i][1]] = startIntervals[j][1];\n            } else {\n                ans[endIntervals[i][1]] = -1;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol2-C]\ntypedef struct {\n    int start;\n    int index;\n} Node;\n\nint cmp(const void *pa, const void *pb) {\n    return ((Node *)pa)->start - ((Node *)pb)->start;\n}\n\nint* findRightInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize){\n    Node * startIntervals = (Node *)malloc(sizeof(Node) * intervalsSize);\n    Node * endIntervals = (Node *)malloc(sizeof(Node) * intervalsSize);\n    for (int i = 0; i < intervalsSize; i++) {\n        startIntervals[i].start = intervals[i][0];\n        startIntervals[i].index = i;\n        endIntervals[i].start = intervals[i][1];\n        endIntervals[i].index = i;\n    }\n    qsort(startIntervals, intervalsSize, sizeof(Node), cmp);\n    qsort(endIntervals, intervalsSize, sizeof(Node), cmp);\n\n    int * ans = (int *)malloc(sizeof(int) * intervalsSize);\n    for (int i = 0, j = 0; i < intervalsSize; i++) {\n        while (j < intervalsSize && endIntervals[i].start > startIntervals[j].start) {\n            j++;\n        }\n        if (j < intervalsSize) {\n            ans[endIntervals[i].index] = startIntervals[j].index;\n        } else {\n            ans[endIntervals[i].index] = -1;\n        }\n    }\n    *returnSize = intervalsSize;\n    free(startIntervals);\n    free(endIntervals);\n    return ans;\n}\n```\n\n```go [sol2-Golang]\nfunc findRightInterval(intervals [][]int) []int {\n    n := len(intervals)\n    type pair struct{ x, i int }\n    starts := make([]pair, n)\n    ends := make([]pair, n)\n    for i, p := range intervals {\n        starts[i] = pair{p[0], i}\n        ends[i] = pair{p[1], i}\n    }\n    sort.Slice(starts, func(i, j int) bool { return starts[i].x < starts[j].x })\n    sort.Slice(ends, func(i, j int) bool { return ends[i].x < ends[j].x })\n\n    ans := make([]int, n)\n    j := 0\n    for _, p := range ends {\n        for j < n && starts[j].x < p.x {\n            j++\n        }\n        if j < n {\n            ans[p.i] = starts[j].i\n        } else {\n            ans[p.i] = -1\n        }\n    }\n    return ans\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar findRightInterval = function(intervals) {\n    const n = intervals.length;\n    const startIntervals = new Array(n).fill(0).map(() => new Array(2).fill(0));\n    const endIntervals = new Array(n).fill(0).map(() => new Array(2).fill(0));\n    for (let i = 0; i < n; i++) {\n        startIntervals[i][0] = intervals[i][0];\n        startIntervals[i][1] = i;\n        endIntervals[i][0] = intervals[i][1];\n        endIntervals[i][1] = i;\n    }\n    startIntervals.sort((o1, o2) => o1[0] - o2[0]);\n    endIntervals.sort((o1, o2) => o1[0] - o2[0]);\n\n    const ans = new Array(n).fill(0);\n    for (let i = 0, j = 0; i < n; i++) {\n        while (j < n && endIntervals[i][0] > startIntervals[j][0]) {\n            j++;\n        }\n        if (j < n) {\n            ans[endIntervals[i][1]] = startIntervals[j][1];\n        } else {\n            ans[endIntervals[i][1]] = -1;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 为区间数组的长度。两个数组的排序时间一共为 $O(n \\log n)$，查找每个区间的右侧区间的时间复杂度为 $O(n)$，因此总的时间复杂度为 $O(n \\log n)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为区间数组的长度。$\\textit{startIntervals}, \\textit{endIntervals}$ 均存储了 $n$ 个元素，因此空间复杂度为 $O(n)$。"
}