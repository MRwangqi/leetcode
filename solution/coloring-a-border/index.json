{
	"titleSlug": "coloring-a-border",
	"slug": "bian-kuang-zhao-se-by-leetcode-solution-0h5l",
	"url": "https://leetcode-cn.com/problems/coloring-a-border/solution/bian-kuang-zhao-se-by-leetcode-solution-0h5l/",
	"content": "#### 前言\n\n此题与搜索的经典题「[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)」较为类似，常规的思路是可以使用深度优先搜索或者广度优先搜索来寻找出位置 $(\\textit{row},\\textit{col})$ 的所在的连通分量，额外要做的是搜索的时候需要判断当前的点是否属于边界。如果属于边界，需要把该点加入到一个用来存所有边界点的数组中。当搜索完毕后，再将所有边界点的进行着色。\n\n#### 方法一：深度优先搜索\n\n**思路及解法**\n\n我们用递归来实现深度优先搜索遍历连通分量，用一个大小和 $\\textit{grid}$ 相同的矩阵 $\\textit{visited}$ 来记录当前节点是否被访问过，并把边界点存入数组$\\textit{borders}$ 中。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        borders = []\n        originalColor = grid[row][col]\n        visited[row][col] = True\n        self.dfs(grid, row, col, visited, borders, originalColor)\n        for x, y in borders:\n            grid[x][y] = color\n        return grid\n\n    def dfs(self, grid, x, y, visited, borders, originalColor):  \n        isBorder = False        \n        m, n = len(grid), len(grid[0])\n        direc = ((-1, 0), (1, 0), (0, -1), (0, 1))\n        for dx, dy in direc:\n            nx, ny = x + dx, y + dy\n            if not (0 <= nx < m and 0 <= ny < n and grid[nx][ny] == originalColor):\n                isBorder = True\n            elif not visited[nx][ny]:\n                visited[nx][ny] = True\n                self.dfs(grid, nx, ny, visited, borders, originalColor)\n        if isBorder:\n            borders.append((x, y))\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int m = grid.length, n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        List<int[]> borders = new ArrayList<>();\n        int originalColor = grid[row][col];\n        visited[row][col] = true;\n        dfs(grid, row, col, visited, borders, originalColor);\n        for (int i = 0; i < borders.size(); i++) {\n            int x = borders.get(i)[0], y = borders.get(i)[1];\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n\n    private void dfs(int[][] grid, int x, int y, boolean[][] visited, List<int[]> borders, int originalColor) {\n        int m = grid.length, n = grid[0].length;\n        boolean isBorder = false;\n        int[][] direc = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        for (int i = 0; i < 4; i++) {\n            int nx = direc[i][0] + x, ny = direc[i][1] + y;\n            if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {\n                isBorder = true;\n            } else if (!visited[nx][ny]){\n                visited[nx][ny] = true;\n                dfs(grid, nx, ny, visited, borders, originalColor);\n            }                \n        }\n        if (isBorder) {\n            borders.add(new int[]{x, y});\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\n        int m = grid.Length, n = grid[0].Length;\n        bool[,] visited = new bool[m, n];\n        IList<int[]> borders = new List<int[]>();\n        int originalColor = grid[row][col];\n        visited[row, col] = true;\n        DFS(grid, row, col, visited, borders, originalColor);\n        for (int i = 0; i < borders.Count; i++) {\n            int x = borders[i][0], y = borders[i][1];\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n\n    private void DFS(int[][] grid, int x, int y, bool[,] visited, IList<int[]> borders, int originalColor) {\n        int m = grid.Length, n = grid[0].Length;\n        bool isBorder = false;\n        int[][] direc = {new int[]{0, 1}, new int[]{0, -1}, new int[]{1, 0}, new int[]{-1, 0}};\n        for (int i = 0; i < 4; i++) {\n            int nx = direc[i][0] + x, ny = direc[i][1] + y;\n            if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {\n                isBorder = true;\n            } else if (!visited[nx, ny]){\n                visited[nx, ny] = true;\n                DFS(grid, nx, ny, visited, borders, originalColor);\n            }                \n        }\n        if (isBorder) {\n            borders.Add(new int[]{x, y});\n        }\n    }\n}\n```\n\n```C++ [sol1-C++]\ntypedef pair<int, int> pii;\n\nclass Solution {\npublic:\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        vector<pii> borders;\n        int originalColor = grid[row][col];\n        visited[row][col] = true;\n        dfs(grid, row, col, visited, borders, originalColor);\n        for (auto & [x, y] : borders) {\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n\n    void dfs(vector<vector<int>>& grid, int x, int y, vector<vector<bool>> & visited, vector<pii> & borders, int originalColor) {\n        int m = grid.size(), n = grid[0].size();\n        bool isBorder = false;\n        int direc[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        for (int i = 0; i < 4; i++) {\n            int nx = direc[i][0] + x, ny = direc[i][1] + y;\n            if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {\n                isBorder = true;\n            } else if (!visited[nx][ny]) {\n                visited[nx][ny] = true;\n                dfs(grid, nx, ny, visited, borders, originalColor);\n            }                \n        }\n        if (isBorder) {\n            borders.emplace_back(x, y);\n        }\n    }\n};\n```\n\n```go [sol1-Golang]\nvar dirs = []struct{ x, y int }{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\nfunc colorBorder(grid [][]int, row, col, color int) [][]int {\n    m, n := len(grid), len(grid[0])\n    type point struct{ x, y int }\n    borders := []point{}\n    originalColor := grid[row][col]\n    vis := make([][]bool, m)\n    for i := range vis {\n        vis[i] = make([]bool, n)\n    }\n\n    var dfs func(int, int)\n    dfs = func(x, y int) {\n        vis[x][y] = true\n        isBorder := false\n        for _, dir := range dirs {\n            nx, ny := x+dir.x, y+dir.y\n            if !(0 <= nx && nx < m && 0 <= ny && ny < n && grid[nx][ny] == originalColor) {\n                isBorder = true\n            } else if !vis[nx][ny] {\n                vis[nx][ny] = true\n                dfs(nx, ny)\n            }\n        }\n        if isBorder {\n            borders = append(borders, point{x, y})\n        }\n    }\n    dfs(row, col)\n\n    for _, p := range borders {\n        grid[p.x][p.y] = color\n    }\n    return grid\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar colorBorder = function(grid, row, col, color) {\n    const m = grid.length, n = grid[0].length;\n    const visited = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    const borders = [];\n    const originalColor = grid[row][col];\n    visited[row][col] = true;\n    dfs(grid, row, col, visited, borders, originalColor);\n    for (let i = 0; i < borders.length; i++) {\n        const x = borders[i][0], y = borders[i][1];\n        grid[x][y] = color;\n    }\n    return grid;\n};\n\nconst dfs = (grid, x, y, visited, borders, originalColor) => {\n    const m = grid.length, n = grid[0].length;\n    let isBorder = false;\n    const direc = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    for (let i = 0; i < 4; i++) {\n        const nx = direc[i][0] + x, ny = direc[i][1] + y;\n        if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] === originalColor)) {\n            isBorder = true;\n        } else if (!visited[nx][ny]){\n            visited[nx][ny] = true;\n            dfs(grid, nx, ny, visited, borders, originalColor);\n        }                \n    }\n    if (isBorder) {\n        borders.push([x, y]);\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是 $\\textit{grid}$ 的行数和列数。在最坏情况下，我们需要访问到 $\\textit{grid}$ 中的每个点。\n\n- 空间复杂度：$O(mn)$。我们用一个与 $\\textit{grid}$ 相同大小的矩阵来存储每个点是否被遍历过，而其他的空间消耗，比如递归和用来存储所有边界点的数组，均不超过 $O(mn)$。\n\n#### 方法二：广度优先搜索\n\n**思路及解法**\n\n我们用一个队列来实现广度优先搜索遍历连通分量，并用一个大小和 $\\textit{grid}$ 相同的矩阵 $\\textit{visited}$ 来记录当前节点是否被访问过，并把边界点存入数组$\\textit{borders}$ 中。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\n        originalColor = grid[row][col]\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        borders = []\n        direc = ((-1, 0), (1, 0), (0, -1), (0, 1))\n        q = deque([(row, col)])\n        visited[row][col] = True\n        while q:\n            x, y = q.popleft()\n            isBorder = False\n            for dx, dy in direc:\n                nx, ny = x + dx, y + dy\n                if not (0 <= nx < m and 0 <= ny < n and grid[nx][ny] == originalColor):\n                    isBorder = True\n                elif not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    q.append((nx, ny))\n            if isBorder:\n                borders.append((x, y))\n        for x, y in borders:\n            grid[x][y] = color\n        return grid\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int m = grid.length, n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        List<int[]> borders = new ArrayList<>();\n        int originalColor = grid[row][col];\n        int[][] direc = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        Deque<int[]> q = new ArrayDeque<>();\n        q.offer(new int[]{row, col});\n        visited[row][col] = true;\n        while (!q.isEmpty()) {\n            int[] node = q.poll();\n            int x = node[0], y = node[1];\n\n            boolean isBorder = false;\n            for (int i = 0; i < 4; i++) {\n                int nx = direc[i][0] + x, ny = direc[i][1] + y;\n                if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {\n                    isBorder = true;\n                } else if (!visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    q.offer(new int[]{nx, ny});\n                }         \n            }\n            if (isBorder) {\n                borders.add(new int[]{x, y});\n            }\n        }\n        for (int i = 0; i < borders.size(); i++) {\n            int x = borders.get(i)[0], y = borders.get(i)[1];\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\n        int m = grid.Length, n = grid[0].Length;\n        bool[,] visited = new bool[m, n];\n        IList<int[]> borders = new List<int[]>();\n        int originalColor = grid[row][col];\n        int[][] direc = {new int[]{0, 1}, new int[]{0, -1}, new int[]{1, 0}, new int[]{-1, 0}};\n        Queue<int[]> q = new Queue<int[]>();\n        visited[row, col] = true;\n        q.Enqueue(new int[]{row, col});\n        while (q.Count > 0) {\n            int[] node = q.Dequeue();\n            int x = node[0], y = node[1];\n            bool isBorder = false;\n            for (int i = 0; i < 4; i++) {\n                int nx = direc[i][0] + x, ny = direc[i][1] + y;\n                if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {\n                    isBorder = true;\n                } else if (!visited[nx, ny]) {\n                    visited[nx, ny] = true;\n                    q.Enqueue(new int[]{nx, ny});\n                }         \n            }\n            if (isBorder) {\n                borders.Add(new int[]{x, y});\n            }\n        }\n        for (int i = 0; i < borders.Count; i++) {\n            int x = borders[i][0], y = borders[i][1];\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n}\n```\n\n```C++ [sol2-C++]\ntypedef pair<int,int> pii;\n\nclass Solution {\npublic:\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        vector<pii> borders;\n        int originalColor = grid[row][col];\n        int direc[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        queue<pii> q;\n        q.emplace(row, col);\n        visited[row][col] = true;\n        while (!q.empty()) {\n            pii & node = q.front();\n            q.pop();\n            int x = node.first, y = node.second;\n\n            bool isBorder = false;\n            for (int i = 0; i < 4; i++) {\n                int nx = direc[i][0] + x, ny = direc[i][1] + y;\n                if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {\n                    isBorder = true;\n                } else if (!visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    q.emplace(nx, ny);\n                }         \n            }\n            if (isBorder) {\n                borders.emplace_back(x, y);\n            }\n        }\n        for (auto & [x, y] : borders) {\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n};\n```\n\n```go [sol2-Golang]\nvar dirs = []struct{ x, y int }{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\nfunc colorBorder(grid [][]int, row, col, color int) [][]int {\n    m, n := len(grid), len(grid[0])\n    type point struct{ x, y int }\n    borders := []point{}\n    originalColor := grid[row][col]\n    vis := make([][]bool, m)\n    for i := range vis {\n        vis[i] = make([]bool, n)\n    }\n\n    q := []point{{row, col}}\n    vis[row][col] = true\n    for len(q) > 0 {\n        p := q[0]\n        q = q[1:]\n        x, y := p.x, p.y\n        isBorder := false\n        for _, dir := range dirs {\n            nx, ny := x+dir.x, y+dir.y\n            if !(0 <= nx && nx < m && 0 <= ny && ny < n && grid[nx][ny] == originalColor) {\n                isBorder = true\n            } else if !vis[nx][ny] {\n                vis[nx][ny] = true\n                q = append(q, point{nx, ny})\n            }\n        }\n        if isBorder {\n            borders = append(borders, point{x, y})\n        }\n    }\n\n    for _, p := range borders {\n        grid[p.x][p.y] = color\n    }\n    return grid\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar colorBorder = function(grid, row, col, color) {\n    const m = grid.length, n = grid[0].length;\n    const visited = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    const borders = [];\n    const originalColor = grid[row][col];\n    const direc = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    const q = [];\n    q.push([row, col]);\n    visited[row][col] = true;\n    while (q.length) {\n        const node = q.pop();\n        const x = node[0], y = node[1];\n\n        let isBorder = false;\n        for (let i = 0; i < 4; i++) {\n            const nx = direc[i][0] + x, ny = direc[i][1] + y;\n            if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] === originalColor)) {\n                isBorder = true;\n            } else if (!visited[nx][ny]) {\n                visited[nx][ny] = true;\n                q.push([nx, ny]);\n            }         \n        }\n        if (isBorder) {\n            borders.push([x, y]);\n        }\n    }\n    for (let i = 0; i < borders.length; i++) {\n        const x = borders[i][0], y = borders[i][1];\n        grid[x][y] = color;\n    }\n    return grid;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是 $\\textit{grid}$ 的行数和列数。在最坏情况下，我们需要访问到 $\\textit{grid}$ 中的每个点。\n\n- 空间复杂度：$O(mn)$。我们用一个与 $\\textit{grid}$ 相同大小的矩阵来存储每个点是否被遍历过，而其他的空间消耗，比如广度优先搜索用到的队列和用来存储所有边界点的数组，均不超过 $O(mn)$。"
}