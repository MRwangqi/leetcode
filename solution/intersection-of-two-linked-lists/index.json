{
	"titleSlug": "intersection-of-two-linked-lists",
	"slug": "tu-jie-xiang-jiao-lian-biao-by-user7208t",
	"url": "https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/",
	"content": "一图胜千言，看图你就明白了\n\n空间复杂度 $O(1)$ 时间复杂度为 $O(n)$\n\n这里使用图解的方式，解释比较巧妙的一种实现。\n\n根据题目意思\n如果两个链表相交，那么相交点之后的长度是相同的\n\n我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。\n为此，我们必须消除两个链表的长度差\n\n1. 指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历\n2. 如果 pA 到了末尾，则 pA = headB 继续遍历\n3. 如果 pB 到了末尾，则 pB = headA 继续遍历\n4. 比较长的链表指针指向较短链表head时，长度差就消除了\n4. 如此，只需要将最短链表遍历两次即可找到位置\n\n听着可能有点绕，看图最直观，链表的题目最适合看图了\n\n![相交链表.png](https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png){:width=400}\n{:align=center}\n\n\n代码也很简单（此处代码是参考评论区的高手的）\n\n```Java []\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    if (headA == null || headB == null) return null;\n    ListNode pA = headA, pB = headB;\n    while (pA != pB) {\n        pA = pA == null ? headB : pA.next;\n        pB = pB == null ? headA : pB.next;\n    }\n    return pA;\n}\n```\n"
}