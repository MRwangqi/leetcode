{
	"titleSlug": "kth-largest-element-in-an-array",
	"slug": "shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-",
	"url": "https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ .mp4](9c5f6d66-f7ed-4d98-a8f4-5629eb8ed376)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n\n#### å‰è¨€\n\n+ çº¦å®šï¼šå‡è®¾è¿™é‡Œæ•°ç»„çš„é•¿åº¦ä¸º $n$ã€‚\n\n+ é¢˜ç›®åˆ†æï¼šæœ¬é¢˜å¸Œæœ›æˆ‘ä»¬è¿”å›æ•°ç»„æ’åºä¹‹åçš„å€’æ•°ç¬¬ $k$ ä¸ªä½ç½®ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šåŸºäºå¿«é€Ÿæ’åºçš„é€‰æ‹©æ–¹æ³•\n\n**æ€è·¯å’Œç®—æ³•**\n\næˆ‘ä»¬å¯ä»¥ç”¨å¿«é€Ÿæ’åºæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå…ˆå¯¹åŸæ•°ç»„æ’åºï¼Œå†è¿”å›å€’æ•°ç¬¬ $k$ ä¸ªä½ç½®ï¼Œè¿™æ ·å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n \\log n)$ï¼Œä½†å…¶å®æˆ‘ä»¬å¯ä»¥åšçš„æ›´å¿«ã€‚\n\né¦–å…ˆæˆ‘ä»¬æ¥å›é¡¾ä¸€ä¸‹å¿«é€Ÿæ’åºï¼Œè¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„åˆ†æ²»ç®—æ³•ã€‚æˆ‘ä»¬å¯¹æ•°ç»„ $a[l \\cdots r]$ åšå¿«é€Ÿæ’åºçš„è¿‡ç¨‹æ˜¯ï¼ˆå‚è€ƒã€Šç®—æ³•å¯¼è®ºã€‹ï¼‰ï¼š\n\n+ **åˆ†è§£ï¼š** å°†æ•°ç»„ $a[l \\cdots r]$ ã€Œåˆ’åˆ†ã€æˆä¸¤ä¸ªå­æ•°ç»„ $a[l \\cdots q - 1]$ã€$a[q + 1 \\cdots r]$ï¼Œä½¿å¾— $a[l \\cdots q - 1]$ ä¸­çš„æ¯ä¸ªå…ƒç´ å°äºç­‰äº $a[q]$ï¼Œä¸” $a[q]$ å°äºç­‰äº $a[q + 1 \\cdots r]$ ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚å…¶ä¸­ï¼Œè®¡ç®—ä¸‹æ ‡ $q$ ä¹Ÿæ˜¯ã€Œåˆ’åˆ†ã€è¿‡ç¨‹çš„ä¸€éƒ¨åˆ†ã€‚\n+ **è§£å†³ï¼š** é€šè¿‡é€’å½’è°ƒç”¨å¿«é€Ÿæ’åºï¼Œå¯¹å­æ•°ç»„ $a[l \\cdots q - 1]$ å’Œ $a[q + 1 \\cdots r]$ è¿›è¡Œæ’åºã€‚\n+ **åˆå¹¶ï¼š** å› ä¸ºå­æ•°ç»„éƒ½æ˜¯åŸå€æ’åºçš„ï¼Œæ‰€ä»¥ä¸éœ€è¦è¿›è¡Œåˆå¹¶æ“ä½œï¼Œ$a[l \\cdots r]$ å·²ç»æœ‰åºã€‚\n+ ä¸Šæ–‡ä¸­æåˆ°çš„ **ã€Œåˆ’åˆ†ã€** è¿‡ç¨‹æ˜¯ï¼šä»å­æ•°ç»„ $a[l \\cdots r]$ ä¸­é€‰æ‹©ä»»æ„ä¸€ä¸ªå…ƒç´  $x$ ä½œä¸ºä¸»å…ƒï¼Œ**è°ƒæ•´å­æ•°ç»„çš„å…ƒç´ ä½¿å¾—å·¦è¾¹çš„å…ƒç´ éƒ½å°äºç­‰äºå®ƒï¼Œå³è¾¹çš„å…ƒç´ éƒ½å¤§äºç­‰äºå®ƒï¼Œ** $x$ çš„æœ€ç»ˆä½ç½®å°±æ˜¯ $q$ã€‚\n\nç”±æ­¤å¯ä»¥å‘ç°æ¯æ¬¡ç»è¿‡ã€Œåˆ’åˆ†ã€æ“ä½œåï¼Œæˆ‘ä»¬ä¸€å®šå¯ä»¥ç¡®å®šä¸€ä¸ªå…ƒç´ çš„æœ€ç»ˆä½ç½®ï¼Œå³ $x$ çš„æœ€ç»ˆä½ç½®ä¸º $q$ï¼Œå¹¶ä¸”ä¿è¯ $a[l \\cdots q - 1]$ ä¸­çš„æ¯ä¸ªå…ƒç´ å°äºç­‰äº $a[q]$ï¼Œä¸” $a[q]$ å°äºç­‰äº $a[q + 1 \\cdots r]$ ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚**æ‰€ä»¥åªè¦æŸæ¬¡åˆ’åˆ†çš„ $q$ ä¸ºå€’æ•°ç¬¬ $k$ ä¸ªä¸‹æ ‡çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±å·²ç»æ‰¾åˆ°äº†ç­”æ¡ˆã€‚** æˆ‘ä»¬åªå…³å¿ƒè¿™ä¸€ç‚¹ï¼Œè‡³äº $a[l \\cdots q - 1]$ å’Œ $a[q+1 \\cdots r]$ æ˜¯å¦æ˜¯æœ‰åºçš„ï¼Œæˆ‘ä»¬ä¸å…³å¿ƒã€‚\n\nå› æ­¤æˆ‘ä»¬å¯ä»¥æ”¹è¿›å¿«é€Ÿæ’åºç®—æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼šåœ¨åˆ†è§£çš„è¿‡ç¨‹å½“ä¸­ï¼Œæˆ‘ä»¬ä¼šå¯¹å­æ•°ç»„è¿›è¡Œåˆ’åˆ†ï¼Œå¦‚æœåˆ’åˆ†å¾—åˆ°çš„ $q$ æ­£å¥½å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ä¸‹æ ‡ï¼Œå°±ç›´æ¥è¿”å› $a[q]$ï¼›å¦åˆ™ï¼Œå¦‚æœ $q$ æ¯”ç›®æ ‡ä¸‹æ ‡å°ï¼Œå°±é€’å½’å³å­åŒºé—´ï¼Œå¦åˆ™é€’å½’å·¦å­åŒºé—´ã€‚è¿™æ ·å°±å¯ä»¥æŠŠåŸæ¥é€’å½’ä¸¤ä¸ªåŒºé—´å˜æˆåªé€’å½’ä¸€ä¸ªåŒºé—´ï¼Œæé«˜äº†æ—¶é—´æ•ˆç‡ã€‚è¿™å°±æ˜¯ã€Œå¿«é€Ÿé€‰æ‹©ã€ç®—æ³•ã€‚\n\næˆ‘ä»¬çŸ¥é“å¿«é€Ÿæ’åºçš„æ€§èƒ½å’Œã€Œåˆ’åˆ†ã€å‡ºçš„å­æ•°ç»„çš„é•¿åº¦å¯†åˆ‡ç›¸å…³ã€‚ç›´è§‚åœ°ç†è§£å¦‚æœæ¯æ¬¡è§„æ¨¡ä¸º $n$ çš„é—®é¢˜æˆ‘ä»¬éƒ½åˆ’åˆ†æˆ $1$ å’Œ $n - 1$ï¼Œæ¯æ¬¡é€’å½’çš„æ—¶å€™åˆå‘ $n - 1$ çš„é›†åˆä¸­é€’å½’ï¼Œè¿™ç§æƒ…å†µæ˜¯æœ€åçš„ï¼Œæ—¶é—´ä»£ä»·æ˜¯ $O(n ^ 2)$ã€‚æˆ‘ä»¬å¯ä»¥å¼•å…¥éšæœºåŒ–æ¥åŠ é€Ÿè¿™ä¸ªè¿‡ç¨‹ï¼Œå®ƒçš„æ—¶é—´ä»£ä»·çš„æœŸæœ›æ˜¯ $O(n)$ï¼Œè¯æ˜è¿‡ç¨‹å¯ä»¥å‚è€ƒã€Œã€Šç®—æ³•å¯¼è®ºã€‹9.2ï¼šæœŸæœ›ä¸ºçº¿æ€§çš„é€‰æ‹©ç®—æ³•ã€ã€‚\n\n**ä»£ç **\n\n```cpp [sol1-C++]\nclass Solution {\npublic:\n    int quickSelect(vector<int>& a, int l, int r, int index) {\n        int q = randomPartition(a, l, r);\n        if (q == index) {\n            return a[q];\n        } else {\n            return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);\n        }\n    }\n\n    inline int randomPartition(vector<int>& a, int l, int r) {\n        int i = rand() % (r - l + 1) + l;\n        swap(a[i], a[r]);\n        return partition(a, l, r);\n    }\n\n    inline int partition(vector<int>& a, int l, int r) {\n        int x = a[r], i = l - 1;\n        for (int j = l; j < r; ++j) {\n            if (a[j] <= x) {\n                swap(a[++i], a[j]);\n            }\n        }\n        swap(a[i + 1], a[r]);\n        return i + 1;\n    }\n\n    int findKthLargest(vector<int>& nums, int k) {\n        srand(time(0));\n        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);\n    }\n};\n```\n```Java [sol1-Java]\nclass Solution {\n    Random random = new Random();\n\n    public int findKthLargest(int[] nums, int k) {\n        return quickSelect(nums, 0, nums.length - 1, nums.length - k);\n    }\n\n    public int quickSelect(int[] a, int l, int r, int index) {\n        int q = randomPartition(a, l, r);\n        if (q == index) {\n            return a[q];\n        } else {\n            return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);\n        }\n    }\n\n    public int randomPartition(int[] a, int l, int r) {\n        int i = random.nextInt(r - l + 1) + l;\n        swap(a, i, r);\n        return partition(a, l, r);\n    }\n\n    public int partition(int[] a, int l, int r) {\n        int x = a[r], i = l - 1;\n        for (int j = l; j < r; ++j) {\n            if (a[j] <= x) {\n                swap(a, ++i, j);\n            }\n        }\n        swap(a, i + 1, r);\n        return i + 1;\n    }\n\n    public void swap(int[] a, int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n}\n```\n\n```C [sol1-C]\ninline int partition(int* a, int l, int r) {\n    int x = a[r], i = l - 1;\n    for (int j = l; j < r; ++j) {\n        if (a[j] <= x) {\n            int t = a[++i];\n            a[i] = a[j], a[j] = t;\n        }\n    }\n    int t = a[i + 1];\n    a[i + 1] = a[r], a[r] = t;\n    return i + 1;\n}\n\ninline int randomPartition(int* a, int l, int r) {\n    int i = rand() % (r - l + 1) + l;\n    int t = a[i];\n    a[i] = a[r], a[r] = t;\n    return partition(a, l, r);\n}\n\nint quickSelect(int* a, int l, int r, int index) {\n    int q = randomPartition(a, l, r);\n    if (q == index) {\n        return a[q];\n    } else {\n        return q < index ? quickSelect(a, q + 1, r, index)\n                         : quickSelect(a, l, q - 1, index);\n    }\n}\n\nint findKthLargest(int* nums, int numsSize, int k) {\n    srand(time(0));\n    return quickSelect(nums, 0, numsSize - 1, numsSize - k);\n}\n```\n\n```golang [sol1-Golang]\nfunc findKthLargest(nums []int, k int) int {\n    rand.Seed(time.Now().UnixNano())\n    return quickSelect(nums, 0, len(nums)-1, len(nums)-k)\n}\n\nfunc quickSelect(a []int, l, r, index int) int {\n    q := randomPartition(a, l, r)\n    if q == index {\n        return a[q]\n    } else if q < index {\n        return quickSelect(a, q + 1, r, index)\n    }\n    return quickSelect(a, l, q - 1, index)\n}\n\nfunc randomPartition(a []int, l, r int) int {\n    i := rand.Int() % (r - l + 1) + l\n    a[i], a[r] = a[r], a[i]\n    return partition(a, l, r)\n}\n\nfunc partition(a []int, l, r int) int {\n    x := a[r]\n    i := l - 1\n    for j := l; j < r; j++ {\n        if a[j] <= x {\n            i++\n            a[i], a[j] = a[j], a[i]\n        }\n    }\n    a[i+1], a[r] = a[r], a[i+1]\n    return i + 1\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå¦‚ä¸Šæ–‡æ‰€è¿°ï¼Œè¯æ˜è¿‡ç¨‹å¯ä»¥å‚è€ƒã€Œã€Šç®—æ³•å¯¼è®ºã€‹9.2ï¼šæœŸæœ›ä¸ºçº¿æ€§çš„é€‰æ‹©ç®—æ³•ã€ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(\\log n)$ï¼Œé€’å½’ä½¿ç”¨æ ˆç©ºé—´çš„ç©ºé—´ä»£ä»·çš„æœŸæœ›ä¸º $O(\\log n)$ã€‚\n\n#### æ–¹æ³•äºŒï¼šåŸºäºå †æ’åºçš„é€‰æ‹©æ–¹æ³•\n\n**æ€è·¯å’Œç®—æ³•**\n\næˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨å †æ’åºæ¥è§£å†³è¿™ä¸ªé—®é¢˜â€”â€”å»ºç«‹ä¸€ä¸ªå¤§æ ¹å †ï¼Œåš $k - 1$ æ¬¡åˆ é™¤æ“ä½œåå †é¡¶å…ƒç´ å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ç­”æ¡ˆã€‚åœ¨å¾ˆå¤šè¯­è¨€ä¸­ï¼Œéƒ½æœ‰ä¼˜å…ˆé˜Ÿåˆ—æˆ–è€…å †çš„çš„å®¹å™¨å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œä½†æ˜¯åœ¨é¢è¯•ä¸­ï¼Œé¢è¯•å®˜æ›´å€¾å‘äºè®©æ›´é¢è¯•è€…è‡ªå·±å®ç°ä¸€ä¸ªå †ã€‚æ‰€ä»¥å»ºè®®è¯»è€…æŒæ¡è¿™é‡Œå¤§æ ¹å †çš„å®ç°æ–¹æ³•ï¼Œåœ¨è¿™é“é¢˜ä¸­å°¤å…¶è¦ææ‡‚ã€Œå»ºå †ã€ã€ã€Œè°ƒæ•´ã€å’Œã€Œåˆ é™¤ã€çš„è¿‡ç¨‹ã€‚\n\n**å‹æƒ…æé†’ï¼šã€Œå †æ’ã€åœ¨å¾ˆå¤šå¤§å…¬å¸çš„é¢è¯•ä¸­éƒ½å¾ˆå¸¸è§ï¼Œä¸äº†è§£çš„åŒå­¦å»ºè®®å‚è€ƒã€Šç®—æ³•å¯¼è®ºã€‹æˆ–è€…å¤§å®¶çš„æ•°æ®ç»“æ„æ•™æï¼Œä¸€å®šè¦å­¦ä¼šè¿™ä¸ªçŸ¥è¯†ç‚¹å“¦ï¼^_^**\n\n<![fig1](https://assets.leetcode-cn.com/solution-static/215/1.png),![fig2](https://assets.leetcode-cn.com/solution-static/215/2.png),![fig3](https://assets.leetcode-cn.com/solution-static/215/3.png),![fig4](https://assets.leetcode-cn.com/solution-static/215/4.png),![fig5](https://assets.leetcode-cn.com/solution-static/215/5.png),![fig6](https://assets.leetcode-cn.com/solution-static/215/6.png),![fig7](https://assets.leetcode-cn.com/solution-static/215/7.png),![fig8](https://assets.leetcode-cn.com/solution-static/215/8.png),![fig9](https://assets.leetcode-cn.com/solution-static/215/9.png),![fig10](https://assets.leetcode-cn.com/solution-static/215/10.png),![fig11](https://assets.leetcode-cn.com/solution-static/215/11.png),![fig12](https://assets.leetcode-cn.com/solution-static/215/12.png),![fig13](https://assets.leetcode-cn.com/solution-static/215/13.png),![fig14](https://assets.leetcode-cn.com/solution-static/215/14.png),![fig15](https://assets.leetcode-cn.com/solution-static/215/15.png),![fig16](https://assets.leetcode-cn.com/solution-static/215/16.png),![fig17](https://assets.leetcode-cn.com/solution-static/215/17.png),![fig18](https://assets.leetcode-cn.com/solution-static/215/18.png),![fig19](https://assets.leetcode-cn.com/solution-static/215/19.png),![fig20](https://assets.leetcode-cn.com/solution-static/215/20.png)>\n\n**ä»£ç **\n\n```cpp [sol2-C++]\nclass Solution {\npublic:\n    void maxHeapify(vector<int>& a, int i, int heapSize) {\n        int l = i * 2 + 1, r = i * 2 + 2, largest = i;\n        if (l < heapSize && a[l] > a[largest]) {\n            largest = l;\n        } \n        if (r < heapSize && a[r] > a[largest]) {\n            largest = r;\n        }\n        if (largest != i) {\n            swap(a[i], a[largest]);\n            maxHeapify(a, largest, heapSize);\n        }\n    }\n\n    void buildMaxHeap(vector<int>& a, int heapSize) {\n        for (int i = heapSize / 2; i >= 0; --i) {\n            maxHeapify(a, i, heapSize);\n        } \n    }\n\n    int findKthLargest(vector<int>& nums, int k) {\n        int heapSize = nums.size();\n        buildMaxHeap(nums, heapSize);\n        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {\n            swap(nums[0], nums[i]);\n            --heapSize;\n            maxHeapify(nums, 0, heapSize);\n        }\n        return nums[0];\n    }\n};\n```\n```Java [sol2-Java]\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int heapSize = nums.length;\n        buildMaxHeap(nums, heapSize);\n        for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {\n            swap(nums, 0, i);\n            --heapSize;\n            maxHeapify(nums, 0, heapSize);\n        }\n        return nums[0];\n    }\n\n    public void buildMaxHeap(int[] a, int heapSize) {\n        for (int i = heapSize / 2; i >= 0; --i) {\n            maxHeapify(a, i, heapSize);\n        } \n    }\n\n    public void maxHeapify(int[] a, int i, int heapSize) {\n        int l = i * 2 + 1, r = i * 2 + 2, largest = i;\n        if (l < heapSize && a[l] > a[largest]) {\n            largest = l;\n        } \n        if (r < heapSize && a[r] > a[largest]) {\n            largest = r;\n        }\n        if (largest != i) {\n            swap(a, i, largest);\n            maxHeapify(a, largest, heapSize);\n        }\n    }\n\n    public void swap(int[] a, int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n}\n```\n\n```C [sol2-C]\nvoid maxHeapify(int* a, int i, int heapSize) {\n    int l = i * 2 + 1, r = i * 2 + 2, largest = i;\n    if (l < heapSize && a[l] > a[largest]) {\n        largest = l;\n    }\n    if (r < heapSize && a[r] > a[largest]) {\n        largest = r;\n    }\n    if (largest != i) {\n        int t = a[i];\n        a[i] = a[largest], a[largest] = t;\n        maxHeapify(a, largest, heapSize);\n    }\n}\n\nvoid buildMaxHeap(int* a, int heapSize) {\n    for (int i = heapSize / 2; i >= 0; --i) {\n        maxHeapify(a, i, heapSize);\n    }\n}\n\nint findKthLargest(int* nums, int numsSize, int k) {\n    int heapSize = numsSize;\n    buildMaxHeap(nums, heapSize);\n    for (int i = numsSize - 1; i >= numsSize - k + 1; --i) {\n        int t = nums[0];\n        nums[0] = nums[i], nums[i] = t;\n        --heapSize;\n        maxHeapify(nums, 0, heapSize);\n    }\n    return nums[0];\n}\n```\n\n```golang [sol2-Golang]\nfunc findKthLargest(nums []int, k int) int {\n    heapSize := len(nums)\n    buildMaxHeap(nums, heapSize)\n    for i := len(nums) - 1; i >= len(nums) - k + 1; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapSize--\n        maxHeapify(nums, 0, heapSize)\n    }\n    return nums[0]\n}\n\nfunc buildMaxHeap(a []int, heapSize int) {\n    for i := heapSize/2; i >= 0; i-- {\n        maxHeapify(a, i, heapSize)\n    }\n}\n\nfunc maxHeapify(a []int, i, heapSize int) {\n    l, r, largest := i * 2 + 1, i * 2 + 2, i\n    if l < heapSize && a[l] > a[largest] {\n        largest = l\n    }\n    if r < heapSize && a[r] > a[largest] {\n        largest = r\n    }\n    if largest != i {\n        a[i], a[largest] = a[largest], a[i]\n        maxHeapify(a, largest, heapSize)\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \\log n)$ï¼Œå»ºå †çš„æ—¶é—´ä»£ä»·æ˜¯ $O(n)$ï¼Œåˆ é™¤çš„æ€»ä»£ä»·æ˜¯ $O(k \\log n)$ï¼Œå› ä¸º $k < n$ï¼Œæ•…æ¸è¿›æ—¶é—´å¤æ‚ä¸º $O(n + k \\log n) = O(n \\log n)$ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(\\log n)$ï¼Œå³é€’å½’ä½¿ç”¨æ ˆç©ºé—´çš„ç©ºé—´ä»£ä»·ã€‚"
}