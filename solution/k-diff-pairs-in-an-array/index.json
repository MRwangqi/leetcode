{
	"titleSlug": "k-diff-pairs-in-an-array",
	"slug": "shu-zu-zhong-de-k-diff-shu-dui-by-leetco-ane6",
	"url": "https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/solution/shu-zu-zhong-de-k-diff-shu-dui-by-leetco-ane6/",
	"content": "#### 方法一：哈希表\n\n**思路**\n\n遍历数组，找出符合条件的数对。因为是寻找不同的数对，所以可以将数对放入哈希表 $\\textit{res}$，完成去重的效果，最后返回哈希表的长度即可。遍历数组时，可以将遍历到的下标当作潜在的 $j$，判断 $j$ 左侧是否有满足条件的 $i$ 来构成 **k-diff** 数对，而这一判断也可以通过提前将下标 $j$ 左侧的元素都放入另一个哈希表 $\\textit{visited}$ 来降低时间复杂度。如果可以构成，则将数对放入哈希表 $\\textit{res}$。\n\n代码实现时，由于 $k$ 是定值，知道数对的较小值，也就知道了另一个值，因此我们可以只将数对的较小值放入 $\\textit{res}$，而不影响结果的正确性。判断完之后，再将当前元素放入 $\\textit{visited}$，作为后续判断潜在的 $\\textit{nums}[i]$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findPairs(self, nums: List[int], k: int) -> int:\n        visited, res = set(), set()\n        for num in nums:\n            if num - k in visited:\n                res.add(num - k)\n            if num + k in visited:\n                res.add(num)\n            visited.add(num)\n        return len(res) \n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findPairs(int[] nums, int k) {\n        Set<Integer> visited = new HashSet<Integer>();\n        Set<Integer> res = new HashSet<Integer>();\n        for (int num : nums) {\n            if (visited.contains(num - k)) {\n                res.add(num - k);\n            }\n            if (visited.contains(num + k)) {\n                res.add(num);\n            }\n            visited.add(num);\n        }\n        return res.size();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindPairs(int[] nums, int k) {\n        ISet<int> visited = new HashSet<int>();\n        ISet<int> res = new HashSet<int>();\n        foreach (int num in nums) {\n            if (visited.Contains(num - k)) {\n                res.Add(num - k);\n            }\n            if (visited.Contains(num + k)) {\n                res.Add(num);\n            }\n            visited.Add(num);\n        }\n        return res.Count;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        unordered_set<int> visited;\n        unordered_set<int> res;\n        for (int num : nums) {\n            if (visited.count(num - k)) {\n                res.emplace(num - k);\n            }\n            if (visited.count(num + k)) {\n                res.emplace(num);\n            }\n            visited.emplace(num);\n        }\n        return res.size();\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    UT_hash_handle hh;\n} HashItem;\n\nint findPairs(int* nums, int numsSize, int k){\n    HashItem *visited = NULL, *res = NULL;\n    int target = 0;\n    for (int i = 0; i < numsSize; i++) {\n        HashItem *pEntry = NULL;\n        target = nums[i] - k;\n        HASH_FIND_INT(visited, &target, pEntry);\n        if (pEntry) {\n            pEntry = NULL;\n            HASH_FIND_INT(res, &target, pEntry); \n            if (NULL == pEntry) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                pEntry->key = nums[i] - k;\n                HASH_ADD_INT(res, key, pEntry);\n            }\n        }\n        pEntry = NULL;\n        target = nums[i] + k;\n        HASH_FIND_INT(visited, &target, pEntry);\n        if (pEntry) {\n            pEntry = NULL;\n            target = nums[i];\n            HASH_FIND_INT(res, &target, pEntry); \n            if (NULL == pEntry) {\n                pEntry = (HashItem *)malloc(sizeof(HashItem));\n                pEntry->key = nums[i];\n                HASH_ADD_INT(res, key, pEntry);\n            }\n        }\n        pEntry = NULL;\n        target = nums[i];\n        HASH_FIND_INT(visited, &target, pEntry);\n        if (NULL == pEntry) {\n            pEntry = (HashItem *)malloc(sizeof(HashItem));\n            pEntry->key = nums[i];\n            HASH_ADD_INT(visited, key, pEntry);\n        }\n    }\n    return HASH_COUNT(res);\n}\n```\n\n```go [sol1-Golang]\nfunc findPairs(nums []int, k int) int {\n    visited := map[int]struct{}{}\n    res := map[int]struct{}{}\n    for _, num := range nums {\n        if _, ok := visited[num-k]; ok {\n            res[num-k] = struct{}{}\n        }\n        if _, ok := visited[num+k]; ok {\n            res[num] = struct{}{}\n        }\n        visited[num] = struct{}{}\n    }\n    return len(res)\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findPairs = function(nums, k) {\n    const visited = new Set();\n    const res = new Set();\n    for (const num of nums) {\n        if (visited.has(num - k)) {\n            res.add(num - k);\n        }\n        if (visited.has(num + k)) {\n            res.add(num);\n        }\n        visited.add(num);\n    }\n    return res.size;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\text{nums}$ 的长度。需要遍历 $\\text{nums}$ 一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\\text{nums}$ 的长度。两个哈希表最多各存放 $n$ 个元素。\n\n#### 方法二：排序 + 双指针\n\n**思路**\n\n题干的两个条件可以这样解读：\n\n- 数对的两个元素的下标值不同。当 $k = 0$ 时，数对的两个元素值可以相同，但下标值必须不同。\n- 数对的两个元素差值为 $k$。\n\n这样的解读之下，原来 $i$ 和 $j$ 的大小关系被抹除了，只要求 $i$ 和 $j$ 不相等。而差值为 $k$ 这一要求则可以在排序后使用双指针来满足。\n\n将原数组升序排序，并用新的指针 $x$ 和 $y$ 来搜索数对。即寻找不同的 $(\\textit{nums}[x], \\textit{nums}[y])$ 满足：\n- $x < y$\n- $\\textit{nums}[x] + k = \\textit{nums}[y]$\n\n记录满足要求的 $x$ 的个数并返回。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def findPairs(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n, y, res = len(nums), 0, 0\n        for x in range(n):\n            if x == 0 or nums[x] != nums[x - 1]:\n                while y < n and (nums[y] < nums[x] + k or y <= x):\n                    y += 1\n                if y < n and nums[y] == nums[x] + k:\n                    res += 1\n        return res\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int findPairs(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length, y = 0, res = 0;\n        for (int x = 0; x < n; x++) {\n            if (x == 0 || nums[x] != nums[x - 1]) {\n                while (y < n && (nums[y] < nums[x] + k || y <= x)) {\n                    y++;\n                }\n                if (y < n && nums[y] == nums[x] + k) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int FindPairs(int[] nums, int k) {\n        Array.Sort(nums);\n        int n = nums.Length, y = 0, res = 0;\n        for (int x = 0; x < n; x++) {\n            if (x == 0 || nums[x] != nums[x - 1]) {\n                while (y < n && (nums[y] < nums[x] + k || y <= x)) {\n                    y++;\n                }\n                if (y < n && nums[y] == nums[x] + k) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), y = 0, res = 0;\n        for (int x = 0; x < n; x++) {\n            if (x == 0 || nums[x] != nums[x - 1]) {\n                while (y < n && (nums[y] < nums[x] + k || y <= x)) {\n                    y++;\n                }\n                if (y < n && nums[y] == nums[x] + k) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C [sol2-C]\nstatic inline int cmp(const void* pa, const void* pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint findPairs(int* nums, int numsSize, int k){\n    qsort(nums, numsSize, sizeof(int), cmp);\n    int y = 0, res = 0;\n    for (int x = 0; x < numsSize; x++) {\n        if (x == 0 || nums[x] != nums[x - 1]) {\n            while (y < numsSize && (nums[y] < nums[x] + k || y <= x)) {\n                y++;\n            }\n            if (y < numsSize && nums[y] == nums[x] + k) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\n```go [sol2-Golang]\nfunc findPairs(nums []int, k int) (ans int) {\n    sort.Ints(nums)\n    y, n := 0, len(nums)\n    for x, num := range nums {\n        if x == 0 || num != nums[x-1] {\n            for y < n && (nums[y] < num+k || y <= x) {\n                y++\n            }\n            if y < n && nums[y] == num+k {\n                ans++\n            }\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar findPairs = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let n = nums.length, y = 0, res = 0;\n    for (let x = 0; x < n; x++) {\n        if (x === 0 || nums[x] !== nums[x - 1]) {\n            while (y < n && (nums[y] < nums[x] + k || y <= x)) {\n                y++;\n            }\n            if (y < n && nums[y] === nums[x] + k) {\n                res++;\n            }\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n\\log n)$，其中 $n$ 是数组 $\\text{nums}$ 的长度。排序需要消耗 $O(n\\log n)$ 复杂度，遍历指针 $x$ 消耗 $O(n)$ 复杂度，指针 $y$ 的值最多变化 $O(n)$ 次，总的时间复杂度为 $O(n\\log n)$。\n\n- 空间复杂度：$O(\\log n)$，其中 $n$ 是数组 $\\text{nums}$ 的长度。排序消耗 $O(\\log n)$ 复杂度，其余消耗常数空间复杂度，总的空间复杂度为 $O(\\log n)$。"
}