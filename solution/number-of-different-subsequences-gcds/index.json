{
	"titleSlug": "number-of-different-subsequences-gcds",
	"slug": "xu-lie-zhong-bu-tong-zui-da-gong-yue-shu-lrka",
	"url": "https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/solution/xu-lie-zhong-bu-tong-zui-da-gong-yue-shu-lrka/",
	"content": "#### 方法一：数学\n\n**提示 1**\n\n考虑逆向思维。如果我们希望构造出一个序列，使得该序列的最大公约数为 $g$，那么我们应该怎么做？\n\n**提示 2**\n\n给定的数组存在一个序列的最大公约数为 $g$，当且仅当数组中所有 $g$ 的倍数的最大公约数为 $g$。\n\n**提示 2 证明**\n\n首先我们只能在数组中选择 $g$ 的倍数，否则构造出的序列的最大公约数一定就不是 $g$ 的倍数，也就不可能是 $g$ 了。\n\n因此，如果数组中存在某个序列的最大公约数为 $g$，那么序列中的每个数都是 $g$ 的倍数，我们再选上其它没有出现在序列中（但出现在数组中）并且为 $g$ 的倍数的那些数，此时最大公约数仍然保持 $g$ 不变。\n\n因此我们就证明了上述结论。\n\n**思路与算法**\n\n设数组 $g[y]$ 表示当前遍历过的所有数中，所有 $y$ 的倍数的最大公约数。\n\n对于数组中的每个数 $x$，我们枚举其所有的约数 $y$，并使用 $x$ 更新 $g[y]$ 即可。\n\n最终遍历数组 $g$，只要有 $y = g[y]$，那么答案增加 $1$。\n\n**$\\texttt{C++}$ 代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int countDifferentSubsequenceGCDs(vector<int>& nums) {\n        int c = *max_element(nums.begin(), nums.end());\n        vector<int> g(c + 1);\n        \n        for (int x: nums) {\n            for (int y = 1; y * y <= x; ++y) {\n                if (x % y == 0) {\n                    if (!g[y]) {\n                        g[y] = x;\n                    }\n                    else {\n                        g[y] = gcd(g[y], x);\n                    }\n                    if (y * y != x) {\n                        int z = x / y;\n                        if (!g[z]) {\n                            g[z] = x;\n                        }\n                        else {\n                            g[z] = gcd(g[z], x);\n                        }\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int i = 1; i <= c; ++i) {\n            if (g[i] == i) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n**$\\texttt{Python}$ 代码**\n\n上面的方法使用 $\\texttt{Python}$ 可能会超出时间限制，我们可以稍微修改一下算法，使其利用到 $\\texttt{Python}$ 比较快的数据结构（比如 $\\texttt{set}$ 或 $\\texttt{dict}$）而不用 $\\texttt{list}$。\n\n我们将数组中的所有元素放入集合中，然后我们直接枚举最大公约数 $y$，并依次判断 $y, 2y, 3y, \\cdots$ 是否在集合中，如果在，就用其计算最大公约数。\n\n这样做的好处在于，如果当前计算出的最大公约数已经为 $y$，那么我们就可以直接退出并累加答案了。\n\n当然 $\\texttt{C++}$ 代码也可以这样写，并且也会比上一种方法快很多，不过最好使用数组代替集合。\n\n```Python [sol2-Python3]\nclass Solution:\n    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:\n        nums = set(nums)\n        c = max(nums)\n        ans = 0\n\n        for y in range(1, c + 1):\n            g = None\n            for x in range(y, c + 1, y):\n                if x in nums:\n                    if not g:\n                        g = x\n                    else:\n                        g = math.gcd(g, x)\n                    if g == y:\n                        ans += 1\n                        break\n        \n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int countDifferentSubsequenceGCDs(vector<int>& nums) {\n        int c = *max_element(nums.begin(), nums.end());\n        vector<int> occ(c + 1);\n        for (int num: nums) {\n            occ[num] = 1;\n        }\n        \n        int ans = 0;\n        for (int y = 1; y <= c; ++y) {\n            int g = -1;\n            for (int x = y; x <= c; x += y) {\n                if (occ[x]) {\n                    if (g == -1) {\n                        g = x;\n                    }\n                    else {\n                        g = gcd(g, x);\n                    }\n                    if (g == y) {\n                        ++ans;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$\\texttt{C++}$ 代码为 $O(n \\sqrt C + C \\log C)$，$\\texttt{Python}$ 代码为 $O(n + C \\log C)$，其中 $n$ 是数组的长度，$C$ 是数组元素的最大值，不会超过 $2 \\times 10^5$。\n\n- 空间复杂度：$O(C)$。\n\n**扩展**\n\n请用这一思路解决 [AtCoder Beginner Contest 191 Problem F](https://atcoder.jp/contests/abc191/tasks/abc191_f)。"
}