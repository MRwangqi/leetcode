{
	"titleSlug": "matchsticks-to-square",
	"slug": "huo-chai-pin-zheng-fang-xing-by-leetcode-szdp",
	"url": "https://leetcode-cn.com/problems/matchsticks-to-square/solution/huo-chai-pin-zheng-fang-xing-by-leetcode-szdp/",
	"content": "#### 方法一：回溯\n\n首先计算所有火柴的总长度 $\\textit{totalLen}$，如果 $\\textit{totalLen}$ 不是 $4$ 的倍数，那么不可能拼成正方形，返回 $\\text{false}$。当 $\\textit{totalLen}$ 是 $4$ 的倍数时，每条边的边长为 $\\textit{len} = \\dfrac{\\textit{totalLen}}{4}$，用 $\\textit{edges}$ 来记录 $4$ 条边已经放入的火柴总长度。对于第 $\\textit{index}$ 火柴，尝试把它放入其中一条边内且满足放入后该边的火柴总长度不超过 $\\textit{len}$，然后继续枚举第 $\\textit{index} + 1$ 根火柴的放置情况，如果所有火柴都已经被放置，那么说明可以拼成正方形。\n\n为了减少搜索量，需要对火柴长度从大到小进行排序。\n\n```Python [sol1-Python3]\nclass Solution:\n    def makesquare(self, matchsticks: List[int]) -> bool:\n        totalLen = sum(matchsticks)\n        if totalLen % 4:\n            return False\n        matchsticks.sort(reverse=True)\n\n        edges = [0] * 4\n        def dfs(idx: int) -> bool:\n            if idx == len(matchsticks):\n                return True\n            for i in range(4):\n                edges[i] += matchsticks[idx]\n                if edges[i] <= totalLen // 4 and dfs(idx + 1):\n                    return True\n                edges[i] -= matchsticks[idx]\n            return False\n        return dfs(0)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool dfs(int index, vector<int> &matchsticks, vector<int> &edges, int len) {\n        if (index == matchsticks.size()) {\n            return true;\n        }\n        for (int i = 0; i < edges.size(); i++) {\n            edges[i] += matchsticks[index];\n            if (edges[i] <= len && dfs(index + 1, matchsticks, edges, len)) {\n                return true;\n            }\n            edges[i] -= matchsticks[index];\n        }\n        return false;\n    }\n\n    bool makesquare(vector<int> &matchsticks) {\n        int totalLen = accumulate(matchsticks.begin(), matchsticks.end(), 0);\n        if (totalLen % 4 != 0) {\n            return false;\n        }\n        sort(matchsticks.begin(), matchsticks.end(), greater<int>()); // 减少搜索量\n\n        vector<int> edges(4);\n        return dfs(0, matchsticks, edges, totalLen / 4);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean makesquare(int[] matchsticks) {\n        int totalLen = Arrays.stream(matchsticks).sum();\n        if (totalLen % 4 != 0) {\n            return false;\n        }\n        Arrays.sort(matchsticks);\n        for (int i = 0, j = matchsticks.length - 1; i < j; i++, j--) {\n            int temp = matchsticks[i];\n            matchsticks[i] = matchsticks[j];\n            matchsticks[j] = temp;\n        }\n\n        int[] edges = new int[4];\n        return dfs(0, matchsticks, edges, totalLen / 4);\n    }\n\n    public boolean dfs(int index, int[] matchsticks, int[] edges, int len) {\n        if (index == matchsticks.length) {\n            return true;\n        }\n        for (int i = 0; i < edges.length; i++) {\n            edges[i] += matchsticks[index];\n            if (edges[i] <= len && dfs(index + 1, matchsticks, edges, len)) {\n                return true;\n            }\n            edges[i] -= matchsticks[index];\n        }\n        return false;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool Makesquare(int[] matchsticks) {\n        int totalLen = matchsticks.Sum();\n        if (totalLen % 4 != 0) {\n            return false;\n        }\n        Array.Sort(matchsticks);\n        for (int i = 0, j = matchsticks.Length - 1; i < j; i++, j--) {\n            int temp = matchsticks[i];\n            matchsticks[i] = matchsticks[j];\n            matchsticks[j] = temp;\n        }\n\n        int[] edges = new int[4];\n        return DFS(0, matchsticks, edges, totalLen / 4);\n    }\n\n    public bool DFS(int index, int[] matchsticks, int[] edges, int len) {\n        if (index == matchsticks.Length) {\n            return true;\n        }\n        for (int i = 0; i < edges.Length; i++) {\n            edges[i] += matchsticks[index];\n            if (edges[i] <= len && DFS(index + 1, matchsticks, edges, len)) {\n                return true;\n            }\n            edges[i] -= matchsticks[index];\n        }\n        return false;\n    }\n}\n```\n\n```C [sol1-C]\nstatic bool dfs(int index, int *matchsticks, int matchsticksSize, int *edges, int len) {\n    if (index == matchsticksSize) {\n        return true;\n    }\n    for (int i = 0; i < 4; i++) {\n        edges[i] += matchsticks[index];\n        if (edges[i] <= len && dfs(index + 1, matchsticks, matchsticksSize, edges, len)) {\n            return true;\n        }\n        edges[i] -= matchsticks[index];\n    }\n    return false;\n}\n\nstatic int cmp(const void *pa, const void *pb) {\n    return *(int *)pb - *(int *)pa;\n}\n\nbool makesquare(int* matchsticks, int matchsticksSize) {\n    int totalLen = 0;\n    for (int i = 0; i < matchsticksSize; i++) {\n        totalLen += matchsticks[i];\n    }\n    if (totalLen % 4 != 0) {\n        return false;\n    }\n    qsort(matchsticks, matchsticksSize, sizeof(int), cmp);\n    int edges[4] = {0, 0, 0, 0};\n    return dfs(0, matchsticks, matchsticksSize, edges, totalLen / 4);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar makesquare = function(matchsticks) {\n    const totalLen = _.sum(matchsticks);\n    if (totalLen % 4 !== 0) {\n        return false;\n    }\n    matchsticks.sort((a, b) => a - b);\n    for (let i = 0, j = matchsticks.length - 1; i < j; i++, j--) {\n        const temp = matchsticks[i];\n        matchsticks[i] = matchsticks[j];\n        matchsticks[j] = temp;\n    }\n\n    const edges = new Array(4).fill(0);\n    return dfs(0, matchsticks, edges, Math.floor(totalLen / 4));\n}\n\nconst dfs = (index, matchsticks, edges, len) => {\n    if (index === matchsticks.length) {\n        return true;\n    }\n    for (let i = 0; i < edges.length; i++) {\n        edges[i] += matchsticks[index];\n        if (edges[i] <= len && dfs(index + 1, matchsticks, edges, len)) {\n            return true;\n        }\n        edges[i] -= matchsticks[index];\n    }\n    return false;\n};\n```\n\n```go [sol1-Golang]\nfunc makesquare(matchsticks []int) bool {\n    totalLen := 0\n    for _, l := range matchsticks {\n        totalLen += l\n    }\n    if totalLen%4 != 0 {\n        return false\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(matchsticks))) // 减少搜索量\n\n    edges := [4]int{}\n    var dfs func(int) bool\n    dfs = func(idx int) bool {\n        if idx == len(matchsticks) {\n            return true\n        }\n        for i := range edges {\n            edges[i] += matchsticks[idx]\n            if edges[i] <= totalLen/4 && dfs(idx+1) {\n                return true\n            }\n            edges[i] -= matchsticks[idx]\n        }\n        return false\n    }\n    return dfs(0)\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(4^n)$，其中 $n$ 是火柴的数目。每根火柴都可以选择放在 $4$ 条边上，因此时间复杂度为 $O(4^n)$。\n\n+ 空间复杂度：$O(n)$。递归栈需要占用 $O(n)$ 的空间。\n\n#### 方法二：状态压缩 + 动态规划\n\n计算所有火柴的总长度 $\\textit{totalLen}$，如果 $\\textit{totalLen}$ 不是 $4$ 的倍数，那么不可能拼成正方形，返回 $\\text{false}$。当 $\\textit{totalLen}$ 是 $4$ 的倍数时，每条边的边长为 $\\textit{len} = \\dfrac{\\textit{totalLen}}{4}$。我们给正方形的四条边进行编号，分别为 $1$，$2$，$3$ 和 $4$。按照编号顺序依次将火柴放入正方形的四条边，只有前一条边被放满后，才能将火柴放入后一条边。\n\n用状态 $s$ 记录哪些火柴已经被放入（$s$ 的第 $k$ 位为 $1$ 表示第 $k$ 根火柴已经被放入），$\\textit{dp}[s]$ 表示正方形未放满的边的当前长度，计算如下：\n\n+ 当 $s = 0$ 时，没有火柴被放入，因此 $\\textit{dp}[0] = 0$。\n\n+ 当 $s \\ne 0$ 时，如果去掉它的第 $k$ 根火柴得到的状态 $s_1$ 满足 $\\textit{dp}[s_1] \\ge 0$ 且 $\\textit{dp}[s_1] + \\textit{matchsticks}[k] \\le \\textit{len}$，那么 $\\textit{dp}[s] = (\\textit{dp}[s_1] + \\textit{matchsticks}[k]) \\bmod \\textit{len}$（因为放满前一条边后，我们开始放后一条边，此时未放满的边的长度为 $0$，所以需要对 $\\textit{len}$ 取余）；否则 $\\textit{dp}[s] = -1$，表示状态 $s$ 对应的火柴集合不可能按上述规则放入正方形的边。\n\n令 $s_\\textit{all}$ 表示所有火柴都已经被放入时的状态，如果 $\\textit{dp}[s_\\textit{all}] = 0$ 成立，那么可以拼成正方形，否则不可以拼成正方形。\n\n```Python [sol2-Python3]\nclass Solution:\n    def makesquare(self, matchsticks: List[int]) -> bool:\n        totalLen = sum(matchsticks)\n        if totalLen % 4:\n            return False\n        tLen = totalLen // 4\n\n        dp = [-1] * (1 << len(matchsticks))\n        dp[0] = 0\n        for s in range(1, len(dp)):\n            for k, v in enumerate(matchsticks):\n                if s & (1 << k) == 0:\n                    continue\n                s1 = s & ~(1 << k)\n                if dp[s1] >= 0 and dp[s1] + v <= tLen:\n                    dp[s] = (dp[s1] + v) % tLen\n                    break\n        return dp[-1] == 0\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool makesquare(vector<int>& matchsticks) {\n        int totalLen = accumulate(matchsticks.begin(), matchsticks.end(), 0);\n        if (totalLen % 4 != 0) {\n            return false;\n        }\n        int len = totalLen / 4, n = matchsticks.size();\n        vector<int> dp(1 << n, -1);\n        dp[0] = 0;\n        for (int s = 1; s < (1 << n); s++) {\n            for (int k = 0; k < n; k++) {\n                if ((s & (1 << k)) == 0) {\n                    continue;\n                }\n                int s1 = s & ~(1 << k);\n                if (dp[s1] >= 0 && dp[s1] + matchsticks[k] <= len) {\n                    dp[s] = (dp[s1] + matchsticks[k]) % len;\n                    break;\n                }\n            }\n        }\n        return dp[(1 << n) - 1] == 0;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean makesquare(int[] matchsticks) {\n        int totalLen = Arrays.stream(matchsticks).sum();\n        if (totalLen % 4 != 0) {\n            return false;\n        }\n        int len = totalLen / 4, n = matchsticks.length;\n        int[] dp = new int[1 << n];\n        Arrays.fill(dp, -1);\n        dp[0] = 0;\n        for (int s = 1; s < (1 << n); s++) {\n            for (int k = 0; k < n; k++) {\n                if ((s & (1 << k)) == 0) {\n                    continue;\n                }\n                int s1 = s & ~(1 << k);\n                if (dp[s1] >= 0 && dp[s1] + matchsticks[k] <= len) {\n                    dp[s] = (dp[s1] + matchsticks[k]) % len;\n                    break;\n                }\n            }\n        }\n        return dp[(1 << n) - 1] == 0;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public bool Makesquare(int[] matchsticks) {\n        int totalLen = matchsticks.Sum();\n        if (totalLen % 4 != 0) {\n            return false;\n        }\n        int len = totalLen / 4, n = matchsticks.Length;\n        int[] dp = new int[1 << n];\n        Array.Fill(dp, -1);\n        dp[0] = 0;\n        for (int s = 1; s < (1 << n); s++) {\n            for (int k = 0; k < n; k++) {\n                if ((s & (1 << k)) == 0) {\n                    continue;\n                }\n                int s1 = s & ~(1 << k);\n                if (dp[s1] >= 0 && dp[s1] + matchsticks[k] <= len) {\n                    dp[s] = (dp[s1] + matchsticks[k]) % len;\n                    break;\n                }\n            }\n        }\n        return dp[(1 << n) - 1] == 0;\n    }\n}\n```\n\n```C [sol2-C]\nbool makesquare(int* matchsticks, int matchsticksSize) {\n    int totalLen = 0;\n    for (int i = 0; i < matchsticksSize; i++) {\n        totalLen += matchsticks[i];\n    }\n    if (totalLen % 4 != 0) {\n        return false;\n    }\n    int len = totalLen / 4, n = matchsticksSize;\n    int *dp = (int *)malloc(sizeof(int) * (1 << n));\n    memset(dp, -1, sizeof(int) * (1 << n));\n    dp[0] = 0;\n    for (int s = 1; s < (1 << n); s++) {\n        for (int k = 0; k < n; k++) {\n            if ((s & (1 << k)) == 0) {\n                continue;\n            }\n            int s1 = s & ~(1 << k);\n            if (dp[s1] >= 0 && dp[s1] + matchsticks[k] <= len) {\n                dp[s] = (dp[s1] + matchsticks[k]) % len;\n                break;\n            }\n        }\n    }\n    bool res = dp[(1 << n) - 1] == 0;\n    free(dp);\n    return res;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar makesquare = function(matchsticks) {\n    const totalLen = _.sum(matchsticks);\n    if (totalLen % 4 !== 0) {\n        return false;\n    }\n    const len = Math.floor(totalLen / 4), n = matchsticks.length;\n    const dp = new Array(1 << n).fill(-1);\n    dp[0] = 0;\n    for (let s = 1; s < (1 << n); s++) {\n        for (let k = 0; k < n; k++) {\n            if ((s & (1 << k)) === 0) {\n                continue;\n            }\n            const s1 = s & ~(1 << k);\n            if (dp[s1] >= 0 && dp[s1] + matchsticks[k] <= len) {\n                dp[s] = (dp[s1] + matchsticks[k]) % len;\n                break;\n            }\n        }\n    }\n    return dp[(1 << n) - 1] === 0;\n}\n```\n\n```go [sol2-Golang]\nfunc makesquare(matchsticks []int) bool {\n    totalLen := 0\n    for _, l := range matchsticks {\n        totalLen += l\n    }\n    if totalLen%4 != 0 {\n        return false\n    }\n\n    tLen := totalLen / 4\n    dp := make([]int, 1<<len(matchsticks))\n    for i := 1; i < len(dp); i++ {\n        dp[i] = -1\n    }\n    for s := 1; s < len(dp); s++ {\n        for k, v := range matchsticks {\n            if s>>k&1 == 0 {\n                continue\n            }\n            s1 := s &^ (1 << k)\n            if dp[s1] >= 0 && dp[s1]+v <= tLen {\n                dp[s] = (dp[s1] + v) % tLen\n                break\n            }\n        }\n    }\n    return dp[len(dp)-1] == 0\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n \\times 2^n)$，其中 $n$ 是火柴的数目。总共有 $2^n$ 个状态，计算每个状态都需要 $O(n)$。\n\n+ 空间复杂度：$O(2^n)$。保存数组 $\\textit{dp}$ 需要 $O(2^n)$ 的空间。"
}