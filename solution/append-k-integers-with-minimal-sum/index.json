{
	"titleSlug": "append-k-integers-with-minimal-sum",
	"slug": "xiang-shu-zu-zhong-zhui-jia-k-ge-zheng-s-9vdv",
	"url": "https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/solution/xiang-shu-zu-zhong-zhui-jia-k-ge-zheng-s-9vdv/",
	"content": "#### 方法一：排序\n\n**思路与算法**\n\n首先可以明确的是：最优的方法一定是从 $1$ 开始，依次往数组 $\\textit{nums}$ 中添加未出现过的正整数，直到添加了 $k$ 个正整数为止。\n\n因此，我们首先对数组 $\\textit{nums}$ 进行升序排序，随后在数组的最前面添加元素 $0$，最后面添加元素 $\\infty$。这样一来，我们从 $\\textit{nums}$ 的第一个元素（首元素为第 $0$ 个元素）开始遍历。当遍历到 $\\textit{nums}[i]$ 时，如果 $\\textit{nums}[i-1] + 1 < \\textit{nums}[i]$，那么我们就可以在 $[\\textit{nums}[i-1] + 1, \\textit{nums}[i] - 1]$ 的范围内添加正整数，总计 $\\textit{nums}[i] - \\textit{nums}[i-1] - 1$ 个。如果这个值小于 $k$，那么我们需要添加该范围内的全部正整数，并将 $k$ 减去这个值；否则我们只需要添加从 $\\textit{nums}[i] + 1$ 开始的最小 $k$ 个正整数即可。此时，添加到数组中的所有正整数之和，即为 $1 + 2 + \\cdots + (\\textit{nums}[i-1] + k)$ 减去所有已完成遍历的元素之和。\n\n**细节**\n\n本题中有两个细节需要注意：\n\n- 由于数组 $\\textit{nums}$ 中的元素和 $k$ 均不超过 $10^9$，因此添加的正整数一定不会超过 $2 \\times 10^9$，即我们可以用 $2 \\times 10^9 + 1$ 代替 $\\infty$。\n\n- 由于数组 $\\textit{nums}$ 中会出现重复的元素，因此在维护「所有已完成遍历的元素之和」时，不能计入重复的元素。即当 $\\textit{nums}[i-1] = \\textit{nums}[i]$ 时不能计入 $\\textit{nums}[i]$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    long long minimalKSum(vector<int>& nums, int k) {\n        nums.push_back(0);\n        nums.push_back(int(2e9) + 1);\n        sort(nums.begin(), nums.end());\n\n        long long presum = 0, ans = 0;\n        for (int i = 1; i < nums.size(); ++i) {\n            int offer = nums[i] - nums[i - 1] - 1;\n            if (offer > 0) {\n                if (offer < k) {\n                    k -= offer;\n                }\n                else {\n                    ans = static_cast<long long>(nums[i - 1] + k + 1) * (nums[i - 1] + k) / 2 - presum;\n                    break;\n                }\n            }\n            if (nums[i] != nums[i - 1]) {\n                presum += nums[i];\n            }\n        }\n\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimalKSum(self, nums: List[int], k: int) -> int:\n        nums.extend([0, int(2e9) + 1])\n        nums.sort()\n\n        presum = 0\n        ans = 0\n        for i in range(1, len(nums)):\n            offer = nums[i] - nums[i - 1] - 1\n            if offer > 0:\n                if offer < k:\n                    k -= offer\n                else:\n                    ans = (nums[i - 1] + k + 1) * (nums[i - 1] + k) // 2 - presum\n                    break\n            if nums[i] != nums[i - 1]:\n                presum += nums[i]\n        \n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度，即为排序需要的时间。\n\n- 空间复杂度：$O(\\log n)$，即为排序需要使用的栈空间。"
}