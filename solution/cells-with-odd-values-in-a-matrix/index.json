{
	"titleSlug": "cells-with-odd-values-in-a-matrix",
	"slug": "qi-shu-zhi-dan-yuan-ge-de-shu-mu-by-leet-oa4o",
	"url": "https://leetcode-cn.com/problems/cells-with-odd-values-in-a-matrix/solution/qi-shu-zhi-dan-yuan-ge-de-shu-mu-by-leet-oa4o/",
	"content": "#### 方法一：直接模拟\n\n直接使用使用一个 $n \\times m$ 的矩阵来存放操作的结果，对于 $\\textit{indices}$ 中的每一对 $[r_i, c_i]$，将矩阵第 $r_i$ 行的所有数增加 $1$，第 $c_i$ 列的所有数增加 $1$。在所有操作模拟完毕后，我们遍历矩阵，得到奇数的数目。\n\n```Python [sol1-Python3]\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        matrix = [[0] * n for _ in range(m)]\n        for x, y in indices:\n            for j in range(n):\n                matrix[x][j] += 1\n            for row in matrix:\n                row[y] += 1\n        return sum(x % 2 for row in matrix for x in row)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\n        int res = 0;\n        vector<vector<int>> matrix(m, vector<int>(n));\n        for (auto &index : indices) {\n            for (int i = 0; i < n; i++) {\n                matrix[index[0]][i]++;\n            }\n            for (int i = 0; i < m; i++) {\n                matrix[i][index[1]]++;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] & 1) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int oddCells(int m, int n, int[][] indices) {\n        int res = 0;\n        int[][] matrix = new int[m][n];\n        for (int[] index : indices) {\n            for (int i = 0; i < n; i++) {\n                matrix[index[0]][i]++;\n            }\n            for (int i = 0; i < m; i++) {\n                matrix[i][index[1]]++;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((matrix[i][j] & 1) != 0) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int OddCells(int m, int n, int[][] indices) {\n        int res = 0;\n        int[,] matrix = new int[m, n];\n        foreach (int[] index in indices) {\n            for (int i = 0; i < n; i++) {\n                matrix[index[0], i]++;\n            }\n            for (int i = 0; i < m; i++) {\n                matrix[i, index[1]]++;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((matrix[i, j] & 1) != 0) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol1-C]\nint oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize) {\n    int res = 0;\n    int **matrix = (int **)malloc(sizeof(int *) * m);\n    for (int i = 0; i < m; i++) {\n        matrix[i] = (int *)malloc(sizeof(int) * n);\n        memset(matrix[i], 0, sizeof(int) * n);\n    }\n    for (int i = 0; i < indicesSize; i++) {\n        for (int j = 0; j < n; j++) {\n            matrix[indices[i][0]][j]++;\n        }\n        for (int j = 0; j < m; j++) {\n            matrix[j][indices[i][1]]++;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] & 1) {\n                res++;\n            }\n        }\n        free(matrix[i]);\n    }\n    free(matrix);\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar oddCells = function(m, n, indices) {\n    let res = 0;\n    const matrix = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    for (const index of indices) {\n        for (let i = 0; i < n; i++) {\n            matrix[index[0]][i]++;\n        }\n        for (let i = 0; i < m; i++) {\n            matrix[i][index[1]]++;\n        }\n    }\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if ((matrix[i][j] & 1) !== 0) {\n                res++;\n            }\n        }\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc oddCells(m, n int, indices [][]int) (ans int) {\n    matrix := make([][]int, m)\n    for i := range matrix {\n        matrix[i] = make([]int, n)\n    }\n    for _, p := range indices {\n        for j := range matrix[p[0]] {\n            matrix[p[0]][j]++\n        }\n        for _, row := range matrix {\n            row[p[1]]++\n        }\n    }\n    for _, row := range matrix {\n        for _, v := range row {\n            ans += v % 2\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(q \\times (m + n) + m \\times n)$, 其中 $q$ 表示数组 $\\textit{indices}$ 的长度，$m, n$ 为矩阵的行数与列数。遍历数组时，每次都需要更新矩阵中一行加一列，需要的时间为 $O(q \\times (m + n))$，最后还需要遍历矩阵，需要的时间为 $O(m \\times n)$，总的时间复杂度为 $O(q \\times (m + n) + m \\times n)$。\n\n- 空间复杂度：$O(m \\times n)$，其中 $m, n$ 为矩阵的行数与列数。需要存储矩阵的所有元素。\n\n#### 方法二：模拟空间优化\n\n由于每次操作只会将一行和一列的数增加 $1$，因此我们可以使用一个行数组 $\\textit{rows}$ 和列数组 $\\textit{cols}$ 分别记录每一行和每一列被增加的次数。对于 $\\textit{indices}$ 中的每一对 $[r_i, c_i]$，我们将 $\\textit{rows}[r_i]$ 和 $\\textit{cols}[c_i]$ 的值分别增加 $1$。\n在所有操作完成后，我们可以计算出位置 $(x, y)$ 位置的计数即为 $\\textit{rows}[x] + \\textit{cols}[y]$。遍历矩阵，即可得到所有奇数的数目。\n\n```Python [sol2-Python3]\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        rows = [0] * m\n        cols = [0] * n\n        for x, y in indices:\n            rows[x] += 1\n            cols[y] += 1\n        return sum((row + col) % 2 for row in rows for col in cols)\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\n        vector<int> rows(m), cols(n);\n        for (auto & index : indices) {\n            rows[index[0]]++;\n            cols[index[1]]++;\n        }\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((rows[i] + cols[j]) & 1) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int oddCells(int m, int n, int[][] indices) {\n        int[] rows = new int[m];\n        int[] cols = new int[n];\n        for (int[] index : indices) {\n            rows[index[0]]++;\n            cols[index[1]]++;\n        }\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (((rows[i] + cols[j]) & 1) != 0) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int OddCells(int m, int n, int[][] indices) {\n        int[] rows = new int[m];\n        int[] cols = new int[n];\n        foreach (int[] index in indices) {\n            rows[index[0]]++;\n            cols[index[1]]++;\n        }\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (((rows[i] + cols[j]) & 1) != 0) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol2-C]\nint oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize) {\n    int res = 0;\n    int *rows = (int *)malloc(sizeof(int) * m);\n    int *cols = (int *)malloc(sizeof(int) * n);\n    memset(rows, 0, sizeof(int) * m);\n    memset(cols, 0, sizeof(int) * n);\n    for (int i = 0; i < indicesSize; i++) {\n        rows[indices[i][0]]++;\n        cols[indices[i][1]]++;\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((rows[i] + cols[j]) & 1) {\n                res++;\n            }\n        }\n    }\n    free(rows);\n    free(cols);\n    return res;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar oddCells = function(m, n, indices) {\n    const rows = new Array(m).fill(0);\n    const cols = new Array(n).fill(0);\n    for (const index of indices) {\n        rows[index[0]]++;\n        cols[index[1]]++;\n    }\n    let res = 0;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (((rows[i] + cols[j]) & 1) !== 0) {\n                res++;\n            }\n        }\n    }\n    return res;\n};\n```\n\n```go [sol2-Golang]\nfunc oddCells(m, n int, indices [][]int) (ans int) {\n    rows := make([]int, m)\n    cols := make([]int, n)\n    for _, p := range indices {\n        rows[p[0]]++\n        cols[p[1]]++\n    }\n    for _, row := range rows {\n        for _, col := range cols {\n            ans += (row + col) % 2\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(q + m \\times n)$, 其中 $q$ 表示数组 $\\textit{indices}$ 的长度，$m, n$ 为矩阵的行数与列数。遍历数组时需要的时间为 $O(q)$，最后还需要遍历矩阵，需要的时间为 $O(m \\times n)$，因此总的时间复杂度为 $O(q + m \\times n)$。\n\n- 空间复杂度：$O(m + n)$，其中 $m, n$ 为矩阵的行数与列数。需要存储矩阵的行数统计与列数统计。\n\n#### 方法三：计数优化\n\n继续对方法二进行优化，矩阵中位于 $(x, y)$ 位置的数为奇数，当且仅当 $\\textit{rows}[x]$ 和 $\\textit{cols}[y]$ 中恰好有一个为奇数，一个为偶数。设 $\\textit{rows}$ 有 $\\textit{odd}_x$ 个奇数，$\\textit{cols}$ 有 $\\textit{odd}_y$ 个奇数，因此对于 $\\textit{rows}[x]$ 为偶数，那么在第 $x$ 行有 $\\textit{odd}_y$ 个位置的数为奇数；对于 $\\textit{rows}[x]$ 为奇数，那么在第 $x$ 行有 $n - \\textit{odd}_y$ 个位置的数为偶数。综上我们可以得到奇数的数目为 $\\textit{odd}_x \\times (n - \\textit{odd}_y) + (m - \\textit{odd}_x) \\times \\textit{odd}_y$。\n\n```Python [sol3-Python3]\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        rows = [0] * m\n        cols = [0] * n\n        for x, y in indices:\n            rows[x] += 1\n            cols[y] += 1\n        oddx = sum(row % 2 for row in rows)\n        oddy = sum(col % 2 for col in cols)\n        return oddx * (n - oddy) + (m - oddx) * oddy\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\n        vector<int> rows(m), cols(n);\n        for (auto & index : indices) {\n            rows[index[0]]++;\n            cols[index[1]]++;\n        }\n        int oddx = 0, oddy = 0;\n        for (int i = 0; i < m; i++) {\n            if (rows[i] & 1) {\n                oddx++;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (cols[i] & 1) {\n                oddy++;\n            }\n        }\n        return oddx * (n - oddy) + (m - oddx) * oddy;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int oddCells(int m, int n, int[][] indices) {\n        int[] rows = new int[m];\n        int[] cols = new int[n];\n        for (int[] index : indices) {\n            rows[index[0]]++;\n            cols[index[1]]++;\n        }\n        int oddx = 0, oddy = 0;\n        for (int i = 0; i < m; i++) {\n            if ((rows[i] & 1) != 0) {\n                oddx++;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if ((cols[i] & 1) != 0) {\n                oddy++;\n            }\n        }\n        return oddx * (n - oddy) + (m - oddx) * oddy;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int OddCells(int m, int n, int[][] indices) {\n        int[] rows = new int[m];\n        int[] cols = new int[n];\n        foreach (int[] index in indices) {\n            rows[index[0]]++;\n            cols[index[1]]++;\n        }\n        int oddx = 0, oddy = 0;\n        for (int i = 0; i < m; i++) {\n            if ((rows[i] & 1) != 0) {\n                oddx++;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if ((cols[i] & 1) != 0) {\n                oddy++;\n            }\n        }\n        return oddx * (n - oddy) + (m - oddx) * oddy;\n    }\n}\n```\n\n```C [sol3-C]\nint oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize) {\n    int res = 0;\n    int *rows = (int *)malloc(sizeof(int) * m);\n    int *cols = (int *)malloc(sizeof(int) * n);\n    memset(rows, 0, sizeof(int) * m);\n    memset(cols, 0, sizeof(int) * n);\n    for (int i = 0; i < indicesSize; i++) {\n        rows[indices[i][0]]++;\n        cols[indices[i][1]]++;\n    }\n    int oddx = 0, oddy = 0;\n    for (int i = 0; i < m; i++) {\n        if (rows[i] & 1) {\n            oddx++;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (cols[i] & 1) {\n            oddy++;\n        }\n    }\n    return oddx * (n - oddy) + (m - oddx) * oddy;\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar oddCells = function(m, n, indices) {\n    const rows = new Array(m).fill(0);\n    const cols = new Array(n).fill(0);\n    for (const index of indices) {\n        rows[index[0]]++;\n        cols[index[1]]++;\n    }\n    let oddx = 0, oddy = 0;\n    for (let i = 0; i < m; i++) {\n        if ((rows[i] & 1) !== 0) {\n            oddx++;\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        if ((cols[i] & 1) !== 0) {\n            oddy++;\n        }\n    }\n    return oddx * (n - oddy) + (m - oddx) * oddy;\n};\n```\n\n```go [sol3-Golang]\nfunc oddCells(m, n int, indices [][]int) int {\n    rows := make([]int, m)\n    cols := make([]int, n)\n    for _, p := range indices {\n        rows[p[0]]++\n        cols[p[1]]++\n    }\n    oddx := 0\n    for _, row := range rows {\n        oddx += row % 2\n    }\n    oddy := 0\n    for _, col := range cols {\n        oddy += col % 2\n    }\n    return oddx*(n-oddy) + (m-oddx)*oddy\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(q + m + n)$, 其中 $q$ 表示数组 $\\textit{indices}$ 的长度，$m, n$ 为矩阵的行数与列数。\n\n- 空间复杂度：$O(m + n)$，其中 $m, n$ 为矩阵的行数与列数。需要存储矩阵的行数统计与列数统计。"
}