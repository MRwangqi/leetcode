{
	"titleSlug": "all-oone-data-structure",
	"slug": "quan-o1-de-shu-ju-jie-gou-by-leetcode-so-7gdv",
	"url": "https://leetcode-cn.com/problems/all-oone-data-structure/solution/quan-o1-de-shu-ju-jie-gou-by-leetcode-so-7gdv/",
	"content": "#### 方法一：双向链表 + 哈希表\n\n本题要求每次操作的时间复杂度均为 $O(1)$（字符串长度视作常数）。我们可以结合双向链表和哈希表来实现，具体如下：\n\n链表中的每个节点存储一个字符串集合 $\\textit{keys}$，和一个正整数 $\\textit{count}$，表示 $\\textit{keys}$ 中的字符串均出现 $\\textit{count}$ 次。链表从头到尾的每个节点的 $\\textit{count}$ 值单调递增（但不一定连续）。此外，每个节点还需存储指向上一个节点的指针 $\\textit{prev}$ 和指向下一个节点的指针 $\\textit{next}$。\n\n另外还要用一个哈希表 $\\textit{nodes}$ 维护每个字符串当前所处的链表节点。\n\n- 对于 $\\text{inc}$ 操作：\n  - 若 $\\textit{key}$ 不在链表中：若链表为空或头节点的 $\\textit{count}>1$，则先插入一个 $\\textit{count}=1$ 的新节点至链表头部，然后将 $\\textit{key}$ 插入到头节点的 $\\textit{keys}$ 中。\n  - 若 $\\textit{key}$ 在链表中：设 $\\textit{key}$ 所在节点为 $\\textit{cur}$，若 $\\textit{cur}.\\textit{next}$ 为空或 $\\textit{cur}.\\textit{next}.\\textit{count}>\\textit{cur}.\\textit{count}+1$，则先插入一个 $\\textit{count}=\\textit{cur}.\\textit{count}+1$ 的新节点至 $\\textit{cur}$ 之后，然后将 $\\textit{key}$ 插入到 $\\textit{cur}.\\textit{next}.\\textit{keys}$ 中。最后，将 $\\textit{key}$ 从 $\\textit{cur}.\\textit{keys}$ 中移除，若移除后 $\\textit{cur}.\\textit{keys}$ 为空，则将 $\\textit{cur}$ 从链表中移除。\n  - 更新 $\\textit{nodes}$ 中 $\\textit{key}$ 所处的节点。\n\n- 对于 $\\text{dec}$ 操作，测试用例保证 $\\textit{key}$ 在链表中。\n  - 若 $\\textit{key}$ 仅出现一次：将其从 $\\textit{nodes}$ 中移除。\n  - 若 $\\textit{key}$ 出现不止一次：设 $\\textit{key}$ 所在节点为 $\\textit{cur}$，若 $\\textit{cur}.\\textit{prev}$ 为空或 $\\textit{cur}.\\textit{prev}.\\textit{count}<\\textit{cur}.\\textit{count}-1$，则先插入一个 $\\textit{count}=\\textit{cur}.\\textit{count}-1$ 的新节点至 $\\textit{cur}$ 之前，然后将 $\\textit{key}$ 插入到 $\\textit{cur}.\\textit{prev}.\\textit{keys}$ 中。更新 $\\textit{nodes}$ 中 $\\textit{key}$ 所处的节点。\n  - 最后，将 $\\textit{key}$ 从 $\\textit{cur}.\\textit{keys}$ 中移除，若移除后 $\\textit{cur}.\\textit{keys}$ 为空，则将 $\\textit{cur}$ 从链表中移除。\n\n- 对于 $\\text{getMaxKey}$ 操作，在链表不为空时，返回链表尾节点的 $\\textit{keys}$ 中的任一元素，否则返回空字符串。\n\n- 对于 $\\text{getMinKey}$ 操作，在链表不为空时，返回链表头节点的 $\\textit{keys}$ 中的任一元素，否则返回空字符串。\n\n```Python [sol1-Python3]\nclass Node:\n    def __init__(self, key=\"\", count=0):\n        self.prev = None\n        self.next = None\n        self.keys = {key}\n        self.count = count\n\n    def insert(self, node: 'Node') -> 'Node':  # 在 self 后插入 node\n        node.prev = self\n        node.next = self.next\n        node.prev.next = node\n        node.next.prev = node\n        return node\n\n    def remove(self):  # 从链表中移除 self\n        self.prev.next = self.next\n        self.next.prev = self.prev\n\nclass AllOne:\n    def __init__(self):\n        self.root = Node()\n        self.root.prev = self.root\n        self.root.next = self.root  # 初始化链表哨兵，下面判断节点的 next 若为 self.root，则表示 next 为空（prev 同理）\n        self.nodes = {}\n\n    def inc(self, key: str) -> None:\n        if key not in self.nodes:  # key 不在链表中\n            if self.root.next is self.root or self.root.next.count > 1:\n                self.nodes[key] = self.root.insert(Node(key, 1))\n            else:\n                self.root.next.keys.add(key)\n                self.nodes[key] = self.root.next\n        else:\n            cur = self.nodes[key]\n            nxt = cur.next\n            if nxt is self.root or nxt.count > cur.count + 1:\n                self.nodes[key] = cur.insert(Node(key, cur.count + 1))\n            else:\n                nxt.keys.add(key)\n                self.nodes[key] = nxt\n            cur.keys.remove(key)\n            if len(cur.keys) == 0:\n                cur.remove()\n\n    def dec(self, key: str) -> None:\n        cur = self.nodes[key]\n        if cur.count == 1:  # key 仅出现一次，将其移出 nodes\n            del self.nodes[key]\n        else:\n            pre = cur.prev\n            if pre is self.root or pre.count < cur.count - 1:\n                self.nodes[key] = cur.prev.insert(Node(key, cur.count - 1))\n            else:\n                pre.keys.add(key)\n                self.nodes[key] = pre\n        cur.keys.remove(key)\n        if len(cur.keys) == 0:\n            cur.remove()\n\n    def getMaxKey(self) -> str:\n        return next(iter(self.root.prev.keys)) if self.root.prev is not self.root else \"\"\n\n    def getMinKey(self) -> str:\n        return next(iter(self.root.next.keys)) if self.root.next is not self.root else \"\"\n```\n\n```C++ [sol1-C++]\nclass AllOne {\n    list<pair<unordered_set<string>, int>> lst;\n    unordered_map<string, list<pair<unordered_set<string>, int>>::iterator> nodes;\n\npublic:\n    AllOne() {}\n\n    void inc(string key) {\n        if (nodes.count(key)) {\n            auto cur = nodes[key], nxt = next(cur);\n            if (nxt == lst.end() || nxt->second > cur->second + 1) {\n                unordered_set<string> s({key});\n                nodes[key] = lst.emplace(nxt, s, cur->second + 1);\n            } else {\n                nxt->first.emplace(key);\n                nodes[key] = nxt;\n            }\n            cur->first.erase(key);\n            if (cur->first.empty()) {\n                lst.erase(cur);\n            }\n        } else { // key 不在链表中\n            if (lst.empty() || lst.begin()->second > 1) {\n                unordered_set<string> s({key});\n                lst.emplace_front(s, 1);\n            } else {\n                lst.begin()->first.emplace(key);\n            }\n            nodes[key] = lst.begin();\n        }\n    }\n\n    void dec(string key) {\n        auto cur = nodes[key];\n        if (cur->second == 1) { // key 仅出现一次，将其移出 nodes\n            nodes.erase(key);\n        } else {\n            auto pre = prev(cur);\n            if (cur == lst.begin() || pre->second < cur->second - 1) {\n                unordered_set<string> s({key});\n                nodes[key] = lst.emplace(cur, s, cur->second - 1);\n            } else {\n                pre->first.emplace(key);\n                nodes[key] = pre;\n            }\n        }\n        cur->first.erase(key);\n        if (cur->first.empty()) {\n            lst.erase(cur);\n        }\n    }\n\n    string getMaxKey() {\n        return lst.empty() ? \"\" : *lst.rbegin()->first.begin();\n    }\n\n    string getMinKey() {\n        return lst.empty() ? \"\" : *lst.begin()->first.begin();\n    }\n};\n```\n\n```Java [sol1-Java]\nclass AllOne {\n    Node root;\n    Map<String, Node> nodes;\n\n    public AllOne() {\n        root = new Node();\n        root.prev = root;\n        root.next = root;  // 初始化链表哨兵，下面判断节点的 next 若为 root，则表示 next 为空（prev 同理）\n        nodes = new HashMap<String, Node>();\n    }\n    \n    public void inc(String key) {\n        if (nodes.containsKey(key)) {\n            Node cur = nodes.get(key);\n            Node nxt = cur.next;\n            if (nxt == root || nxt.count > cur.count + 1) {\n                nodes.put(key, cur.insert(new Node(key, cur.count + 1)));\n            } else {\n                nxt.keys.add(key);\n                nodes.put(key, nxt);\n            }\n            cur.keys.remove(key);\n            if (cur.keys.isEmpty()) {\n                cur.remove();\n            }\n        } else {  // key 不在链表中\n            if (root.next == root || root.next.count > 1) {\n                nodes.put(key, root.insert(new Node(key, 1)));\n            } else {\n                root.next.keys.add(key);\n                nodes.put(key, root.next);\n            }\n        }\n    }\n    \n    public void dec(String key) {\n        Node cur = nodes.get(key);\n        if (cur.count == 1) {  // key 仅出现一次，将其移出 nodes\n            nodes.remove(key);\n        } else {\n            Node pre = cur.prev;\n            if (pre == root || pre.count < cur.count - 1) {\n                nodes.put(key, cur.prev.insert(new Node(key, cur.count - 1)));\n            } else {\n                pre.keys.add(key);\n                nodes.put(key, pre);\n            }\n        }\n        cur.keys.remove(key);\n        if (cur.keys.isEmpty()) {\n            cur.remove();\n        }\n    }\n    \n    public String getMaxKey() {\n        return root.prev != null ? root.prev.keys.iterator().next() : \"\";\n    }\n    \n    public String getMinKey() {\n        return root.next != null ? root.next.keys.iterator().next() : \"\";\n    }\n}\n\nclass Node {\n    Node prev;\n    Node next;\n    Set<String> keys;\n    int count;\n\n    public Node() {\n        this(\"\", 0);\n    }\n\n    public Node(String key, int count) {\n        this.count = count;\n        keys = new HashSet<String>();\n        keys.add(key);\n    }\n\n    public Node insert(Node node) {  // 在 this 后插入 node\n        node.prev = this;\n        node.next = this.next;\n        node.prev.next = node;\n        node.next.prev = node;\n        return node;\n    }\n\n    public void remove() {\n        this.prev.next = this.next;\n        this.next.prev = this.prev;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class AllOne {\n    Node root;\n    Dictionary<string, Node> nodes;\n\n    public AllOne() {\n        root = new Node();\n        root.Prev = root;\n        root.Next = root;  // 初始化链表哨兵，下面判断节点的 Next 若为 root，则表示 Next 为空（Prev 同理）\n        nodes = new Dictionary<string, Node>();\n    }\n    \n    public void Inc(string key) {\n        if (nodes.ContainsKey(key)) {\n            Node cur = nodes[key];\n            Node nxt = cur.Next;\n            if (nxt == root || nxt.Count > cur.Count + 1) {\n                nodes[key] = cur.Insert(new Node(key, cur.Count + 1));\n            } else {\n                nxt.Keys.Add(key);\n                nodes[key] = nxt;\n            }\n            cur.Keys.Remove(key);\n            if (cur.Keys.Count == 0) {\n                cur.Remove();\n            }\n        } else {  // key 不在链表中\n            if (root.Next == root || root.Next.Count > 1) {\n                nodes.Add(key, root.Insert(new Node(key, 1)));\n            } else {\n                root.Next.Keys.Add(key);\n                nodes.Add(key, root.Next);\n            }\n        }\n    }\n    \n    public void Dec(string key) {\n        Node cur = nodes[key];\n        if (cur.Count == 1) {  // key 仅出现一次，将其移出 nodes\n            nodes.Remove(key);\n        } else {\n            Node pre = cur.Prev;\n            if (pre == root || pre.Count < cur.Count - 1) {\n                nodes[key] = cur.Prev.Insert(new Node(key, cur.Count - 1));\n            } else {\n                pre.Keys.Add(key);\n                nodes[key] = pre;\n            }\n        }\n        cur.Keys.Remove(key);\n        if (cur.Keys.Count == 0) {\n            cur.Remove();\n        }\n    }\n    \n    public string GetMaxKey() {\n        if (root.Prev == null) {\n            return \"\";\n        }\n        string maxKey = \"\";\n        foreach (string key in root.Prev.Keys) {\n            maxKey = key;\n            break;\n        }\n        return maxKey;\n    }\n    \n    public string GetMinKey() {\n        if (root.Next == null) {\n            return \"\";\n        }\n        string minKey = \"\";\n        foreach (string key in root.Next.Keys) {\n            minKey = key;\n            break;\n        }\n        return minKey;\n    }\n}\n\nclass Node {\n    public Node Prev { get; set; }\n    public Node Next { get; set; }\n    public ISet<string> Keys { get; set; }\n    public int Count { get; set; }\n\n    public Node() : this(\"\", 0) {\n\n    }\n\n    public Node(string key, int count) {\n        this.Count = count;\n        Keys = new HashSet<string>();\n        Keys.Add(key);\n    }\n\n    public Node Insert(Node node) {  // 在 this 后插入 node\n        node.Prev = this;\n        node.Next = this.Next;\n        node.Prev.Next = node;\n        node.Next.Prev = node;\n        return node;\n    }\n\n    public void Remove() {\n        this.Prev.Next = this.Next;\n        this.Next.Prev = this.Prev;\n    }\n}\n```\n\n```go [sol1-Golang]\ntype node struct {\n    keys  map[string]struct{}\n    count int\n}\n\ntype AllOne struct {\n    *list.List\n    nodes map[string]*list.Element\n}\n\nfunc Constructor() AllOne {\n    return AllOne{list.New(), map[string]*list.Element{}}\n}\n\nfunc (l *AllOne) Inc(key string) {\n    if cur := l.nodes[key]; cur != nil {\n        curNode := cur.Value.(node)\n        if nxt := cur.Next(); nxt == nil || nxt.Value.(node).count > curNode.count+1 {\n            l.nodes[key] = l.InsertAfter(node{map[string]struct{}{key: {}}, curNode.count + 1}, cur)\n        } else {\n            nxt.Value.(node).keys[key] = struct{}{}\n            l.nodes[key] = nxt\n        }\n        delete(curNode.keys, key)\n        if len(curNode.keys) == 0 {\n            l.Remove(cur)\n        }\n    } else { // key 不在链表中\n        if l.Front() == nil || l.Front().Value.(node).count > 1 {\n            l.nodes[key] = l.PushFront(node{map[string]struct{}{key: {}}, 1})\n        } else {\n            l.Front().Value.(node).keys[key] = struct{}{}\n            l.nodes[key] = l.Front()\n        }\n    }\n}\n\nfunc (l *AllOne) Dec(key string) {\n    cur := l.nodes[key]\n    curNode := cur.Value.(node)\n    if curNode.count > 1 {\n        if pre := cur.Prev(); pre == nil || pre.Value.(node).count < curNode.count-1 {\n            l.nodes[key] = l.InsertBefore(node{map[string]struct{}{key: {}}, curNode.count - 1}, cur)\n        } else {\n            pre.Value.(node).keys[key] = struct{}{}\n            l.nodes[key] = pre\n        }\n    } else { // key 仅出现一次，将其移出 nodes\n        delete(l.nodes, key)\n    }\n    delete(curNode.keys, key)\n    if len(curNode.keys) == 0 {\n        l.Remove(cur)\n    }\n}\n\nfunc (l *AllOne) GetMaxKey() string {\n    if b := l.Back(); b != nil {\n        for key := range b.Value.(node).keys {\n            return key\n        }\n    }\n    return \"\"\n}\n\nfunc (l *AllOne) GetMinKey() string {\n    if f := l.Front(); f != nil {\n        for key := range f.Value.(node).keys {\n            return key\n        }\n    }\n    return \"\"\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar AllOne = function() {\n    this.root = new Node();\n    this.root.prev = this.root;\n    this.root.next = this.root; // 初始化链表哨兵，下面判断节点的 next 若为 root，则表示 next 为空（prev 同理）\n    this.nodes = new Map();\n};\n\nAllOne.prototype.inc = function(key) {\n    if (this.nodes.has(key)) {\n        const cur = this.nodes.get(key);\n        const nxt = cur.next;\n        if (nxt === this.root || nxt.count > cur.count + 1) {\n            this.nodes.set(key, cur.insert(new Node(key, cur.count + 1)));\n        } else {\n            nxt.keys.add(key);\n            this.nodes.set(key, nxt);\n        }\n        cur.keys.delete(key);\n        if (cur.keys.size === 0) {\n            cur.remove();\n        }\n    } else {  // key 不在链表中\n        if (this.root.next === this.root || this.root.next.count > 1) {\n            this.nodes.set(key, this.root.insert(new Node(key, 1)));\n        } else {\n            this.root.next.keys.add(key);\n            this.nodes.set(key, this.root.next);\n        }\n    }    \n};\n\nAllOne.prototype.dec = function(key) {\n    const cur = this.nodes.get(key);\n    if (cur.count === 1) {  // key 仅出现一次，将其移出 nodes\n        this.nodes.delete(key);\n    } else {\n        const pre = cur.prev;\n        if (pre === this.root || pre.count < cur.count - 1) {\n            this.nodes.set(key, cur.prev.insert(new Node(key, cur.count - 1)));\n        } else {\n            pre.keys.add(key);\n            this.nodes.set(key, pre);\n        }\n    }\n    cur.keys.delete(key);\n    if (cur.keys.size === 0) {\n        cur.remove();\n    }\n};\n\nAllOne.prototype.getMaxKey = function() {\n    if (!this.root.prev) {\n        return \"\";\n    }\n    let maxKey = \"\";\n    for (const key of this.root.prev.keys) {\n        maxKey = key;\n        break;\n    }\n    return maxKey;\n};\n\nAllOne.prototype.getMinKey = function() {\n    if (!this.root.next) {\n        return \"\";\n    }\n    let minKey = \"\";\n    for (const key of this.root.next.keys) {\n        minKey = key;\n        break;\n    }\n    return minKey;\n};\n\nclass Node {\n    constructor(key, count) {\n        count ? this.count = count : 0;\n        this.keys = new Set();\n        key ? this.keys.add(key) : this.keys.add(\"\");\n    }\n\n    insert(node) {  // 在 this 后插入 node\n        node.prev = this;\n        node.next = this.next;\n        node.prev.next = node;\n        node.next.prev = node;\n        return node;\n    }\n\n    remove() {\n        this.prev.next = this.next;\n        this.next.prev = this.prev;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：所有操作均为 $O(1)$，这里将字符串长度视作常数。\n\n- 空间复杂度：$O(I)$，其中 $I$ 是调用 $\\text{inc}$ 的次数。最坏情况下每次调用 $\\text{inc}$ 传入的字符串均不相同，我们需要 $O(I)$ 大小的哈希表来存储所有字符串。"
}