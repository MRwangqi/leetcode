{
	"titleSlug": "n-repeated-element-in-size-2n-array",
	"slug": "zai-chang-du-2n-de-shu-zu-zhong-zhao-chu-w88a",
	"url": "https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/solution/zai-chang-du-2n-de-shu-zu-zhong-zhao-chu-w88a/",
	"content": "#### 方法一：哈希表\n\n**思路与算法**\n\n记重复 $n$ 次的元素为 $x$。由于数组 $\\textit{nums}$ 中有 $n+1$ 个不同的元素，而其长度为 $2n$，那么数组中剩余的元素均只出现了一次。也就是说，我们只需要找到重复出现的元素即为答案。\n\n因此我们可以对数组进行一次遍历，并使用哈希集合存储已经出现过的元素。如果遍历到了哈希集合中的元素，那么返回该元素作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int repeatedNTimes(vector<int>& nums) {\n        unordered_set<int> found;\n        for (int num: nums) {\n            if (found.count(num)) {\n                return num;\n            }\n            found.insert(num);\n        }\n        // 不可能的情况\n        return -1;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int repeatedNTimes(int[] nums) {\n        Set<Integer> found = new HashSet<Integer>();\n        for (int num : nums) {\n            if (!found.add(num)) {\n                return num;\n            }\n        }\n        // 不可能的情况\n        return -1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int RepeatedNTimes(int[] nums) {\n        ISet<int> found = new HashSet<int>();\n        foreach (int num in nums) {\n            if (!found.Add(num)) {\n                return num;\n            }\n        }\n        // 不可能的情况\n        return -1;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def repeatedNTimes(self, nums: List[int]) -> int:\n        found = set()\n\n        for num in nums:\n            if num in found:\n                return num\n            found.add(num)\n        \n        # 不可能的情况\n        return -1\n```\n\n```C [sol1-C]\nstruct HashItem {\n    int key;\n    UT_hash_handle hh;\n};\n\nvoid freeHash(struct HashItem **obj) {\n    struct HashItem *curr, *tmp;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);        \n    }\n}\n\nint repeatedNTimes(int* nums, int numsSize){\n    struct HashItem *found = NULL;\n    for (int i = 0; i < numsSize; i++) {\n        struct HashItem *pEntry = NULL;\n        HASH_FIND_INT(found, &nums[i], pEntry);\n        if (pEntry != NULL) {\n            freeHash(&found);\n            return nums[i];\n        } else {\n            pEntry = (struct HashItem *)malloc(sizeof(struct HashItem));\n            pEntry->key = nums[i];\n            HASH_ADD_INT(found, key, pEntry);\n        }\n    }\n    // 不可能的情况\n    freeHash(&found);\n    return -1;\n}\n```\n\n```go [sol1-Golang]\nfunc repeatedNTimes(nums []int) int {\n    found := map[int]bool{}\n    for _, num := range nums {\n        if found[num] {\n            return num\n        }\n        found[num] = true\n    }\n    return -1 // 不可能的情况\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar repeatedNTimes = function(nums) {\n    const found = new Set();\n    for (const num of nums) {\n        if (found.has(num)) {\n            return num;\n        }\n        found.add(num);\n    }\n    // 不可能的情况\n    return -1;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。我们只需要对数组 $\\textit{nums}$ 进行一次遍历。\n\n- 空间复杂度：$O(n)$，即为哈希集合需要使用的空间。\n\n#### 方法二：数学\n\n**思路与算法**\n\n我们可以考虑重复的元素 $x$ 在数组 $\\textit{nums}$ 中出现的位置。\n\n如果相邻的 $x$ 之间至少都隔了 $2$ 个位置，那么数组的总长度至少为：\n\n$$\nn + 2(n - 1) = 3n - 2\n$$\n\n当 $n > 2$ 时，$3n-2 > 2n$，不存在满足要求的数组。因此一定存在两个相邻的 $x$，它们的位置是连续的，或者只隔了 $1$ 个位置。\n\n当 $n = 2$ 时，数组的长度最多为 $2n = 4$，因此最多只能隔 $2$ 个位置。\n\n这样一来，我们只需要遍历所有间隔 $2$ 个位置及以内的下标对，判断对应的元素是否相等即可。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int repeatedNTimes(vector<int>& nums) {\n        int n = nums.size();\n        for (int gap = 1; gap <= 3; ++gap) {\n            for (int i = 0; i + gap < n; ++i) {\n                if (nums[i] == nums[i + gap]) {\n                    return nums[i];\n                }\n            }\n        }\n        // 不可能的情况\n        return -1;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int repeatedNTimes(int[] nums) {\n        int n = nums.length;\n        for (int gap = 1; gap <= 3; ++gap) {\n            for (int i = 0; i + gap < n; ++i) {\n                if (nums[i] == nums[i + gap]) {\n                    return nums[i];\n                }\n            }\n        }\n        // 不可能的情况\n        return -1;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int RepeatedNTimes(int[] nums) {\n        int n = nums.Length;\n        for (int gap = 1; gap <= 3; ++gap) {\n            for (int i = 0; i + gap < n; ++i) {\n                if (nums[i] == nums[i + gap]) {\n                    return nums[i];\n                }\n            }\n        }\n        // 不可能的情况\n        return -1;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def repeatedNTimes(self, nums: List[int]) -> int:\n        n = len(nums)\n        for gap in range(1, 4):\n            for i in range(n - gap):\n                if nums[i] == nums[i + gap]:\n                    return nums[i]\n        \n        # 不可能的情况\n        return -1\n```\n\n```C [sol2-C]\nint repeatedNTimes(int* nums, int numsSize) {\n    for (int gap = 1; gap <= 3; ++gap) {\n        for (int i = 0; i + gap < numsSize; ++i) {\n            if (nums[i] == nums[i + gap]) {\n                return nums[i];\n            }\n        }\n    }\n    // 不可能的情况\n    return -1;\n}\n```\n\n```go [sol2-Golang]\nfunc repeatedNTimes(nums []int) int {\n    for gap := 1; gap <= 3; gap++ {\n        for i, num := range nums[:len(nums)-gap] {\n            if num == nums[i+gap] {\n                return num\n            }\n        }\n    }\n    return -1 // 不可能的情况\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar repeatedNTimes = function(nums) {\n    const n = nums.length;\n    for (let gap = 1; gap <= 3; ++gap) {\n        for (let i = 0; i + gap < n; ++i) {\n            if (nums[i] === nums[i + gap]) {\n                return nums[i];\n            }\n        }\n    }\n    // 不可能的情况\n    return -1;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。我们最多对数组进行三次遍历（除了 $n=2$ 之外，最多两次遍历）。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法三：随机选择\n\n**思路与算法**\n\n我们可以每次随机选择两个不同的下标，判断它们对应的元素是否相等即可。如果相等，那么返回任意一个作为答案。\n\n**代码**\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int repeatedNTimes(vector<int>& nums) {\n        int n = nums.size();\n        mt19937 gen{random_device{}()};\n        uniform_int_distribution<int> dis(0, n - 1);\n\n        while (true) {\n            int x = dis(gen), y = dis(gen);\n            if (x != y && nums[x] == nums[y]) {\n                return nums[x];\n            }\n        }\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int repeatedNTimes(int[] nums) {\n        int n = nums.length;\n        Random random = new Random();\n\n        while (true) {\n            int x = random.nextInt(n), y = random.nextInt(n);\n            if (x != y && nums[x] == nums[y]) {\n                return nums[x];\n            }\n        }\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int RepeatedNTimes(int[] nums) {\n        int n = nums.Length;\n        Random random = new Random();\n\n        while (true) {\n            int x = random.Next(n), y = random.Next(n);\n            if (x != y && nums[x] == nums[y]) {\n                return nums[x];\n            }\n        }\n    }\n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def repeatedNTimes(self, nums: List[int]) -> int:\n        n = len(nums)\n\n        while True:\n            x, y = random.randrange(n), random.randrange(n)\n            if x != y and nums[x] == nums[y]:\n                return nums[x]\n```\n\n```C [sol3-C]\nint repeatedNTimes(int* nums, int numsSize) {\n    srand(time(NULL));\n    while (true) {\n        int x = random() % numsSize, y = random() % numsSize;\n        if (x != y && nums[x] == nums[y]) {\n            return nums[x];\n        }\n    }\n}\n```\n\n```go [sol3-Golang]\nfunc repeatedNTimes(nums []int) int {\n    n := len(nums)\n    for {\n        x, y := rand.Intn(n), rand.Intn(n)\n        if x != y && nums[x] == nums[y] {\n            return nums[x]\n        }\n    }\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar repeatedNTimes = function(nums) {\n    const n = nums.length;\n\n    while (true) {\n        const x = Math.floor(Math.random() * n), y = Math.floor(Math.random() * n);\n        if (x !== y && nums[x] === nums[y]) {\n            return nums[x];\n        }\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：期望 $O(1)$。选择两个相同元素的概率为 $\\dfrac{n}{2n} \\times \\dfrac{n-1}{2n} \\approx \\dfrac{1}{4}$，因此期望 $4$ 次结束循环。\n\n- 空间复杂度：$O(1)$。"
}