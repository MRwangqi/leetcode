{
	"titleSlug": "paint-house-iii",
	"slug": "fen-shua-fang-zi-iii-by-leetcode-solutio-powb",
	"url": "https://leetcode-cn.com/problems/paint-house-iii/solution/fen-shua-fang-zi-iii-by-leetcode-solutio-powb/",
	"content": "#### 前言\n\n为了叙述方便，我们令所有的变量都从 $0$ 开始编号，即：\n\n- 房子的编号为 $[0, m-1]$；\n- 颜色的编号为 $[0, n-1]$，如果房子没有涂上颜色，那么记为 $-1$；\n- 街区的编号为 $[0, \\textit{target}-1]$。\n\n#### 方法一：动态规划\n\n**思路与算法**\n\n我们可以使用动态规划解决本题。\n\n设 $\\textit{dp}(i,j,k)$ 表示将 $[0, i]$ 的房子都涂上颜色，最末尾的第 $i$ 个房子的颜色为 $j$，并且它属于第 $k$ 个街区时，需要的最少花费。\n\n在进行状态转移时，我们需要考虑「第 $i-1$ 个房子的颜色」，这关系到「花费」以及「街区数量」的计算，因此我们还需要对其进行枚举。\n\n设第 $i-1$ 个房子的颜色为 $j_0$，我们可以分类讨论出不同情况下的状态转移方程：\n\n- 如果 $\\textit{houses}[i] \\neq -1$，说明第 $i$ 个房子已经涂过颜色了。由于我们不能重复涂色，那么必须有 $\\textit{houses}[i] = j$。我们可以写出在 $\\textit{houses}[i] \\neq j$ 时的状态转移方程：\n\n    $$\n    \\textit{dp}(i, j, k) = \\infty, \\quad 如果~\\textit{houses}[i] \\neq -1~并且~\\textit{houses}[i] \\neq j\n    $$\n\n    这里我们用极大值 $\\infty$ 表示不满足要求的状态，由于我们需要求出的是最少花费，因此极大值不会对状态转移产生影响。\n\n    当 $\\textit{houses}[i] = j$ 时，如果 $j=j_0$，那么第 $i-1$ 个房子和第 $i$ 个房子属于同一个街区，状态转移方程为：\n\n    $$\n    \\textit{dp}(i, j, k) = \\textit{dp}(i-1, j, k), \\quad 如果~ \\textit{houses}[i] = j\n    $$\n\n    如果 $j \\neq j_0$，那么它们属于不同的街区，状态转移方程为：\n\n    $$\n    \\textit{dp}(i, j, k) = \\min_{j_0 \\neq j} \\textit{dp}(i-1,j_0, k-1), \\quad 如果~ \\textit{houses}[i] = j\n    $$\n\n- 如果 $\\textit{houses}[i] = -1$，说明我们需要将第 $i$ 个房子涂成颜色 $j$，花费为 $\\textit{cost}[i][j]$。\n\n    此外的状态转移与上一类情况类似。如果 $j = j_0$，那么状态转移方程为：\n\n    $$\n    \\textit{dp}(i, j, k) = \\textit{dp}(i-1, j, k) + \\textit{cost}[i][j], \\quad 如果~\\textit{houses}[i]=-1\n    $$\n\n    如果 $j \\neq j_0$，那么状态转移方程为：\n\n    $$\n    \\textit{dp}(i, j, k) = \\min_{j_0 \\neq j} \\textit{dp}(i-1,j_0, k-1) + \\textit{cost}[i][j], \\quad 如果~\\textit{houses}[i]=-1\n    $$\n\n最终的答案即为 $\\min\\limits_{j} \\textit{dp}(m-1, j, \\textit{target} - 1)$。\n\n**细节**\n\n以下的细节有助于写出更简洁的代码：\n\n- 我们可以将所有的状态初始化为 $\\infty$。在进行状态转移时，我们是选择转移中的最小值，因此 $\\infty$ 不会产生影响；\n\n- 两类情况下的状态转移方程十分类似，因此我们可以先不去管 $\\textit{cost}[i][j]$ 的部分，在求出 $\\textit{dp}(i, j, k)$ 的最小值之后，如果发现 $\\textit{houses}[i]=-1$，再加上 $\\textit{cost}[i][j]$ 即可；\n\n- 当 $k=0$ 时，不能从包含 $k-1$ 的状态转移而来；\n\n- 当 $i=0$ 时，第 $0$ 个房子之前没有房子，因此 $k$ 也必须为 $0$。此时状态转移方程为：\n\n    $$\n    \\textit{dp}(0, j, 0) = \\left\\{ \\begin{aligned}\n    & \\infty, && 如果~\\textit{houses}[i] \\neq -1 ~并且~\\textit{houses}[i] \\neq j \\\\\n    & 0, && 如果~\\textit{houses}[i] \\neq -1 ~并且~\\textit{houses}[i] = j \\\\\n    & \\textit{cost}[i][j], && 如果~\\textit{houses}[i]=-1\n    \\end{aligned} \\right.\n    $$\n\n    当 $i=0$ 且 $k \\neq 0$ 时，$\\textit{dp}(0, j, k) = \\infty$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    // 极大值\n    // 选择 INT_MAX / 2 的原因是防止整数相加溢出\n    static constexpr int INFTY = INT_MAX / 2;\n\npublic:\n    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {\n        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n        for (int& c: houses) {\n            --c;\n        }\n\n        // dp 所有元素初始化为极大值\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(target, INFTY)));\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (houses[i] != -1 && houses[i] != j) {\n                    continue;\n                }\n                \n                for (int k = 0; k < target; ++k) {\n                    for (int j0 = 0; j0 < n; ++j0) {\n                        if (j == j0) {\n                            if (i == 0) {\n                                if (k == 0) {\n                                    dp[i][j][k] = 0;\n                                }\n                            }\n                            else {\n                                dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k]);\n                            }\n                        }\n                        else if (i > 0 && k > 0) {\n                            dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j0][k - 1]);\n                        }\n                    }\n\n                    if (dp[i][j][k] != INFTY && houses[i] == -1) {\n                        dp[i][j][k] += cost[i][j];\n                    }\n                }\n            }\n        }\n\n        int ans = INFTY;\n        for (int j = 0; j < n; ++j) {\n            ans = min(ans, dp[m - 1][j][target - 1]);\n        }\n        return ans == INFTY ? -1 : ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    // 极大值\n    // 选择 Integer.MAX_VALUE / 2 的原因是防止整数相加溢出\n    static final int INFTY = Integer.MAX_VALUE / 2;\n\n    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {\n        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n        for (int i = 0; i < m; ++i) {\n            --houses[i];\n        }\n\n        // dp 所有元素初始化为极大值\n        int[][][] dp = new int[m][n][target];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                Arrays.fill(dp[i][j], INFTY);\n            }\n        }\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (houses[i] != -1 && houses[i] != j) {\n                    continue;\n                }\n                \n                for (int k = 0; k < target; ++k) {\n                    for (int j0 = 0; j0 < n; ++j0) {\n                        if (j == j0) {\n                            if (i == 0) {\n                                if (k == 0) {\n                                    dp[i][j][k] = 0;\n                                }\n                            } else {\n                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k]);\n                            }\n                        } else if (i > 0 && k > 0) {\n                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j0][k - 1]);\n                        }\n                    }\n\n                    if (dp[i][j][k] != INFTY && houses[i] == -1) {\n                        dp[i][j][k] += cost[i][j];\n                    }\n                }\n            }\n        }\n\n        int ans = INFTY;\n        for (int j = 0; j < n; ++j) {\n            ans = Math.min(ans, dp[m - 1][j][target - 1]);\n        }\n        return ans == INFTY ? -1 : ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    // 极大值\n    // 选择 int.MaxValue / 2 的原因是防止整数相加溢出\n    const int INFTY = int.MaxValue / 2;\n\n    public int MinCost(int[] houses, int[][] cost, int m, int n, int target) {\n        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n        for (int i = 0; i < m; ++i) {\n            --houses[i];\n        }\n\n        // dp 所有元素初始化为极大值\n        int[,,] dp = new int[m, n, target];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < target; ++k) {\n                    dp[i, j, k] = INFTY;\n                }\n            }\n        }\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (houses[i] != -1 && houses[i] != j) {\n                    continue;\n                }\n                \n                for (int k = 0; k < target; ++k) {\n                    for (int j0 = 0; j0 < n; ++j0) {\n                        if (j == j0) {\n                            if (i == 0) {\n                                if (k == 0) {\n                                    dp[i, j, k] = 0;\n                                }\n                            } else {\n                                dp[i, j, k] = Math.Min(dp[i, j, k], dp[i - 1, j, k]);\n                            }\n                        } else if (i > 0 && k > 0) {\n                            dp[i, j, k] = Math.Min(dp[i, j, k], dp[i - 1, j0, k - 1]);\n                        }\n                    }\n\n                    if (dp[i, j, k] != INFTY && houses[i] == -1) {\n                        dp[i, j, k] += cost[i][j];\n                    }\n                }\n            }\n        }\n\n        int ans = INFTY;\n        for (int j = 0; j < n; ++j) {\n            ans = Math.Min(ans, dp[m - 1, j, target - 1]);\n        }\n        return ans == INFTY ? -1 : ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        # 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n        houses = [c - 1 for c in houses]\n\n        # dp 所有元素初始化为极大值\n        dp = [[[float(\"inf\")] * target for _ in range(n)] for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if houses[i] != -1 and houses[i] != j:\n                    continue\n                \n                for k in range(target):\n                    for j0 in range(n):\n                        if j == j0:\n                            if i == 0:\n                                if k == 0:\n                                    dp[i][j][k] = 0\n                            else:\n                                dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])\n                        elif i > 0 and k > 0:\n                            dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j0][k - 1])\n\n                    if dp[i][j][k] != float(\"inf\") and houses[i] == -1:\n                        dp[i][j][k] += cost[i][j]\n\n        ans = min(dp[m - 1][j][target - 1] for j in range(n))\n        return -1 if ans == float(\"inf\") else ans\n```\n\n```JavaScript [sol1-JavaScript]\nvar minCost = function(houses, cost, m, n, target) {\n    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n    houses = houses.map(c => --c);\n    const dp = new Array(m).fill(0)\n                           .map(() => new Array(n).fill(0)\n                           .map(() => new Array(target).fill(Number.MAX_VALUE)));\n    \n    // dp 所有元素初始化为极大值\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (houses[i] !== -1 && houses[i] !== j) {\n                continue;\n            }\n            \n            for (let k = 0; k < target; ++k) {\n                for (let j0 = 0; j0 < n; ++j0) {\n                    if (j === j0) {\n                        if (i === 0) {\n                            if (k === 0) {\n                                dp[i][j][k] = 0;\n                            }\n                        } else {\n                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k]);\n                        }\n                    } else if (i > 0 && k > 0) {\n                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j0][k - 1]);\n                    }\n                }\n\n                if (dp[i][j][k] !== Number.MAX_VALUE && houses[i] === -1) {\n                    dp[i][j][k] += cost[i][j];\n                }\n            }\n        }\n    }\n    \n    let ans = Number.MAX_VALUE;\n    for (let j = 0; j < n; ++j) {\n        ans = Math.min(ans, dp[m - 1][j][target - 1]);\n    }\n    return ans === Number.MAX_VALUE ? -1 : ans;\n};\n```\n\n```go [sol1-Golang]\nfunc minCost(houses []int, cost [][]int, m, n, target int) int {\n    const inf = math.MaxInt64 / 2 // 防止整数相加溢出\n\n    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n    for i := range houses {\n        houses[i]--\n    }\n\n    // dp 所有元素初始化为极大值\n    dp := make([][][]int, m)\n    for i := range dp {\n        dp[i] = make([][]int, n)\n        for j := range dp[i] {\n            dp[i][j] = make([]int, target)\n            for k := range dp[i][j] {\n                dp[i][j][k] = inf\n            }\n        }\n    }\n\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            if houses[i] != -1 && houses[i] != j {\n                continue\n            }\n\n            for k := 0; k < target; k++ {\n                for j0 := 0; j0 < n; j0++ {\n                    if j == j0 {\n                        if i == 0 {\n                            if k == 0 {\n                                dp[i][j][k] = 0\n                            }\n                        } else {\n                            dp[i][j][k] = min(dp[i][j][k], dp[i-1][j][k])\n                        }\n                    } else if i > 0 && k > 0 {\n                        dp[i][j][k] = min(dp[i][j][k], dp[i-1][j0][k-1])\n                    }\n                }\n\n                if dp[i][j][k] != inf && houses[i] == -1 {\n                    dp[i][j][k] += cost[i][j]\n                }\n            }\n        }\n    }\n\n    ans := inf\n    for _, res := range dp[m-1] {\n        ans = min(ans, res[target-1])\n    }\n    if ans == inf {\n        return -1\n    }\n    return ans\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n```C [sol1-C]\n// 极大值\n// 选择 INT_MAX / 2 的原因是防止整数相加溢出\nconst int INFTY = 0x3f3f3f3f;\n\nint minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target) {\n    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n    for (int i = 0; i < housesSize; ++i) {\n        houses[i]--;\n    }\n\n    // dp 所有元素初始化为极大值\n    int dp[m][n][target];\n    memset(dp, 0x3f, sizeof(dp));\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (houses[i] != -1 && houses[i] != j) {\n                continue;\n            }\n\n            for (int k = 0; k < target; ++k) {\n                for (int j0 = 0; j0 < n; ++j0) {\n                    if (j == j0) {\n                        if (i == 0) {\n                            if (k == 0) {\n                                dp[i][j][k] = 0;\n                            }\n                        } else {\n                            dp[i][j][k] = fmin(dp[i][j][k], dp[i - 1][j][k]);\n                        }\n                    } else if (i > 0 && k > 0) {\n                        dp[i][j][k] = fmin(dp[i][j][k], dp[i - 1][j0][k - 1]);\n                    }\n                }\n\n                if (dp[i][j][k] != INFTY && houses[i] == -1) {\n                    dp[i][j][k] += cost[i][j];\n                }\n            }\n        }\n    }\n\n    int ans = INFTY;\n    for (int j = 0; j < n; ++j) {\n        ans = fmin(ans, dp[m - 1][j][target - 1]);\n    }\n    return ans == INFTY ? -1 : ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m\\cdot n^2\\cdot \\textit{target})$。状态的数量为 $O(m\\cdot n\\cdot \\textit{target})$，每个状态需要 $O(n)$ 的时间枚举 $j_0$，因此总时间复杂度为 $O(m\\cdot n^2\\cdot \\textit{target})$。\n\n- 空间复杂度：$O(m \\cdot n \\cdot \\textit{target})$，即为状态的数量。\n\n    注意到 $\\textit{dp}(i,j,k)$ 只会从 $\\textit{dp}(i-1, \\cdots, \\cdots)$ 转移而来，因此我们可以使用滚动数组对空间复杂度进行优化，即使用两个大小为 $n \\cdot \\textit{target}$ 的数组 $\\textit{dp}_1$, $\\textit{dp}_2$，将 $dp(0,j,k)$ 的值存储在 $\\textit{dp}_1$ 中，将 $dp(1,j,k)$ 的值存储在 $\\textit{dp}_2$ 中，将 $dp(2,j,k)$ 的值存储在 $\\textit{dp}_1$ 中，将 $dp(3,j,k)$ 的值存储在 $\\textit{dp}_2$ 中，以此类推。这样优化后的空间复杂度为 $O(n\\cdot \\textit{target})$。\n\n\n#### 方法二：动态规划 + 优化\n\n**思路与算法**\n\n在方法一中，我们分类讨论出了五种不同的状态转移方程，其中有三种是可以在 $O(1)$ 的时间进行状态转移的，而剩余的两种需要枚举 $j_0$，只能在 $O(n)$ 的时间进行转移，即：\n\n$$\n\\textit{dp}(i, j, k) = \\min_{j_0 \\neq j} \\textit{dp}(i-1,j_0, k-1), \\quad 如果~ \\textit{houses}[i] = j\n$$\n\n以及：\n\n$$\n\\textit{dp}(i, j, k) = \\min_{j_0 \\neq j} \\textit{dp}(i-1,j_0, k-1) + \\textit{cost}[i][j], \\quad 如果~\\textit{houses}[i]=-1\n$$\n\n如果我们能将它们优化至 $O(1)$，那么整个动态规划的时间复杂度也可以从 $O(m\\cdot n^2\\cdot \\textit{target})$ 优化至 $O(m \\cdot n \\cdot \\textit{target})$。\n\n我们可以令 $\\textit{best}(i, k) = (\\textit{first}, \\textit{first\\_idx}, \\textit{second})$，表示所有的状态 $dp(i, j, k)$ 中的最小值为 $\\textit{first}$，取到最小值对应的 $j$ 值为 $\\textit{first\\_idx}$，次小值为 $\\textit{second}$。这里 $j$ 可以在 $[0, n)$ 中任意选择，但我们只记录最大值和次大值，以及最大值对应的 $j$。\n\n这样做的好处在于我们可以快速地求出原先需要 $O(n)$ 的时间才能求出的：\n\n$$\n\\min_{j_0 \\neq j} \\textit{dp}(i-1,j_0, k-1)\n$$\n\n这一项。即：\n\n- 我们取出 $\\textit{best}(i - 1, k - 1)$，它包含的三个值为 $(\\textit{first}, \\textit{first\\_idx}, \\textit{second})$；\n\n- 如果 $j = \\textit{first\\_idx}$，那么 $\\textit{dp}(i, j, k) = \\textit{second}$；\n\n- 如果 $j \\neq \\textit{first\\_idx}$，那么 $\\textit{dp}(i, j, k) = \\textit{first}$。\n\n这样做的正确性通过 $\\min\\limits_{j_0 \\neq j} \\textit{dp}(i-1,j_0, k-1)$ 本身的定义就能体现。\n\n那么如何求出 $\\textit{best}(i, k)$ 呢？我们可以给每一个 $\\textit{best}(i, k)$ 赋予初始值 $(\\infty, -1, \\infty)$，每次我们计算出 $\\textit{dp}(i, j, k)$ 时，使用其更新 $\\textit{best}(i, k)$ 即可。\n\n**代码**\n\n方法二的代码较为复杂，主要的原因在于我们需要将方法一中的 $O(n)$ 枚举 $j_0$ 的循环删除，并且需要保持方法一中的边界条件不变。\n\n```C++ [sol2-C++]\nclass Solution {\nprivate:\n    // 极大值\n    // 选择 INT_MAX / 2 的原因是防止整数相加溢出\n    static constexpr int INFTY = INT_MAX / 2;\n\n    using TIII = tuple<int, int, int>;\n\npublic:\n    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {\n        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n        for (int& c: houses) {\n            --c;\n        }\n\n        // dp 所有元素初始化为极大值\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(target, INFTY)));\n        vector<vector<TIII>> best(m, vector<TIII>(target, {INFTY, -1, INFTY}));\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (houses[i] != -1 && houses[i] != j) {\n                    continue;\n                }\n                \n                for (int k = 0; k < target; ++k) {\n                    if (i == 0) {\n                        if (k == 0) {\n                            dp[i][j][k] = 0;\n                        }\n                    }\n                    else {\n                        dp[i][j][k] = dp[i - 1][j][k];\n                        if (k > 0) {\n                            // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值\n                            auto&& [first, first_idx, second] = best[i - 1][k - 1];\n                            dp[i][j][k] = min(dp[i][j][k], (j == first_idx ? second : first));\n                        }\n                    }\n\n                    if (dp[i][j][k] != INFTY && houses[i] == -1) {\n                        dp[i][j][k] += cost[i][j];\n                    }\n\n                    // 用 dp(i,j,k) 更新 best(i,k)\n                    auto&& [first, first_idx, second] = best[i][k];\n                    if (dp[i][j][k] < first) {\n                        second = first;\n                        first = dp[i][j][k];\n                        first_idx = j;\n                    }\n                    else if (dp[i][j][k] < second) {\n                        second = dp[i][j][k];\n                    }\n                }\n            }\n        }\n\n        int ans = INFTY;\n        for (int j = 0; j < n; ++j) {\n            ans = min(ans, dp[m - 1][j][target - 1]);\n        }\n        return ans == INFTY ? -1 : ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    // 极大值\n    // 选择 Integer.MAX_VALUE / 2 的原因是防止整数相加溢出\n    static final int INFTY = Integer.MAX_VALUE / 2;\n\n    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {\n        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n        for (int i = 0; i < m; ++i) {\n            --houses[i];\n        }\n\n        // dp 所有元素初始化为极大值\n        int[][][] dp = new int[m][n][target];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                Arrays.fill(dp[i][j], INFTY);\n            }\n        }\n        int[][][] best = new int[m][target][3];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < target; ++j) {\n                best[i][j][0] = best[i][j][2] = INFTY;\n                best[i][j][1] = -1;\n            }\n        }\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (houses[i] != -1 && houses[i] != j) {\n                    continue;\n                }\n                \n                for (int k = 0; k < target; ++k) {\n                    if (i == 0) {\n                        if (k == 0) {\n                            dp[i][j][k] = 0;\n                        }\n                    } else {\n                        dp[i][j][k] = dp[i - 1][j][k];\n                        if (k > 0) {\n                            // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值\n                            int first = best[i - 1][k - 1][0];\n                            int firstIdx = best[i - 1][k - 1][1];\n                            int second = best[i - 1][k - 1][2];\n                            dp[i][j][k] = Math.min(dp[i][j][k], (j == firstIdx ? second : first));\n                        }\n                    }\n\n                    if (dp[i][j][k] != INFTY && houses[i] == -1) {\n                        dp[i][j][k] += cost[i][j];\n                    }\n\n                    // 用 dp(i,j,k) 更新 best(i,k)\n                    int first = best[i][k][0];\n                    int firstIdx = best[i][k][1];\n                    int second = best[i][k][2];\n                    if (dp[i][j][k] < first) {\n                        best[i][k][2] = first;\n                        best[i][k][0] = dp[i][j][k];\n                        best[i][k][1] = j;\n                    } else if (dp[i][j][k] < second) {\n                        best[i][k][2] = dp[i][j][k];\n                    }\n                }\n            }\n        }\n\n        int ans = INFTY;\n        for (int j = 0; j < n; ++j) {\n            ans = Math.min(ans, dp[m - 1][j][target - 1]);\n        }\n        return ans == INFTY ? -1 : ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    // 极大值\n    // 选择 int.MaxValue / 2 的原因是防止整数相加溢出\n    const int INFTY = int.MaxValue / 2;\n\n    public int MinCost(int[] houses, int[][] cost, int m, int n, int target) {\n        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n        for (int i = 0; i < m; ++i) {\n            --houses[i];\n        }\n\n        // dp 所有元素初始化为极大值\n        int[,,] dp = new int[m, n, target];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < target; ++k) {\n                    dp[i, j, k] = INFTY;\n                }\n            }\n        }\n        int[,,] best = new int[m, target, 3];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < target; ++j) {\n                best[i, j, 0] = best[i, j, 2] = INFTY;\n                best[i, j, 1] = -1;\n            }\n        }\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (houses[i] != -1 && houses[i] != j) {\n                    continue;\n                }\n                \n                for (int k = 0; k < target; ++k) {\n                    if (i == 0) {\n                        if (k == 0) {\n                            dp[i, j, k] = 0;\n                        }\n                    } else {\n                        dp[i, j, k] = dp[i - 1, j, k];\n                        if (k > 0) {\n                            // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值\n                            dp[i, j, k] = Math.Min(dp[i, j, k], (j == best[i - 1, k - 1, 1] ? best[i - 1, k - 1, 2] : best[i - 1, k - 1, 0]));\n                        }\n                    }\n\n                    if (dp[i, j, k] != INFTY && houses[i] == -1) {\n                        dp[i, j, k] += cost[i][j];\n                    }\n\n                    // 用 dp(i,j,k) 更新 best(i,k)\n                    int first = best[i, k, 0];\n                    int firstIdx = best[i, k, 1];\n                    int second = best[i, k, 2];\n                    if (dp[i, j, k] < first) {\n                        best[i, k, 2] = first;\n                        best[i, k, 0] = dp[i, j, k];\n                        best[i, k, 1] = j;\n                    } else if (dp[i, j, k] < second) {\n                        best[i, k, 2] = dp[i, j, k];\n                    }\n                }\n            }\n        }\n\n        int ans = INFTY;\n        for (int j = 0; j < n; ++j) {\n            ans = Math.Min(ans, dp[m - 1, j, target - 1]);\n        }\n        return ans == INFTY ? -1 : ans;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Entry:\n    def __init__(self):\n        self.first = float(\"inf\")\n        self.first_idx = -1\n        self.second = float(\"inf\")\n\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        # 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n        houses = [c - 1 for c in houses]\n\n        # dp 所有元素初始化为极大值\n        dp = [[[float(\"inf\")] * target for _ in range(n)] for _ in range(m)]\n        best = [[Entry() for _ in range(target)] for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if houses[i] != -1 and houses[i] != j:\n                    continue\n                \n                for k in range(target):\n                    if i == 0:\n                        if k == 0:\n                            dp[i][j][k] = 0\n                    else:\n                        dp[i][j][k] = dp[i - 1][j][k]\n                        if k > 0:\n                            # 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值\n                            info = best[i - 1][k - 1]\n                            dp[i][j][k] = min(dp[i][j][k], (info.second if j == info.first_idx else info.first))\n\n                    if dp[i][j][k] != float(\"inf\") and houses[i] == -1:\n                        dp[i][j][k] += cost[i][j]\n                    \n                    # 用 dp(i,j,k) 更新 best(i,k)\n                    info = best[i][k]\n                    if dp[i][j][k] < info.first:\n                        info.second = info.first\n                        info.first = dp[i][j][k]\n                        info.first_idx = j\n                    elif dp[i][j][k] < info.second:\n                        info.second = dp[i][j][k]\n\n        ans = min(dp[m - 1][j][target - 1] for j in range(n))\n        return -1 if ans == float(\"inf\") else ans\n```\n\n```go [sol2-Golang]\ntype entry struct {\n    first, firstIdx, second int\n}\n\nfunc minCost(houses []int, cost [][]int, m, n, target int) int {\n    const inf = math.MaxInt64 / 2 // 防止整数相加溢出\n\n    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n    for i := range houses {\n        houses[i]--\n    }\n\n    // dp 所有元素初始化为极大值\n    dp := make([][][]int, m)\n    for i := range dp {\n        dp[i] = make([][]int, n)\n        for j := range dp[i] {\n            dp[i][j] = make([]int, target)\n            for k := range dp[i][j] {\n                dp[i][j][k] = inf\n            }\n        }\n    }\n    best := make([][]entry, m)\n    for i := range best {\n        best[i] = make([]entry, target)\n        for j := range best[i] {\n            best[i][j] = entry{inf, -1, inf}\n        }\n    }\n\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            if houses[i] != -1 && houses[i] != j {\n                continue\n            }\n\n            for k := 0; k < target; k++ {\n                if i == 0 {\n                    if k == 0 {\n                        dp[i][j][k] = 0\n                    }\n                } else {\n                    dp[i][j][k] = dp[i-1][j][k]\n                    if k > 0 {\n                        // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值\n                        if b := best[i-1][k-1]; j == b.firstIdx {\n                            dp[i][j][k] = min(dp[i][j][k], b.second)\n                        } else {\n                            dp[i][j][k] = min(dp[i][j][k], b.first)\n                        }\n                    }\n                }\n\n                if dp[i][j][k] != inf && houses[i] == -1 {\n                    dp[i][j][k] += cost[i][j]\n                }\n\n                // 用 dp(i,j,k) 更新 best(i,k)\n                if b := &best[i][k]; dp[i][j][k] < b.first {\n                    b.second = b.first\n                    b.first = dp[i][j][k]\n                    b.firstIdx = j\n                } else if dp[i][j][k] < b.second {\n                    b.second = dp[i][j][k]\n                }\n            }\n        }\n    }\n\n    ans := inf\n    for _, res := range dp[m-1] {\n        ans = min(ans, res[target-1])\n    }\n    if ans == inf {\n        return -1\n    }\n    return ans\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n```C [sol2-C]\nstruct TIII {\n    int first, first_idx, second;\n};\n\n// 极大值\n// 选择 INT_MAX / 2 的原因是防止整数相加溢出\nconst int INFTY = 0x3f3f3f3f;\n\nint minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target) {\n    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n    for (int i = 0; i < housesSize; ++i) {\n        houses[i]--;\n    }\n\n    // dp 所有元素初始化为极大值\n    int dp[m][n][target];\n    memset(dp, 0x3f, sizeof(dp));\n    struct TIII best[m][target];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < target; j++) {\n            best[i][j] = (struct TIII){INFTY, -1, INFTY};\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (houses[i] != -1 && houses[i] != j) {\n                continue;\n            }\n\n            for (int k = 0; k < target; ++k) {\n                if (i == 0) {\n                    if (k == 0) {\n                        dp[i][j][k] = 0;\n                    }\n                } else {\n                    dp[i][j][k] = dp[i - 1][j][k];\n                    if (k > 0) {\n                        // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值\n                        struct TIII* tmp = &best[i - 1][k - 1];\n                        dp[i][j][k] = fmin(dp[i][j][k], (j == tmp->first_idx ? tmp->second : tmp->first));\n                    }\n                }\n\n                if (dp[i][j][k] != INFTY && houses[i] == -1) {\n                    dp[i][j][k] += cost[i][j];\n                }\n\n                // 用 dp(i,j,k) 更新 best(i,k)\n                struct TIII* tmp = &best[i][k];\n                if (dp[i][j][k] < tmp->first) {\n                    tmp->second = tmp->first;\n                    tmp->first = dp[i][j][k];\n                    tmp->first_idx = j;\n                } else if (dp[i][j][k] < tmp->second) {\n                    tmp->second = dp[i][j][k];\n                }\n            }\n        }\n    }\n\n    int ans = INFTY;\n    for (int j = 0; j < n; ++j) {\n        ans = fmin(ans, dp[m - 1][j][target - 1]);\n    }\n    return ans == INFTY ? -1 : ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar minCost = function(houses, cost, m, n, target) {\n    const INFTY = Number.MAX_VALUE;\n\n    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1\n    for (let i = 0; i < m; ++i) {\n        --houses[i];\n    }\n\n    // dp 所有元素初始化为极大值\n    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0).map(() => new Array(target).fill(INFTY)));\n    const best = new Array(m).fill(0).map(() => new Array(target).fill(0).map(() => new Array(3).fill(INFTY)));\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < target; ++j) {\n            // best[i][j][0] = best[i][j][2] = INFTY;\n            best[i][j][1] = -1;\n        }\n    }\n\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (houses[i] !== -1 && houses[i] !== j) {\n                continue;\n            }\n\n            for (let k = 0; k < target; ++k) {\n                if (i === 0) {\n                    if (k === 0) {\n                        dp[i][j][k] = 0;\n                    }\n                } else {\n                    dp[i][j][k] = dp[i - 1][j][k];\n                    if (k > 0) {\n                        // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值\n                        const first = best[i - 1][k - 1][0];\n                        const firstIdx = best[i - 1][k - 1][1];\n                        const second = best[i - 1][k - 1][2];\n                        dp[i][j][k] = Math.min(dp[i][j][k], (j === firstIdx ? second : first));\n                    }\n                }\n\n                if (dp[i][j][k] !== INFTY && houses[i] === -1) {\n                    dp[i][j][k] += cost[i][j];\n                }\n\n                // 用 dp(i,j,k) 更新 best(i,k)\n                const first = best[i][k][0];\n                const firstIdx = best[i][k][1];\n                const second = best[i][k][2];\n                if (dp[i][j][k] < first) {\n                    best[i][k][2] = first;\n                    best[i][k][0] = dp[i][j][k];\n                    best[i][k][1] = j;\n                } else if (dp[i][j][k] < second) {\n                    best[i][k][2] = dp[i][j][k];\n                }\n            }\n        }\n    }\n    let ans = INFTY;\n    for (let j = 0; j < n; ++j) {\n        ans = Math.min(ans, dp[m - 1][j][target - 1]);\n    }\n    return ans === INFTY ? -1 : ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m\\cdot n\\cdot \\textit{target})$。状态的数量为 $O(m\\cdot n\\cdot \\textit{target})$，每个状态只需要 $O(1)$ 的时间进行计算，同时需要 $O(1)$ 的时间来更新 $\\textit{best}$，因此总时间复杂度为 $O(m\\cdot n\\cdot \\textit{target})$。\n\n- 空间复杂度：$O(m\\cdot n \\cdot \\textit{target})$，即为状态的数量。除此之外，我们需要 $O(m \\cdot \\textit{target})$ 的空间存储 $\\textit{best}$，但其在渐进意义下小于前者，因此可以忽略。\n\n    与方法一相同，我们也可以将空间复杂度优化至 $O(n\\cdot \\textit{target})$。"
}