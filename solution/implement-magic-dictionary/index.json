{
	"titleSlug": "implement-magic-dictionary",
	"slug": "shi-xian-yi-ge-mo-fa-zi-dian-by-leetcode-b35s",
	"url": "https://leetcode-cn.com/problems/implement-magic-dictionary/solution/shi-xian-yi-ge-mo-fa-zi-dian-by-leetcode-b35s/",
	"content": "#### 方法一：枚举每个字典中的字符串并判断\n\n**思路与算法**\n\n对于本题来说，我们有两种做法：第一种是把字典中的所有字符串存储在数组中，而当进行 $\\text{search}$ 操作时，我们将待查询的字符串和数组中的字符串依次进行比较；第二种是提前把字典中每个字符串替换任一字母的结果存在哈希表中，当进行 $\\text{search}$ 操作时，我们只需要检查待查询的字符串本身是否在哈希表中即可。\n\n记字典中字符串的个数为 $n$，平均长度为 $l$，查询的次数为 $q$，字符集为 $\\Sigma$。那么：\n\n- 第一种方法需要 $O(nl)$ 的时间把所有字符串存储在数组中，每一次查询也需要 $O(nl)$ 的时间，总时间复杂度为 $O(nl + qnl) = O(qnl)$；\n\n- 第二种方法需要 $O(nl^2|\\Sigma|)$ 的时间把所有字符串替换任一字母的结果存在哈希表中，每一次查询仅需要 $O(l)$ 的时间，总时间复杂度为 $O(nl^2|\\Sigma| + ql)$。\n\n在本题的数据范围中 $n, l, q \\leq 100$ 同阶，而 $|\\Sigma| = 26$，因此第一种方法的时间复杂度较低，下面的代码使用的是第一种方法。\n\n**细节**\n\n使用第一种方法比较两个字符串时，我们首先需要保证它们的长度相等，随后遍历这两个字符串，需要保证这两个字符串恰好有一个位置对应的字符不同。\n\n**代码**\n\n```C++ [sol1-C++]\nclass MagicDictionary {\npublic:\n    MagicDictionary() {}\n    \n    void buildDict(vector<string> dictionary) {\n        words = dictionary;\n    }\n    \n    bool search(string searchWord) {\n        for (auto&& word: words) {\n            if (word.size() != searchWord.size()) {\n                continue;\n            }\n\n            int diff = 0;\n            for (int i = 0; i < word.size(); ++i) {\n                if (word[i] != searchWord[i]) {\n                    ++diff;\n                    if (diff > 1) {\n                        break;\n                    }\n                }\n            }\n            if (diff == 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nprivate:\n    vector<string> words;\n};\n```\n\n```Java [sol1-Java]\nclass MagicDictionary {\n    private String[] words;\n\n    public MagicDictionary() {\n\n    }\n\n    public void buildDict(String[] dictionary) {\n        words = dictionary;\n    }\n\n    public boolean search(String searchWord) {\n        for (String word : words) {\n            if (word.length() != searchWord.length()) {\n                continue;\n            }\n\n            int diff = 0;\n            for (int i = 0; i < word.length(); ++i) {\n                if (word.charAt(i) != searchWord.charAt(i)) {\n                    ++diff;\n                    if (diff > 1) {\n                        break;\n                    }\n                }\n            }\n            if (diff == 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class MagicDictionary {\n    private string[] words;\n\n    public MagicDictionary() {\n\n    }\n    \n    public void BuildDict(string[] dictionary) {\n        words = dictionary;\n    }\n\n    public bool Search(string searchWord) {\n        foreach (string word in words) {\n            if (word.Length != searchWord.Length) {\n                continue;\n            }\n\n            int diff = 0;\n            for (int i = 0; i < word.Length; ++i) {\n                if (word[i] != searchWord[i]) {\n                    ++diff;\n                    if (diff > 1) {\n                        break;\n                    }\n                }\n            }\n            if (diff == 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass MagicDictionary:\n\n    def __init__(self):\n        self.words = list()\n\n    def buildDict(self, dictionary: List[str]) -> None:\n        self.words = dictionary\n\n    def search(self, searchWord: str) -> bool:\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            \n            diff = 0\n            for chx, chy in zip(word, searchWord):\n                if chx != chy:\n                    diff += 1\n                    if diff > 1:\n                        break\n            \n            if diff == 1:\n                return True\n        \n        return False\n```\n\n```C [sol1-C]\ntypedef struct {\n    char **words;\n    int wordsSize;\n} MagicDictionary;\n\nMagicDictionary* magicDictionaryCreate() {\n    MagicDictionary *obj = (MagicDictionary *)malloc(sizeof(MagicDictionary));\n    return obj;\n}\n\nvoid magicDictionaryBuildDict(MagicDictionary* obj, char ** dictionary, int dictionarySize) {\n    obj->words = dictionary;\n    obj->wordsSize = dictionarySize;\n}\n\nbool magicDictionarySearch(MagicDictionary* obj, char * searchWord) {\n    int len = strlen(searchWord);\n    for (int j = 0; j < obj->wordsSize; j++) {\n        if (strlen(obj->words[j]) != len) {\n            continue;\n        }\n        int diff = 0;\n        for (int i = 0; i < len; ++i) {\n            if (obj->words[j][i] != searchWord[i]) {\n                ++diff;\n                if (diff > 1) {\n                    break;\n                }\n            }\n        }\n        if (diff == 1) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid magicDictionaryFree(MagicDictionary* obj) {\n    free(obj);\n}\n```\n\n```go [sol1-Golang]\ntype MagicDictionary []string\n\nfunc Constructor() MagicDictionary {\n    return MagicDictionary{}\n}\n\nfunc (d *MagicDictionary) BuildDict(dictionary []string) {\n    *d = dictionary\n}\n\nfunc (d *MagicDictionary) Search(searchWord string) bool {\nnext:\n    for _, word := range *d {\n        if len(word) != len(searchWord) {\n            continue\n        }\n        diff := false\n        for i := range word {\n            if word[i] != searchWord[i] {\n                if diff {\n                    continue next\n                }\n                diff = true\n            }\n        }\n        if diff {\n            return true\n        }\n    }\n    return false\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar MagicDictionary = function() {\n\n};\n\nMagicDictionary.prototype.buildDict = function(dictionary) {\n    this.words = dictionary;\n};\n\nMagicDictionary.prototype.search = function(searchWord) {\n    for (const word of this.words) {\n        if (word.length !== searchWord.length) {\n            continue;\n        }\n\n        let diff = 0;\n        for (let i = 0; i < word.length; ++i) {\n            if (word[i] !== searchWord[i]) {\n                ++diff;\n                if (diff > 1) {\n                    break;\n                }\n            }\n        }\n        if (diff === 1) {\n            return true;\n        }\n    }\n    return false;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(qnl)$，其中 $n$ 是数组 $\\textit{dictionary}$ 的长度，$l$ 是数组 $\\textit{dictionary}$ 中字符串的平均长度，$q$ 是函数 $\\text{search(searchWord)}$ 的调用次数。\n\n- 空间复杂度：$O(nl)$，即为数组需要使用的空间。\n\n#### 方法二：使用字典树优化枚举\n\n**思路与算法**\n\n我们也可以使用字典树代替数组，将所有字符串进行存储。这一部分需要的时间是相同的。\n\n在查询时，我们可以使用递归 + 回溯的方法，使用递归函数 $\\text{dfs}(\\textit{node}, \\textit{pos}, \\textit{modified})$，其中的变量分别表示：当前遍历到的字典树上的节点是 $\\textit{node}$ 以及待查询字符串 $\\textit{searchWord}$ 的第 $\\textit{pos}$ 个字符，并且在之前的遍历中是否已经替换过恰好一个字符（如果替换过，那么 $\\textit{modified}$ 为 $\\text{true}$，否则为 $\\text{false}$）。\n\n如果 $\\textit{node}$ 有一个值为 $\\textit{searchWord}[pos]$ 的子节点，那么我们就可以继续进行递归。同时，如果 $\\textit{modified}$ 为 $\\text{false}$，我们可以将 $\\textit{searchWord}[pos]$ 替换成任意一个是 $\\textit{node}$ 子节点的字符，将 $\\textit{modified}$ 置为 $\\text{true}$ 并继续进行递归。\n\n当 $\\textit{pos}$ 等于 $\\textit{searchWord}$ 的长度时，说明递归完成。此时我们需要检查 $\\textit{node}$ 是否是一个字典树上的结束节点（即一个单词的末尾），同时需要保证 $\\textit{modified}$ 为 $\\text{true}$，因为我们必须进行一次修改。\n\n**代码**\n\n```C++ [sol2-C++]\nstruct Trie {\n    bool is_finished;\n    Trie* child[26];\n\n    Trie() {\n        is_finished = false;\n        fill(begin(child), end(child), nullptr);\n    }\n};\n\nclass MagicDictionary {\npublic:\n    MagicDictionary() {\n        root = new Trie();\n    }\n    \n    void buildDict(vector<string> dictionary) {\n        for (auto&& word: dictionary) {\n            Trie* cur = root;\n            for (char ch: word) {\n                int idx = ch - 'a';\n                if (!cur->child[idx]) {\n                    cur->child[idx] = new Trie();\n                }\n                cur = cur->child[idx];\n            }\n            cur->is_finished = true;\n        }\n    }\n    \n    bool search(string searchWord) {\n        function<bool(Trie*, int, bool)> dfs = [&](Trie* node, int pos, bool modified) {\n            if (pos == searchWord.size()) {\n                return modified && node->is_finished;\n            }\n            int idx = searchWord[pos] - 'a';\n            if (node->child[idx]) {\n                if (dfs(node->child[idx], pos + 1, modified)) {\n                    return true;\n                }\n            }\n            if (!modified) {\n                for (int i = 0; i < 26; ++i) {\n                    if (i != idx && node->child[i]) {\n                        if (dfs(node->child[i], pos + 1, true)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        };\n\n        return dfs(root, 0, false);\n    }\n\nprivate:\n    Trie* root;\n};\n```\n\n```Java [sol2-Java]\nclass MagicDictionary {\n    Trie root;\n\n    public MagicDictionary() {\n        root = new Trie();\n    }\n\n    public void buildDict(String[] dictionary) {\n        for (String word : dictionary) {\n            Trie cur = root;\n            for (int i = 0; i < word.length(); ++i) {\n                char ch = word.charAt(i);\n                int idx = ch - 'a';\n                if (cur.child[idx] == null) {\n                    cur.child[idx] = new Trie();\n                }\n                cur = cur.child[idx];\n            }\n            cur.isFinished = true;\n        }\n    }\n\n    public boolean search(String searchWord) {\n        return dfs(searchWord, root, 0, false);\n    }\n\n    private boolean dfs(String searchWord, Trie node, int pos, boolean modified) {\n        if (pos == searchWord.length()) {\n            return modified && node.isFinished;\n        }\n        int idx = searchWord.charAt(pos) - 'a';\n        if (node.child[idx] != null) {\n            if (dfs(searchWord, node.child[idx], pos + 1, modified)) {\n                return true;\n            }\n        }\n        if (!modified) {\n            for (int i = 0; i < 26; ++i) {\n                if (i != idx && node.child[i] != null) {\n                    if (dfs(searchWord, node.child[i], pos + 1, true)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n\nclass Trie {\n    boolean isFinished;\n    Trie[] child;\n\n    public Trie() {\n        isFinished = false;\n        child = new Trie[26];\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class MagicDictionary {\n    Trie root;\n\n    public MagicDictionary() {\n        root = new Trie();\n    }\n\n    public void BuildDict(string[] dictionary) {\n        foreach (string word in dictionary) {\n            Trie cur = root;\n            foreach (char ch in word) {\n                int idx = ch - 'a';\n                if (cur.Child[idx] == null) {\n                    cur.Child[idx] = new Trie();\n                }\n                cur = cur.Child[idx];\n            }\n            cur.IsFinished = true;\n        }\n    }\n\n    public bool Search(string searchWord) {\n        return DFS(searchWord, root, 0, false);\n    }\n\n    private bool DFS(string searchWord, Trie node, int pos, bool modified) {\n        if (pos == searchWord.Length) {\n            return modified && node.IsFinished;\n        }\n        int idx = searchWord[pos] - 'a';\n        if (node.Child[idx] != null) {\n            if (DFS(searchWord, node.Child[idx], pos + 1, modified)) {\n                return true;\n            }\n        }\n        if (!modified) {\n            for (int i = 0; i < 26; ++i) {\n                if (i != idx && node.Child[i] != null) {\n                    if (DFS(searchWord, node.Child[i], pos + 1, true)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n\nclass Trie {\n    public bool IsFinished { get; set; }\n    public Trie[] Child { get; set; }\n\n    public Trie() {\n        IsFinished = false;\n        Child = new Trie[26];\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Trie:\n    def __init__(self):\n        self.is_finished = False\n        self.child = dict()\n\n\nclass MagicDictionary:\n\n    def __init__(self):\n        self.root = Trie()\n\n    def buildDict(self, dictionary: List[str]) -> None:\n        for word in dictionary:\n            cur = self.root\n            for ch in word:\n                if ch not in cur.child:\n                    cur.child[ch] = Trie()\n                cur = cur.child[ch]\n            cur.is_finished = True\n\n    def search(self, searchWord: str) -> bool:\n        def dfs(node: Trie, pos: int, modified: bool) -> bool:\n            if pos == len(searchWord):\n                return modified and node.is_finished\n            \n            ch = searchWord[pos]\n            if ch in node.child:\n                if dfs(node.child[ch], pos + 1, modified):\n                    return True\n                \n            if not modified:\n                for cnext in node.child:\n                    if ch != cnext:\n                        if dfs(node.child[cnext], pos + 1, True):\n                            return True\n            \n            return False\n        \n        return dfs(self.root, 0, False)\n```\n\n```C [sol2-C]\ntypedef struct Trie {\n    bool is_finished;\n    struct Trie* child[26];\n} Trie;\n\ntypedef struct {\n    Trie *root;\n} MagicDictionary;\n\nTrie* trieCreate() {\n    Trie *node = (Trie *)malloc(sizeof(Trie));\n    for (int i = 0; i < 26; i++) {\n        node->child[i] = NULL;\n    }\n    node->is_finished = false;\n    return node;\n}\n\nMagicDictionary* magicDictionaryCreate() {\n    MagicDictionary *obj = (MagicDictionary *)malloc(sizeof(MagicDictionary));\n    obj->root = trieCreate();\n    return obj;\n}\n\nvoid magicDictionaryBuildDict(MagicDictionary* obj, char ** dictionary, int dictionarySize) {\n    for (int j = 0; j < dictionarySize; j++) {\n        Trie* cur = obj->root;\n        int len = strlen(dictionary[j]);\n        for (int i = 0; i < len; i++) {\n            int idx = dictionary[j][i] - 'a';\n            if (!cur->child[idx]) {\n                cur->child[idx] = trieCreate();\n            }\n            cur = cur->child[idx];\n        }\n        cur->is_finished = true;\n    }\n}\n\nstatic bool dfs(Trie* node, char *searchWord, int pos, bool modified) {\n    if (pos == strlen(searchWord)) {\n        return modified && node->is_finished;\n    }\n    int idx = searchWord[pos] - 'a';\n    if (node->child[idx]) {\n        if (dfs(node->child[idx], searchWord, pos + 1, modified)) {\n            return true;\n        }\n    }\n    if (!modified) {\n        for (int i = 0; i < 26; ++i) {\n            if (i != idx && node->child[i]) {\n                if (dfs(node->child[i], searchWord, pos + 1, true)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nbool magicDictionarySearch(MagicDictionary* obj, char * searchWord) {\n    return dfs(obj->root, searchWord, 0, false);\n}\n\nstatic void trieFree(Trie *root) {\n    for (int i = 0; i < 26; i++) {\n        if (root->child[i]) {\n            free(root->child[i]);\n        }\n    }\n    free(root);\n}\n\nvoid magicDictionaryFree(MagicDictionary* obj) {\n    trieFree(obj->root);\n    free(obj);\n}\n```\n\n```go [sol2-Golang]\ntype trie struct {\n    children   [26]*trie\n    isFinished bool\n}\n\ntype MagicDictionary struct {\n    *trie\n}\n\nfunc Constructor() MagicDictionary {\n    return MagicDictionary{&trie{}}\n}\n\nfunc (d *MagicDictionary) BuildDict(dictionary []string) {\n    for _, word := range dictionary {\n        cur := d.trie\n        for _, c := range word {\n            c -= 'a'\n            if cur.children[c] == nil {\n                cur.children[c] = &trie{}\n            }\n            cur = cur.children[c]\n        }\n        cur.isFinished = true\n    }\n}\n\nfunc dfs(node *trie, searchWord string, modified bool) bool {\n    if searchWord == \"\" {\n        return modified && node.isFinished\n    }\n    c := searchWord[0] - 'a'\n    if node.children[c] != nil && dfs(node.children[c], searchWord[1:], modified) {\n        return true\n    }\n    if !modified {\n        for i, child := range node.children {\n            if i != int(c) && child != nil && dfs(child, searchWord[1:], true) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nfunc (d *MagicDictionary) Search(searchWord string) bool {\n    return dfs(d.trie, searchWord, false)\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar MagicDictionary = function() {\n    this.root = new Trie();\n};\n\nMagicDictionary.prototype.buildDict = function(dictionary) {\n    for (const word of dictionary) {\n        let cur = this.root;\n        for (let i = 0; i < word.length; ++i) {\n            const ch = word[i];\n            const idx = ch.charCodeAt() - 'a'.charCodeAt();\n            if (!cur.child[idx]) {\n                cur.child[idx] = new Trie();\n            }\n            cur = cur.child[idx];\n        }\n        cur.isFinished = true;\n    }\n};\n\nMagicDictionary.prototype.search = function(searchWord) {\n    return dfs(searchWord, this.root, 0, false);\n};\n\nconst dfs = (searchWord, node, pos, modified) => {\n    if (pos === searchWord.length) {\n        return modified && node.isFinished;\n    }\n    let idx = searchWord[pos].charCodeAt() - 'a'.charCodeAt();\n    if (node.child[idx]) {\n        if (dfs(searchWord, node.child[idx], pos + 1, modified)) {\n            return true;\n        }\n    }\n    if (!modified) {\n        for (let i = 0; i < 26; ++i) {\n            if (i !== idx && node.child[i]) {\n                if (dfs(searchWord, node.child[i], pos + 1, true)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nclass Trie {\n    constructor() {\n        this.isFinished = false;\n        this.child = new Array(26).fill(0);\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(nl+ql|\\Sigma|)$，其中 $n$ 是数组 $\\textit{dictionary}$ 的长度，$l$ 是数组 $\\textit{dictionary}$ 中字符串的平均长度，$q$ 是函数 $\\text{search(searchWord)}$ 的调用次数，$\\Sigma$ 是字符集。初始化需要的时间为 $O(nl)$，每一次查询最多会把与 $\\textit{searchWord}$ 相差一个字符的单词全部遍历一遍，因此时间复杂度为 $O(l|\\Sigma|)$。\n\n- 空间复杂度：$O(nl)$，即为字典树需要使用的空间。"
}