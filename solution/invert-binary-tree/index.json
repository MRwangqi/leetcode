{
	"titleSlug": "invert-binary-tree",
	"slug": "dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua",
	"url": "https://leetcode-cn.com/problems/invert-binary-tree/solution/dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua/",
	"content": "### 递归\r\n我们在做二叉树题目时候，第一想到的应该是用 **递归** 来解决。\r\n仔细看下题目的 **输入** 和 **输出**，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来完成这道题。\r\n看一下动画就明白了：\r\n![226_2.gif](https://pic.leetcode-cn.com/0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif)\r\n\r\n其实就是交换一下左右节点，然后再递归的交换左节点，右节点\r\n根据动画图我们可以总结出递归的两个条件如下：\r\n- 终止条件：当前节点为 `null` 时返回\r\n- 交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点\r\n\r\n时间复杂度：每个元素都必须访问一次，所以是 $O(n)$\r\n空间复杂度：最坏的情况下，需要存放 $O(h)$ 个函数调用(h是树的高度)，所以是 $O(h)$\r\n代码实现如下：\r\n\r\n```Java []\r\nclass Solution {\r\n\tpublic TreeNode invertTree(TreeNode root) {\r\n\t\t//递归函数的终止条件，节点为空时返回\r\n\t\tif(root==null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t//下面三句是将当前节点的左右子树交换\r\n\t\tTreeNode tmp = root.right;\r\n\t\troot.right = root.left;\r\n\t\troot.left = tmp;\r\n\t\t//递归交换当前节点的 左子树\r\n\t\tinvertTree(root.left);\r\n\t\t//递归交换当前节点的 右子树\r\n\t\tinvertTree(root.right);\r\n\t\t//函数返回时就表示当前这个节点，以及它的左右子树\r\n\t\t//都已经交换完了\r\n\t\treturn root;\r\n\t}\r\n}\r\n```\r\n```Python []\r\nclass Solution(object):\r\n\tdef invertTree(self, root):\r\n\t\t\"\"\"\r\n\t\t:type root: TreeNode\r\n\t\t:rtype: TreeNode\r\n\t\t\"\"\"\r\n\t\t# 递归函数的终止条件，节点为空时返回\r\n\t\tif not root:\r\n\t\t\treturn None\r\n\t\t# 将当前节点的左右子树交换\r\n\t\troot.left,root.right = root.right,root.left\r\n\t\t# 递归交换当前节点的 左子树和右子树\r\n\t\tself.invertTree(root.left)\r\n\t\tself.invertTree(root.right)\r\n\t\t# 函数返回时就表示当前这个节点，以及它的左右子树\r\n\t\t# 都已经交换完了\t\t\r\n\t\treturn root\r\n```\r\n\r\n\r\n\r\n### 迭代\r\n递归实现也就是深度优先遍历的方式，那么对应的就是广度优先遍历。\r\n广度优先遍历需要额外的数据结构--队列，来存放临时遍历到的元素。\r\n深度优先遍历的特点是一竿子插到底，不行了再退回来继续；而广度优先遍历的特点是层层扫荡。\r\n所以，我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。   \r\n对当前元素调换其左右子树的位置，然后：\r\n- 判断其左子树是否为空，不为空就放入队列中\r\n- 判断其右子树是否为空，不为空就放入队列中\r\n   \r\n动态图如下：   \r\n![226_迭代.gif](https://pic.leetcode-cn.com/f9e06159617cbf8372b544daee37be70286c3d9b762c016664e225044fc4d479-226_%E8%BF%AD%E4%BB%A3.gif)\r\n\r\n深度优先遍历和广度优先遍历，从动画图中看起来很类似，这是因为演示的树层数只有三层。   \r\n时间复杂度：同样每个节点都需要入队列/出队列一次，所以是 $O(n)$\r\n空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是 `n/2`个，所以时间复杂度是 $0(n)$\r\n代码实现如下：\r\n```Java []\r\nclass Solution {\r\n\tpublic TreeNode invertTree(TreeNode root) {\r\n\t\tif(root==null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t//将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素\r\n\t\tLinkedList<TreeNode> queue = new LinkedList<TreeNode>();\r\n\t\tqueue.add(root);\r\n\t\twhile(!queue.isEmpty()) {\r\n\t\t\t//每次都从队列中拿一个节点，并交换这个节点的左右子树\r\n\t\t\tTreeNode tmp = queue.poll();\r\n\t\t\tTreeNode left = tmp.left;\r\n\t\t\ttmp.left = tmp.right;\r\n\t\t\ttmp.right = left;\r\n\t\t\t//如果当前节点的左子树不为空，则放入队列等待后续处理\r\n\t\t\tif(tmp.left!=null) {\r\n\t\t\t\tqueue.add(tmp.left);\r\n\t\t\t}\r\n\t\t\t//如果当前节点的右子树不为空，则放入队列等待后续处理\r\n\t\t\tif(tmp.right!=null) {\r\n\t\t\t\tqueue.add(tmp.right);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t//返回处理完的根节点\r\n\t\treturn root;\r\n\t}\r\n}\r\n```\r\n```Python []\r\nclass Solution(object):\r\n\tdef invertTree(self, root):\r\n\t\t\"\"\"\r\n\t\t:type root: TreeNode\r\n\t\t:rtype: TreeNode\r\n\t\t\"\"\"\r\n\t\tif not root:\r\n\t\t\treturn None\r\n\t\t# 将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素\r\n\t\tqueue = [root]\r\n\t\twhile queue:\r\n\t\t\t# 每次都从队列中拿一个节点，并交换这个节点的左右子树\r\n\t\t\ttmp = queue.pop(0)\r\n\t\t\ttmp.left,tmp.right = tmp.right,tmp.left\r\n\t\t\t# 如果当前节点的左子树不为空，则放入队列等待后续处理\r\n\t\t\tif tmp.left:\r\n\t\t\t\tqueue.append(tmp.left)\r\n\t\t\t# 如果当前节点的右子树不为空，则放入队列等待后续处理\t\r\n\t\t\tif tmp.right:\r\n\t\t\t\tqueue.append(tmp.right)\r\n\t\t# 返回处理完的根节点\r\n\t\treturn root\r\n```"
}