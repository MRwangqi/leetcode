{
	"titleSlug": "third-maximum-number",
	"slug": "di-san-da-de-shu-by-leetcode-solution-h3sp",
	"url": "https://leetcode-cn.com/problems/third-maximum-number/solution/di-san-da-de-shu-by-leetcode-solution-h3sp/",
	"content": "#### 方法一：排序\n\n将数组从大到小排序后，从头开始遍历数组，通过判断相邻元素是否不同，来统计不同元素的个数。如果能找到三个不同的元素，就返回第三大的元素，否则返回最大的元素。\n\n```Python [sol1-Python3]\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        diff = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                diff += 1\n                if diff == 3:  # 此时 nums[i] 就是第三大的数\n                    return nums[i]\n        return nums[0]\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int thirdMax(vector<int> &nums) {\n        sort(nums.begin(), nums.end(), greater<>());\n        for (int i = 1, diff = 1; i < nums.size(); ++i) {\n            if (nums[i] != nums[i - 1] && ++diff == 3) { // 此时 nums[i] 就是第三大的数\n                return nums[i];\n            }\n        }\n        return nums[0];\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int thirdMax(int[] nums) {\n        Arrays.sort(nums);\n        reverse(nums);\n        for (int i = 1, diff = 1; i < nums.length; ++i) {\n            if (nums[i] != nums[i - 1] && ++diff == 3) { // 此时 nums[i] 就是第三大的数\n                return nums[i];\n            }\n        }\n        return nums[0];\n    }\n\n    public void reverse(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int temp = nums[left];\n            nums[left] = nums[right];\n            nums[right] = temp;\n            left++;\n            right--;\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int ThirdMax(int[] nums) {\n        Array.Sort(nums);\n        Array.Reverse(nums);\n        for (int i = 1, diff = 1; i < nums.Length; ++i) {\n            if (nums[i] != nums[i - 1] && ++diff == 3) { // 此时 nums[i] 就是第三大的数\n                return nums[i];\n            }\n        }\n        return nums[0];\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc thirdMax(nums []int) int {\n    sort.Sort(sort.Reverse(sort.IntSlice(nums)))\n    for i, diff := 1, 1; i < len(nums); i++ {\n        if nums[i] != nums[i-1] {\n            diff++\n            if diff == 3 { // 此时 nums[i] 就是第三大的数\n                return nums[i]\n            }\n        }\n    }\n    return nums[0]\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar thirdMax = function(nums) {\n    nums.sort((a, b) => a - b);\n    nums.reverse();\n    for (let i = 1, diff = 1; i < nums.length; ++i) {\n        if (nums[i] !== nums[i - 1] && ++diff === 3) { // 此时 nums[i] 就是第三大的数\n            return nums[i];\n        }\n    }\n    return nums[0];\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n\\log n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。排序需要 $O(n\\log n)$ 的时间。\n\n- 空间复杂度：$O(\\log n)$。排序需要的栈空间为 $O(\\log n)$。\n\n#### 方法二：有序集合\n\n我们可以遍历数组，同时用一个有序集合来维护数组中前三大的数。具体做法是每遍历一个数，就将其插入有序集合，若有序集合的大小超过 $3$，就删除集合中的最小元素。这样可以保证有序集合的大小至多为 $3$，且遍历结束后，若有序集合的大小为 $3$，其最小值就是数组中第三大的数；若有序集合的大小不足 $3$，那么就返回有序集合中的最大值。\n\n```Python [sol2-Python3]\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        s = SortedList()\n        for num in nums:\n            if num not in s:\n                s.add(num)\n                if len(s) > 3:\n                    s.pop(0)\n        return s[0] if len(s) == 3 else s[-1]\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int thirdMax(vector<int> &nums) {\n        set<int> s;\n        for (int num : nums) {\n            s.insert(num);\n            if (s.size() > 3) {\n                s.erase(s.begin());\n            }\n        }\n        return s.size() == 3 ? *s.begin() : *s.rbegin();\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int thirdMax(int[] nums) {\n        TreeSet<Integer> s = new TreeSet<Integer>();\n        for (int num : nums) {\n            s.add(num);\n            if (s.size() > 3) {\n                s.remove(s.first());\n            }\n        }\n        return s.size() == 3 ? s.first() : s.last();\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int ThirdMax(int[] nums) {\n        SortedSet<int> s = new SortedSet<int>();\n        foreach (int num in nums) {\n            s.Add(num);\n            if (s.Count > 3) {\n                s.Remove(s.Min);\n            }\n        }\n        return s.Count == 3 ? s.Min : s.Max;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc thirdMax(nums []int) int {\n    t := redblacktree.NewWithIntComparator()\n    for _, num := range nums {\n        t.Put(num, nil)\n        if t.Size() > 3 {\n            t.Remove(t.Left().Key)\n        }\n    }\n    if t.Size() == 3 {\n        return t.Left().Key.(int)\n    }\n    return t.Right().Key.(int)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。由于有序集合的大小至多为 $3$，插入和删除的时间复杂度可以视作是 $O(1)$ 的，因此时间复杂度为 $O(n)$。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法三：一次遍历\n\n我们可以遍历数组，并用三个变量 $a$、$b$ 和 $c$ 来维护数组中的最大值、次大值和第三大值，以模拟方法二中的插入和删除操作。为方便编程实现，我们将其均初始化为小于数组最小值的元素，视作「无穷小」，比如 $-2^{63}$ 等。\n\n遍历数组，对于数组中的元素 $\\textit{num}$：\n\n- 若 $\\textit{num}>a$，我们将 $c$ 替换为 $b$，$b$ 替换为 $a$，$a$ 替换为 $\\textit{num}$，这模拟了将 $\\textit{num}$ 插入有序集合，并删除有序集合中的最小值的过程；\n- 若 $a>\\textit{num}>b$，类似地，我们将 $c$ 替换为 $b$，$b$ 替换为 $\\textit{num}$，$a$ 保持不变；\n- 若 $b>\\textit{num}>c$，类似地，我们将 $c$ 替换为 $\\textit{num}$，$a$ 和 $b$ 保持不变；\n- 其余情况不做处理。\n\n遍历结束后，若 $c$ 仍然为 $-2^{63}$，则说明数组中不存在三个或三个以上的不同元素，即第三大的数不存在，返回 $a$，否则返回 $c$。\n\n```Python [sol3-Python3]\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        a, b, c = float('-inf'), float('-inf'), float('-inf')\n        for num in nums:\n            if num > a:\n                a, b, c = num, a, b\n            elif a > num > b:\n                b, c = num, b\n            elif b > num > c:\n                c = num\n        return a if c == float('-inf') else c\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int thirdMax(vector<int> &nums) {\n        long a = LONG_MIN, b = LONG_MIN, c = LONG_MIN;\n        for (long num : nums) {\n            if (num > a) {\n                c = b;\n                b = a;\n                a = num;\n            } else if (a > num && num > b) {\n                c = b;\n                b = num;\n            } else if (b > num && num > c) {\n                c = num;\n            }\n        }\n        return c == LONG_MIN ? a : c;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int thirdMax(int[] nums) {\n        long a = Long.MIN_VALUE, b = Long.MIN_VALUE, c = Long.MIN_VALUE;\n        for (long num : nums) {\n            if (num > a) {\n                c = b;\n                b = a;\n                a = num;\n            } else if (a > num && num > b) {\n                c = b;\n                b = num;\n            } else if (b > num && num > c) {\n                c = num;\n            }\n        }\n        return c == Long.MIN_VALUE ? (int) a : (int) c;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int ThirdMax(int[] nums) {\n        long a = long.MinValue, b = long.MinValue, c = long.MinValue;\n        foreach (long num in nums) {\n            if (num > a) {\n                c = b;\n                b = a;\n                a = num;\n            } else if (a > num && num > b) {\n                c = b;\n                b = num;\n            } else if (b > num && num > c) {\n                c = num;\n            }\n        }\n        return c == long.MinValue ? (int) a : (int) c;\n    }\n}\n```\n\n```go [sol3-Golang]\nfunc thirdMax(nums []int) int {\n    a, b, c := math.MinInt64, math.MinInt64, math.MinInt64\n    for _, num := range nums {\n        if num > a {\n            a, b, c = num, a, b\n        } else if a > num && num > b {\n            b, c = num, b\n        } else if b > num && num > c {\n            c = num\n        }\n    }\n    if c == math.MinInt64 {\n        return a\n    }\n    return c\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar thirdMax = function(nums) {\n    let a = -Number.MAX_VALUE, b = -Number.MAX_VALUE, c = -Number.MAX_VALUE;\n    for (const num of nums) {\n        if (num > a) {\n            c = b;\n            b = a;\n            a = num;\n        } else if (a > num && num > b) {\n            c = b;\n            b = num;\n        } else if (b > num && num > c) {\n            c = num;\n        }\n    }\n    return c === -Number.MAX_VALUE ? a : c;\n};\n```\n\n另一种不依赖元素范围的做法是，将 $a$、$b$ 和 $c$ 初始化为空指针或空对象，视作「无穷小」，并在比较大小前先判断是否为空指针或空对象。遍历结束后，若 $c$ 为空，则说明第三大的数不存在，返回 $a$，否则返回 $c$。\n\n```Python [sol4-Python3]\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        a, b, c = None, None, None\n        for num in nums:\n            if a is None or num > a:\n                a, b, c = num, a, b\n            elif a > num and (b is None or num > b):\n                b, c = num, b\n            elif b is not None and b > num and (c is None or num > c):\n                c = num\n        return a if c is None else c\n```\n\n```C++ [sol4-C++]\nclass Solution {\npublic:\n    int thirdMax(vector<int> &nums) {\n        int *a = nullptr, *b = nullptr, *c = nullptr;\n        for (int &num : nums) {\n            if (a == nullptr || num > *a) {\n                c = b;\n                b = a;\n                a = &num;\n            } else if (*a > num && (b == nullptr || num > *b)) {\n                c = b;\n                b = &num;\n            } else if (b != nullptr && *b > num && (c == nullptr || num > *c)) {\n                c = &num;\n            }\n        }\n        return c == nullptr ? *a : *c;\n    }\n};\n```\n\n```Java [sol4-Java]\nclass Solution {\n    public int thirdMax(int[] nums) {\n        Integer a = null, b = null, c = null;\n        for (int num : nums) {\n            if (a == null || num > a) {\n                c = b;\n                b = a;\n                a = num;\n            } else if (a > num && (b == null || num > b)) {\n                c = b;\n                b = num;\n            } else if (b != null && b > num && (c == null || num > c)) {\n                c = num;\n            }\n        }\n        return c == null ? a : c;\n    }\n}\n```\n\n```C# [sol4-C#]\npublic class Solution {\n    public int ThirdMax(int[] nums) {\n        int? a = null, b = null, c = null;\n        foreach (int num in nums) {\n            if (a == null || num > a) {\n                c = b;\n                b = a;\n                a = num;\n            } else if (a > num && (b == null || num > b)) {\n                c = b;\n                b = num;\n            } else if (b != null && b > num && (c == null || num > c)) {\n                c = num;\n            }\n        }\n        return c == null ? (int) a : (int) c;\n    }\n}\n```\n\n```go [sol4-Golang]\nfunc thirdMax(nums []int) int {\n    var a, b, c *int\n    for _, num := range nums {\n        num := num\n        if a == nil || num > *a {\n            a, b, c = &num, a, b\n        } else if *a > num && (b == nil || num > *b) {\n            b, c = &num, b\n        } else if b != nil && *b > num && (c == nil || num > *c) {\n            c = &num\n        }\n    }\n    if c == nil {\n        return *a\n    }\n    return *c\n}\n```\n\n```JavaScript [sol4-JavaScript]\nvar thirdMax = function(nums) {\n    let a = null, b = null, c = null;\n    for (const num of nums) {\n        if (a === null || num > a) {\n            c = b;\n            b = a;\n            a = num;\n        } else if (a > num && (b === null || num > b)) {\n            c = b;\n            b = num;\n        } else if (b !== null && b > num && (c === null || num > c)) {\n            c = num;\n        }\n    }\n    return c === null ? a : c;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(1)$。"
}