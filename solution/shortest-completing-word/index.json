{
	"titleSlug": "shortest-completing-word",
	"slug": "zui-duan-bu-quan-ci-by-leetcode-solution-35pt",
	"url": "https://leetcode-cn.com/problems/shortest-completing-word/solution/zui-duan-bu-quan-ci-by-leetcode-solution-35pt/",
	"content": "#### 方法一：统计字符出现次数\n\n根据题意，我们先统计 $\\textit{licensePlate}$ 中每个字母的出现次数（忽略大小写），然后遍历 $\\textit{words}$ 中的每个单词，若 $26$ 个字母在该单词中的出现次数均不小于在 $\\textit{licensePlate}$ 中的出现次数，则该单词是一个补全词。返回最短且最靠前的补全词。\n\n```Python [sol1-Python3]\nclass Solution:\n    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:\n        cnt = Counter(ch.lower() for ch in licensePlate if ch.isalpha())\n        return min((word for word in words if not cnt - Counter(word)), key=len)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string shortestCompletingWord(string licensePlate, vector<string> &words) {\n        array<int, 26> cnt{};\n        for (char ch : licensePlate) {\n            if (isalpha(ch)) {\n                ++cnt[tolower(ch) - 'a'];\n            }\n        }\n        int idx = -1;\n        for (int i = 0; i < words.size(); ++i) {\n            array<int, 26> c{};\n            for (char ch : words[i]) {\n                ++c[ch - 'a'];\n            }\n            bool ok = true;\n            for (int j = 0; j < 26; ++j) {\n                if (c[j] < cnt[j]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok && (idx < 0 || words[i].length() < words[idx].length())) {\n                idx = i;\n            }\n        }\n        return words[idx];\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String shortestCompletingWord(String licensePlate, String[] words) {\n        int[] cnt = new int[26];\n        for (int i = 0; i < licensePlate.length(); ++i) {\n            char ch = licensePlate.charAt(i);\n            if (Character.isLetter(ch)) {\n                ++cnt[Character.toLowerCase(ch) - 'a'];\n            }\n        }\n        int idx = -1;\n        for (int i = 0; i < words.length; ++i) {\n            int[] c = new int[26];\n            for (int j = 0; j < words[i].length(); ++j) {\n                char ch = words[i].charAt(j);\n                ++c[ch - 'a'];\n            }\n            boolean ok = true;\n            for (int j = 0; j < 26; ++j) {\n                if (c[j] < cnt[j]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok && (idx < 0 || words[i].length() < words[idx].length())) {\n                idx = i;\n            }\n        }\n        return words[idx];\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string ShortestCompletingWord(string licensePlate, string[] words) {\n        int[] cnt = new int[26];\n        foreach (char ch in licensePlate) {\n            if (char.IsLetter(ch)) {\n                ++cnt[char.ToLower(ch) - 'a'];\n            }\n        }\n        int idx = -1;\n        for (int i = 0; i < words.Length; ++i) {\n            int[] c = new int[26];\n            foreach (char ch in words[i]) {\n                ++c[ch - 'a'];\n            }\n            bool ok = true;\n            for (int j = 0; j < 26; ++j) {\n                if (c[j] < cnt[j]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok && (idx < 0 || words[i].Length < words[idx].Length)) {\n                idx = i;\n            }\n        }\n        return words[idx];\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc shortestCompletingWord(licensePlate string, words []string) (ans string) {\n    cnt := [26]int{}\n    for _, ch := range licensePlate {\n        if unicode.IsLetter(ch) {\n            cnt[unicode.ToLower(ch)-'a']++\n        }\n    }\n\nnext:\n    for _, word := range words {\n        c := [26]int{}\n        for _, ch := range word {\n            c[ch-'a']++\n        }\n        for i := 0; i < 26; i++ {\n            if c[i] < cnt[i] {\n                continue next\n            }\n        }\n        if ans == \"\" || len(word) < len(ans) {\n            ans = word\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar shortestCompletingWord = function(licensePlate, words) {\n    const cnt = new Array(26).fill(0);\n    for (const ch of licensePlate) {\n        if (/^[a-zA-Z]+$/.test(ch)) {\n            ++cnt[ch.toLowerCase().charCodeAt() - 'a'.charCodeAt()];\n        }\n    }\n    let idx = -1;\n    for (let i = 0; i < words.length; ++i) {\n        const c = Array(26).fill(0);\n        for (let j = 0; j < words[i].length; ++j) {\n            const ch = words[i][j];\n            ++c[ch.charCodeAt() - 'a'.charCodeAt()];\n        }\n        let ok = true;\n        for (let j = 0; j < 26; ++j) {\n            if (c[j] < cnt[j]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok && (idx < 0 || words[i].length < words[idx].length)) {\n            idx = i;\n        }\n    }\n    return words[idx];\n};\n```\n\n```C [sol1-C]\nchar * shortestCompletingWord(char * licensePlate, char ** words, int wordsSize){\n    int cnt[26];\n    int n = strlen(licensePlate);\n    memset(cnt, 0 ,sizeof(cnt));\n\n    for(int i = 0; i < n; ++i) {\n        if (isalpha(licensePlate[i])) {\n            ++cnt[tolower(licensePlate[i]) - 'a'];\n        }\n    }\n    int idx = -1;\n    int minLen = INT_MAX;\n    for (int i = 0; i < wordsSize; ++i) {\n        int currLen = strlen(words[i]);\n        int c[26];\n        memset(c, 0, sizeof(c));\n        for (int j = 0; j < currLen; ++j) {\n            ++c[words[i][j] - 'a'];\n        }\n        bool ok = true;\n        for (int j = 0; j < 26; ++j) {\n            if (c[j] < cnt[j]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok && (idx < 0 || currLen < minLen)) {\n            minLen = currLen;\n            idx = i;\n        }\n    }\n    return words[idx];\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(N+L+M\\cdot |\\Sigma|)$，其中 $N$ 是字符串 $\\textit{licensePlate}$ 的长度，$L$ 是 $\\textit{words}$ 中的所有字符串的长度之和，$M$ 是 $\\textit{words}$ 数组的长度，$|\\Sigma|$ 为字符集合的大小，本题中有 $26$ 个英文字母，即 $|\\Sigma|=26$。\n\n- 空间复杂度：$O(|\\Sigma|)$。"
}