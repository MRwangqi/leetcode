{
	"titleSlug": "beautiful-arrangement-ii",
	"slug": "you-mei-de-pai-lie-ii-by-leetcode-soluti-qkrs",
	"url": "https://leetcode-cn.com/problems/beautiful-arrangement-ii/solution/you-mei-de-pai-lie-ii-by-leetcode-soluti-qkrs/",
	"content": "#### 方法一：从特殊情况到一般情况\n\n**思路与算法**\n\n当 $k=1$ 时，我们将 $1 \\sim n$ 按照 $[1, 2, \\cdots, n]$ 的顺序进行排列，那么相邻的差均为 $1$，满足 $k=1$ 的要求。\n\n当 $k=n-1$ 时，我们将 $1 \\sim n$ 按照 $[1, n, 2, n-1, 3, \\cdots]$ 的顺序进行排列，那么相邻的差从 $n-1$ 开始，依次递减 $1$。这样一来，所有从 $1$ 到 $n-1$ 的差值均出现一次，满足 $k=n-1$ 的要求。\n\n对于其它的一般情况，我们可以将这两种特殊情况进行合并，即列表的前半部分相邻差均为 $1$，后半部分相邻差从 $k$ 开始逐渐递减到 $1$，这样从 $1$ 到 $k$ 的差值均出现一次，对应的列表即为：\n\n$$\n[1, 2, \\cdots, n-k, n, n-k+1, n-1, n-k+2, \\cdots]\n$$\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> constructArray(int n, int k) {\n        vector<int> answer;\n        for (int i = 1; i < n - k; ++i) {\n            answer.push_back(i);\n        }\n        for (int i = n - k, j = n; i <= j; ++i, --j) {\n            answer.push_back(i);\n            if (i != j) {\n                answer.push_back(j);\n            }\n        }\n        return answer;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] constructArray(int n, int k) {\n        int[] answer = new int[n];\n        int idx = 0;\n        for (int i = 1; i < n - k; ++i) {\n            answer[idx] = i;\n            ++idx;\n        }\n        for (int i = n - k, j = n; i <= j; ++i, --j) {\n            answer[idx] = i;\n            ++idx;\n            if (i != j) {\n                answer[idx] = j;\n                ++idx;\n            }\n        }\n        return answer;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] ConstructArray(int n, int k) {\n        int[] answer = new int[n];\n        int idx = 0;\n        for (int i = 1; i < n - k; ++i) {\n            answer[idx] = i;\n            ++idx;\n        }\n        for (int i = n - k, j = n; i <= j; ++i, --j) {\n            answer[idx] = i;\n            ++idx;\n            if (i != j) {\n                answer[idx] = j;\n                ++idx;\n            }\n        }\n        return answer;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def constructArray(self, n: int, k: int) -> List[int]:\n        answer = list(range(1, n - k))\n        i, j = n - k, n\n        while i <= j:\n            answer.append(i)\n            if i != j:\n                answer.append(j)\n            i, j = i + 1, j - 1\n        return answer\n```\n\n```C [sol1-C]\nint* constructArray(int n, int k, int* returnSize){\n    int *answer = (int *)malloc(sizeof(int) * n);\n    int pos = 0;\n    for (int i = 1; i < n - k; ++i) {\n        answer[pos++] = i;\n    }\n    for (int i = n - k, j = n; i <= j; ++i, --j) {\n        answer[pos++] = i;\n        if (i != j) {\n            answer[pos++] = j;\n        }\n    }\n    *returnSize = n;\n    return answer;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar constructArray = function(n, k) {\n    const answer = new Array(n).fill(0);\n    let idx = 0;\n    for (let i = 1; i < n - k; ++i) {\n        answer[idx] = i;\n        ++idx;\n    }\n    for (let i = n - k, j = n; i <= j; ++i, --j) {\n        answer[idx] = i;\n        ++idx;\n        if (i !== j) {\n            answer[idx] = j;\n            ++idx;\n        }\n    }\n    return answer;\n};\n```\n\n```go [sol1-Golang]\nfunc constructArray(n, k int) []int {\n    ans := make([]int, 0, n)\n    for i := 1; i < n-k; i++ {\n        ans = append(ans, i)\n    }\n    for i, j := n-k, n; i <= j; i++ {\n        ans = append(ans, i)\n        if i != j {\n            ans = append(ans, j)\n        }\n        j--\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。\n\n- 空间复杂度：$O(1)$，这里不计入返回值需要的空间。"
}