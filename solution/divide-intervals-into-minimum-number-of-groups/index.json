{
	"titleSlug": "divide-intervals-into-minimum-number-of-groups",
	"slug": "by-endlesscheng-ze3t",
	"url": "https://leetcode-cn.com/problems/divide-intervals-into-minimum-number-of-groups/solution/by-endlesscheng-ze3t/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1it4y1L7kL) 已出炉，欢迎点赞三连，在评论区分享你对这场周赛的看法~\r\n\r\n---\r\n \r\n按照 $\\textit{left}$ 排序后，用最小堆模拟，堆顶存储每个组最后一个区间的 $\\textit{right}$。\r\n\r\n遍历区间：\r\n\r\n- 如果当前的 $\\textit{left}$ 大于堆顶，则可以接在这个组的末尾，更新堆顶为 $\\textit{right}$；\r\n- 否则需要创建一个新的组。\r\n\r\n```py [sol1-Python3]\r\nclass Solution:\r\n    def minGroups(self, intervals: List[List[int]]) -> int:\r\n        intervals.sort(key=lambda p: p[0])\r\n        h = []\r\n        for left, right in intervals:\r\n            if h and left > h[0]: heapreplace(h, right)\r\n            else: heappush(h, right)\r\n        return len(h)\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int minGroups(int[][] intervals) {\r\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\r\n        var pq = new PriorityQueue<Integer>();\r\n        for (var p : intervals) {\r\n            if (!pq.isEmpty() && pq.peek() < p[0]) pq.poll();\r\n            pq.offer(p[1]);\r\n        }\r\n        return pq.size();\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int minGroups(vector<vector<int>> &intervals) {\r\n        sort(intervals.begin(), intervals.end(), [](auto &a, auto &b) { return a[0] < b[0]; });\r\n        priority_queue<int, vector<int>, greater<>> pq;\r\n        for (auto &p : intervals) {\r\n            if (!pq.empty() && pq.top() < p[0]) pq.pop();\r\n            pq.push(p[1]);\r\n        }\r\n        return pq.size();\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc minGroups(intervals [][]int) int {\r\n\th := hp{}\r\n\tsort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\r\n\tfor _, p := range intervals {\r\n\t\tif h.Len() == 0 || p[0] <= h.IntSlice[0] {\r\n\t\t\theap.Push(&h, p[1])\r\n\t\t} else {\r\n\t\t\th.IntSlice[0] = p[1]\r\n\t\t\theap.Fix(&h, 0)\r\n\t\t}\r\n\t}\r\n\treturn h.Len()\r\n}\r\n\r\ntype hp struct{ sort.IntSlice }\r\nfunc (h *hp) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) }\r\nfunc (h *hp) Pop() interface{}   { a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v }\r\n```\r\n\r\n另外一种思路是转换成上下车模型，每个区间看成一个人，他在 $\\textit{left}$ 时刻上车，$\\textit{right}+1$ 时刻下车，最后答案为同时在车上的人数的最大值。\r\n\r\n这可以用差分数组实现，下面代码用的平衡树，方便从小到大计算。\r\n\r\n```cpp [sol2-C++]\r\nclass Solution {\r\npublic:\r\n    int minGroups(vector<vector<int>> &intervals) {\r\n        map<int, int> diff;\r\n        for (auto &p : intervals)\r\n            ++diff[p[0]], --diff[p[1] + 1];\r\n        int ans = 0, sum = 0;\r\n        for (auto &[_, d] : diff)\r\n            ans = max(ans, sum += d);\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(n\\log n)$，其中 $n$ 为 $\\textit{nums}$ 的长度。\r\n- 空间复杂度：$O(n)$。\r\n\r\n#### 思考题\r\n\r\n从所有满足 $1\\le\\textit{left}\\le\\textit{right}\\le m$ 的一共 $\\dfrac{m(m+1)}{2}$ 个区间中，随机选择 $n$ 个区间作为本题的输入，得到的答案的期望是多少？"
}