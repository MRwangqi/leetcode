{
	"titleSlug": "sum-of-root-to-leaf-binary-numbers",
	"slug": "cong-gen-dao-xie-de-er-jin-zhi-shu-zhi-h-eqss",
	"url": "https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/solution/cong-gen-dao-xie-de-er-jin-zhi-shu-zhi-h-eqss/",
	"content": "#### 前言\n\n关于二叉树后序遍历的详细说明请参考「[145. 二叉树的后序遍历的官方题解](https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/)」。\n\n#### 方法一：递归\n\n后序遍历的访问顺序为：左子树——右子树——根节点。我们对根节点 $\\textit{root}$ 进行后序遍历：\n\n+ 如果节点是叶子节点，返回它对应的数字 $\\textit{val}$。\n\n+ 如果节点是非叶子节点，返回它的左子树和右子树对应的结果之和。\n\n```Python [sol1-Python3]\nclass Solution:\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\n        def dfs(node: Optional[TreeNode], val: int) -> int:\n            if node is None:\n                return 0\n            val = (val << 1) | node.val\n            if node.left is None and node.right is None:\n                return val\n            return dfs(node.left, val) + dfs(node.right, val)\n        return dfs(root, 0)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int dfs(TreeNode *root, int val) {\n        if (root == nullptr) {\n            return 0;\n        }\n        val = (val << 1) | root->val;\n        if (root->left == nullptr && root->right == nullptr) {\n            return val;\n        }\n        return dfs(root->left, val) + dfs(root->right, val);\n    }\n\n    int sumRootToLeaf(TreeNode* root) {\n        return dfs(root, 0);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int sumRootToLeaf(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int val) {\n        if (root == null) {\n            return 0;\n        }\n        val = (val << 1) | root.val;\n        if (root.left == null && root.right == null) {\n            return val;\n        }\n        return dfs(root.left, val) + dfs(root.right, val);\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int SumRootToLeaf(TreeNode root) {\n        return DFS(root, 0);\n    }\n\n    public int DFS(TreeNode root, int val) {\n        if (root == null) {\n            return 0;\n        }\n        val = (val << 1) | root.val;\n        if (root.left == null && root.right == null) {\n            return val;\n        }\n        return DFS(root.left, val) + DFS(root.right, val);\n    }\n}\n```\n\n```C [sol1-C]\nint dfs(struct TreeNode *root, int val) {\n    if (root == NULL) {\n        return 0;\n    }\n    val = (val << 1) | root->val;\n    if (root->left == NULL && root->right == NULL) {\n        return val;\n    }\n    return dfs(root->left, val) + dfs(root->right, val);\n}\n\nint sumRootToLeaf(struct TreeNode* root){\n    return dfs(root, 0);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar sumRootToLeaf = function(root) {\n    const dfs = (root, val) => {\n        if (!root) {\n            return 0;\n        }\n        val = (val << 1) | root.val;\n        if (!root.left&& !root.right) {\n            return val;\n        }\n        return dfs(root.left, val) + dfs(root.right, val);\n    }\n    return dfs(root, 0);\n};\n```\n\n```go [sol1-Golang]\nfunc dfs(node *TreeNode, val int) int {\n    if node == nil {\n        return 0\n    }\n    val = val<<1 | node.Val\n    if node.Left == nil && node.Right == nil {\n        return val\n    }\n    return dfs(node.Left, val) + dfs(node.Right, val)\n}\n\nfunc sumRootToLeaf(root *TreeNode) int {\n    return dfs(root, 0)\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是节点数目。总共访问 $n$ 个节点。\n\n+ 空间复杂度：$O(n)$。递归栈需要 $O(n)$ 的空间。\n\n#### 方法二：迭代\n\n我们用栈来模拟递归，同时使用一个 $\\textit{prev}$ 指针来记录先前访问的节点。算法步骤如下：\n\n1. 如果节点 $\\textit{root}$ 非空，我们将不断地将它及它的左节点压入栈中。\n\n2. 我们从栈中获取节点：\n\n    + 该节点的右节点为空或者等于 $\\textit{prev}$，说明该节点的左子树及右子树都已经被访问，我们将它出栈。如果该节点是叶子节点，我们将它对应的数字 $\\textit{val}$ 加入结果中。设置 $\\textit{prev}$ 为该节点，设置 $\\textit{root}$ 为空指针。 \n\n    + 该节点的右节点非空且不等于 $\\textit{prev}$，我们令 $\\textit{root}$ 指向该节点的右节点。 \n\n3. 如果 $\\textit{root}$ 为空指针或者栈空，中止算法，否则重复步骤 $1$。\n\n需要注意的是，每次出入栈都需要更新 $\\textit{val}$。\n\n```Python [sol2-Python3]\nclass Solution:\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\n        ans = val = 0\n        st = []\n        pre = None\n        while root or st:\n            while root:\n                val = (val << 1) | root.val\n                st.append(root)\n                root = root.left\n            root = st[-1]\n            if root.right is None or root.right == pre:\n                if root.left is None and root.right is None:\n                    ans += val\n                val >>= 1\n                st.pop()\n                pre = root\n                root = None\n            else:\n                root = root.right\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int sumRootToLeaf(TreeNode* root) {\n        stack<TreeNode *> st;\n        int val = 0, ret = 0;\n        TreeNode *prev = nullptr;\n        while (root != nullptr || !st.empty()) {\n            while (root != nullptr) {\n                val = (val << 1) | root->val;\n                st.push(root);\n                root = root->left;\n            }\n            root = st.top();\n            if (root->right == nullptr || root->right == prev) {\n                if (root->left == nullptr && root->right == nullptr) {\n                    ret += val;\n                }\n                val >>= 1;\n                st.pop();\n                prev = root;\n                root = nullptr;\n            } else {\n                root = root->right;\n            }\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int sumRootToLeaf(TreeNode root) {\n        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();\n        int val = 0, ret = 0;\n        TreeNode prev = null;\n        while (root != null || !stack.isEmpty()) {\n            while (root != null) {\n                val = (val << 1) | root.val;\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.peek();\n            if (root.right == null || root.right == prev) {\n                if (root.left == null && root.right == null) {\n                    ret += val;\n                }\n                val >>= 1;\n                stack.pop();\n                prev = root;\n                root = null;\n            } else {\n                root = root.right;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int SumRootToLeaf(TreeNode root) {\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        int val = 0, ret = 0;\n        TreeNode prev = null;\n        while (root != null || stack.Count > 0) {\n            while (root != null) {\n                val = (val << 1) | root.val;\n                stack.Push(root);\n                root = root.left;\n            }\n            root = stack.Peek();\n            if (root.right == null || root.right == prev) {\n                if (root.left == null && root.right == null) {\n                    ret += val;\n                }\n                val >>= 1;\n                stack.Pop();\n                prev = root;\n                root = null;\n            } else {\n                root = root.right;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n```C [sol2-C]\n#define MAX_NODE_SIZE 1000\n\nint sumRootToLeaf(struct TreeNode* root) {\n    struct TreeNode ** stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * MAX_NODE_SIZE);\n    int top = 0;\n    int val = 0, ret = 0;\n    struct TreeNode *prev = NULL;\n    while (root != NULL || top) {\n        while (root != NULL) {\n            val = (val << 1) | root->val;\n            stack[top++] = root;\n            root = root->left;\n        }\n        root = stack[top - 1];\n        if (root->right == NULL || root->right == prev) {\n            if (root->left == NULL && root->right == NULL) {\n                ret += val;\n            }\n            val >>= 1;\n            top--;\n            prev = root;\n            root = NULL;\n        } else {\n            root = root->right;\n        }\n    }\n    free(stack);\n    return ret;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar sumRootToLeaf = function(root) {\n    const stack = [];\n    let val = 0, ret = 0;\n    let prev = null;\n    while (root || stack.length) {\n        while (root) {\n            val = (val << 1) | root.val;\n            stack.push(root);\n            root = root.left;\n        }\n        root = stack[stack.length - 1];\n        if (!root.right || root.right === prev) {\n            if (!root.left && !root.right) {\n                ret += val;\n            }\n            val >>= 1;\n            stack.pop();\n            prev = root;\n            root = null;\n        } else {\n            root = root.right;\n        }\n    }\n    return ret;\n};\n```\n\n```go [sol2-Golang]\nfunc sumRootToLeaf(root *TreeNode) (ans int) {\n    val, st := 0, []*TreeNode{}\n    var pre *TreeNode\n    for root != nil || len(st) > 0 {\n        for root != nil {\n            val = val<<1 | root.Val\n            st = append(st, root)\n            root = root.Left\n        }\n        root = st[len(st)-1]\n        if root.Right == nil || root.Right == pre {\n            if root.Left == nil && root.Right == nil {\n                ans += val\n            }\n            val >>= 1\n            st = st[:len(st)-1]\n            pre = root\n            root = nil\n        } else {\n            root = root.Right\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是节点数目。总共访问 $n$ 个节点。\n\n+ 空间复杂度：$O(n)$。栈最多压入 $n$ 个节点。"
}