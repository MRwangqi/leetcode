{
	"titleSlug": "lowest-common-ancestor-of-deepest-leaves",
	"slug": "zui-shen-xie-jie-dian-de-zui-jin-gong-go-u2z5",
	"url": "https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/solution/zui-shen-xie-jie-dian-de-zui-jin-gong-go-u2z5/",
	"content": "**思路：**\n- 此题和[865. 具有所有最深节点的最小子树](/problems/smallest-subtree-with-all-the-deepest-nodes/)一样；\n\n**子问题：**\n- 如果左子树深度比右子树深，那么最深的叶子结点肯定在左边，最近公共祖先也肯定在左子树那边；\n- 如果右子树深度比左子树深，那么最深的叶子结点肯定在右边，最近公共祖先也肯定在右子树那边；\n- 如果左右两边深度一样，那么最下面那一层肯定都是叶子节点，所以最近公共祖先就是当前结点；\n\n1. 定义一个深度搜索函数depth，去求结点的深度；\n2. 在lcaDeepestLeaves函数里面判断，如果是左边深还是右边深还是一样深；\n\n### 代码\n\n```cpp\n\nclass Solution {\npublic:\n    //求当前结点的深度\n    int depth(TreeNode* root){\n        if(!root) return 0;\n\n        int left = depth(root->left);\n        int right = depth(root->right);\n\n        return 1+max(left, right);\n\n    }\n    TreeNode* lcaDeepestLeaves(TreeNode* root) {\n        if(!root) return NULL;\n\n        int left = depth(root->left); //左树深度\n        int right = depth(root->right); //右树深度\n\n        if(left == right){ //如果左右两边深度相等，那么当前结点就是最近公共祖先\n            return root;\n        }\n        else if(left>right){ //左边更深，那么就去左边找\n            return lcaDeepestLeaves(root->left);\n        }\n        else{\n            return lcaDeepestLeaves(root->right);\n        }\n    }\n};\n```"
}