{
	"titleSlug": "elimination-game",
	"slug": "xiao-chu-you-xi-by-leetcode-solution-ydpb",
	"url": "https://leetcode-cn.com/problems/elimination-game/solution/xiao-chu-you-xi-by-leetcode-solution-ydpb/",
	"content": "#### 方法一：等差数列模拟\n\n**思路与算法**\n\n依照题意，我们每次都将整数列表进行间隔删除，因此每次删除后剩余的整数列表都是等差数列。假设第 $k$ 次删除后的等差数列的首元素为 $a_1^k$，末尾元素为 $a_n^k$，公差为 $\\textit{step}_k$，元素数目为 $\\textit{cnt}_k$，则第 $k+1$ 次删除后的等差数列满足：\n\n$$\\textit{step}_{k+1}=\\textit{step}_k \\times 2$$\n$$\\textit{cnt}_{k+1}=\\Big\\lfloor \\frac{\\textit{cnt}_k}{2} \\Big\\rfloor$$\n\n初始时 $k=0$，表示尚未删除任何元素。\n\n* 如果 $\\textit{k}$ 是偶数，则从左向右删除。\n\n    * 如果元素数目 $\\textit{cnt}_k$ 为奇数，则两端的元素都会被删除。\n    \n    $$\n    \\begin{aligned}\n    a_1^{k+1}&=a_1^k+\\textit{step}_k \\\\\n    a_n^{k+1}&=a_n^k-\\textit{step}_k\n    \\end{aligned}\n    $$\n    \n    * 如果元素数目 $\\textit{cnt}_k$ 为偶数，则首端元素会被删除，末端元素不会被删除。\n    \n    $$\n    \\begin{aligned}\n    a_1^{k+1}&=a_1^k+\\textit{step}_k \\\\\n    a_n^{k+1}&=a_n^k\n    \\end{aligned}\n    $$\n\n* 如果 $k$ 是奇数，则从右向左删除。\n\n    * 如果元素数目 $\\textit{cnt}_k$ 为奇数，则两端的元素都会被删除。\n    \n    $$\n    \\begin{aligned}\n    a_1^{k+1}&=a_1^k+\\textit{step}_k \\\\\n    a_n^{k+1}&=a_n^k-\\textit{step}_k\n    \\end{aligned}\n    $$\n\n    * 如果元素数目 $\\textit{cnt}_k$ 为偶数，则首端元素不会被删除，末端元素会被删除。\n    \n    $$\n    \\begin{aligned}\n    a_1^{k+1}&=a_1^k \\\\\n    a_n^{k+1}&=a_n^k-\\textit{step}_k\n    \\end{aligned}\n    $$\n\n当等差数列只剩一个元素，即 $\\textit{cnt}_k=1$ 时，返回首元素 $a_1^k$ 即可。\n\n注意到末尾元素 $a_n^k$ 可以使用首元素 $a_1^k$、公差 $\\textit{step}_k$ 和元素数目 $\\textit{cnt}_k$ 表示：\n\n$$a_n^k=a_1^k+\\textit{step}_k \\times (\\textit{cnt}_k-1)$$\n\n因此可以省略末尾元素 $a_n^k$。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int lastRemaining(int n) {\n        int a1 = 1;\n        int k = 0, cnt = n, step = 1;\n        while (cnt > 1) {\n            if (k % 2 == 0) { // 正向\n                a1 = a1 + step;\n            } else { // 反向\n                a1 = (cnt % 2 == 0) ? a1 : a1 + step;\n            }\n            k++;\n            cnt = cnt >> 1;\n            step = step << 1;\n        }\n        return a1;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int lastRemaining(int n) {\n        int a1 = 1;\n        int k = 0, cnt = n, step = 1;\n        while (cnt > 1) {\n            if (k % 2 == 0) { // 正向\n                a1 = a1 + step;\n            } else { // 反向\n                a1 = (cnt % 2 == 0) ? a1 : a1 + step;\n            }\n            k++;\n            cnt = cnt >> 1;\n            step = step << 1;\n        }\n        return a1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int LastRemaining(int n) {\n        int a1 = 1;\n        int k = 0, cnt = n, step = 1;\n        while (cnt > 1) {\n            if (k % 2 == 0) { // 正向\n                a1 = a1 + step;\n            } else { // 反向\n                a1 = (cnt % 2 == 0) ? a1 : a1 + step;\n            }\n            k++;\n            cnt = cnt >> 1;\n            step = step << 1;\n        }\n        return a1;\n    }\n}\n```\n\n```C [sol1-C]\nint lastRemaining(int n) {\n    int a1 = 1;\n    int k = 0, cnt = n, step = 1;\n    while (cnt > 1) {\n        if (k % 2 == 0) { // 正向\n            a1 = a1 + step;\n        } else { // 反向\n            a1 = (cnt % 2 == 0) ? a1 : a1 + step;\n        }\n        k++;\n        cnt = cnt >> 1;\n        step = step << 1;\n    }\n    return a1;\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def lastRemaining(self, n: int) -> int:\n        a1 = 1\n        k, cnt, step = 0, n, 1\n        while cnt > 1:\n            if k % 2 == 0:  # 正向\n                a1 += step\n            else:  # 反向\n                if cnt % 2:\n                    a1 += step\n            k += 1\n            cnt >>= 1\n            step <<= 1\n        return a1\n```\n\n```go [sol1-Golang]\nfunc lastRemaining(n int) int {\n    a1 := 1\n    k, cnt, step := 0, n, 1\n    for cnt > 1 {\n        if k%2 == 0 { // 正向\n            a1 += step\n        } else { // 反向\n            if cnt%2 == 1 {\n                a1 += step\n            }\n        }\n        k++\n        cnt >>= 1\n        step <<= 1\n    }\n    return a1\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar lastRemaining = function(n) {\n    let a1 = 1;\n    let k = 0, cnt = n, step = 1;\n    while (cnt > 1) {\n        if (k % 2 === 0) { // 正向\n            a1 = a1 + step;\n        } else { // 反向\n            a1 = (cnt % 2 === 0) ? a1 : a1 + step;\n        }\n        k++;\n        cnt = cnt >> 1;\n        step = step << 1;\n    }\n    return a1;\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(\\log n)$，其中 $n$ 为初始整数列表的元素数目。每次删除都会将元素数目减半，所以时间复杂度为 $O(\\log n)$。\n\n+ 空间复杂度：$O(1)$。只需要使用常数的额外空间。"
}