{
	"titleSlug": "shortest-common-supersequence",
	"slug": "by-ac_oier-s346",
	"url": "https://leetcode-cn.com/problems/shortest-common-supersequence/solution/by-ac_oier-s346/",
	"content": "## LCS 求具体方案 + 构造\n\n为了方便，我们令 `str1` 为 `s1`，`str2` 为 `s2`，并将两者长度记为 $n$ 和 $m$。\n\n容易想到最终的方案必然是由三部分组成：两字符串的公共子序列（且必然是最长公共子序列）+ 两者特有的字符部分。\n\n基于此，我们可以先使用对两者求 `LCS`，并在求具体方案时遵循：属于最长公共子序列的字符只添加一次，而特有于 `s1` 或 `s2` 的字符则独自添加一次。\n\n求解 `LCS` 部分我们定义 **$f[i][j]$ 代表考虑 $s1$ 的前 $i$ 个字符、考虑 $s2$ 的前 $j$ 的字符，形成的最长公共子序列长度（为了方便，令下标从 $1$ 开始）。**\n\n当有了「状态定义」之后，基本上「转移方程」就是呼之欲出：\n\n* `s1[i]==s2[j]` : $f[i][j]=f[i-1][j-1]+1$。代表**必然使用 $s1[i]$ 与 $s2[j]$ 时** `LCS` 的长度。\n* `s1[i]!=s2[j]` : $f[i][j]=max(f[i-1][j], f[i][j-1])$。代表**必然不使用 $s1[i]$（但可能使用$s2[j]$）时** 和 **必然不使用 $s2[j]$（但可能使用$s1[i]$）时** `LCS` 的长度。\n\n> **不了解 LCS 的同学可以看前置 🧀 : [LCS 模板题](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247492097&idx=1&sn=f51f29d86df809d8a***3a40a1369b3d6)**\n\n当预处理出动规数组 `f` 之后，我们使用「双指针」和「通用 `DP` 求具体方案」的做法进行构造：使用 `i` 变量指向 `s1` 的尾部（即起始有 $i = n$），使用 `j` 变量指向 `s2` 的尾部（即起始有 $j = m$），根据 `i` 和 `j` 当前所在位置以及 $f[i][j]$ 从何值转移而来：\n\n1. 若 `i` 或 `j` 其一走完（`i = 0` 或 `j = 0`），将剩余字符追加到答案中；\n2. 当 $f[i][j] = f[i - 1][j - 1] + 1$ 且 $s1[i] = s2[j]$ 时（可简化为 $s1[i] = s2[j]$ 判断），此时 `i` 指向的字符和 `j` 指向的字符为相同，且为 `LCS` 中的字符，将其追加到具体方案，并让 `i` 和 `j` 同时后移；\n3. 当 $f[i][j] = f[i - 1][j]$，将 `s1[i]` 追加到答案中，令 `i` 后移；\n4. 当 $f[i][j] = f[i][j - 1]$，将 `s2[j]` 追加到答案中，令 `j` 后移。\n\n当条件 `3` 和 `4` 同时满足时，由于只需要输出任一具体方案，我们任取其一即可。\n\n最后，由于我们是从后往前进行构造，在返回时需要再进行一次翻转。\n\n代码：\n```Java []\nclass Solution {\n    public String shortestCommonSupersequence(String str1, String str2) {\n        int n = str1.length(), m = str2.length();\n        str1 = \" \" + str1; str2 = \" \" + str2;\n        char[] s1 = str1.toCharArray(), s2 = str2.toCharArray();\n        int[][] f = new int[n + 10][m + 10];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (s1[i] == s2[j]) f[i][j] = f[i - 1][j - 1] + 1;\n                else f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        int i = n, j = m;\n        while (i > 0 || j > 0) {\n            if (i == 0) sb.append(s2[j--]);\n            else if (j == 0) sb.append(s1[i--]);\n            else {\n                if (s1[i] == s2[j]) {\n                    sb.append(s1[i]);\n                    i--; j--;\n                } else if (f[i][j] == f[i - 1][j]) {\n                    sb.append(s1[i--]);\n                } else {\n                    sb.append(s2[j--]);\n                }\n            }\n        }\n        return sb.reverse().toString();\n    }\n}\n```\n```TypeScript []\nfunction shortestCommonSupersequence(s1: string, s2: string): string {\n    const n = s1.length, m = s2.length\n    s1 = \" \" + s1; s2 = \" \" + s2\n    const f = new Array<Array<number>>()\n    for (let i = 0; i < n + 10; i++) f.push(new Array<number>(m + 10).fill(0))\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= m; j++) {\n            if (s1[i] == s2[j]) f[i][j] = f[i - 1][j - 1] + 1\n            else f[i][j] = Math.max(f[i - 1][j], f[i][j - 1])\n        }\n    }\n    let ans = \"\"\n    let i = n, j = m\n    while (i > 0 || j > 0) {\n        if (i == 0) ans += s2[j--]\n        else if (j == 0) ans += s1[i--]\n        else {\n            if (s1[i] == s2[j]) {\n                ans += s1[i]\n                i--; j--\n            } else if (f[i][j] == f[i - 1][j]) {\n                ans += s1[i--]\n            } else {\n                ans += s2[j--]\n            }\n        }\n    }\n    return ans.split('').reverse().join('')\n};\n```\n```Python []\nclass Solution:\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\n        n, m = len(s1), len(s2)\n        s1 = \" \" + s1\n        s2 = \" \" + s2\n        f = [[0] * (m + 10) for _ in range(n + 10)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                f[i][j] = f[i - 1][j - 1] + 1 if s1[i] == s2[j] else max(f[i - 1][j], f[i][j - 1])\n        ans = \"\"\n        i, j = n, m\n        while i > 0 or j > 0:\n            if i == 0:\n                ans += s2[j]\n                j -= 1\n            elif j == 0:\n                ans += s1[i]\n                i -= 1\n            else:\n                if s1[i] == s2[j]:\n                    ans += s1[i]\n                    i -= 1\n                    j -= 1\n                elif f[i][j] == f[i - 1][j]:\n                    ans += s1[i]\n                    i -= 1\n                else:\n                    ans += s2[j]\n                    j -= 1\n        return ans[::-1]\n```\n* 时间复杂度：`LCS` 复杂度为 $O(n \\times m)$；构造答案复杂度为 $O(n \\times m)$。整体复杂度为 $O(n \\times m)$\n* 空间复杂度：$O(n \\times m)$\n\n---\n\n## 最后\n\n**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ (\"▔□▔)/**\n\n也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。\n\n所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~"
}