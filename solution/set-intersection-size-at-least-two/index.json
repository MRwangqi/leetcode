{
	"titleSlug": "set-intersection-size-at-least-two",
	"slug": "she-zhi-jiao-ji-da-xiao-zhi-shao-wei-2-b-vuiv",
	"url": "https://leetcode-cn.com/problems/set-intersection-size-at-least-two/solution/she-zhi-jiao-ji-da-xiao-zhi-shao-wei-2-b-vuiv/",
	"content": "#### 方法一：贪心\n\n**思路与算法**\n\n首先我们从稍简化的情况开始分析：如果题目条件为设置交集大小为 $1$，为了更好的分析我们将 $\\textit{intervals}$ 按照 $[s,e]$ 序对进行升序排序，其中 $\\textit{intervals}$ 为题目给出的区间集合，$s,e$ 为区间的左右边界。设排序后的 $\\textit{intervals} = \\{[s_1,e_1,],\\dots,[s_n,e_n]\\}$，其中 $n$ 为区间集合的大小，并满足 $\\forall i,j \\in [1,n],i < j$ 有 $s_i \\leq s_j$ 成立。然后对于最后一个区间 $[s_n,e_n]$ 来说一定是要提供一个最后交集集合中的元素，那么我们思考我们选择该区间中哪个元素是最优的——最优的元素应该尽可能的把之前的区间尽可能的覆盖。那么我们选择该区间的开头元素 $s_n$ 一定是最优的，因为对于前面的某一个区间 $[s_i,s_j]$：\n\n- 如果 $s_j < s_n$：那么无论选择最后一个区间中的哪个数字都不会在区间 $[s_i,s_j]$ 中。\n- 否则 $s_j \\geq s_n$：因为 $s_n \\geq s_i$ 所以此时选择 $s_n$ 一定会在区间 $[s_i,s_j]$ 中。\n\n即对于最后一个区间 $[s_n，e_n]$ 来说选择区间的开头元素 $s_n$ 一定是最优的。那么贪心的思路就出来了：排序后从后往前进行遍历，每次选取与当前交集集合相交为空的区间的最左边的元素即可，然后往前判断前面是否有区间能因此产生交集，产生交集的直接跳过即可。此时算法的时间复杂度为：$O(n \\log n)$ 主要为排序的时间复杂度。对于这种情况具体也可以见本站题目 [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)。\n\n那么我们用同样的思路来扩展到需要交集为 $m~,~m > 1$ 的情况：此时同样首先对 $\\textit{intervals}$ 按照 $[s,e]$ 序对进行升序排序，然后我们需要额外记录每一个区间与最后交集集合中相交的元素（只记录到 $m$ 个为止）。同样我们从最后一个区间往前进行处理，如果该区间与交集集合相交元素个数小于 $m$ 个时，我们从该区间左边界开始往后添加不在交集集合中的元素，并往前进行更新需要更新的区间，重复该过程直至该区间与交集元素集合有 $m$ 个元素相交。到此就可以解决问题了，不过我们也可以来修改排序的规则——我们将区间 $[s,e]$ 序对按照 $s$ 升序，当 $s$ 相同时按照 $e$ 降序来进行排序，这样可以实现在处理与交集集合相交元素个数小于 $m$ 个的区间 $[s_i,e_i]$ 时，保证不足的元素都是在区间的开始部分，即我们可以直接从区间开始部分进行往交集集合中添加元素。\n\n而对于本题来说，我们只需要取 $m = 2$ 的情况即可。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        ans, n, m = 0, len(intervals), 2\n        vals = [[] for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            j = intervals[i][0]\n            for k in range(len(vals[i]), m):\n                ans += 1\n                for p in range(i - 1, -1, -1):\n                    if intervals[p][1] < j:\n                        break\n                    vals[p].append(j)\n                j += 1\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    void help(vector<vector<int>>& intervals, vector<vector<int>>& temp, int pos, int num) {\n        for (int i = pos; i >= 0; i--) {\n            if (intervals[i][1] < num) {\n                break;\n            }\n            temp[i].push_back(num);\n        }\n    }\n\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        int res = 0;\n        int m = 2;\n        sort(intervals.begin(), intervals.end(), [&](vector<int>& a, vector<int>& b) {\n            if (a[0] == b[0]) {\n                return a[1] > b[1];\n            }\n            return a[0] < b[0];\n        });\n        vector<vector<int>> temp(n);\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = intervals[i][0], k = temp[i].size(); k < m; j++, k++) {\n                res++;\n                help(intervals, temp, i - 1, j);\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int intersectionSizeTwo(int[][] intervals) {\n        int n = intervals.length;\n        int res = 0;\n        int m = 2;\n        Arrays.sort(intervals, (a, b) -> {\n            if (a[0] == b[0]) {\n                return b[1] - a[1];\n            }\n            return a[0] - b[0];\n        });\n        List<Integer>[] temp = new List[n];\n        for (int i = 0; i < n; i++) {\n            temp[i] = new ArrayList<Integer>();\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = intervals[i][0], k = temp[i].size(); k < m; j++, k++) {\n                res++;\n                help(intervals, temp, i - 1, j);\n            }\n        }\n        return res;\n    }\n\n    public void help(int[][] intervals, List<Integer>[] temp, int pos, int num) {\n        for (int i = pos; i >= 0; i--) {\n            if (intervals[i][1] < num) {\n                break;\n            }\n            temp[i].add(num);\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int IntersectionSizeTwo(int[][] intervals) {\n        int n = intervals.Length;\n        int res = 0;\n        int m = 2;\n        Array.Sort(intervals, (a, b) => {\n            if (a[0] == b[0]) {\n                return b[1] - a[1];\n            }\n            return a[0] - b[0];\n        });\n        IList<int>[] temp = new IList<int>[n];\n        for (int i = 0; i < n; i++) {\n            temp[i] = new List<int>();\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = intervals[i][0], k = temp[i].Count; k < m; j++, k++) {\n                res++;\n                Help(intervals, temp, i - 1, j);\n            }\n        }\n        return res;\n    }\n\n    public void Help(int[][] intervals, IList<int>[] temp, int pos, int num) {\n        for (int i = pos; i >= 0; i--) {\n            if (intervals[i][1] < num) {\n                break;\n            }\n            temp[i].Add(num);\n        }\n    }\n}\n```\n\n```C [sol1-C]\nstatic void help(int** intervals, int** temp, int *colSize, int pos, int num) {\n    for (int i = pos; i >= 0; i --) {\n        if (intervals[i][1] < num) {\n            break;\n        }\n        temp[i][colSize[i]++] = num;\n    }\n}\n\nstatic inline int cmp(const void* pa, const void* pb) {\n    if ((*(int **)pa)[0] == (*(int **)pb)[0]) {\n        return (*(int **)pb)[1] - (*(int **)pa)[1];\n    }\n    return (*(int **)pa)[0] - (*(int **)pb)[0];\n}\n\nint intersectionSizeTwo(int** intervals, int intervalsSize, int* intervalsColSize){\n    int res = 0;\n    int m = 2;\n    qsort(intervals, intervalsSize, sizeof(int *), cmp);\n    int **temp = (int **)malloc(sizeof(int *) * intervalsSize);\n    for (int i = 0; i < intervalsSize; i++) {\n        temp[i] = (int *)malloc(sizeof(int) * 2);\n    }\n    int *colSize = (int *)malloc(sizeof(int) * intervalsSize);\n    memset(colSize, 0, sizeof(int) * intervalsSize);\n    for (int i = intervalsSize - 1; i >= 0; i --) {\n        for (int j = intervals[i][0], k = colSize[i]; k < m; j++, k++) {\n            res++;\n            help(intervals, temp, colSize, i - 1, j);\n        }\n    }\n    for (int i = 0; i < intervalsSize; i++) {\n        free(temp[i]);\n    }\n    free(colSize);\n    return res;\n}\n```\n\n```go [sol1-Golang]\nfunc intersectionSizeTwo(intervals [][]int) (ans int) {\n    sort.Slice(intervals, func(i, j int) bool {\n        a, b := intervals[i], intervals[j]\n        return a[0] < b[0] || a[0] == b[0] && a[1] > b[1]\n    })\n    n, m := len(intervals), 2\n    vals := make([][]int, n)\n    for i := n - 1; i >= 0; i-- {\n        for j, k := intervals[i][0], len(vals[i]); k < m; k++ {\n            ans++\n            for p := i - 1; p >= 0 && intervals[p][1] >= j; p-- {\n                vals[p] = append(vals[p], j)\n            }\n            j++\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar intersectionSizeTwo = function(intervals) {\n    const n = intervals.length;\n    let res = 0;\n    let m = 2;\n    intervals.sort((a, b) => {\n        if (a[0] === b[0]) {\n            return b[1] - a[1];\n        }\n        return a[0] - b[0];\n    });\n    const temp = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        temp[i] = [];\n    }\n\n    const help = (intervals, temp, pos, num) => {\n        for (let i = pos; i >= 0; i--) {\n            if (intervals[i][1] < num) {\n                break;\n            }\n            temp[i].push(num);\n        }\n    }\n\n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = intervals[i][0], k = temp[i].length; k < m; j++, k++) {\n            res++;\n            help(intervals, temp, i - 1, j);\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n + nm)$，其中 $n$ 为给定区间集合 $\\textit{intervals}$ 的大小，$m$ 为设置交集大小，本题为 $2$。\n\n- 空间复杂度：$O(nm)$，其中 $n$ 为给定区间集合 $\\textit{intervals}$ 的大小，$m$ 为设置交集的大小，本题为 $2$。主要开销为存储每一个区间与交集集合的相交的元素的开销。"
}