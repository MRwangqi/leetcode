{
	"titleSlug": "maximum-length-of-pair-chain",
	"slug": "zui-chang-shu-dui-lian-by-leetcode-solut-ifpn",
	"url": "https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/zui-chang-shu-dui-lian-by-leetcode-solut-ifpn/",
	"content": "#### 前言\n\n这题和「[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)」类似，区别就是：\n 1. 此题中，数对链中相邻的数对，前者的第二个数字必须小于后者的第一个数字。而在「[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)」中，相邻的区间，前者的结束时间需小于等于后者的开始时间。\n 2. 此题返回最长数对链的长度，而 「[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)」返回形成无重叠区间，最少需要删除多少区间（即原长度减去最长数对链的长度）。\n\n此题解也按照「[435. 无重叠区间的官方题解](https://leetcode.cn/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/)」进行编写。\n\n#### 方法一：动态规划\n\n**思路**\n\n定义 $\\textit{dp}[i]$ 为以 $\\textit{pairs}[i]$ 为结尾的最长数对链的长度。计算 $\\textit{dp}[i]$ 时，可以先找出所有的满足 $\\textit{pairs}[i][0] > \\textit{pairs}[j][1]$ 的 $j$，并求出最大的 $\\textit{dp}[j]$，$\\textit{dp}[i]$ 的值即可赋为这个最大值加一。这种动态规划的思路要求计算 $\\textit{dp}[i]$ 时，所有潜在的 $\\textit{dp}[j]$ 已经计算完成，可以先将 $\\textit{pairs}$ 进行排序来满足这一要求。初始化时，$\\textit{dp}$ 需要全部赋值为 $1$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort()\n        dp = [1] * len(pairs)\n        for i in range(len(pairs)):\n            for j in range(i):\n                if pairs[i][0] > pairs[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return dp[-1]\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& pairs) {\n        int n = pairs.size();\n        sort(pairs.begin(), pairs.end());\n        vector<int> dp(n, 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (pairs[i][0] > pairs[j][1]) {\n                    dp[i] = max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        return dp[n - 1];\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findLongestChain(int[][] pairs) {\n        int n = pairs.length;\n        Arrays.sort(pairs, (a, b) -> a[0] - b[0]);\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (pairs[i][0] > pairs[j][1]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        return dp[n - 1];\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindLongestChain(int[][] pairs) {\n        int n = pairs.Length;\n        Array.Sort(pairs, (a, b) => a[0] - b[0]);\n        int[] dp = new int[n];\n        Array.Fill(dp, 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (pairs[i][0] > pairs[j][1]) {\n                    dp[i] = Math.Max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        return dp[n - 1];\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nstatic inline int cmp(const void *pa, const void *pb) {\n    if ((*(int **)pa)[0] == (*(int **)pb)[0]) {\n        return (*(int **)pa)[1] == (*(int **)pb)[1];\n    } \n    return (*(int **)pa)[0] - (*(int **)pb)[0];\n}\n\nint findLongestChain(int** pairs, int pairsSize, int* pairsColSize){\n    qsort(pairs, pairsSize, sizeof(int *), cmp);\n    int *dp = (int *)malloc(sizeof(int) * pairsSize);\n    for (int i = 0; i < pairsSize; i++) {\n        dp[i] = 1;\n    }\n    for (int i = 0; i < pairsSize; i++) {\n        for (int j = 0; j < i; j++) {\n            if (pairs[i][0] > pairs[j][1]) {\n                dp[i] = MAX(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    int ret = dp[pairsSize - 1];\n    free(dp);\n    return ret;\n}\n```\n\n```go [sol1-Golang]\nfunc findLongestChain(pairs [][]int) int {\n    sort.Slice(pairs, func(i, j int) bool { return pairs[i][0] < pairs[j][0] })\n    n := len(pairs)\n    dp := make([]int, n)\n    for i, p := range pairs {\n        dp[i] = 1\n        for j, q := range pairs[:i] {\n            if p[0] > q[1] {\n                dp[i] = max(dp[i], dp[j]+1)\n            }\n        }\n    }\n    return dp[n-1]\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findLongestChain = function(pairs) {\n    const n = pairs.length;\n    pairs.sort((a, b) => a[0] - b[0]);\n    const dp = new Array(n).fill(1);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            if (pairs[i][0] > pairs[j][1]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    return dp[n - 1];\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 为 $\\textit{pairs}$ 的长度。排序的时间复杂度为 $O(n \\log n)$，两层 $\\texttt{for}$ 循环的时间复杂度为 $O(n^2)$。\n\n- 空间复杂度：$O(n)$，数组 $\\textit{dp}$ 的空间复杂度为 $O(n)$。\n\n#### 方法二：最长递增子序列\n\n**思路**\n\n方法一实际上是「[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)」的动态规划解法，这个解法可以改造为贪心 + 二分查找的形式。用一个数组 $\\textit{arr}$ 来记录当前最优情况，$\\textit{arr}[i]$ 就表示长度为 $i+1$ 的数对链的末尾可以取得的最小值，遇到一个新数对时，先用二分查找得到这个数对可以放置的位置，再更新 $\\textit{arr}$。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort()\n        arr = []\n        for x, y in pairs:\n            i = bisect_left(arr, x)\n            if i < len(arr):\n                arr[i] = min(arr[i], y)\n            else:\n                arr.append(y)\n        return len(arr)\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& pairs) {\n        sort(pairs.begin(), pairs.end());\n        vector<int> arr;\n        for (auto p : pairs) {\n            int x = p[0], y = p[1];\n            if (arr.size() == 0 || x > arr.back()) {\n                arr.emplace_back(y);\n            } else {\n                int idx = lower_bound(arr.begin(), arr.end(), x) - arr.begin();\n                arr[idx] = min(arr[idx], y);\n            }\n        }\n        return arr.size();\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int findLongestChain(int[][] pairs) {\n        Arrays.sort(pairs, (a, b) -> a[0] - b[0]);\n        List<Integer> arr = new ArrayList<Integer>();\n        for (int[] p : pairs) {\n            int x = p[0], y = p[1];\n            if (arr.isEmpty() || x > arr.get(arr.size() - 1)) {\n                arr.add(y);\n            } else {\n                int idx = binarySearch(arr, x);\n                arr.set(idx, Math.min(arr.get(idx), y));\n            }\n        }\n        return arr.size();\n    }\n\n    public int binarySearch(List<Integer> arr, int x) {\n        int low = 0, high = arr.size() - 1;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (arr.get(mid) >= x) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int FindLongestChain(int[][] pairs) {\n        Array.Sort(pairs, (a, b) => a[0] - b[0]);\n        IList<int> arr = new List<int>();\n        foreach (int[] p in pairs) {\n            int x = p[0], y = p[1];\n            if (arr.Count == 0 || x > arr[arr.Count - 1]) {\n                arr.Add(y);\n            } else {\n                int idx = BinarySearch(arr, x);\n                arr[idx] = Math.Min(arr[idx], y);\n            }\n        }\n        return arr.Count;\n    }\n\n    public int BinarySearch(IList<int> arr, int x) {\n        int low = 0, high = arr.Count - 1;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (arr[mid] >= x) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n}\n```\n\n```C [sol2-C]\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nstatic inline int cmp(const void *pa, const void *pb) {\n    if ((*(int **)pa)[0] == (*(int **)pb)[0]) {\n        return (*(int **)pa)[1] == (*(int **)pb)[1];\n    } \n    return (*(int **)pa)[0] - (*(int **)pb)[0];\n}\n\nint lowerbound(const int *arr, int left, int right, int val) {\n    int ret = -1;\n    while (left <= right) {\n        int mid = (left + right) >> 1;\n        if (arr[mid] >= val) {\n            ret = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return ret;\n}\n\nint findLongestChain(int** pairs, int pairsSize, int* pairsColSize){\n    qsort(pairs, pairsSize, sizeof(int *), cmp);\n    int *arr = (int *)malloc(sizeof(int) * pairsSize);\n    int pos = 0;\n    for (int i = 0; i < pairsSize; i++) {\n        int x = pairs[i][0], y = pairs[i][1];\n        if (pos == 0 || x > arr[pos - 1]) {\n            arr[pos++] = y;\n        } else {\n            int idx = lowerbound(arr, 0, pos - 1, x);\n            arr[idx] = MIN(arr[idx], y);\n        }\n    }\n    free(arr);\n    return pos;\n}\n```\n\n```go [sol2-Golang]\nfunc findLongestChain(pairs [][]int) int {\n    sort.Slice(pairs, func(i, j int) bool { return pairs[i][0] < pairs[j][0] })\n    arr := []int{}\n    for _, p := range pairs {\n        i := sort.SearchInts(arr, p[0])\n        if i < len(arr) {\n            arr[i] = min(arr[i], p[1])\n        } else {\n            arr = append(arr, p[1])\n        }\n    }\n    return len(arr)\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar findLongestChain = function(pairs) {\n    pairs.sort((a, b) => a[0] - b[0]);\n    const arr = [];\n    for (const p of pairs) {\n        let x = p[0], y = p[1];\n        if (arr.length === 0 || x > arr[arr.length - 1]) {\n            arr.push(y);\n        } else {\n            const idx = binarySearch(arr, x);\n            arr[idx] =  Math.min(arr[idx], y);\n        }\n    }\n    return arr.length;\n}\n\nconst binarySearch = (arr, x) => {\n    let low = 0, high = arr.length - 1;\n    while (low < high) {\n        const mid = low + Math.floor((high - low) / 2);\n        if (arr[mid] >= x) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return low;\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 为 $\\textit{pairs}$ 的长度。排序的时间复杂度为 $O(n \\log n)$，二分查找的时间复杂度为 $O(n \\log n)$，二分的次数为 $O(n)$。\n\n- 空间复杂度：$O(n)$，数组 $\\textit{arr}$ 的长度最多为 $O(n)$。\n\n#### 方法三：贪心\n\n**思路**\n\n要挑选最长数对链的第一个数对时，最优的选择是挑选第二个数字最小的，这样能给挑选后续的数对留下更多的空间。挑完第一个数对后，要挑第二个数对时，也是按照相同的思路，是在剩下的数对中，第一个数字满足题意的条件下，挑选第二个数字最小的。按照这样的思路，可以先将输入按照第二个数字排序，然后不停地判断第一个数字是否能满足大于前一个数对的第二个数字即可。\n\n**代码**\n\n```Python [sol3-Python3]\nclass Solution(object):\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        cur, res = -inf, 0\n        for x, y in sorted(pairs, key=lambda p: p[1]):\n            if cur < x:\n                cur = y\n                res += 1\n        return res\n```\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& pairs) {\n        int curr = INT_MIN, res = 0;\n        sort(pairs.begin(), pairs.end(), [](const vector<int> &a, const vector<int> &b) {\n            return a[1] < b[1];\n        });\n        for (auto &p : pairs) {\n            if (curr < p[0]) {\n                curr = p[1];\n                res++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int findLongestChain(int[][] pairs) {\n        int curr = Integer.MIN_VALUE, res = 0;\n        Arrays.sort(pairs, (a, b) -> a[1] - b[1]);\n        for (int[] p : pairs) {\n            if (curr < p[0]) {\n                curr = p[1];\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int FindLongestChain(int[][] pairs) {\n        int curr = int.MinValue, res = 0;\n        Array.Sort(pairs, (a, b) => a[1] - b[1]);\n        foreach (int[] p in pairs) {\n            if (curr < p[0]) {\n                curr = p[1];\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol3-C]\nstatic inline int cmp(const void *pa, const void *pb) {\n    return (*(int **)pa)[1] - (*(int **)pb)[1];\n}\n\nint findLongestChain(int** pairs, int pairsSize, int* pairsColSize){\n    int curr = INT_MIN, res = 0;\n    qsort(pairs, pairsSize, sizeof(int *), cmp);\n    for (int i = 0; i < pairsSize; i++) {\n        if (curr < pairs[i][0]) {\n            curr = pairs[i][1];\n            res += 1;\n        }\n    }\n    return res;\n}\n```\n\n```go [sol3-Golang]\nfunc findLongestChain(pairs [][]int) (ans int) {\n    sort.Slice(pairs, func(i, j int) bool { return pairs[i][1] < pairs[j][1] })\n    cur := math.MinInt32\n    for _, p := range pairs {\n        if cur < p[0] {\n            cur = p[1]\n            ans++\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar findLongestChain = function(pairs) {\n    let curr = -Number.MAX_VALUE, res = 0;\n    pairs.sort((a, b) => a[1] - b[1]);\n    for (const p of pairs) {\n        if (curr < p[0]) {\n            curr = p[1];\n            res++;\n        }\n    }\n    return res;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 为 $\\textit{pairs}$ 的长度。排序的时间复杂度为 $O(n \\log n)$。\n\n- 空间复杂度：$O(\\log n)$，为排序的空间复杂度。"
}