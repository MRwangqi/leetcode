{
	"titleSlug": "jump-game-iv",
	"slug": "tiao-yue-you-xi-iv-by-leetcode-solution-zsix",
	"url": "https://leetcode-cn.com/problems/jump-game-iv/solution/tiao-yue-you-xi-iv-by-leetcode-solution-zsix/",
	"content": "#### 方法一：广度优先搜索\n\n**思路**\n\n记数组 $\\textit{arr}$ 的长度为 $n$。题目描述的数组可以抽象为一个无向图，数组元素为图的顶点，相邻下标的元素之间有一条无向边相连，所有值相同元素之间也有无向边相连。每条边的权重都为 $1$，即此图为无权图。求从第一个元素到最后一个元素的最少操作数，即求从第一个元素到最后一个元素的最短路径长度。求无权图两点间的最短路可以用广度优先搜索来解，时间复杂度为 $O(V+E)$，其中 $V$ 为图的顶点数，$E$ 为图的边数。\n\n在此题中，$V = n$，而 $E$ 可达 $O(n^2)$ 数量级，按照常规方法使用广度优先搜索会超时。造成超时的主要原因是所有值相同的元素构成了一个稠密子图，普通的广度优先搜索方法会对这个稠密子图中的所有边都访问一次。但对于无权图的最短路问题，这样的访问是不必要的。在第一次访问到这个子图中的某个节点时，即会将这个子图的所有其他未在队列中的节点都放入队列。在第二次访问到这个子图中的节点时，就不需要去考虑这个子图中的其他节点了，因为所有其他节点都已经在队列中或者已经被访问过了。因此，在用广度优先搜索解决此题时，先需要找出所有的值相同的子图，用一个哈希表 $\\textit{idxSameValue}$ 保存。在第一次把这个子图的所有节点放入队列后，把该子图清空，就不会重复访问该子图的其他边了。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        idxSameValue = defaultdict(list)\n        for i, a in enumerate(arr):\n            idxSameValue[a].append(i)\n        visitedIndex = set()\n        q = deque()\n        q.append([0, 0])\n        visitedIndex.add(0)\n        while q:\n            idx, step = q.popleft()\n            if idx == len(arr) - 1:\n                return step\n            v = arr[idx]\n            step += 1\n            for i in idxSameValue[v]:\n                if i not in visitedIndex:\n                    visitedIndex.add(i)\n                    q.append([i, step])\n            del idxSameValue[v]\n            if idx + 1 < len(arr) and (idx + 1) not in visitedIndex:\n                visitedIndex.add(idx + 1)\n                q.append([idx+1, step])\n            if idx - 1 >= 0 and (idx - 1) not in visitedIndex:\n                visitedIndex.add(idx - 1)\n                q.append([idx-1, step])\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer, List<Integer>> idxSameValue = new HashMap<Integer, List<Integer>>();\n        for (int i = 0; i < arr.length; i++) {\n            idxSameValue.putIfAbsent(arr[i], new ArrayList<Integer>());\n            idxSameValue.get(arr[i]).add(i);\n        }\n        Set<Integer> visitedIndex = new HashSet<Integer>();\n        Queue<int[]> queue = new ArrayDeque<int[]>();\n        queue.offer(new int[]{0, 0});\n        visitedIndex.add(0);\n        while (!queue.isEmpty()) {\n            int[] idxStep = queue.poll();\n            int idx = idxStep[0], step = idxStep[1];\n            if (idx == arr.length - 1) {\n                return step;\n            }\n            int v = arr[idx];\n            step++;\n            if (idxSameValue.containsKey(v)) {\n                for (int i : idxSameValue.get(v)) {\n                    if (visitedIndex.add(i)) {\n                        queue.offer(new int[]{i, step});\n                    }\n                }\n                idxSameValue.remove(v);\n            }\n            if (idx + 1 < arr.length && visitedIndex.add(idx + 1)) {\n                queue.offer(new int[]{idx + 1, step});\n            }\n            if (idx - 1 >= 0 && visitedIndex.add(idx - 1)) {\n                queue.offer(new int[]{idx - 1, step});\n            }\n        }\n        return -1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MinJumps(int[] arr) {\n        Dictionary<int, IList<int>> idxSameValue = new Dictionary<int, IList<int>>();\n        for (int i = 0; i < arr.Length; i++) {\n            if (!idxSameValue.ContainsKey(arr[i])) {\n                idxSameValue.Add(arr[i], new List<int>());\n            }\n            idxSameValue[arr[i]].Add(i);\n        }\n        ISet<int> visitedIndex = new HashSet<int>();\n        Queue<int[]> queue = new Queue<int[]>();\n        queue.Enqueue(new int[]{0, 0});\n        visitedIndex.Add(0);\n        while (queue.Count > 0) {\n            int[] idxStep = queue.Dequeue();\n            int idx = idxStep[0], step = idxStep[1];\n            if (idx == arr.Length - 1) {\n                return step;\n            }\n            int v = arr[idx];\n            step++;\n            if (idxSameValue.ContainsKey(v)) {\n                foreach (int i in idxSameValue[v]) {\n                    if (visitedIndex.Add(i)) {\n                        queue.Enqueue(new int[]{i, step});\n                    }\n                }\n                idxSameValue.Remove(v);\n            }\n            if (idx + 1 < arr.Length && visitedIndex.Add(idx + 1)) {\n                queue.Enqueue(new int[]{idx + 1, step});\n            }\n            if (idx - 1 >= 0 && visitedIndex.Add(idx - 1)) {\n                queue.Enqueue(new int[]{idx - 1, step});\n            }\n        }\n        return 0;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minJumps(vector<int>& arr) {\n        unordered_map<int, vector<int>> idxSameValue;\n        for (int i = 0; i < arr.size(); i++) {\n            idxSameValue[arr[i]].push_back(i);\n        }\n        unordered_set<int> visitedIndex;\n        queue<pair<int, int>> q;\n        q.emplace(0, 0);\n        visitedIndex.emplace(0);\n        while (!q.empty()) {\n            auto [idx, step] = q.front();\n            q.pop();\n            if (idx == arr.size() - 1) {\n                return step;\n            }\n            int v = arr[idx];\n            step++;\n            if (idxSameValue.count(v)) {\n                for (auto & i : idxSameValue[v]) {\n                    if (!visitedIndex.count(i)) {\n                        visitedIndex.emplace(i);\n                        q.emplace(i, step);\n                    }\n                }\n                idxSameValue.erase(v);\n            }\n            if (idx + 1 < arr.size() && !visitedIndex.count(idx + 1)) {\n                visitedIndex.emplace(idx + 1);\n                q.emplace(idx + 1, step);\n            }\n            if (idx - 1 >= 0 && !visitedIndex.count(idx - 1)) {\n                visitedIndex.emplace(idx - 1);\n                q.emplace(idx - 1, step);\n            }\n        }\n        return -1;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct IdxHashEntry {\n    int key;               \n    struct ListNode * head;\n    UT_hash_handle hh;         \n}IdxHashEntry;\n\ntypedef struct SetHashEntry {\n    int key; \n    UT_hash_handle hh;         \n}SetHashEntry;\n\ntypedef struct Pair {\n    int idx;\n    int step;\n}Pair;\n\nvoid hashAddIdxItem(struct IdxHashEntry **obj, int key, int val) {\n    struct IdxHashEntry *pEntry = NULL;\n    struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode));\n    node->val = val;\n    node->next = NULL;\n\n    HASH_FIND(hh, *obj, &key, sizeof(key), pEntry);\n    if (NULL == pEntry) {\n        pEntry = (struct IdxHashEntry *)malloc(sizeof(struct IdxHashEntry));\n        pEntry->key = key;\n        pEntry->head = node;\n        HASH_ADD(hh, *obj, key, sizeof(int), pEntry);\n    } else {\n        node->next = pEntry->head;\n        pEntry->head = node;\n    }\n} \n\nstruct IdxHashEntry *hashFindIdxItem(struct IdxHashEntry **obj, int key)\n{\n    struct IdxHashEntry *pEntry = NULL;\n    HASH_FIND(hh, *obj, &key, sizeof(int), pEntry);\n    return pEntry;\n}\n\nvoid hashFreeIdxAll(struct IdxHashEntry **obj)\n{\n    struct IdxHashEntry *curr = NULL, *next = NULL;\n    HASH_ITER(hh, *obj, curr, next)\n    {\n        HASH_DEL(*obj, curr);  \n        free(curr);      \n    }\n}\n\nvoid hashAddSetItem(struct SetHashEntry **obj, int key) {\n    struct SetHashEntry *pEntry = NULL;\n    HASH_FIND(hh, *obj, &key, sizeof(key), pEntry);\n    if (pEntry == NULL) {\n        pEntry = malloc(sizeof(struct SetHashEntry));\n        pEntry->key = key;\n        HASH_ADD(hh, *obj, key, sizeof(int), pEntry);\n    }\n} \n\nstruct SetHashEntry *hashFindSetItem(struct SetHashEntry **obj, int key)\n{\n    struct SetHashEntry *pEntry = NULL;\n    HASH_FIND(hh, *obj, &key, sizeof(int), pEntry);\n    return pEntry;\n}\n\nvoid hashFreeSetAll(struct SetHashEntry **obj)\n{\n    struct SetHashEntry *curr = NULL, *next = NULL;\n    HASH_ITER(hh, *obj, curr, next)\n    {\n        HASH_DEL(*obj, curr);  \n        free(curr);      \n    }\n}\n\nint minJumps(int* arr, int arrSize){\n    struct IdxHashEntry * idxSameValue = NULL;\n    for (int i = 0; i < arrSize; i++) {\n        hashAddIdxItem(&idxSameValue, arr[i], i);\n    }\n    \n    struct SetHashEntry * visitedIndex = NULL;\n    struct Pair * queue = (struct Pair *)malloc(sizeof(struct Pair) * arrSize * 2);\n    int head = 0;\n    int tail = 0;\n    queue[tail].idx = 0;\n    queue[tail].step = 0;\n    tail++;\n    hashAddSetItem(&visitedIndex, 0);\n    while (head != tail) {\n        int idx = queue[head].idx;\n        int step = queue[head].step;\n        head++;\n        if (idx + 1 == arrSize) {\n            hashFreeIdxAll(&idxSameValue);\n            hashFreeSetAll(&visitedIndex);\n            free(queue);\n            return step;\n        }\n        int v = arr[idx];\n        step++;\n        struct IdxHashEntry * pEntry = hashFindIdxItem(&idxSameValue, v);\n        if (NULL != pEntry) {\n            for (struct ListNode * node = pEntry->head; node; node = node->next) {\n                if (NULL == hashFindSetItem(&visitedIndex, node->val)) {\n                    hashAddSetItem(&visitedIndex, node->val);\n                    queue[tail].idx = node->val;\n                    queue[tail].step = step;\n                    tail++;\n                }\n            }\n            HASH_DEL(idxSameValue, pEntry);\n        }\n        if (idx + 1 < arrSize && NULL == hashFindSetItem(&visitedIndex, idx + 1)) {\n            hashAddSetItem(&visitedIndex, idx + 1);\n            queue[tail].idx = idx + 1;\n            queue[tail].step = step;\n            tail++;\n        }\n        if (idx - 1 >= 0 && NULL == hashFindSetItem(&visitedIndex, idx - 1)) {\n            hashAddSetItem(&visitedIndex, idx - 1);\n            queue[tail].idx = idx - 1;\n            queue[tail].step = step;\n            tail++;\n        }\n    }\n    hashFreeIdxAll(&idxSameValue);\n    hashFreeSetAll(&visitedIndex);\n    free(queue);\n    return -1;\n}\n```\n\n```go [sol1-Golang]\nfunc minJumps(arr []int) int {\n    n := len(arr)\n    idx := map[int][]int{}\n    for i, v := range arr {\n        idx[v] = append(idx[v], i)\n    }\n    vis := map[int]bool{0: true}\n    type pair struct{ idx, step int }\n    q := []pair{{}}\n    for {\n        p := q[0]\n        q = q[1:]\n        i, step := p.idx, p.step\n        if i == n-1 {\n            return step\n        }\n        for _, j := range idx[arr[i]] {\n            if !vis[j] {\n                vis[j] = true\n                q = append(q, pair{j, step + 1})\n            }\n        }\n        delete(idx, arr[i])\n        if !vis[i+1] {\n            vis[i+1] = true\n            q = append(q, pair{i + 1, step + 1})\n        }\n        if i > 0 && !vis[i-1] {\n            vis[i-1] = true\n            q = append(q, pair{i - 1, step + 1})\n        }\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{arr}$ 的长度。每个元素最多只进入队列一次，最多被判断是否需要进入队列三次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{arr}$ 的长度。队列，哈希表和哈希集合均最多存储 $n$ 个元素。"
}