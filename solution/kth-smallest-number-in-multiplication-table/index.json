{
	"titleSlug": "kth-smallest-number-in-multiplication-table",
	"slug": "cheng-fa-biao-zhong-di-kxiao-de-shu-by-l-521a",
	"url": "https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table/solution/cheng-fa-biao-zhong-di-kxiao-de-shu-by-l-521a/",
	"content": "#### 方法一：二分查找\n\n由于 $m$ 和 $n$ 很大，直接求出所有数字然后找到第 $k$ 小会超出时间限制。不妨考虑一个反向问题：对于乘法表中的数字 $x$，它是乘法表中第几小的数字？\n\n求第几小等价于求有多少数字不超过 $x$。我们可以遍历乘法表的每一行，对于乘法表的第 $i$ 行，其数字均为 $i$ 的倍数，因此不超过 $x$ 的数字有 $\\min(\\Big\\lfloor\\dfrac{x}{i}\\Big\\rfloor,n)$ 个，所以整个乘法表不超过 $x$ 的数字个数为\n\n$$\n\\sum_{i=1}^{m} \\min(\\Big\\lfloor\\dfrac{x}{i}\\Big\\rfloor,n)\n$$\n\n由于 $i\\le \\Big\\lfloor\\dfrac{x}{n}\\Big\\rfloor$ 时 $\\Big\\lfloor\\dfrac{x}{i}\\Big\\rfloor \\ge n$，上式可化简为\n\n$$\n\\Big\\lfloor\\dfrac{x}{n}\\Big\\rfloor\\cdot n + \\sum_{i=\\Big\\lfloor\\dfrac{x}{n}\\Big\\rfloor+1}^{m} \\Big\\lfloor\\dfrac{x}{i}\\Big\\rfloor\n$$\n\n由于 $x$ 越大上式越大，$x$ 越小上式越小，因此我们可以二分 $x$ 找到答案，二分的初始边界为乘法表的元素范围，即 $[1,mn]$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def findKthNumber(self, m: int, n: int, k: int) -> int:\n        return bisect_left(range(m * n), k, key=lambda x: x // n * n + sum(x // i for i in range(x // n + 1, m + 1)))\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findKthNumber(int m, int n, int k) {\n        int left = 1, right = m * n;\n        while (left < right) {\n            int x = left + (right - left) / 2;\n            int count = x / n * n;\n            for (int i = x / n + 1; i <= m; ++i) {\n                count += x / i;\n            }\n            if (count >= k) {\n                right = x;\n            } else {\n                left = x + 1;\n            }\n        }\n        return left;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findKthNumber(int m, int n, int k) {\n        int left = 1, right = m * n;\n        while (left < right) {\n            int x = left + (right - left) / 2;\n            int count = x / n * n;\n            for (int i = x / n + 1; i <= m; ++i) {\n                count += x / i;\n            }\n            if (count >= k) {\n                right = x;\n            } else {\n                left = x + 1;\n            }\n        }\n        return left;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindKthNumber(int m, int n, int k) {\n        int left = 1, right = m * n;\n        while (left < right) {\n            int x = left + (right - left) / 2;\n            int count = x / n * n;\n            for (int i = x / n + 1; i <= m; ++i) {\n                count += x / i;\n            }\n            if (count >= k) {\n                right = x;\n            } else {\n                left = x + 1;\n            }\n        }\n        return left;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc findKthNumber(m, n, k int) int {\n    return sort.Search(m*n, func(x int) bool {\n        count := x / n * n\n        for i := x / n + 1; i <= m; i++ {\n            count += x / i\n        }\n        return count >= k\n    })\n}\n```\n\n```C [sol1-C]\nint findKthNumber(int m, int n, int k){\n    int left = 1, right = m * n;\n    while (left < right) {\n        int x = left + (right - left) / 2;\n        int count = x / n * n;\n        for (int i = x / n + 1; i <= m; ++i) {\n            count += x / i;\n        }\n        if (count >= k) {\n            right = x;\n        } else {\n            left = x + 1;\n        }\n    }\n    return left;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findKthNumber = function(m, n, k) {\n    let left = 1, right = m * n;\n    while (left < right) {\n        const x = left + Math.floor((right - left) / 2);\n        let count = Math.floor(x / n) * n;\n        for (let i = Math.floor(x / n) + 1; i <= m; ++i) {\n            count += Math.floor(x / i);\n        }\n        if (count >= k) {\n            right = x;\n        } else {\n            left = x + 1;\n        }\n    }\n    return left;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(m\\log mn)$。二分的次数为 $O(\\log mn)$，每次二分需要 $O(m)$ 的时间计算。\n\n- 空间复杂度：$O(1)$。只需要常数的空间存放若干变量。"
}