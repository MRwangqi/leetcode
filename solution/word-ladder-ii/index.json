{
	"titleSlug": "word-ladder-ii",
	"slug": "xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-3-3",
	"url": "https://leetcode-cn.com/problems/word-ladder-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-3-3/",
	"content": "给定两个单词，一个作为开始，一个作为结束，还有一个单词列表。然后依次选择单词，只有当前单词到下一个单词只有一个字母不同才能被选择，然后新的单词再作为当前单词，直到选到结束的单词。输出这个的最短路径，如果有多组，则都输出。\r\n\r\n#### 思路分析\r\n\r\n如果我们从开始的单词，把与之能够转换的单词连起来，它就会长成下边的样子。\r\n\r\n![](https://pic.leetcode-cn.com/164a736e22a59a44e7e51e79e2f22f77d392fcd4dc621ea0083a91bd86855884.jpg)\r\n\r\n橙色表示结束单词，上图橙色的路线就是我们要找的最短路径。所以我们要做的其实就是遍历上边的树，然后判断当前节点是不是结束单词，找到结束单词后，还要判断当前是不是最短的路径。说到遍历当然就是两种思路了，`DFS` 或者 `BFS`。\r\n\r\n#### 解法一  DFS\r\n\r\n利用回溯的思想，做一个 DFS。\r\n\r\n首先要解决的问题是怎么找到节点的所有孩子节点。这里有两种方案。\r\n\r\n第一种，遍历 `wordList` 来判断每个单词和当前单词是否只有一个字母不同。\r\n\r\n```Java []\r\nfor (int i = 0; i < wordList.size(); i++) {\r\n    String curWord = wordList.get(i);\r\n    //符合只有一个单词不同，就进入递归\r\n    if (oneChanged(beginWord, curWord)) {\r\n        //此时代表可以从 beginWord -> curWord\r\n    }\r\n}\r\n\r\nprivate boolean oneChanged(String beginWord, String curWord) {\r\n    int count = 0;\r\n    for (int i = 0; i < beginWord.length(); i++) {\r\n        if (beginWord.charAt(i) != curWord.charAt(i)) {\r\n            count++;\r\n        }\r\n        if (count == 2) {\r\n            return false;\r\n        }\r\n    }\r\n    return count == 1;\r\n}\r\n```\r\n\r\n这种的时间复杂度的话，如果 `wordList` 长度为 `m`，每个单词的长度为 `n`。那么就是 `O(mn)`。\r\n第二种，将要找的节点单词的每个位置换一个字符，然后看更改后的单词在不在 `wordList` 中。\r\n\r\n```Java []\r\n//dict 就是 wordList，为了提高速度，从 List 转为 HashSet\r\n//cur 是我们要考虑的单词\r\nprivate List<String> getNext(String cur, Set<String> dict) {\r\n    List<String> res = new ArrayList<>();\r\n    char[] chars = cur.toCharArray();\r\n    //考虑每一位\r\n    for (int i = 0; i < chars.length; i++) {\r\n        char old = chars[i];\r\n        //考虑变成其他所有的字母\r\n        for (char c = 'a'; c <= 'z'; c++) {\r\n            if (c == old) {\r\n                continue;\r\n            }\r\n            chars[i] = c;\r\n            String next = new String(chars);\r\n            //判断 wordList 是否包含修改后的单词\r\n            if (dict.contains(next)) {\r\n                res.add(next);\r\n            }\r\n        }\r\n        chars[i] = old;\r\n    }\r\n    return res;\r\n}\r\n```\r\n\r\n这种的话，由于用到了 `HashSet` ，所以 `contains` 函数就是 $O(1)$。所以整个计算量就是 `26n`，所以是 $O(n)$。\r\n\r\n还要解决的一个问题是，因为我们要找的是最短的路径。但是事先我们并不知道最短的路径是多少，我们需要一个全局变量来保存当前找到的路径的长度。如果找到的新的路径的长度比之前的路径短，就把之前的结果清空，重新找，如果是最小的长度，就加入到结果中。\r\n\r\n看下一递归出口。\r\n\r\n```Java []\r\n//到了结尾单词\r\nif (beginWord.equals(endWord)) {\r\n    //当前长度更小，清空之前的，加新的路径加入到结果中\r\n    if (min > temp.size()) {\r\n        ans.clear();\r\n        min = temp.size();\r\n        ans.add(new ArrayList<String>(temp));\r\n    //相等的话就直接加路径加入到结果中\r\n    } else if (min == temp.size()) {\r\n        ans.add(new ArrayList<String>(temp));\r\n    }\r\n    return;\r\n}\r\n//当前的长度到达了 min，还是没有到达结束单词就提前结束\r\nif (temp.size() >= min) {\r\n    return;\r\n}\r\n```\r\n\r\n得到下一个节点刚才讲了两种思路，我们先采用第一种解法，看一下效果。\r\n\r\n```Java []\r\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n    List<List<String>> ans = new ArrayList<>();\r\n    ArrayList<String> temp = new ArrayList<String>();\r\n    //temp 用来保存当前的路径\r\n    temp.add(beginWord);\r\n    findLaddersHelper(beginWord, endWord, wordList, temp, ans);\r\n    return ans;\r\n}\r\n\r\nint min = Integer.MAX_VALUE;\r\n\r\nprivate void findLaddersHelper(String beginWord, String endWord, List<String> wordList, \r\n                               ArrayList<String> temp, List<List<String>> ans) {\r\n    if (beginWord.equals(endWord)) {\r\n        if (min > temp.size()) {\r\n            ans.clear();\r\n            min = temp.size();\r\n            ans.add(new ArrayList<String>(temp));\r\n        } else if (min == temp.size()) {\r\n            ans.add(new ArrayList<String>(temp));\r\n        }\r\n        return;\r\n    }\r\n    //当前的长度到达了 min，还是没有到达结束单词就提前结束\r\n    if (temp.size() >= min) {\r\n        return;\r\n    }\r\n    //遍历当前所有的单词\r\n    for (int i = 0; i < wordList.size(); i++) {\r\n        String curWord = wordList.get(i);\r\n        //路径中已经含有当前单词，如果再把当前单词加到路径，那肯定会使得路径更长，所以跳过\r\n        if (temp.contains(curWord)) {\r\n            continue;\r\n        }\r\n        //符合只有一个单词不同，就进入递归\r\n        if (oneChanged(beginWord, curWord)) {\r\n            temp.add(curWord);\r\n            findLaddersHelper(curWord, endWord, wordList, temp, ans);\r\n            temp.remove(temp.size() - 1);\r\n        }\r\n    }\r\n}\r\nprivate boolean oneChanged(String beginWord, String curWord) {\r\n    int count = 0;\r\n    for (int i = 0; i < beginWord.length(); i++) {\r\n        if (beginWord.charAt(i) != curWord.charAt(i)) {\r\n            count++;\r\n        }\r\n        if (count == 2) {\r\n            return false;\r\n        }\r\n    }\r\n    return count == 1;\r\n}\r\n```\r\n\r\n但是对于普通的输入可以解决，如果 `wordList` 过长的话就会造成超时了。\r\n\r\n![](https://pic.leetcode-cn.com/82f5b1da642030609c9bd7a77c272af10315cad16a4f6ac2a8405a185cb0f9e1.jpg)\r\n\r\n得到下一个的节点，如果采用第二种解法呢？\r\n\r\n```Java []\r\nint min = Integer.MAX_VALUE;\r\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n    List<List<String>> ans = new ArrayList<>();\r\n    ArrayList<String> temp = new ArrayList<String>();\r\n    temp.add(beginWord);\r\n    //temp 用来保存当前的路径\r\n    findLaddersHelper(beginWord, endWord, wordList, temp, ans);\r\n    return ans;\r\n}\r\n\r\n\r\nprivate void findLaddersHelper(String beginWord, String endWord, List<String> wordList,\r\n                               ArrayList<String> temp, List<List<String>> ans) {\r\n    if (beginWord.equals(endWord)) {\r\n        if (min > temp.size()) {\r\n            ans.clear();\r\n            min = temp.size();\r\n            ans.add(new ArrayList<String>(temp));\r\n        } else if (min == temp.size()) {\r\n            ans.add(new ArrayList<String>(temp));\r\n        }\r\n        return;\r\n    }\r\n\r\n    if (temp.size() >= min) {\r\n        return;\r\n    }\r\n    Set<String> dict = new HashSet<>(wordList);\r\n    //一次性到达所有的下一个的节点\r\n    ArrayList<String> neighbors = getNeighbors(beginWord, dict);\r\n    for (String neighbor : neighbors) {\r\n        if (temp.contains(neighbor)) {\r\n            continue;\r\n        }\r\n        temp.add(neighbor);\r\n        findLaddersHelper(neighbor, endWord, wordList,  temp, ans);\r\n        temp.remove(temp.size() - 1);\r\n    }\r\n}\r\n\r\n\r\nprivate ArrayList<String> getNeighbors(String node, Set<String> dict) {\r\n    ArrayList<String> res = new ArrayList<String>();\r\n    char chs[] = node.toCharArray();\r\n\r\n    for (char ch = 'a'; ch <= 'z'; ch++) {\r\n        for (int i = 0; i < chs.length; i++) {\r\n            if (chs[i] == ch)\r\n                continue;\r\n            char old_ch = chs[i];\r\n            chs[i] = ch;\r\n            if (dict.contains(String.valueOf(chs))) {\r\n                res.add(String.valueOf(chs));\r\n            }\r\n            chs[i] = old_ch;\r\n        }\r\n\r\n    }\r\n    return res;\r\n}\r\n```\r\n\r\n快了一些，但是还是超时。\r\n\r\n![](https://pic.leetcode-cn.com/baab849769b79da464aa96f3acfc47d4fb2d607939891a4a62f36b158f40dad0.jpg)\r\n\r\n我们继续来优化，首先想一下为什么会超时，看一下之前的图。\r\n\r\n![](https://pic.leetcode-cn.com/164a736e22a59a44e7e51e79e2f22f77d392fcd4dc621ea0083a91bd86855884.jpg)\r\n\r\n`DFS` 的过程的话，结合上图，就是先考虑了最左边的路径，然后再回溯一下，继续到达底部。然后回溯回溯，终于到了一条含有结束单词的路径，然而事实上这条并不是最短路径。综上，我们会多判断很多无用的路径。\r\n\r\n如果我们事先知道了最短路径长度是 `4`，那么我们只需要考虑前 `4` 层就足够了。\r\n\r\n![](https://pic.leetcode-cn.com/2a8ee4ecbccdcd06d1fb979c35c2db1cef7a8a2f369830dff5ac9db2453984cc.jpg)\r\n\r\n怎么知道结束单词在哪一层呢？只能一层层的找了，也就是 `BFS`。此外，因为上图需要搜索的树提前是没有的，我们需要边找边更新这个树。而在 `DFS` 中，我们也需要这个树，其实就是需要每个节点的所有相邻节点。\r\n\r\n所以我们在 `BFS` 中，就把每个节点的所有相邻节点保存到 `HashMap` 中，就省去了 `DFS` 再去找相邻节点的时间。\r\n\r\n此外，`BFS` 的过程中，把最短路径的高度用 `min` 也记录下来，在 `DFS` 的时候到达高度后就可以提前结束。\r\n\r\n```Java []\r\nint min = 0;\r\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n    List<List<String>> ans = new ArrayList<>();\r\n    //如果不含有结束单词，直接结束，不然后边会造成死循环\r\n    if (!wordList.contains(endWord)) {\r\n        return ans;\r\n    }\r\n    //利用 BFS 得到所有的邻居节点\r\n    HashMap<String, ArrayList<String>> map = bfs(beginWord, endWord, wordList);\r\n    ArrayList<String> temp = new ArrayList<String>();\r\n    // temp 用来保存当前的路径\r\n    temp.add(beginWord);\r\n    findLaddersHelper(beginWord, endWord, map, temp, ans);\r\n    return ans;\r\n}\r\n\r\nprivate void findLaddersHelper(String beginWord, String endWord, HashMap<String, ArrayList<String>> map,\r\n                               ArrayList<String> temp, List<List<String>> ans) {\r\n    if (beginWord.equals(endWord)) {\r\n        ans.add(new ArrayList<String>(temp));\r\n\r\n        return;\r\n    }\r\n    if(temp.size() - 1==  min){\r\n        return;\r\n    }\r\n    // 得到所有的下一个的节点\r\n    ArrayList<String> neighbors = map.getOrDefault(beginWord, new ArrayList<String>());\r\n    for (String neighbor : neighbors) {\r\n        if (temp.contains(neighbor)) {\r\n            continue;\r\n        }\r\n        temp.add(neighbor);\r\n        findLaddersHelper(neighbor, endWord, map, temp, ans);\r\n        temp.remove(temp.size() - 1);\r\n    }\r\n}\r\n\r\npublic HashMap<String, ArrayList<String>> bfs(String beginWord, String endWord, List<String> wordList) {\r\n    Queue<String> queue = new LinkedList<>();\r\n    queue.offer(beginWord);\r\n    HashMap<String, ArrayList<String>> map = new HashMap<>();\r\n    boolean isFound = false;\r\n\r\n    Set<String> dict = new HashSet<>(wordList);\r\n    while (!queue.isEmpty()) {\r\n        int size = queue.size();\r\n        min++;\r\n        for (int j = 0; j < size; j++) {\r\n            String temp = queue.poll();\r\n            // 一次性得到所有的下一个的节点\r\n            ArrayList<String> neighbors = getNeighbors(temp, dict);\r\n            map.put(temp, neighbors);\r\n            for (String neighbor : neighbors) {\r\n                if (neighbor.equals(endWord)) {\r\n                    isFound = true;\r\n                }\r\n                queue.offer(neighbor);\r\n            }\r\n        }\r\n        if (isFound) {\r\n            break;\r\n        }\r\n    }\r\n    return map;\r\n}\r\nprivate ArrayList<String> getNeighbors(String node, Set<String> dict) {\r\n    ArrayList<String> res = new ArrayList<String>();\r\n    char chs[] = node.toCharArray();\r\n\r\n    for (char ch = 'a'; ch <= 'z'; ch++) {\r\n        for (int i = 0; i < chs.length; i++) {\r\n            if (chs[i] == ch)\r\n                continue;\r\n            char old_ch = chs[i];\r\n            chs[i] = ch;\r\n            if (dict.contains(String.valueOf(chs))) {\r\n                res.add(String.valueOf(chs));\r\n            }\r\n            chs[i] = old_ch;\r\n        }\r\n\r\n    }\r\n    return res;\r\n}\r\n```\r\n\r\n然而这个优化，对于 `leetcode` 的 `tests` 并没有什么影响。\r\n\r\n![](https://pic.leetcode-cn.com/baab849769b79da464aa96f3acfc47d4fb2d607939891a4a62f36b158f40dad0.jpg)\r\n\r\n让我们继续考虑优化方案，回到之前的图。\r\n\r\n![](https://pic.leetcode-cn.com/0ccb79ccd1536af655f460c8e8ab3cb4e88e7a229c28ccd850023316cbb4ffb2.jpg)\r\n\r\n假如我们在考虑上图中黄色节点的相邻节点，发现第三层的 `abc` 在第二层已经考虑过了。所以第三层的 `abc` 其实不用再考虑了，第三层的  `abc` 后边的结构一定和第二层后边的结构一样，因为我们要找最短的路径，所以如果产生了最短路径，一定是第二层的 `abc` 首先达到结束单词。\r\n\r\n所以其实我们在考虑第 `k` 层的某一个单词，如果这个单词在第 `1` 到 `k-1` 层已经出现过，我们其实就不过继续向下探索了。\r\n\r\n在之前的代码中，我们其实已经考虑了部分这个问题。\r\n\r\n```Java []\r\nif (temp.contains(neighbor)) {\r\n    continue;\r\n}\r\n```\r\n\r\n但我们只考虑了当前路径是否含有该单词，而就像上图表示的，其他路径之前已经考虑过了当前单词，我们也是可以跳过的。\r\n\r\n根据这个优化思路，有两种解决方案。\r\n\r\n第一种，再利用一个 `HashMap`，记为 `distance` 变量。在 `BFS` 的过程中，把第一次遇到的单词当前的层数存起来。之后遇到也不进行更新，就会是下边的效果。\r\n\r\n![](https://pic.leetcode-cn.com/a677744731d785ae02ee5373b669c056ad03293262b03b6b8bb90a5cd5105093.jpg)\r\n\r\n这样我们就可以在 `DFS` 的时候来判断当前黄色的节点的 `distance` 是不是比邻接节点的小 `1`。上图中 `distance` 都是 `1` ，所以不符合，就可以跳过。\r\n\r\n此外，在 `DFS` 中，因为我们每次都根据节点的层数来进行深搜，所以之前保存最短路径的全局变量 `min` 在这里也就不需要了。\r\n\r\n```Java []\r\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n    List<List<String>> ans = new ArrayList<>();\r\n    // 如果不含有结束单词，直接结束，不然后边会造成死循环\r\n    if (!wordList.contains(endWord)) {\r\n        return ans;\r\n    }\r\n    // 利用 BFS 得到所有的邻居节点,以及每个节点的所在层数\r\n    HashMap<String, Integer> distance = new HashMap<>();\r\n    HashMap<String, ArrayList<String>> map = new HashMap<>();\r\n    bfs(beginWord, endWord, wordList, map, distance);\r\n    ArrayList<String> temp = new ArrayList<String>();\r\n    // temp 用来保存当前的路径\r\n    temp.add(beginWord);\r\n    findLaddersHelper(beginWord, endWord, map, distance, temp, ans);\r\n    return ans;\r\n}\r\n\r\nprivate void findLaddersHelper(String beginWord, String endWord, HashMap<String, ArrayList<String>> map,\r\n                               HashMap<String, Integer> distance, ArrayList<String> temp, List<List<String>> ans) {\r\n    if (beginWord.equals(endWord)) {\r\n        ans.add(new ArrayList<String>(temp));\r\n        return;\r\n    }\r\n    // 得到所有的下一个的节点\r\n    /*\r\n      \"a\"\r\n      \"c\"\r\n      [\"a\",\"b\",\"c\"]*/\r\n    //之所以是 map.getOrDefault 而不是 get，就是上边的情况 get 会出错\r\n    ArrayList<String> neighbors = map.getOrDefault(beginWord, new ArrayList<String>());\r\n    for (String neighbor : neighbors) {\r\n        //判断层数是否符合\r\n        if (distance.get(beginWord) + 1 == distance.get(neighbor)) {\r\n            temp.add(neighbor);\r\n            findLaddersHelper(neighbor, endWord, map, distance, temp, ans);\r\n            temp.remove(temp.size() - 1);\r\n        }\r\n    }\r\n}\r\n\r\npublic void bfs(String beginWord, String endWord, List<String> wordList, HashMap<String, ArrayList<String>> map,\r\n                HashMap<String, Integer> distance) {\r\n    Queue<String> queue = new LinkedList<>();\r\n    queue.offer(beginWord);\r\n    distance.put(beginWord, 0);\r\n    boolean isFound = false;\r\n    int depth = 0;\r\n    Set<String> dict = new HashSet<>(wordList);\r\n    while (!queue.isEmpty()) {\r\n        int size = queue.size();\r\n        depth++;\r\n        for (int j = 0; j < size; j++) {\r\n            String temp = queue.poll();\r\n            // 一次性得到所有的下一个的节点\r\n            ArrayList<String> neighbors = getNeighbors(temp, dict);\r\n            map.put(temp, neighbors);\r\n            for (String neighbor : neighbors) {\r\n                if (!distance.containsKey(neighbor)) {\r\n                    distance.put(neighbor, depth);\r\n                    if (neighbor.equals(endWord)) {\r\n                        isFound = true;\r\n                    }\r\n                    queue.offer(neighbor);\r\n                }\r\n\r\n            }\r\n        }\r\n        if (isFound) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nprivate ArrayList<String> getNeighbors(String node, Set<String> dict) {\r\n    ArrayList<String> res = new ArrayList<String>();\r\n    char chs[] = node.toCharArray();\r\n\r\n    for (char ch = 'a'; ch <= 'z'; ch++) {\r\n        for (int i = 0; i < chs.length; i++) {\r\n            if (chs[i] == ch)\r\n                continue;\r\n            char old_ch = chs[i];\r\n            chs[i] = ch;\r\n             if (dict.contains(String.valueOf(chs))) {\r\n                res.add(String.valueOf(chs));\r\n            }\r\n            chs[i] = old_ch;\r\n        }\r\n\r\n    }\r\n    return res;\r\n}\r\n\r\n```\r\n\r\n终于，上边的算法 `AC` 了。上边讲到我们提前存储了 `distance` ，方便在 `DFS` 中来判断我们是否继续深搜。\r\n\r\n这里再讲一下另一种思路，再回顾一下这个要进行优化的图。\r\n\r\n![](https://pic.leetcode-cn.com/a677744731d785ae02ee5373b669c056ad03293262b03b6b8bb90a5cd5105093.jpg)\r\n\r\n我们就是减少了第三层的 `abc` 的情况的判断。我们其实可以不用 `distance` ，在 `BFS` 中，如果发现有邻接节点在之前已经出现过了，我们直接把这个邻接节点删除不去。这样的话，在 `DFS` 中就不用再判断了，直接取邻居节点就可以了。\r\n\r\n判断之前是否已经处理过，可以用一个  `HashSet` 来把之前的节点存起来进行判断。\r\n\r\n这里删除邻接节点需要用到一个语言特性，`java` 中遍历 `List` 过程中，不能对 `List` 元素进行删除。如果想边遍历边删除，可以借助迭代器。\r\n\r\n```Java []\r\nIterator<String> it = neighbors.iterator();//把元素导入迭代器\r\nwhile (it.hasNext()) {\r\n    String neighbor = it.next();\r\n    if (!visited.contains(neighbor)) {\r\n        if (neighbor.equals(endWord)) {\r\n            isFound = true;\r\n        }\r\n        queue.offer(neighbor);\r\n        subVisited.add(neighbor);\r\n    }else{\r\n        it.remove();\r\n    } \r\n}\r\n```\r\n\r\n此外我们要判断的是当前节点在之前层有没有出现过，当前层正在遍历的节点先加到 `subVisited` 中。\r\n\r\n```Java []\r\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n    List<List<String>> ans = new ArrayList<>();\r\n    if (!wordList.contains(endWord)) {\r\n        return ans;\r\n    }\r\n    // 利用 BFS 得到所有的邻居节点\r\n    HashMap<String, ArrayList<String>> map = new HashMap<>();\r\n    bfs(beginWord, endWord, wordList, map);\r\n    ArrayList<String> temp = new ArrayList<String>();\r\n    // temp 用来保存当前的路径\r\n    temp.add(beginWord);\r\n    findLaddersHelper(beginWord, endWord, map, temp, ans);\r\n    return ans;\r\n}\r\n\r\nprivate void findLaddersHelper(String beginWord, String endWord, HashMap<String, ArrayList<String>> map,\r\n                               ArrayList<String> temp, List<List<String>> ans) {\r\n    if (beginWord.equals(endWord)) {\r\n        ans.add(new ArrayList<String>(temp));\r\n        return;\r\n    }\r\n    // 得到所有的下一个的节点\r\n    ArrayList<String> neighbors = map.getOrDefault(beginWord, new ArrayList<String>());\r\n    for (String neighbor : neighbors) {\r\n        temp.add(neighbor);\r\n        findLaddersHelper(neighbor, endWord, map, temp, ans);\r\n        temp.remove(temp.size() - 1);\r\n\r\n    }\r\n}\r\n\r\npublic void bfs(String beginWord, String endWord, List<String> wordList, HashMap<String, ArrayList<String>> map) {\r\n    Queue<String> queue = new LinkedList<>();\r\n    queue.offer(beginWord);\r\n    boolean isFound = false;\r\n    int depth = 0;\r\n    Set<String> dict = new HashSet<>(wordList);\r\n    Set<String> visited = new HashSet<>();\r\n    visited.add(beginWord);\r\n    while (!queue.isEmpty()) {\r\n        int size = queue.size();\r\n        depth++;\r\n        Set<String> subVisited = new HashSet<>();\r\n        for (int j = 0; j < size; j++) {\r\n            String temp = queue.poll();\r\n            // 一次性得到所有的下一个的节点\r\n            ArrayList<String> neighbors = getNeighbors(temp, dict); \r\n            Iterator<String> it = neighbors.iterator();//把元素导入迭代器\r\n            while (it.hasNext()) {\r\n                String neighbor = it.next();\r\n                if (!visited.contains(neighbor)) {\r\n                    if (neighbor.equals(endWord)) {\r\n                        isFound = true;\r\n                    }\r\n                    queue.offer(neighbor);\r\n                    subVisited.add(neighbor);\r\n                }else{\r\n                    it.remove();\r\n                } \r\n            }\r\n            map.put(temp, neighbors);\r\n        }\r\n        visited.addAll(subVisited);\r\n        if (isFound) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nprivate ArrayList<String> getNeighbors(String node, Set<String> dict) {\r\n    ArrayList<String> res = new ArrayList<String>();\r\n    char chs[] = node.toCharArray();\r\n\r\n    for (char ch = 'a'; ch <= 'z'; ch++) {\r\n        for (int i = 0; i < chs.length; i++) {\r\n            if (chs[i] == ch)\r\n                continue;\r\n            char old_ch = chs[i];\r\n            chs[i] = ch;\r\n            if (dict.contains(String.valueOf(chs))) {\r\n                res.add(String.valueOf(chs));\r\n            }\r\n            chs[i] = old_ch;\r\n        }\r\n\r\n    }\r\n    return res;\r\n}\r\n```\r\n\r\n#### 解法二  BFS\r\n\r\n如果理解了上边的 `DFS` 过程，接下来就很好讲了。上边 `DFS` 借助了 `BFS` 把所有的邻接关系保存了起来，再用 `DFS` 进行深度搜索。\r\n\r\n我们可不可以只用  `BFS`，一边进行层次遍历，一边就保存结果。当到达结束单词的时候，就把结果存储。省去再进行 `DFS`  的过程。\r\n\r\n是完全可以的，`BFS` 的队列就不去存储 `String` 了，直接去存到目前为止的路径，也就是一个 `List`。\r\n\r\n```Java []\r\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n    List<List<String>> ans = new ArrayList<>();\r\n    // 如果不含有结束单词，直接结束，不然后边会造成死循环\r\n    if (!wordList.contains(endWord)) {\r\n        return ans;\r\n    }\r\n    bfs(beginWord, endWord, wordList, ans);\r\n    return ans;\r\n}\r\n\r\npublic void bfs(String beginWord, String endWord, List<String> wordList, List<List<String>> ans) {\r\n    Queue<List<String>> queue = new LinkedList<>();\r\n    List<String> path = new ArrayList<>();\r\n    path.add(beginWord);\r\n    queue.offer(path);\r\n    boolean isFound = false;\r\n    Set<String> dict = new HashSet<>(wordList);\r\n    Set<String> visited = new HashSet<>();\r\n    visited.add(beginWord);\r\n    while (!queue.isEmpty()) {\r\n        int size = queue.size();\r\n        Set<String> subVisited = new HashSet<>();\r\n        for (int j = 0; j < size; j++) {\r\n            List<String> p = queue.poll();\r\n            //得到当前路径的末尾单词\r\n            String temp = p.get(p.size() - 1);\r\n            // 一次性得到所有的下一个的节点\r\n            ArrayList<String> neighbors = getNeighbors(temp, dict);\r\n            for (String neighbor : neighbors) {\r\n                //只考虑之前没有出现过的单词\r\n                if (!visited.contains(neighbor)) {\r\n                    //到达结束单词\r\n                    if (neighbor.equals(endWord)) {\r\n                        isFound = true;\r\n                        p.add(neighbor);\r\n                        ans.add(new ArrayList<String>(p));\r\n                        p.remove(p.size() - 1);\r\n                    }\r\n                    //加入当前单词\r\n                    p.add(neighbor);\r\n                    queue.offer(new ArrayList<String>(p));\r\n                    p.remove(p.size() - 1);\r\n                    subVisited.add(neighbor);\r\n                }\r\n            }\r\n        }\r\n        visited.addAll(subVisited);\r\n        if (isFound) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nprivate ArrayList<String> getNeighbors(String node, Set<String> dict) {\r\n    ArrayList<String> res = new ArrayList<String>();\r\n    char chs[] = node.toCharArray();\r\n    for (char ch = 'a'; ch <= 'z'; ch++) {\r\n        for (int i = 0; i < chs.length; i++) {\r\n            if (chs[i] == ch)\r\n                continue;\r\n            char old_ch = chs[i];\r\n            chs[i] = ch;\r\n            if (dict.contains(String.valueOf(chs))) {\r\n                res.add(String.valueOf(chs));\r\n            }\r\n            chs[i] = old_ch;\r\n        }\r\n\r\n    }\r\n    return res;\r\n}\r\n```\r\n\r\n代码看起来简洁了很多。\r\n\r\n#### 解法三 DFS + BFS 双向搜索（two-end BFS）\r\n\r\n在解法一的思路上，我们还能够继续优化。\r\n\r\n解法一中，我们利用了 `BFS` 建立了每个节点的邻居节点。在之前的示意图中，我们把同一个字符串也画在了不同节点。这里把同一个节点画在一起，再看一下。\r\n\r\n![](https://pic.leetcode-cn.com/3df75feb64b7fcf06e76de68a4f4f3aad334b5a586cfbdbd3c4a961ffceba894.jpg)\r\n\r\n我们可以从结束单词反向进行 `BFS`。\r\n\r\n![](https://pic.leetcode-cn.com/7fa5d97f3e1ee324975cf6a83d89d04fc40b5671a3722804d89bb9f24084b866.jpg)\r\n\r\n这样的话，当两个方向产生了共同的节点，就是我们的最短路径了。\r\n\r\n至于每次从哪个方向扩展，我们可以每次选择需要扩展的节点数少的方向进行扩展。\r\n\r\n例如上图中，一开始需要向下扩展的个数是 `1` 个，需要向上扩展的个数是 `1` 个。个数相等，我们就向下扩展。然后需要向下扩展的个数就变成了 `4` 个，而需要向上扩展的个数是 `1` 个，所以此时我们向上扩展。接着，需要向上扩展的个数变成了 `6` 个，需要向下扩展的个数是 `4` 个，我们就向下扩展......直到相遇。\r\n\r\n双向扩展的好处，我们粗略的估计一下时间复杂度。\r\n\r\n假设 `beginword` 和 `endword` 之间的距离是 `d`。每个节点可以扩展出 `k` 个节点。\r\n\r\n那么正常的时间复杂就是 $k^d$。\r\n\r\n双向搜索的时间复杂度就是 $k^{d/2} + k^{d/2}$。\r\n\r\n```Java []\r\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n    List<List<String>> ans = new ArrayList<>();\r\n    if (!wordList.contains(endWord)) {\r\n        return ans;\r\n    }\r\n    // 利用 BFS 得到所有的邻居节点\r\n    HashMap<String, ArrayList<String>> map = new HashMap<>();\r\n    bfs(beginWord, endWord, wordList, map);\r\n    ArrayList<String> temp = new ArrayList<String>();\r\n    // temp 用来保存当前的路径\r\n    temp.add(beginWord);\r\n    findLaddersHelper(beginWord, endWord, map, temp, ans);\r\n    return ans;\r\n}\r\n\r\nprivate void findLaddersHelper(String beginWord, String endWord, HashMap<String, ArrayList<String>> map,\r\n                               ArrayList<String> temp, List<List<String>> ans) {\r\n    if (beginWord.equals(endWord)) {\r\n        ans.add(new ArrayList<String>(temp));\r\n        return;\r\n    }\r\n    // 得到所有的下一个的节点\r\n    ArrayList<String> neighbors = map.getOrDefault(beginWord, new ArrayList<String>());\r\n    for (String neighbor : neighbors) {\r\n        temp.add(neighbor);\r\n        findLaddersHelper(neighbor, endWord, map, temp, ans);\r\n        temp.remove(temp.size() - 1);\r\n    }\r\n}\r\n\r\n//利用递归实现了双向搜索\r\nprivate void bfs(String beginWord, String endWord, List<String> wordList, HashMap<String, ArrayList<String>> map) {\r\n    Set<String> set1 = new HashSet<String>();\r\n    set1.add(beginWord);\r\n    Set<String> set2 = new HashSet<String>();\r\n    set2.add(endWord);\r\n    Set<String> wordSet = new HashSet<String>(wordList);\r\n    bfsHelper(set1, set2, wordSet, true, map);\r\n}\r\n\r\n// direction 为 true 代表向下扩展，false 代表向上扩展\r\nprivate boolean bfsHelper(Set<String> set1, Set<String> set2, Set<String> wordSet, boolean direction,\r\n                          HashMap<String, ArrayList<String>> map) {\r\n    //set1 为空了，就直接结束\r\n    //比如下边的例子就会造成 set1 为空\r\n    /*\t\"hot\"\r\n\t\t\"dog\"\r\n\t\t[\"hot\",\"dog\"]*/\r\n    if(set1.isEmpty()){\r\n        return false;\r\n    }\r\n    // set1 的数量多，就反向扩展\r\n    if (set1.size() > set2.size()) {\r\n        return bfsHelper(set2, set1, wordSet, !direction, map);\r\n    }\r\n    // 将已经访问过单词删除\r\n    wordSet.removeAll(set1);\r\n    wordSet.removeAll(set2);\r\n\r\n    boolean done = false;\r\n\r\n    // 保存新扩展得到的节点\r\n    Set<String> set = new HashSet<String>();\r\n\r\n    for (String str : set1) {\r\n        //遍历每一位\r\n        for (int i = 0; i < str.length(); i++) {\r\n            char[] chars = str.toCharArray();\r\n\r\n            // 尝试所有字母\r\n            for (char ch = 'a'; ch <= 'z'; ch++) {\r\n                if(chars[i] == ch){\r\n                    continue;\r\n                }\r\n                chars[i] = ch;\r\n\r\n                String word = new String(chars);\r\n\r\n                // 根据方向得到 map 的 key 和 val\r\n                String key = direction ? str : word;\r\n                String val = direction ? word : str;\r\n\r\n                ArrayList<String> list = map.containsKey(key) ? map.get(key) : new ArrayList<String>();\r\n                \r\n                //如果相遇了就保存结果\r\n                if (set2.contains(word)) {\r\n                    done = true;\r\n                    list.add(val);\r\n                    map.put(key, list);\r\n                }\r\n\r\n                //如果还没有相遇，并且新的单词在 word 中，那么就加到 set 中\r\n                if (!done && wordSet.contains(word)) {\r\n                    set.add(word);\r\n                    list.add(val);\r\n                    map.put(key, list);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //一般情况下新扩展的元素会多一些，所以我们下次反方向扩展  set2\r\n    return done || bfsHelper(set2, set, wordSet, !direction, map);\r\n\r\n}\r\n```\r\n\r\n#### 总\r\n\r\n最近事情比较多，这道题每天想一想，陆陆续续拖了好几天了。这道题本质上就是在正常的遍历的基础上，去将一些分支剪去，从而提高速度。至于方法的话，除了我上边介绍的实现方式，应该也会有很多其它的方式，但其实本质上是为了实现一样的东西。另外，双向搜索的方法，自己第一次遇到，网上搜了。\r\n"
}