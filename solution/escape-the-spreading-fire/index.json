{
	"titleSlug": "escape-the-spreading-fire",
	"slug": "er-fen-bfspythonjavacgo-by-endlesscheng-ypp1",
	"url": "https://leetcode-cn.com/problems/escape-the-spreading-fire/solution/er-fen-bfspythonjavacgo-by-endlesscheng-ypp1/",
	"content": "## 方法一：二分答案 + BFS\r\n\r\n#### 提示 1\r\n\r\n如果可以停留 $t$ 分钟，那么肯定也可以停留少于 $t$ 分钟；如果不能停留 $t$ 分钟，那么肯定也不能停留超过 $t$ 分钟。\r\n\r\n因此可以二分最长停留时间。\r\n\r\n#### 提示 2\r\n\r\n为了避免遇到火，人需要尽可能快地到达安全屋，这可以用 BFS。\r\n\r\n蔓延火势也符合多源 BFS 的模型。\r\n\r\n#### 提示 3\r\n\r\n每过一分钟，将人能到达的位置向外扩充一圈，火势也向外蔓延一圈。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(mn\\log mn)$。\r\n- 空间复杂度：$O(mn)$。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\r\n        m, n = len(grid), len(grid[0])\r\n\r\n        def check(t: int) -> bool:\r\n            f = [(i, j) for i, row in enumerate(grid) for j, v in enumerate(row) if v == 1]\r\n            fire = set(f)\r\n            def spread_fire():\r\n                nonlocal f\r\n                tmp = f\r\n                f = []\r\n                for i, j in tmp:\r\n                    for x, y in (i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j):\r\n                        if 0 <= x < m and 0 <= y < n and grid[x][y] == 0 and (x, y) not in fire:\r\n                            fire.add((x, y))\r\n                            f.append((x, y))\r\n            while t and f:\r\n                spread_fire()  # 蔓延至多 t 分钟的火势\r\n                t -= 1\r\n            if (0, 0) in fire:  # 起点着火，寄\r\n                return True\r\n\r\n            q = [(0, 0)]\r\n            vis = set(q)\r\n            while q:\r\n                tmp = q\r\n                q = []\r\n                for i, j in tmp:\r\n                    if (i, j) not in fire:\r\n                        for x, y in (i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j):\r\n                            if 0 <= x < m and 0 <= y < n and grid[x][y] == 0 and (x, y) not in fire and (x, y) not in vis:\r\n                                if x == m - 1 and y == n - 1:  # 我们安全了…暂时。\r\n                                    return False\r\n                                vis.add((x, y))\r\n                                q.append((x, y))\r\n                spread_fire()  # 蔓延 1 分钟的火势\r\n            return True  # 寄\r\n\r\n        ans = bisect_left(range(m * n + 1), True, key=check) - 1\r\n        return ans if ans < m * n else 10 ** 9\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n\r\n    public int maximumMinutes(int[][] grid) {\r\n        int m = grid.length, n = grid[0].length;\r\n        int left = -1, right = m * n;\r\n        while (left < right) {\r\n            var mid = (left + right + 1) / 2;\r\n            if (check(grid, mid)) left = mid;\r\n            else right = mid - 1;\r\n        }\r\n        return left < m * n ? left : (int) 1e9;\r\n    }\r\n\r\n    boolean check(int[][] grid, int t) {\r\n        int m = grid.length, n = grid[0].length;\r\n        var fire = new boolean[m][n];\r\n        var f = new ArrayList<int[]>();\r\n        for (var i = 0; i < m; i++)\r\n            for (var j = 0; j < n; j++)\r\n                if (grid[i][j] == 1) {\r\n                    fire[i][j] = true;\r\n                    f.add(new int[]{i, j});\r\n                }\r\n        while (t-- > 0 && f.size() > 0)\r\n            f = spreadFire(grid, fire, f); // 蔓延至多 t 分钟的火势\r\n        if (fire[0][0]) return false; // 起点着火，寄\r\n\r\n        var vis = new boolean[m][n];\r\n        vis[0][0] = true;\r\n        var q = new ArrayList<int[]>();\r\n        q.add(new int[]{0, 0});\r\n        while (q.size() > 0) {\r\n            var tmp = q;\r\n            q = new ArrayList<>();\r\n            for (var p : tmp)\r\n                if (!fire[p[0]][p[1]])\r\n                    for (var d : dirs) {\r\n                        int x = p[0] + d[0], y = p[1] + d[1];\r\n                        if (0 <= x && x < m && 0 <= y && y < n && !fire[x][y] && !vis[x][y] && grid[x][y] == 0) {\r\n                            if (x == m - 1 && y == n - 1) return true; // 我们安全了…暂时。\r\n                            vis[x][y] = true;\r\n                            q.add(new int[]{x, y});\r\n                        }\r\n                    }\r\n            f = spreadFire(grid, fire, f); // 蔓延 1 分钟的火势\r\n        }\r\n        return false; // 寄\r\n    }\r\n\r\n    ArrayList<int[]> spreadFire(int[][] grid, boolean[][] fire, ArrayList<int[]> f) {\r\n        int m = grid.length, n = grid[0].length;\r\n        var tmp = f;\r\n        f = new ArrayList<>();\r\n        for (var p : tmp)\r\n            for (var d : dirs) {\r\n                int x = p[0] + d[0], y = p[1] + d[1];\r\n                if (0 <= x && x < m && 0 <= y && y < n && !fire[x][y] && grid[x][y] == 0) {\r\n                    fire[x][y] = true;\r\n                    f.add(new int[]{x, y});\r\n                }\r\n            }\r\n        return f;\r\n    }\r\n}    \r\n```\r\n\r\n```C++ [sol1-C++]\r\nconst int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n\r\nclass Solution {\r\n    bool check(vector<vector<int>> &grid, int t) {\r\n        int m = grid.size(), n = grid[0].size();\r\n        bool fire[m][n]; memset(fire, 0, sizeof(fire));\r\n        vector<pair<int, int>> f, q;\r\n        for (int i = 0; i < m; ++i)\r\n            for (int j = 0; j < n; ++j)\r\n                if (grid[i][j] == 1) {\r\n                    fire[i][j] = true;\r\n                    f.emplace_back(i, j);\r\n                }\r\n        auto spread_fire = [&]() {\r\n            vector<pair<int, int>> nf;\r\n            for (auto &[i, j] : f)\r\n                for (auto [dx, dy] : dirs) {\r\n                    int x = i + dx, y = j + dy;\r\n                    if (0 <= x && x < m && 0 <= y && y < n && !fire[x][y] && grid[x][y] == 0) {\r\n                        fire[x][y] = true;\r\n                        nf.emplace_back(x, y);\r\n                    }\r\n                }\r\n            f = move(nf);\r\n        };\r\n        while (t-- && !f.empty()) spread_fire(); // 蔓延至多 t 分钟的火势\r\n        if (fire[0][0]) return false; // 起点着火，寄\r\n\r\n        bool vis[m][n]; memset(vis, 0, sizeof(vis));\r\n        vis[0][0] = true;\r\n        q.emplace_back(0, 0);\r\n        while (!q.empty()) {\r\n            vector<pair<int, int>> nq;\r\n            for (auto &[i, j] : q)\r\n                if (!fire[i][j])\r\n                    for (auto [dx, dy] : dirs) {\r\n                        int x = i + dx, y = j + dy;\r\n                        if (0 <= x && x < m && 0 <= y && y < n && !fire[x][y] && !vis[x][y] && grid[x][y] == 0) {\r\n                            if (x == m - 1 && y == n - 1) return true; // 我们安全了…暂时。\r\n                            vis[x][y] = true;\r\n                            nq.emplace_back(x, y);\r\n                        }\r\n                    }\r\n            q = move(nq);\r\n            spread_fire(); // 蔓延 1 分钟的火势\r\n        }\r\n        return false; // 寄\r\n    }\r\n\r\npublic:\r\n    int maximumMinutes(vector<vector<int>> &grid) {\r\n        int m = grid.size(), n = grid[0].size();\r\n        int left = -1, right = m * n;\r\n        while (left < right) {\r\n            int mid = (left + right + 1) / 2;\r\n            if (check(grid, mid)) left = mid;\r\n            else right = mid - 1;\r\n        }\r\n        return left < m * n ? left : 1e9;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\ntype pair struct{ x, y int }\r\nvar dirs = []pair{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\r\n\r\nfunc maximumMinutes(grid [][]int) int {\r\n\tm, n := len(grid), len(grid[0])\r\n\tans := sort.Search(m*n+1, func(t int) bool {\r\n\t\tfire := make([][]bool, m)\r\n\t\tfor i := range fire {\r\n\t\t\tfire[i] = make([]bool, n)\r\n\t\t}\r\n\t\tf := []pair{}\r\n\t\tfor i, row := range grid {\r\n\t\t\tfor j, v := range row {\r\n\t\t\t\tif v == 1 {\r\n\t\t\t\t\tfire[i][j] = true\r\n\t\t\t\t\tf = append(f, pair{i, j})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tspreadFire := func() {\r\n\t\t\ttmp := f\r\n\t\t\tf = nil\r\n\t\t\tfor _, p := range tmp {\r\n\t\t\t\tfor _, d := range dirs {\r\n\t\t\t\t\tif x, y := p.x+d.x, p.y+d.y; 0 <= x && x < m && 0 <= y && y < n && !fire[x][y] && grid[x][y] == 0 {\r\n\t\t\t\t\t\tfire[x][y] = true\r\n\t\t\t\t\t\tf = append(f, pair{x, y})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor ; t > 0 && len(f) > 0; t-- {\r\n\t\t\tspreadFire() // 蔓延至多 t 分钟的火势\r\n\t\t}\r\n\t\tif fire[0][0] { // 起点着火，寄\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tvis := make([][]bool, m)\r\n\t\tfor i := range vis {\r\n\t\t\tvis[i] = make([]bool, n)\r\n\t\t}\r\n\t\tvis[0][0] = true\r\n\t\tq := []pair{{}}\r\n\t\tfor len(q) > 0 {\r\n\t\t\ttmp := q\r\n\t\t\tq = nil\r\n\t\t\tfor _, p := range tmp {\r\n\t\t\t\tif !fire[p.x][p.y] {\r\n\t\t\t\t\tfor _, d := range dirs {\r\n\t\t\t\t\t\tif x, y := p.x+d.x, p.y+d.y; 0 <= x && x < m && 0 <= y && y < n && !vis[x][y] && !fire[x][y] && grid[x][y] == 0 {\r\n\t\t\t\t\t\t\tif x == m-1 && y == n-1 { // 我们安全了…暂时。\r\n\t\t\t\t\t\t\t\treturn false\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvis[x][y] = true\r\n\t\t\t\t\t\t\tq = append(q, pair{x, y})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tspreadFire() // 蔓延 1 分钟的火势\r\n\t\t}\r\n\t\treturn true // 寄\r\n\t}) - 1\r\n\tif ans < m*n {\r\n\t\treturn ans\r\n\t}\r\n\treturn 1e9\r\n}\r\n```\r\n\r\n## 方法二：两次 BFS\r\n\r\n首先通过 BFS 处理出人到每个格子的最短时间 $\\textit{manTime}$，以及火到每个格子的最短时间 $\\textit{fireTime}$。\r\n\r\n如果 $\\textit{manTime}[m-1][n-1]<0$，人无法到达终点，返回 $-1$。\r\n\r\n如果 $\\textit{fireTime}[m-1][n-1]<0$，火无法到达终点，返回 $10^9$。\r\n\r\n记 $\\textit{ans}=\\textit{fireTime}[m-1][n-1]-\\textit{manTime}[m-1][n-1]$。\r\n\r\n如果 $\\textit{ans} < 0$，说明火比人先到终点，返回 $-1$。\r\n\r\n如果 $\\textit{ans} > 0$，说明人比火先到终点。注意不会出现中途火把人烧到的情况，如果出现，那么火可以沿着人走的最短路到达终点，不会出现人比火先到的情况，与实际矛盾。\r\n\r\n最后还需要细致分析一下：\r\n\r\n- 如果火和人是从不同方向到达终点的（左侧和上侧），那么答案可以是 $\\textit{ans}$，即人可以等待 $\\textit{ans}$ 时间，最终与火同时到达终点。\r\n- 如果火和人是从同一方向到达终点的，也就意味着火一直跟在人的后面，那么在中途不能出现人火重合的情况，所以答案应该是 $\\textit{ans}-1$。\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：$O(mn)$。\r\n- 空间复杂度：$O(mn)$。\r\n\r\n```Python [sol2-Python3]\r\nclass Solution:\r\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\r\n        m, n = len(grid), len(grid[0])\r\n        def bfs(q: List[Tuple[int, int]]) -> (int, int, int):\r\n            time = [[-1] * n for _ in range(m)]\r\n            t = 0\r\n            while q:\r\n                tmp = q\r\n                q = []\r\n                for i, j in tmp:\r\n                    time[i][j] = t\r\n                    for x, y in (i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j):\r\n                        if 0 <= x < m and 0 <= y < n and grid[x][y] == 0 and time[x][y] < 0:\r\n                            q.append((x, y))\r\n                t += 1\r\n            return time[-1][-1], time[-1][-2], time[-2][-1]\r\n\r\n        man_to_house_time, m1, m2 = bfs([(0, 0)])\r\n        if man_to_house_time < 0: return -1  # 人无法到终点\r\n        fire_to_house_time, f1, f2 = bfs([(i, j) for i, row in enumerate(grid) for j, v in enumerate(row) if v == 1])\r\n        if fire_to_house_time < 0: return 10 ** 9  # 火无法到终点\r\n        ans = fire_to_house_time - man_to_house_time\r\n        if ans < 0: return -1  # 火比人先到终点\r\n        if m1 < 0 or m2 < 0 or f1 - m1 == f2 - m2 == ans:\r\n            return ans - 1  # 火只会跟在人的后面，在到达终点前，人和火不能重合\r\n        return ans  # 人和火可以同时到终点\r\n```\r\n\r\n```java [sol2-Java]\r\nclass Solution {\r\n    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n\r\n    public int maximumMinutes(int[][] grid) {\r\n        var res = bfs(grid, List.of(new int[]{0, 0}));\r\n        int manToHouseTime = res[0], m1 = res[1], m2 = res[2];\r\n        if (manToHouseTime < 0) return -1; // 人无法到终点\r\n\r\n        var fires = new ArrayList<int[]>();\r\n        for (var i = 0; i < grid.length; i++)\r\n            for (var j = 0; j < grid[i].length; j++)\r\n                if (grid[i][j] == 1) fires.add(new int[]{i, j});\r\n        res = bfs(grid, fires);\r\n        int fireToHouseTime = res[0], f1 = res[1], f2 = res[2];\r\n        if (fireToHouseTime < 0) return (int) 1e9; // 火无法到终点\r\n\r\n        var ans = fireToHouseTime - manToHouseTime;\r\n        if (ans < 0) return -1; // 火比人先到终点\r\n        if (m1 < 0 || m2 < 0 || f1 - m1 == ans && f2 - m2 == ans)\r\n            return ans - 1; // 火只会跟在人的后面，在到达终点前，人和火不能重合\r\n        return ans;// 人和火可以同时到终点\r\n    }\r\n\r\n    int[] bfs(int[][] grid, List<int[]> q) {\r\n        int m = grid.length, n = grid[0].length;\r\n        var time = new int[m][n];\r\n        for (var i = 0; i < m; i++) Arrays.fill(time[i], -1);\r\n        for (var t = 0; q.size() > 0; t++) {\r\n            var tmp = q;\r\n            q = new ArrayList<>();\r\n            for (var p : tmp) {\r\n                time[p[0]][p[1]] = t;\r\n                for (var d : dirs) {\r\n                    int x = p[0] + d[0], y = p[1] + d[1];\r\n                    if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] == 0 && time[x][y] < 0)\r\n                        q.add(new int[]{x, y});\r\n                }\r\n            }\r\n        }\r\n        return new int[]{time[m - 1][n - 1], time[m - 1][n - 2], time[m - 2][n - 1]};\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol2-C++]\r\nconst int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n\r\nclass Solution {\r\npublic:\r\n    int maximumMinutes(vector<vector<int>> &grid) {\r\n        int m = grid.size(), n = grid[0].size();\r\n        auto bfs = [&](vector<pair<int, int>> &q) -> tuple<int, int, int> {\r\n            int time[m][n]; memset(time, -1, sizeof(time));\r\n            for (int t = 0; !q.empty(); ++t) {\r\n                vector<pair<int, int>> nq;\r\n                for (auto &[i, j] : q) {\r\n                    time[i][j] = t;\r\n                    for (auto[dx, dy] : dirs) {\r\n                        int x = i + dx, y = j + dy;\r\n                        if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] == 0 && time[x][y] < 0)\r\n                            nq.emplace_back(x, y);\r\n                    }\r\n                }\r\n                q = move(nq);\r\n            }\r\n            return {time[m - 1][n - 1], time[m - 1][n - 2], time[m - 2][n - 1]};\r\n        };\r\n\r\n        vector<pair<int, int>> q = {{0, 0}};\r\n        auto [man_to_house_time, m1, m2] = bfs(q);\r\n        if (man_to_house_time < 0) return -1; // 人无法到终点\r\n\r\n        vector<pair<int, int>> fires;\r\n        for (int i = 0; i < m; ++i)\r\n            for (int j = 0; j < n; ++j)\r\n                if (grid[i][j] == 1) fires.emplace_back(i, j);\r\n        auto [fire_to_house_time, f1, f2] = bfs(fires);\r\n        if (fire_to_house_time < 0) return 1e9; // 火无法到终点\r\n\r\n        int ans = fire_to_house_time - man_to_house_time;\r\n        if (ans < 0) return -1; // 火比人先到终点\r\n        if (m1 < 0 || m2 < 0 || f1 - m1 == ans && f2 - m2 == ans)\r\n            return ans - 1; // 火只会跟在人的后面，在到达终点前，人和火不能重合\r\n        return ans;// 人和火可以同时到终点\r\n    }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\ntype pair struct{ x, y int }\r\nvar dirs = []pair{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\r\n\r\nfunc maximumMinutes(grid [][]int) int {\r\n\tm, n := len(grid), len(grid[0])\r\n\tbfs := func(q []pair) (int, int, int) {\r\n\t\ttime := make([][]int, m)\r\n\t\tfor i := range time {\r\n\t\t\ttime[i] = make([]int, n)\r\n\t\t\tfor j := range time[i] {\r\n\t\t\t\ttime[i][j] = -1\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor t := 0; len(q) > 0; t++ {\r\n\t\t\ttmp := q\r\n\t\t\tq = nil\r\n\t\t\tfor _, p := range tmp {\r\n\t\t\t\ttime[p.x][p.y] = t\r\n\t\t\t\tfor _, d := range dirs {\r\n\t\t\t\t\tif x, y := p.x+d.x, p.y+d.y; 0 <= x && x < m && 0 <= y && y < n && grid[x][y] == 0 && time[x][y] < 0 {\r\n\t\t\t\t\t\tq = append(q, pair{x, y})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn time[m-1][n-1], time[m-1][n-2], time[m-2][n-1]\r\n\t}\r\n\r\n\tmanToHouseTime, m1, m2 := bfs([]pair{{}})\r\n\tif manToHouseTime < 0 {\r\n\t\treturn -1 // 人无法到终点\r\n\t}\r\n\r\n\tfires := []pair{}\r\n\tfor i, row := range grid {\r\n\t\tfor j, v := range row {\r\n\t\t\tif v == 1 {\r\n\t\t\t\tfires = append(fires, pair{i, j})\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfireToHouseTime, f1, f2 := bfs(fires)\r\n\tif fireToHouseTime < 0 {\r\n\t\treturn 1e9 // 火无法到终点\r\n\t}\r\n\r\n\tans := fireToHouseTime - manToHouseTime\r\n\tif ans < 0 {\r\n\t\treturn -1 // 火比人先到终点\r\n\t}\r\n\tif m1 < 0 || m2 < 0 || f1-m1 == ans && f2-m2 == ans {\r\n\t\treturn ans - 1 // 火只会跟在人的后面，在到达终点前，人和火不能重合\r\n\t}\r\n\treturn ans // 人和火可以同时到终点\r\n}\r\n```\r\n"
}