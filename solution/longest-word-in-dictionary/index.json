{
	"titleSlug": "longest-word-in-dictionary",
	"slug": "ci-dian-zhong-zui-chang-de-dan-ci-by-lee-k5gj",
	"url": "https://leetcode-cn.com/problems/longest-word-in-dictionary/solution/ci-dian-zhong-zui-chang-de-dan-ci-by-lee-k5gj/",
	"content": "#### 方法一：哈希集合\n\n**思路和算法**\n\n定义「符合要求的单词」如下：\n\n- 空字符串是符合要求的单词；\n\n- 在符合要求的单词的末尾添加一个字母，得到的新单词是符合要求的单词。\n\n这道题要求返回数组 $\\textit{words}$ 中的最长的符合要求的单词，如果有多个最长的符合要求的单词则返回其中字典序最小的单词。以下将返回值称为「答案」。\n\n为了方便处理，需要将数组 $\\textit{words}$ 排序，排序的规则是首先按照单词的长度升序排序，如果单词的长度相同则按照字典序降序排序。排序之后，可以确保当遍历到每个单词时，比该单词短的全部单词都已经遍历过，且每次遇到符合要求的单词一定是最长且字典序最小的单词，可以直接更新答案。\n\n将答案初始化为空字符串。使用哈希集合存储所有符合要求的单词，初始时将空字符串加入哈希集合。遍历数组 $\\textit{words}$，对于每个单词，判断当前单词去掉最后一个字母之后的前缀是否在哈希集合中，如果该前缀在哈希集合中则当前单词是符合要求的单词，将当前单词加入哈希集合，并将答案更新为当前单词。\n\n遍历结束之后，返回答案。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def longestWord(self, words: List[str]) -> str:\n        words.sort(key=lambda x: (-len(x), x), reverse=True)\n        longest = \"\"\n        candidates = {\"\"}\n        for word in words:\n            if word[:-1] in candidates:\n                longest = word\n                candidates.add(word)\n        return longest\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String longestWord(String[] words) {\n        Arrays.sort(words, (a, b) ->  {\n            if (a.length() != b.length()) {\n                return a.length() - b.length();\n            } else {\n                return b.compareTo(a);\n            }\n        });\n        String longest = \"\";\n        Set<String> candidates = new HashSet<String>();\n        candidates.add(\"\");\n        int n = words.length;\n        for (int i = 0; i < n; i++) {\n            String word = words[i];\n            if (candidates.contains(word.substring(0, word.length() - 1))) {\n                candidates.add(word);\n                longest = word;\n            }\n        }\n        return longest;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string LongestWord(string[] words) {\n        Array.Sort(words, (a, b) =>  {\n            if (a.Length != b.Length) {\n                return a.Length - b.Length;\n            } else {\n                return b.CompareTo(a);\n            }\n        });\n        string longest = \"\";\n        ISet<string> candidates = new HashSet<string>();\n        candidates.Add(\"\");\n        int n = words.Length;\n        for (int i = 0; i < n; i++) {\n            string word = words[i];\n            if (candidates.Contains(word.Substring(0, word.Length - 1))) {\n                candidates.Add(word);\n                longest = word;\n            }\n        }\n        return longest;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string longestWord(vector<string> &words) {\n        sort(words.begin(), words.end(), [](const string &a, const string &b) {\n            return a.size() != b.size() ? a.size() < b.size() : a > b;\n        });\n        string longest;\n        unordered_set<string> candidates = {\"\"};\n        for (const auto &word: words) {\n            if (candidates.count(word.substr(0, word.size() - 1))) {\n                candidates.emplace(word);\n                longest = word;\n            }\n        }\n        return longest;\n    }\n};\n```\n\n```C [sol1-C]\n#define MAX_STR_LEN 32\n\ntypedef struct {\n    char * key;\n    UT_hash_handle hh;\n} HashEntry;\n\nvoid hashInsert(HashEntry ** obj, const char * str) {\n    HashEntry * pEntry = NULL;\n    HASH_FIND_STR(*obj, str, pEntry);\n    if (NULL == pEntry) {\n        pEntry = (HashEntry *)malloc(sizeof(HashEntry));\n        pEntry->key = str;\n        HASH_ADD_STR(*obj, key, pEntry);\n    }\n}\n\nbool hashFind(const HashEntry ** obj, const char * str) {\n    HashEntry * pEntry = NULL;\n    HASH_FIND_STR(*obj, str, pEntry);\n    if (NULL == pEntry) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nbool hashRelease(HashEntry ** obj) {\n    HashEntry * curr = NULL, * next = NULL;\n     HASH_ITER(hh, *obj, curr, next) {\n      HASH_DEL(*obj, curr);\n      free(curr);\n    }\n    return true;\n}\n\nint cmp(const void * a, const void * b) {\n    char * pa = *(char **)a;\n    char * pb = *(char **)b;\n    int la = strlen(pa);\n    int lb = strlen(pb);\n    if (la != lb) {\n        return la - lb;\n    } else {\n        return strcmp(pb, pa);\n    }\n}\n\nchar * longestWord(char ** words, int wordsSize){\n    qsort(words, wordsSize, sizeof(char *), cmp);\n    char * longest = \"\";\n    HashEntry * candidates = NULL;\n    hashInsert(&candidates, \"\");\n    char str[MAX_STR_LEN] = {0};\n    for (int i = 0; i < wordsSize; i++) {\n        snprintf(str, strlen(words[i]), \"%s\", words[i]);\n        if (hashFind(&candidates, str)) {\n            hashInsert(&candidates, words[i]);\n            longest = words[i];\n        }\n    }\n    hashRelease(&candidates);\n    return longest;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar longestWord = function(words) {\n    words.sort((a, b) => {\n        if (a.length !== b.length) {\n            return a.length - b.length;\n        } else {\n            return b.localeCompare(a);\n        }\n    })\n    let longest = \"\";\n    let candidates = new Set();\n    candidates.add(\"\");\n    const n = words.length;\n    for (let i = 0; i < n; i++) {\n        const word = words[i];\n        if (candidates.has(word.slice(0, word.length - 1))) {\n            candidates.add(word);\n            longest = word;\n        }\n    }\n    return longest;\n};\n```\n\n```go [sol1-Golang]\nfunc longestWord(words []string) (longest string) {\n    sort.Slice(words, func(i, j int) bool {\n        s, t := words[i], words[j]\n        return len(s) < len(t) || len(s) == len(t) && s > t\n    })\n\n    candidates := map[string]struct{}{\"\": {}}\n    for _, word := range words {\n        if _, ok := candidates[word[:len(word)-1]]; ok {\n            longest = word\n            candidates[word] = struct{}{}\n        }\n    }\n    return longest\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\sum_{0 \\le i < n} l_i \\times \\log n)$，其中 $n$ 是数组 $\\textit{words}$ 的长度，$l_i$ 是单词 $\\textit{words}[i]$ 的长度。对数组 $\\textit{words}$ 排序最多需要 $O(\\sum_{0 \\le i < n} l_i \\times \\log n)$ 的时间，排序后遍历数组 $\\textit{words}$ 将单词加入哈希集合并得到答案最多需要 $O(\\sum_{0 \\le i < n} l_i)$ 的时间。由于在渐进意义下 $O(\\sum_{0 \\le i < n} l_i)$ 小于 $O(\\sum_{0 \\le i < n} l_i \\times \\log n)$，因此时间复杂度是 $O(\\sum_{0 \\le i < n} l_i \\times \\log n)$。\n\n- 空间复杂度：$O(\\sum_{0 \\le i < n} l_i)$，其中 $n$ 是数组 $\\textit{words}$ 的长度，$l_i$ 是单词 $\\textit{words}[i]$ 的长度。排序需要 $O(\\log n)$ 的空间，哈希集合需要 $O(\\sum_{0 \\le i < n} l_i)$ 的空间，由于在渐进意义下 $O(\\log n)$ 小于 $O(\\sum_{0 \\le i < n} l_i)$，因此空间复杂度是 $O(\\sum_{0 \\le i < n} l_i)$。\n\n#### 方法二：字典树\n\n**预备知识**\n\n该方法需要使用字典树。如果读者对字典树不了解，建议首先阅读「[208. 实现 Trie (前缀树) 的官方题解](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/)」，在理解字典树的实现之后继续阅读。\n\n**思路和算法**\n\n由于符合要求的单词的每个前缀都是符合要求的单词，因此可以使用字典树存储所有符合要求的单词。\n\n创建字典树，遍历数组 $\\textit{words}$ 并将每个单词插入字典树。当所有的单词都插入字典树之后，将答案初始化为空字符串，再次遍历数组 $\\textit{words}$，判断每个单词是否是符合要求的单词，并更新答案。如果一个单词是符合要求的单词，则比较当前单词与答案，如果当前单词的长度大于答案的长度，或者当前单词的长度等于答案的长度且当前单词的字典序小于答案的字典序，则将答案更新为当前单词。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEnd = False\n\n    def insert(self, word: str) -> None:\n        node = self\n        for ch in word:\n            ch = ord(ch) - ord('a')\n            if not node.children[ch]:\n                node.children[ch] = Trie()\n            node = node.children[ch]\n        node.isEnd = True\n\n    def search(self, word: str) -> bool:\n        node = self\n        for ch in word:\n            ch = ord(ch) - ord('a')\n            if node.children[ch] is None or not node.children[ch].isEnd:\n                return False\n            node = node.children[ch]\n        return True\n\nclass Solution:\n    def longestWord(self, words: List[str]) -> str:\n        t = Trie()\n        for word in words:\n            t.insert(word)\n        longest = \"\"\n        for word in words:\n            if t.search(word) and (len(word) > len(longest) or len(word) == len(longest) and word < longest):\n                longest = word\n        return longest\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public String longestWord(String[] words) {\n        Trie trie = new Trie();\n        for (String word : words) {\n            trie.insert(word);\n        }\n        String longest = \"\";\n        for (String word : words) {\n            if (trie.search(word)) {\n                if (word.length() > longest.length() || (word.length() == longest.length() && word.compareTo(longest) < 0)) {\n                    longest = word;\n                }\n            }\n        }\n        return longest;\n    }\n}\n\nclass Trie {\n    Trie[] children;\n    boolean isEnd;\n\n    public Trie() {\n        children = new Trie[26];\n        isEnd = false;\n    }\n    \n    public void insert(String word) {\n        Trie node = this;\n        for (int i = 0; i < word.length(); i++) {\n            char ch = word.charAt(i);\n            int index = ch - 'a';\n            if (node.children[index] == null) {\n                node.children[index] = new Trie();\n            }\n            node = node.children[index];\n        }\n        node.isEnd = true;\n    }\n    \n    public boolean search(String word) {\n        Trie node = this;\n        for (int i = 0; i < word.length(); i++) {\n            char ch = word.charAt(i);\n            int index = ch - 'a';\n            if (node.children[index] == null || !node.children[index].isEnd) {\n                return false;\n            }\n            node = node.children[index];\n        }\n        return node != null && node.isEnd;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public string LongestWord(string[] words) {\n        Trie trie = new Trie();\n        foreach (string word in words) {\n            trie.Insert(word);\n        }\n        string longest = \"\";\n        foreach (string word in words) {\n            if (trie.Search(word)) {\n                if (word.Length > longest.Length || (word.Length == longest.Length && word.CompareTo(longest) < 0)) {\n                    longest = word;\n                }\n            }\n        }\n        return longest;\n    }\n}\n\nclass Trie {\n    public Trie[] Children { get; set; }\n    public bool IsEnd { get; set; }\n\n    public Trie() {\n        Children = new Trie[26];\n        IsEnd = false;\n    }\n    \n    public void Insert(string word) {\n        Trie node = this;\n        for (int i = 0; i < word.Length; i++) {\n            char ch = word[i];\n            int index = ch - 'a';\n            if (node.Children[index] == null) {\n                node.Children[index] = new Trie();\n            }\n            node = node.Children[index];\n        }\n        node.IsEnd = true;\n    }\n    \n    public bool Search(string word) {\n        Trie node = this;\n        for (int i = 0; i < word.Length; i++) {\n            char ch = word[i];\n            int index = ch - 'a';\n            if (node.Children[index] == null || !node.Children[index].IsEnd) {\n                return false;\n            }\n            node = node.Children[index];\n        }\n        return node != null && node.IsEnd;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Trie {\npublic:\n    Trie() {\n        this->children = vector<Trie *>(26, nullptr);\n        this->isEnd = false;\n    }\n    \n    bool insert(const string & word) {\n        Trie * node = this;\n        for (const auto & ch : word) {\n            int index = ch - 'a';\n            if (node->children[index] == nullptr) {\n                node->children[index] = new Trie();\n            }\n            node = node->children[index];\n        }\n        node->isEnd = true;\n        return true;\n    }\n\n    bool search(const string & word) {\n        Trie * node = this;\n        for (const auto & ch : word) {\n            int index = ch - 'a';\n            if (node->children[index] == nullptr || !node->children[index]->isEnd) {\n                return false;\n            }\n            node = node->children[index];\n        }\n        return node != nullptr && node->isEnd;\n    }\nprivate:\n    vector<Trie *> children;\n    bool isEnd;\n};\n\nclass Solution {\npublic:\n    string longestWord(vector<string>& words) {\n        Trie trie;\n        for (const auto & word : words) {\n            trie.insert(word);\n        }\n        string longest = \"\";\n        for (const auto & word : words) {\n            if (trie.search(word)) {\n                if (word.size() > longest.size() || (word.size() == longest.size() && word < longest)) {\n                    longest = word;\n                }\n            }\n        }\n        return longest;\n    }\n};\n```\n\n```C [sol2-C]\n#define MAX_STR_LEN 32\n\ntypedef struct Trie {\n    struct Trie * children[26];\n    bool isEnd;\n} Trie;\n\n\nvoid initTrie(Trie * trie) {\n    for (int i = 0; i < 26; i++) {\n        trie->children[i] = NULL;\n    }\n    trie->isEnd = false;\n}\n\nbool insertTrie(Trie * trie, const char * word) {\n    Trie * node = trie;\n    int len = strlen(word);\n    for (int i = 0; i < len; i++) {\n        char ch = word[i];\n        int index = ch - 'a';\n        if (node->children[index] == NULL) {\n            node->children[index] = (Trie *)malloc(sizeof(Trie));\n            initTrie(node->children[index]);\n        }\n        node = node->children[index];\n    }\n    node->isEnd = true;\n    return true;\n}\n\nbool searchTrie(const Trie * trie, const char * word) {\n    Trie * node = trie;\n    int len = strlen(word);\n    for (int i = 0; i < len; i++) {\n        char ch = word[i];\n        int index = ch - 'a';\n        if (node->children[index] == NULL || !node->children[index]->isEnd) {\n            return false;\n        }\n        node = node->children[index];\n    }\n    return node != NULL && node->isEnd;\n}\n\nchar * longestWord(char ** words, int wordsSize){\n    Trie * trie = (Trie *)malloc(sizeof(Trie));\n    initTrie(trie);\n    for (int i = 0; i < wordsSize; i++) {\n        insertTrie(trie, words[i]);\n    }\n    char * longest = \"\";\n    for (int i = 0; i < wordsSize; i++) {\n        if (searchTrie(trie, words[i])) {\n            if (strlen(words[i]) > strlen(longest) || (strlen(words[i]) == strlen(longest) && strcmp(words[i], longest) < 0)) {\n                longest = words[i];\n            }\n        }\n    }\n    return longest;\n}\n```\n\n```go [sol2-Golang]\ntype Trie struct {\n\tchildren [26]*Trie\n\tisEnd    bool\n}\n\nfunc (t *Trie) Insert(word string) {\n\tnode := t\n\tfor _, ch := range word {\n\t\tch -= 'a'\n\t\tif node.children[ch] == nil {\n\t\t\tnode.children[ch] = &Trie{}\n\t\t}\n\t\tnode = node.children[ch]\n\t}\n\tnode.isEnd = true\n}\n\nfunc (t *Trie) Search(word string) bool {\n\tnode := t\n\tfor _, ch := range word {\n\t\tch -= 'a'\n\t\tif node.children[ch] == nil || !node.children[ch].isEnd {\n\t\t\treturn false\n\t\t}\n\t\tnode = node.children[ch]\n\t}\n\treturn true\n}\n\nfunc longestWord(words []string) (longest string) {\n\tt := &Trie{}\n\tfor _, word := range words {\n\t\tt.Insert(word)\n\t}\n\tfor _, word := range words {\n\t\tif t.Search(word) && (len(word) > len(longest) || len(word) == len(longest) && word < longest) {\n\t\t\tlongest = word\n\t\t}\n\t}\n\treturn longest\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar longestWord = function(words) {\n    const trie = new Trie();\n    for (const word of words) {\n        trie.insert(word);\n    }\n    let longest = \"\";\n    for (const word of words) {\n        if (trie.search(word)) {\n            if (word.length > longest.length || (word.length === longest.length && word.localeCompare(longest) < 0)) {\n                longest = word;\n            }\n        }\n    }\n    return longest;\n};\n\nclass Node {\n    constructor() {\n        this.children = {};\n        this.isEnd = false;\n    }\n}\n\nclass Trie {\n    constructor() {\n        this.children = new Node();\n        this.isEnd = false;\n    }\n\n    insert(word) {\n        let node = this;\n        for (let i = 0; i < word.length; i++) {\n            const ch = word[i];\n            const index = ch.charCodeAt() - 'a'.charCodeAt();\n            if (!node.children[index]) {\n                node.children[index] = new Node();\n            }\n            node = node.children[index];\n        }\n        node.isEnd = true;\n    }\n\n    search(word) {\n        let node = this;\n        for (let i = 0; i < word.length; i++) {\n            const ch = word[i];\n            const index = ch.charCodeAt() - 'a'.charCodeAt();\n            if (!node.children[index] || !node.children[index].isEnd) {\n                return false;\n            }\n            node = node.children[index];\n        }\n        return node && node.isEnd;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\sum_{0 \\le i < n} l_i)$，其中 $n$ 是数组 $\\textit{words}$ 的长度，$l_i$ 是单词 $\\textit{words}[i]$ 的长度。将数组 $\\textit{words}$ 中的每个单词加入字典树需要 $O(\\sum_{0 \\le i < n} l_i)$ 的时间，在字典树中判断每个单词是否符合要求并得到答案也需要 $O(\\sum_{0 \\le i < n} l_i)$ 的时间。\n\n- 空间复杂度：$O(\\sum_{0 \\le i < n} l_i)$，其中 $n$ 是数组 $\\textit{words}$ 的长度，$l_i$ 是单词 $\\textit{words}[i]$ 的长度。字典树最多需要 $O(\\sum_{0 \\le i < n} l_i)$ 的空间。"
}