{
	"titleSlug": "subdomain-visit-count",
	"slug": "zi-yu-ming-fang-wen-ji-shu-by-leetcode-s-0a6i",
	"url": "https://leetcode-cn.com/problems/subdomain-visit-count/solution/zi-yu-ming-fang-wen-ji-shu-by-leetcode-s-0a6i/",
	"content": "#### 方法一：哈希表\n\n每个计数配对域名的格式都是 $\\texttt{\"rep d1.d2.d3\"}$ 或 $\\texttt{\"rep d1.d2\"}$。子域名的计数如下：\n\n- 对于格式 $\\texttt{\"rep d1.d2.d3\"}$，有三个子域名 $\\texttt{\"d1.d2.d3\"}$、$\\texttt{\"d2.d3\"}$ 和 $\\texttt{\"d3\"}$，每个子域名各被访问 $\\texttt{rep}$ 次；\n\n- 对于格式 $\\texttt{\"rep d1.d2\"}$，有两个子域名 $\\texttt{\"d1.d2\"}$ 和 $\\texttt{\"d2\"}$，每个子域名各被访问 $\\texttt{rep}$ 次。\n\n为了获得每个子域名的计数配对域名，需要使用哈希表记录每个子域名的计数。遍历数组 $\\textit{cpdomains}$，对于每个计数配对域名，获得计数和完整域名，更新哈希表中的每个子域名的访问次数。\n\n遍历数组 $\\textit{cpdomains}$ 之后，遍历哈希表，对于哈希表中的每个键值对，关键字是子域名，值是计数，将计数和子域名拼接得到计数配对域名，添加到答案中。\n\n```Python [sol1-Python3]\nclass Solution:\n    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:\n        cnt = Counter()\n        for domain in cpdomains:\n            c, s = domain.split()\n            c = int(c)\n            cnt[s] += c\n            while '.' in s:\n                s = s[s.index('.') + 1:]\n                cnt[s] += c\n        return [f\"{c} {s}\" for s, c in cnt.items()]\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<String> subdomainVisits(String[] cpdomains) {\n        List<String> ans = new ArrayList<String>();\n        Map<String, Integer> counts = new HashMap<String, Integer>();\n        for (String cpdomain : cpdomains) {\n            int space = cpdomain.indexOf(' ');\n            int count = Integer.parseInt(cpdomain.substring(0, space));\n            String domain = cpdomain.substring(space + 1);\n            counts.put(domain, counts.getOrDefault(domain, 0) + count);\n            for (int i = 0; i < domain.length(); i++) {\n                if (domain.charAt(i) == '.') {\n                    String subdomain = domain.substring(i + 1);\n                    counts.put(subdomain, counts.getOrDefault(subdomain, 0) + count);\n                }\n            }\n        }\n        for (Map.Entry<String, Integer> entry : counts.entrySet()) {\n            String subdomain = entry.getKey();\n            int count = entry.getValue();\n            ans.add(count + \" \" + subdomain);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<string> SubdomainVisits(string[] cpdomains) {\n        IList<string> ans = new List<string>();\n        Dictionary<string, int> counts = new Dictionary<string, int>();\n        foreach (string cpdomain in cpdomains) {\n            int space = cpdomain.IndexOf(' ');\n            int count = int.Parse(cpdomain.Substring(0, space));\n            string domain = cpdomain.Substring(space + 1);\n            if (!counts.ContainsKey(domain)) {\n                counts.Add(domain, 0);\n            }\n            counts[domain] += count;\n            for (int i = 0; i < domain.Length; i++) {\n                if (domain[i] == '.') {\n                    string subdomain = domain.Substring(i + 1);\n                    if (!counts.ContainsKey(subdomain)) {\n                        counts.Add(subdomain, 0);\n                    }\n                    counts[subdomain] += count;\n                }\n            }\n        }\n        foreach (KeyValuePair<string, int> pair in counts) {\n            string subdomain = pair.Key;\n            int count = pair.Value;\n            ans.Add(count + \" \" + subdomain);\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<string> subdomainVisits(vector<string>& cpdomains) {\n        vector<string> ans;\n        unordered_map<string, int> counts;\n        for (auto &&cpdomain : cpdomains) {\n            int space = cpdomain.find(' ');\n            int count = stoi(cpdomain.substr(0, space));\n            string domain = cpdomain.substr(space + 1);\n            counts[domain] += count;\n            for (int i = 0; i < domain.size(); i++) {\n                if (domain[i] == '.') {\n                    string subdomain = domain.substr(i + 1);\n                    counts[subdomain] += count;\n                }\n            }\n        }\n        for (auto &&[subdomain, count] : counts) {\n            ans.emplace_back(to_string(count) + \" \" + subdomain);\n        }\n        return ans;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    const char *key;\n    int val;\n    UT_hash_handle hh;\n} HashItem; \n\nHashItem *hashFindItem(HashItem **obj, const char *key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_STR(*obj, key, pEntry);\n    return pEntry;\n}\n\nbool hashAddItem(HashItem **obj, const char* key, int val) {\n    if (hashFindItem(obj, key)) {\n        return false;\n    }\n    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = key;\n    pEntry->val = val;\n    HASH_ADD_STR(*obj, key, pEntry);\n    return true;\n}\n\nbool hashSetItem(HashItem **obj, const char* key, int val) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        hashAddItem(obj, key, val);\n    } else {\n        pEntry->val = val;\n    }\n    return true;\n}\n\nint hashGetItem(HashItem **obj, char* key, int defaultVal) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        return defaultVal;\n    }\n    return pEntry->val;\n}\n\nvoid hashFree(HashItem **obj) {\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);             \n    }\n}\n\nchar ** subdomainVisits(char ** cpdomains, int cpdomainsSize, int* returnSize){\n    HashItem *counts = NULL;\n    for (int i = 0; i < cpdomainsSize; i++) {\n        int space = strchr(cpdomains[i], ' ') - cpdomains[i];\n        int count = atoi(cpdomains[i]);\n        char *domain = cpdomains[i] + space + 1;\n        hashSetItem(&counts, domain, hashGetItem(&counts, domain, 0) + count);\n        int len = strlen(domain);\n        for (int j = 0; j < len; j++) {\n            if (domain[j] == '.') {\n                char *subdomain = domain + j + 1;\n                hashSetItem(&counts, subdomain, hashGetItem(&counts, subdomain, 0) + count);\n            }\n        }\n    }\n    char **ans = (char **)malloc(sizeof(char *) * cpdomainsSize * 4);\n    int pos = 0;\n    *returnSize = HASH_COUNT(counts);\n    for (HashItem *pEntry = counts; pEntry != NULL; pEntry = pEntry->hh.next) {\n        ans[pos] = (char *)malloc(sizeof(char) * (strlen(pEntry->key) + 32));\n        sprintf(ans[pos], \"%d %s\", pEntry->val, pEntry->key);\n        pos++;\n    }\n    hashFree(&counts);\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar subdomainVisits = function(cpdomains) {\n    const ans = [];\n    const counts = new Map();\n    for (const cpdomain of cpdomains) {\n        const space = cpdomain.indexOf(' ');\n        const count = parseInt(cpdomain.slice(0, space));\n        const domain = cpdomain.slice(space + 1);\n        counts.set(domain, (counts.get(domain) || 0) + count);\n        for (let i = 0; i < domain.length; i++) {\n            if (domain[i] === '.') {\n                const subdomain = domain.slice(i + 1);\n                counts.set(subdomain, (counts.get(subdomain) || 0) + count);\n            }\n        }\n    }\n    for (const [subdomain, count] of counts.entries()) {\n        ans.push(count + \" \" + subdomain);\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc subdomainVisits(cpdomains []string) []string {\n    cnt := map[string]int{}\n    for _, s := range cpdomains {\n        i := strings.IndexByte(s, ' ')\n        c, _ := strconv.Atoi(s[:i])\n        s = s[i+1:]\n        cnt[s] += c\n        for {\n            i := strings.IndexByte(s, '.')\n            if i < 0 {\n                break\n            }\n            s = s[i+1:]\n            cnt[s] += c\n        }\n    }\n    ans := make([]string, 0, len(cnt))\n    for s, c := range cnt {\n        ans = append(ans, strconv.Itoa(c)+\" \"+s)\n    }\n    return ans\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(L)$，其中 $L$ 是数组 $\\textit{cpdomains}$ 中的所有字符串长度之和。遍历数组中所有的计数配对域名计算每个子域名的计数需要 $O(L)$ 的时间，遍历哈希表也需要 $O(L)$ 的时间。\n\n- 空间复杂度：$O(L)$，其中 $L$ 是数组 $\\textit{cpdomains}$ 中的所有字符串长度之和。哈希表需要 $O(L)$ 的空间。"
}