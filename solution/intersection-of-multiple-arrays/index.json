{
	"titleSlug": "intersection-of-multiple-arrays",
	"slug": "duo-ge-shu-zu-qiu-jiao-ji-by-leetcode-so-5c9z",
	"url": "https://leetcode-cn.com/problems/intersection-of-multiple-arrays/solution/duo-ge-shu-zu-qiu-jiao-ji-by-leetcode-so-5c9z/",
	"content": "#### 方法一：模拟\n\n**思路与算法**\n\n我们可以用哈希集合来模拟求解交集的过程。具体地，我们用哈希集合 $\\textit{res}$ 存储第一个数组 $\\textit{nums}[0]$ 的所有元素，随后，我们遍历二维数组 $\\textit{nums}$ 的剩余元素。遍历元素 $\\textit{nums}[i]$ 时，我们用另一个哈希集合 $\\textit{tmp}$ 来存储 $\\textit{res}$ 和 $\\textit{nums}[i]$ 中元素的交集。我们可以通过遍历 $\\textit{nums}[i]$ 判断每个元素是否在 $\\textit{res}$ 中。最后，我们令 $\\textit{res} = \\textit{tmp}$，即为前 $i + 1$ 个数组的交集。\n\n最终，$\\textit{res}$ 即为所有数组的元素交集。我们用数组记录哈希集合 $\\textit{res}$ 的所有元素，并排序后作为答案返回。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> intersection(vector<vector<int>>& nums) {\n        int n = nums.size();\n        unordered_set<int> res(nums[0].begin(), nums[0].end());\n        for (int i = 1; i < n; ++i) {\n            unordered_set<int> tmp;\n            for (int num: nums[i]) {\n                if (res.count(num)) {\n                    tmp.insert(num);\n                }\n            }\n            res = tmp;\n        }\n        vector<int> ans(res.begin(), res.end());\n        sort(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        n = len(nums)\n        res = set(nums[0])\n        for i in range(1, n):\n            tmp = set()\n            for num in nums[i]:\n                if num in res:\n                    tmp.add(num)\n            res = tmp\n        return sorted(res)\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\sum_i n_i + \\min(n_i)\\log\\min(n_i))$，其中 $n_i$ 为 $\\textit{nums}[i]$ 的长度。其中遍历求交集的时间复杂度为 $O(\\sum_i n_i)$，对结果排序的时间复杂度为 $O(\\min(n_i)\\log\\min(n_i))$。\n\n- 空间复杂度：$O(\\max(n_i))$，即为辅助哈希集合的空间开销。\n\n\n#### 方法二：统计每个整数的出现次数\n\n**思路与算法**\n\n我们用 $n$ 表示二维数组 $\\textit{nums}$ 的长度。由于二维数组 $\\textit{nums}$ 里面的每个数组中的元素互不相同，因此如果一个元素在每个数组中均出现过，则它在 $\\textit{nums}$ 中的出现次数应当等于 $n$。\n\n因此我们可以用哈希表 $\\textit{freq}$ 维护每个整数的出现次数，随后我们遍历 $\\textit{nums}$ 并维护哈希表 $\\textit{freq}$。最终，我们遍历 $\\textit{freq}$ 并用 $\\textit{res}$ 数组记录所有出现次数等于 $n$ 的整数，然后返回排序后的 $\\textit{res}$ 数组作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> intersection(vector<vector<int>>& nums) {\n        int n = nums.size();\n        unordered_map<int, int> freq;\n        for (const auto& arr: nums) {\n            for (int num: arr) {\n                ++freq[num];\n            }\n        }\n        vector<int> res;\n        for (const auto& [k, v]: freq) {\n            if (v == n) {\n                res.push_back(k);\n            }\n        }\n        sort(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        n = len(nums)\n        freq = defaultdict(int)\n        for arr in nums:\n            for num in arr:\n                freq[num] += 1\n        res = []\n        for k, v in freq.items():\n            if v == n:\n                res.append(k)\n        return sorted(res)\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\sum_i n_i + \\min(n_i)\\log\\min(n_i))$，其中 $n_i$ 为 $\\textit{nums}[i]$ 的长度。即为遍历统计每个整数出现次数，遍历哈希表统计结果以及排序的时间复杂度。\n\n- 空间复杂度：$O(\\max_i n_i)$，即为辅助哈希表的时间复杂度。"
}