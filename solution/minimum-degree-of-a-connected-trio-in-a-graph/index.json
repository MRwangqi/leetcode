{
	"titleSlug": "minimum-degree-of-a-connected-trio-in-a-graph",
	"slug": "gei-wu-xiang-tu-ding-xiang-by-lucifer100-c72d",
	"url": "https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/solution/gei-wu-xiang-tu-ding-xiang-by-lucifer100-c72d/",
	"content": "### 方法一：暴力\n\n数据范围$N\\leq400$是一个典型的$\\mathcal{O}(N^3)$范围，所以直接暴力枚举三元组即可。\n\n为了快速判断连通性，可以先把边集转为邻接矩阵。同时我们统计每个点的度数，方便最后计算总度数（对于一个连通三元组，总度数为三个点的总度数减去它们内部的度数，也就是$2\\times3=6$）。\n\n- 时间复杂度$\\mathcal{O}(N^3)$。\n- 空间复杂度$\\mathcal{O}(N^2)$。\n\n```cpp\nclass Solution {\npublic:\n    int minTrioDegree(int n, vector<vector<int>>& edges) {\n        vector<vector<bool>> d(n, vector<bool>(n));\n        vector<int> deg(n);\n        for (auto &e : edges) {\n            d[e[0] - 1][e[1] - 1] = d[e[1] - 1][e[0] - 1] = true;\n            deg[e[0] - 1]++;\n            deg[e[1] - 1]++;\n        }\n        int ans = INT_MAX;\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                if (!d[i][j])\n                    continue;\n                for (int k = j + 1; k < n; ++k) {\n                    if (d[i][k] && d[j][k]) \n                        ans = min(ans, deg[i] + deg[j] + deg[k] - 6);\n                }\n            }\n        return ans == INT_MAX ? -1 : ans;\n    }\n};\n```\n\n### 方法二：给无向图定向\n\n考虑更大的数据范围$N\\leq2\\times10^5,M\\leq\\min(\\frac{N(N-1)}{2},2\\times10^5)$。此时上面的暴力解法显然不再成立。\n\n一个可行的做法是给无向图定向。这里需要用到一些推导。\n\n- 我们把所有边的方向定为从度数小的点连向度数大的点（如果度数相等则可以任意连接，下面的参考代码中是从标号小的连向标号大的）。\n- 可以证明，此时任意点的出度不会超过$\\sqrt{2M}$。因为如果一个点的出度超过了$\\sqrt{2M}$，则由于我们上面的规则，可知这些点的度数也都大于$\\sqrt{2M}$，从而这些点的总度数将超过$2M$，而这是不可能的。\n\n有了这一保证，我们就可以逐个枚举第一个点$u$，枚举其所有相邻点$v$，然后枚举$v$的所有相邻点$w$，检查$u,v,w$是否能构成连通三元组，然后更新答案。\n\n总复杂度是多少呢？枚举$u$和$v$的时间复杂度是$\\mathcal{O}(M)$；而对于每一对$(u,v)$，由于$v$的出度不超过$\\sqrt{2M}$，所以枚举$w$的时间复杂度是$\\mathcal{O}(\\sqrt{M})$。\n\n- 时间复杂度$\\mathcal{O}(M^{\\frac{3}{2}})$。\n- 空间复杂度$\\mathcal{O}(N+M)$。\n\n```cpp\nclass Solution {\npublic:\n    int minTrioDegree(int n, vector<vector<int>>& edges) {\n        vector<unordered_set<int>> d(n);\n        for (auto &e : edges) {\n            int u = e[0] - 1, v = e[1] - 1;\n            d[u].insert(v), d[v].insert(u);\n        }\n        \n        vector<vector<int>> adj(n);\n        for (auto &e : edges) {\n            int u = e[0] - 1, v = e[1] - 1;\n            if (d[u].size() < d[v].size() || (d[u].size() == d[v].size() && u < v))\n                adj[u].emplace_back(v);\n            else\n                adj[v].emplace_back(u);\n        }\n\n        int ans = INT_MAX;\n        for (int u = 0; u < n; ++u)\n            for (int v : adj[u])\n                for (int w : adj[v])\n                    if (d[u].count(w))\n                        ans = min(ans, (int)(d[u].size() + d[v].size() + d[w].size() - 6));\n        \n        return ans == INT_MAX ? -1 : ans;\n    }\n};\n```"
}