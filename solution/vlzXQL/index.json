{
	"titleSlug": "vlzXQL",
	"slug": "ji-suan-chu-fa-by-leetcode-solution-p731",
	"url": "https://leetcode-cn.com/problems/vlzXQL/solution/ji-suan-chu-fa-by-leetcode-solution-p731/",
	"content": "#### 方法一：广度优先搜索\n\n我们可以将整个问题建模成一张图：给定图中的一些点（变量），以及某些边的权值（两个变量的比值），试对任意两点（两个变量）求出其路径长（两个变量的比值）。\n\n因此，我们首先需要遍历 $\\textit{equations}$ 数组，找出其中所有不同的字符串，并通过哈希表将每个不同的字符串映射成整数。\n\n在构建完图之后，对于任何一个查询，就可以从起点出发，通过广度优先搜索的方式，不断更新起点与当前点之间的路径长度，直到搜索到终点为止。\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        int nvars = 0;\n        unordered_map<string, int> variables;\n\n        int n = equations.size();\n        for (int i = 0; i < n; i++) {\n            if (variables.find(equations[i][0]) == variables.end()) {\n                variables[equations[i][0]] = nvars++;\n            }\n            if (variables.find(equations[i][1]) == variables.end()) {\n                variables[equations[i][1]] = nvars++;\n            }\n        }\n\n        // 对于每个点，存储其直接连接到的所有点及对应的权值\n        vector<vector<pair<int, double>>> edges(nvars);\n        for (int i = 0; i < n; i++) {\n            int va = variables[equations[i][0]], vb = variables[equations[i][1]];\n            edges[va].push_back(make_pair(vb, values[i]));\n            edges[vb].push_back(make_pair(va, 1.0 / values[i]));\n        }\n\n        vector<double> ret;\n        for (const auto& q: queries) {\n            double result = -1.0;\n            if (variables.find(q[0]) != variables.end() && variables.find(q[1]) != variables.end()) {\n                int ia = variables[q[0]], ib = variables[q[1]];\n                if (ia == ib) {\n                    result = 1.0;\n                } else {\n                    queue<int> points;\n                    points.push(ia);\n                    vector<double> ratios(nvars, -1.0);\n                    ratios[ia] = 1.0;\n\n                    while (!points.empty() && ratios[ib] < 0) {\n                        int x = points.front();\n                        points.pop();\n\n                        for (const auto [y, val]: edges[x]) {\n                            if (ratios[y] < 0) {\n                                ratios[y] = ratios[x] * val;\n                                points.push(y);\n                            }\n                        }\n                    }\n                    result = ratios[ib];\n                }\n            }\n            ret.push_back(result);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n        int nvars = 0;\n        Map<String, Integer> variables = new HashMap<String, Integer>();\n\n        int n = equations.size();\n        for (int i = 0; i < n; i++) {\n            if (!variables.containsKey(equations.get(i).get(0))) {\n                variables.put(equations.get(i).get(0), nvars++);\n            }\n            if (!variables.containsKey(equations.get(i).get(1))) {\n                variables.put(equations.get(i).get(1), nvars++);\n            }\n        }\n\n        // 对于每个点，存储其直接连接到的所有点及对应的权值\n        List<Pair>[] edges = new List[nvars];\n        for (int i = 0; i < nvars; i++) {\n            edges[i] = new ArrayList<Pair>();\n        }\n        for (int i = 0; i < n; i++) {\n            int va = variables.get(equations.get(i).get(0)), vb = variables.get(equations.get(i).get(1));\n            edges[va].add(new Pair(vb, values[i]));\n            edges[vb].add(new Pair(va, 1.0 / values[i]));\n        }\n\n        int queriesCount = queries.size();\n        double[] ret = new double[queriesCount];\n        for (int i = 0; i < queriesCount; i++) {\n            List<String> query = queries.get(i);\n            double result = -1.0;\n            if (variables.containsKey(query.get(0)) && variables.containsKey(query.get(1))) {\n                int ia = variables.get(query.get(0)), ib = variables.get(query.get(1));\n                if (ia == ib) {\n                    result = 1.0;\n                } else {\n                    Queue<Integer> points = new LinkedList<Integer>();\n                    points.offer(ia);\n                    double[] ratios = new double[nvars];\n                    Arrays.fill(ratios, -1.0);\n                    ratios[ia] = 1.0;\n\n                    while (!points.isEmpty() && ratios[ib] < 0) {\n                        int x = points.poll();\n                        for (Pair pair : edges[x]) {\n                            int y = pair.index;\n                            double val = pair.value;\n                            if (ratios[y] < 0) {\n                                ratios[y] = ratios[x] * val;\n                                points.offer(y);\n                            }\n                        }\n                    }\n                    result = ratios[ib];\n                }\n            }\n            ret[i] = result;\n        }\n        return ret;\n    }\n}\n\nclass Pair {\n    int index;\n    double value;\n\n    Pair(int index, double value) {\n        this.index = index;\n        this.value = value;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\n    // 给方程组中的每个变量编号\n    id := map[string]int{}\n    for _, eq := range equations {\n        a, b := eq[0], eq[1]\n        if _, has := id[a]; !has {\n            id[a] = len(id)\n        }\n        if _, has := id[b]; !has {\n            id[b] = len(id)\n        }\n    }\n\n    // 建图\n    type edge struct {\n        to     int\n        weight float64\n    }\n    graph := make([][]edge, len(id))\n    for i, eq := range equations {\n        v, w := id[eq[0]], id[eq[1]]\n        graph[v] = append(graph[v], edge{w, values[i]})\n        graph[w] = append(graph[w], edge{v, 1 / values[i]})\n    }\n\n    bfs := func(start, end int) float64 {\n        ratios := make([]float64, len(graph))\n        ratios[start] = 1\n        queue := []int{start}\n        for len(queue) > 0 {\n            v := queue[0]\n            queue = queue[1:]\n            if v == end {\n                return ratios[v]\n            }\n            for _, e := range graph[v] {\n                if w := e.to; ratios[w] == 0 {\n                    ratios[w] = ratios[v] * e.weight\n                    queue = append(queue, w)\n                }\n            }\n        }\n        return -1\n    }\n\n    ans := make([]float64, len(queries))\n    for i, q := range queries {\n        start, hasS := id[q[0]]\n        end, hasE := id[q[1]]\n        if !hasS || !hasE {\n            ans[i] = -1\n        } else {\n            ans[i] = bfs(start, end)\n        }\n    }\n    return ans\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar calcEquation = function(equations, values, queries) {\n    let nvars = 0;\n    const variables = new Map();\n\n    const n = equations.length;\n    for (let i = 0; i < n; i++) {\n        if (!variables.has(equations[i][0])) {\n            variables.set(equations[i][0], nvars++);\n        }\n        if (!variables.has(equations[i][1])) {\n            variables.set(equations[i][1], nvars++);\n        }\n    }\n\n    // 对于每个点，存储其直接连接到的所有点及对应的权值\n    const edges = new Array(nvars).fill(0);\n    for (let i = 0; i < nvars; i++) {\n        edges[i] = [];\n    }\n    for (let i = 0; i < n; i++) {\n        const va = variables.get(equations[i][0]), vb = variables.get(equations[i][1]);\n        edges[va].push([vb, values[i]]);\n        edges[vb].push([va, 1.0 / values[i]]);\n    }\n\n    const queriesCount = queries.length;\n    const ret = [];\n    for (let i = 0; i < queriesCount; i++) {\n        const query = queries[i];\n        let result = -1.0;\n        if (variables.has(query[0]) && variables.has(query[1])) {\n            const ia = variables.get(query[0]), ib = variables.get(query[1]);\n            if (ia === ib) {\n                result = 1.0;\n            } else {\n                const points = [];\n                points.push(ia);\n                const ratios = new Array(nvars).fill(-1.0);\n                ratios[ia] = 1.0;\n\n                while (points.length && ratios[ib] < 0) {\n                    const x = points.pop();\n                    for (const [y, val] of edges[x]) {\n                        if (ratios[y] < 0) {\n                            ratios[y] = ratios[x] * val;\n                            points.push(y);\n                        }\n                    }\n                }\n                result = ratios[ib];\n            }\n        }\n        ret[i] = result;\n    }\n    return ret;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(ML+Q\\cdot(L+M))$，其中 $M$ 为边的数量，$Q$ 为询问的数量，$L$ 为字符串的平均长度。构建图时，需要处理 $M$ 条边，每条边都涉及到 $O(L)$ 的字符串比较；处理查询时，每次查询首先要进行一次 $O(L)$ 的比较，然后至多遍历 $O(M)$ 条边。\n\n- 空间复杂度：$O(NL+M)$，其中 $N$ 为点的数量，$M$ 为边的数量，$L$ 为字符串的平均长度。为了将每个字符串映射到整数，需要开辟空间为 $O(NL)$ 的哈希表；随后，需要花费 $O(M)$ 的空间存储每条边的权重；处理查询时，还需要 $O(N)$ 的空间维护访问队列。最终，总的复杂度为 $O(NL+M+N) = O(NL+M)$。\n\n#### 方法二：$\\text{Floyd}$ 算法\n\n对于查询数量很多的情形，如果为每次查询都独立搜索一次，则效率会变低。为此，我们不妨对图先做一定的预处理，随后就可以在较短的时间内回答每个查询。\n\n在本题中，我们可以使用 $\\text{Floyd}$ 算法，预先计算出任意两点之间的距离。\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        int nvars = 0;\n        unordered_map<string, int> variables;\n\n        int n = equations.size();\n        for (int i = 0; i < n; i++) {\n            if (variables.find(equations[i][0]) == variables.end()) {\n                variables[equations[i][0]] = nvars++;\n            }\n            if (variables.find(equations[i][1]) == variables.end()) {\n                variables[equations[i][1]] = nvars++;\n            }\n        }\n        vector<vector<double>> graph(nvars, vector<double>(nvars, -1.0));\n        for (int i = 0; i < n; i++) {\n            int va = variables[equations[i][0]], vb = variables[equations[i][1]];\n            graph[va][vb] = values[i];\n            graph[vb][va] = 1.0 / values[i];\n        }\n\n        for (int k = 0; k < nvars; k++) {\n            for (int i = 0; i < nvars; i++) {\n                for (int j = 0; j < nvars; j++) {\n                    if (graph[i][k] > 0 && graph[k][j] > 0) {\n                        graph[i][j] = graph[i][k] * graph[k][j];\n                    }\n                }\n            }\n        }\n\n        vector<double> ret;\n        for (const auto& q: queries) {\n            double result = -1.0;\n            if (variables.find(q[0]) != variables.end() && variables.find(q[1]) != variables.end()) {\n                int ia = variables[q[0]], ib = variables[q[1]];\n                if (graph[ia][ib] > 0) {\n                    result = graph[ia][ib];\n                }\n            }\n            ret.push_back(result);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n        int nvars = 0;\n        Map<String, Integer> variables = new HashMap<String, Integer>();\n\n        int n = equations.size();\n        for (int i = 0; i < n; i++) {\n            if (!variables.containsKey(equations.get(i).get(0))) {\n                variables.put(equations.get(i).get(0), nvars++);\n            }\n            if (!variables.containsKey(equations.get(i).get(1))) {\n                variables.put(equations.get(i).get(1), nvars++);\n            }\n        }\n        double[][] graph = new double[nvars][nvars];\n        for (int i = 0; i < nvars; i++) {\n            Arrays.fill(graph[i], -1.0);\n        }\n        for (int i = 0; i < n; i++) {\n            int va = variables.get(equations.get(i).get(0)), vb = variables.get(equations.get(i).get(1));\n            graph[va][vb] = values[i];\n            graph[vb][va] = 1.0 / values[i];\n        }\n\n        for (int k = 0; k < nvars; k++) {\n            for (int i = 0; i < nvars; i++) {\n                for (int j = 0; j < nvars; j++) {\n                    if (graph[i][k] > 0 && graph[k][j] > 0) {\n                        graph[i][j] = graph[i][k] * graph[k][j];\n                    }\n                }\n            }\n        }\n\n        int queriesCount = queries.size();\n        double[] ret = new double[queriesCount];\n        for (int i = 0; i < queriesCount; i++) {\n            List<String> query = queries.get(i);\n            double result = -1.0;\n            if (variables.containsKey(query.get(0)) && variables.containsKey(query.get(1))) {\n                int ia = variables.get(query.get(0)), ib = variables.get(query.get(1));\n                if (graph[ia][ib] > 0) {\n                    result = graph[ia][ib];\n                }\n            }\n            ret[i] = result;\n        }\n        return ret;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\n    // 给方程组中的每个变量编号\n    id := map[string]int{}\n    for _, eq := range equations {\n        a, b := eq[0], eq[1]\n        if _, has := id[a]; !has {\n            id[a] = len(id)\n        }\n        if _, has := id[b]; !has {\n            id[b] = len(id)\n        }\n    }\n\n    // 建图\n    graph := make([][]float64, len(id))\n    for i := range graph {\n        graph[i] = make([]float64, len(id))\n    }\n    for i, eq := range equations {\n        v, w := id[eq[0]], id[eq[1]]\n        graph[v][w] = values[i]\n        graph[w][v] = 1 / values[i]\n    }\n\n    // 执行 Floyd 算法\n    for k := range graph {\n        for i := range graph {\n            for j := range graph {\n                if graph[i][k] > 0 && graph[k][j] > 0 {\n                    graph[i][j] = graph[i][k] * graph[k][j]\n                }\n            }\n        }\n    }\n\n    ans := make([]float64, len(queries))\n    for i, q := range queries {\n        start, hasS := id[q[0]]\n        end, hasE := id[q[1]]\n        if !hasS || !hasE || graph[start][end] == 0 {\n            ans[i] = -1\n        } else {\n            ans[i] = graph[start][end]\n        }\n    }\n    return ans\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar calcEquation = function(equations, values, queries) {\n    let nvars = 0;\n    const variables = new Map();\n\n    const n = equations.length;\n    for (let i = 0; i < n; i++) {\n        if (!variables.has(equations[i][0])) {\n            variables.set(equations[i][0], nvars++);\n        }\n        if (!variables.has(equations[i][1])) {\n            variables.set(equations[i][1], nvars++);\n        }\n    }\n    const graph = new Array(nvars).fill(0).map(() => new Array(nvars).fill(-1.0));\n    for (let i = 0; i < n; i++) {\n        const va = variables.get(equations[i][0]), vb = variables.get(equations[i][1]);\n        graph[va][vb] = values[i];\n        graph[vb][va] = 1.0 / values[i];\n    }\n\n    for (let k = 0; k < nvars; k++) {\n        for (let i = 0; i < nvars; i++) {\n            for (let j = 0; j < nvars; j++) {\n                if (graph[i][k] > 0 && graph[k][j] > 0) {\n                    graph[i][j] = graph[i][k] * graph[k][j];\n                }\n            }\n        }\n    }\n\n    const queriesCount = queries.length;\n    const ret = new Array(queriesCount).fill(0);\n    for (let i = 0; i < queriesCount; i++) {\n        const query = queries[i];\n        let result = -1.0;\n        if (variables.has(query[0]) && variables.has(query[1])) {\n            const ia = variables.get(query[0]), ib = variables.get(query[1]);\n            if (graph[ia][ib] > 0) {\n                result = graph[ia][ib];\n            }\n        }\n        ret[i] = result;\n    }\n    return ret;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(ML+N^3+QL)$。构建图需要 $O(ML)$ 的时间；$\\text{Floyd}$ 算法需要 $O(N^3)$ 的时间；处理查询时，单次查询只需要 $O(L)$ 的字符串比较以及常数时间的额外操作。\n\n- 空间复杂度：$O(NL+N^2)$。\n\n#### 方法三：带权并查集\n\n我们还可以考虑以并查集的方式存储节点之间的关系。设节点 $x$ 的值（即对应变量的取值）为 $v[x]$。对于任意两点 $x, y$，假设它们在并查集中具有共同的父亲 $f$，且 $v[x]/v[f] = a, v[y]/v[f]=b$，则 $v[x]/v[y]=a/b$。\n\n在观察到这一点后，就不难利用并查集的思想解决此题。对于每个节点 $x$ 而言，除了维护其父亲 $f[x]$ 之外，还要维护其权值 $w$，其中「权值」定义为节点 $x$ 的取值与父亲 $f[x]$ 的取值之间的比值。换言之，我们有\n$$\nw[x] = \\frac{v[x]}{v[f[x]]}\n$$\n\n下面，我们对并查集的两种操作的实现细节做出讨论。\n\n**当查询节点 $x$ 父亲时**，如果 $f[x] \\ne x$，我们需要先找到 $f[x]$ 的父亲 $\\textit{father}$，并将 $f[x]$ 更新为 $\\textit{father}$。此时，我们有\n$$\n\\begin{aligned}\nw[x] &\\leftarrow \\frac{v[x]}{v[\\textit{father}]} \\\\\n&= \\frac{v[x]}{v[f[x]]} \\cdot \\frac{v[f[x]]}{v[\\textit{father}]} \\\\\n&= w[i] \\cdot w[f[x]]\n\\end{aligned}\n$$\n\n也就是说，我们要将 $w[x]$ 更新为 $w[x] \\cdot w[f[x]]$。\n\n**当合并两个节点 $x,y$ 时**，我们首先找到两者的父亲 $f_x, f_y$，并将 $f[f_x]$ 更新为 $f_y$。此时，我们有\n$$\n\\begin{aligned}\nw[f_x] &\\leftarrow \\frac{v[f_x]}{v[f_y]} \\\\\n&= \\frac{v[x]/w[x]}{v[y]/w[y]} \\\\\n&= \\frac{v[x]}{v[y]} \\cdot \\frac{w[y]}{w[x]}\n\\end{aligned}\n$$\n\n也就是说，当在已有的图中添加一条方程式 $\\frac{v[x]}{v[y]}=k$ 时，需要将 $w[f_x]$ 更新为 $k\\cdot \\frac{w[y]}{w[x]}$。\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int findf(vector<int>& f, vector<double>& w, int x) {\n        if (f[x] != x) {\n            int father = findf(f, w, f[x]);\n            w[x] = w[x] * w[f[x]];\n            f[x] = father;\n        }\n        return f[x];\n    }\n\n    void merge(vector<int>& f, vector<double>& w, int x, int y, double val) {\n        int fx = findf(f, w, x);\n        int fy = findf(f, w, y);\n        f[fx] = fy;\n        w[fx] = val * w[y] / w[x];\n    }\n\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        int nvars = 0;\n        unordered_map<string, int> variables;\n\n        int n = equations.size();\n        for (int i = 0; i < n; i++) {\n            if (variables.find(equations[i][0]) == variables.end()) {\n                variables[equations[i][0]] = nvars++;\n            }\n            if (variables.find(equations[i][1]) == variables.end()) {\n                variables[equations[i][1]] = nvars++;\n            }\n        }\n        vector<int> f(nvars);\n        vector<double> w(nvars, 1.0);\n        for (int i = 0; i < nvars; i++) {\n            f[i] = i;\n        }\n\n        for (int i = 0; i < n; i++) {\n            int va = variables[equations[i][0]], vb = variables[equations[i][1]];\n            merge(f, w, va, vb, values[i]);\n        }\n        vector<double> ret;\n        for (const auto& q: queries) {\n            double result = -1.0;\n            if (variables.find(q[0]) != variables.end() && variables.find(q[1]) != variables.end()) {\n                int ia = variables[q[0]], ib = variables[q[1]];\n                int fa = findf(f, w, ia), fb = findf(f, w, ib);\n                if (fa == fb) {\n                    result = w[ia] / w[ib];\n                }\n            }\n            ret.push_back(result);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n        int nvars = 0;\n        Map<String, Integer> variables = new HashMap<String, Integer>();\n\n        int n = equations.size();\n        for (int i = 0; i < n; i++) {\n            if (!variables.containsKey(equations.get(i).get(0))) {\n                variables.put(equations.get(i).get(0), nvars++);\n            }\n            if (!variables.containsKey(equations.get(i).get(1))) {\n                variables.put(equations.get(i).get(1), nvars++);\n            }\n        }\n        int[] f = new int[nvars];\n        double[] w = new double[nvars];\n        Arrays.fill(w, 1.0);\n        for (int i = 0; i < nvars; i++) {\n            f[i] = i;\n        }\n\n        for (int i = 0; i < n; i++) {\n            int va = variables.get(equations.get(i).get(0)), vb = variables.get(equations.get(i).get(1));\n            merge(f, w, va, vb, values[i]);\n        }\n        int queriesCount = queries.size();\n        double[] ret = new double[queriesCount];\n        for (int i = 0; i < queriesCount; i++) {\n            List<String> query = queries.get(i);\n            double result = -1.0;\n            if (variables.containsKey(query.get(0)) && variables.containsKey(query.get(1))) {\n                int ia = variables.get(query.get(0)), ib = variables.get(query.get(1));\n                int fa = findf(f, w, ia), fb = findf(f, w, ib);\n                if (fa == fb) {\n                    result = w[ia] / w[ib];\n                }\n            }\n            ret[i] = result;\n        }\n        return ret;\n    }\n\n    public void merge(int[] f, double[] w, int x, int y, double val) {\n        int fx = findf(f, w, x);\n        int fy = findf(f, w, y);\n        f[fx] = fy;\n        w[fx] = val * w[y] / w[x];\n    }\n\n    public int findf(int[] f, double[] w, int x) {\n        if (f[x] != x) {\n            int father = findf(f, w, f[x]);\n            w[x] = w[x] * w[f[x]];\n            f[x] = father;\n        }\n        return f[x];\n    }\n}\n```\n\n```go [sol3-Golang]\nfunc calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\n    // 给方程组中的每个变量编号\n    id := map[string]int{}\n    for _, eq := range equations {\n        a, b := eq[0], eq[1]\n        if _, has := id[a]; !has {\n            id[a] = len(id)\n        }\n        if _, has := id[b]; !has {\n            id[b] = len(id)\n        }\n    }\n\n    fa := make([]int, len(id))\n    w := make([]float64, len(id))\n    for i := range fa {\n        fa[i] = i\n        w[i] = 1\n    }\n    var find func(int) int\n    find = func(x int) int {\n        if fa[x] != x {\n            f := find(fa[x])\n            w[x] *= w[fa[x]]\n            fa[x] = f\n        }\n        return fa[x]\n    }\n    merge := func(from, to int, val float64) {\n        fFrom, fTo := find(from), find(to)\n        w[fFrom] = val * w[to] / w[from]\n        fa[fFrom] = fTo\n    }\n\n    for i, eq := range equations {\n        merge(id[eq[0]], id[eq[1]], values[i])\n    }\n\n    ans := make([]float64, len(queries))\n    for i, q := range queries {\n        start, hasS := id[q[0]]\n        end, hasE := id[q[1]]\n        if hasS && hasE && find(start) == find(end) {\n            ans[i] = w[start] / w[end]\n        } else {\n            ans[i] = -1\n        }\n    }\n    return ans\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar calcEquation = function(equations, values, queries) {\n    let nvars = 0;\n    const variables = new Map();\n\n    const n = equations.length;\n    for (let i = 0; i < n; i++) {\n        if (!variables.has(equations[i][0])) {\n            variables.set(equations[i][0], nvars++);\n        }\n        if (!variables.has(equations[i][1])) {\n            variables.set(equations[i][1], nvars++);\n        }\n    }\n    const f = new Array(nvars).fill(0).map((val, index) => index);\n    const w = new Array(nvars).fill(1.0);\n\n    for (let i = 0; i < n; i++) {\n        const va = variables.get(equations[i][0]), vb = variables.get(equations[i][1]);\n        merge(f, w, va, vb, values[i]);\n    }\n    const queriesCount = queries.length;\n    const ret = new Array(queriesCount).fill(0);\n    for (let i = 0; i < queriesCount; i++) {\n        const query = queries[i];\n        let result = -1.0;\n        if (variables.has(query[0]) && variables.has(query[1])) {\n            const ia = variables.get(query[0]), ib = variables.get(query[1]);\n            const fa = findf(f, w, ia), fb = findf(f, w, ib);\n            if (fa == fb) {\n                result = w[ia] / w[ib];\n            }\n        }\n        ret[i] = result;\n    }\n    return ret;\n}\n\nconst merge = (f, w, x, y, val) => {\n    const fx = findf(f, w, x);\n    const fy = findf(f, w, y);\n    f[fx] = fy;\n    w[fx] = val * w[y] / w[x];\n}\n\nconst findf = (f, w, x) => {\n    if (f[x] != x) {\n        const father = findf(f, w, f[x]);\n        w[x] = w[x] * w[f[x]];\n        f[x] = father;\n    }\n    return f[x];\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(ML+N+M\\log N+Q\\cdot(L+\\log N))$。构建图需要 $O(ML)$ 的时间；初始化并查集需要 $O(N)$ 的初始化时间；构建并查集的单次操作复杂度为 $O(\\log N)$，共需 $O(M\\log N)$ 的时间；每个查询需要 $O(L)$ 的字符串比较以及 $O(\\log N)$ 的查询。\n\n- 空间复杂度：$O(NL)$。哈希表需要 $O(NL)$ 的空间，并查集需要 $O(N)$ 的空间。"
}