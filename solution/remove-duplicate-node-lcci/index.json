{
	"titleSlug": "remove-duplicate-node-lcci",
	"slug": "yi-chu-zhong-fu-jie-dian-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/remove-duplicate-node-lcci/solution/yi-chu-zhong-fu-jie-dian-by-leetcode-solution/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![02.01.ç§»é™¤é‡å¤èŠ‚ç‚¹.mp4](e14212f5-8248-42e3-b84f-63205c361ef9)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### å‰è¨€\n\nåœ¨æœ¬é¢˜ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ç§»é™¤æœªæ’åºé“¾è¡¨ä¸­çš„é‡å¤èŠ‚ç‚¹ã€‚ä¿ç•™æœ€å¼€å§‹å‡ºç°çš„èŠ‚ç‚¹ã€‚åœ¨ä¸€äº›è¯­è¨€ï¼ˆä¾‹å¦‚ `C++`ï¼‰ä¸­ï¼Œå¹¶æ²¡æœ‰è¾ƒå¥½çš„å†…å­˜å›æ”¶æœºåˆ¶ï¼Œå› æ­¤å¦‚æœåœ¨é¢è¯•ä¸­é‡åˆ°äº†æœ¬é¢˜ï¼Œå¯ä»¥å’Œé¢è¯•å®˜ç¡®è®¤æ˜¯å¦éœ€è¦é‡Šæ”¾è¢«ç§»é™¤çš„èŠ‚ç‚¹å ç”¨çš„å†…å­˜ç©ºé—´ã€‚æœ¬é¢˜è§£ç»™å‡ºçš„ `C++` ä»£ç ä¸­é»˜è®¤**ä¸é‡Šæ”¾**ç©ºé—´ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨\n\næˆ‘ä»¬å¯¹ç»™å®šçš„é“¾è¡¨è¿›è¡Œä¸€æ¬¡éå†ï¼Œå¹¶ç”¨ä¸€ä¸ªå“ˆå¸Œé›†åˆï¼ˆHashSetï¼‰æ¥å­˜å‚¨æ‰€æœ‰å‡ºç°è¿‡çš„èŠ‚ç‚¹ã€‚ç”±äºåœ¨å¤§éƒ¨åˆ†è¯­è¨€ä¸­ï¼Œå¯¹ç»™å®šçš„é“¾è¡¨å…ƒç´ ç›´æ¥è¿›è¡Œã€Œç›¸ç­‰ã€æ¯”è¾ƒï¼Œå®é™…ä¸Šæ˜¯å¯¹ä¸¤ä¸ªé“¾è¡¨å…ƒç´ çš„åœ°å€ï¼ˆè€Œä¸æ˜¯å€¼ï¼‰è¿›è¡Œæ¯”è¾ƒã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨å“ˆå¸Œé›†åˆä¸­å­˜å‚¨é“¾è¡¨å…ƒç´ çš„å€¼ï¼Œæ–¹ä¾¿ç›´æ¥ä½¿ç”¨ç­‰å·è¿›è¡Œæ¯”è¾ƒã€‚\n\nå…·ä½“åœ°ï¼Œæˆ‘ä»¬ä»é“¾è¡¨çš„å¤´èŠ‚ç‚¹ $\\textit{head}$ å¼€å§‹è¿›è¡Œéå†ï¼Œéå†çš„æŒ‡é’ˆè®°ä¸º $\\textit{pos}$ã€‚ç”±äºå¤´èŠ‚ç‚¹ä¸€å®šä¸ä¼šè¢«åˆ é™¤ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æšä¸¾å¾…ç§»é™¤èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ï¼Œå‡å°‘ç¼–å†™ä»£ç çš„å¤æ‚åº¦ã€‚\n\n> è¿™æ ·æšä¸¾æœ‰ä»€ä¹ˆå¥½å¤„ï¼Ÿè¯•æƒ³ä¸€ä¸‹ï¼Œå¦‚æœæˆ‘ä»¬ç›´æ¥æšä¸¾å¾…ç§»é™¤èŠ‚ç‚¹ï¼Œé‚£ä¹ˆåœ¨å°†å®ƒè¿›è¡Œç§»é™¤æ—¶ï¼Œæˆ‘ä»¬æœ¬è´¨ä¸Šæ˜¯å°†å®ƒçš„å‰é©±èŠ‚ç‚¹è¿å‘åç»§èŠ‚ç‚¹ã€‚è€Œç”±äºé¢˜ç›®ç»™å®šçš„é“¾è¡¨ç»“æ„ä¸­ï¼Œæˆ‘ä»¬æ— æ³•ç›´æ¥è®¿é—®ä¸€ä¸ªèŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸å¦‚ç›´æ¥æšä¸¾å‰é©±èŠ‚ç‚¹ `u`ï¼Œé‚£ä¹ˆèŠ‚ç‚¹æœ¬èº«å°±æ˜¯ `u.next`ï¼Œåç»§èŠ‚ç‚¹å°±æ˜¯ `u.next.next`ã€‚\n\nåœ¨éå†å®Œæˆåï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†æœ€ç»ˆçš„ç­”æ¡ˆé“¾è¡¨ã€‚\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    ListNode* removeDuplicateNodes(ListNode* head) {\n        if (head == nullptr) {\n            return head;\n        }\n        unordered_set<int> occurred = {head->val};\n        ListNode* pos = head;\n        // æšä¸¾å‰é©±èŠ‚ç‚¹\n        while (pos->next != nullptr) {\n            // å½“å‰å¾…åˆ é™¤èŠ‚ç‚¹\n            ListNode* cur = pos->next;\n            if (!occurred.count(cur->val)) {\n                occurred.insert(cur->val);\n                pos = pos->next;\n            } else {\n                pos->next = pos->next->next;\n            }\n        }\n        pos->next = nullptr;\n        return head;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public ListNode removeDuplicateNodes(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n        Set<Integer> occurred = new HashSet<Integer>();\n        occurred.add(head.val);\n        ListNode pos = head;\n        // æšä¸¾å‰é©±èŠ‚ç‚¹\n        while (pos.next != null) {\n            // å½“å‰å¾…åˆ é™¤èŠ‚ç‚¹\n            ListNode cur = pos.next;\n            if (occurred.add(cur.val)) {\n                pos = pos.next;\n            } else {\n                pos.next = pos.next.next;\n            }\n        }\n        pos.next = null;\n        return head;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def removeDuplicateNodes(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        occurred = {head.val}\n        pos = head\n        # æšä¸¾å‰é©±èŠ‚ç‚¹\n        while pos.next:\n            # å½“å‰å¾…åˆ é™¤èŠ‚ç‚¹\n            cur = pos.next\n            if cur.val not in occurred:\n                occurred.add(cur.val)\n                pos = pos.next\n            else:\n                pos.next = pos.next.next\n        return head\n```\n\n```golang [sol1-Golang]\nfunc removeDuplicateNodes(head *ListNode) *ListNode {\n    if head == nil {\n        return head\n    }\n    occurred := map[int]bool{head.Val: true}\n    pos := head\n    for pos.Next != nil {\n        cur := pos.Next\n        if !occurred[cur.Val] {\n            occurred[cur.Val] = true\n            pos = pos.Next\n        } else {\n            pos.Next = pos.Next.Next\n        }\n    }\n    pos.Next = nil\n    return head\n}\n```\n\n```C [sol1-C]\nstruct ListNode* removeDuplicateNodes(struct ListNode* head) {\n    if (head == NULL) {\n        return head;\n    }\n    int* occurred = (int*)calloc(20001, sizeof(int));\n    occurred[head->val] = 1;\n    struct ListNode* pos = head;\n    // æšä¸¾å‰é©±èŠ‚ç‚¹\n    while (pos->next != NULL) {\n        // å½“å‰å¾…åˆ é™¤èŠ‚ç‚¹\n        struct ListNode* cur = pos->next;\n        if (!occurred[cur->val]) {\n            occurred[cur->val] = 1;\n            pos = pos->next;\n        } else {\n            pos->next = pos->next->next;\n        }\n    }\n    pos->next = NULL;\n    return head;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯ç»™å®šé“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œç»™å®šé“¾è¡¨ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¸ç›¸åŒï¼Œå“ˆå¸Œè¡¨ä¸­éœ€è¦å­˜å‚¨æ‰€æœ‰çš„ $N$ ä¸ªå€¼ã€‚\n\n#### æ–¹æ³•äºŒï¼šä¸¤é‡å¾ªç¯\n\nè€ƒè™‘é¢˜ç›®æè¿°ä¸­çš„ã€Œè¿›é˜¶ã€éƒ¨åˆ†ï¼Œæ˜¯å¦å­˜åœ¨ä¸€ç§ä¸ä½¿ç”¨ä¸´æ—¶ç¼“å†²åŒºï¼ˆä¹Ÿå°±æ˜¯æ–¹æ³•ä¸€ä¸­çš„å“ˆå¸Œè¡¨ï¼‰çš„æ–¹æ³•å‘¢ï¼Ÿ\n\nä¸å¹¸çš„æ˜¯ï¼Œåœ¨ä¿è¯æ–¹æ³•ä¸€æ—¶é—´å¤æ‚åº¦ $O(N)$ çš„å‰æä¸‹ï¼Œæ˜¯ä¸å­˜åœ¨è¿™æ ·çš„æ–¹æ³•çš„ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦å¢åŠ æ—¶é—´å¤æ‚åº¦ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥ä»…ä½¿ç”¨å¸¸æ•°çš„ç©ºé—´æ¥å®Œæˆæœ¬é¢˜ã€‚ä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯ï¼Œæˆ‘ä»¬åœ¨ç»™å®šçš„é“¾è¡¨ä¸Šä½¿ç”¨ä¸¤é‡å¾ªç¯ï¼Œå…¶ä¸­ç¬¬ä¸€é‡å¾ªç¯ä»é“¾è¡¨çš„å¤´èŠ‚ç‚¹å¼€å§‹ï¼Œæšä¸¾ä¸€ä¸ªä¿ç•™çš„èŠ‚ç‚¹ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬ä¿ç•™çš„æ˜¯ã€Œæœ€å¼€å§‹å‡ºç°çš„èŠ‚ç‚¹ã€ã€‚ç¬¬äºŒé‡å¾ªç¯ä»æšä¸¾çš„ä¿ç•™èŠ‚ç‚¹å¼€å§‹ï¼Œåˆ°é“¾è¡¨çš„æœ«å°¾ç»“æŸï¼Œå°†æ‰€æœ‰ä¸ä¿ç•™èŠ‚ç‚¹ç›¸åŒçš„èŠ‚ç‚¹å…¨éƒ¨ç§»é™¤ã€‚\n\næ–¹æ³•äºŒçš„ç»†èŠ‚éƒ¨åˆ†ä¸æ–¹æ³•ä¸€ç±»ä¼¼ã€‚ç¬¬ä¸€é‡å¾ªç¯æšä¸¾ä¿ç•™çš„èŠ‚ç‚¹æœ¬èº«ï¼Œè€Œä¸ºäº†ç¼–ç æ–¹ä¾¿ï¼Œç¬¬äºŒé‡å¾ªç¯å¯ä»¥æšä¸¾å¾…ç§»é™¤èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ï¼Œæ–¹ä¾¿æˆ‘ä»¬å¯¹èŠ‚ç‚¹è¿›è¡Œç§»é™¤ã€‚è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬ä½¿ç”¨ã€Œæ—¶é—´æ¢ç©ºé—´ã€çš„æ–¹æ³•ï¼Œå°±å¯ä»¥ä¸ä½¿ç”¨ä¸´æ—¶ç¼“å†²åŒºè§£å†³æœ¬é¢˜äº†ã€‚\n\n**æ³¨æ„ï¼š** `Python` è¯­è¨€ä¼šè¶…å‡ºæ—¶é—´é™åˆ¶ï¼Œå¹¶ä¸èƒ½ä½¿ç”¨æ–¹æ³•äºŒé€šè¿‡æœ¬é¢˜ã€‚\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    ListNode* removeDuplicateNodes(ListNode* head) {\n        ListNode* ob = head;\n        while (ob != nullptr) {\n            ListNode* oc = ob;\n            while (oc->next != nullptr) {\n                if (oc->next->val == ob->val) {\n                    oc->next = oc->next->next;\n                } else {\n                    oc = oc->next;\n                }\n            }\n            ob = ob->next;\n        }\n        return head;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public ListNode removeDuplicateNodes(ListNode head) {\n        ListNode ob = head;\n        while (ob != null) {\n            ListNode oc = ob;\n            while (oc.next != null) {\n                if (oc.next.val == ob.val) {\n                    oc.next = oc.next.next;\n                } else {\n                    oc = oc.next;\n                }\n            }\n            ob = ob.next;\n        }\n        return head;\n    }\n}\n```\n\n```golang [sol2-Golang]\nfunc removeDuplicateNodes(head *ListNode) *ListNode {\n    ob := head\n    for ob != nil {\n        oc := ob\n        for oc.Next != nil {\n            if oc.Next.Val == ob.Val {\n                oc.Next = oc.Next.Next\n            } else {\n                oc = oc.Next\n            }\n        }\n        ob = ob.Next\n    }\n    return head\n}\n```\n\n```C [sol2-C]\nstruct ListNode* removeDuplicateNodes(struct ListNode* head) {\n    struct ListNode* ob = head;\n    while (ob != NULL) {\n        struct ListNode* oc = ob;\n        while (oc->next != NULL) {\n            if (oc->next->val == ob->val) {\n                oc->next = oc->next->next;\n            } else {\n                oc = oc->next;\n            }\n        }\n        ob = ob->next;\n    }\n    return head;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$ï¼Œå…¶ä¸­ $N$ æ˜¯ç»™å®šé“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚"
}