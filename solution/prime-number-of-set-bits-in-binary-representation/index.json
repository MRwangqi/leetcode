{
	"titleSlug": "prime-number-of-set-bits-in-binary-representation",
	"slug": "er-jin-zhi-biao-shi-zhong-zhi-shu-ge-ji-jy35g",
	"url": "https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/solution/er-jin-zhi-biao-shi-zhong-zhi-shu-ge-ji-jy35g/",
	"content": "#### 方法一：数学 + 位运算\n\n我们可以枚举 $[\\textit{left},\\textit{right}]$ 范围内的每个整数，挨个判断是否满足题目要求。\n\n对于每个数 $x$，我们需要解决两个问题：\n\n1. 如何求出 $x$ 的二进制中的 $1$ 的个数，见「[191. 位 1 的个数](https://leetcode-cn.com/problems/number-of-1-bits/)」，下面代码用库函数实现；\n2. 如何判断一个数是否为质数，见「[204. 计数质数](https://leetcode-cn.com/problems/count-primes/)」的「[官方解法](https://leetcode-cn.com/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/)」的方法一（注意 $0$ 和 $1$ 不是质数）。\n\n```Python [sol1-Python3]\nclass Solution:\n    def isPrime(self, x: int) -> bool:\n        if x < 2:\n            return False\n        i = 2\n        while i * i <= x:\n            if x % i == 0:\n                return False\n            i += 1\n        return True\n\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        return sum(self.isPrime(x.bit_count()) for x in range(left, right + 1))\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    bool isPrime(int x) {\n        if (x < 2) {\n            return false;\n        }\n        for (int i = 2; i * i <= x; ++i) {\n            if (x % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\npublic:\n    int countPrimeSetBits(int left, int right) {\n        int ans = 0;\n        for (int x = left; x <= right; ++x) {\n            if (isPrime(__builtin_popcount(x))) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int countPrimeSetBits(int left, int right) {\n        int ans = 0;\n        for (int x = left; x <= right; ++x) {\n            if (isPrime(Integer.bitCount(x))) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n\n    private boolean isPrime(int x) {\n        if (x < 2) {\n            return false;\n        }\n        for (int i = 2; i * i <= x; ++i) {\n            if (x % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int CountPrimeSetBits(int left, int right) {\n        int ans = 0;\n        for (int x = left; x <= right; ++x) {\n            if (IsPrime(BitCount(x))) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n\n    private bool IsPrime(int x) {\n        if (x < 2) {\n            return false;\n        }\n        for (int i = 2; i * i <= x; ++i) {\n            if (x % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static int BitCount(int i) {\n        i = i - ((i >> 1) & 0x55555555);\n        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n        i = (i + (i >> 4)) & 0x0f0f0f0f;\n        i = i + (i >> 8);\n        i = i + (i >> 16);\n        return i & 0x3f;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc isPrime(x int) bool {\n    if x < 2 {\n        return false\n    }\n    for i := 2; i*i <= x; i++ {\n        if x%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc countPrimeSetBits(left, right int) (ans int) {\n    for x := left; x <= right; x++ {\n        if isPrime(bits.OnesCount(uint(x))) {\n            ans++\n        }\n    }\n    return\n}\n```\n\n```C [sol1-C]\nbool isPrime(int x) {\n    if (x < 2) {\n        return false;\n    }\n    for (int i = 2; i * i <= x; ++i) {\n        if (x % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint countPrimeSetBits(int left, int right){\n    int ans = 0;\n    for (int x = left; x <= right; ++x) {\n        if (isPrime(__builtin_popcount(x))) {\n            ++ans;\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar countPrimeSetBits = function(left, right) {\n    let ans = 0;\n    for (let x = left; x <= right; ++x) {\n        if (isPrime(bitCount(x))) {\n            ++ans;\n        }\n    }\n    return ans;\n};\n\nconst isPrime = (x) => {\n    if (x < 2) {\n        return false;\n    }\n    for (let i = 2; i * i <= x; ++i) {\n        if (x % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst bitCount = (x) => {\n    return x.toString(2).split('0').join('').length;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O((\\textit{right}-\\textit{left})\\sqrt{\\log\\textit{right}})$。二进制中 $1$ 的个数为 $O(\\log\\textit{right})$，判断值为 $x$ 的数是否为质数的时间为 $O(\\sqrt{x})$。\n\n- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。\n\n#### 方法二：判断质数优化\n\n注意到 $\\textit{right} \\le 10^6 < 2^{20}$，因此二进制中 $1$ 的个数不会超过 $19$，而不超过 $19$ 的质数只有\n\n$$\n2, 3, 5, 7, 11, 13, 17, 19\n$$\n\n我们可以用一个二进制数 $\\textit{mask}=665772=10100010100010101100_{2}$ 来存储这些质数，其中 $\\textit{mask}$ 二进制的从低到高的第 $i$ 位为 $1$ 表示 $i$ 是质数，为 $0$ 表示 $i$ 不是质数。\n\n设整数 $x$ 的二进制中 $1$ 的个数为 $c$，若 $\\textit{mask}$ 按位与 $2^c$ 不为 $0$，则说明 $c$ 是一个质数。\n\n```Python [sol2-Python3]\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        return sum(((1 << x.bit_count()) & 665772) != 0 for x in range(left, right + 1))\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int countPrimeSetBits(int left, int right) {\n        int ans = 0;\n        for (int x = left; x <= right; ++x) {\n            if ((1 << __builtin_popcount(x)) & 665772) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int countPrimeSetBits(int left, int right) {\n        int ans = 0;\n        for (int x = left; x <= right; ++x) {\n            if (((1 << Integer.bitCount(x)) & 665772) != 0) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int CountPrimeSetBits(int left, int right) {\n        int ans = 0;\n        for (int x = left; x <= right; ++x) {\n            if (((1 << BitCount(x)) & 665772) != 0) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n\n    private static int BitCount(int i) {\n        i = i - ((i >> 1) & 0x55555555);\n        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n        i = (i + (i >> 4)) & 0x0f0f0f0f;\n        i = i + (i >> 8);\n        i = i + (i >> 16);\n        return i & 0x3f;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc countPrimeSetBits(left, right int) (ans int) {\n    for x := left; x <= right; x++ {\n        if 1<<bits.OnesCount(uint(x))&665772 != 0 {\n            ans++\n        }\n    }\n    return\n}\n```\n\n```C [sol2-C]\nint countPrimeSetBits(int left, int right){\n    int ans = 0;\n    for (int x = left; x <= right; ++x) {\n        if ((1 << __builtin_popcount(x)) & 665772) {\n            ++ans;\n        }\n    }\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar countPrimeSetBits = function(left, right) {\n    let ans = 0;\n    for (let x = left; x <= right; ++x) {\n        if (((1 << bitCount(x)) & 665772) != 0) {\n            ++ans;\n        }\n    }\n    return ans;\n};\n\nconst bitCount = (x) => {\n    return x.toString(2).split('0').join('').length;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\textit{right}-\\textit{left})$。\n\n- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。"
}