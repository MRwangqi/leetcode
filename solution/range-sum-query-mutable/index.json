{
	"titleSlug": "range-sum-query-mutable",
	"slug": "qu-yu-he-jian-suo-shu-zu-ke-xiu-gai-by-l-76xj",
	"url": "https://leetcode-cn.com/problems/range-sum-query-mutable/solution/qu-yu-he-jian-suo-shu-zu-ke-xiu-gai-by-l-76xj/",
	"content": "#### 方法一：分块处理\n\n**思路与算法**\n\n设数组大小为 $n$，我们将数组 $\\textit{nums}$ 分成多个块，每个块大小 $\\textit{size}$，最后一个块的大小为剩余的不超过 $\\textit{size}$ 的元素数目，那么块的总数为 $\\Big  \\lceil \\dfrac{n}{\\textit{size}} \\Big \\rceil$，用一个数组 $\\textit{sum}$ 保存每个块的元素和。\n\n+ 构造函数\n\n    计算块大小 $\\textit{size}$，初始化 $\\textit{sum}$。\n\n+ $\\textit{update}$ 函数\n\n    下标 $\\textit{index}$ 对应的块下标为 $\\Big \\lfloor \\dfrac{\\textit{index}}{\\textit{size}} \\Big \\rfloor$，更新 $\\textit{nums}$ 和 $\\textit{sum}$。\n\n+ $\\textit{sumRange}$ 函数\n\n    设 $\\textit{left}$ 位于第 $b_1$ 个块内的第 $i_1$ 个元素，$\\textit{right}$ 位于第 $b_2$ 个块内的第 $i_2$ 个元素。如果 $b_1 = b_2$，那么直接返回第 $b_1$ 个块位于区间 $[i_1, i_2]$ 的元素之和；否则计算第 $b_1$ 个块位于区间 $[i_1, \\textit{size} - 1)$的元素之和 $\\textit{sum}_1$，第 $b_2$ 个块位于区间 $[0, i_2]$ 的元素之和 $\\textit{sum}_2$，第 $b_1 + 1$ 个块到第 $b_2 - 1$ 个块的元素和的总和 $\\textit{sum}_3$，返回 $\\textit{sum}_1 + \\textit{sum}_2 + \\textit{sum}_3$。\n\n对于块大小 $\\textit{size}$ 的取值，我们从各个函数的时间复杂度入手。构造函数的时间复杂度为 $O(n)$，$\\textit{update}$ 函数的时间复杂度为 $O(1)$，而 $\\textit{sumRange}$ 函数的时间复杂度为 $O(\\textit{size} + \\dfrac{n}{size})$。因为 $\\textit{size} + \\dfrac{n}{\\textit{size}} \\ge 2\\sqrt n$，仅当 $\\textit{size} = \\sqrt n$ 时等号成立。因此 $\\textit{size}$ 取 $\\lfloor \\sqrt n \\rfloor$，此时 $\\textit{sumRange}$ 函数的时间复杂度为 $O(\\sqrt n)$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass NumArray:\n    def __init__(self, nums: List[int]):\n        n = len(nums)\n        size = int(n ** 0.5)\n        sums = [0] * ((n + size - 1) // size)  # n/size 向上取整\n        for i, num in enumerate(nums):\n            sums[i // size] += num\n        self.nums = nums\n        self.sums = sums\n        self.size = size\n\n    def update(self, index: int, val: int) -> None:\n        self.sums[index // self.size] += val - self.nums[index]\n        self.nums[index] = val\n\n    def sumRange(self, left: int, right: int) -> int:\n        m = self.size\n        b1, b2 = left // m, right // m\n        if b1 == b2:  # 区间 [left, right] 在同一块中\n            return sum(self.nums[left:right + 1])\n        return sum(self.nums[left:(b1 + 1) * m]) + sum(self.sums[b1 + 1:b2]) + sum(self.nums[b2 * m:right + 1])\n```\n\n```C++ [sol1-C++]\nclass NumArray {\nprivate:\n    vector<int> sum; // sum[i] 表示第 i 个块的元素和\n    int size; // 块的大小\n    vector<int> &nums;\npublic:\n    NumArray(vector<int>& nums) : nums(nums) {\n        int n = nums.size();\n        size = sqrt(n);\n        sum.resize((n + size - 1) / size); // n/size 向上取整\n        for (int i = 0; i < n; i++) {\n            sum[i / size] += nums[i];\n        }\n    }\n\n    void update(int index, int val) {\n        sum[index / size] += val - nums[index];\n        nums[index] = val;\n    }\n\n    int sumRange(int left, int right) {\n        int b1 = left / size, i1 = left % size, b2 = right / size, i2 = right % size;\n        if (b1 == b2) { // 区间 [left, right] 在同一块中\n            return accumulate(nums.begin() + b1 * size + i1, nums.begin() + b1 * size + i2 + 1, 0);\n        }\n        int sum1 = accumulate(nums.begin() + b1 * size + i1, nums.begin() + b1 * size + size, 0);\n        int sum2 = accumulate(nums.begin() + b2 * size, nums.begin() + b2 * size + i2 + 1, 0);\n        int sum3 = accumulate(sum.begin() + b1 + 1, sum.begin() + b2, 0);\n        return sum1 + sum2 + sum3;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass NumArray {\n    private int[] sum; // sum[i] 表示第 i 个块的元素和\n    private int size; // 块的大小\n    private int[] nums;\n\n    public NumArray(int[] nums) {\n        this.nums = nums;\n        int n = nums.length;\n        size = (int) Math.sqrt(n);\n        sum = new int[(n + size - 1) / size]; // n/size 向上取整\n        for (int i = 0; i < n; i++) {\n            sum[i / size] += nums[i];\n        }\n    }\n\n    public void update(int index, int val) {\n        sum[index / size] += val - nums[index];\n        nums[index] = val;\n    }\n\n    public int sumRange(int left, int right) {\n        int b1 = left / size, i1 = left % size, b2 = right / size, i2 = right % size;\n        if (b1 == b2) { // 区间 [left, right] 在同一块中\n            int sum = 0;\n            for (int j = i1; j <= i2; j++) {\n                sum += nums[b1 * size + j];\n            }\n            return sum;\n        }\n        int sum1 = 0;\n        for (int j = i1; j < size; j++) {\n            sum1 += nums[b1 * size + j];\n        }\n        int sum2 = 0;\n        for (int j = 0; j <= i2; j++) {\n            sum2 += nums[b2 * size + j];\n        }\n        int sum3 = 0;\n        for (int j = b1 + 1; j < b2; j++) {\n            sum3 += sum[j];\n        }\n        return sum1 + sum2 + sum3;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class NumArray {\n    private int[] sum; // sum[i] 表示第 i 个块的元素和\n    private int size; // 块的大小\n    private int[] nums;\n\n    public NumArray(int[] nums) {\n        this.nums = nums;\n        int n = nums.Length;\n        size = (int) Math.Sqrt(n);\n        sum = new int[(n + size - 1) / size]; // n/size 向上取整\n        for (int i = 0; i < n; i++) {\n            sum[i / size] += nums[i];\n        }\n    }\n\n    public void Update(int index, int val) {\n        sum[index / size] += val - nums[index];\n        nums[index] = val;\n    }\n\n    public int SumRange(int left, int right) {\n        int b1 = left / size, i1 = left % size, b2 = right / size, i2 = right % size;\n        if (b1 == b2) { // 区间 [left, right] 在同一块中\n            int sum = 0;\n            for (int j = i1; j <= i2; j++) {\n                sum += nums[b1 * size + j];\n            }\n            return sum;\n        }\n        int sum1 = 0;\n        for (int j = i1; j < size; j++) {\n            sum1 += nums[b1 * size + j];\n        }\n        int sum2 = 0;\n        for (int j = 0; j <= i2; j++) {\n            sum2 += nums[b2 * size + j];\n        }\n        int sum3 = 0;\n        for (int j = b1 + 1; j < b2; j++) {\n            sum3 += sum[j];\n        }\n        return sum1 + sum2 + sum3;\n    }\n}\n```\n\n```C [sol1-C]\ntypedef struct {\n    int * sum; // sum[i] 表示第 i 个块的元素和\n    int * nums;\n    int blockSize; // 块的大小\n} NumArray;\n\nNumArray* numArrayCreate(int* nums, int numsSize) {\n    NumArray * obj = (NumArray *)malloc(sizeof(NumArray));\n    obj->blockSize = sqrt(numsSize);\n    obj->sum = (int *)malloc(sizeof(int) * (numsSize + obj->blockSize - 1) / obj->blockSize);\n    obj->nums = (int *)malloc(sizeof(int) * numsSize);\n    memset(obj->sum, 0, sizeof(int) * (numsSize + obj->blockSize - 1) / obj->blockSize);\n    memcpy(obj->nums, nums, sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        obj->sum[i / obj->blockSize] += nums[i];\n    }\n    return obj;\n}\n\nvoid numArrayUpdate(NumArray* obj, int index, int val) {\n    obj->sum[index / obj->blockSize] += val - obj->nums[index];\n    obj->nums[index] = val;\n}\n\nint numArraySumRange(NumArray* obj, int left, int right) {\n    int b1 = left / obj->blockSize, i1 = left % obj->blockSize;\n    int b2 = right / obj->blockSize, i2 = right % obj->blockSize;\n    int ans = 0;\n    if (b1 == b2) { // 区间 [left, right] 在同一块中\n        for (int i = i1; i <= i2; i++) {\n            ans += obj->nums[b1 * obj->blockSize + i];\n        }\n        return ans;\n    }\n    for (int i = i1; i < obj->blockSize; i++) {\n        ans += obj->nums[b1 * obj->blockSize + i];\n    }\n    for (int i = 0; i <= i2; i++) {\n        ans += obj->nums[b2 * obj->blockSize + i];\n    }\n    for (int i = b1 + 1; i < b2; i++) {\n        ans += obj->sum[i];\n    }\n    return ans;\n}\n\nvoid numArrayFree(NumArray* obj) {\n    free(obj->nums);\n    free(obj->sum);\n    free(obj);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar NumArray = function(nums) {\n    this.nums = nums;\n    const n = nums.length;\n    size = Math.floor(Math.sqrt(n));\n    this.sum = new Array(Math.floor((n + size - 1) / size)).fill(0); // n/size 向上取整\n    for (let i = 0; i < n; i++) {\n        this.sum[Math.floor(i / size)] += nums[i];\n    }\n};\n\nNumArray.prototype.update = function(index, val) {\n    this.sum[Math.floor(index / size)] += val - this.nums[index];\n    this.nums[index] = val;\n};\n\nNumArray.prototype.sumRange = function(left, right) {\n    const b1 = Math.floor(left / size), i1 = left % size, b2 = Math.floor(right / size), i2 = right % size;\n    if (b1 === b2) { // 区间 [left, right] 在同一块中\n        let sum = 0;\n        for (let j = i1; j <= i2; j++) {\n            sum += this.nums[b1 * size + j];\n        }\n        return sum;\n    }\n    let sum1 = 0;\n    for (let j = i1; j < size; j++) {\n        sum1 += this.nums[b1 * size + j];\n    }\n    let sum2 = 0;\n    for (let j = 0; j <= i2; j++) {\n        sum2 += this.nums[b2 * size + j];\n    }\n    let sum3 = 0;\n    for (let j = b1 + 1; j < b2; j++) {\n        sum3 += this.sum[j];\n    }\n    return sum1 + sum2 + sum3;\n};\n```\n\n```go [sol1-Golang]\ntype NumArray struct {\n    nums, sums []int // sums[i] 表示第 i 个块的元素和\n    size       int   // 块的大小\n}\n\nfunc Constructor(nums []int) NumArray {\n    n := len(nums)\n    size := int(math.Sqrt(float64(n)))\n    sums := make([]int, (n+size-1)/size) // n/size 向上取整\n    for i, num := range nums {\n        sums[i/size] += num\n    }\n    return NumArray{nums, sums, size}\n}\n\nfunc (na *NumArray) Update(index, val int) {\n    na.sums[index/na.size] += val - na.nums[index]\n    na.nums[index] = val\n}\n\nfunc (na *NumArray) SumRange(left, right int) (ans int) {\n    size := na.size\n    b1, b2 := left/size, right/size\n    if b1 == b2 { // 区间 [left, right] 在同一块中\n        for i := left; i <= right; i++ {\n            ans += na.nums[i]\n        }\n        return\n    }\n    for i := left; i < (b1+1)*size; i++ {\n        ans += na.nums[i]\n    }\n    for i := b1 + 1; i < b2; i++ {\n        ans += na.sums[i]\n    }\n    for i := b2 * size; i <= right; i++ {\n        ans += na.nums[i]\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：构造函数为 $O(n)$，$\\textit{update}$ 函数为 $O(1)$，$\\textit{sumRange}$ 函数为 $O(\\sqrt n)$，其中 $n$ 为数组 $\\textit{nums}$ 的大小。对于 $\\textit{sumRange}$ 函数，我们最多遍历两个块以及 $\\textit{sum}$ 数组，因此时间复杂度为 $O(\\sqrt n)$。\n\n+ 空间复杂度：$O(\\sqrt n)$。保存 $\\textit{sum}$ 数组需要 $O(\\sqrt n)$ 的空间。\n\n#### 方法二：线段树\n\n**思路与算法**\n\n线段树 $\\textit{segmentTree}$ 是一个二叉树，每个结点保存数组 $\\textit{nums}$ 在区间 $[s, e]$ 的最小值、最大值或者总和等信息。线段树可以用树也可以用数组（堆式存储）来实现。对于数组实现，假设根结点的下标为 $0$，如果一个结点在数组的下标为 $\\textit{node}$，那么它的左子结点下标为 $\\textit{node} \\times 2 + 1$，右子结点下标为 $\\textit{node} \\times 2 + 2$。\n\n+ 建树 $\\textit{build}$ 函数\n\n    我们在结点 $\\textit{node}$ 保存数组 $\\textit{nums}$ 在区间 $[s, e]$ 的总和。\n\n    + $s = e$ 时，结点 $\\textit{node}$ 是叶子结点，它保存的值等于 $\\textit{nums}[s]$。\n    \n    + $s < e$ 时，结点 $\\textit{node}$ 的左子结点保存区间 $\\Big [ s, \\Big \\lfloor \\dfrac{s + e}{2} \\Big \\rfloor \\Big ]$ 的总和，右子结点保存区间 $\\Big [ \\Big \\lfloor \\dfrac{s + e}{2} \\Big  \\rfloor + 1, e \\Big ]$ 的总和，那么结点 $\\textit{node}$ 保存的值等于它的两个子结点保存的值之和。\n\n    假设 $\\textit{nums}$ 的大小为 $n$，我们规定根结点 $\\textit{node} = 0$ 保存区间 $[0, n - 1]$ 的总和，然后自下而上递归地建树。\n\n+ 单点修改 $\\textit{change}$ 函数\n\n    当我们要修改 $\\textit{nums}[\\textit{index}]$ 的值时，我们找到对应区间 $[\\textit{index}, \\textit{index}]$ 的叶子结点，直接修改叶子结点的值为 $\\textit{val}$，并自下而上递归地更新父结点的值。\n\n+ 范围求和 $\\textit{range}$ 函数\n\n    给定区间 $[\\textit{left}, \\textit{right}]$ 时，我们将区间 $[\\textit{left}, \\textit{right}]$ 拆成多个结点对应的区间。\n\n    + 如果结点 $\\textit{node}$ 对应的区间与 $[\\textit{left}, \\textit{right}]$ 相同，可以直接返回该结点的值，即当前区间和。\n\n    + 如果结点 $\\textit{node}$ 对应的区间与 $[\\textit{left}, \\textit{right}]$ 不同，设左子结点对应的区间的右端点为 $m$，那么将区间 $[\\textit{left}, \\textit{right}]$ 沿点 $m$ 拆成两个区间，分别计算左子结点和右子结点。\n\n    我们从根结点开始递归地拆分区间 $[\\textit{left}, \\textit{right}]$。\n\n**代码**\n\n```Python [sol2-Python3]\nclass NumArray:\n    def __init__(self, nums: List[int]):\n        n = len(nums)\n        self.n = n\n        self.seg = [0] * (n * 4)\n        self.build(nums, 0, 0, n - 1)\n\n    def build(self, nums: List[int], node: int, s: int, e: int):\n        if s == e:\n            self.seg[node] = nums[s]\n            return\n        m = s + (e - s) // 2\n        self.build(nums, node * 2 + 1, s, m)\n        self.build(nums, node * 2 + 2, m + 1, e)\n        self.seg[node] = self.seg[node * 2 + 1] + self.seg[node * 2 + 2]\n\n    def change(self, index: int, val: int, node: int, s: int, e: int):\n        if s == e:\n            self.seg[node] = val\n            return\n        m = s + (e - s) // 2\n        if index <= m:\n            self.change(index, val, node * 2 + 1, s, m)\n        else:\n            self.change(index, val, node * 2 + 2, m + 1, e)\n        self.seg[node] = self.seg[node * 2 + 1] + self.seg[node * 2 + 2]\n\n    def range(self, left: int, right: int, node: int, s: int, e: int) -> int:\n        if left == s and right == e:\n            return self.seg[node]\n        m = s + (e - s) // 2\n        if right <= m:\n            return self.range(left, right, node * 2 + 1, s, m)\n        if left > m:\n            return self.range(left, right, node * 2 + 2, m + 1, e)\n        return self.range(left, m, node * 2 + 1, s, m) + self.range(m + 1, right, node * 2 + 2, m + 1, e)\n\n    def update(self, index: int, val: int) -> None:\n        self.change(index, val, 0, 0, self.n - 1)\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.range(left, right, 0, 0, self.n - 1)\n```\n\n```C++ [sol2-C++]\nclass NumArray {\nprivate:\n    vector<int> segmentTree;\n    int n;\n\n    void build(int node, int s, int e, vector<int> &nums) {\n        if (s == e) {\n            segmentTree[node] = nums[s];\n            return;\n        }\n        int m = s + (e - s) / 2;\n        build(node * 2 + 1, s, m, nums);\n        build(node * 2 + 2, m + 1, e, nums);\n        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n    }\n\n    void change(int index, int val, int node, int s, int e) {\n        if (s == e) {\n            segmentTree[node] = val;\n            return;\n        }\n        int m = s + (e - s) / 2;\n        if (index <= m) {\n            change(index, val, node * 2 + 1, s, m);\n        } else {\n            change(index, val, node * 2 + 2, m + 1, e);\n        }\n        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n    }\n\n    int range(int left, int right, int node, int s, int e) {\n        if (left == s && right == e) {\n            return segmentTree[node];\n        }\n        int m = s + (e - s) / 2;\n        if (right <= m) {\n            return range(left, right, node * 2 + 1, s, m);\n        } else if (left > m) {\n            return range(left, right, node * 2 + 2, m + 1, e);\n        } else {\n            return range(left, m, node * 2 + 1, s, m) + range(m + 1, right, node * 2 + 2, m + 1, e);\n        }\n    }\n\npublic:\n    NumArray(vector<int>& nums) : n(nums.size()), segmentTree(nums.size() * 4) {\n        build(0, 0, n - 1, nums);\n    }\n\n    void update(int index, int val) {\n        change(index, val, 0, 0, n - 1);\n    }\n\n    int sumRange(int left, int right) {\n        return range(left, right, 0, 0, n - 1);\n    }\n};\n```\n\n```Java [sol2-Java]\nclass NumArray {\n    private int[] segmentTree;\n    private int n;\n\n    public NumArray(int[] nums) {\n        n = nums.length;\n        segmentTree = new int[nums.length * 4];\n        build(0, 0, n - 1, nums);\n    }\n\n    public void update(int index, int val) {\n        change(index, val, 0, 0, n - 1);\n    }\n\n    public int sumRange(int left, int right) {\n        return range(left, right, 0, 0, n - 1);\n    }\n\n    private void build(int node, int s, int e, int[] nums) {\n        if (s == e) {\n            segmentTree[node] = nums[s];\n            return;\n        }\n        int m = s + (e - s) / 2;\n        build(node * 2 + 1, s, m, nums);\n        build(node * 2 + 2, m + 1, e, nums);\n        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n    }\n\n    private void change(int index, int val, int node, int s, int e) {\n        if (s == e) {\n            segmentTree[node] = val;\n            return;\n        }\n        int m = s + (e - s) / 2;\n        if (index <= m) {\n            change(index, val, node * 2 + 1, s, m);\n        } else {\n            change(index, val, node * 2 + 2, m + 1, e);\n        }\n        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n    }\n\n    private int range(int left, int right, int node, int s, int e) {\n        if (left == s && right == e) {\n            return segmentTree[node];\n        }\n        int m = s + (e - s) / 2;\n        if (right <= m) {\n            return range(left, right, node * 2 + 1, s, m);\n        } else if (left > m) {\n            return range(left, right, node * 2 + 2, m + 1, e);\n        } else {\n            return range(left, m, node * 2 + 1, s, m) + range(m + 1, right, node * 2 + 2, m + 1, e);\n        }\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class NumArray {\n    private int[] segmentTree;\n    private int n;\n\n    public NumArray(int[] nums) {\n        n = nums.Length;\n        segmentTree = new int[nums.Length * 4];\n        Build(0, 0, n - 1, nums);\n    }\n\n    public void Update(int index, int val) {\n        Change(index, val, 0, 0, n - 1);\n    }\n\n    public int SumRange(int left, int right) {\n        return Range(left, right, 0, 0, n - 1);\n    }\n\n    private void Build(int node, int s, int e, int[] nums) {\n        if (s == e) {\n            segmentTree[node] = nums[s];\n            return;\n        }\n        int m = s + (e - s) / 2;\n        Build(node * 2 + 1, s, m, nums);\n        Build(node * 2 + 2, m + 1, e, nums);\n        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n    }\n\n    private void Change(int index, int val, int node, int s, int e) {\n        if (s == e) {\n            segmentTree[node] = val;\n            return;\n        }\n        int m = s + (e - s) / 2;\n        if (index <= m) {\n            Change(index, val, node * 2 + 1, s, m);\n        } else {\n            Change(index, val, node * 2 + 2, m + 1, e);\n        }\n        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n    }\n\n    private int Range(int left, int right, int node, int s, int e) {\n        if (left == s && right == e) {\n            return segmentTree[node];\n        }\n        int m = s + (e - s) / 2;\n        if (right <= m) {\n            return Range(left, right, node * 2 + 1, s, m);\n        } else if (left > m) {\n            return Range(left, right, node * 2 + 2, m + 1, e);\n        } else {\n            return Range(left, m, node * 2 + 1, s, m) + Range(m + 1, right, node * 2 + 2, m + 1, e);\n        }\n    }\n}\n```\n\n```C [sol2-C]\ntypedef struct {\n    int * segmentTree;\n    int numsSize; \n} NumArray;\n\nvoid build(int * segmentTree, int node, int s, int e, const int * nums) {\n    if (s == e) {\n        segmentTree[node] = nums[s];\n        return;\n    }\n    int m = s + (e - s) / 2;\n    build(segmentTree, node * 2 + 1, s, m, nums);\n    build(segmentTree, node * 2 + 2, m + 1, e, nums);\n    segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n}\n\nvoid change(int * segmentTree, int index, int val, int node, int s, int e) {\n    if (s == e) {\n        segmentTree[node] = val;\n        return;\n    }\n    int m = s + (e - s) / 2;\n    if (index <= m) {\n        change(segmentTree, index, val, node * 2 + 1, s, m);\n    } else {\n        change(segmentTree, index, val, node * 2 + 2, m + 1, e);\n    }\n    segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n}\n\nint range(const int * segmentTree, int left, int right, int node, int s, int e) {\n    if (left == s && right == e) {\n        return segmentTree[node];\n    }\n    int m = s + (e - s) / 2;\n    if (right <= m) {\n        return range(segmentTree, left, right, node * 2 + 1, s, m);\n    } else if (left > m) {\n        return range(segmentTree, left, right, node * 2 + 2, m + 1, e);\n    } else {\n        return range(segmentTree, left, m, node * 2 + 1, s, m) + \\\n               range(segmentTree, m + 1, right, node * 2 + 2, m + 1, e);\n    }\n}\n\n\nNumArray* numArrayCreate(int* nums, int numsSize) {\n    NumArray * obj = (int *)malloc(sizeof(NumArray));\n    obj->numsSize = numsSize;\n    obj->segmentTree = (int *)malloc(sizeof(int) * 4 * numsSize);\n    build(obj->segmentTree, 0, 0, numsSize - 1, nums);\n    return obj;\n}\n\nvoid numArrayUpdate(NumArray* obj, int index, int val) {\n    change(obj->segmentTree, index, val, 0, 0, obj->numsSize - 1);\n}\n\nint numArraySumRange(NumArray* obj, int left, int right) {\n    return range(obj->segmentTree, left, right, 0, 0, obj->numsSize - 1);\n}\n\nvoid numArrayFree(NumArray* obj) {\n    free(obj->segmentTree);\n    free(obj);\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar NumArray = function(nums) {\n    n = nums.length;\n    this.segmentTree = new Array(nums.length * 4).fill(0);\n    this.build(0, 0, n - 1, nums);\n};\n\nNumArray.prototype.update = function(index, val) {\n    this.change(index, val, 0, 0, n - 1);\n};\n\nNumArray.prototype.sumRange = function(left, right) {\n    return this.range(left, right, 0, 0, n - 1);\n};\n\nNumArray.prototype.build = function(node, s, e, nums) {\n    if (s === e) {\n        this.segmentTree[node] = nums[s];\n        return;\n    }\n    const m = s + Math.floor((e - s) / 2);\n    this.build(node * 2 + 1, s, m, nums);\n    this.build(node * 2 + 2, m + 1, e, nums);\n    this.segmentTree[node] = this.segmentTree[node * 2 + 1] + this.segmentTree[node * 2 + 2];\n}\n\nNumArray.prototype.change = function(index, val, node, s, e) {\n    if (s === e) {\n        this.segmentTree[node] = val;\n        return;\n    }\n    const m = s + Math.floor((e - s) / 2);\n    if (index <= m) {\n        this.change(index, val, node * 2 + 1, s, m);\n    } else {\n        this.change(index, val, node * 2 + 2, m + 1, e);\n    }\n    this.segmentTree[node] = this.segmentTree[node * 2 + 1] + this.segmentTree[node * 2 + 2];\n}\n\nNumArray.prototype.range = function(left, right, node, s, e) {\n    if (left === s && right === e) {\n        return this.segmentTree[node];\n    }\n    const m = s + Math.floor((e - s) / 2);\n    if (right <= m) {\n        return this.range(left, right, node * 2 + 1, s, m);\n    } else if (left > m) {\n        return this.range(left, right, node * 2 + 2, m + 1, e);\n    } else {\n        return this.range(left, m, node * 2 + 1, s, m) + this.range(m + 1, right, node * 2 + 2, m + 1, e);\n    }\n}\n```\n\n```go [sol2-Golang]\ntype NumArray []int\n\nfunc Constructor(nums []int) NumArray {\n    n := len(nums)\n    seg := make(NumArray, n*4)\n    seg.build(nums, 0, 0, n-1)\n    return seg\n}\n\nfunc (seg NumArray) build(nums []int, node, s, e int) {\n    if s == e {\n        seg[node] = nums[s]\n        return\n    }\n    m := s + (e-s)/2\n    seg.build(nums, node*2+1, s, m)\n    seg.build(nums, node*2+2, m+1, e)\n    seg[node] = seg[node*2+1] + seg[node*2+2]\n}\n\nfunc (seg NumArray) change(index, val, node, s, e int) {\n    if s == e {\n        seg[node] = val\n        return\n    }\n    m := s + (e-s)/2\n    if index <= m {\n        seg.change(index, val, node*2+1, s, m)\n    } else {\n        seg.change(index, val, node*2+2, m+1, e)\n    }\n    seg[node] = seg[node*2+1] + seg[node*2+2]\n}\n\nfunc (seg NumArray) range_(left, right, node, s, e int) int {\n    if left == s && right == e {\n        return seg[node]\n    }\n    m := s + (e-s)/2\n    if right <= m {\n        return seg.range_(left, right, node*2+1, s, m)\n    }\n    if left > m {\n        return seg.range_(left, right, node*2+2, m+1, e)\n    }\n    return seg.range_(left, m, node*2+1, s, m) + seg.range_(m+1, right, node*2+2, m+1, e)\n}\n\nfunc (seg NumArray) Update(index, val int) {\n    seg.change(index, val, 0, 0, len(seg)/4-1)\n}\n\nfunc (seg NumArray) SumRange(left, right int) int {\n    return seg.range_(left, right, 0, 0, len(seg)/4-1)\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：\n  \n    + 构造函数：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的大小。二叉树的高度不超过 $\\lceil \\log n \\rceil + 1$，那么 $\\textit{segmentTree}$ 的大小不超过 $2 ^ {\\lceil \\log n \\rceil + 1} - 1 \\le 4n$，所以 $\\textit{build}$ 的时间复杂度为 $O(n)$。\n    \n    + $\\textit{update}$ 函数：$O(\\log n)$。因为树的高度不超过 $\\lceil \\log n \\rceil + 1$，所以涉及更新的结点数不超过 $\\lceil \\log n \\rceil + 1$。\n    \n    + $\\textit{sumRange}$ 函数：$O(\\log n)$。每层结点最多访问四个，总共访问的结点数不超过 $4 \\times (\\lceil \\log n \\rceil + 1)$。\n\n+ 空间复杂度：$O(n)$。保存 $\\textit{segmentTree}$ 需要 $O(n)$ 的空间。\n\n#### 方法三：树状数组\n\n**思路与算法**\n\n关于树状数组的详细介绍可以参考百度百科「[树状数组](https://baike.baidu.com/item/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84)」，本文不作过多介绍。\n\n树状数组是一种可以动态维护序列前缀和的数据结构（序列下标从 $1$ 开始），它的功能是：\n\n+ 单点修改 $\\textit{add}(\\textit{index}, \\textit{val})$：把序列第 $\\textit{index}$ 个数增加 $\\textit{val}$；\n\n+ 区间查询 $\\textit{prefixSum}(\\textit{index})$：查询前 $\\textit{index}$ 个元素的前缀和。\n\n因为题目要求实现更新 $\\textit{nums}$ 在某个位置的值，因此我们保存原始的 $\\textit{nums}$ 数组。\n\n+ 构造函数\n\n    树状数组初始对应一个零序列，因此我们遍历 $\\textit{nums}$ 数组，调用 $\\textit{add}$ 函数来更新树状数组。\n\n+ $\\textit{update}$ 函数\n\n    获取 $\\textit{nums}$ 在 $\\textit{index}$ 的增加值， 调用 $\\textit{add}$ 函数更新树状数组，并更新 $\\textit{nums}[\\textit{index}] = \\textit{val}$。\n\n+ $\\textit{sumRange}$ 函数\n\n    区间和 $[\\textit{left}, \\textit{right}]$ 可以转化为两个前缀和之差，调用树状数组的 $\\textit{prefixSum}$ 函数获取前 $\\textit{right} + 1$ 个元素的前缀和 $\\textit{sum}_1$ 和前 $\\textit{left}$ 个元素的前缀和 $\\textit{sum}_2$，返回 $\\textit{sum}_1 - \\textit{sum}_2$。 \n\n**代码**\n\n```Python [sol3-Python3]\nclass NumArray:\n    def __init__(self, nums: List[int]):\n        self.nums = nums\n        self.tree = [0] * (len(nums) + 1)\n        for i, num in enumerate(nums, 1):\n            self.add(i, num)\n\n    def add(self, index: int, val: int):\n        while index < len(self.tree):\n            self.tree[index] += val\n            index += index & -index\n\n    def prefixSum(self, index) -> int:\n        s = 0\n        while index:\n            s += self.tree[index]\n            index &= index - 1\n        return s\n\n    def update(self, index: int, val: int) -> None:\n        self.add(index + 1, val - self.nums[index])\n        self.nums[index] = val\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefixSum(right + 1) - self.prefixSum(left)\n```\n\n```C++ [sol3-C++]\nclass NumArray {\nprivate:\n    vector<int> tree;\n    vector<int> &nums;\n\n    int lowBit(int x) {\n        return x & -x;\n    }\n\n    void add(int index, int val) {\n        while (index < tree.size()) {\n            tree[index] += val;\n            index += lowBit(index);\n        }\n    }\n\n    int prefixSum(int index) {\n        int sum = 0;\n        while (index > 0) {\n            sum += tree[index];\n            index -= lowBit(index);\n        }\n        return sum;\n    }\n\npublic:\n    NumArray(vector<int>& nums) : tree(nums.size() + 1), nums(nums) {\n        for (int i = 0; i < nums.size(); i++) {\n            add(i + 1, nums[i]);\n        }\n    }\n\n    void update(int index, int val) {\n        add(index + 1, val - nums[index]);\n        nums[index] = val;\n    }\n\n    int sumRange(int left, int right) {\n        return prefixSum(right + 1) - prefixSum(left);\n    }\n};\n```\n\n```Java [sol3-Java]\nclass NumArray {\n    private int[] tree;\n    private int[] nums;\n\n    public NumArray(int[] nums) {\n        this.tree = new int[nums.length + 1];\n        this.nums = nums;\n        for (int i = 0; i < nums.length; i++) {\n            add(i + 1, nums[i]);\n        }\n    }\n\n    public void update(int index, int val) {\n        add(index + 1, val - nums[index]);\n        nums[index] = val;\n    }\n\n    public int sumRange(int left, int right) {\n        return prefixSum(right + 1) - prefixSum(left);\n    }\n\n    private int lowBit(int x) {\n        return x & -x;\n    }\n\n    private void add(int index, int val) {\n        while (index < tree.length) {\n            tree[index] += val;\n            index += lowBit(index);\n        }\n    }\n\n    private int prefixSum(int index) {\n        int sum = 0;\n        while (index > 0) {\n            sum += tree[index];\n            index -= lowBit(index);\n        }\n        return sum;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class NumArray {\n    private int[] tree;\n    private int[] nums;\n\n    public NumArray(int[] nums) {\n        this.tree = new int[nums.Length + 1];\n        this.nums = nums;\n        for (int i = 0; i < nums.Length; i++) {\n            Add(i + 1, nums[i]);\n        }\n    }\n    \n    public void Update(int index, int val) {\n        Add(index + 1, val - nums[index]);\n        nums[index] = val;\n    }\n    \n    public int SumRange(int left, int right) {\n        return PrefixSum(right + 1) - PrefixSum(left);\n    }\n\n    private int LowBit(int x) {\n        return x & -x;\n    }\n\n    private void Add(int index, int val) {\n        while (index < tree.Length) {\n            tree[index] += val;\n            index += LowBit(index);\n        }\n    }\n\n    private int PrefixSum(int index) {\n        int sum = 0;\n        while (index > 0) {\n            sum += tree[index];\n            index -= LowBit(index);\n        }\n        return sum;\n    }\n}\n```\n\n```C [sol3-C]\ntypedef struct {\n    int * nums;\n    int * tree;\n    int treeSize;\n} NumArray;\n\nint lowBit(int x) {\n    return x & -x;\n}\n\nvoid add(int * tree, int treeSize, int index, int val) {\n    while (index < treeSize) {\n        tree[index] += val;\n        index += lowBit(index);\n    }\n}\n\nint prefixSum(const int * tree, int index) {\n    int sum = 0;\n    while (index > 0) {\n        sum += tree[index];\n        index -= lowBit(index);\n    }\n    return sum;\n}\n\nNumArray* numArrayCreate(int* nums, int numsSize) {\n    NumArray * obj = (NumArray *)malloc(sizeof(NumArray));\n    obj->nums = (int *)malloc(sizeof(int) * numsSize);\n    memcpy(obj->nums, nums, sizeof(int) * numsSize);\n    obj->treeSize = numsSize + 1;\n    obj->tree = (int *)malloc(sizeof(int) * obj->treeSize);\n    memset(obj->tree, 0, sizeof(int) * obj->treeSize);\n    for (int i = 0; i < numsSize; i++) {\n        add(obj->tree, obj->treeSize, i + 1, nums[i]);\n    }\n    return obj;\n}\n\nvoid numArrayUpdate(NumArray* obj, int index, int val) {\n    add(obj->tree, obj->treeSize, index + 1, val - obj->nums[index]);\n    obj->nums[index] = val;\n}\n\nint numArraySumRange(const NumArray* obj, int left, int right) {\n    return prefixSum(obj->tree, right + 1) - prefixSum(obj->tree, left);\n}\n\nvoid numArrayFree(NumArray* obj) {\n    free(obj->nums);\n    free(obj->tree);\n    free(obj);\n}\n```\n\n```JavaScript [sol3-JavaScript]\nvar NumArray = function(nums) {\n    this.tree = new Array(nums.length + 1).fill(0);\n    this.nums = nums;\n    for (let i = 0; i < nums.length; i++) {\n        this.add(i + 1, nums[i]);\n    }\n};\n\nNumArray.prototype.update = function(index, val) {\n    this.add(index + 1, val - this.nums[index]);\n    this.nums[index] = val;\n};\n\nNumArray.prototype.sumRange = function(left, right) {\n    return this.prefixSum(right + 1) - this.prefixSum(left);\n};\n\nNumArray.prototype.lowBit = function(x) {\n    return x & -x;\n}\n\nNumArray.prototype.add = function(index, val) {\n    while (index < this.tree.length) {\n        this.tree[index] += val;\n        index += this.lowBit(index);\n    }\n}\n\nNumArray.prototype.prefixSum = function(index) {\n    let sum = 0;\n    while (index > 0) {\n        sum += this.tree[index];\n        index -= this.lowBit(index);\n    }\n    return sum;\n}\n```\n\n```go [sol3-Golang]\ntype NumArray struct {\n    nums, tree []int\n}\n\nfunc Constructor(nums []int) NumArray {\n    tree := make([]int, len(nums)+1)\n    na := NumArray{nums, tree}\n    for i, num := range nums {\n        na.add(i+1, num)\n    }\n    return na\n}\n\nfunc (na *NumArray) add(index, val int) {\n    for ; index < len(na.tree); index += index & -index {\n        na.tree[index] += val\n    }\n}\n\nfunc (na *NumArray) prefixSum(index int) (sum int) {\n    for ; index > 0; index &= index - 1 {\n        sum += na.tree[index]\n    }\n    return\n}\n\nfunc (na *NumArray) Update(index, val int) {\n    na.add(index+1, val-na.nums[index])\n    na.nums[index] = val\n}\n\nfunc (na *NumArray) SumRange(left, right int) int {\n    return na.prefixSum(right+1) - na.prefixSum(left)\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：\n  \n    + 构造函数：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{nums}$ 的大小。$\\textit{add}$ 函数的时间复杂度是 $O(\\log n)$，总共调用 $n$ 次。\n    \n    + $\\textit{update}$ 函数：$O(\\log n)$。$\\textit{add}$ 函数的时间复杂度是 $O(\\log n)$。\n    \n    + $\\textit{sumRange}$ 函数：$O(\\log n)$。$\\textit{prefixSum}$ 函数的时间复杂度是 $O(\\log n)$。\n\n+ 空间复杂度：$O(n)$。保存 $\\textit{tree}$ 需要 $O(n)$ 的空间。"
}