{
	"titleSlug": "EJvmW4",
	"slug": "by-endlesscheng-pk2q",
	"url": "https://leetcode-cn.com/problems/EJvmW4/solution/by-endlesscheng-pk2q/",
	"content": "#### 提示 1\r\n\r\n考虑计算前 $i$ 个舱室需要的最小能量，由于题目中只有联合屏障会涉及到相邻的舱室，因此可以往 DP 上去思考。\r\n\r\n#### 提示 2\r\n\r\n对于一个固定的舱室，其联合屏障在不同时间点上可能是不一样的，有时会和上一个舱室联合，有时会和下一个舱室联合，有时没有联合。\r\n\r\n因此对于 DP，我们不能直接一刀切地划分，而是要细细枚举每个时间点上的联合情况。（或者说划分是一条曲线，可以结合提示 3 思考）\r\n\r\n#### 提示 3\r\n\r\n枚举第 $i-1$ 个舱室在哪些时间点（记作 $\\textit{pre}$ 集合）开启了联合屏障，这会对第 $i$ 个舱室产生如下影响（限制）：\r\n\r\n- 第 $i$ 个舱室在属于 $\\textit{pre}$ 集合的时间点，由于被第 $i-1$ 个舱室的联合屏障保护，无需开启任何屏障；\r\n- 第 $i$ 个舱室在不属于 $\\textit{pre}$ 集合的时间点，可以选择开启联合屏障，也可以选择开启单独屏障；若该时间点没有受到陨石雨的冲击，还可以选择不开启屏障。\r\n\r\n#### 提示 4\r\n\r\n将「开启联合屏障的时间点集合」当作状态中的一个维度。\r\n\r\n---\r\n\r\n定义 $f[i][j]$ 表示考虑前 $i$ 个舱室，且第 $i$ 个舱室与第 $i+1$ 个舱室开启联合屏障的时间点集合为 $j$ 时，所需的最小能量。\r\n\r\n考虑 $f[i][j]$ 的转移来源。由于联合屏障的限制，我们需要枚举第 $i-1$ 个舱室开启联合屏障的时间点集合 $\\textit{pre}$，满足 $\\textit{pre}\\cap j=\\varnothing$，即集合 $\\textit{pre}$ 与集合 $j$ 的交集为空。\r\n\r\n剩下需要考虑的就是既不属于集合 $\\textit{pre}$ 又不属于集合 $j$ 的时间点了，如果在这些时间点上受到陨石雨的冲击，那么对应的时间点必须单独开启屏障。\r\n\r\n记 $\\textit{union}[j]$ 表示开启联合屏障的时间点集合**恰好**为 $j$ 时，所需要的能量：如果两个时间点相邻，则可以花费 $1$ 能量继续维持，否则花费 $3$ 能量重新开启。\r\n\r\n记 $\\textit{single}[j]$ 表示开启单独屏障的时间点集合**恰好**为 $j$ 时，所需要的能量：如果两个时间点相邻，则可以花费 $1$ 能量继续维持，否则花费 $2$ 能量重新开启。\r\n\r\n因此有\r\n\r\n$$\r\nf[i][j] = \\min_{\\textit{pre}\\cap j=\\varnothing} f[i-1][\\textit{pre}] + \\textit{union}[j] + \\textit{single}[k]\r\n$$\r\n\r\n其中 $k$ 为既不属于集合 $\\textit{pre}$ 又不属于集合 $j$，且第 $i$ 个舱室受到陨石雨冲击的时间点集合。\r\n\r\n设 $n=\\max(\\textit{position})$，最后答案为 $f[n][\\varnothing]$，因为最后一个舱室无需开启联合屏障。\r\n\r\n代码实现时，$\\textit{single}$ 和 $\\textit{union}$ 都可以预处理出来，且用二进制表示集合。\r\n\r\n时间复杂度为 $O(n\\cdot 3^m)$，其中 $n=\\max(\\textit{position})$，$m=\\max(\\textit{time})$。对于每个舱室 $i$，状态转移次数为 $j$ 的每个子集的子集个数之和，由于元素个数为 $k$ 的集合有 $C(m,k)$ 个，其子集有 $2^k$ 个，根据二项式定理，$\\sum C(m,k)2^k = (2+1)^m = 3^m$，所以对每个 $i$，状态转移次数为 $O(3^m)$，因此总的时间复杂度为 $O(n\\cdot 3^m)$。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def defendSpaceCity(self, time: List[int], position: List[int]) -> int:\r\n        n, m = max(position), 1 << max(time)\r\n        rain = [0] * (n + 1)\r\n        for t, p in zip(time, position):\r\n            rain[p] |= 1 << (t - 1)\r\n\r\n        union = [0] * m\r\n        single = [0] * m\r\n        for i in range(1, m):\r\n            lb = i & -i\r\n            j = i ^ lb\r\n            lb2 = j & -j\r\n            union[i] = union[j] + (1 if lb == (lb2 >> 1) else 3)  # lb == (lb2 >> 1) 表示两个时间点相邻\r\n            single[i] = single[j] + (1 if lb == (lb2 >> 1) else 2)  # 递推\r\n\r\n        f = [[inf] * m for _ in range(n + 1)]\r\n        for j in range(m):\r\n            f[0][j] = union[j] + single[((m - 1) ^ j) & rain[0]]\r\n        for i in range(1, n + 1):\r\n            for j in range(m):\r\n                pre = mask = (m - 1) ^ j\r\n                while True:  # 枚举 j 的补集 mask 中的子集 pre\r\n                    cost = f[i - 1][pre] + union[j] + single[(mask ^ pre) & rain[i]]\r\n                    f[i][j] = min(f[i][j], cost)\r\n                    if pre == 0:\r\n                        break\r\n                    pre = (pre - 1) & mask\r\n        return f[n][0]\r\n```\r\n\r\n\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public int defendSpaceCity(int[] time, int[] position) {\r\n        var n = Arrays.stream(position).max().getAsInt();\r\n        var m = 1 << Arrays.stream(time).max().getAsInt();\r\n        var rain = new int[n + 1];\r\n        for (var i = 0; i < time.length; i++)\r\n            rain[position[i]] |= 1 << (time[i] - 1);\r\n\r\n        var union = new int[m];\r\n        var single = new int[m];\r\n        for (var i = 1; i < m; i++) {\r\n            int lb = i & -i, j = i ^ lb, lb2 = j & -j;\r\n            union[i] = union[j] + (lb == (lb2 >> 1) ? 1 : 3); // lb == (lb2 >> 1) 表示两个时间点相邻\r\n            single[i] = single[j] + (lb == (lb2 >> 1) ? 1 : 2); // 递推\r\n        }\r\n\r\n        var f = new int[n + 1][m];\r\n        for (var j = 0; j < m; j++)\r\n            f[0][j] = union[j] + single[((m - 1) ^ j) & rain[0]];\r\n        for (var i = 1; i <= n; ++i) {\r\n            Arrays.fill(f[i], Integer.MAX_VALUE / 2);\r\n            for (var j = 0; j < m; ++j)\r\n                // 枚举 j 的补集 mask 中的子集 pre\r\n                for (int mask = (m - 1) ^ j, pre = mask; ; pre = (pre - 1) & mask) {\r\n                    var cost = f[i - 1][pre] + union[j] + single[(mask ^ pre) & rain[i]];\r\n                    f[i][j] = Math.min(f[i][j], cost);\r\n                    if (pre == 0) break;\r\n                }\r\n        }\r\n        return f[n][0];\r\n    }\r\n}\r\n```\r\n\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int defendSpaceCity(vector<int> &time, vector<int> &position) {\r\n        int n = *max_element(position.begin(), position.end());\r\n        int m = 1 << *max_element(time.begin(), time.end());\r\n        int rain[n + 1]; memset(rain, 0, sizeof(rain));\r\n        for (int i = 0; i < time.size(); ++i)\r\n            rain[position[i]] |= 1 << (time[i] - 1);\r\n\r\n        int un[m], single[m];\r\n        un[0] = single[0] = 0;\r\n        for (int i = 1; i < m; ++i) {\r\n            int lb = i & -i, j = i ^ lb, lb2 = j & -j;\r\n            un[i] = un[j] + (lb == (lb2 >> 1) ? 1 : 3); // lb == (lb2 >> 1) 表示两个时间点相邻\r\n            single[i] = single[j] + (lb == (lb2 >> 1) ? 1 : 2); // 递推\r\n        }\r\n\r\n        int f[n + 1][m]; memset(f, 0x3f, sizeof(f));\r\n        for (int j = 0; j < m; ++j)\r\n            f[0][j] = un[j] + single[((m - 1) ^ j) & rain[0]];\r\n        for (int i = 1; i <= n; ++i)\r\n            for (int j = 0; j < m; ++j)\r\n                // 枚举 j 的补集 mask 中的子集 pre\r\n                for (int mask = (m - 1) ^ j, pre = mask;; pre = (pre - 1) & mask) {\r\n                    int cost = f[i - 1][pre] + un[j] + single[(mask ^ pre) & rain[i]];\r\n                    f[i][j] = min(f[i][j], cost);\r\n                    if (pre == 0) break;\r\n                }\r\n        return f[n][0];\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc defendSpaceCity(time, position []int) int {\r\n\tconst n, m = 100, 1 << 5\r\n\train := [n + 1]int{}\r\n\tfor i, t := range time {\r\n\t\train[position[i]] |= 1 << (t - 1)\r\n\t}\r\n\r\n\tvar union, single [m]int\r\n\tfor i := 1; i < m; i++ {\r\n\t\tlb := i & -i\r\n\t\tj := i ^ lb\r\n\t\tlb2 := j & -j\r\n\t\tif lb == lb2>>1 { // 两个时间点相邻\r\n\t\t\tunion[i] = union[j] + 1\r\n\t\t\tsingle[i] = single[j] + 1 // 递推\r\n\t\t} else {\r\n\t\t\t// 若 i 的二进制包含 101，对于联合屏障选择继续维持是更优的，\r\n\t\t\t// 不过下面的 DP 已经枚举了所有的情况，自然会选择更优的方案\r\n\t\t\tunion[i] = union[j] + 3\r\n\t\t\tsingle[i] = single[j] + 2\r\n\t\t}\r\n\t}\r\n\r\n\tf := [n + 1][m]int{}\r\n\tfor j := range f[0] {\r\n\t\tf[0][j] = union[j] + single[(m-1^j)&rain[0]]\r\n\t}\r\n\tfor i := 1; i <= n; i++ {\r\n\t\tfor j := range f[i] {\r\n\t\t\tf[i][j] = math.MaxInt32 / 2\r\n\t\t\tmask := m - 1 ^ j\r\n\t\t\tfor pre := mask; ; pre = (pre - 1) & mask { // 枚举 j 的补集 mask 中的子集 pre\r\n\t\t\t\tcost := f[i-1][pre] + union[j] + single[(mask^pre)&rain[i]]\r\n\t\t\t\tf[i][j] = min(f[i][j], cost)\r\n\t\t\t\tif pre == 0 { break }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn f[n][0]\r\n}\r\n\r\nfunc min(a, b int) int { if a > b { return b }; return a }\r\n```"
}