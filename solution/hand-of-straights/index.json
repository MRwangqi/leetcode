{
	"titleSlug": "hand-of-straights",
	"slug": "yi-shou-shun-zi-by-leetcode-solution-4lwn",
	"url": "https://leetcode-cn.com/problems/hand-of-straights/solution/yi-shou-shun-zi-by-leetcode-solution-4lwn/",
	"content": "#### 方法一：贪心\n\n题目要求将数组 $\\textit{hand}$ 中的牌分组使得每组的大小是 $\\textit{groupSize}$。假设数组 $\\textit{hand}$ 的长度是 $n$，只有当 $n \\bmod \\textit{groupSize} = 0$ 时才可能完成分组，因此如果 $n \\bmod \\textit{groupSize} \\ne 0$ 则直接返回 $\\text{false}$。\n\n当 $n \\bmod \\textit{groupSize} = 0$ 时，可以将数组 $\\textit{hand}$ 中的牌分组使得每组的大小是 $\\textit{groupSize}$，此时需要判断是否存在一种分组方式使得同一组的牌都是连续的。\n\n由于每张牌都必须被分到某个组，因此可以使用贪心的策略。假设尚未分组的牌中，最小的数字是 $x$，则如果存在符合要求的分组方式，$x$ 一定是某个组中的最小数字（否则 $x$ 不属于任何一个组，不符合每张牌都必须被分到某个组），该组的数字范围是 $[x, x + \\textit{groupSize} - 1]$。在将 $x$ 到 $x + \\textit{groupSize} - 1$ 的 $\\textit{groupSize}$ 张牌分成一个组之后，继续使用贪心的策略对剩下的牌分组，直到所有的牌分组结束或者无法完成分组。如果在分组过程中发现从最小数字开始的连续 $\\textit{groupSize}$ 个数字中有不存在的数字，则无法完成分组。\n\n首先对数组 $\\textit{hand}$ 排序，并使用哈希表记录数组 $\\textit{hand}$ 中每个元素的出现次数，然后遍历数组 $\\textit{hand}$，使用基于上述贪心策略的做法判断是否可以完成分组。贪心策略的具体做法如下：\n\n1. 将当前元素记为 $x$，如果 $x$ 不在哈希表中则跳过，如果 $x$ 在哈希表中，则 $x$ 是某个组中的最小数字（因为数组 $\\textit{hand}$ 有序，当遍历到 $x$ 时，$x$ 一定是所有尚未分组的元素中的最小数字），该组的数字范围是 $[x, x + \\textit{groupSize} - 1]$；\n\n2. 如果可以完成分组，则 $x$ 到 $x + \\textit{groupSize} - 1$ 的每个整数在哈希表中记录的出现次数都至少为 $1$，如果遇到某个整数的出现次数为 $0$ 则无法完成分组，返回 $\\text{false}$；\n\n3. 将 $x$ 到 $x + \\textit{groupSize} - 1$ 的每个整数在哈希表中记录的出现次数减 $1$，如果出现次数减为 $0$ 则从哈希表中移除该整数；\n\n4. 对于其余元素，重复上述操作，直到遍历结束。\n\n遍历结束之后，如果没有出现无法完成分组的情况，返回 $\\text{true}$。\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean isNStraightHand(int[] hand, int groupSize) {\n        int n = hand.length;\n        if (n % groupSize != 0) {\n            return false;\n        }\n        Arrays.sort(hand);\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        for (int x : hand) {\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n        }\n        for (int x : hand) {\n            if (!cnt.containsKey(x)) {\n                continue;\n            }\n            for (int j = 0; j < groupSize; j++) {\n                int num = x + j;\n                if (!cnt.containsKey(num)) {\n                    return false;\n                }\n                cnt.put(num, cnt.get(num) - 1);\n                if (cnt.get(num) == 0) {\n                    cnt.remove(num);\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool IsNStraightHand(int[] hand, int groupSize) {\n        int n = hand.Length;\n        if (n % groupSize != 0) {\n            return false;\n        }\n        Array.Sort(hand);\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        foreach (int x in hand) {\n            if (!cnt.ContainsKey(x)) {\n                cnt.Add(x, 0);\n            }\n            cnt[x]++;\n        }\n        foreach (int x in hand) {\n            if (!cnt.ContainsKey(x)) {\n                continue;\n            }\n            for (int j = 0; j < groupSize; j++) {\n                int num = x + j;\n                if (!cnt.ContainsKey(num)) {\n                    return false;\n                }\n                cnt[num]--;\n                if (cnt[num] == 0) {\n                    cnt.Remove(num);\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool isNStraightHand(vector<int>& hand, int groupSize) {\n        int n = hand.size();\n        if (n % groupSize != 0) {\n            return false;\n        }\n        sort(hand.begin(), hand.end());\n        unordered_map<int, int> cnt;\n        for (auto & num : hand) {\n            cnt[num]++;\n        }\n        for (auto & x : hand) {\n            if (!cnt.count(x)) {\n                continue;\n            }\n            for (int j = 0; j < groupSize; j++) {\n                int num = x + j;\n                if (!cnt.count(num)) {\n                    return false;\n                }\n                cnt[num]--;\n                if (cnt[num] == 0) {\n                    cnt.erase(num);\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n```C [sol1-C]\nstatic int cmp(const void * pa, const void * pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\ntypedef struct Node {\n    int val;\n    int freq;\n} Node;\n\nbool isNStraightHand(int* hand, int handSize, int groupSize) {\n    if (handSize % groupSize != 0) {\n        return false;\n    }\n    qsort(hand, handSize, sizeof(int), cmp);\n    Node * cnt = (Node *)malloc(sizeof(Node) * handSize);\n    memset(cnt, 0, sizeof(Node) * handSize);\n    int cardSize = 0;\n    for (int i = 0; i < handSize; ++i) {\n        if (i == 0) {\n            cnt[cardSize].val = hand[i];\n            cnt[cardSize].freq = 1;\n        } else {\n            if(hand[i] != cnt[cardSize].val) {\n                cardSize++;\n            } \n            cnt[cardSize].val = hand[i];\n            cnt[cardSize].freq++;\n        }\n    }\n    int pos = 0;\n    for (int i = 0; i < handSize; ++i) {\n        while (pos < cardSize && cnt[pos].freq == 0) {\n            pos++;\n        }\n        if (cnt[pos].val == hand[i] && cnt[pos].freq > 0) {\n            for (int j = 0; j < groupSize; ++j) {\n                int num = hand[i] + j;\n                if (cnt[pos + j].freq > 0 && cnt[pos + j].val == num) {\n                    cnt[pos + j].freq--;\n                } else {\n                    return false;\n                }\n            }\n        } \n    }\n    free(cnt);\n    return true;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar isNStraightHand = function(hand, groupSize) {\n    const n = hand.length;\n    if (n % groupSize !== 0) {\n        return false;\n    }\n    hand.sort((a, b) => a - b);\n    const cnt = new Map();\n    for (const x of hand) {\n        cnt.set(x, (cnt.get(x) || 0) + 1);\n    }\n    for (const x of hand) {\n        if (!cnt.has(x)) {\n            continue;\n        }\n        for (let j = 0; j < groupSize; j++) {\n            const num = x + j;\n            if (!cnt.has(num)) {\n                return false;\n            }\n            cnt.set(num, cnt.get(num) - 1);\n            if (cnt.get(num) == 0) {\n                cnt.delete(num);\n            }\n        }\n    }\n    return true;\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize > 0:\n            return False\n        hand.sort()\n        cnt = Counter(hand)\n        for x in hand:\n            if cnt[x] == 0:\n                continue\n            for num in range(x, x + groupSize):\n                if cnt[num] == 0:\n                    return False\n                cnt[num] -= 1\n        return True\n```\n\n```go [sol1-Golang]\nfunc isNStraightHand(hand []int, groupSize int) bool {\n    if len(hand)%groupSize > 0 {\n        return false\n    }\n    sort.Ints(hand)\n    cnt := map[int]int{}\n    for _, num := range hand {\n        cnt[num]++\n    }\n    for _, x := range hand {\n        if cnt[x] == 0 {\n            continue\n        }\n        for num := x; num < x+groupSize; num++ {\n            if cnt[num] == 0 {\n                return false\n            }\n            cnt[num]--\n        }\n    }\n    return true\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{hand}$ 的长度。对数组 $\\textit{hand}$ 排序需要 $O(n \\log n)$ 的时间，排序之后遍历数组 $\\textit{hand}$ 两次，每次遍历过程中，每个元素的处理时间都是 $O(1)$，因此每次遍历的时间复杂度都是 $O(n)$，总时间复杂度是 $O(n \\log n)$。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{hand}$ 的长度。空间复杂度主要取决于哈希表，哈希表中最多存储 $n$ 个元素。"
}