{
	"titleSlug": "max-number-of-k-sum-pairs",
	"slug": "by-stormsunshine-hgly",
	"url": "https://leetcode-cn.com/problems/max-number-of-k-sum-pairs/solution/by-stormsunshine-hgly/",
	"content": "# 解法一\r\n\r\n## 思路和算法\r\n\r\n对于数组中的元素 $\\textit{num}$，如果数组中存在另一个**不同下标的**元素 $k - \\textit{num}$，则可以执行一次操作将 $\\textit{num}$ 和 $k - \\textit{num}$ 移除。\r\n\r\n可以使用哈希表记录数组中每个值的剩余次数。遍历数组的过程中，对于每个元素 $\\textit{num}$，记 $\\textit{num}_2 = k - \\textit{num}$，执行如下操作。\r\n\r\n- 如果 $\\textit{num}_2$ 在哈希表中的剩余次数大于 $0$，则有剩余的 $\\textit{num}_2$，可以执行一次操作将 $\\textit{num}$ 和 $\\textit{num}_2$ 移除。因此将操作数加 $1$，将 $\\textit{num}_2$ 在哈希表中的剩余次数减 $1$。\r\n\r\n- 如果 $\\textit{num}_2$ 在哈希表中的剩余次数等于 $0$，则没有剩余的 $\\textit{num}_2$，当前不能执行操作将 $\\textit{num}$ 和 $\\textit{num}_2$ 移除。因此当前的 $\\textit{num}$ 保留，将 $\\textit{num}$ 在哈希表中的剩余次数加 $1$。\r\n\r\n由于每一步操作必须移除数组中的两个整数，不能将同一个整数移除两次（移除的两个整数可以相等但是下标必须不同），因此为了避免在 $\\textit{num} = \\textit{num}_2$ 时产生错误，只有当不能执行删除操作时才将 $\\textit{num}$ 在哈希表中的剩余次数加 $1$。\r\n\r\n遍历结束之后，即可得到最大操作数。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public int maxOperations(int[] nums, int k) {\r\n        int operations = 0;\r\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\r\n        for (int num : nums) {\r\n            int num2 = k - num;\r\n            if (counts.containsKey(num2)) {\r\n                operations++;\r\n                counts.put(num2, counts.get(num2) - 1);\r\n                if (counts.get(num2) == 0) {\r\n                    counts.remove(num2);\r\n                }\r\n            } else {\r\n                counts.put(num, counts.getOrDefault(num, 0) + 1);\r\n            }\r\n        }\r\n        return operations;\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public int MaxOperations(int[] nums, int k) {\r\n        int operations = 0;\r\n        IDictionary<int, int> counts = new Dictionary<int, int>();\r\n        foreach (int num in nums) {\r\n            int num2 = k - num;\r\n            if (counts.ContainsKey(num2)) {\r\n                operations++;\r\n                counts[num2]--;\r\n                if (counts[num2] == 0) {\r\n                    counts.Remove(num2);\r\n                }\r\n            } else {\r\n                counts.TryAdd(num, 0);\r\n                counts[num]++;\r\n            }\r\n        }\r\n        return operations;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。遍历数组一次，每个元素的计算时间都是常数。\r\n\r\n- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。空间复杂度主要取决于哈希表，哈希表中的元素个数不超过 $n$。\r\n\r\n# 解法二\r\n\r\n## 思路和算法\r\n\r\n将数组排序之后，可以使用双指针计算数组中的元素之和等于 $k$ 的元素对数目，即最大操作数。\r\n\r\n用 $\\textit{left}$ 和 $\\textit{right}$ 表示两个指针，初始时 $\\textit{left}$ 和 $\\textit{right}$ 分别指向数组的最小下标和最大下标。每次计算两个指针指向的元素之和 $\\textit{sum}$，即 $\\textit{sum} = \\textit{nums}[\\textit{left}] + \\textit{nums}[\\textit{right}]$，比较 $\\textit{sum}$ 和 $k$ 的大小关系，调整指针指向的下标。\r\n\r\n- 如果 $\\textit{sum} = k$，则找到元素之和等于 $k$ 的两个元素，将操作数加 $1$。由于当前的 $\\textit{nums}[\\textit{left}]$ 和 $\\textit{nums}[\\textit{right}]$ 都被移除，因此将 $\\textit{left}$ 向右移动一位，将 $\\textit{right}$ 向左移动一位。\r\n\r\n- 如果 $\\textit{sum} < k$，则将 $\\textit{left}$ 向右移动一位。\r\n\r\n- 如果 $\\textit{sum} > k$，则将 $\\textit{right}$ 向左移动一位。\r\n\r\n上述操作的条件是 $\\textit{left} < \\textit{right}$。当 $\\textit{left} = \\textit{right}$ 时，两个指针指向同一个元素，因此不存在两个**不同下标的**元素之和等于 $k$，结束上述操作，此时即可得到最大操作数。\r\n\r\n上述做法不会遗漏掉答案，理由如下。\r\n\r\n对于任意满足 $\\textit{nums}[\\textit{left}_k] + \\textit{nums}[\\textit{right}_k] = k$ 的指针对 $(\\textit{left}_k, \\textit{right}_k)$，初始时一定有 $\\textit{left} \\le \\textit{left}_k < \\textit{right}_k \\le \\textit{right}$。如果初始时 $\\textit{left} = \\textit{left}_k$ 且 $\\textit{right} = \\textit{right}_k$，则找到两个不同下标的元素之和等于 $k$，这两个元素都被移除，因此将 $\\textit{left}$ 向右移动一位，将 $\\textit{right}$ 向左移动一位。否则，一定有 $\\textit{left}$ 先到达 $\\textit{left}_k$ 或 $\\textit{right}$ 先到达 $\\textit{right}_k$。\r\n\r\n- 如果 $\\textit{left}$ 先到达 $\\textit{left}_k$，则当 $\\textit{left}$ 到达 $\\textit{left}_k$ 时，$\\textit{right} > \\textit{right}_k$，此时 $\\textit{nums}[\\textit{left}] + \\textit{nums}[\\textit{right}] > k$，因此一定是 $\\textit{right}$ 向左移动直到 $\\textit{right} = \\textit{right}_k$。\r\n\r\n- 如果 $\\textit{right}$ 先到达 $\\textit{right}_k$，则当 $\\textit{right}$ 到达 $\\textit{right}_k$ 时，$\\textit{left} < \\textit{left}_k$，此时 $\\textit{nums}[\\textit{left}] + \\textit{nums}[\\textit{right}] < k$，因此一定是 $\\textit{left}$ 向右移动直到 $\\textit{left} = \\textit{left}_k$。\r\n\r\n因此，上述做法一定会遍历到每一对元素和等于 $k$ 的元素，不会遗漏掉答案。\r\n\r\n## 代码\r\n\r\n```Java [sol2-Java]\r\nclass Solution {\r\n    public int maxOperations(int[] nums, int k) {\r\n        int operations = 0;\r\n        Arrays.sort(nums);\r\n        int left = 0, right = nums.length - 1;\r\n        while (left < right) {\r\n            int sum = nums[left] + nums[right];\r\n            if (sum == k) {\r\n                operations++;\r\n                left++;\r\n                right--;\r\n            } else if (sum < k) {\r\n                left++;\r\n            } else {\r\n                right--;\r\n            }\r\n        }\r\n        return operations;\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol2-C#]\r\npublic class Solution {\r\n    public int MaxOperations(int[] nums, int k) {\r\n        int operations = 0;\r\n        Array.Sort(nums);\r\n        int left = 0, right = nums.Length - 1;\r\n        while (left < right) {\r\n            int sum = nums[left] + nums[right];\r\n            if (sum == k) {\r\n                operations++;\r\n                left++;\r\n                right--;\r\n            } else if (sum < k) {\r\n                left++;\r\n            } else {\r\n                right--;\r\n            }\r\n        }\r\n        return operations;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。对数组排序需要 $O(n \\log n)$ 的时间，使用双指针遍历数组计算最大操作数需要 $O(n)$ 的时间，因此时间复杂度是 $O(n \\log n + n) = O(n \\log n)$。\r\n\r\n- 空间复杂度：$O(\\log n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。空间复杂度主要取决于排序的递归调用栈空间。"
}