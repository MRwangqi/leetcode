{
	"titleSlug": "longest-uncommon-subsequence-i",
	"slug": "zui-chang-te-shu-xu-lie-i-by-leetcode-so-v9sr",
	"url": "https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/solution/zui-chang-te-shu-xu-lie-i-by-leetcode-so-v9sr/",
	"content": "#### 方法一：脑筋急转弯\n\n字符串的子序列的长度不会超过该字符串的长度。若子序列的长度等于字符串的长度，那么子序列就是该字符串。\n\n若两字符串不相同，那么我们可以选择较长的字符串作为最长特殊序列，显然它不会是较短的字符串的子序列。特别地，当两字符串长度相同时（但不是同一字符串），我们仍然可以选择其中的一个字符串作为最长特殊序列，它不会是另一个字符串的子序列。\n\n若两字符串相同，那么任一字符串的子序列均会出现在两个字符串中，此时应返回 $-1$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        return max(len(a), len(b)) if a != b else -1\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findLUSlength(string a, string b) {\n        return a != b ? max(a.length(), b.length()) : -1;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int findLUSlength(String a, String b) {\n        return !a.equals(b) ? Math.max(a.length(), b.length()) : -1;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int FindLUSlength(string a, string b) {\n        return !a.Equals(b) ? Math.Max(a.Length, b.Length) : -1;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc findLUSlength(a, b string) int {\n    if a != b {\n        return max(len(a), len(b))\n    }\n    return -1\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint findLUSlength(char * a, char * b) {\n    int lena = strlen(a);\n    int lenb = strlen(b);\n    return strcmp(a, b) != 0 ? MAX(lena, lenb) : -1;\n    \n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findLUSlength = function(a, b) {\n    return a !== b ? Math.max(a.length, b.length) : -1;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $a$ 的长度。当两字符串长度不同时，时间复杂度为 $O(1)$；当字符串长度相同时，时间复杂度为 $O(n)$。因此时间复杂度为 $O(n)$。\n\n- 空间复杂度：$O(1)$。"
}