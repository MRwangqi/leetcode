{
	"titleSlug": "shortest-subarray-to-be-removed-to-make-array-sorted",
	"slug": "by-stormsunshine-3qqs",
	"url": "https://leetcode-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solution/by-stormsunshine-3qqs/",
	"content": "# 解法一\r\n\r\n## 思路和算法\r\n\r\n这道题要求从数组 $\\textit{arr}$ 中删除最短的子数组，使剩下的元素非递减。可以将数组 $\\textit{arr}$ 分成三个子数组，三个子数组从左到右依次是 $\\textit{left}$、$\\textit{mid}$ 和 $\\textit{right}$。考虑以下两种情况。\r\n\r\n- 如果 $\\textit{arr}$ 已经是非递减的数组，则 $\\textit{left}$ 为整个数组 $\\textit{arr}$，$\\textit{mid}$ 和 $\\textit{right}$ 均为空。此时不需要删除任何元素，需要删除的最短子数组的长度是 $0$。\r\n\r\n- 如果 $\\textit{arr}$ 不是非递减的数组，则 $\\textit{left}$ 和 $\\textit{right}$ 都不为空且应尽可能长，$\\textit{mid}$ 可能为空。用 $\\textit{leftEnd}$ 表示 $\\textit{left}$ 的结束下标，用 $\\textit{rightStart}$ 表示 $\\textit{right}$ 的开始下标，则 $\\textit{arr}[\\textit{leftEnd}] > \\textit{arr}[\\textit{leftEnd} + 1]$，$\\textit{arr}[\\textit{rightStart}] < \\textit{arr}[\\textit{rightStart} - 1]$。为了使剩下的元素非递减，应将 $\\textit{mid}$ 全部删除，并需要在 $\\textit{left}$ 的结束位置和 $\\textit{right}$ 的开始位置删除零个或多个元素，使得剩余的元素满足 $\\textit{left}$ 的末尾元素小于等于 $\\textit{right}$ 的首个元素。\r\n\r\n当 $\\textit{arr}$ 不是非递减的数组时，如果存在删除长度为 $x$ 的子数组的方案使剩下的元素非递减，则一定存在删除长度大于 $x$ 的子数组的方案使剩下的元素非递减，因此可以使用二分查找得到需要删除的最短子数组的长度。二分查找的下界和上界分别记为 $\\textit{low}$ 和 $\\textit{high}$。\r\n\r\n由于 $\\textit{mid}$ 必须全部删除，因此初始时 $\\textit{low}$ 为 $\\textit{mid}$ 的长度。由于保留完整的 $\\textit{left}$ 或 $\\textit{right}$ 可以得到非递减的数组，因此初始时 $\\textit{high}$ 为 $\\textit{mid}$ 和 $\\textit{right}$ 的长度之和或 $\\textit{left}$ 和 $\\textit{mid}$ 的长度之和，两者取较小值。\r\n\r\n每次查找取 $\\textit{tmp}$ 为 $\\textit{low}$ 和 $\\textit{high}$ 的平均数向下取整，判断是否存在删除长度为 $\\textit{tmp}$ 的方案使剩下的元素非递减，执行如下操作。\r\n\r\n- 如果存在删除长度为 $\\textit{tmp}$ 的方案使剩下的元素非递减，则需要删除的最短子数组的长度小于等于 $\\textit{tmp}$，因此在下标范围 $[\\textit{low}, \\textit{tmp}]$ 中继续查找。\r\n\r\n- 如果不存在删除长度为 $\\textit{tmp}$ 的方案使剩下的元素非递减，则需要删除的最短子数组的长度大于 $\\textit{tmp}$，因此在下标范围 $[\\textit{tmp} + 1, \\textit{high}]$ 中继续查找。\r\n\r\n当 $\\textit{low} = \\textit{high}$ 时，查找结束，此时 $\\textit{low}$ 为需要删除的最短子数组的长度。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public int findLengthOfShortestSubarray(int[] arr) {\r\n        int n = arr.length;\r\n        int leftEnd = 0;\r\n        for (int i = 1; i < n && arr[i] >= arr[i - 1]; i++) {\r\n            leftEnd = i;\r\n        }\r\n        if (leftEnd == n - 1) {\r\n            return 0;\r\n        }\r\n        int rightStart = n - 1;\r\n        for (int i = n - 2; i >= 0 && arr[i] <= arr[i + 1]; i--) {\r\n            rightStart = i;\r\n        }\r\n        int low = rightStart - leftEnd - 1;\r\n        int high = Math.min(rightStart, n - leftEnd - 1);\r\n        while (low < high) {\r\n            int tmp = low + (high - low) / 2;\r\n            if (canMakeSorted(arr, leftEnd + 1, rightStart - 1, tmp)) {\r\n                high = tmp;\r\n            } else {\r\n                low = tmp + 1;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n\r\n    public boolean canMakeSorted(int[] arr, int midStart, int midEnd, int remove) {\r\n        int n = arr.length;\r\n        for (int i = midEnd - remove, j = midEnd + 1; i < midStart; i++, j++) {\r\n            if (arr[i] <= arr[j]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public int FindLengthOfShortestSubarray(int[] arr) {\r\n        int n = arr.Length;\r\n        int leftEnd = 0;\r\n        for (int i = 1; i < n && arr[i] >= arr[i - 1]; i++) {\r\n            leftEnd = i;\r\n        }\r\n        if (leftEnd == n - 1) {\r\n            return 0;\r\n        }\r\n        int rightStart = n - 1;\r\n        for (int i = n - 2; i >= 0 && arr[i] <= arr[i + 1]; i--) {\r\n            rightStart = i;\r\n        }\r\n        int low = rightStart - leftEnd - 1;\r\n        int high = Math.Min(rightStart, n - leftEnd - 1);\r\n        while (low < high) {\r\n            int tmp = low + (high - low) / 2;\r\n            if (CanMakeSorted(arr, leftEnd + 1, rightStart - 1, tmp)) {\r\n                high = tmp;\r\n            } else {\r\n                low = tmp + 1;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n\r\n    public bool CanMakeSorted(int[] arr, int midStart, int midEnd, int remove) {\r\n        int n = arr.Length;\r\n        for (int i = midEnd - remove, j = midEnd + 1; i < midStart; i++, j++) {\r\n            if (arr[i] <= arr[j]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度。需要 $O(n)$ 的时间判断数组 $\\textit{arr}$ 是否非递减，如果数组 $\\textit{arr}$ 不是非递减则需要执行 $O(\\log n)$ 次二分查找，每次二分查找的时间是 $O(n)$，因此时间复杂度是 $O(n + n \\log n) = O(n \\log n)$。\r\n\r\n- 空间复杂度：$O(1)$。\r\n\r\n# 解法二\r\n\r\n## 思路和算法\r\n\r\n根据解法一可知，为了得到需要删除的最短子数组的长度，应该从数组 $\\textit{arr}$ 的两端分别寻找最长的非递减子数组，分别记为 $\\textit{left}$ 和 $\\textit{right}$。用 $n$ 表示数组 $\\textit{arr}$ 的长度，用 $\\textit{leftEnd}$ 表示 $\\textit{left}$ 的结束下标，用 $\\textit{rightStart}$ 表示 $\\textit{right}$ 的开始下标，则对于满足 $-1 \\le i \\le \\textit{leftEnd}$ 的每个下标 $i$，需要找到满足 $\\textit{rightStart} \\le j \\le n$ 且 $\\textit{arr}[i] \\le \\textit{arr}[j]$ 的最小下标 $j$，删除下标范围 $[i + 1, j - 1]$ 的子数组之后可以使剩余元素非递减。这里规定 $\\textit{arr}[-1] = -\\infty$，$\\textit{arr}[n] = +\\infty$。\r\n\r\n由于 $\\textit{left}$ 和 $\\textit{right}$ 都是非递减子数组，因此当 $i$ 增加时，$\\textit{arr}[i]$ 不变或增加，对应的最小下标 $j$ 一定不变或增加。可以使用双指针的做法计算需要删除的最短子数组的长度。\r\n\r\n首先从数组 $\\textit{arr}$ 的两端分别寻找最长的非递减子数组，如果 $\\textit{arr}$ 已经是非递减的数组，则返回 $0$。\r\n\r\n如果 $\\textit{arr}$ 不是非递减的数组，则将需要删除的最短子数组的长度初始化为 $n - 1$（因为剩余一个元素一定非递减），然后使用双指针遍历数组 $\\textit{arr}$，计算需要删除的最短子数组的长度。\r\n\r\n用 $i$ 和 $j$ 表示双指针，初始时 $i = -1$，$j = \\textit{rightStart}$。当 $i \\le \\textit{leftEnd}$ 且 $j \\le n$ 时，对于每个下标 $i$，执行如下操作。\r\n\r\n1. 如果 $i$ 和 $j$ 都在数组下标范围中且 $\\textit{arr}[i] > \\textit{arr}[j]$，则将 $j$ 向右移动，直到 $j = n$ 或 $\\textit{arr}[i] \\le \\textit{arr}[j]$。\r\n\r\n2. 此时的 $j$ 为满足 $\\textit{arr}[i] \\le \\textit{arr}[j]$ 的最小下标 $j$，需要删除下标范围 $[i + 1, j - 1]$ 的子数组使剩余元素非递减，删除的子数组长度是 $j - i - 1$，使用 $j - i - 1$ 更新需要删除的最短子数组的长度。特别地，如果 $i = -1$ 则 $\\textit{left}$ 需要全部删除，如果 $j = n$ 则 $\\textit{right}$ 需要全部删除，当 $i$ 或 $j$ 不在数组下标范围中时，删除下标范围 $[i + 1, j - 1]$ 的子数组同样适用。\r\n\r\n遍历结束之后，即可得到需要删除的最短子数组的长度。\r\n\r\n## 代码\r\n\r\n```Java [sol2-Java]\r\nclass Solution {\r\n    public int findLengthOfShortestSubarray(int[] arr) {\r\n        int n = arr.length;\r\n        int leftEnd = 0;\r\n        while (leftEnd + 1 < n && arr[leftEnd] <= arr[leftEnd + 1]) {\r\n            leftEnd++;\r\n        }\r\n        if (leftEnd == n - 1) {\r\n            return 0;\r\n        }\r\n        int rightStart = n - 1;\r\n        while (rightStart > 0 && arr[rightStart] >= arr[rightStart - 1]) {\r\n            rightStart--;\r\n        }\r\n        int minLength = n - 1;\r\n        for (int i = -1, j = rightStart; i <= leftEnd && j <= n; i++) {\r\n            while (i >= 0 && j < n && arr[i] > arr[j]) {\r\n                j++;\r\n            }\r\n            minLength = Math.min(minLength, j - i - 1);\r\n        }\r\n        return minLength;\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol2-C#]\r\npublic class Solution {\r\n    public int FindLengthOfShortestSubarray(int[] arr) {\r\n        int n = arr.Length;\r\n        int leftEnd = 0;\r\n        while (leftEnd + 1 < n && arr[leftEnd] <= arr[leftEnd + 1]) {\r\n            leftEnd++;\r\n        }\r\n        if (leftEnd == n - 1) {\r\n            return 0;\r\n        }\r\n        int rightStart = n - 1;\r\n        while (rightStart > 0 && arr[rightStart] >= arr[rightStart - 1]) {\r\n            rightStart--;\r\n        }\r\n        int minLength = n - 1;\r\n        for (int i = -1, j = rightStart; i <= leftEnd && j <= n; i++) {\r\n            while (i >= 0 && j < n && arr[i] > arr[j]) {\r\n                j++;\r\n            }\r\n            minLength = Math.Min(minLength, j - i - 1);\r\n        }\r\n        return minLength;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度。使用双指针各遍历数组一次。\r\n\r\n- 空间复杂度：$O(1)$。"
}