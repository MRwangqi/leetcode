{
	"titleSlug": "path-with-maximum-gold",
	"slug": "huang-jin-kuang-gong-by-leetcode-solutio-f9gg",
	"url": "https://leetcode-cn.com/problems/path-with-maximum-gold/solution/huang-jin-kuang-gong-by-leetcode-solutio-f9gg/",
	"content": "#### 方法一：回溯算法\n\n**思路与算法**\n\n我们首先在 $m \\times n$ 个网格内枚举起点。只要格子内的数大于 $0$，它就可以作为起点进行开采。\n\n记枚举的起点为 $(i, j)$，我们就可以从 $(i, j)$ 开始进行递归 + 回溯，枚举所有可行的开采路径。我们用递归函数 $\\textit{dfs}(x, y, \\textit{gold})$ 进行枚举，其中 $(x, y)$ 表示当前所在的位置，$\\textit{gold}$ 表示在开采位置 $(x, y)$ 之前，已经拥有的黄金数量。根据题目的要求，我们需要进行如下的步骤：\n\n- 我们需要将 $\\textit{gold}$ 更新为 $\\textit{gold} + \\textit{grid}[x][y]$，表示对位置 $(x, y)$ 进行开采。由于我们的目标是最大化收益，因此我们还要维护一个最大的收益值 $\\textit{ans}$，并在这一步使用 $\\textit{gold}$ 更新 $\\textit{ans}$；\n\n- 我们需要枚举矿工下一步的方向。由于矿工每次可以从当前位置向上下左右四个方向走，因此我们需要依次枚举每一个方向。如果往某一个方向不会走出网格，并且走到的位置的值不为 $0$，我们就可以进行递归搜索；\n\n- 在搜索完所有方向后，我们进行回溯。\n\n需要注意的是，题目规定了「每个单元格只能被开采一次」，因此当我们到达位置 $(x, y)$ 时，我们可以将 $\\textit{grid}[x][y]$ 暂时置为 $0$；在进行回溯之前，再将 $\\textit{grid}[x][y]$ 的值恢复。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\npublic:\n    int getMaximumGold(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int ans = 0;\n\n        function<void(int, int, int)> dfs = [&](int x, int y, int gold) {\n            gold += grid[x][y];\n            ans = max(ans, gold);\n\n            int rec = grid[x][y];\n            grid[x][y] = 0;\n\n            for (int d = 0; d < 4; ++d) {\n                int nx = x + dirs[d][0];\n                int ny = y + dirs[d][1];\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] > 0) {\n                    dfs(nx, ny, gold);\n                }\n            }\n\n            grid[x][y] = rec;\n        };\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] != 0) {\n                    dfs(i, j, 0);\n                }\n            }\n        }\n\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    int[][] grid;\n    int m, n;\n    int ans = 0;\n\n    public int getMaximumGold(int[][] grid) {\n        this.grid = grid;\n        this.m = grid.length;\n        this.n = grid[0].length;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] != 0) {\n                    dfs(i, j, 0);\n                }\n            }\n        }\n        return ans;\n    }\n\n    public void dfs(int x, int y, int gold) {\n        gold += grid[x][y];\n        ans = Math.max(ans, gold);\n\n        int rec = grid[x][y];\n        grid[x][y] = 0;\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dirs[d][0];\n            int ny = y + dirs[d][1];\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] > 0) {\n                dfs(nx, ny, gold);\n            }\n        }\n\n        grid[x][y] = rec;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    static int[][] dirs = {new int[]{-1, 0}, new int[]{1, 0}, new int[]{0, -1}, new int[]{0, 1}};\n    int[][] grid;\n    int m, n;\n    int ans = 0;\n\n    public int GetMaximumGold(int[][] grid) {\n        this.grid = grid;\n        this.m = grid.Length;\n        this.n = grid[0].Length;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] != 0) {\n                    DFS(i, j, 0);\n                }\n            }\n        }\n        return ans;\n    }\n\n    public void DFS(int x, int y, int gold) {\n        gold += grid[x][y];\n        ans = Math.Max(ans, gold);\n\n        int rec = grid[x][y];\n        grid[x][y] = 0;\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dirs[d][0];\n            int ny = y + dirs[d][1];\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] > 0) {\n                DFS(nx, ny, gold);\n            }\n        }\n\n        grid[x][y] = rec;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        ans = 0\n\n        def dfs(x: int, y: int, gold: int) -> None:\n            gold += grid[x][y]\n            nonlocal ans\n            ans = max(ans, gold)\n\n            rec = grid[x][y]\n            grid[x][y] = 0\n\n            for nx, ny in ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)):\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] > 0:\n                    dfs(nx, ny, gold)\n\n            grid[x][y] = rec\n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    dfs(i, j, 0)\n\n        return ans\n```\n\n```JavaScript [sol1-JavaScript]\nvar getMaximumGold = function(grid) {\n    this.grid = grid;\n    this.m = grid.length;\n    this.n = grid[0].length;\n    this.dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    this.ans = 0;\n\n    const dfs = (x, y, gold, dirs) => {\n        gold += grid[x][y];\n        this.ans = Math.max(ans, gold);\n\n        const rec = grid[x][y];\n        grid[x][y] = 0;\n\n        for (let d = 0; d < 4; ++d) {\n            const nx = x + this.dirs[d][0];\n            const ny = y + this.dirs[d][1];\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] > 0) {\n                dfs(nx, ny, gold);\n            }\n        }\n\n        grid[x][y] = rec;\n    }\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j] !== 0) {\n                dfs(i, j, 0);\n            }\n        }\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nvar dirs = []struct{ x, y int }{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\nfunc getMaximumGold(grid [][]int) (ans int) {\n    var dfs func(x, y, gold int)\n    dfs = func(x, y, gold int) {\n        gold += grid[x][y]\n        if gold > ans {\n            ans = gold\n        }\n\n        rec := grid[x][y]\n        grid[x][y] = 0\n        for _, d := range dirs {\n            nx, ny := x+d.x, y+d.y\n            if 0 <= nx && nx < len(grid) && 0 <= ny && ny < len(grid[nx]) && grid[nx][ny] > 0 {\n                dfs(nx, ny, gold)\n            }\n        }\n        grid[x][y] = rec\n    }\n\n    for i, row := range grid {\n        for j, gold := range row {\n            if gold > 0 {\n                dfs(i, j, 0)\n            }\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn + \\min(mn, T) \\cdot 3^{\\min(mn, T)})$，其中 $T = 25$ 表示最多包含黄金的单元格数量。枚举起点需要 $O(mn)$ 的时间，可以成为起点的位置必须有黄金，那么可能的起点有 $\\min(mn, T)$ 个。对于每一个起点，第一步最多有 $4$ 个可行的方向，后面的每一步最多有 $3$ 个可行的方向，因此可以粗略估计出一次搜索需要的时间为 $O(4 \\times 3^{\\min(mn, T) - 2}) = O(3^{\\min(mn, T)})$。\n\n- 空间复杂度：$O(\\min(mn, T))$，即为递归需要的栈空间。"
}