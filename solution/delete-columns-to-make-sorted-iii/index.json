{
	"titleSlug": "delete-columns-to-make-sorted-iii",
	"slug": "shan-lie-zao-xu-iii-by-leetcode",
	"url": "https://leetcode-cn.com/problems/delete-columns-to-make-sorted-iii/solution/shan-lie-zao-xu-iii-by-leetcode/",
	"content": "#### 方法 1：动态规划\n\n**想法和算法**\n\n这是一个复杂的问题，很难抽象出解题思路。\n\n首先，找出需要保留的列数，而不是需要删除的列数。最后，可以相减得到答案。\n\n假设我们一定保存第一列 `C`，那么保存的下一列 `D` 就必须保证每行都是字典有序的，也就是 `C[i] <= D[i]`。那么我们就可以删除 `C` 和 `D` 之间的所有列。\n\n我们可以用动态规划来解决这个问题，让 `dp[k]` 表示在输入为 `[row[k:] for row in A]` 时保存的列数，那么 `dp[k]` 的递推式显而易见。\n\n```Java []\nclass Solution {\n    public int minDeletionSize(String[] A) {\n        int W = A[0].length();\n        int[] dp = new int[W];\n        Arrays.fill(dp, 1);\n        for (int i = W-2; i >= 0; --i)\n            search: for (int j = i+1; j < W; ++j) {\n                for (String row: A)\n                    if (row.charAt(i) > row.charAt(j))\n                        continue search;\n\n                dp[i] = Math.max(dp[i], 1 + dp[j]);\n            }\n\n        int kept = 0;\n        for (int x: dp)\n            kept = Math.max(kept, x);\n        return W - kept;\n    }\n}\n```\n\n```Python []\nclass Solution(object):\n    def minDeletionSize(self, A):\n        W = len(A[0])\n        dp = [1] * W\n        for i in xrange(W-2, -1, -1):\n            for j in xrange(i+1, W):\n                if all(row[i] <= row[j] for row in A):\n                    dp[i] = max(dp[i], 1 + dp[j])\n\n        return W - max(dp)\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(N * W^2)$，其中 $N$ 是 `A` 的长度，$W$ 是 `A` 中每个单词的长度。\n* 空间复杂度：$O(W)$。"
}