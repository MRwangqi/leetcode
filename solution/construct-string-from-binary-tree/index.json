{
	"titleSlug": "construct-string-from-binary-tree",
	"slug": "gen-ju-er-cha-shu-chuang-jian-zi-fu-chua-e1af",
	"url": "https://leetcode-cn.com/problems/construct-string-from-binary-tree/solution/gen-ju-er-cha-shu-chuang-jian-zi-fu-chua-e1af/",
	"content": "#### 方法一：递归\n\n我们可以使用递归的方法得到二叉树的前序遍历，并在递归时加上额外的括号。\n\n会有以下 $4$ 种情况：\n\n- 如果当前节点有两个孩子，那我们在递归时，需要在两个孩子的结果外都加上一层括号；\n\n- 如果当前节点没有孩子，那我们不需要在节点后面加上任何括号；\n\n![No_child](https://pic.leetcode-cn.com/Figures/606/606_Case2.PNG)\n{:align=\"center\"}\n\n- 如果当前节点只有左孩子，那我们在递归时，只需要在左孩子的结果外加上一层括号，而不需要给右孩子加上任何括号；\n\n![Left_child](https://pic.leetcode-cn.com/Figures/606/606_Case3.PNG)\n{:align=\"center\"}\n\n- 如果当前节点只有右孩子，那我们在递归时，需要先加上一层空的括号 $\\text{`()'}$ 表示左孩子为空，再对右孩子进行递归，并在结果外加上一层括号。\n\n![Right_child](https://pic.leetcode-cn.com/Figures/606/606_Case4.PNG)\n{:align=\"center\"}\n\n考虑完上面的 $4$ 种情况，我们就可以得到最终的字符串。\n\n```Python [sol1-Python3]\nclass Solution:\n    def tree2str(self, root: Optional[TreeNode]) -> str:\n        if root is None:\n            return \"\"\n        if root.left is None and root.right is None:\n            return str(root.val)\n        if root.right is None:\n            return f\"{root.val}({self.tree2str(root.left)})\"\n        return f\"{root.val}({self.tree2str(root.left)})({self.tree2str(root.right)})\"\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string tree2str(TreeNode *root) {\n        if (root == nullptr) {\n            return \"\";\n        }\n        if (root->left == nullptr && root->right == nullptr) {\n            return to_string(root->val);\n        }\n        if (root->right == nullptr) {\n            return to_string(root->val) + \"(\" + tree2str(root->left) + \")\";\n        }\n        return to_string(root->val) + \"(\" + tree2str(root->left) + \")(\" + tree2str(root->right) + \")\";\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String tree2str(TreeNode root) {\n        if (root == null) {\n            return \"\";\n        }\n        if (root.left == null && root.right == null) {\n            return Integer.toString(root.val);\n        }\n        if (root.right == null) {\n            return new StringBuffer().append(root.val).append(\"(\").append(tree2str(root.left)).append(\")\").toString();\n        }\n        return new StringBuffer().append(root.val).append(\"(\").append(tree2str(root.left)).append(\")(\").append(tree2str(root.right)).append(\")\").toString();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string Tree2str(TreeNode root) {\n        if (root == null) {\n            return \"\";\n        }\n        if (root.left == null && root.right == null) {\n            return root.val.ToString();\n        }\n        if (root.right == null) {\n            return new StringBuilder().Append(root.val).Append(\"(\").Append(Tree2str(root.left)).Append(\")\").ToString();\n        }\n        return new StringBuilder().Append(root.val).Append(\"(\").Append(Tree2str(root.left)).Append(\")(\").Append(Tree2str(root.right)).Append(\")\").ToString();\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc tree2str(root *TreeNode) string {\n    switch {\n    case root == nil:\n        return \"\"\n    case root.Left == nil && root.Right == nil:\n        return strconv.Itoa(root.Val)\n    case root.Right == nil:\n        return fmt.Sprintf(\"%d(%s)\", root.Val, tree2str(root.Left))\n    default:\n        return fmt.Sprintf(\"%d(%s)(%s)\", root.Val, tree2str(root.Left), tree2str(root.Right))\n    }\n}\n```\n\n```C [sol1-C]\n\n#define MAX_STR_LEN 100000\n\nvoid helper(struct TreeNode* root, char * str, int * pos) {\n    if (root == NULL) {\n        return;\n    }\n    if (root->left == NULL && root->right == NULL) {\n        *pos += sprintf(str + *pos, \"%d\", root->val);\n        return;\n    }\n    if (root->right == NULL) {\n        *pos += sprintf(str + *pos, \"%d\", root->val);\n        str[(*pos)++] = '(';\n        helper(root->left, str, pos);\n        str[(*pos)++] = ')';\n    } else {\n        *pos += sprintf(str + *pos, \"%d\", root->val);\n        str[(*pos)++] = '(';\n        helper(root->left, str, pos);\n        str[(*pos)++] = ')';\n        str[(*pos)++] = '(';\n        helper(root->right, str, pos);\n        str[(*pos)++] = ')';\n    } \n}\n\nchar * tree2str(struct TreeNode* root) {\n    char * res = (char *)malloc(sizeof(char) * MAX_STR_LEN);\n    int pos = 0;\n    helper(root, res, &pos);\n    res[pos] = '\\0';\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar tree2str = function(root) {\n    if (!root) {\n        return \"\";\n    }\n    if (!root.left && !root.right) {\n        return '' + root.val;\n    }\n    if (!root.right) {\n        return root.val + '(' + tree2str(root.left) + ')';\n    }\n    return root.val + '(' + tree2str(root.left) + ')(' + tree2str(root.right) + ')';\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉树中的节点数目。\n\n- 空间复杂度：$O(n)$。在最坏情况下会递归 $n$ 层，需要 $O(n)$ 的栈空间。\n\n#### 方法二：迭代\n\n我们也可以使用迭代的方法得到二叉树的前序遍历，并在迭代时加上额外的括号。\n\n用一个栈来存储树中的一些节点，其中栈顶的元素为当前遍历到的节点，从栈底到栈顶的节点为从根到当前节点的唯一路径上的节点。和迭代得到前序遍历的方法略有不同，由于这里需要输出额外的括号，因此我们还需要用一个集合存储所有遍历过的节点，理由见下文。\n\n首先我们把根节点入栈。对于当前栈顶的元素，如果它没有遍历过，那么就把它加入到集合中，并开始对以它为根的子树进行前序遍历。我们先在答案末尾添加一个 $\\text{`('}$，表示一个节点的开始，然后判断该节点的子节点个数。\n\n和方法一相同，这里会出现四种情况：\n\n- 如果当前节点有两个孩子，那么我们先将右孩子入栈，再将左孩子入栈，从而保证前序遍历的顺序；\n- 如果当前节点没有孩子，我们什么都不做；\n- 如果当前节点只有左孩子，那么我们将左孩子入栈；\n- 如果当前节点只有右孩子，那么需要在答案末尾添加一对 $\\text{`()'}$ 表示空的左孩子，再将右孩子入栈。\n\n注意这四种情况中，我们都不会将当前节点出栈，原因是我们一开始添加了 $\\text{`('}$ 表示节点的开始，在以当前节点为根的子树中所有节点遍历完成之后，我们才会在答案末尾添加 $\\text{`)'}$ 表示节点的结束。因此我们需要用上面提到的集合来存储遍历过的节点，如果当前栈顶的元素遍历过，那么就需要在答案末尾添加 $\\text{`)'}$ ，并将这个节点出栈。\n\n<![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide1.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide2.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide3.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide4.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide5.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide6.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide7.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide8.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide9.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide10.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide11.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide12.PNG),![1000](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide13.PNG)>\n\n```Python [sol2-Python3]\nclass Solution:\n    def tree2str(self, root: Optional[TreeNode]) -> str:\n        ans = \"\"\n        st = [root]\n        vis = set()\n        while st:\n            node = st[-1]\n            if node in vis:\n                if node != root:\n                    ans += \")\"\n                st.pop()\n            else:\n                vis.add(node)\n                if node != root:\n                    ans += \"(\"\n                ans += str(node.val)\n                if node.left is None and node.right:\n                    ans += \"()\"\n                if node.right:\n                    st.append(node.right)\n                if node.left:\n                    st.append(node.left)\n        return ans\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    string tree2str(TreeNode *root) {\n        string ans = \"\";\n        stack<TreeNode *> st;\n        st.push(root);\n        unordered_set<TreeNode *> vis;\n        while (!st.empty()) {\n            auto node = st.top();\n            if (vis.count(node)) {\n                if (node != root) {\n                    ans += \")\";\n                }\n                st.pop();\n            } else {\n                vis.insert(node);\n                if (node != root) {\n                    ans += \"(\";\n                }\n                ans += to_string(node->val);\n                if (node->left == nullptr && node->right != nullptr) {\n                    ans += \"()\";\n                }\n                if (node->right != nullptr) {\n                    st.push(node->right);\n                }\n                if (node->left != nullptr) {\n                    st.push(node->left);\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public String tree2str(TreeNode root) {\n        StringBuffer ans = new StringBuffer();\n        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();\n        stack.push(root);\n        Set<TreeNode> visited = new HashSet<TreeNode>();\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.peek();\n            if (!visited.add(node)) {\n                if (node != root) {\n                    ans.append(\")\");\n                }\n                stack.pop();\n            } else {\n                if (node != root) {\n                    ans.append(\"(\");\n                }\n                ans.append(node.val);\n                if (node.left == null && node.right != null) {\n                    ans.append(\"()\");\n                }\n                if (node.right != null) {\n                    stack.push(node.right);\n                }\n                if (node.left != null) {\n                    stack.push(node.left);\n                }\n            }\n        }\n        return ans.toString();\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public string Tree2str(TreeNode root) {\n        StringBuilder ans = new StringBuilder();\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        stack.Push(root);\n        ISet<TreeNode> visited = new HashSet<TreeNode>();\n        while (stack.Count > 0) {\n            TreeNode node = stack.Peek();\n            if (!visited.Add(node)) {\n                if (node != root) {\n                    ans.Append(\")\");\n                }\n                stack.Pop();\n            } else {\n                if (node != root) {\n                    ans.Append(\"(\");\n                }\n                ans.Append(node.val);\n                if (node.left == null && node.right != null) {\n                    ans.Append(\"()\");\n                }\n                if (node.right != null) {\n                    stack.Push(node.right);\n                }\n                if (node.left != null) {\n                    stack.Push(node.left);\n                }\n            }\n        }\n        return ans.ToString();\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc tree2str(root *TreeNode) string {\n    ans := &strings.Builder{}\n    st := []*TreeNode{root}\n    vis := map[*TreeNode]bool{}\n    for len(st) > 0 {\n        node := st[len(st)-1]\n        if vis[node] {\n            if (node != root) {\n                ans.WriteByte(')')\n            }\n            st = st[:len(st)-1]\n        } else {\n            vis[node] = true\n            if (node != root) {\n                ans.WriteByte('(')\n            }\n            ans.WriteString(strconv.Itoa(node.Val))\n            if node.Left == nil && node.Right != nil {\n                ans.WriteString(\"()\")\n            }\n            if node.Right != nil {\n                st = append(st, node.Right)\n            }\n            if node.Left != nil {\n                st = append(st, node.Left)\n            }\n        }\n    }\n    return ans.String()\n}\n```\n\n```C [sol2-C]\n#define MAX_STR_LEN 100000\n#define MAX_NODE_SIZE 100000\n\ntypedef struct {\n    struct TreeNode * key;\n    UT_hash_handle hh; \n} HashItem;\n\nchar * tree2str(struct TreeNode* root){\n    char * ans = (char *)malloc(sizeof(char) * MAX_STR_LEN);\n    int pos = 0;\n    struct TreeNode ** st = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * MAX_NODE_SIZE);\n    HashItem * vis = NULL;\n    int top = 0;\n    st[top++] = root;\n\n    while (top > 0) {\n        struct TreeNode * node = st[top - 1];\n        HashItem * pEntry = NULL;\n        HASH_FIND_PTR(vis, &node, pEntry);\n        if (pEntry != NULL) {\n            if (node != root) {\n                ans[pos++] = ')';\n            }\n            top--;\n        } else {\n            pEntry = (HashItem *)malloc(sizeof(HashItem));\n            pEntry->key = node;\n            HASH_ADD_PTR(vis, key, pEntry);\n            if (node != root) {\n                ans[pos++] = '(';\n            }\n            pos += sprintf(ans + pos, \"%d\", node->val);\n            if (node->left == NULL && node->right != NULL) {\n                pos += sprintf(ans + pos, \"()\");\n            }\n            if (node->right != NULL) {\n                st[top++] = node->right;\n            }\n            if (node->left != NULL) {\n                st[top++] = node->left;\n            }\n        }        \n    }\n    ans[pos] = '\\0';\n    free(st);\n    HashItem * curr, * next;\n    HASH_ITER(hh, vis, curr, next) {\n        HASH_DEL(vis, curr);  \n        free(curr);            \n    }\n    return ans;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar tree2str = function(root) {\n    let ans = '';\n    const st = [root];\n    const vis = new Set();\n    while (st.length) {\n        const node = st[st.length - 1];\n        if (vis.has(node)) {\n            if (node !== root) {\n                ans += ')';\n            }\n            st.pop();\n        } else {\n            vis.add(node);\n            if (node !== root) {\n                ans += '(';\n            }\n            ans += '' + node.val;\n            if (!node.left && node.right) {\n                ans += '()';\n            }\n            if (node.right) {\n                st.push(node.right);\n            }\n            if (node.left) {\n                st.push(node.left);\n            }\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉树中的节点数目。\n\n- 空间复杂度：$O(n)$。哈希表和栈需要 $O(n)$ 的空间。"
}