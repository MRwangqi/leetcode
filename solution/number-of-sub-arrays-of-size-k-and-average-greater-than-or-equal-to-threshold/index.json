{
	"titleSlug": "number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold",
	"slug": "by-stormsunshine-kxlc",
	"url": "https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/solution/by-stormsunshine-kxlc/",
	"content": "# 解法\r\n\r\n## 思路和算法\r\n\r\n对于任意长度为 $k$ 的子数组，其平均值等于子数组的元素和除以 $k$。由于 $k$ 是正整数，因此一个长度为 $k$ 的子数组的平均值大于等于 $\\textit{threshold}$ 等价于该子数组的元素和大于等于 $\\textit{threshold} \\times k$。只要得到元素和大于等于 $\\textit{threshold} \\times k$ 的子数组数目，即可得到平均值大于等于 $\\textit{threshold}$ 的子数组数目。为了计算子数组数目，需要维护一个计数。\r\n\r\n长度为 $n$ 的数组 $\\textit{arr}$ 中，长度为 $k$ 的子数组有 $n - k + 1$ 个，其中最左侧的子数组的下标范围是 $[0, k - 1]$。用 $\\textit{sum}$ 表示长度为 $k$ 的子数组的元素和，初始时 $\\textit{sum}$ 等于最左侧的 $k$ 个元素之和，如果 $\\textit{sum} \\ge \\textit{threshold} \\times k$，则计数等于 $1$，否则计数等于 $0$。\r\n\r\n对于 $k \\le i < n$，当子数组的下标范围从 $[i - k, i - 1]$ 移动到 $[i - k + 1, i]$ 时，$\\textit{arr}[i - k]$ 移出子数组，$\\textit{arr}[i]$ 移入子数组，因此 $\\textit{sum}$ 的变化是减少 $\\textit{arr}[i - k]$ 并增加 $\\textit{arr}[i]$。每次移动子数组的下标范围及更新 $\\textit{sum}$ 之后，如果 $\\textit{sum} \\ge \\textit{threshold} \\times k$，则将计数加 $1$。\r\n\r\n遍历所有的子数组之后，计数值即为平均值大于等于 $\\textit{threshold}$ 的子数组数目。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public int numOfSubarrays(int[] arr, int k, int threshold) {\r\n        int sum = 0;\r\n        int n = arr.length;\r\n        for (int i = 0; i < k; i++) {\r\n            sum += arr[i];\r\n        }\r\n        int subarrays = sum >= threshold * k ? 1 : 0;\r\n        for (int i = k; i < n; i++) {\r\n            sum -= arr[i - k];\r\n            sum += arr[i];\r\n            if (sum >= threshold * k) {\r\n                subarrays++;\r\n            }\r\n        }\r\n        return subarrays;\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public int NumOfSubarrays(int[] arr, int k, int threshold) {\r\n        int sum = 0;\r\n        int n = arr.Length;\r\n        for (int i = 0; i < k; i++) {\r\n            sum += arr[i];\r\n        }\r\n        int subarrays = sum >= threshold * k ? 1 : 0;\r\n        for (int i = k; i < n; i++) {\r\n            sum -= arr[i - k];\r\n            sum += arr[i];\r\n            if (sum >= threshold * k) {\r\n                subarrays++;\r\n            }\r\n        }\r\n        return subarrays;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{arr}$ 的长度。需要遍历数组一次。\r\n\r\n- 空间复杂度：$O(1)$。"
}