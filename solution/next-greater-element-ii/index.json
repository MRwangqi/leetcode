{
	"titleSlug": "next-greater-element-ii",
	"slug": "dong-hua-jiang-jie-dan-diao-zhan-by-fuxu-4z2g",
	"url": "https://leetcode-cn.com/problems/next-greater-element-ii/solution/dong-hua-jiang-jie-dan-diao-zhan-by-fuxu-4z2g/",
	"content": "各位题友大家好！ 今天是 **[@负雪明烛](/u/fuxuemingzhu/)** 坚持日更的第 **41** 天。今天力扣上的每日一题是「[503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)」。\n\n# 解题思路\n\n今天题目的两个重点：\n\n\n- 如何求下一个更大的元素\n- 如何实现循环数组\n\n\n## 1. 如何求下一个更大的元素\n\n本题如果暴力求解，对于每个元素都向后去寻找比它更大的元素，那么时间复杂度 $O(N^2)$ 会超时。必须想办法优化。\n\n\n我们注意到，暴力解法中，如果数组的前半部分是单调不增的，那么会有很大的计算资源的浪费。比如说 `[6,5,4,3,8]`，对于前面的 `[6,5,4,3]` 等数字都需要向后遍历，当寻找到元素 8 时才找到了比自己大的元素；而如果已知元素 6 向后找到元素 8 才找到了比自己的大的数字，那么对于元素 `[5,4,3]` 来说，它们都比元素 6 更小，所以比它们更大的元素一定是元素 8，不需要单独遍历对 `[5,4,3]` 向后遍历一次！\n\n\n根据上面的分析可知，**可以遍历一次数组，如果元素是单调递减的（则他们的「下一个更大元素」相同），我们就把这些元素保存，直到找到一个较大的元素；把该较大元素逐一跟保存了的元素比较，如果该元素更大，那么它就是前面元素的「下一个更大元素」**。\n\n在实现上，我们可以使用「**单调栈**」来实现，**单调栈**是说栈里面的元素从栈底到栈顶是**单调递增**或者**单调递减**的（类似于汉诺塔）。\n\n\n本题应该用个「单调递减栈」来实现。\n\n\n建立「单调递减栈」，并对原数组遍历一次：\n\n- 如果栈为空，则把当前元素放入栈内；\n- 如果栈不为空，则需要判断当前元素和栈顶元素的大小：\n  - 如果当前元素比栈顶元素大：说明当前元素是前面一些元素的「下一个更大元素」，则逐个弹出栈顶元素，直到当前元素比栈顶元素小为止。\n  - 如果当前元素比栈顶元素小：说明当前元素的「下一个更大元素」与栈顶元素相同，则把当前元素入栈。\n\n\n\n可以用下面的动图来帮助理解：\n\n\n![503.gif](https://pic.leetcode-cn.com/1614996551-SXYMXC-503.gif)\n\n也可以用下面 PPT 逐步观看：\n\n<![503.001.jpeg](https://pic.leetcode-cn.com/1614996688-iHniEz-503.001.jpeg),![503.002.jpeg](https://pic.leetcode-cn.com/1614996688-Mrxypj-503.002.jpeg),![503.003.jpeg](https://pic.leetcode-cn.com/1614996688-zVzXcN-503.003.jpeg),![503.004.jpeg](https://pic.leetcode-cn.com/1614996688-OQpVPM-503.004.jpeg),![503.005.jpeg](https://pic.leetcode-cn.com/1614996688-lkulIy-503.005.jpeg),![503.006.jpeg](https://pic.leetcode-cn.com/1614996688-AHzHdS-503.006.jpeg),![503.007.jpeg](https://pic.leetcode-cn.com/1614996688-UucgWI-503.007.jpeg),![503.008.jpeg](https://pic.leetcode-cn.com/1614996688-KVUIpd-503.008.jpeg),![503.009.jpeg](https://pic.leetcode-cn.com/1614996688-SivLHw-503.009.jpeg),![503.010.jpeg](https://pic.leetcode-cn.com/1614996688-nTyZYe-503.010.jpeg),![503.011.jpeg](https://pic.leetcode-cn.com/1614996688-EIVHUd-503.011.jpeg),![503.012.jpeg](https://pic.leetcode-cn.com/1614996688-lvMIdG-503.012.jpeg)>\n\n\n## 2. 如何实现循环数组\n\n题目说给出的数组是循环数组，何为循环数组？就是说数组的最后一个元素下一个元素是数组的第一个元素，形状类似于「环」。\n\n\n- 一种实现方式是，把数组复制一份到数组末尾，这样虽然不是严格的循环数组，但是对于本题已经足够了，因为本题对数组最多遍历两次。\n- 另一个常见的实现方式是，使用取模运算 $%$ 可以把下标 $i$ 映射到数组 $nums$ 长度的 $0 - N$ 内。\n\n# 代码\n\n\n栈里面需要保存元素在数组中的下标，而不是具体的数字。因为需要根据下标修改结果数组 `res`。\n\n\n```python\nclass Solution(object):\n    def nextGreaterElements(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        N = len(nums)\n        res = [-1] * N\n        stack = []\n        for i in range(N * 2):\n            while stack and nums[stack[-1]] < nums[i % N]:\n                res[stack.pop()] = nums[i % N]\n            stack.append(i % N)\n        return res\n```\n\n\n\n\n- 时间复杂度：$O(N)$，遍历了两次数组；\n- 空间复杂度：$O(N)$，使用了额外空间「单调栈」，最坏情况下，栈内会保存数组的所有元素。\n\n\n\n\n# 刷题心得\n\n\n单调栈是神器之一，虽然考察的不多，但是需要学会。\n\n-----\n\n\nOK，以上就是 [@负雪明烛](https://leetcode-cn.com/u/fuxuemingzhu/) 写的今天题解的全部内容了，如果你觉得有帮助的话，**求赞、求关注、求收藏**。如果有疑问的话，请在下面评论，我会及时解答。\n\n\n**关注我**，你将不会错过我的精彩动画题解、面试题分享、组队刷题活动，进入主页 [@负雪明烛](https://leetcode-cn.com/u/fuxuemingzhu/) 右侧有刷题组织，从此刷题不再孤单。\n\n\n祝大家牛年大吉！AC 多多，Offer 多多！我们明天再见！"
}