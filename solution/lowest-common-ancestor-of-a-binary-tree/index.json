{
	"titleSlug": "lowest-common-ancestor-of-a-binary-tree",
	"slug": "er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2",
	"url": "https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ.mp4](6258a388-b9c6-486c-9d92-c09571d373a9)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### æ–¹æ³•ä¸€ï¼šé€’å½’\n\n**æ€è·¯å’Œç®—æ³•**\n\næˆ‘ä»¬é€’å½’éå†æ•´æ£µäºŒå‰æ ‘ï¼Œå®šä¹‰ $f_x$ è¡¨ç¤º $x$ èŠ‚ç‚¹çš„å­æ ‘ä¸­æ˜¯å¦åŒ…å« $p$ èŠ‚ç‚¹æˆ– $q$ èŠ‚ç‚¹ï¼Œå¦‚æœåŒ…å«ä¸º `true`ï¼Œå¦åˆ™ä¸º `false`ã€‚é‚£ä¹ˆç¬¦åˆæ¡ä»¶çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ $x$ ä¸€å®šæ»¡è¶³å¦‚ä¸‹æ¡ä»¶ï¼š\n\n$$\n(f_{\\text{lson}}\\ \\&\\&\\ f_{\\text{rson}})\\ ||\\ ((x\\ =\\ p\\ ||\\ x\\ =\\ q)\\ \\&\\&\\ (f_{\\text{lson}}\\ ||\\ f_{\\text{rson}}))\n$$\n\nå…¶ä¸­ $\\text{lson}$ å’Œ $\\text{rson}$ åˆ†åˆ«ä»£è¡¨ $x$ èŠ‚ç‚¹çš„å·¦å­©å­å’Œå³å­©å­ã€‚åˆçœ‹å¯èƒ½ä¼šæ„Ÿè§‰æ¡ä»¶åˆ¤æ–­æœ‰ç‚¹å¤æ‚ï¼Œæˆ‘ä»¬æ¥ä¸€æ¡æ¡çœ‹ï¼Œ$f_{\\text{lson}}\\ \\&\\&\\ f_{\\text{rson}}$ è¯´æ˜å·¦å­æ ‘å’Œå³å­æ ‘å‡åŒ…å« $p$ èŠ‚ç‚¹æˆ– $q$ èŠ‚ç‚¹ï¼Œå¦‚æœå·¦å­æ ‘åŒ…å«çš„æ˜¯ $p$ èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå³å­æ ‘åªèƒ½åŒ…å« $q$ èŠ‚ç‚¹ï¼Œåä¹‹äº¦ç„¶ï¼Œå› ä¸º $p$ èŠ‚ç‚¹å’Œ $q$ èŠ‚ç‚¹éƒ½æ˜¯ä¸åŒä¸”å”¯ä¸€çš„èŠ‚ç‚¹ï¼Œå› æ­¤å¦‚æœæ»¡è¶³è¿™ä¸ªåˆ¤æ–­æ¡ä»¶å³å¯è¯´æ˜ $x$ å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚å†æ¥çœ‹ç¬¬äºŒæ¡åˆ¤æ–­æ¡ä»¶ï¼Œè¿™ä¸ªåˆ¤æ–­æ¡ä»¶å³æ˜¯è€ƒè™‘äº† $x$ æ°å¥½æ˜¯ $p$ èŠ‚ç‚¹æˆ– $q$ èŠ‚ç‚¹ä¸”å®ƒçš„å·¦å­æ ‘æˆ–å³å­æ ‘æœ‰ä¸€ä¸ªåŒ…å«äº†å¦ä¸€ä¸ªèŠ‚ç‚¹çš„æƒ…å†µï¼Œå› æ­¤å¦‚æœæ»¡è¶³è¿™ä¸ªåˆ¤æ–­æ¡ä»¶äº¦å¯è¯´æ˜ $x$ å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚\n\nä½ å¯èƒ½ä¼šç–‘æƒ‘è¿™æ ·æ‰¾å‡ºæ¥çš„å…¬å…±ç¥–å…ˆæ·±åº¦æ˜¯å¦æ˜¯æœ€å¤§çš„ã€‚å…¶å®æ˜¯æœ€å¤§çš„ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯è‡ªåº•å‘ä¸Šä»å¶å­èŠ‚ç‚¹å¼€å§‹æ›´æ–°çš„ï¼Œæ‰€ä»¥åœ¨æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„å…¬å…±ç¥–å…ˆä¸­ä¸€å®šæ˜¯æ·±åº¦æœ€å¤§çš„ç¥–å…ˆå…ˆè¢«è®¿é—®åˆ°ï¼Œä¸”ç”±äº $f_x$ æœ¬èº«çš„å®šä¹‰å¾ˆå·§å¦™ï¼Œåœ¨æ‰¾åˆ°æœ€è¿‘å…¬å…±ç¥–å…ˆ $x$ ä»¥åï¼Œ$f_x$ æŒ‰å®šä¹‰è¢«è®¾ç½®ä¸º `true` ï¼Œå³å‡å®šäº†è¿™ä¸ªå­æ ‘ä¸­åªæœ‰ä¸€ä¸ª $p$ èŠ‚ç‚¹æˆ– $q$ èŠ‚ç‚¹ï¼Œå› æ­¤å…¶ä»–å…¬å…±ç¥–å…ˆä¸ä¼šå†è¢«åˆ¤æ–­ä¸ºç¬¦åˆæ¡ä»¶ã€‚\n\nä¸‹å›¾å±•ç¤ºäº†ä¸€ä¸ªç¤ºä¾‹ï¼Œæœç´¢æ ‘ä¸­ä¸¤ä¸ªèŠ‚ç‚¹ `9` å’Œ `11` çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚\n\n<![fig1](https://assets.leetcode-cn.com/solution-static/236/1.PNG),![fig2](https://assets.leetcode-cn.com/solution-static/236/2.PNG),![fig3](https://assets.leetcode-cn.com/solution-static/236/3.PNG),![fig4](https://assets.leetcode-cn.com/solution-static/236/4.PNG),![fig5](https://assets.leetcode-cn.com/solution-static/236/5.PNG),![fig6](https://assets.leetcode-cn.com/solution-static/236/6.PNG),![fig7](https://assets.leetcode-cn.com/solution-static/236/7.PNG),![fig8](https://assets.leetcode-cn.com/solution-static/236/8.PNG),![fig9](https://assets.leetcode-cn.com/solution-static/236/9.PNG),![fig10](https://assets.leetcode-cn.com/solution-static/236/10.PNG),![fig11](https://assets.leetcode-cn.com/solution-static/236/11.PNG)>\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    TreeNode* ans;\n    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr) return false;\n        bool lson = dfs(root->left, p, q);\n        bool rson = dfs(root->right, p, q);\n        if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) {\n            ans = root;\n        } \n        return lson || rson || (root->val == p->val || root->val == q->val);\n    }\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        dfs(root, p, q);\n        return ans;\n    }\n};\n```\n\n```JavaScript [sol1-JavaScript]\nvar lowestCommonAncestor = function(root, p, q) {\n    let ans;\n    const dfs = (root, p, q) => {\n        if (root === null) return false;\n        const lson = dfs(root.left, p, q);\n        const rson = dfs(root.right, p, q);\n        if ((lson && rson) || ((root.val === p.val || root.val === q.val) && (lson || rson))) {\n            ans = root;\n        } \n        return lson || rson || (root.val === p.val || root.val === q.val);\n    }\n    dfs(root, p, q);\n    return ans;\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n\n    private TreeNode ans;\n\n    public Solution() {\n        this.ans = null;\n    }\n\n    private boolean dfs(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null) return false;\n        boolean lson = dfs(root.left, p, q);\n        boolean rson = dfs(root.right, p, q);\n        if ((lson && rson) || ((root.val == p.val || root.val == q.val) && (lson || rson))) {\n            ans = root;\n        } \n        return lson || rson || (root.val == p.val || root.val == q.val);\n    }\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        this.dfs(root, p, q);\n        return this.ans;\n    }\n}\n```\n\n```golang [sol1-Golang]\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    if root == nil {\n        return nil\n    }\n    if root.Val == p.Val || root.Val == q.Val {\n        return root\n    }\n    left := lowestCommonAncestor(root.Left, p, q)\n    right := lowestCommonAncestor(root.Right, p, q)\n    if left != nil && right != nil {\n        return root\n    }\n    if left == nil {\n        return right\n    }\n    return left\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n* æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚äºŒå‰æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹æœ‰ä¸”åªä¼šè¢«è®¿é—®ä¸€æ¬¡ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º $O(N)$ã€‚\n\n* ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ ï¼Œå…¶ä¸­ $N$ æ˜¯äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚é€’å½’è°ƒç”¨çš„æ ˆæ·±åº¦å–å†³äºäºŒå‰æ ‘çš„é«˜åº¦ï¼ŒäºŒå‰æ ‘æœ€åæƒ…å†µä¸‹ä¸ºä¸€æ¡é“¾ï¼Œæ­¤æ—¶é«˜åº¦ä¸º $N$ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(N)$ã€‚\n\n#### æ–¹æ³•äºŒï¼šå­˜å‚¨çˆ¶èŠ‚ç‚¹\n\n**æ€è·¯**\n\næˆ‘ä»¬å¯ä»¥ç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œç„¶åæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¿¡æ¯ä» `p` ç»“ç‚¹å¼€å§‹ä¸æ–­å¾€ä¸Šè·³ï¼Œå¹¶è®°å½•å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå†ä» `q` èŠ‚ç‚¹å¼€å§‹ä¸æ–­å¾€ä¸Šè·³ï¼Œå¦‚æœç¢°åˆ°å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚\n\n**ç®—æ³•**\n\n1. ä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†æ•´æ£µäºŒå‰æ ‘ï¼Œç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æŒ‡é’ˆã€‚\n2. ä» `p` èŠ‚ç‚¹å¼€å§‹ä¸æ–­å¾€å®ƒçš„ç¥–å…ˆç§»åŠ¨ï¼Œå¹¶ç”¨æ•°æ®ç»“æ„è®°å½•å·²ç»è®¿é—®è¿‡çš„ç¥–å…ˆèŠ‚ç‚¹ã€‚\n3. åŒæ ·ï¼Œæˆ‘ä»¬å†ä» `q` èŠ‚ç‚¹å¼€å§‹ä¸æ–­å¾€å®ƒçš„ç¥–å…ˆç§»åŠ¨ï¼Œå¦‚æœæœ‰ç¥–å…ˆå·²ç»è¢«è®¿é—®è¿‡ï¼Œå³æ„å‘³ç€è¿™æ˜¯ `p` å’Œ `q` çš„æ·±åº¦æœ€æ·±çš„å…¬å…±ç¥–å…ˆï¼Œå³ LCA èŠ‚ç‚¹ã€‚\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    unordered_map<int, TreeNode*> fa;\n    unordered_map<int, bool> vis;\n    void dfs(TreeNode* root){\n        if (root->left != nullptr) {\n            fa[root->left->val] = root;\n            dfs(root->left);\n        }\n        if (root->right != nullptr) {\n            fa[root->right->val] = root;\n            dfs(root->right);\n        }\n    }\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        fa[root->val] = nullptr;\n        dfs(root);\n        while (p != nullptr) {\n            vis[p->val] = true;\n            p = fa[p->val];\n        }\n        while (q != nullptr) {\n            if (vis[q->val]) return q;\n            q = fa[q->val];\n        }\n        return nullptr;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    Map<Integer, TreeNode> parent = new HashMap<Integer, TreeNode>();\n    Set<Integer> visited = new HashSet<Integer>();\n\n    public void dfs(TreeNode root) {\n        if (root.left != null) {\n            parent.put(root.left.val, root);\n            dfs(root.left);\n        }\n        if (root.right != null) {\n            parent.put(root.right.val, root);\n            dfs(root.right);\n        }\n    }\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        dfs(root);\n        while (p != null) {\n            visited.add(p.val);\n            p = parent.get(p.val);\n        }\n        while (q != null) {\n            if (visited.contains(q.val)) {\n                return q;\n            }\n            q = parent.get(q.val);\n        }\n        return null;\n    }\n}\n```\n\n```golang [sol2-Golang]\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    parent := map[int]*TreeNode{}\n    visited := map[int]bool{}\n\n    var dfs func(*TreeNode)\n    dfs = func(r *TreeNode) {\n        if r == nil {\n            return\n        }\n        if r.Left != nil {\n            parent[r.Left.Val] = r\n            dfs(r.Left)\n        }\n        if r.Right != nil {\n            parent[r.Right.Val] = r\n            dfs(r.Right)\n        }\n    }\n    dfs(root)\n\n    for p != nil {\n        visited[p.Val] = true\n        p = parent[p.Val]\n    }\n    for q != nil {\n        if visited[q.Val] {\n            return q\n        }\n        q = parent[q.Val]\n    }\n\n    return nil\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n* æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚äºŒå‰æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹æœ‰ä¸”åªä¼šè¢«è®¿é—®ä¸€æ¬¡ï¼Œä» `p` å’Œ `q` èŠ‚ç‚¹å¾€ä¸Šè·³ç»è¿‡çš„ç¥–å…ˆèŠ‚ç‚¹ä¸ªæ•°ä¸ä¼šè¶…è¿‡ $N$ï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(N)$ã€‚\n\n* ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ ï¼Œå…¶ä¸­ $N$ æ˜¯äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚é€’å½’è°ƒç”¨çš„æ ˆæ·±åº¦å–å†³äºäºŒå‰æ ‘çš„é«˜åº¦ï¼ŒäºŒå‰æ ‘æœ€åæƒ…å†µä¸‹ä¸ºä¸€æ¡é“¾ï¼Œæ­¤æ—¶é«˜åº¦ä¸º $N$ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(N)$ï¼Œå“ˆå¸Œè¡¨å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¹Ÿéœ€è¦ $O(N)$ çš„ç©ºé—´å¤æ‚åº¦ï¼Œå› æ­¤æœ€åæ€»çš„ç©ºé—´å¤æ‚åº¦ä¸º $O(N)$ã€‚"
}