{
	"titleSlug": "naming-a-company",
	"slug": "by-endlesscheng-ruz8",
	"url": "https://leetcode-cn.com/problems/naming-a-company/solution/by-endlesscheng-ruz8/",
	"content": "本题 [视频讲解](https://www.bilibili.com/video/BV1aT41157bh) 已出炉，欢迎点赞三连~\r\n\r\n---\r\n\r\n#### 提示 1\r\n\r\n什么情况下得到的新名字不会在 $\\textit{ideas}$ 中？\r\n\r\n#### 提示 2\r\n\r\n按照除去首字母的子串 $\\textit{ideas}[i][1:]$ 分组，记录每组的首字母有哪些。\r\n\r\n#### 提示 3\r\n\r\n我们不能选两个在同一组的字符串。那么考虑选两个分属不同组的字符串，这两个字符串需要满足什么要求？\r\n\r\n#### 提示 4\r\n\r\n设 $\\textit{idea}_A$ 的首字母为 $i$，$\\textit{idea}_B$ 的首字母为 $j$。那么 $i$ 不能出现在 $\\textit{idea}_B$ 所属组的首字母中，且 $j$ 也不能出现在 $\\textit{idea}_A$ 所属组的首字母中。\r\n\r\n#### 提示 5\r\n\r\n没有头绪？对于这类字符串问题，可以尝试枚举所有小写字母。\r\n\r\n尝试枚举 $i$ 和 $j$。我们需要统计什么？\r\n\r\n#### 提示 6\r\n\r\n定义 $\\textit{cnt}[i][j]$ 表示组中首字母不包含 $i$ 但包含 $j$ 的组的个数。枚举每个组，统计 $\\textit{cnt}$，同时枚举该组的首字母 $i$ 和不在该组的首字母 $j$，答案即为 $\\textit{cnt}[i][j]$ 的累加值。\r\n\r\n简单来说就是「有 $i$ 无 $j$」可以和「无 $i$ 有 $j$」的字符串互换。\r\n\r\n由于我们是一次遍历所有组，没有考虑两个字符串的顺序，最后需要把答案乘 $2$，表示 A+B 和 B+A 两种字符串的组合。\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def distinctNames(self, ideas: List[str]) -> int:\r\n        group = defaultdict(int)\r\n        for s in ideas:\r\n            group[s[1:]] |= 1 << (ord(s[0]) - ord('a'))\r\n        ans = 0\r\n        cnt = [[0] * 26 for _ in range(26)]\r\n        for mask in group.values():\r\n            for i in range(26):\r\n                if mask >> i & 1 == 0:\r\n                    for j in range(26):\r\n                        if mask >> j & 1:\r\n                            cnt[i][j] += 1\r\n                else:\r\n                    for j in range(26):\r\n                        if mask >> j & 1 == 0:\r\n                            ans += cnt[i][j]\r\n        return ans * 2\r\n```\r\n\r\n```java [sol1-Java]\r\nclass Solution {\r\n    public long distinctNames(String[] ideas) {\r\n        var group = new HashMap<String, Integer>();\r\n        for (var s : ideas) {\r\n            var t = s.substring(1);\r\n            group.put(t, group.getOrDefault(t, 0) | 1 << (s.charAt(0) - 'a'));\r\n        }\r\n        var ans = 0L;\r\n        var cnt = new int[26][26];\r\n        for (var mask : group.values())\r\n            for (var i = 0; i < 26; i++)\r\n                if ((mask >> i & 1) == 0) {\r\n                    for (var j = 0; j < 26; j++)\r\n                        if ((mask >> j & 1) > 0) ++cnt[i][j];\r\n                } else {\r\n                    for (var j = 0; j < 26; j++)\r\n                        if ((mask >> j & 1) == 0) ans += cnt[i][j];\r\n                }\r\n        return ans * 2;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    long long distinctNames(vector<string> &ideas) {\r\n        unordered_map<string, int> group;\r\n        for (auto &s : ideas)\r\n            group[s.substr(1)] |= 1 << (s[0] - 'a');\r\n        long ans = 0L;\r\n        int cnt[26][26] = {};\r\n        for (auto &[_, mask] : group)\r\n            for (int i = 0; i < 26; i++)\r\n                if ((mask >> i & 1) == 0) {\r\n                    for (int j = 0; j < 26; j++)\r\n                        if (mask >> j & 1) ++cnt[i][j];\r\n                } else {\r\n                    for (int j = 0; j < 26; j++)\r\n                        if ((mask >> j & 1) == 0) ans += cnt[i][j];\r\n                }\r\n        return ans * 2;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol1-Go]\r\nfunc distinctNames(ideas []string) (ans int64) {\r\n\tgroup := map[string]int{}\r\n\tfor _, s := range ideas {\r\n\t\tgroup[s[1:]] |= 1 << (s[0] - 'a')\r\n\t}\r\n\tcnt := [26][26]int{}\r\n\tfor _, mask := range group {\r\n\t\tfor i := 0; i < 26; i++ {\r\n\t\t\tif mask>>i&1 == 0 {\r\n\t\t\t\tfor j := 0; j < 26; j++ {\r\n\t\t\t\t\tif mask>>j&1 > 0 {\r\n\t\t\t\t\t\tcnt[i][j]++\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor j := 0; j < 26; j++ {\r\n\t\t\t\t\tif mask>>j&1 == 0 {\r\n\t\t\t\t\t\tans += int64(cnt[i][j])\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn ans * 2\r\n}\r\n```\r\n\r\n第二种实现方式是根据首字母分组。\r\n\r\n对于 $A$ 组中的字符串 $s$，如果 $B$ 组中存在字符串 $t$，使得 $s[1:]=t[1:]$，那么 $s$ 无法与 $B$ 组中的任意字符串互换首字母，否则可以互换。对于 $B$ 组同理。\r\n\r\n设 $A$ 组和 $B$ 组交集的大小为 $m$，则这两个组可以组成的合法答案数为\r\n\r\n$$\r\n2\\cdot(|A|-m)\\cdot(|B|-m)\r\n$$\r\n\r\n其中 $|A|$ 表示集合 $A$ 的大小，$|B|$ 表示集合 $B$ 的大小。\r\n\r\n遍历所有组对，累加答案。\r\n\r\n注：相比上面的写法，这种写法会让 Python 跑的飞快，但是其他语言并无太大区别。\r\n\r\n```Python [sol2-Python3]\r\nclass Solution:\r\n    def distinctNames(self, ideas: List[str]) -> int:\r\n        group = defaultdict(set)\r\n        for s in ideas:\r\n            group[s[0]].add(s[1:])\r\n        ans = 0\r\n        for a, b in combinations(group.values(), 2):\r\n            m = len(a & b)\r\n            ans += (len(a) - m) * (len(b) - m)\r\n        return ans * 2\r\n```\r\n\r\n```java [sol2-Java]\r\nclass Solution {\r\n    public long distinctNames(String[] ideas) {\r\n        var group = new Set[26];\r\n        for (var i = 0; i < 26; i++) \r\n            group[i] = new HashSet<String>();\r\n        for (var s : ideas) \r\n            group[s.charAt(0) - 'a'].add(s.substring(1));\r\n        var ans = 0L;\r\n        for (var i = 1; i < 26; ++i)\r\n            for (var j = 0; j < i; ++j) {\r\n                var m = 0;\r\n                for (var s : group[i])\r\n                    if (group[j].contains(s)) ++m;\r\n                ans += (long) (group[i].size() - m) * (group[j].size() - m);\r\n            }\r\n        return ans * 2;\r\n    }\r\n}\r\n```\r\n\r\n```C++ [sol2-C++]\r\nclass Solution {\r\npublic:\r\n    long long distinctNames(vector<string> &ideas) {\r\n        unordered_set<string> group[26];\r\n        for (auto &s : ideas)\r\n            group[s[0] - 'a'].emplace(s.substr(1));\r\n        long ans = 0L;\r\n        for (int i = 1; i < 26; ++i)\r\n            for (int j = 0; j < i; ++j) {\r\n                int m = 0;\r\n                for (auto &s : group[i])\r\n                    m += group[j].count(s);\r\n                ans += (long) (group[i].size() - m) * (group[j].size() - m);\r\n            }\r\n        return ans * 2;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol2-Go]\r\nfunc distinctNames(ideas []string) (ans int64) {\r\n\tgroup := [26]map[string]bool{}\r\n\tfor i := range group {\r\n\t\tgroup[i] = map[string]bool{}\r\n\t}\r\n\tfor _, s := range ideas {\r\n\t\tgroup[s[0]-'a'][s[1:]] = true\r\n\t}\r\n\tfor i, a := range group {\r\n\t\tfor _, b := range group[:i] {\r\n\t\t\tm := 0\r\n\t\t\tfor s := range a {\r\n\t\t\t\tif b[s] {\r\n\t\t\t\t\tm++\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tans += int64(len(a)-m) * int64(len(b)-m)\r\n\t\t}\r\n\t}\r\n\treturn ans * 2\r\n}\r\n```\r\n\r\n第三种实现方式结合了上面两种写法，在遍历 $\\textit{ideas}$ 的同时，计算上面写法中的交集大小 $m$。\r\n\r\n具体地，按照除去首字母的子串 $\\textit{ideas}[i][1:]$ 分组，记录每组的首字母，同时统计字符 $i$ 无法与多少个字符 $j$ 开头的字符串交换。\r\n\r\n```Python [sol3-Python3]\r\nclass Solution:\r\n    def distinctNames(self, ideas: List[str]) -> int:\r\n        group = defaultdict(int)\r\n        size = [0] * 26\r\n        bad = [[0] * 26 for _ in range(26)]\r\n        for s in ideas:\r\n            i = ord(s[0]) - ord('a')\r\n            s = s[1:]\r\n            mask = group[s]\r\n            group[s] |= 1 << i\r\n            size[i] += 1\r\n            for j in range(26):\r\n                if mask >> j & 1:\r\n                    bad[i][j] += 1  # 统计 i 无法与多少个 j 开头的字符串交换\r\n                    bad[j][i] += 1  # 统计 j 无法与多少个 i 开头的字符串交换\r\n        ans = 0\r\n        for i, b in enumerate(bad):\r\n            for j, m in enumerate(b[:i]):\r\n                ans += (size[i] - m) * (size[j] - m)\r\n        return ans * 2\r\n```\r\n\r\n```java [sol3-Java]\r\nclass Solution {\r\n    public long distinctNames(String[] ideas) {\r\n        var group = new HashMap<String, Integer>();\r\n        var size = new int[26];\r\n        var bad = new int[26][26];\r\n        for (var s : ideas) {\r\n            var i = s.charAt(0) - 'a';\r\n            s = s.substring(1);\r\n            var mask = group.getOrDefault(s, 0);\r\n            group.put(s, mask | 1 << i);\r\n            ++size[i];\r\n            for (var j = 0; j < 26; ++j)\r\n                if ((mask >> j & 1) > 0) {\r\n                    ++bad[i][j]; // 统计 i 无法与多少个 j 开头的字符串交换\r\n                    ++bad[j][i]; // 统计 j 无法与多少个 i 开头的字符串交换\r\n                }\r\n        }\r\n        var ans = 0L;\r\n        for (var i = 1; i < 26; i++)\r\n            for (var j = 0; j < i; j++)\r\n                ans += (long) (size[i] - bad[i][j]) * (size[j] - bad[i][j]);\r\n        return ans * 2;\r\n    }\r\n}\r\n```\r\n\r\n```cpp [sol3-C++]\r\nclass Solution {\r\npublic:\r\n    long long distinctNames(vector<string> &ideas) {\r\n        unordered_map<string, int> group;\r\n        int size[26] = {};\r\n        int bad[26][26] = {};\r\n        for (auto &s: ideas) {\r\n            int i = s[0] - 'a';\r\n            auto t = s.substr(1);\r\n            int mask = group[t];\r\n            group[t] |= 1 << i;\r\n            ++size[i];\r\n            for (int j = 0; j < 26; ++j)\r\n                if (mask >> j & 1) {\r\n                    ++bad[i][j]; // 统计 i 无法与多少个 j 开头的字符串交换\r\n                    ++bad[j][i]; // 统计 j 无法与多少个 i 开头的字符串交换\r\n                }\r\n        }\r\n        long ans = 0L;\r\n        for (int i = 1; i < 26; i++)\r\n            for (int j = 0; j < i; j++)\r\n                ans += (long) (size[i] - bad[i][j]) * (size[j] - bad[i][j]);\r\n        return ans * 2;\r\n    }\r\n};\r\n```\r\n\r\n```go [sol3-Go]\r\nfunc distinctNames(ideas []string) (ans int64) {\r\n\tgroup := map[string]int{}\r\n\tsize := [26]int{}\r\n\tbad := [26][26]int{}\r\n\tfor _, s := range ideas {\r\n\t\ti := s[0] - 'a'\r\n\t\tmask := group[s[1:]]\r\n\t\tgroup[s[1:]] |= 1 << i\r\n\t\tsize[i]++\r\n\t\tfor j := 0; j < 26; j++ {\r\n\t\t\tif mask>>j&1 > 0 {\r\n\t\t\t\tbad[i][j]++ // 统计 i 无法与多少个 j 开头的字符串交换\r\n\t\t\t\tbad[j][i]++ // 统计 j 无法与多少个 i 开头的字符串交换\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor i, b := range bad {\r\n\t\tfor j, m := range b[:i] {\r\n\t\t\tans += int64(size[i]-m) * int64(size[j]-m)\r\n\t\t}\r\n\t}\r\n\treturn ans * 2\r\n}\r\n```\r\n"
}