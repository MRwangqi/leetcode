{
	"titleSlug": "remove-nth-node-from-end-of-list",
	"slug": "shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61",
	"url": "https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹.mp4](801f6caa-3449-4117-885d-6dd33c117534)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### å‰è¨€\n\nåœ¨å¯¹é“¾è¡¨è¿›è¡Œæ“ä½œæ—¶ï¼Œä¸€ç§å¸¸ç”¨çš„æŠ€å·§æ˜¯æ·»åŠ ä¸€ä¸ªå“‘èŠ‚ç‚¹ï¼ˆdummy nodeï¼‰ï¼Œå®ƒçš„ $\\textit{next}$ æŒ‡é’ˆæŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬å°±ä¸éœ€è¦å¯¹å¤´èŠ‚ç‚¹è¿›è¡Œç‰¹æ®Šçš„åˆ¤æ–­äº†ã€‚\n\nä¾‹å¦‚ï¼Œåœ¨æœ¬é¢˜ä¸­ï¼Œå¦‚æœæˆ‘ä»¬è¦åˆ é™¤èŠ‚ç‚¹ $y$ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“èŠ‚ç‚¹ $y$ çš„å‰é©±èŠ‚ç‚¹ $x$ï¼Œå¹¶å°† $x$ çš„æŒ‡é’ˆæŒ‡å‘ $y$ çš„åç»§èŠ‚ç‚¹ã€‚ä½†ç”±äºå¤´èŠ‚ç‚¹ä¸å­˜åœ¨å‰é©±èŠ‚ç‚¹ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨åˆ é™¤å¤´èŠ‚ç‚¹æ—¶è¿›è¡Œç‰¹æ®Šåˆ¤æ–­ã€‚ä½†å¦‚æœæˆ‘ä»¬æ·»åŠ äº†å“‘èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå¤´èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹å°±æ˜¯å“‘èŠ‚ç‚¹æœ¬èº«ï¼Œæ­¤æ—¶æˆ‘ä»¬å°±åªéœ€è¦è€ƒè™‘é€šç”¨çš„æƒ…å†µå³å¯ã€‚\n\nç‰¹åˆ«åœ°ï¼Œåœ¨æŸäº›è¯­è¨€ä¸­ï¼Œç”±äºéœ€è¦è‡ªè¡Œå¯¹å†…å­˜è¿›è¡Œç®¡ç†ã€‚å› æ­¤åœ¨å®é™…çš„é¢è¯•ä¸­ï¼Œå¯¹äºã€Œæ˜¯å¦éœ€è¦é‡Šæ”¾è¢«åˆ é™¤èŠ‚ç‚¹å¯¹åº”çš„ç©ºé—´ã€è¿™ä¸€é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦å’Œé¢è¯•å®˜è¿›è¡Œç§¯æçš„æ²Ÿé€šä»¥è¾¾æˆä¸€è‡´ã€‚ä¸‹é¢çš„ä»£ç ä¸­é»˜è®¤ä¸é‡Šæ”¾ç©ºé—´ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šè®¡ç®—é“¾è¡¨é•¿åº¦\n\n**æ€è·¯ä¸ç®—æ³•**\n\nä¸€ç§å®¹æ˜“æƒ³åˆ°çš„æ–¹æ³•æ˜¯ï¼Œæˆ‘ä»¬é¦–å…ˆä»å¤´èŠ‚ç‚¹å¼€å§‹å¯¹é“¾è¡¨è¿›è¡Œä¸€æ¬¡éå†ï¼Œå¾—åˆ°é“¾è¡¨çš„é•¿åº¦ $L$ã€‚éšåæˆ‘ä»¬å†ä»å¤´èŠ‚ç‚¹å¼€å§‹å¯¹é“¾è¡¨è¿›è¡Œä¸€æ¬¡éå†ï¼Œå½“éå†åˆ°ç¬¬ $L-n+1$ ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå®ƒå°±æ˜¯æˆ‘ä»¬éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ã€‚\n\n> ä¸ºäº†ä¸é¢˜ç›®ä¸­çš„ $n$ ä¿æŒä¸€è‡´ï¼ŒèŠ‚ç‚¹çš„ç¼–å·ä» $1$ å¼€å§‹ï¼Œå¤´èŠ‚ç‚¹ä¸ºç¼–å· $1$ çš„èŠ‚ç‚¹ã€‚\n\nä¸ºäº†æ–¹ä¾¿åˆ é™¤æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥ä»å“‘èŠ‚ç‚¹å¼€å§‹éå† $L-n+1$ ä¸ªèŠ‚ç‚¹ã€‚å½“éå†åˆ°ç¬¬ $L-n+1$ ä¸ªèŠ‚ç‚¹æ—¶ï¼Œ**å®ƒçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹**å°±æ˜¯æˆ‘ä»¬éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼Œè¿™æ ·æˆ‘ä»¬åªéœ€è¦ä¿®æ”¹ä¸€æ¬¡æŒ‡é’ˆï¼Œå°±èƒ½å®Œæˆåˆ é™¤æ“ä½œã€‚\n\n![p1](https://assets.leetcode-cn.com/solution-static/19/p1.png)\n\n**ä»£ç **\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int getLength(ListNode* head) {\n        int length = 0;\n        while (head) {\n            ++length;\n            head = head->next;\n        }\n        return length;\n    }\n\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummy = new ListNode(0, head);\n        int length = getLength(head);\n        ListNode* cur = dummy;\n        for (int i = 1; i < length - n + 1; ++i) {\n            cur = cur->next;\n        }\n        cur->next = cur->next->next;\n        ListNode* ans = dummy->next;\n        delete dummy;\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0, head);\n        int length = getLength(head);\n        ListNode cur = dummy;\n        for (int i = 1; i < length - n + 1; ++i) {\n            cur = cur.next;\n        }\n        cur.next = cur.next.next;\n        ListNode ans = dummy.next;\n        return ans;\n    }\n\n    public int getLength(ListNode head) {\n        int length = 0;\n        while (head != null) {\n            ++length;\n            head = head.next;\n        }\n        return length;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        def getLength(head: ListNode) -> int:\n            length = 0\n            while head:\n                length += 1\n                head = head.next\n            return length\n        \n        dummy = ListNode(0, head)\n        length = getLength(head)\n        cur = dummy\n        for i in range(1, length - n + 1):\n            cur = cur.next\n        cur.next = cur.next.next\n        return dummy.next\n```\n\n```Golang [sol1-Golang]\nfunc getLength(head *ListNode) (length int) {\n    for ; head != nil; head = head.Next {\n        length++\n    }\n    return\n}\n\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    length := getLength(head)\n    dummy := &ListNode{0, head}\n    cur := dummy\n    for i := 0; i < length-n; i++ {\n        cur = cur.Next\n    }\n    cur.Next = cur.Next.Next\n    return dummy.Next\n}\n```\n\n```C [sol1-C]\nint getLength(struct ListNode* head) {\n    int length = 0;\n    while (head) {\n        ++length;\n        head = head->next;\n    }\n    return length;\n}\n\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\n    dummy->val = 0, dummy->next = head;\n    int length = getLength(head);\n    struct ListNode* cur = dummy;\n    for (int i = 1; i < length - n + 1; ++i) {\n        cur = cur->next;\n    }\n    cur->next = cur->next->next;\n    struct ListNode* ans = dummy->next;\n    free(dummy);\n    return ans;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(L)$ï¼Œå…¶ä¸­ $L$ æ˜¯é“¾è¡¨çš„é•¿åº¦ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚\n\n#### æ–¹æ³•äºŒï¼šæ ˆ\n\n**æ€è·¯ä¸ç®—æ³•**\n\næˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨éå†é“¾è¡¨çš„åŒæ—¶å°†æ‰€æœ‰èŠ‚ç‚¹ä¾æ¬¡å…¥æ ˆã€‚æ ¹æ®æ ˆã€Œå…ˆè¿›åå‡ºã€çš„åŸåˆ™ï¼Œæˆ‘ä»¬å¼¹å‡ºæ ˆçš„ç¬¬ $n$ ä¸ªèŠ‚ç‚¹å°±æ˜¯éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼Œå¹¶ä¸”ç›®å‰æ ˆé¡¶çš„èŠ‚ç‚¹å°±æ˜¯å¾…åˆ é™¤èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ã€‚è¿™æ ·ä¸€æ¥ï¼Œåˆ é™¤æ“ä½œå°±å˜å¾—ååˆ†æ–¹ä¾¿äº†ã€‚\n\n<![ppt1](https://assets.leetcode-cn.com/solution-static/19/1.png),![ppt2](https://assets.leetcode-cn.com/solution-static/19/2.png),![ppt3](https://assets.leetcode-cn.com/solution-static/19/3.png),![ppt4](https://assets.leetcode-cn.com/solution-static/19/4.png),![ppt5](https://assets.leetcode-cn.com/solution-static/19/5.png),![ppt6](https://assets.leetcode-cn.com/solution-static/19/6.png),![ppt7](https://assets.leetcode-cn.com/solution-static/19/7.png),![ppt8](https://assets.leetcode-cn.com/solution-static/19/8.png),![ppt9](https://assets.leetcode-cn.com/solution-static/19/9.png),![ppt10](https://assets.leetcode-cn.com/solution-static/19/10.png)>\n\n**ä»£ç **\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummy = new ListNode(0, head);\n        stack<ListNode*> stk;\n        ListNode* cur = dummy;\n        while (cur) {\n            stk.push(cur);\n            cur = cur->next;\n        }\n        for (int i = 0; i < n; ++i) {\n            stk.pop();\n        }\n        ListNode* prev = stk.top();\n        prev->next = prev->next->next;\n        ListNode* ans = dummy->next;\n        delete dummy;\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0, head);\n        Deque<ListNode> stack = new LinkedList<ListNode>();\n        ListNode cur = dummy;\n        while (cur != null) {\n            stack.push(cur);\n            cur = cur.next;\n        }\n        for (int i = 0; i < n; ++i) {\n            stack.pop();\n        }\n        ListNode prev = stack.peek();\n        prev.next = prev.next.next;\n        ListNode ans = dummy.next;\n        return ans;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = ListNode(0, head)\n        stack = list()\n        cur = dummy\n        while cur:\n            stack.append(cur)\n            cur = cur.next\n        \n        for i in range(n):\n            stack.pop()\n\n        prev = stack[-1]\n        prev.next = prev.next.next\n        return dummy.next\n```\n\n```Golang [sol2-Golang]\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    nodes := []*ListNode{}\n    dummy := &ListNode{0, head}\n    for node := dummy; node != nil; node = node.Next {\n        nodes = append(nodes, node)\n    }\n    prev := nodes[len(nodes)-1-n]\n    prev.Next = prev.Next.Next\n    return dummy.Next\n}\n```\n\n```C [sol2-C]\nstruct Stack {\n    struct ListNode* val;\n    struct Stack* next;\n};\n\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\n    dummy->val = 0, dummy->next = head;\n    struct Stack* stk = NULL;\n    struct ListNode* cur = dummy;\n    while (cur) {\n        struct Stack* tmp = malloc(sizeof(struct Stack));\n        tmp->val = cur, tmp->next = stk;\n        stk = tmp;\n        cur = cur->next;\n    }\n    for (int i = 0; i < n; ++i) {\n        struct Stack* tmp = stk->next;\n        free(stk);\n        stk = tmp;\n    }\n    struct ListNode* prev = stk->val;\n    prev->next = prev->next->next;\n    struct ListNode* ans = dummy->next;\n    free(dummy);\n    return ans;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(L)$ï¼Œå…¶ä¸­ $L$ æ˜¯é“¾è¡¨çš„é•¿åº¦ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(L)$ï¼Œå…¶ä¸­ $L$ æ˜¯é“¾è¡¨çš„é•¿åº¦ã€‚ä¸»è¦ä¸ºæ ˆçš„å¼€é”€ã€‚\n\n#### æ–¹æ³•ä¸‰ï¼šåŒæŒ‡é’ˆ\n\n**æ€è·¯ä¸ç®—æ³•**\n\næˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨ä¸é¢„å¤„ç†å‡ºé“¾è¡¨çš„é•¿åº¦ï¼Œä»¥åŠä½¿ç”¨å¸¸æ•°ç©ºé—´çš„å‰æä¸‹è§£å†³æœ¬é¢˜ã€‚\n\nç”±äºæˆ‘ä»¬éœ€è¦æ‰¾åˆ°å€’æ•°ç¬¬ $n$ ä¸ªèŠ‚ç‚¹ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆ $\\textit{first}$ å’Œ $\\textit{second}$ åŒæ—¶å¯¹é“¾è¡¨è¿›è¡Œéå†ï¼Œå¹¶ä¸” $\\textit{first}$ æ¯” $\\textit{second}$ è¶…å‰ $n$ ä¸ªèŠ‚ç‚¹ã€‚å½“ $\\textit{first}$ éå†åˆ°é“¾è¡¨çš„æœ«å°¾æ—¶ï¼Œ$\\textit{second}$ å°±æ°å¥½å¤„äºå€’æ•°ç¬¬ $n$ ä¸ªèŠ‚ç‚¹ã€‚\n\nå…·ä½“åœ°ï¼Œåˆå§‹æ—¶ $\\textit{first}$ å’Œ $\\textit{second}$ å‡æŒ‡å‘å¤´èŠ‚ç‚¹ã€‚æˆ‘ä»¬é¦–å…ˆä½¿ç”¨ $\\textit{first}$ å¯¹é“¾è¡¨è¿›è¡Œéå†ï¼Œéå†çš„æ¬¡æ•°ä¸º $n$ã€‚æ­¤æ—¶ï¼Œ$\\textit{first}$ å’Œ $\\textit{second}$ ä¹‹é—´é—´éš”äº† $n-1$ ä¸ªèŠ‚ç‚¹ï¼Œå³ $\\textit{first}$ æ¯” $\\textit{second}$ è¶…å‰äº† $n$ ä¸ªèŠ‚ç‚¹ã€‚\n\nåœ¨è¿™ä¹‹åï¼Œæˆ‘ä»¬åŒæ—¶ä½¿ç”¨ $\\textit{first}$ å’Œ $\\textit{second}$ å¯¹é“¾è¡¨è¿›è¡Œéå†ã€‚å½“ $\\textit{first}$ éå†åˆ°é“¾è¡¨çš„æœ«å°¾ï¼ˆå³ $\\textit{first}$ ä¸ºç©ºæŒ‡é’ˆï¼‰æ—¶ï¼Œ$\\textit{second}$ æ°å¥½æŒ‡å‘å€’æ•°ç¬¬ $n$ ä¸ªèŠ‚ç‚¹ã€‚\n\næ ¹æ®æ–¹æ³•ä¸€å’Œæ–¹æ³•äºŒï¼Œå¦‚æœæˆ‘ä»¬èƒ½å¤Ÿå¾—åˆ°çš„æ˜¯å€’æ•°ç¬¬ $n$ ä¸ªèŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹è€Œä¸æ˜¯å€’æ•°ç¬¬ $n$ ä¸ªèŠ‚ç‚¹çš„è¯ï¼Œåˆ é™¤æ“ä½œä¼šæ›´åŠ æ–¹ä¾¿ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥è€ƒè™‘åœ¨åˆå§‹æ—¶å°† $\\textit{second}$ æŒ‡å‘å“‘èŠ‚ç‚¹ï¼Œå…¶ä½™çš„æ“ä½œæ­¥éª¤ä¸å˜ã€‚è¿™æ ·ä¸€æ¥ï¼Œå½“ $\\textit{first}$ éå†åˆ°é“¾è¡¨çš„æœ«å°¾æ—¶ï¼Œ$\\textit{second}$ çš„**ä¸‹ä¸€ä¸ªèŠ‚ç‚¹**å°±æ˜¯æˆ‘ä»¬éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ã€‚\n\n![p3](https://assets.leetcode-cn.com/solution-static/19/p3.png)\n\n**ä»£ç **\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* first = head;\n        ListNode* second = dummy;\n        for (int i = 0; i < n; ++i) {\n            first = first->next;\n        }\n        while (first) {\n            first = first->next;\n            second = second->next;\n        }\n        second->next = second->next->next;\n        ListNode* ans = dummy->next;\n        delete dummy;\n        return ans;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode first = head;\n        ListNode second = dummy;\n        for (int i = 0; i < n; ++i) {\n            first = first.next;\n        }\n        while (first != null) {\n            first = first.next;\n            second = second.next;\n        }\n        second.next = second.next.next;\n        ListNode ans = dummy.next;\n        return ans;\n    }\n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = ListNode(0, head)\n        first = head\n        second = dummy\n        for i in range(n):\n            first = first.next\n\n        while first:\n            first = first.next\n            second = second.next\n        \n        second.next = second.next.next\n        return dummy.next\n```\n\n```Golang [sol3-Golang]\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    dummy := &ListNode{0, head}\n    first, second := head, dummy\n    for i := 0; i < n; i++ {\n        first = first.Next\n    }\n    for ; first != nil; first = first.Next {\n        second = second.Next\n    }\n    second.Next = second.Next.Next\n    return dummy.Next\n}\n```\n\n```C [sol3-C]\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\n    dummy->val = 0, dummy->next = head;\n    struct ListNode* first = head;\n    struct ListNode* second = dummy;\n    for (int i = 0; i < n; ++i) {\n        first = first->next;\n    }\n    while (first) {\n        first = first->next;\n        second = second->next;\n    }\n    second->next = second->next->next;\n    struct ListNode* ans = dummy->next;\n    free(dummy);\n    return ans;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(L)$ï¼Œå…¶ä¸­ $L$ æ˜¯é“¾è¡¨çš„é•¿åº¦ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚"
}