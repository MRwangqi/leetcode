{
	"titleSlug": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows",
	"slug": "by-lfool-w2ul",
	"url": "https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/solution/by-lfool-w2ul/",
	"content": "# [如果想要查看作者更多文章，可以点击此处！！！🔥🔥🔥](https://lfool.github.io/LFool-Notes/)\n\n# [为了本篇文章更好的观感，可以点击此处！！！](https://lfool.github.io/LFool-Notes/algorithm/二分搜索-第K小问题.html)\n\n[719. 找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)\n\n[1439. 有序矩阵中的第 k 个最小数组和](https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/)\n\n本篇文章主要介绍如何使用「二分搜索」来解决「第 K 小」的问题。如上面给出的两个题目，难度为「Hard」，在理解上可能需要花更多的时间！！\n\n**关于「二分搜索」的详细介绍可见 [二分搜索](https://lfool.github.io/LFool-Notes/algorithm/二分搜索.html)**；**关于抽象类的二分搜索 [抽象类的二分搜索](https://lfool.github.io/LFool-Notes/algorithm/抽象类的二分搜索.html)**\n\n今天的题目也属于「抽象类的二分搜索」类型，所有我们需要搞清楚什么是「**搜索对象**」和「**搜索范围**」\n\n## 找出第 K 小的数对距离\n\n**题目详情可见 [找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)**\n\n**这里给出暴力的思路**：维护一个大小为 `k` 的大根堆优先队列，如果入队元素「小于」当前队顶元素，则弹出队顶元素，然后把要入队的元素压入队列中。当处理完所有元素后，队顶元素即为「第 K 小」的元素\n\n当然，本篇文章要介绍的方法更快，更好！其实就是二分搜索啦！！！\n\n我们先明确一下原问题：「返回**所有数对距离中**第 `k` 小的数对距离」\n\n对于一个给定的数对距离 `d`，如果该距离近了，那我们就「向右收缩」；如果该距离远了，那我们就「向左收缩」；如果该距离满足要求，那我们能不能找一个更小的且满足要求的距离，所以需要继续「向左收缩」(是不是很像「寻找最左相等元素」？自信点，就是「寻找最左相等元素」)\n\n所以「**搜索对象**」是什么？？很明显就是「**距离**」嘛！！\n\n那「**搜索范围**」又是什么呢？？\n\n- 距离最小值可以到达多少？$0$\n- 距离最大值可以到达多少？$10^6 \\Rightarrow$  根据题目范围得到滴！ \n\n明确了「**搜索对象**」和「**搜索范围**」，我们还需要搞清楚怎么确定距离近了还是远了，肯定要有一个参考对象才能确定近还是远嘛\n\n很聪明，这个参考对象就是题目给的「第 `k` 小」。对于距离 `d`，小于等于该距离的数量为 `n`，如果 `n < k` 说明距离近了；如果 `n > k` 说明距离远了\n\n### 双指针计算 `n`\n\n对于一个距离 `d`，怎么得到小于等于该距离的数量呢？\n\n可以直接暴力，但这不是我们想要的，这里介绍「双指针」方法。\n\n使用「双指针」的前提是需要数组有序，由于本题目中的距离是绝对值，所以事先对数组排序并不影响结果的正确性\n\n假设 `nums = [1, 4, 5, 8, 10, 12], d = 4`\n\n双指针 `i` 表示区间的起点，`j` 表示区间的终点，表示为 `[i, j)`，注意是「左闭右开」\n\n区间 `[i, j)` 表示对于任意 $a$ 且满足 $i < a < j$，均有 $d(i, a) \\le 4$。具体如下图所示：\n\n![1.svg](https://pic.leetcode-cn.com/1655473042-nSPbxu-1.svg)\n\n**解释**：对于区间 `[0, 3)`，以 `0` 为起点的数对有：`(0, 1), (0, 2)`，其距离均小于等于 4\n\n当 `i = 0` 满足要求的情况处理完后，`i` 向前移动一格，此时 `j` 只需要在位置 `3` 的基础上继续向前扩张即可。具体如下图所示：\n\n![2.svg](https://pic.leetcode-cn.com/1655473035-JrVoXH-2.svg)\n\n可以看到橙色部分是 `i = 0` 确定的区域，红色部分是新扩张的区域。由于 `i` 向前移动了一格，所以上一步满足要求的区域，此时肯定也满足要求 (**有点绕，需要好好理解**)\n\n下面给出本题的代码实现：\n\n```java\npublic int smallestDistancePair(int[] nums, int k) {\n    // 排序\n    Arrays.sort(nums);\n    // 搜索范围\n    int lo = 0, hi = (int) 1e6;\n    while (lo <= hi) {\n        int mid = lo - (lo - hi) / 2;\n        // 对应距离远了，向左收缩\n        if (check(nums, mid) >= k) hi = mid - 1;\n        // 对应距离近了，向右收缩\n        else lo = mid + 1;\n    }\n    return lo;\n}\n// 双指针计算 小于等于 x 的数量\nprivate int check(int[] nums, int x) {\n    int ans = 0;\n    int n = nums.length;\n    // 初始时，i = 0, j = 1\n    for (int i = 0, j = 1; i < n; i++) {\n        // j 向向前扩张\n        while (j < n && nums[j] - nums[i] <= x) j++;\n        // 对于区间 [i, j)，满足要求的数量为 j - i - 1\n        ans += j - i - 1;\n    }\n    return ans;\n}\n```\n\n## 有序矩阵中的第 k 个最小数组和\n\n**题目详情可见 [有序矩阵中的第 k 个最小数组和](https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/)**\n\n我们先明确一下原问题：「返回所有可能数组中的第 k 个**最小**数组和」\n\n对于一个给定的数组和 `sum`，如果该数组和小了，那我们就「向右收缩」；如果该数组和大了，那我们就「向左收缩」；如果该数组和满足要求，那我们能不能找一个更小的且满足要求的数组和，所以需要继续「向左收缩」(是不是很像「寻找最左相等元素」？自信点，就是「寻找最左相等元素」)\n\n所以「**搜索对象**」是什么？？很明显就是「**数组和**」嘛！！\n\n那「**搜索范围**」又是什么呢？？\n\n- 数组和最小值可以到达多少？肯定是该矩形的第一列组成的组数和嘛 (矩形每行递增)\n- 数组和最大值可以到达多少？肯定是该矩形的最后一列组成的组数和嘛 (矩形每行递增)\n\n明确了「**搜索对象**」和「**搜索范围**」，我们还需要搞清楚怎么确定数组和小了还是大了，肯定要有一个参考对象才能确定近还是远嘛\n\n很聪明，这个参考对象就是题目给的「第 `k` 最小」。对于数组和 `sum`，小于等于该数组和的数量为 `n`，如果 `n < k` 说明数组和小了；如果 `n > k` 说明数组和大了\n\n### DFS 计算 `n`\n\n这一部分还挺难理解的，看了好多题解，发现很多人都是一下子给出代码！！\n\n既然这是一个 DFS 问题，肯定也是满足 DFS 套路的。**关于 DFS 的详细介绍可见 [回溯 (DFS) 算法框架](https://lfool.github.io/LFool-Notes/algorithm/回溯(DFS).html)**\n\n初始状态为第一列，如下图所示：\n\n![6.svg](https://pic.leetcode-cn.com/1655473014-PyjRVv-6.svg)\n\n对于第一行，我们可以选择「不变」，也可以选择「 2 or 3 or 4 or 5」与「1」交换。假如选择了「4」与「1」交换，那么此时的子数组为「4，6，11，16」，和为「37」，如下图所示：\n\n![7.svg](https://pic.leetcode-cn.com/1655472992-ZnebaZ-7.svg)\n\n对于每一行，都和第一行差不多。为了更清晰的写出 DFS，下面给出「搜索树」\n\n![9.svg](https://pic.leetcode-cn.com/1655473001-LVGyze-9.svg)\n\n下面给出本题的代码实现：\n\n```java\nprivate int m, n, k;\nprivate int[][] mat;\n// 计算小于等于当前数组和的数量\nprivate int cnt = 0;\npublic int kthSmallest(int[][] mat, int k) {\n    this.k = k;\n    this.mat = mat;\n    m = mat.length;\n    n = mat[0].length;\n    // 搜索范围\n    int left = 0, right = 0;\n    for (int i = 0; i < m; i++) {\n        left += mat[i][0];\n        right += mat[i][n - 1];\n    }\n    // 把最小值设为初始值\n    int init = left;\n    while (left <= right) {\n        int mid = left - (left - right) / 2;\n        // 初始值也算一个可行解\n        cnt = 1;\n        dfs(0, init, mid);\n        // 对应数组和大了，向左收缩\n        if (cnt >= k) right = mid - 1;\n        // 对应数组和小了，向右收缩\n        else left = mid + 1;\n    }\n    return left;\n}\n// DFS 计算 小于等于 target 的数量\nprivate void dfs(int row, int sum, int target) {\n    // 特殊情况，直接返回\n    // sum > target：当前数组和大于 target\n    // cnt > k：当前小于等于 target 的数量大于 k\n    // row >= m：已经到达最后一行 (结束条件)\n    if (sum > target || cnt > k || row >= m) return;\n    // 不做交换\n    dfs(row + 1, sum, target);\n    // 分别与 [1, n-1] 交换\n    for (int i = 1; i < n; i++) {\n        // 更新数组和：减去「第一个元素」，加上「要交换的元素」\n        int newSum = sum - mat[row][0] + mat[row][i];\n        // 交换后的数组和大于 target，直接跳出循环\n        // 原因：由于每行元素递增，所以当前元素大了，该行后面的元素肯定也大了\n        if (newSum > target) break;\n        // 满足要求，cnt + 1\n        cnt++;\n        // 搜索下一行\n        dfs(row + 1, newSum, target);\n    }\n}\n```"
}