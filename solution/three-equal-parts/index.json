{
	"titleSlug": "three-equal-parts",
	"slug": "san-deng-fen-by-leetcode-solution-3l2y",
	"url": "https://leetcode-cn.com/problems/three-equal-parts/solution/san-deng-fen-by-leetcode-solution-3l2y/",
	"content": "#### 方法一：将 $1$ 的数量三等分\n\n**思路与算法**\n\n如果存在一种分法使得三个非空部分所表示的二进制值相同，那么最终每一部分 $1$ 的数量一定是相等的。根据这个思想，我们首先统计数组 $\\textit{arr}$ 中 $1$ 的个数，把它设为 $\\textit{sum}$。如果 $\\textit{sum}$ 不能被 $3$ 整除，那么显然不存在正确分法。否则，每一个部分都应当有 $\\textit{partial} = \\dfrac{\\textit{sum}}{3}$ 个 $1$。\n\n我们尝试找到 $\\textit{arr}$ 中第 $1$ 个 $1$ 出现的位置 $\\textit{first}$，第 $\\textit{partial} + 1$ 个 $1$ 出现的位置 $\\textit{second}$ 以及第 $2 \\times \\textit{partial} + 1$ 个 $1$ 出现的位置 $\\textit{third}$。因为每一部分末尾的 $0$ 可以移动到下一部分的首部从而改变二进制值的大小, 所以每一部分的末尾难以界定。但是注意到，数组的末尾是无法改变的，因此区间 $[\\textit{third}, \\textit{arr.length} - 1]$ 所表示的二进制值可以固定。\n\n设 $\\textit{len} = \\textit{arr.length} - \\textit{third}$，表示二进制值的长度。接下来只需要判断 $[\\textit{first}, \\textit{first} + \\textit{len})$、$[\\textit{second}, \\textit{second} + \\textit{len})$ 和 $[\\textit{third}, \\textit{third} + \\textit{len})$ 是否完全相同即可。前提是 $\\textit{first} + \\textit{len} \\le \\textit{second}$ 并且 $\\textit{second} + \\textit{len} \\le \\textit{third}$。\n\n如果以上三段区间是完全相同的，那么答案就是 $[\\textit{first} + \\textit{len} - 1, \\textit{second} + \\textit{len}]$。最后需要注意到，如果 $\\textit{sum} = 0$，我们需要直接返回答案 $[0, 2]$（或者其他任意合法答案）。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\n        s = sum(arr)\n        if s % 3:\n            return [-1, -1]\n        if s == 0:\n            return [0, 2]\n\n        partial = s // 3\n        first = second = third = cur = 0\n        for i, x in enumerate(arr):\n            if x:\n                if cur == 0:\n                    first = i\n                elif cur == partial:\n                    second = i\n                elif cur == 2 * partial:\n                    third = i\n                cur += 1\n\n        n = len(arr)\n        length = n - third\n        if first + length <= second and second + length <= third:\n            i = 0\n            while third + i < n:\n                if arr[first + i] != arr[second + i] or arr[first + i] != arr[third + i]:\n                    return [-1, -1]\n                i += 1\n            return [first + length - 1, second + length]\n        return [-1, -1]\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& arr) {\n        int sum = accumulate(arr.begin(), arr.end(), 0);\n        if (sum % 3 != 0) {\n            return {-1, -1};\n        }\n        if (sum == 0) {\n            return {0, 2};\n        }\n\n        int partial = sum / 3;\n        int first = 0, second = 0, third = 0, cur = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr[i] == 1) {\n                if (cur == 0) {\n                    first = i;\n                }\n                else if (cur == partial) {\n                    second = i;\n                }\n                else if (cur == 2 * partial) {\n                    third = i;\n                }\n                cur++;\n            }\n        }\n\n        int len = (int)arr.size() - third;\n        if (first + len <= second && second + len <= third) {\n            int i = 0;\n            while (third + i < arr.size()) {\n                if (arr[first + i] != arr[second + i] || arr[first + i] != arr[third + i]) {\n                    return {-1, -1};\n                }\n                i++;\n            }\n            return {first + len - 1, second + len};\n        }\n        return {-1, -1};\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] threeEqualParts(int[] arr) {\n        int sum = Arrays.stream(arr).sum();\n        if (sum % 3 != 0) {\n            return new int[]{-1, -1};\n        }\n        if (sum == 0) {\n            return new int[]{0, 2};\n        }\n\n        int partial = sum / 3;\n        int first = 0, second = 0, third = 0, cur = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == 1) {\n                if (cur == 0) {\n                    first = i;\n                } else if (cur == partial) {\n                    second = i;\n                } else if (cur == 2 * partial) {\n                    third = i;\n                }\n                cur++;\n            }\n        }\n\n        int len = arr.length - third;\n        if (first + len <= second && second + len <= third) {\n            int i = 0;\n            while (third + i < arr.length) {\n                if (arr[first + i] != arr[second + i] || arr[first + i] != arr[third + i]) {\n                    return new int[]{-1, -1};\n                }\n                i++;\n            }\n            return new int[]{first + len - 1, second + len};\n        }\n        return new int[]{-1, -1};\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] ThreeEqualParts(int[] arr) {\n        int sum = arr.Sum();\n        if (sum % 3 != 0) {\n            return new int[]{-1, -1};\n        }\n        if (sum == 0) {\n            return new int[]{0, 2};\n        }\n\n        int partial = sum / 3;\n        int first = 0, second = 0, third = 0, cur = 0;\n        for (int i = 0; i < arr.Length; i++) {\n            if (arr[i] == 1) {\n                if (cur == 0) {\n                    first = i;\n                } else if (cur == partial) {\n                    second = i;\n                } else if (cur == 2 * partial) {\n                    third = i;\n                }\n                cur++;\n            }\n        }\n\n        int len = arr.Length - third;\n        if (first + len <= second && second + len <= third) {\n            int i = 0;\n            while (third + i < arr.Length) {\n                if (arr[first + i] != arr[second + i] || arr[first + i] != arr[third + i]) {\n                    return new int[]{-1, -1};\n                }\n                i++;\n            }\n            return new int[]{first + len - 1, second + len};\n        }\n        return new int[]{-1, -1};\n    }\n}\n```\n\n```C [sol1-C]\nint* threeEqualParts(int* arr, int arrSize, int* returnSize) {\n    int sum = 0;\n    int *ans = (int *)malloc(sizeof(int) * 2);\n    *returnSize = 2;\n    for (int i = 0; i < arrSize; i++) {\n        sum += arr[i];\n    }\n    if (sum % 3 != 0) {\n        ans[0] = -1, ans[1] = -1;\n        return ans;\n    }\n    if (sum == 0) {\n        ans[0] = 0, ans[1] = 2;\n        return ans;\n    }\n\n    int partial = sum / 3;\n    int first = 0, second = 0, third = 0, cur = 0;\n    for (int i = 0; i < arrSize; i++) {\n        if (arr[i] == 1) {\n            if (cur == 0) {\n                first = i;\n            }\n            else if (cur == partial) {\n                second = i;\n            }\n            else if (cur == 2 * partial) {\n                third = i;\n            }\n            cur++;\n        }\n    }\n\n    int len = (int)arrSize - third;\n    if (first + len <= second && second + len <= third) {\n        int i = 0;\n        while (third + i < arrSize) {\n            if (arr[first + i] != arr[second + i] || arr[first + i] != arr[third + i]) {\n                ans[0] = -1, ans[1] = -1;\n                return ans;\n            }\n            i++;\n        }\n        ans[0] = first + len - 1, ans[1] = second + len;\n        return ans;\n    }\n    ans[0] = -1, ans[1] = -1;\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar threeEqualParts = function(arr) {\n    const sum = _.sum(arr);\n    if (sum % 3 !== 0) {\n        return [-1, -1];\n    }\n    if (sum === 0) {\n        return [0, 2];\n    }\n\n    const partial = Math.floor(sum / 3);\n    let first = 0, second = 0, third = 0, cur = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === 1) {\n            if (cur === 0) {\n                first = i;\n            } else if (cur === partial) {\n                second = i;\n            } else if (cur === 2 * partial) {\n                third = i;\n            }\n            cur++;\n        }\n    }\n\n    let len = arr.length - third;\n    if (first + len <= second && second + len <= third) {\n        let i = 0;\n        while (third + i < arr.length) {\n            if (arr[first + i] !== arr[second + i] || arr[first + i] !== arr[third + i]) {\n                return [-1, -1];\n            }\n            i++;\n        }\n        return [first + len - 1, second + len];\n    }\n    return [-1, -1];\n};\n```\n\n```go [sol1-Golang]\nfunc threeEqualParts(arr []int) []int {\n    sum := 0\n    for _, v := range arr {\n        sum += v\n    }\n    if sum%3 != 0 {\n        return []int{-1, -1}\n    }\n    if sum == 0 {\n        return []int{0, 2}\n    }\n\n    partial := sum / 3\n    first, second, third, cur := 0, 0, 0, 0\n    for i, x := range arr {\n        if x == 1 {\n            if cur == 0 {\n                first = i\n            } else if cur == partial {\n                second = i\n            } else if cur == 2*partial {\n                third = i\n            }\n            cur++\n        }\n    }\n\n    n := len(arr)\n    length := n - third\n    if first+length <= second && second+length <= third {\n        i := 0\n        for third+i < n {\n            if arr[first+i] != arr[second+i] || arr[first+i] != arr[third+i] {\n                return []int{-1, -1}\n            }\n            i++\n        }\n        return []int{first + length - 1, second + length}\n    }\n    return []int{-1, -1}\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是 $\\textit{arr}$ 的长度。找到三个下标的时间复杂度为 $O(n)$，判断三个部分是否相同的时间复杂度也是 $O(n)$。\n\n- 空间复杂度：$O(1)$，只用到常数个变量空间。"
}