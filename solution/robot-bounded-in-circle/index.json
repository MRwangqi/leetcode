{
	"titleSlug": "robot-bounded-in-circle",
	"slug": "by-stormsunshine-e9zx",
	"url": "https://leetcode-cn.com/problems/robot-bounded-in-circle/solution/by-stormsunshine-e9zx/",
	"content": "# 解法\r\n\r\n## 思路和算法\r\n\r\n为了判断机器人是否总是位于一个环中，需要遍历所有的指令，模拟机器人的操作。机器人接受的指令有三种，分别对应直走、左转和右转。\r\n\r\n- 机器人向北移动的坐标变化是 $(0, 1)$，机器人向南移动的坐标变化是 $(0, -1)$，机器人向东移动的坐标变化是 $(1, 0)$，机器人向西移动的坐标变化是 $(-1, 0)$。\r\n\r\n- 左转经过的方向依次是北、西、南、东。\r\n\r\n- 右转经过的方向依次是北、东、南、西。\r\n\r\n初始时，机器人位于坐标 $(0, 0)$，面向北方。遍历所有的指令并依次执行每个指令，对于每个指令，更新机器人的坐标或朝向。\r\n\r\n由于给定的指令数量有限，因此如果只执行一次给定的指令，则机器人一定位于一个环中。为了判断机器人是否总是位于一个环中，不需要考虑机器人的中间状态，只需要考虑给定的指令遍历一次结束时机器人所在坐标和朝向。\r\n\r\n- 如果给定的指令遍历一次结束时，机器人回到原点，则将给定的指令完整遍历任意次之后，机器人都将位于原点，因此机器人总是位于一个环中。\r\n\r\n- 如果给定的指令遍历一次结束时，机器人没有回到原点，但是机器人的朝向和初始朝向不同，则将给定的指令遍历两次或四次之后，机器人一定可以回到原点，因此机器人总是位于一个环中。假设给定的指令遍历一次结束时，机器人位于坐标 $(x, y)$，分别考虑机器人的不同朝向。\r\n\r\n   - 如果机器人面向南方，则将给定的指令遍历第二次的坐标变化是 $(-x, -y)$，因此将给定的指令遍历两次之后，机器人回到原点。\r\n\r\n   - 如果机器人面向东方，则将给定的指令遍历第二次的坐标变化是 $(y, -x)$，将给定的指令遍历第三次的坐标变化是 $(-x, -y)$，将给定的指令遍历第四次的坐标变化是 $(-y, x)$，因此将给定的指令遍历四次之后，机器人回到原点。\r\n\r\n   - 如果机器人面向西方，则将给定的指令遍历第二次的坐标变化是 $(-y, x)$，将给定的指令遍历第三次的坐标变化是 $(-x, -y)$，将给定的指令遍历第四次的坐标变化是 $(y, -x)$，因此将给定的指令遍历四次之后，机器人回到原点。\r\n\r\n- 如果给定的指令遍历一次结束时，机器人没有回到原点，且机器人的朝向和初始朝向相同，则每次遍历给定的指令都会使机器人向相同的方向移动，因此机器人不会总是位于一个环中。假设给定的指令遍历一次结束时，机器人位于坐标 $(x, y)$，则将给定的指令遍历 $k$ 次之后，机器人位于 $(kx, ky)$，由于 $x$ 和 $y$ 中至少有一个不为 $0$，因此每次遍历给定的指令都会使机器人和原点的距离更远，不存在一个环使得机器人总是位于这个环中。\r\n\r\n根据上述分析可知，机器人总是位于一个环中，等价于给定的指令遍历一次结束时，以下两个条件中至少有一个成立：机器人回到原点、机器人的朝向和初始朝向不同。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public boolean isRobotBounded(String instructions) {\r\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\r\n        int directionIndex = 0;\r\n        int xPosition = 0, yPosition = 0;\r\n        int length = instructions.length();\r\n        for (int i = 0; i < length; i++) {\r\n            char instruction = instructions.charAt(i);\r\n            if (instruction == 'G') {\r\n                xPosition += directions[directionIndex][0];\r\n                yPosition += directions[directionIndex][1];\r\n            } else if (instruction == 'L') {\r\n                directionIndex = (directionIndex + 3) % 4;\r\n            } else if (instruction == 'R') {\r\n                directionIndex = (directionIndex + 1) % 4;\r\n            }\r\n        }\r\n        return (xPosition == 0 && yPosition == 0) || directionIndex != 0;\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public bool IsRobotBounded(string instructions) {\r\n        int[][] directions = {new int[]{0, 1}, new int[]{1, 0}, new int[]{0, -1}, new int[]{-1, 0}};\r\n        int directionIndex = 0;\r\n        int xPosition = 0, yPosition = 0;\r\n        int length = instructions.Length;\r\n        for (int i = 0; i < length; i++) {\r\n            char instruction = instructions[i];\r\n            if (instruction == 'G') {\r\n                xPosition += directions[directionIndex][0];\r\n                yPosition += directions[directionIndex][1];\r\n            } else if (instruction == 'L') {\r\n                directionIndex = (directionIndex + 3) % 4;\r\n            } else if (instruction == 'R') {\r\n                directionIndex = (directionIndex + 1) % 4;\r\n            }\r\n        }\r\n        return (xPosition == 0 && yPosition == 0) || directionIndex != 0;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $\\textit{instructions}$ 的长度。需要遍历字符串 $\\textit{instructions}$ 一次，模拟机器人的操作，每个指令的处理时间是 $O(1)$。\r\n\r\n- 空间复杂度：$O(1)$。"
}