{
	"titleSlug": "string-rotation-lcci",
	"slug": "zi-fu-chuan-lun-zhuan-by-leetcode-soluti-kc8z",
	"url": "https://leetcode-cn.com/problems/string-rotation-lcci/solution/zi-fu-chuan-lun-zhuan-by-leetcode-soluti-kc8z/",
	"content": "#### 方法一：模拟\n\n**思路**\n\n首先，如果 $s_1$ 和 $s_2$ 的长度不一样，那么无论怎么轮转，$s_1$ 都不能得到 $s_2$，返回 $\\text{false}$。在长度一样（都为 $n$）的前提下，假设 $s_1$ 轮转 $i$ 位，则与 $s_2$ 中的某一位字符 $s_2[j]$ 对应的原 $s_1$ 中的字符应该为 $s_1[(i+j) \\bmod n]$。在固定 $i$ 的情况下，遍历所有 $j$，若对应字符都相同，则返回 $\\text{true}$。否则，继续遍历其他候选的 $i$。若所有的 $i$ 都不能使 $s_1$ 变成 $s_2$，则返回 $\\text{false}$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def isFlipedString(self, s1: str, s2: str) -> bool:\n        m, n = len(s1), len(s2)\n        if m != n:\n            return False\n        if n == 0:\n            return True\n        for i in range(n):\n            for j in range(n):\n                if s1[(i + j) % n] != s2[j]:\n                    break\n            else:\n                return True\n        return False\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean isFlipedString(String s1, String s2) {\n        int m = s1.length(), n = s2.length();\n        if (m != n) {\n            return false;\n        }\n        if (n == 0) {\n            return true;\n        }\n        for (int i = 0; i < n; i++) {\n            boolean flag = true;\n            for (int j = 0; j < n; j++) {\n                if (s1.charAt((i + j) % n) != s2.charAt(j)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool IsFlipedString(string s1, string s2) {\n        int m = s1.Length, n = s2.Length;\n        if (m != n) {\n            return false;\n        }\n        if (n == 0) {\n            return true;\n        }\n        for (int i = 0; i < n; i++) {\n            bool flag = true;\n            for (int j = 0; j < n; j++) {\n                if (s1[(i + j) % n] != s2[j]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool isFlipedString(string s1, string s2) {\n        int m = s1.size(), n = s2.size();\n        if (m != n) {\n            return false;\n        }\n        if (n == 0) {\n            return true;\n        }\n        for (int i = 0; i < n; i++) {\n            bool flag = true;\n            for (int j = 0; j < n; j++) {\n                if (s1[(i + j) % n] != s2[j]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n```C [sol1-C]\nbool isFlipedString(char* s1, char* s2) {\n    int m = strlen(s1), n = strlen(s2);\n    if (m != n) {\n        return false;\n    }\n    if (n == 0) {\n        return true;\n    }\n    for (int i = 0; i < n; i++) {\n        bool flag = true;\n        for (int j = 0; j < n; j++) {\n            if (s1[(i + j) % n] != s2[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar isFlipedString = function(s1, s2) {\n    const m = s1.length, n = s2.length;\n    if (m !== n) {\n        return false;\n    }\n    if (n === 0) {\n        return true;\n    }\n    for (let i = 0; i < n; i++) {\n        let flag = true;\n        for (let j = 0; j < n; j++) {\n            if (s1[(i + j) % n] !== s2[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            return true;\n        }\n    }\n    return false;\n};\n```\n\n```go [sol1-Golang]\nfunc isFlipedString(s1 string, s2 string) bool {\n    n := len(s1)\n    if n != len(s2) {\n        return false\n    }\n    if n == 0 {\n        return true\n    }\nnext:\n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            if s1[(i+j)%n] != s2[j] {\n                continue next\n            }\n        }\n        return true\n    }\n    return false\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 是字符串 $s_1$ 的长度。我们需要双重循环来判断。\n\n- 空间复杂度：$O(1)$。仅使用常数空间。\n\n#### 方法二：搜索子字符串\n\n**思路**\n\n首先，如果 $s_1$ 和 $s_2$ 的长度不一样，那么无论怎么轮转，$s_1$ 都不能得到 $s_2$，返回 $\\text{false}$。字符串 $s + s$ 包含了所有 $s_1$ 可以通过轮转操作得到的字符串，只需要检查 $s_2$ 是否为 $s + s$ 的子字符串即可。具体可以参考「[28. 实现 strStr() 的官方题解](https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode-solution-ds6y/)」的实现代码，本题解中采用直接调用库函数的方法。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def isFlipedString(self, s1: str, s2: str) -> bool:\n        return len(s1) == len(s2) and s2 in s1 + s1\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean isFlipedString(String s1, String s2) {\n        return s1.length() == s2.length() && (s1 + s1).contains(s2);\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public bool IsFlipedString(string s1, string s2) {\n        return s1.Length == s2.Length && (s1 + s1).Contains(s2);\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool isFlipedString(string s1, string s2) {\n        return s1.size() == s2.size() && (s1 + s1).find(s2) != string::npos;\n    }\n};\n```\n\n```C [sol2-C]\nbool isFlipedString(char* s1, char* s2) {\n    int m = strlen(s1), n = strlen(s2);\n    if (m != n) {\n        return false;\n    }\n    char * str = (char *)malloc(sizeof(char) * (m + n + 1));\n    sprintf(str, \"%s%s\", s2, s2);\n    return strstr(str, s1) != NULL;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar isFlipedString = function(s1, s2) {\n    return s1.length === s2.length && (s1 + s1).indexOf(s2) !== -1;\n};\n```\n\n```go [sol2-Golang]\nfunc isFlipedString(s1 string, s2 string) bool {\n   return len(s1) == len(s2) && strings.Contains(s1+s1, s2)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s_1$ 的长度。$\\text{KMP}$ 算法搜索子字符串的时间复杂度为 $O(n)$，其他搜索子字符串的方法会略有差异。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是字符串 $s_1$ 的长度。$\\text{KMP}$ 算法搜索子字符串的空间复杂度为 $O(n)$，其他搜索子字符串的方法会略有差异。"
}