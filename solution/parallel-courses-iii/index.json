{
	"titleSlug": "parallel-courses-iii",
	"slug": "-by-yu-niang-niang-vwx1",
	"url": "https://leetcode-cn.com/problems/parallel-courses-iii/solution/-by-yu-niang-niang-vwx1/",
	"content": "### 方法：拓扑排序\n1. 拓扑建图、算入度、BFS,为了方便计算，所有课程编码减少1个\n2. 学完第i门课程的最短时间用max[i]表示\n3. 入度为0的点学完第i门课程的最短时间为max[i]\n4. 对于每个有先修课程的点，必须学完所有先修课程才可以继续学，所以需要取所有先修的最长时间，加上当前课程的学习时间，作为学完这门课需要的最短时间\n5. 返回学完所有课程最短时间的最大值\n\n```java\nclass Solution {\n    public int minimumTime(int n, int[][] relations, int[] time) {\n       Set<Integer>[] graph = new HashSet[n];\n       Arrays.setAll(graph,o->new HashSet<>());\n       int[] indegrees = new int[n];\n       for(int[] relation:relations){\n           int a = relation[0]-1;\n           int b = relation[1]-1;\n           graph[a].add(b);\n           indegrees[b]++;\n       }\n\n       int[] max = new int[n];\n      \n       Queue<Integer> queue =new LinkedList<>();\n       for(int i = 0; i < n; i++){\n           if(indegrees[i]==0){\n               queue.offer(i);\n               max[i] = time[i];\n           }\n       }\n       \n       \n       while (!queue.isEmpty()){\n           int item = queue.poll();\n           for(Integer next:graph[item]){\n               indegrees[next]--;\n               max[next] = Math.max(max[next],max[item]+time[next]);\n               if(indegrees[next]==0){\n                   queue.offer(next);\n               }\n           }\n       }\n\n       int ans = 0;\n       for(int v:max) ans = Math.max(v,ans);\n       return ans;\n    }\n}\n```"
}