{
	"titleSlug": "unique-morse-code-words",
	"slug": "wei-yi-mo-er-si-mi-ma-ci-by-leetcode-sol-9n7w",
	"url": "https://leetcode-cn.com/problems/unique-morse-code-words/solution/wei-yi-mo-er-si-mi-ma-ci-by-leetcode-sol-9n7w/",
	"content": "#### 方法一：哈希表\n\n**思路与算法**\n\n我们将数组 $\\textit{words}$ 中的每个单词按照莫尔斯密码表转换为摩尔斯码，并加入哈希集合中，最终的答案即为哈希集合中元素的个数。\n\n**代码**\n\n```Python [sol1-Python3]\nMORSE = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\",\n         \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\",\n         \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\n         \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\n\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        return len(set(\"\".join(MORSE[ord(ch) - ord('a')] for ch in word) for word in words))\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public static final String[] MORSE = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\",\n                                      \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\",\n                                      \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\n                                      \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\n\n    public int uniqueMorseRepresentations(String[] words) {\n        Set<String> seen = new HashSet<String>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charAt(i);\n                code.append(MORSE[c - 'a']);\n            }\n            seen.add(code.toString());\n        }\n        return seen.size();\n    }\n}\n```\n\n```C++ [sol1-C++]\nconst static string MORSE[] = {\n        \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\",\n        \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\",\n        \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\n        \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n};\n\nclass Solution {\npublic:\n    int uniqueMorseRepresentations(vector<string> &words) {\n        unordered_set<string> seen;\n        for (auto &word: words) {\n            string code;\n            for (auto &c: word) {\n                code.append(MORSE[c - 'a']);\n            }\n            seen.emplace(code);\n        }\n        return seen.size();\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public static string[] MORSE = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\",\n                                      \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\",\n                                      \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\n                                      \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\n\n    public int UniqueMorseRepresentations(string[] words) {\n        ISet<string> seen = new HashSet<string>();\n        foreach (string word in words) {\n            StringBuilder code = new StringBuilder();\n            foreach (char c in word) {\n                code.Append(MORSE[c - 'a']);\n            }\n            seen.Add(code.ToString());\n        }\n        return seen.Count;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX_STR_LEN 64\n\ntypedef struct {\n    char key[MAX_STR_LEN];\n    UT_hash_handle hh;\n} HashItem;\n\nconst static char * MORSE[26] = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \\\n                                 \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \\\n                                 \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \\\n                                 \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\n\nint uniqueMorseRepresentations(char ** words, int wordsSize){\n    HashItem * seen = NULL;\n    for (int i = 0; i < wordsSize; i++) {\n        HashItem * pEntry = NULL;\n        int len = strlen(words[i]);\n        int pos = 0;\n        char code[MAX_STR_LEN];\n        for (int j = 0; j < len; j++) {\n            pos += sprintf(code + pos, \"%s\", MORSE[words[i][j] - 'a']);\n        }\n        HASH_FIND_STR(seen, code, pEntry);\n        if (NULL == pEntry) {\n            pEntry = (HashItem *)malloc(sizeof(HashItem));\n            strcpy(pEntry->key, code);\n            HASH_ADD_STR(seen, key, pEntry);\n        }\n    }\n    int ans = HASH_COUNT(seen);\n    HashItem * curr = NULL, * tmp = NULL;\n    HASH_ITER(hh, seen, curr, tmp) {\n        HASH_DEL(seen, curr); \n        free(curr);            \n    }\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst MORSE = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\nvar uniqueMorseRepresentations = function(words) {\n    const seen = new Set();\n    for (const word of words) {\n        let code = '';\n        for (const ch of word) {\n            code += (MORSE[ch.charCodeAt() - 'a'.charCodeAt()]);\n        }\n        seen.add(code);\n    }\n    return seen.size;\n}\n```\n\n```go [sol1-Golang]\nvar morse = []string{\n    \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\",\n    \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\",\n    \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\n    \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\",\n}\n\nfunc uniqueMorseRepresentations(words []string) int {\n    set := map[string]struct{}{}\n    for _, word := range words {\n        trans := &strings.Builder{}\n        for _, ch := range word {\n            trans.WriteString(morse[ch-'a'])\n        }\n        set[trans.String()] = struct{}{}\n    }\n    return len(set)\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(S)$，其中 $S$ 是数组 $\\textit{words}$ 中所有单词的长度之和。\n\n+ 空间复杂度：$O(S)$，其中 $S$ 是数组 $\\textit{words}$ 中所有单词的长度之和。"
}