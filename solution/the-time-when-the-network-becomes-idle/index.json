{
	"titleSlug": "the-time-when-the-network-becomes-idle",
	"slug": "wang-luo-kong-xian-de-shi-ke-by-leetcode-qttv",
	"url": "https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/solution/wang-luo-kong-xian-de-shi-ke-by-leetcode-qttv/",
	"content": "#### 方法一：广度优先搜索\n\n**思路**\n\n我们可以将整个计算机网络视为一个无向图，服务器为图中的节点。根据图中的边对应的关系 $\\textit{edges}$ 即可求出图中任意节点之间的最短距离。利用广度优先搜索求出节点 $0$ 到其他节点的最短距离，然后依次求出每个节点变为空闲的时间，当所有节点都变为空闲时，整个网络即变空闲状态，因此网络的最早空闲时间即为各个节点中最晚的空闲时间。定义节点的空闲状态定义为该节点不再发送和接收消息。\n\n+ 求各个节点与 $0$ 号服务器的最短路径，直接利用广度优先搜索即可。\n\n+ 设节点 $v$ 与节点 $0$ 之间的最短距离为 $\\textit{dist}$，则此时当节点 $v$ 接收到主服务器节点 $0$ 的最后一个回复后的下一秒，则节点 $v$ 变为空闲状态。节点 $v$ 发送一个消息经过 $\\textit{dist}$ 秒到达节点 $0$，节点 $0$ 回复消息又经过 $\\textit{dist}$ 秒到达节点 $v$，因此节点 $v$ 每发送一次消息后，经过 $2 \\times \\textit{dist}$ 秒才能收到回复。由于节点 $v$ 在未收到节点 $0$ 的回复时，会周期性每 $\\textit{patience}[v]$ 秒发送一次消息，一旦收到来自节点 $0$ 的回复后就停止发送消息，需要分以下两种情况进行讨论：\n\n    - 当 $2 \\times \\textit{dist} \\le \\textit{patience}[v]$ 时，则此时节点 $v$ 还未开始发送第二次消息就已收到回复，因此节点 $v$ 只会发送一次消息，则此时节点 $v$ 变为空闲的时间为 $2 \\times \\textit{dist} + 1$。\n\n    - 当 $2 \\times \\textit{dist} > \\textit{patience}[v]$ 时，则此时节点还在等待第一次发送消息的回复时，就会开始再次重发消息，经过计算可以知道在 $[1,2 \\times \\textit{dist})$ 时间范围内会最多再次发送 $\\Big\\lfloor\\dfrac{2 \\times \\textit{dist}-1}{\\textit{patience}[i]}\\Big\\rfloor$ 次消息，最后一次发送消息的时间为 $\\textit{patience}[v] \\times \\Big\\lfloor\\dfrac{2 \\times \\textit{dist}-1}{\\textit{patience}[v]}\\Big\\rfloor$，而节点 $v$ 每发送一次消息就会经过 $2 \\times \\textit{dist}[v]$ 收到回复，因此节点 $v$ 最后一次收到回复的时间为 $\\textit{patience}[v] \\times \\Big\\lfloor\\dfrac{2 \\times \\textit{dist}-1}{\\textit{patience}[v]}\\Big\\rfloor + 2 \\times \\textit{dist}$，则此时可知节点 $v$ 变为空闲的时间为 $\\textit{patience}[v] \\times \\Big\\lfloor\\dfrac{2 \\times \\textit{dist}-1}{\\textit{patience}[v]}\\Big\\rfloor + 2 \\times \\textit{dist} + 1$。\n    \n   当 $2 \\times \\textit{dist} \\le \\textit{patience}[v]$ 时，$\\Big\\lfloor\\dfrac{2 \\times \\textit{dist}-1}{\\textit{patience}[v]}\\Big\\rfloor = 0$，因此以上两种情况可以进行合并，即节点 $v$ 变为空闲的时间为 $\\textit{patience}[v] \\times \\Big\\lfloor\\dfrac{2 \\times \\textit{dist}-1}{\\textit{patience}[v]}\\Big\\rfloor + 2 \\times \\textit{dist} + 1$。\n\n依次求出每个节点变为空闲的时间，返回最大值即为答案。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\n        n = len(patience)\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n\n        vis = [False] * n\n        vis[0] = True\n        q = deque([0])\n        ans, dist = 0, 1\n        while q:\n            for _ in range(len(q)):\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v]:\n                        continue\n                    vis[v] = True\n                    q.append(v)\n                    ans = max(ans, (dist * 2 - 1) // patience[v] * patience[v] + dist * 2 + 1)\n            dist += 1\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\n        int n = patience.size();       \n        vector<vector<int>> adj(n);\n        vector<bool> visit(n, false);  \n        for (auto & v : edges) {\n            adj[v[0]].emplace_back(v[1]);\n            adj[v[1]].emplace_back(v[0]);\n        }\n\n        queue<int> qu;\n        qu.emplace(0);\n        visit[0] = true;\n        int dist = 1;\n        int ans = 0;\n        while (!qu.empty()) {\n            int sz = qu.size();\n            for (int i = 0; i < sz; ++i) {\n                int curr = qu.front();\n                qu.pop();\n                for (auto & v : adj[curr]) {\n                    if (visit[v]) {\n                        continue;\n                    }\n                    qu.emplace(v);\n                    int time = patience[v] * ((2 * dist - 1) / patience[v]) + 2 * dist + 1;\n                    ans = max(ans, time);\n                    visit[v] = true;\n                }\n            }\n            dist++;\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\n        int n = patience.length;       \n        List<Integer>[] adj = new List[n];\n        for (int i = 0; i < n; ++i) {\n            adj[i] = new ArrayList<Integer>();\n        }\n        boolean[] visit = new boolean[n];\n        for (int[] v : edges) {\n            adj[v[0]].add(v[1]);\n            adj[v[1]].add(v[0]);\n        }\n\n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        queue.offer(0);\n        visit[0] = true;\n        int dist = 1;\n        int ans = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int curr = queue.poll();\n                for (int v : adj[curr]) {\n                    if (visit[v]) {\n                        continue;\n                    }\n                    queue.offer(v);\n                    int time = patience[v] * ((2 * dist - 1) / patience[v]) + 2 * dist + 1;\n                    ans = Math.max(ans, time);\n                    visit[v] = true;\n                }\n            }\n            dist++;\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int NetworkBecomesIdle(int[][] edges, int[] patience) {\n        int n = patience.Length;       \n        IList<int>[] adj = new IList<int>[n];\n        for (int i = 0; i < n; ++i) {\n            adj[i] = new List<int>();\n        }\n        bool[] visit = new bool[n];\n        foreach (int[] v in edges) {\n            adj[v[0]].Add(v[1]);\n            adj[v[1]].Add(v[0]);\n        }\n\n        Queue<int> queue = new Queue<int>();\n        queue.Enqueue(0);\n        visit[0] = true;\n        int dist = 1;\n        int ans = 0;\n        while (queue.Count > 0) {\n            int size = queue.Count;\n            for (int i = 0; i < size; i++) {\n                int curr = queue.Dequeue();\n                foreach (int v in adj[curr]) {\n                    if (visit[v]) {\n                        continue;\n                    }\n                    queue.Enqueue(v);\n                    int time = patience[v] * ((2 * dist - 1) / patience[v]) + 2 * dist + 1;\n                    ans = Math.Max(ans, time);\n                    visit[v] = true;\n                }\n            }\n            dist++;\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\nstatic inline int max(int x, int y) {\n    return x > y ? x : y;\n}\n\nint networkBecomesIdle(int** edges, int edgesSize, int* edgesColSize, int* patience, int patienceSize) {\n    int n = patienceSize;\n    struct ListNode ** adj = (struct ListNode **)malloc(sizeof(struct ListNode * ) * n);\n    bool * visit = (bool *)malloc(sizeof(bool) * n);\n    for (int i = 0; i < n; i++) {\n        visit[i] = false;\n        adj[i] = NULL;\n    }\n    struct ListNode * node = NULL;\n    for (int i = 0; i < edgesSize; i++) {\n        node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = edges[i][0];\n        node->next = adj[edges[i][1]];\n        adj[edges[i][1]] = node;\n        node = (struct ListNode *)malloc(sizeof(struct ListNode));\n        node->val = edges[i][1];\n        node->next = adj[edges[i][0]];\n        adj[edges[i][0]] = node;\n    }\n\n    int * queue = (int *)malloc(sizeof(int) * n);\n    int head = 0;\n    int tail = 0;\n    queue[tail++] = 0;\n    visit[0] = true;\n    int dist = 1;\n    int ans = 0;\n    while (head != tail) {\n        int sz = tail - head;\n        for (int i = 0; i < sz; ++i) {\n            int curr = queue[head];\n            head++;\n            for (struct ListNode * node = adj[curr]; node; node = node->next) {\n                int v = node->val;\n                if (visit[v]) {\n                    continue;\n                }\n                queue[tail++] = v;\n                int time = patience[v] * ((2 * dist - 1) / patience[v]) + 2 * dist + 1;\n                ans = max(ans, time);\n                visit[v] = true;\n            }\n        }\n        dist++;\n    }\n    free(queue);\n    free(visit);\n    for (int i = 0; i < n; i++) {\n        for (struct ListNode * curr = adj[i]; curr;) {\n            struct ListNode * next = curr->next;\n            free(curr);\n            curr = next;\n        }\n    }\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc networkBecomesIdle(edges [][]int, patience []int) (ans int) {\n    n := len(patience)\n    g := make([][]int, n)\n    for _, e := range edges {\n        x, y := e[0], e[1]\n        g[x] = append(g[x], y)\n        g[y] = append(g[y], x)\n    }\n\n    vis := make([]bool, n)\n    vis[0] = true\n    q := []int{0}\n    for dist := 1; q != nil; dist++ {\n        tmp := q\n        q = nil\n        for _, x := range tmp {\n            for _, v := range g[x] {\n                if vis[v] {\n                    continue\n                }\n                vis[v] = true\n                q = append(q, v)\n                ans = max(ans, (dist*2-1)/patience[v]*patience[v]+dist*2+1)\n            }\n        }\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n + m)$，其中 $n$ 为节点的数目，$m$ 为 $\\textit{edges}$ 数组的大小。利用广度优先搜索求每个节点到节点 $0$ 的最短距离的时间复杂度为 $O(n + m)$，求出每个节点的空闲时间的时间复杂度为 $O(n)$，因此总的时间复杂度为 $O(n + m)$。\n\n- 空间复杂度：$O(n + m)$，其中 $n$ 为节点的数目，$m$ 为 $\\textit{edges}$ 数组的大小。需要利用 $\\textit{edges}$ 重建图的关系，需要的空间为 $O(n + m)$，记录每个节点到节点 $0$ 的最短距离需要的空间为 $O(n)$，因此总的空间复杂度为 $O(n + m)$。"
}