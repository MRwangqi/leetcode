{
	"titleSlug": "most-frequent-subtree-sum",
	"slug": "chu-xian-ci-shu-zui-duo-de-zi-shu-yuan-s-kdjc",
	"url": "https://leetcode-cn.com/problems/most-frequent-subtree-sum/solution/chu-xian-ci-shu-zui-duo-de-zi-shu-yuan-s-kdjc/",
	"content": "#### 方法一：深度优先搜索\n\n我们可以从根结点出发，深度优先搜索这棵二叉树。对于每棵子树，其子树元素和等于子树根结点的元素值，加上左子树的元素和，以及右子树的元素和。\n\n用哈希表统计每棵子树的元素和的出现次数，计算出现次数的最大值 $\\textit{maxCnt}$，最后将出现次数等于 $\\textit{maxCnt}$ 的所有元素和返回。\n\n```Python [sol1-Python3]\nclass Solution:\n    def findFrequentTreeSum(self, root: TreeNode) -> List[int]:\n        cnt = Counter()\n        def dfs(node: TreeNode) -> int:\n            if node is None:\n                return 0\n            sum = node.val + dfs(node.left) + dfs(node.right)\n            cnt[sum] += 1\n            return sum\n        dfs(root)\n\n        maxCnt = max(cnt.values())\n        return [s for s, c in cnt.items() if c == maxCnt]\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    unordered_map<int, int> cnt;\n    int maxCnt = 0;\n\n    int dfs(TreeNode *node) {\n        if (node == nullptr) {\n            return 0;\n        }\n        int sum = node->val + dfs(node->left) + dfs(node->right);\n        maxCnt = max(maxCnt, ++cnt[sum]);\n        return sum;\n    }\n\npublic:\n    vector<int> findFrequentTreeSum(TreeNode *root) {\n        dfs(root);\n        vector<int> ans;\n        for (auto &[s, c]: cnt) {\n            if (c == maxCnt) {\n                ans.emplace_back(s);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n    int maxCnt = 0;\n\n    public int[] findFrequentTreeSum(TreeNode root) {\n        dfs(root);\n        List<Integer> list = new ArrayList<Integer>();\n        for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n            int s = entry.getKey(), c = entry.getValue();\n            if (c == maxCnt) {\n                list.add(s);\n            }\n        }\n        int[] ans = new int[list.size()];\n        for (int i = 0; i < list.size(); ++i) {\n            ans[i] = list.get(i);\n        }\n        return ans;\n    }\n\n    public int dfs(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        int sum = node.val + dfs(node.left) + dfs(node.right);\n        cnt.put(sum, cnt.getOrDefault(sum, 0) + 1);\n        maxCnt = Math.max(maxCnt, cnt.get(sum));\n        return sum;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    Dictionary<int, int> cnt = new Dictionary<int, int>();\n    int maxCnt = 0;\n\n    public int[] FindFrequentTreeSum(TreeNode root) {\n        DFS(root);\n        IList<int> ans = new List<int>();\n        foreach (KeyValuePair<int, int> pair in cnt) {\n            int s = pair.Key, c = pair.Value;\n            if (c == maxCnt) {\n                ans.Add(s);\n            }\n        }\n        return ans.ToArray();\n    }\n\n    public int DFS(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        int sum = node.val + DFS(node.left) + DFS(node.right);\n        if (!cnt.ContainsKey(sum)) {\n            cnt.Add(sum, 0);\n        }\n        maxCnt = Math.Max(maxCnt, ++cnt[sum]);\n        return sum;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc findFrequentTreeSum(root *TreeNode) (ans []int) {\n    cnt := map[int]int{}\n    maxCnt := 0\n    var dfs func(*TreeNode) int\n    dfs = func(node *TreeNode) int {\n        if node == nil {\n            return 0\n        }\n        sum := node.Val + dfs(node.Left) + dfs(node.Right)\n        cnt[sum]++\n        if cnt[sum] > maxCnt {\n            maxCnt = cnt[sum]\n        }\n        return sum\n    }\n    dfs(root)\n\n    for s, c := range cnt {\n        if c == maxCnt {\n            ans = append(ans, s)\n        }\n    }\n    return\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findFrequentTreeSum = function(root) {\n    const cnt = new Map();\n    let maxCnt = 0;\n\n    const dfs = (node) => {\n        if (!node) {\n            return 0;\n        }\n        const sum = node.val + dfs(node.left) + dfs(node.right);\n        cnt.set(sum, (cnt.get(sum) || 0) + 1);\n        maxCnt = Math.max(maxCnt, cnt.get(sum));\n        return sum;\n    }\n\n    dfs(root);\n    const list = [];\n    for (const [s, c] of cnt.entries()) {\n        if (c === maxCnt) {\n            list.push(s);\n        }\n    }\n    const ans = new Array(list.length);\n    for (let i = 0; i < list.length; ++i) {\n        ans[i] = list[i];\n    }\n    return ans;\n};\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} HashItem;\n\nint dfs(struct TreeNode *node, HashItem **cnt, int *maxCnt) {\n    if (node == NULL) {\n        return 0;\n    }\n    int sum = node->val + dfs(node->left, cnt, maxCnt) + dfs(node->right, cnt, maxCnt);\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*cnt, &sum, pEntry);\n    if (NULL == pEntry) {\n        pEntry = (HashItem *)malloc(sizeof(HashItem));\n        pEntry->key = sum;\n        pEntry->val = 1;\n        HASH_ADD_INT(*cnt, key, pEntry);\n    } else {\n        pEntry->val++;\n    }\n    *maxCnt = MAX(*maxCnt, pEntry->val);\n    return sum;\n}\n\nint* findFrequentTreeSum(struct TreeNode* root, int* returnSize) {\n    HashItem * cnt = NULL;\n    int maxCnt = 0;\n    dfs(root, &cnt, &maxCnt);\n    unsigned int n = HASH_COUNT(cnt);\n    int *ans = (int *)malloc(sizeof(int) * n);\n    int pos = 0;\n    for (HashItem *pEntry = cnt; pEntry; pEntry = pEntry->hh.next) {\n        if (pEntry->val == maxCnt) {\n            ans[pos++] = pEntry->key;\n        }\n    }\n    HashItem *curr, *tmp;\n    HASH_ITER(hh, cnt, curr, tmp) {\n        HASH_DEL(cnt, curr);  \n        free(curr);\n    }\n    *returnSize = pos;\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉树的结点个数。深度优先搜索的时间为 $O(n)$。\n\n- 空间复杂度：$O(n)$。哈希表和递归的栈空间均为 $O(n)$。"
}