{
	"titleSlug": "orderly-queue",
	"slug": "you-xu-dui-lie-by-leetcode-solution-p6gv",
	"url": "https://leetcode-cn.com/problems/orderly-queue/solution/you-xu-dui-lie-by-leetcode-solution-p6gv/",
	"content": "#### 方法一：分情况讨论\n\n计算字典序最小的字符串时，需要分别考虑 $k = 1$ 和 $k > 1$ 的两种情况。\n\n当 $k = 1$ 时，每次只能取 $s$ 的首个字符并将其移动到末尾，因此对于给定的字符串，可能的移动方法是唯一的，移动后的结果也是唯一的。对于长度为 $n$ 的字符串 $s$，经过 $0$ 次到 $n - 1$ 次移动之后分别得到 $n$ 个字符串，这 $n$ 个字符串中的字典序最小的字符串即为答案。\n\n当 $k > 1$ 时，一定可以经过移动将 $s$ 变成升序字符串，因此将字符串 $s$ 升序排序之后得到的字符串即为答案。理由如下。\n\n考虑 $k = 2$ 的情况。假设 $s$ 的所有字符按照升序排序依次是 $c_0, c_1, \\ldots, c_{n - 1}$。对于 $s$ 的任意排列，总是可以经过若干次移动将 $c_{n - 1}$ 变成首个字符。\n\n当 $c_{n - 1}$ 变成首个字符之后，可以将 $c_{n - 2}, c_{n - 1}$ 变成前两个字符：\n\n1. 每次将首个字符移动到末尾，直到 $c_{n - 2}$ 变成首个字符；\n\n2. 保持 $c_{n - 2}$ 位于首个字符，每次将 $c_{n - 2}$ 后面的字符移动到末尾，直到 $c_{n - 2}$ 后面的字符是 $c_{n - 1}$。\n\n使用同样的方法，对于 $1 \\le m < n$，如果 $c_{n - m}, c_{n - m + 1}, \\ldots, c_{n - 1}$ 位于前 $m$ 个字符，则可以经过若干次移动将 $c_{n - m - 1}, c_{n - m}, c_{n - m + 1}, \\ldots, c_{n - 1}$ 变成前 $m + 1$ 个字符：\n\n1. 每次将首个字符移动到末尾，直到 $c_{n - m - 1}$ 变成首个字符，此时 $c_{n - m}, c_{n - m + 1}, \\ldots, c_{n - 1}$ 为字符串中连续的 $m$ 个字符；\n\n2. 保持 $c_{n - m - 1}$ 位于首个字符，每次将 $c_{n - m - 1}$ 后面的字符移动到末尾，直到 $c_{n - m - 1}$ 后面的字符是 $c_{n - m}$，此时前 $m + 1$ 个字符是 $c_{n - m - 1}, c_{n - m}, c_{n - m + 1}, \\ldots, c_{n - 1}$。\n\n因此，当 $k = 2$ 时，一定可以经过移动将 $s$ 变成升序字符串。\n\n当 $k > 2$ 时，同样可以对字符串的前两个字符执行移动操作将 $s$ 变成升序字符串。\n\n```Python [sol1-Python3]\nclass Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n        if k == 1:\n            ans = s\n            for _ in range(len(s) - 1):\n                s = s[1:] + s[0]\n                ans = min(ans, s)\n            return ans\n        return ''.join(sorted(s))\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String orderlyQueue(String s, int k) {\n        if (k == 1) {\n            String smallest = s;\n            StringBuilder sb = new StringBuilder(s);\n            int n = s.length();\n            for (int i = 1; i < n; i++) {\n                char c = sb.charAt(0);\n                sb.deleteCharAt(0);\n                sb.append(c);\n                if (sb.toString().compareTo(smallest) < 0) {\n                    smallest = sb.toString();\n                }\n            }\n            return smallest;\n        } else {\n            char[] arr = s.toCharArray();\n            Arrays.sort(arr);\n            return new String(arr);\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string OrderlyQueue(string s, int k) {\n        if (k == 1) {\n            string smallest = s;\n            StringBuilder sb = new StringBuilder(s);\n            int n = s.Length;\n            for (int i = 1; i < n; i++) {\n                char c = sb[0];\n                sb.Remove(0, 1);\n                sb.Append(c);\n                if (sb.ToString().CompareTo(smallest) < 0) {\n                    smallest = sb.ToString();\n                }\n            }\n            return smallest;\n        } else {\n            char[] arr = s.ToCharArray();\n            Array.Sort(arr);\n            return new string(arr);\n        }\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string orderlyQueue(string s, int k) {\n        if (k == 1) {\n            string smallest = s;\n            int n = s.size();\n            for (int i = 1; i < n; i++) {\n                char c = s[0];\n                s = s.substr(1);\n                s.push_back(c);\n                if (s < smallest) {\n                    smallest = s;\n                }\n            }\n            return smallest;\n        } else {\n            sort(s.begin(), s.end());\n            return s;\n        }\n    }\n};\n```\n\n```C [sol1-C]\nstatic inline int cmp(const void *pa, const void *pb) {\n    return *(char *)pa - *(char *)pb;\n}\n\nchar * orderlyQueue(char * s, int k) {\n    int n = strlen(s);\n    if (k == 1) {\n        char *smallest = (char *)malloc(sizeof(char) * (n + 1));\n        strcpy(smallest, s);\n        for (int i = 1; i < n; i++) {\n            char c = s[0];\n            for (int j = 0; j < n - 1; j++) {\n                s[j] = s[j + 1];\n            }\n            s[n - 1] = c;\n            if (strcmp(s, smallest) < 0) {\n                strcpy(smallest, s);\n            }\n        }\n        return smallest;\n    } else {\n        qsort(s, n, sizeof(char), cmp);\n        return s;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc orderlyQueue(s string, k int) string {\n    if k == 1 {\n        ans := s\n        for i := 1; i < len(s); i++ {\n            s = s[1:] + s[:1]\n            if s < ans {\n                ans = s\n            }\n        }\n        return ans\n    }\n    t := []byte(s)\n    sort.Slice(t, func(i, j int) bool { return t[i] < t[j] })\n    return string(t)\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar orderlyQueue = function(s, k) {\n    if (k === 1) {\n        let ans = s;\n        for (let i = 0; i < s.length - 1; ++i) {\n            const n = s.length;\n            s = s.substring(1, n) + s[0];\n            ans = ans < s ? ans : s;\n        }\n        return ans;\n    }\n    return [...s].sort().join('');\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 是字符串 $s$ 的长度。当 $k = 1$ 时需要遍历 $n$ 个可能的字符串，每个字符串需要 $O(n)$ 的时间生成和判断是否字典序最小，时间复杂度是 $O(n^2)$；当 $k > 1$ 时需要对字符串排序，时间复杂度是 $O(n \\log n)$。最坏情况下时间复杂度是 $O(n^2)$。\n\n- 空间复杂度：$O(n)$ 或 $O(\\log n)$，其中 $n$ 是字符串 $s$ 的长度。空间复杂度取决于具体实现的语言。对于字符串不可变的语言，当 $k = 1$ 时生成每个字符串和当 $k > 1$ 时生成排序后的字符串都需要 $O(n)$ 的空间；对于字符串可变的语言，可以省略 $O(n)$ 的空间，只有当 $k > 1$ 时排序需要 $O(\\log n)$ 的空间。\n\n#### 结语\n\n上述做法在 $k = 1$ 时寻找字典序最小的字符串需要 $O(n^2)$ 的时间。如果使用最小表示法，则可以将时间复杂度降低到 $O(n)$。\n\n由于最小表示法超出了面试的范围，因此这里不具体讲解，感兴趣的读者可以参考[最小表示法](https://oi-wiki.org/string/minimal-string)。"
}