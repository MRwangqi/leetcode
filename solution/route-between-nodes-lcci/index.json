{
	"titleSlug": "route-between-nodes-lcci",
	"slug": "by-stormsunshine-v5xi",
	"url": "https://leetcode-cn.com/problems/route-between-nodes-lcci/solution/by-stormsunshine-v5xi/",
	"content": "# 解法一\r\n\r\n## 思路和算法\r\n\r\n使用广度优先搜索判断是否存在从顶点 $\\textit{start}$ 到顶点 $\\textit{target}$ 的路径，需要从顶点 $\\textit{start}$ 开始依次遍历每一层的顶点，判断可以到达顶点 $\\textit{target}$。\r\n\r\n由于题目中的图的表示方式是边数组，为了方便处理，需要首先将边数组转换成邻接顶点集合的形式，转换后可以在 $O(1)$ 时间获得一个顶点的全部相邻顶点，然后使用广度优先搜索遍历图。由于可能存在自环和平行边，因此需要使用集合存储邻接顶点，且只有与当前顶点不同的邻接顶点才能加入集合。\r\n\r\n广度优先搜索需要使用哈希表（或数组）记录每个顶点的访问状态，使用队列存储最近访问过的顶点。初始时将顶点 $\\textit{start}$ 设为已访问，并将其入队列。每次将一个顶点 $\\textit{vertex}$ 出队列，对于每个与 $\\textit{vertex}$ 相邻且未访问的顶点 $\\textit{next}$，将 $\\textit{next}$ 设为已访问，并将其入队列。当队列为空或访问到顶点 $\\textit{target}$ 时，遍历结束，将顶点 $\\textit{target}$ 的访问状态返回。\r\n\r\n## 代码\r\n\r\n```Java [sol1-Java]\r\nclass Solution {\r\n    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {\r\n        Set<Integer>[] adjacentArr = new Set[n];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new HashSet<Integer>();\r\n        }\r\n        for (int[] edge : graph) {\r\n            if (edge[0] != edge[1]) {\r\n                adjacentArr[edge[0]].add(edge[1]);\r\n            }\r\n        }\r\n        boolean[] visited = new boolean[n];\r\n        visited[start] = true;\r\n        Queue<Integer> queue = new ArrayDeque<Integer>();\r\n        queue.offer(start);\r\n        while (!queue.isEmpty() && !visited[target]) {\r\n            int vertex = queue.poll();\r\n            Set<Integer> adjacent = adjacentArr[vertex];\r\n            for (int next : adjacent) {\r\n                if (!visited[next]) {\r\n                    visited[next] = true;\r\n                    queue.offer(next);\r\n                }\r\n            }\r\n        }\r\n        return visited[target];\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol1-C#]\r\npublic class Solution {\r\n    public bool FindWhetherExistsPath(int n, int[][] graph, int start, int target) {\r\n        ISet<int>[] adjacentArr = new ISet<int>[n];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new HashSet<int>();\r\n        }\r\n        foreach (int[] edge in graph) {\r\n            if (edge[0] != edge[1]) {\r\n                adjacentArr[edge[0]].Add(edge[1]);\r\n            }\r\n        }\r\n        bool[] visited = new bool[n];\r\n        visited[start] = true;\r\n        Queue<int> queue = new Queue<int>();\r\n        queue.Enqueue(start);\r\n        while (queue.Count > 0 && !visited[target]) {\r\n            int vertex = queue.Dequeue();\r\n            ISet<int> adjacent = adjacentArr[vertex];\r\n            foreach (int next in adjacent) {\r\n                if (!visited[next]) {\r\n                    visited[next] = true;\r\n                    queue.Enqueue(next);\r\n                }\r\n            }\r\n        }\r\n        return visited[target];\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n + m)$，其中 $n$ 是图中的顶点数，$m$ 是图中的边数。广度优先搜索的时间复杂度由顶点数和边数决定。\r\n\r\n- 空间复杂度：$O(n + m)$，其中 $n$ 是图中的顶点数，$m$ 是图中的边数。空间复杂度主要取决于邻接顶点集合、记录每个顶点访问状态的数组和队列，邻接顶点集合需要 $O(m)$ 的空间，记录每个顶点访问状态的数组和队列需要 $O(n)$ 的空间。\r\n\r\n# 解法二\r\n\r\n## 思路和算法\r\n\r\n使用深度优先搜索判断是否存在从顶点 $\\textit{start}$ 到顶点 $\\textit{target}$ 的路径，需要从顶点 $\\textit{start}$ 开始依次遍历每一条路径，判断可以到达顶点 $\\textit{target}$。\r\n\r\n由于题目中的图的表示方式是边数组，为了方便处理，需要首先将边数组转换成邻接顶点集合的形式，转换后可以在 $O(1)$ 时间获得一个顶点的全部相邻顶点，然后使用深度优先搜索遍历图。由于可能存在自环和平行边，因此需要使用集合存储邻接顶点，且只有与当前顶点不同的邻接顶点才能加入集合。\r\n\r\n深度优先搜索需要使用哈希表（或数组）记录每个顶点的访问状态。从顶点 $\\textit{start}$ 开始遍历。每次访问一个顶点 $\\textit{vertex}$ 时，将该顶点设为已访问，对于每个与 $\\textit{vertex}$ 相邻且未访问的顶点 $\\textit{next}$，递归地访问 $\\textit{next}$。当没有更多顶点可以访问或访问到顶点 $\\textit{target}$ 时，遍历结束，将顶点 $\\textit{target}$ 的访问状态返回。\r\n\r\n## 代码\r\n\r\n```Java [sol2-Java]\r\nclass Solution {\r\n    Set<Integer>[] adjacentArr;\r\n    boolean[] visited;\r\n\r\n    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {\r\n        adjacentArr = new Set[n];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new HashSet<Integer>();\r\n        }\r\n        for (int[] edge : graph) {\r\n            if (edge[0] != edge[1]) {\r\n                adjacentArr[edge[0]].add(edge[1]);\r\n            }\r\n        }\r\n        visited = new boolean[n];\r\n        return dfs(start, target);\r\n    }\r\n\r\n    public boolean dfs(int vertex, int target) {\r\n        visited[vertex] = true;\r\n        if (!visited[target]) {\r\n            Set<Integer> adjacent = adjacentArr[vertex];\r\n            for (int next : adjacent) {\r\n                if (!visited[next] && dfs(next, target)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return visited[target];\r\n    }\r\n}\r\n```\r\n\r\n```C# [sol2-C#]\r\npublic class Solution {\r\n    ISet<int>[] adjacentArr;\r\n    bool[] visited;\r\n\r\n    public bool FindWhetherExistsPath(int n, int[][] graph, int start, int target) {\r\n        adjacentArr = new ISet<int>[n];\r\n        for (int i = 0; i < n; i++) {\r\n            adjacentArr[i] = new HashSet<int>();\r\n        }\r\n        foreach (int[] edge in graph) {\r\n            if (edge[0] != edge[1]) {\r\n                adjacentArr[edge[0]].Add(edge[1]);\r\n            }\r\n        }\r\n        visited = new bool[n];\r\n        return DFS(start, target);\r\n    }\r\n\r\n    public bool DFS(int vertex, int target) {\r\n        visited[vertex] = true;\r\n        if (!visited[target]) {\r\n            ISet<int> adjacent = adjacentArr[vertex];\r\n            foreach (int next in adjacent) {\r\n                if (!visited[next] && DFS(next, target)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return visited[target];\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：$O(n + m)$，其中 $n$ 是图中的顶点数，$m$ 是图中的边数。深度优先搜索的时间复杂度由顶点数和边数决定。\r\n\r\n- 空间复杂度：$O(n + m)$，其中 $n$ 是图中的顶点数，$m$ 是图中的边数。空间复杂度主要取决于邻接顶点集合、记录每个顶点访问状态的数组和递归调用栈，邻接顶点集合需要 $O(m)$ 的空间，记录每个顶点访问状态的数组和递归调用栈需要 $O(n)$ 的空间。"
}