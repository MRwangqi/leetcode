{
	"titleSlug": "falling-squares",
	"slug": "diao-luo-de-fang-kuai-by-leetcode-soluti-2dmw",
	"url": "https://leetcode-cn.com/problems/falling-squares/solution/diao-luo-de-fang-kuai-by-leetcode-soluti-2dmw/",
	"content": "#### 方法一：暴力枚举\n\n我们用数组 $\\textit{heights}$ 记录各个方块掉落后的高度。对于第 $i$ 个掉落的方块，如果它的底部区间与第 $j$ 个掉落的方块有重叠，那么它掉落后的高度至少为 $\\textit{heights}[j] + \\textit{size}_i$，其中 $j \\lt i$ 且 $\\textit{size}_i$ 为第 $i$ 个掉落的方块的边长。因此对于第 $i$ 个掉落的方块，$\\textit{heights}[i]$ 的初始值为 $\\textit{size}_i$，我们暴力枚举所有之前已经掉落的方块，如果两者的底部区间有重叠，那么更新 $\\textit{heights}[i] = \\max(\\textit{heights}[i], \\textit{heights}[j] + \\textit{size}_i)$。\n\n因为题目要求返回一个所有已经落稳的方块的最大堆叠高度列表，我们从 $i=1$ 开始，更新 $\\textit{heights}[i] = \\max(\\textit{heights}[i], \\textit{heights}[i - 1])$，然后返回 $\\textit{heights}$ 即可。\n\n```Python [sol1-Python3]\nclass Solution:\n    def fallingSquares(self, positions: List[List[int]]) -> List[int]:\n        n = len(positions)\n        heights = [0] * n\n        for i, (left1, side1) in enumerate(positions):\n            right1 = left1 + side1 - 1\n            heights[i] = side1\n            for j in range(i):\n                left2, right2 = positions[j][0], positions[j][0] + positions[j][1] - 1\n                if right1 >= left2 and right2 >= left1:\n                    heights[i] = max(heights[i], heights[j] + side1)\n        for i in range(1, n):\n            heights[i] = max(heights[i], heights[i - 1])\n        return heights\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> fallingSquares(vector<vector<int>>& positions) {\n        int n = positions.size();\n        vector<int> heights(n);\n        for (int i = 0; i < n; i++) {\n            int left1 = positions[i][0], right1 = positions[i][0] + positions[i][1] - 1;\n            heights[i] = positions[i][1];\n            for (int j = 0; j < i; j++) {\n                int left2 = positions[j][0], right2 = positions[j][0] + positions[j][1] - 1;\n                if (right1 >= left2 && right2 >= left1) {\n                    heights[i] = max(heights[i], heights[j] + positions[i][1]);\n                }\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            heights[i] = max(heights[i], heights[i - 1]);\n        }\n        return heights;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> fallingSquares(int[][] positions) {\n        int n = positions.length;\n        List<Integer> heights = new ArrayList<Integer>();\n        for (int i = 0; i < n; i++) {\n            int left1 = positions[i][0], right1 = positions[i][0] + positions[i][1] - 1;\n            int height = positions[i][1];\n            for (int j = 0; j < i; j++) {\n                int left2 = positions[j][0], right2 = positions[j][0] + positions[j][1] - 1;\n                if (right1 >= left2 && right2 >= left1) {\n                    height = Math.max(height, heights.get(j) + positions[i][1]);\n                }\n            }\n            heights.add(height);\n        }\n        for (int i = 1; i < n; i++) {\n            heights.set(i, Math.max(heights.get(i), heights.get(i - 1)));\n        }\n        return heights;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> FallingSquares(int[][] positions) {\n        int n = positions.Length;\n        IList<int> heights = new List<int>();\n        for (int i = 0; i < n; i++) {\n            int left1 = positions[i][0], right1 = positions[i][0] + positions[i][1] - 1;\n            heights.Add(positions[i][1]);\n            for (int j = 0; j < i; j++) {\n                int left2 = positions[j][0], right2 = positions[j][0] + positions[j][1] - 1;\n                if (right1 >= left2 && right2 >= left1) {\n                    heights[i] = Math.Max(heights[i], heights[j] + positions[i][1]);\n                }\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            heights[i] = Math.Max(heights[i], heights[i - 1]);\n        }\n        return heights;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint* fallingSquares(int** positions, int positionsSize, int* positionsColSize, int* returnSize) {\n    int *heights = (int *)malloc(sizeof(int) * positionsSize);\n    for (int i = 0; i < positionsSize; i++) {\n        int left1 = positions[i][0], right1 = positions[i][0] + positions[i][1] - 1;\n        heights[i] = positions[i][1];\n        for (int j = 0; j < i; j++) {\n            int left2 = positions[j][0], right2 = positions[j][0] + positions[j][1] - 1;\n            if (right1 >= left2 && right2 >= left1) {\n                heights[i] = MAX(heights[i], heights[j] + positions[i][1]);\n            }\n        }\n    }\n    for (int i = 1; i < positionsSize; i++) {\n        heights[i] = MAX(heights[i], heights[i - 1]);\n    }\n    *returnSize = positionsSize;\n    return heights;\n}\n```\n\n```go [sol1-Golang]\nfunc fallingSquares(positions [][]int) []int {\n    n := len(positions)\n    heights := make([]int, n)\n    for i, p := range positions {\n        left1, right1 := p[0], p[0]+p[1]-1\n        heights[i] = p[1]\n        for j, q := range positions[:i] {\n            left2, right2 := q[0], q[0]+q[1]-1\n            if right1 >= left2 && right2 >= left1 {\n                heights[i] = max(heights[i], heights[j]+p[1])\n            }\n        }\n    }\n    for i := 1; i < n; i++ {\n        heights[i] = max(heights[i], heights[i-1])\n    }\n    return heights\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar fallingSquares = function(positions) {\n    const n = positions.length;\n    const heights = [];\n    for (let i = 0; i < n; i++) {\n        let left1 = positions[i][0], right1 = positions[i][0] + positions[i][1] - 1;\n        let height = positions[i][1];\n        for (let j = 0; j < i; j++) {\n            let left2 = positions[j][0], right2 = positions[j][0] + positions[j][1] - 1;\n            if (right1 >= left2 && right2 >= left1) {\n                height = Math.max(height, heights[j] + positions[i][1]);\n            }\n        }\n        heights.push(height);\n    }\n    for (let i = 1; i < n; i++) {\n        heights.splice(i, 1, Math.max(heights[i], heights[i - 1]));\n    }\n    return heights;\n};\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n^2)$，其中 $n$ 是数组 $\\textit{positions}$ 的长度。\n\n+ 空间复杂度：$O(1)$。返回值不计入空间复杂度。\n\n#### 方法二：有序集合\n\n已经落稳的方块的堆叠高度情况可以使用一个有序集合 $\\textit{heightMap}$ 进行记录，$\\textit{heightMap}[x_1]$ 表示从 $x_1$ 开始（包括 $x_1$）直到遇到下一个 $x_2$（不包括 $x_2$）的所有数轴上的点的堆叠高度为 $\\textit{heightMap}[x_1]$，其中 $x_2 > x_1$。通俗上来说就是用 $\\textit{heightMap}$ 记录每一个相对于前一个点而言，堆叠高度发生变化的点。初始时，令 $\\textit{heightMap}[0] = 0$，表示从 $0$ 开始的所有点的堆叠高度都为 $0$。\n\n对于第 $i$ 个掉落的方块，记它底部的左端点为 $\\textit{left}$，右端点为 $\\textit{right}$。我们在有序集合中查找该区间 $[\\textit{left}, \\textit{right}]$ 内所有点的堆叠高度，然后更新该方块对应的堆叠高度 $\\textit{height}$。在第 $i$ 个方块掉落后，区间 $[\\textit{left}, \\textit{right}]$ 内的所有点的堆叠高度都是 $\\textit{height}$，因此我们将有序集合里对应区间 $[\\textit{left}, \\textit{right}]$ 内的点全部删除。该掉落的方块带来的堆叠高度变化主要在两个点，即 $\\textit{left}$ 和 $\\textit{right} + 1$，更新对应的变化即可。\n\n前 $i$ 个掉落的方块的最大堆叠高度等于前 $i - 1$ 个掉落的方块的最大堆叠高度与第 $i$ 个方块的堆叠高度的最大值。\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> fallingSquares(vector<vector<int>>& positions) {\n        int n = positions.size();\n        vector<int> ret(n);\n        map<int, int> heightMap;\n        heightMap[0] = 0; // 初始时从 0 开始的所有点的堆叠高度都是 0\n        for (int i = 0; i < n; i++) {\n            int size = positions[i][1];\n            int left = positions[i][0], right = positions[i][0] + positions[i][1] - 1;\n            auto lp = heightMap.upper_bound(left), rp = heightMap.upper_bound(right);\n            int rHeight = prev(rp)->second; // 记录 right + 1 对应的堆叠高度（如果 right + 1 不在 heightMap 中）\n\n            // 更新第 i 个掉落的方块的堆叠高度\n            int height = 0;\n            for (auto p = prev(lp); p != rp; p++) {\n                height = max(height, p->second + size);\n            }\n\n            // 清除 heightMap 中位于 (left, right] 内的点\n            heightMap.erase(lp, rp);\n\n            heightMap[left] = height; // 更新 left 的变化\n            if (rp == heightMap.end() || rp->first != right + 1) { // 如果 right + 1 不在 heightMap 中，更新 right + 1 的变化\n                heightMap[right + 1] = rHeight;\n            }\n            ret[i] = i > 0 ? max(ret[i - 1], height) : height;\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public List<Integer> fallingSquares(int[][] positions) {\n        int n = positions.length;\n        List<Integer> ret = new ArrayList<Integer>();\n        TreeMap<Integer, Integer> heightMap = new TreeMap<Integer, Integer>();\n        heightMap.put(0, 0); // 初始时从 0 开始的所有点的堆叠高度都是 0\n        for (int i = 0; i < n; i++) {\n            int size = positions[i][1];\n            int left = positions[i][0], right = positions[i][0] + positions[i][1] - 1;\n            Integer lp = heightMap.higherKey(left), rp = heightMap.higherKey(right);\n            Integer prevRightKey = rp != null ? heightMap.lowerKey(rp) : heightMap.lastKey();\n            int rHeight = prevRightKey != null ? heightMap.get(prevRightKey) : 0; // 记录 right + 1 对应的堆叠高度（如果 right + 1 不在 heightMap 中）\n\n            // 更新第 i 个掉落的方块的堆叠高度\n            int height = 0;\n            Integer prevLeftKey = lp != null ? heightMap.lowerKey(lp) : heightMap.lastKey();\n            Map<Integer, Integer> tail = prevLeftKey != null ? heightMap.tailMap(prevLeftKey) : heightMap;\n            for (Map.Entry<Integer, Integer> entry : tail.entrySet()) {\n                if (entry.getKey() == rp) {\n                    break;\n                }\n                height = Math.max(height, entry.getValue() + size);\n            }\n\n            // 清除 heightMap 中位于 (left, right] 内的点\n            Set<Integer> keySet = new TreeSet<Integer>(tail.keySet());\n            for (Integer tmp : keySet) {\n                if (lp == null || tmp < lp) {\n                    continue;\n                }\n                if (rp != null && tmp >= rp) {\n                    break;\n                }\n                heightMap.remove(tmp);\n            }\n\n            heightMap.put(left, height); // 更新 left 的变化\n            if (rp == null || rp != right + 1) { // 如果 right + 1 不在 heightMap 中，更新 right + 1 的变化\n                heightMap.put(right + 1, rHeight);\n            }\n            ret.add(i > 0 ? Math.max(ret.get(i - 1), height) : height);\n        }\n        return ret;\n    }\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n \\log n)$，其中 $n$ 是数组 $\\textit{positions}$ 的长度。有序集合 $\\textit{heightMap}$ 最多插入 $2n + 1$ 个元素，因此整个循环最多执行删除操作 $2n + 1$ 次，而每次循环里的查询操作只比删除操作多一次，因此总的查询操作最多为 $3n + 1$ 次；插入操作、删除操作、迭代器递增操作以及二分查找操作都需要 $O(\\log n)$，因此总共需要 $O(n \\log n)$。\n\n+ 空间复杂度：$O(n)$。有序集合最多保存 $2n + 1$ 个元素。"
}