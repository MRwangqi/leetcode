{
	"titleSlug": "consecutive-characters",
	"slug": "lian-xu-zi-fu-by-leetcode-solution-lctm",
	"url": "https://leetcode-cn.com/problems/consecutive-characters/solution/lian-xu-zi-fu-by-leetcode-solution-lctm/",
	"content": "#### 方法一：一次遍历\n\n题目中的「只包含一种字符的最长非空子字符串的长度」，即为某个字符连续出现次数的最大值。据此可以设计如下算法来求解：\n\n初始化当前字符连续出现次数 $\\textit{cnt}$ 为 $1$。\n\n从 $s[1]$ 开始，向后遍历字符串，如果 $s[i]=s[i-1]$，则将 $\\textit{cnt}$ 加一，否则将 $\\textit{cnt}$ 重置为 $1$。\n\n维护上述过程中 $\\textit{cnt}$ 的最大值，即为答案。\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxPower(self, s: str) -> int:\n        ans, cnt = 1, 1\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                cnt += 1\n                ans = max(ans, cnt)\n            else:\n                cnt = 1\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxPower(string s) {\n        int ans = 1, cnt = 1;\n        for (int i = 1; i < s.length(); ++i) {\n            if (s[i] == s[i - 1]) {\n                ++cnt;\n                ans = max(ans, cnt);\n            } else {\n                cnt = 1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maxPower(String s) {\n        int ans = 1, cnt = 1;\n        for (int i = 1; i < s.length(); ++i) {\n            if (s.charAt(i) == s.charAt(i - 1)) {\n                ++cnt;\n                ans = Math.max(ans, cnt);\n            } else {\n                cnt = 1;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MaxPower(string s) {\n        int ans = 1, cnt = 1;\n        for (int i = 1; i < s.Length; ++i) {\n            if (s[i] == s[i - 1]) {\n                ++cnt;\n                ans = Math.Max(ans, cnt);\n            } else {\n                cnt = 1;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc maxPower(s string) int {\n    ans, cnt := 1, 1\n    for i := 1; i < len(s); i++ {\n        if s[i] == s[i-1] {\n            cnt++\n            if cnt > ans {\n                ans = cnt\n            }\n        } else {\n            cnt = 1\n        }\n    }\n    return ans\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maxPower = function(s) {\n    let ans = 1, cnt = 1;\n    for (let i = 1; i < s.length; ++i) {\n        if (s[i] == s[i - 1]) {\n            ++cnt;\n            ans = Math.max(ans, cnt);\n        } else {\n            cnt = 1;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。遍历一次 $s$ 的时间复杂度为 $O(n)$。\n\n- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。"
}