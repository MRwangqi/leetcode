{
	"titleSlug": "rank-transform-of-an-array",
	"slug": "shu-zu-xu-hao-zhuan-huan-by-leetcode-sol-8zlu",
	"url": "https://leetcode-cn.com/problems/rank-transform-of-an-array/solution/shu-zu-xu-hao-zhuan-huan-by-leetcode-sol-8zlu/",
	"content": "#### 方法一：排序 + 哈希表\n\n**思路** \n\n首先用一个数组保存排序完的原数组，然后用一个哈希表保存各元素的序号，最后将原属组的元素替换为序号后返回。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\n        ranks = {v: i for i, v in enumerate(sorted(set(arr)), 1)}\n        return [ranks[v] for v in arr]\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] arrayRankTransform(int[] arr) {\n        int[] sortedArr = new int[arr.length];\n        System.arraycopy(arr, 0, sortedArr, 0, arr.length);\n        Arrays.sort(sortedArr);\n        Map<Integer, Integer> ranks = new HashMap<Integer, Integer>();\n        int[] ans = new int[arr.length];\n        for (int a : sortedArr) {\n            if (!ranks.containsKey(a)) {\n                ranks.put(a, ranks.size() + 1);\n            }\n        }\n        for (int i = 0; i < arr.length; i++) {\n            ans[i] = ranks.get(arr[i]);\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] ArrayRankTransform(int[] arr) {\n        int[] sortedArr = new int[arr.Length];\n        Array.Copy(arr, 0, sortedArr, 0, arr.Length);\n        Array.Sort(sortedArr);\n        Dictionary<int, int> ranks = new Dictionary<int, int>();\n        int[] ans = new int[arr.Length];\n        foreach (int a in sortedArr) {\n            ranks.TryAdd(a, ranks.Count + 1);\n        }\n        for (int i = 0; i < arr.Length; i++) {\n            ans[i] = ranks[arr[i]];\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        vector<int> sortedArr = arr;\n        sort(sortedArr.begin(), sortedArr.end());\n        unordered_map<int, int> ranks;\n        vector<int> ans(arr.size());\n        for (auto &a : sortedArr) {\n            if (!ranks.count(a)) {\n                ranks[a] = ranks.size() + 1;\n            }\n        }\n        for (int i = 0; i < arr.size(); i++) {\n            ans[i] = ranks[arr[i]];\n        }\n        return ans;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} HashItem;\n\nstatic inline int cmp(const void *pa, const void *pb) {\n    return *(int *)pa - *(int *)pb;\n}\n\nint* arrayRankTransform(int* arr, int arrSize, int* returnSize) {\n    int *sortedArr = (int *)malloc(sizeof(int) * arrSize);\n    int *ans = (int *)malloc(sizeof(int) * arrSize);\n    memcpy(sortedArr, arr, sizeof(int) * arrSize);\n    qsort(sortedArr, arrSize, sizeof(int), cmp);\n    HashItem *ranks = NULL;\n    for (int i = 0; i < arrSize; i++) {\n        HashItem *pEntry = NULL;\n        HASH_FIND_INT(ranks, &sortedArr[i], pEntry);\n        if (pEntry == NULL) {\n            pEntry = (HashItem *)malloc(sizeof(HashItem));\n            pEntry->key = sortedArr[i];\n            pEntry->val = HASH_COUNT(ranks) + 1;\n            HASH_ADD_INT(ranks, key, pEntry);\n        }\n    }\n    for (int i = 0; i < arrSize; i++) {\n        HashItem *pEntry = NULL;\n        HASH_FIND_INT(ranks, &arr[i], pEntry);\n        ans[i] = pEntry->val;\n    }\n    *returnSize = arrSize;\n    HashItem *cur, *tmp;\n    HASH_ITER(hh, ranks, cur, tmp) {\n        HASH_DEL(ranks, cur);  \n        free(cur);             \n    }\n    free(sortedArr);\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar arrayRankTransform = function(arr) {\n    const sortedArr = new Array(arr.length).fill(0);\n    sortedArr.splice(0, arr.length, ...arr);\n    sortedArr.sort((a, b) => a - b);\n    const ranks = new Map();\n    const ans = new Array(arr.length).fill(0);\n    for (const a of sortedArr) {\n        if (!ranks.has(a)) {\n            ranks.set(a, ranks.size + 1);\n        }\n    }\n    for (let i = 0; i < arr.length; i++) {\n        ans[i] = ranks.get(arr[i]);\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc arrayRankTransform(arr []int) []int {\n    a := append([]int{}, arr...)\n    sort.Ints(a)\n    ranks := map[int]int{}\n    for _, v := range a {\n        if _, ok := ranks[v]; !ok {\n            ranks[v] = len(ranks) + 1\n        }\n    }\n    for i, v := range arr {\n        arr[i] = ranks[v]\n    }\n    return arr\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times \\log{n})$，其中 $n$ 是输入数组 $\\textit{arr}$ 的长度，排序消耗 $O(n \\times \\log{n})$ 时间。\n\n- 空间复杂度：$O(n)$。有序数组和哈希表各消耗 $O(n)$ 空间。"
}