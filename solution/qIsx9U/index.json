{
	"titleSlug": "qIsx9U",
	"slug": "hua-dong-chuang-kou-de-ping-jun-zhi-by-l-0rxf",
	"url": "https://leetcode-cn.com/problems/qIsx9U/solution/hua-dong-chuang-kou-de-ping-jun-zhi-by-l-0rxf/",
	"content": "#### 方法一：队列\n\n这道题要求根据给定的数据流计算滑动窗口中所有数字的平均值，滑动窗口的大小为给定的参数 $\\textit{size}$。当数据流中的数字个数不超过滑动窗口的大小时，计算数据流中的所有数字的平均值；当数据流中的数字个数超过滑动窗口的大小时，只计算滑动窗口中的数字的平均值，数据流中更早的数字被移出滑动窗口。\n\n由于数字进入滑动窗口和移出滑动窗口的规则符合先进先出，因此可以使用队列存储滑动窗口中的数字，同时维护滑动窗口的大小以及滑动窗口的数字之和。\n\n初始时，队列为空，滑动窗口的大小设为给定的参数 $\\textit{size}$，滑动窗口的数字之和为 $0$。\n\n每次调用 $\\texttt{next}$ 时，需要将 $\\textit{val}$ 添加到滑动窗口中，同时确保滑动窗口中的数字个数不超过 $\\textit{size}$，如果数字个数超过 $\\textit{size}$ 则需要将多余的数字移除，在添加和移除数字的同时需要更新滑动窗口的数字之和。由于每次调用只会将一个数字添加到滑动窗口中，因此每次调用最多只需要将一个多余的数字移除。具体操作如下。\n\n1. 如果队列中的数字个数等于滑动窗口的大小，则移除队首的数字，将移除的数字从滑动窗口的数字之和中减去。如果队列中的数字个数小于滑动窗口的大小，则不移除队首的数字。\n\n2. 将 $\\textit{val}$ 添加到队列中，并加到滑动窗口的数字之和中。\n\n3. 计算滑动窗口的数字之和与队列中的数字个数之商，即为滑动窗口中所有数字的平均值。\n\n```Python [sol1-Python3]\nclass MovingAverage:\n    def __init__(self, size: int):\n        self.size = size\n        self.sum = 0\n        self.q = deque()\n\n    def next(self, val: int) -> float:\n        if len(self.q) == self.size:\n            self.sum -= self.q.popleft()\n        self.sum += val\n        self.q.append(val)\n        return self.sum / len(self.q)\n```\n\n```Java [sol1-Java]\nclass MovingAverage {\n    Queue<Integer> queue;\n    int size;\n    double sum;\n\n    public MovingAverage(int size) {\n        queue = new ArrayDeque<Integer>();\n        this.size = size;\n        sum = 0;\n    }\n\n    public double next(int val) {\n        if (queue.size() == size) {\n            sum -= queue.poll();\n        }\n        queue.offer(val);\n        sum += val;\n        return sum / queue.size();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class MovingAverage {\n    Queue<int> queue;\n    int size;\n    double sum;\n\n    public MovingAverage(int size) {\n        queue = new Queue<int>();\n        this.size = size;\n        sum = 0;\n    }\n    \n    public double Next(int val) {\n        if (queue.Count == size) {\n            sum -= queue.Dequeue();\n        }\n        queue.Enqueue(val);\n        sum += val;\n        return sum / queue.Count;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass MovingAverage {\npublic:\n    MovingAverage(int size) {\n        this->size = size;\n        this->sum = 0.0;\n    }\n    \n    double next(int val) {\n        if (qu.size() == size) {\n            sum -= qu.front();\n            qu.pop();\n        }\n        qu.emplace(val);\n        sum += val;\n        return sum / qu.size();\n    }\nprivate:\n    int size;\n    double sum;\n    queue<int> qu;\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int size;\n    double sum;\n    int *queue;\n    int front;\n    int rear;\n} MovingAverage;\n\n\nMovingAverage* movingAverageCreate(int size) {\n    MovingAverage *obj = (MovingAverage *)malloc(sizeof(MovingAverage));\n    obj->size = size;\n    obj->sum = 0;\n    obj->queue = (int *)malloc(sizeof(int) * (size + 1));\n    obj->front = 0;\n    obj->rear = 0;\n    return obj;\n}\n\ndouble movingAverageNext(MovingAverage* obj, int val) {\n    int size = (obj->rear - obj->front + obj->size + 1) % (obj->size + 1);\n    if (size == obj->size) {\n        obj->sum -= obj->queue[obj->front];\n        obj->front = (obj->front + 1) % (obj->size + 1);\n        size--;\n    }\n    obj->queue[obj->rear] = val;\n    obj->rear = (obj->rear + 1) % (obj->size + 1);\n    obj->sum += val;\n    size++;\n    return obj->sum / size;\n}\n\nvoid movingAverageFree(MovingAverage* obj) {\n    free(obj->queue);\n    free(obj);\n}\n```\n\n```go [sol1-Golang]\ntype MovingAverage struct {\n    size, sum int\n    q         []int\n}\n\nfunc Constructor(size int) MovingAverage {\n    return MovingAverage{size: size}\n}\n\nfunc (m *MovingAverage) Next(val int) float64 {\n    if len(m.q) == m.size {\n        m.sum -= m.q[0]\n        m.q = m.q[1:]\n    }\n    m.sum += val\n    m.q = append(m.q, val)\n    return float64(m.sum) / float64(len(m.q))\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar MovingAverage = function(size) {\n    this.queue = [];\n    this.size = size;\n    this.sum = 0;\n};\n\nMovingAverage.prototype.next = function(val) {\n    if (this.queue.length === this.size) {\n        this.sum -= this.queue.shift();\n    }\n    this.queue.push(val);\n    this.sum += val;\n    return this.sum / this.queue.length;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：初始化和每次调用 $\\texttt{next}$ 的时间复杂度都是 $O(1)$。\n\n- 空间复杂度：$O(\\textit{size})$，其中 $\\textit{size}$ 是滑动窗口的大小。空间复杂度主要取决于队列，队列中的数字个数不超过 $\\textit{size}$。"
}