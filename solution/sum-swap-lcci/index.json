{
	"titleSlug": "sum-swap-lcci",
	"slug": "zi-ji-shi-xian-hash-by-confident-eulerxx-92qr",
	"url": "https://leetcode-cn.com/problems/sum-swap-lcci/solution/zi-ji-shi-xian-hash-by-confident-eulerxx-92qr/",
	"content": "### 解题思路\n这道题实际是一道数学题目，通过各种优化得到如下结果：\n![1659717842687.jpg](https://pic.leetcode-cn.com/1659717854-UOKSaO-1659717842687.jpg)\n\n\n**定义：**\nsum1是array1中所有数之和，sum2是array2中所有数之和，set是一个hash表记录了array2中的所有数字。\nnum1是array1中的数字，num2是array2中的数字，按照题目操作后能满足结果要求。\n\n**获取关系式**：\n如果array1和array2交换数字后2边的数字之和相等，则有下面的关系：\nsum1-num1+num2=sum2-num2+num1\n可以得到关系式：num2=(sum2-sum1)/2+num1; 要求sum2-sum1是一个偶数，否则一定不存在结果。\n\n**代码优化**\n默认我只能优化到3ms左右，后续无法优化了，最终考虑自己实现一个Set，减少Set的计算次数提升性能，下面就是具体的代码实现。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] findSwapValues(int[] array1, int[] array2) {\n\n        int sum1 = 0;\n        for (int num : array1) {\n            sum1 += num;\n        }\n        int sum2 = 0;\n        MyHashSet set = new MyHashSet();\n        for (int num : array2) {\n            sum2 += num;\n            set.add(num);\n        }\n        if ((sum2 - sum1) % 2 != 0) {\n            return new int[]{};\n        }\n        int v = (sum2 - sum1) / 2;\n\n        for (int num1 : array1) {\n            int x = v + num1;\n            if (set.contains(x)) {\n                return new int[]{num1, x};\n            }\n        }\n        return new int[]{};\n    }\n\n\n    class MyHashSet {\n        List<Integer>[] array = new List[100002];\n\n        void add(int value) {\n            int hashcode = hashcode(value);\n            if (array[hashcode] == null) {\n                array[hashcode] = new ArrayList<>();\n            }\n            array[hashcode].add(value);\n        }\n\n        boolean contains(int value) {\n            List<Integer> set = array[hashcode(value)];\n            return (set != null && set.contains(value));\n        }\n\n        int hashcode(int value) {\n            return value & 100001;\n        }\n    }\n}\n```\n\n"
}