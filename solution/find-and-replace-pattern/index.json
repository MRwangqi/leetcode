{
	"titleSlug": "find-and-replace-pattern",
	"slug": "cha-zhao-he-ti-huan-mo-shi-by-leetcode-s-fyyg",
	"url": "https://leetcode-cn.com/problems/find-and-replace-pattern/solution/cha-zhao-he-ti-huan-mo-shi-by-leetcode-s-fyyg/",
	"content": "#### 方法一：构造双射\n\n我们可以逐个判断 $\\textit{words}$ 中的每个单词 $\\textit{word}$ 是否与 $\\textit{pattern}$ 匹配。\n\n根据题意，我们需要构造从字母到字母的双射，即 $\\textit{word}$ 的每个字母需要映射到 $\\textit{pattern}$ 的对应字母，并且 $\\textit{pattern}$ 的每个字母也需要映射到 $\\textit{word}$ 的对应字母。\n\n我们可以编写一个函数 $\\text{match}(\\textit{word},\\textit{pattern})$，仅当 $\\textit{word}$ 中相同字母映射到 $\\textit{pattern}$ 中的相同字母时返回 $\\texttt{true}$。我们可以在遍历这两个字符串的同时，用一个哈希表记录 $\\textit{word}$ 的每个字母 $x$ 需要映射到 $\\textit{pattern}$ 的哪个字母上，如果 $x$ 已有映射，则需要检查对应字母是否相同。\n\n如果 $\\text{match}(\\textit{word},\\textit{pattern})$ 和 $\\text{match}(\\textit{pattern},\\textit{word})$ 均为 $\\texttt{true}$，则表示 $\\textit{word}$ 与 $\\textit{pattern}$ 匹配。\n\n```Python [sol1-Python3]\nclass Solution:\n    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:\n        def match(word: str, pattern: str) -> bool:\n            mp = {}\n            for x, y in zip(word, pattern):\n                if x not in mp:\n                    mp[x] = y\n                elif mp[x] != y:  # word 中的同一字母必须映射到 pattern 中的同一字母上\n                    return False\n            return True\n        return [word for word in words if match(word, pattern) and match(pattern, word)]\n```\n\n```C++ [sol1-C++]\nclass Solution {\n    bool match(string &word, string &pattern) {\n        unordered_map<char, char> mp;\n        for (int i = 0; i < word.length(); ++i) {\n            char x = word[i], y = pattern[i];\n            if (!mp.count(x)) {\n                mp[x] = y;\n            } else if (mp[x] != y) { // word 中的同一字母必须映射到 pattern 中的同一字母上\n                return false;\n            }\n        }\n        return true;\n    }\n\npublic:\n    vector<string> findAndReplacePattern(vector<string> &words, string &pattern) {\n        vector<string> ans;\n        for (auto &word: words) {\n            if (match(word, pattern) && match(pattern, word)) {\n                ans.emplace_back(word);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<String> findAndReplacePattern(String[] words, String pattern) {\n        List<String> ans = new ArrayList<String>();\n        for (String word : words) {\n            if (match(word, pattern) && match(pattern, word)) {\n                ans.add(word);\n            }\n        }\n        return ans;\n    }\n\n    public boolean match(String word, String pattern) {\n        Map<Character, Character> map = new HashMap<Character, Character>();\n        for (int i = 0; i < word.length(); ++i) {\n            char x = word.charAt(i), y = pattern.charAt(i);\n            if (!map.containsKey(x)) {\n                map.put(x, y);\n            } else if (map.get(x) != y) { // word 中的同一字母必须映射到 pattern 中的同一字母上\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<string> FindAndReplacePattern(string[] words, string pattern) {\n        IList<string> ans = new List<string>();\n        foreach (string word in words) {\n            if (Match(word, pattern) && Match(pattern, word)) {\n                ans.Add(word);\n            }\n        }\n        return ans;\n    }\n\n    public bool Match(String word, String pattern) {\n        Dictionary<char, char> dic = new Dictionary<char, char>();\n        for (int i = 0; i < word.Length; ++i) {\n            char x = word[i], y = pattern[i];\n            if (!dic.ContainsKey(x)) {\n                dic.Add(x, y);\n            } else if (dic[x] != y) { // word 中的同一字母必须映射到 pattern 中的同一字母上\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```go [sol1-Golang]\nfunc match(word, pattern string) bool {\n    mp := map[rune]byte{}\n    for i, x := range word {\n        y := pattern[i]\n        if mp[x] == 0 {\n            mp[x] = y\n        } else if mp[x] != y { // word 中的同一字母必须映射到 pattern 中的同一字母上\n            return false\n        }\n    }\n    return true\n}\n\nfunc findAndReplacePattern(words []string, pattern string) (ans []string) {\n    for _, word := range words {\n        if match(word, pattern) && match(pattern, word) {\n            ans = append(ans, word)\n        }\n    }\n    return\n}\n```\n\n```C [sol1-C]\nbool match(const char* word, const char* pattern) {\n    char mp[256];\n    memset(mp, 0, sizeof(mp));\n    int len = strlen(word);\n    for (int i = 0; i < len; ++i) {\n        char x = word[i], y = pattern[i];\n        if (!mp[x]) {\n            mp[x] = y;\n        } else if (mp[x] != y) { // word 中的同一字母必须映射到 pattern 中的同一字母上\n            return false;\n        }\n    }\n    return true;\n}\n\nchar ** findAndReplacePattern(char ** words, int wordsSize, char * pattern, int* returnSize){\n    char **ans = (char **)malloc(sizeof(char *) * wordsSize);\n    int pos = 0;\n    for (int i = 0; i < wordsSize; i++) {\n        if (match(words[i], pattern) && match(pattern, words[i])) {\n            ans[pos++] = words[i];\n        }\n    }\n    *returnSize = pos;\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar findAndReplacePattern = function(words, pattern) {\n    const ans = [];\n    for (const word of words) {\n        if (match(word, pattern) && match(pattern, word)) {\n            ans.push(word);\n        }\n    }\n    return ans;\n};\n\nconst match = (word, pattern) => {\n    const map = new Map();\n    for (let i = 0; i < word.length; ++i) {\n        const x = word[i], y = pattern[i];\n        if (!map.has(x)) {\n            map.set(x, y);\n        } else if (map.get(x) !== y) { // word 中的同一字母必须映射到 pattern 中的同一字母上\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(nm)$，其中 $n$ 是数组 $\\textit{words}$ 的长度，$m$ 是 $\\textit{pattern}$ 的长度。对于每个 $\\textit{word}$ 需要 $O(m)$ 的时间检查其是否与 $\\textit{pattern}$ 匹配。\n\n- 空间复杂度：$O(m)$。哈希表需要 $O(m)$ 的空间。"
}