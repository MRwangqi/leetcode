{
	"titleSlug": "fraction-addition-and-subtraction",
	"slug": "fen-shu-jia-jian-yun-suan-by-leetcode-so-2mto",
	"url": "https://leetcode-cn.com/problems/fraction-addition-and-subtraction/solution/fen-shu-jia-jian-yun-suan-by-leetcode-so-2mto/",
	"content": "#### 方法一：模拟\n\n对于两个分数 $\\dfrac{x_1}{y_1} 和 \\dfrac{x_2}{y_2}$，它们相加的结果为：\n\n$$\\dfrac{x_1 \\times y_2 + x_2 \\times y_1}{y_1 \\times y_2}$$\n\n初始分数的分子为 $\\textit{x} = 0$，分母为 $\\textit{y} = 1$。我们不断从字符串中获取下一个分数，它的分子为 $\\textit{x}_1$，分母为 $\\textit{y}_1$，将它加到初始分数上，有：\n\n$$\n\\begin{cases}\n\\textit{x} = \\textit{x} \\times \\textit{y}_1 + \\textit{x}_1 \\times \\textit{y} \\\\\n\\textit{y} = \\textit{y} \\times \\textit{y}_1\n\\end{cases}\n$$\n\n最后如果 $\\textit{x} = 0$，说明结果为零，直接返回 $\\text{\"0/1\"}$；否则计算分子分母的最大公约数，返回约简后分数的字符串表示。\n\n```Python [sol1-Python3]\nclass Solution:\n    def fractionAddition(self, expression: str) -> str:\n        x, y = 0, 1  # 分子，分母\n        i, n = 0, len(expression)\n        while i < n:\n            # 读取分子\n            x1, sign = 0, 1\n            if expression[i] == '-' or expression[i] == '+':\n                if expression[i] == '-':\n                    sign = -1\n                i += 1\n            while i < n and expression[i].isdigit():\n                x1 = x1 * 10 + int(expression[i])\n                i += 1\n            x1 = sign * x1\n            i += 1\n\n            # 读取分母\n            y1 = 0\n            while i < n and expression[i].isdigit():\n                y1 = y1 * 10 + int(expression[i])\n                i += 1\n\n            x = x * y1 + x1 * y\n            y *= y1\n        if x == 0:\n            return \"0/1\"\n        g = gcd(abs(x), y)\n        return f\"{x // g}/{y // g}\"\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string fractionAddition(string expression) {\n        long long x = 0, y = 1; // 分子，分母\n        int index = 0, n = expression.size();\n        while (index < n) {\n            // 读取分子\n            long long x1 = 0, sign = 1;\n            if (expression[index] == '-' || expression[index] == '+') {\n                sign = expression[index] == '-' ? -1 : 1;\n                index++;\n            }\n            while (index < n && isdigit(expression[index])) {\n                x1 = x1 * 10 + expression[index] - '0';\n                index++;\n            }\n            x1 = sign * x1;\n            index++;\n\n            // 读取分母\n            long long y1 = 0;\n            while (index < n && isdigit(expression[index])) {\n                y1 = y1 * 10 + expression[index] - '0';\n                index++;\n            }\n\n            x = x * y1 + x1 * y;\n            y *= y1;\n        }\n        if (x == 0) {\n            return \"0/1\";\n        }\n        long long g = gcd(abs(x), y); // 获取最大公约数\n        return to_string(x / g) + \"/\" + to_string(y / g);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String fractionAddition(String expression) {\n        long x = 0, y = 1; // 分子，分母\n        int index = 0, n = expression.length();\n        while (index < n) {\n            // 读取分子\n            long x1 = 0, sign = 1;\n            if (expression.charAt(index) == '-' || expression.charAt(index) == '+') {\n                sign = expression.charAt(index) == '-' ? -1 : 1;\n                index++;\n            }\n            while (index < n && Character.isDigit(expression.charAt(index))) {\n                x1 = x1 * 10 + expression.charAt(index) - '0';\n                index++;\n            }\n            x1 = sign * x1;\n            index++;\n\n            // 读取分母\n            long y1 = 0;\n            while (index < n && Character.isDigit(expression.charAt(index))) {\n                y1 = y1 * 10 + expression.charAt(index) - '0';\n                index++;\n            }\n\n            x = x * y1 + x1 * y;\n            y *= y1;\n        }\n        if (x == 0) {\n            return \"0/1\";\n        }\n        long g = gcd(Math.abs(x), y); // 获取最大公约数\n        return Long.toString(x / g) + \"/\" + Long.toString(y / g);\n    }\n\n    public long gcd(long a, long b) {\n        long remainder = a % b;\n        while (remainder != 0) {\n            a = b;\n            b = remainder;\n            remainder = a % b;\n        }\n        return b;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string FractionAddition(string expression) {\n        long x = 0, y = 1; // 分子，分母\n        int index = 0, n = expression.Length;\n        while (index < n) {\n            // 读取分子\n            long x1 = 0, sign = 1;\n            if (expression[index] == '-' || expression[index] == '+') {\n                sign = expression[index] == '-' ? -1 : 1;\n                index++;\n            }\n            while (index < n && char.IsDigit(expression[index])) {\n                x1 = x1 * 10 + expression[index] - '0';\n                index++;\n            }\n            x1 = sign * x1;\n            index++;\n\n            // 读取分母\n            long y1 = 0;\n            while (index < n && char.IsDigit(expression[index])) {\n                y1 = y1 * 10 + expression[index] - '0';\n                index++;\n            }\n\n            x = x * y1 + x1 * y;\n            y *= y1;\n        }\n        if (x == 0) {\n            return \"0/1\";\n        }\n        long g = GCD(Math.Abs(x), y); // 获取最大公约数\n        return (x / g).ToString() + \"/\" + (y / g).ToString();\n    }\n\n    public long GCD(long a, long b) {\n        long remainder = a % b;\n        while (remainder != 0) {\n            a = b;\n            b = remainder;\n            remainder = a % b;\n        }\n        return b;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX_STR_LEN 80\n\nlong long gcd(long long a, long long b) {\n    long remainder = a % b;\n    while (remainder != 0) {\n        a = b;\n        b = remainder;\n        remainder = a % b;\n    }\n    return b;\n}\n\nchar * fractionAddition(char * expression) {\n    long long x = 0, y = 1; // 分子，分母\n    int index = 0, n = strlen(expression);\n    while (index < n) {\n        // 读取分子\n        long long x1 = 0, sign = 1;\n        if (expression[index] == '-' || expression[index] == '+') {\n            sign = expression[index] == '-' ? -1 : 1;\n            index++;\n        }\n        while (index < n && isdigit(expression[index])) {\n            x1 = x1 * 10 + expression[index] - '0';\n            index++;\n        }\n        x1 = sign * x1;\n        index++;\n\n        // 读取分母\n        long long y1 = 0;\n        while (index < n && isdigit(expression[index])) {\n            y1 = y1 * 10 + expression[index] - '0';\n            index++;\n        }\n\n        x = x * y1 + x1 * y;\n        y *= y1;\n    }\n    if (x == 0) {\n        return \"0/1\";\n    }\n    long long g = gcd(abs(x), y); // 获取最大公约数\n    char *ans = (char *)malloc(sizeof(char) * MAX_STR_LEN);\n    sprintf(ans, \"%d/%d\", x / g, y / g);\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc fractionAddition(expression string) string {\n    x, y := 0, 1 // 分子，分母\n    for i, n := 0, len(expression); i < n; {\n        // 读取分子\n        x1, sign := 0, 1\n        if expression[i] == '-' || expression[i] == '+' {\n            if expression[i] == '-' {\n                sign = -1\n            }\n            i++\n        }\n        for i < n && unicode.IsDigit(rune(expression[i])) {\n            x1 = x1*10 + int(expression[i]-'0')\n            i++\n        }\n        x1 = sign * x1\n        i++\n\n        // 读取分母\n        y1 := 0\n        for i < n && unicode.IsDigit(rune(expression[i])) {\n            y1 = y1*10 + int(expression[i]-'0')\n            i++\n        }\n\n        x = x*y1 + x1*y\n        y *= y1\n    }\n    if x == 0 {\n        return \"0/1\"\n    }\n    g := gcd(abs(x), y)\n    return fmt.Sprintf(\"%d/%d\", x/g, y/g)\n}\n\nfunc gcd(a, b int) int {\n    for a != 0 {\n        a, b = b%a, a\n    }\n    return b\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar fractionAddition = function(expression) {\n    let x = 0, y = 1; // 分子，分母\n    let index = 0, n = expression.length;\n    while (index < n) {\n        // 读取分子\n        let x1 = 0, sign = 1;\n        if (expression[index] === '-' || expression[index] === '+') {\n            sign = expression[index] === '-' ? -1 : 1;\n            index++;\n        }\n        while (index < n && isDigit(expression[index])) {\n            x1 = x1 * 10 + expression[index].charCodeAt() - '0'.charCodeAt();\n            index++;\n        }\n        x1 = sign * x1;\n        index++;\n\n        // 读取分母\n        let y1 = 0;\n        while (index < n && isDigit(expression[index])) {\n            y1 = y1 * 10 + expression[index].charCodeAt() - '0'.charCodeAt();\n            index++;\n        }\n\n        x = x * y1 + x1 * y;\n        y *= y1;\n    }\n    if (x === 0) {\n        return \"0/1\";\n    }\n    const g = gcd(Math.abs(x), y); // 获取最大公约数\n    return Math.floor(x / g) + \"/\" + Math.floor(y / g);\n}\n\nconst gcd = (a, b) => {\n    let remainder = a % b;\n    while (remainder !== 0) {\n        a = b;\n        b = remainder;\n        remainder = a % b;\n    }\n    return b;\n};\n\nconst isDigit = (ch) => {\n    return parseFloat(ch).toString() === \"NaN\" ? false : true;\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n + \\log C)$，其中 $n$ 是字符串 $\\textit{expression}$ 的长度，$C$ 为化简前结果分子分母的最大值。求最大公约数需要 $O(\\log C)$。\n\n+ 空间复杂度：$O(1)$。"
}