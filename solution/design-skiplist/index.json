{
	"titleSlug": "design-skiplist",
	"slug": "she-ji-tiao-biao-by-leetcode-solution-e8yh",
	"url": "https://leetcode-cn.com/problems/design-skiplist/solution/she-ji-tiao-biao-by-leetcode-solution-e8yh/",
	"content": "#### 方法一：直接构造\n\n跳表这种数据结构是由 $\\text{William Pugh}$ 发明的，关于跳表的详细介绍可以参考论文:「[Skip Lists: A Probabilistic Alternative to Balanced Trees](https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf)」，论文中详细阐述了关于 $\\texttt{skiplist}$ 查找元素、删除元素、插入元素的算法伪代码，以及时间复杂度的分析。跳表是一种随机化的数据结构，可以被看做二叉树的一个变种，它在性能上和红黑树、$\\texttt{AVL}$ 树不相上下，但是跳表的原理非常简单，目前在 $\\texttt{Redis}$ 和 $\\texttt{LevelDB}$ 中都有用到。跳表的期望空间复杂度为 $O(n)$，跳表的查询，插入和删除操作的期望时间复杂度均为 $O(\\log n)$。跳表实际为一种多层的有序链表，跳表的每一层都为一个有序链表，且满足每个位于第 $i$ 层的节点有 $p$ 的概率出现在第 $i+1$ 层，其中 $p$ 为常数。\n\n它的结构类似于如下图所示:\n\n跳表在进行查找时，首先从当前的最高层 $L(n)$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第一层。此时，若下一个节点是目标节点，则成功查找；反之，则元素不存在。由于从高层往低层开始查找，由于低层出现的元素可能不会出现在高层，因此跳表在进行查找的过程中会跳过一些元素，相比于有序链表的查询，跳表的查询速度会更快。\n跳表的初始化、查找、添加、删除操作详细描述如下：\n\n![跳表结构](https://assets.leetcode-cn.com/solution-static/1206/1206_1.PNG)\n\n+ $\\texttt{search}$：从跳表的当前的最大层数 $\\textit{level}$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第  $1$ 层。此时，若第 $1$ 层的下一个节点的值等于 $\\textit{target}$，则返回 $\\texttt{true}$；反之，则返回 $\\texttt{false}$。如图所示：\n\n![跳表查询](https://assets.leetcode-cn.com/solution-static/1206/1206_2.PNG)\n\n+ $\\texttt{add}$：从跳表的当前的最大层数 $\\textit{level}$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第  $1$ 层。设新加入的节点为 $\\textit{newNode}$，我们需要计算出此次节点插入的层数 $\\textit{lv}$，如果 $\\textit{level}$ 小于 $\\textit{lv}$，则同时需要更新 $\\textit{level}$。我们用数组 $\\textit{update}$ 保存每一层查找的最后一个节点，第 $i$ 层最后的节点为 $\\textit{update}[i]$。我们将 $\\textit{newNode}$ 的后续节点指向 $update[i]$ 的下一个节点，同时更新 $update[i]$ 的后续节点为 $\\textit{newNode}$。如图所示：\n\n<![update1](https://assets.leetcode-cn.com/solution-static/1206/1206_3.PNG),![update2](https://assets.leetcode-cn.com/solution-static/1206/1206_4.PNG),![update3](https://assets.leetcode-cn.com/solution-static/1206/1206_5.PNG),![update4](https://assets.leetcode-cn.com/solution-static/1206/1206_6.PNG),![update5](https://assets.leetcode-cn.com/solution-static/1206/1206_7.PNG)>\n\n+ $\\texttt{erase}$：首先我们需要查找当前元素是否存在跳表中。从跳表的当前的最大层数 $\\textit{level}$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第 $1$ 层。如果第 $1$ 层的下一个节点不等于 $\\textit{num}$ 时，则表示当前元素不存在直接返回。我们用数组 $\\textit{update}$ 保存每一层查找的最后一个节点，第 $i$ 层最后的节点为 $\\textit{update}[i]$。此时第 $i$ 层的下一个节点的值为 $\\textit{num}$，则我们需要将其从跳表中将其删除。由于第 $i$ 层的以 $p$ 的概率出现在第 $i+1$ 层，因此我们应当从第 $1$ 层开始往上进行更新，将 $\\textit{num}$ 从 $update[i]$ 的下一跳中删除，同时更新 $update[i]$ 的后续节点，直到当前层的链表中没有出现 $\\textit{num}$ 的节点为止。最后我们还需要更新跳表中当前的最大层数 $\\textit{level}$。如图所示：\n\n<![erase2](https://assets.leetcode-cn.com/solution-static/1206/1206_9.PNG),![erase3](https://assets.leetcode-cn.com/solution-static/1206/1206_10.PNG),![erase4](https://assets.leetcode-cn.com/solution-static/1206/1206_11.PNG),![erase5](https://assets.leetcode-cn.com/solution-static/1206/1206_12.PNG),![erase6](https://assets.leetcode-cn.com/solution-static/1206/1206_13.PNG),![erase7](https://assets.leetcode-cn.com/solution-static/1206/1206_14.PNG)>\n\n关于跳表的复杂度的分析如下：\n\n+ 空间复杂度分析：我们知道每次添加节点时，节点出现在第 $i$ 层的概率为 $(1-p)\\times p^{i-1}$，跳表插入时的期望层数为:\n\n$$\n\\begin{aligned}\nE(L) &= 1 \\times (1-p) + 2 \\times (1-p)\\times p + 3 \\times (1-p) \\times p^2 + \\cdots \\\\\n&= \\sum_{i=1}^{\\infty} i \\times (1-p) \\times p^{i-1} \\\\\n&= (1-p) \\times \\sum_{i=1}^{\\infty} i \\times p^{i-1} \\\\\n&= (1-p) \\times \\dfrac{1}{(1-p)^2} \\\\\n&= \\dfrac{1}{1-p}\n\\end{aligned}\n$$\n\n如果节点的目标层数为 $L$，则此时需要的空间为 $O(L)$，因此总的空间复杂度为 $O(n \\times E(L)) = O(n \\times \\dfrac{1}{1-p}) = O(n)$。 \n\n+ 时间复杂度分析: 在含有 $n$ 个节点的跳表中，当前最大层数 $L(n)$ 包含的元素个数期望为 $\\dfrac{1}{p}$，根据跳表的定义可以知道第 $1$ 层的每个元素出现在 $L(n)$ 的概率为 $p^{L(n)-1}$，则此时我们可以推出如下：\n\n$$\n\\begin{aligned}\n\\dfrac{1}{p} &= np^{L(n)-1} \\\\\np^{L(n)} &= \\dfrac{1}{n} \\\\\nL(n) &= \\log_p {\\dfrac{1}{n}}\n\\end{aligned}\n$$\n\n根据以上结论可以知道在含有 $n$ 个节点的跳表中，当前最大层数期望 $L(n) = \\log_p {\\dfrac{1}{n}}$。\n\n我们首先思考一下搜索目标节点 $x$ 的过程，每次我们搜索第 $i$ 层时，如果第 $i$ 层的当前节点小于 $x$ 时，则我们会在第 $i$ 层向右进行搜索，直到下一个节点的值大于等于 $x$；如果第 $i$ 层的节点值大于等于 $x$，则我们则会下降到 $i-1$ 层。根据之前的定义，如果节点 $x$ 在第 $i$ 层出现，则节点 $x$ 一定会出现在第 $i-1$ 层。现在假设我们从 $L(n)$ 的第一个节点搜索到第 $1$ 层的目标节点 $x$ 的路径为 $S$，现在我们将路径 $S$ 反过来，即从第 $1$ 的节点 $x$ 回到 $L(n)$ 层的第一个节点，我们可以观察到从第 $1$ 层的节点 $x$ 一直往上一层，直到 $x$ 的最大层数，然后再向左走一步到达节点 $y$，再向上走，再重复上述步骤，实际搜索时如果在上一层可以到访问到节点 $x$，则在下一层遍历时一定不会访问所有小于 $x$ 的节点。假设当前我们处于一个第 $i$ 层的节点 $x$，此时并不知道 $x$ 的最大层数和 $x$ 左侧节点的最大层数，只知道 $x$ 的最大层数至少为 $i$。我们可以知道 $x$ 的最大层数大于 $i$，那么下一步按照最优选择应该是向上一层，这种情况的概率为 $p$；如果 $x$ 的最大层数等于 $i$，那么下一步应该是同一层向左侧后退一个节点，这种情况概率为 $1-p$。令 $C(i)$ 为在一个无限长度的跳表中向上爬 $i$ 层的期望代价，则知道:\n\n$$\n\\begin{aligned}\nC(0) &= 0 \\\\\nC(i) &= (1-p)(1 + C(i)) + p(1 + C(i-1)) \\\\\nC(i) &= \\dfrac{1}{p} + C(i-1) \\\\\nC(i) &= \\dfrac{i}{p}\n\\end{aligned}\n$$\n\n在含有 $n$ 个元素的跳表中，从第 $1$ 层爬到第 $L(n)$ 层的期望步数存在上界 $\\dfrac{L(n) - 1}{p}$。现在只需要分析爬到第 $L(n)$ 层后还要再走多少步。当达到第 $L(n)$ 层后，我们需要向左走。我们已知 $L(n)$ 层的节点总数的期望存在上界为 $\\dfrac{1}{p}$。所以我们知道搜索的总的代价为:\n\n$$\n\\dfrac{L(n) - 1}{p} + \\dfrac{1}{p} = \\dfrac{\\log_{\\frac{1}{p}}n -1}{p} + \\dfrac{1}{p} =  \\dfrac{\\log_{\\frac{1}{p}}n}{p}\n$$\n\n根据以上推理可以得到查询的平均时间复杂度为 $O(\\log n)$。\n\n上述的推理过程与原本的论文相比还是有所忽略细节，如果对复杂度分析的详细细节感兴趣的可以参考原始论文:「[Skip Lists: A Probabilistic Alternative to Balanced Trees](https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf)」。\n\n```Python [sol1-Python3]\nMAX_LEVEL = 32\nP_FACTOR = 0.25\n\ndef random_level() -> int:\n    lv = 1\n    while lv < MAX_LEVEL and random.random() < P_FACTOR:\n        lv += 1\n    return lv\n\nclass SkiplistNode:\n    __slots__ = 'val', 'forward'\n\n    def __init__(self, val: int, max_level=MAX_LEVEL):\n        self.val = val\n        self.forward = [None] * max_level\n\nclass Skiplist:\n    def __init__(self):\n        self.head = SkiplistNode(-1)\n        self.level = 0\n\n    def search(self, target: int) -> bool:\n        curr = self.head\n        for i in range(self.level - 1, -1, -1):\n            # 找到第 i 层小于且最接近 target 的元素\n            while curr.forward[i] and curr.forward[i].val < target:\n                curr = curr.forward[i]\n        curr = curr.forward[0]\n        # 检测当前元素的值是否等于 target\n        return curr is not None and curr.val == target\n\n    def add(self, num: int) -> None:\n        update = [self.head] * MAX_LEVEL\n        curr = self.head\n        for i in range(self.level - 1, -1, -1):\n            # 找到第 i 层小于且最接近 num 的元素\n            while curr.forward[i] and curr.forward[i].val < num:\n                curr = curr.forward[i]\n            update[i] = curr\n        lv = random_level()\n        self.level = max(self.level, lv)\n        new_node = SkiplistNode(num, lv)\n        for i in range(lv):\n            # 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点\n            new_node.forward[i] = update[i].forward[i]\n            update[i].forward[i] = new_node\n\n    def erase(self, num: int) -> bool:\n        update = [None] * MAX_LEVEL\n        curr = self.head\n        for i in range(self.level - 1, -1, -1):\n            # 找到第 i 层小于且最接近 num 的元素\n            while curr.forward[i] and curr.forward[i].val < num:\n                curr = curr.forward[i]\n            update[i] = curr\n        curr = curr.forward[0]\n        if curr is None or curr.val != num:  # 值不存在\n            return False\n        for i in range(self.level):\n            if update[i].forward[i] != curr:\n                break\n            # 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳\n            update[i].forward[i] = curr.forward[i]\n        # 更新当前的 level\n        while self.level > 1 and self.head.forward[self.level - 1] is None:\n            self.level -= 1\n        return True\n```\n\n```C++ [sol1-C++]\nconstexpr int MAX_LEVEL = 32;\nconstexpr double P_FACTOR = 0.25;\n\nstruct SkiplistNode {\n    int val;\n    vector<SkiplistNode *> forward;\n    SkiplistNode(int _val, int _maxLevel = MAX_LEVEL) : val(_val), forward(_maxLevel, nullptr) {\n        \n    }\n};\n\nclass Skiplist {\nprivate:\n    SkiplistNode * head;\n    int level;\n    mt19937 gen{random_device{}()};\n    uniform_real_distribution<double> dis;\n\npublic:\n    Skiplist(): head(new SkiplistNode(-1)), level(0), dis(0, 1) {\n\n    }\n\n    bool search(int target) {\n        SkiplistNode *curr = this->head;\n        for (int i = level - 1; i >= 0; i--) {\n            /* 找到第 i 层小于且最接近 target 的元素*/\n            while (curr->forward[i] && curr->forward[i]->val < target) {\n                curr = curr->forward[i];\n            }\n        }\n        curr = curr->forward[0];\n        /* 检测当前元素的值是否等于 target */\n        if (curr && curr->val == target) {\n            return true;\n        } \n        return false;\n    }\n\n    void add(int num) {\n        vector<SkiplistNode *> update(MAX_LEVEL, head);\n        SkiplistNode *curr = this->head;\n        for (int i = level - 1; i >= 0; i--) {\n            /* 找到第 i 层小于且最接近 num 的元素*/\n            while (curr->forward[i] && curr->forward[i]->val < num) {\n                curr = curr->forward[i];\n            }\n            update[i] = curr;\n        }\n        int lv = randomLevel();\n        level = max(level, lv);\n        SkiplistNode *newNode = new SkiplistNode(num, lv);\n        for (int i = 0; i < lv; i++) {\n            /* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */\n            newNode->forward[i] = update[i]->forward[i];\n            update[i]->forward[i] = newNode;\n        }\n    }\n\n    bool erase(int num) {\n        vector<SkiplistNode *> update(MAX_LEVEL, nullptr);\n        SkiplistNode *curr = this->head;\n        for (int i = level - 1; i >= 0; i--) {\n            /* 找到第 i 层小于且最接近 num 的元素*/\n            while (curr->forward[i] && curr->forward[i]->val < num) {\n                curr = curr->forward[i];\n            }\n            update[i] = curr;\n        }\n        curr = curr->forward[0];\n        /* 如果值不存在则返回 false */\n        if (!curr || curr->val != num) {\n            return false;\n        }\n        for (int i = 0; i < level; i++) {\n            if (update[i]->forward[i] != curr) {\n                break;\n            }\n            /* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */\n            update[i]->forward[i] = curr->forward[i];\n        }\n        delete curr;\n        /* 更新当前的 level */\n        while (level > 1 && head->forward[level - 1] == nullptr) {\n            level--;\n        }\n        return true;\n    }\n\n    int randomLevel() {\n        int lv = 1;\n        /* 随机生成 lv */\n        while (dis(gen) < P_FACTOR && lv < MAX_LEVEL) {\n            lv++;\n        }\n        return lv;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Skiplist {\n    static final int MAX_LEVEL = 32;\n    static final double P_FACTOR = 0.25;\n    private SkiplistNode head;\n    private int level;\n    private Random random;\n\n    public Skiplist() {\n        this.head = new SkiplistNode(-1, MAX_LEVEL);\n        this.level = 0;\n        this.random = new Random();\n    }\n\n    public boolean search(int target) {\n        SkiplistNode curr = this.head;\n        for (int i = level - 1; i >= 0; i--) {\n            /* 找到第 i 层小于且最接近 target 的元素*/\n            while (curr.forward[i] != null && curr.forward[i].val < target) {\n                curr = curr.forward[i];\n            }\n        }\n        curr = curr.forward[0];\n        /* 检测当前元素的值是否等于 target */\n        if (curr != null && curr.val == target) {\n            return true;\n        } \n        return false;\n    }\n\n    public void add(int num) {\n        SkiplistNode[] update = new SkiplistNode[MAX_LEVEL];\n        Arrays.fill(update, head);\n        SkiplistNode curr = this.head;\n        for (int i = level - 1; i >= 0; i--) {\n            /* 找到第 i 层小于且最接近 num 的元素*/\n            while (curr.forward[i] != null && curr.forward[i].val < num) {\n                curr = curr.forward[i];\n            }\n            update[i] = curr;\n        }\n        int lv = randomLevel();\n        level = Math.max(level, lv);\n        SkiplistNode newNode = new SkiplistNode(num, lv);\n        for (int i = 0; i < lv; i++) {\n            /* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */\n            newNode.forward[i] = update[i].forward[i];\n            update[i].forward[i] = newNode;\n        }\n    }\n\n    public boolean erase(int num) {\n        SkiplistNode[] update = new SkiplistNode[MAX_LEVEL];\n        SkiplistNode curr = this.head;\n        for (int i = level - 1; i >= 0; i--) {\n            /* 找到第 i 层小于且最接近 num 的元素*/\n            while (curr.forward[i] != null && curr.forward[i].val < num) {\n                curr = curr.forward[i];\n            }\n            update[i] = curr;\n        }\n        curr = curr.forward[0];\n        /* 如果值不存在则返回 false */\n        if (curr == null || curr.val != num) {\n            return false;\n        }\n        for (int i = 0; i < level; i++) {\n            if (update[i].forward[i] != curr) {\n                break;\n            }\n            /* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */\n            update[i].forward[i] = curr.forward[i];\n        }\n        /* 更新当前的 level */\n        while (level > 1 && head.forward[level - 1] == null) {\n            level--;\n        }\n        return true;\n    }\n\n    private int randomLevel() {\n        int lv = 1;\n        /* 随机生成 lv */\n        while (random.nextDouble() < P_FACTOR && lv < MAX_LEVEL) {\n            lv++;\n        }\n        return lv;\n    }\n}\n\nclass SkiplistNode {\n    int val;\n    SkiplistNode[] forward;\n\n    public SkiplistNode(int val, int maxLevel) {\n        this.val = val;\n        this.forward = new SkiplistNode[maxLevel];\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Skiplist {\n    const int MAX_LEVEL = 32;\n    const double P_FACTOR = 0.25;\n    private SkiplistNode head;\n    private int level;\n    private Random random;\n\n    public Skiplist() {\n        this.head = new SkiplistNode(-1, MAX_LEVEL);\n        this.level = 0;\n        this.random = new Random();\n    }\n    \n    public bool Search(int target) {\n        SkiplistNode curr = this.head;\n        for (int i = level - 1; i >= 0; i--) {\n            /* 找到第 i 层小于且最接近 target 的元素*/\n            while (curr.forward[i] != null && curr.forward[i].val < target) {\n                curr = curr.forward[i];\n            }\n        }\n        curr = curr.forward[0];\n        /* 检测当前元素的值是否等于 target */\n        if (curr != null && curr.val == target) {\n            return true;\n        } \n        return false;\n    }\n    \n    public void Add(int num) {\n        SkiplistNode[] update = new SkiplistNode[MAX_LEVEL];\n        Array.Fill(update, head);\n        SkiplistNode curr = this.head;\n        for (int i = level - 1; i >= 0; i--) {\n            /* 找到第 i 层小于且最接近 num 的元素*/\n            while (curr.forward[i] != null && curr.forward[i].val < num) {\n                curr = curr.forward[i];\n            }\n            update[i] = curr;\n        }\n        int lv = RandomLevel();\n        level = Math.Max(level, lv);\n        SkiplistNode newNode = new SkiplistNode(num, lv);\n        for (int i = 0; i < lv; i++) {\n            /* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */\n            newNode.forward[i] = update[i].forward[i];\n            update[i].forward[i] = newNode;\n        }\n    }\n    \n    public bool Erase(int num) {\n        SkiplistNode[] update = new SkiplistNode[MAX_LEVEL];\n        SkiplistNode curr = this.head;\n        for (int i = level - 1; i >= 0; i--) {\n            /* 找到第 i 层小于且最接近 num 的元素*/\n            while (curr.forward[i] != null && curr.forward[i].val < num) {\n                curr = curr.forward[i];\n            }\n            update[i] = curr;\n        }\n        curr = curr.forward[0];\n        /* 如果值不存在则返回 false */\n        if (curr == null || curr.val != num) {\n            return false;\n        }\n        for (int i = 0; i < level; i++) {\n            if (update[i].forward[i] != curr) {\n                break;\n            }\n            /* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */\n            update[i].forward[i] = curr.forward[i];\n        }\n        /* 更新当前的 level */\n        while (level > 1 && head.forward[level - 1] == null) {\n            level--;\n        }\n        return true;\n    }\n\n    private int RandomLevel() {\n        int lv = 1;\n        /* 随机生成 lv */\n        while (random.NextDouble() < P_FACTOR && lv < MAX_LEVEL) {\n            lv++;\n        }\n        return lv;\n    }\n}\n\npublic class SkiplistNode {\n    public int val;\n    public SkiplistNode[] forward;\n\n    public SkiplistNode(int val, int maxLevel) {\n        this.val = val;\n        this.forward = new SkiplistNode[maxLevel];\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\nconst int MAX_LEVEL = 32;\nconst int P_FACTOR = RAND_MAX >> 2;\n\ntypedef struct SkiplistNode {\n    int val;\n    int maxLevel;\n    struct SkiplistNode **forward;\n} SkiplistNode;\n\ntypedef struct {\n    SkiplistNode *head;\n    int level;\n} Skiplist;\n\nSkiplistNode *skiplistNodeCreat(int val, int maxLevel) {\n    SkiplistNode *obj = (SkiplistNode *)malloc(sizeof(SkiplistNode));\n    obj->val = val;\n    obj->maxLevel = maxLevel;\n    obj->forward = (SkiplistNode **)malloc(sizeof(SkiplistNode *) * maxLevel);\n    for (int i = 0; i < maxLevel; i++) {\n        obj->forward[i] = NULL;\n    }\n    return obj;\n}\n\nvoid skiplistNodeFree(SkiplistNode* obj) {\n    if (obj->forward) {\n        free(obj->forward);\n        obj->forward = NULL;\n        obj->maxLevel = 0;\n    }\n    free(obj);\n}\n\nSkiplist* skiplistCreate() {\n    Skiplist *obj = (Skiplist *)malloc(sizeof(Skiplist));\n    obj->head = skiplistNodeCreat(-1, MAX_LEVEL);\n    obj->level = 0;\n    srand(time(NULL));\n    return obj;\n}\n\nstatic inline int randomLevel() {\n    int lv = 1;\n    /* 随机生成 lv */\n    while (rand() < P_FACTOR && lv < MAX_LEVEL) {\n        lv++;\n    }\n    return lv;\n}\n\nbool skiplistSearch(Skiplist* obj, int target) {\n    SkiplistNode *curr = obj->head;\n    for (int i = obj->level - 1; i >= 0; i--) {\n        /* 找到第 i 层小于且最接近 target 的元素*/\n        while (curr->forward[i] && curr->forward[i]->val < target) {\n            curr = curr->forward[i];\n        }\n    }\n    curr = curr->forward[0];\n    /* 检测当前元素的值是否等于 target */\n    if (curr && curr->val == target) {\n        return true;\n    } \n    return false;\n}\n\nvoid skiplistAdd(Skiplist* obj, int num) {\n    SkiplistNode *update[MAX_LEVEL];\n    SkiplistNode *curr = obj->head;\n    for (int i = obj->level - 1; i >= 0; i--) {\n        /* 找到第 i 层小于且最接近 num 的元素*/\n        while (curr->forward[i] && curr->forward[i]->val < num) {\n            curr = curr->forward[i];\n        }\n        update[i] = curr;\n    }\n    int lv = randomLevel();\n    if (lv > obj->level) {\n        for (int i = obj->level; i < lv; i++) {\n            update[i] = obj->head;\n        }\n        obj->level = lv;\n    }\n    SkiplistNode *newNode = skiplistNodeCreat(num, lv);\n    for (int i = 0; i < lv; i++) {\n        /* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */\n        newNode->forward[i] = update[i]->forward[i];\n        update[i]->forward[i] = newNode;\n    }\n}\n\nbool skiplistErase(Skiplist* obj, int num) {\n    SkiplistNode *update[MAX_LEVEL];\n    SkiplistNode *curr = obj->head;\n    for (int i = obj->level - 1; i >= 0; i--) {\n        /* 找到第 i 层小于且最接近 num 的元素*/\n        while (curr->forward[i] && curr->forward[i]->val < num) {\n            curr = curr->forward[i];\n        }\n        update[i] = curr;\n    }\n    curr = curr->forward[0];\n    /* 如果值不存在则返回 false */\n    if (!curr || curr->val != num) {\n        return false;\n    }\n    for (int i = 0; i < obj->level; i++) {\n        if (update[i]->forward[i] != curr) {\n            break;\n        } \n        /* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */\n        update[i]->forward[i] = curr->forward[i];\n    }\n    skiplistNodeFree(curr);\n    /* 更新当前的 level */\n    while (obj->level > 1 && obj->head->forward[obj->level - 1] == NULL) {\n        obj->level--;\n    }\n    return true;\n}\n\nvoid skiplistFree(Skiplist* obj) {\n    for (SkiplistNode * curr = obj->head; curr; ) {\n        SkiplistNode *prev = curr;\n        curr = curr->forward[0];\n        skiplistNodeFree(prev);\n    }\n    free(obj);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nconst MAX_LEVEL = 32;\nconst P_FACTOR = 0.25;\nvar Skiplist = function() {\n    this.head = new SkiplistNode(-1, MAX_LEVEL);\n    this.level = 0;\n};\n\nSkiplist.prototype.search = function(target) {\n    let curr = this.head;\n    for (let i = this.level - 1; i >= 0; i--) {\n        /* 找到第 i 层小于且最接近 target 的元素*/\n        while (curr.forward[i] && curr.forward[i].val < target) {\n            curr = curr.forward[i];\n        }\n    }\n    curr = curr.forward[0];\n    /* 检测当前元素的值是否等于 target */\n    if (curr && curr.val === target) {\n        return true;\n    } \n    return false;\n};\n\nSkiplist.prototype.add = function(num) {\n    const update = new Array(MAX_LEVEL).fill(this.head);\n    let curr = this.head;\n    for (let i = this.level - 1; i >= 0; i--) {\n        /* 找到第 i 层小于且最接近 num 的元素*/\n        while (curr.forward[i] && curr.forward[i].val < num) {\n            curr = curr.forward[i];\n        }\n        update[i] = curr;\n    }\n    const lv = randomLevel();\n    this.level = Math.max(this.level, lv);\n    const newNode = new SkiplistNode(num, lv);\n    for (let i = 0; i < lv; i++) {\n        /* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */\n        newNode.forward[i] = update[i].forward[i];\n        update[i].forward[i] = newNode;\n    }\n};\n\nSkiplist.prototype.erase = function(num) {\n    const update = new Array(MAX_LEVEL).fill(0);\n    let curr = this.head;\n    for (let i = this.level - 1; i >= 0; i--) {\n        /* 找到第 i 层小于且最接近 num 的元素*/\n        while (curr.forward[i] && curr.forward[i].val < num) {\n            curr = curr.forward[i];\n        }\n        update[i] = curr;\n    }\n    curr = curr.forward[0];\n    /* 如果值不在存则返回 false */\n    if (!curr || curr.val !== num) {\n        return false;\n    }\n    for (let i = 0; i < this.level; i++) {\n        if (update[i].forward[i] !== curr) {\n            break;\n        }\n        /* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */\n        update[i].forward[i] = curr.forward[i];\n    }\n    /* 更新当前的 level */\n    while (this.level > 1 && !this.head.forward[this.level - 1]) {\n        this.level--;\n    }\n    return true;\n};\n\nconst randomLevel = () => {\n    let lv = 1;\n    /* 随机生成 lv */\n    while (Math.random() < P_FACTOR && lv < MAX_LEVEL) {\n        lv++;\n    }\n    return lv;\n}\n\nclass SkiplistNode {\n    constructor(val, maxLevel) {\n        this.val = val;\n        this.forward = new Array(maxLevel).fill(0);\n    }\n}\n```\n\n```go [sol1-Golang]\nconst maxLevel = 32\nconst pFactor = 0.25\n\ntype SkiplistNode struct {\n    val     int\n    forward []*SkiplistNode\n}\n\ntype Skiplist struct {\n    head  *SkiplistNode\n    level int\n}\n\nfunc Constructor() Skiplist {\n    return Skiplist{&SkiplistNode{-1, make([]*SkiplistNode, maxLevel)}, 0}\n}\n\nfunc (Skiplist) randomLevel() int {\n    lv := 1\n    for lv < maxLevel && rand.Float64() < pFactor {\n        lv++\n    }\n    return lv\n}\n\nfunc (s *Skiplist) Search(target int) bool {\n    curr := s.head\n    for i := s.level - 1; i >= 0; i-- {\n        // 找到第 i 层小于且最接近 target 的元素\n        for curr.forward[i] != nil && curr.forward[i].val < target {\n            curr = curr.forward[i]\n        }\n    }\n    curr = curr.forward[0]\n    // 检测当前元素的值是否等于 target\n    return curr != nil && curr.val == target\n}\n\nfunc (s *Skiplist) Add(num int) {\n    update := make([]*SkiplistNode, maxLevel)\n    for i := range update {\n        update[i] = s.head\n    }\n    curr := s.head\n    for i := s.level - 1; i >= 0; i-- {\n        // 找到第 i 层小于且最接近 num 的元素\n        for curr.forward[i] != nil && curr.forward[i].val < num {\n            curr = curr.forward[i]\n        }\n        update[i] = curr\n    }\n    lv := s.randomLevel()\n    s.level = max(s.level, lv)\n    newNode := &SkiplistNode{num, make([]*SkiplistNode, lv)}\n    for i, node := range update[:lv] {\n        // 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点\n        newNode.forward[i] = node.forward[i]\n        node.forward[i] = newNode\n    }\n}\n\nfunc (s *Skiplist) Erase(num int) bool {\n    update := make([]*SkiplistNode, maxLevel)\n    curr := s.head\n    for i := s.level - 1; i >= 0; i-- {\n        // 找到第 i 层小于且最接近 num 的元素\n        for curr.forward[i] != nil && curr.forward[i].val < num {\n            curr = curr.forward[i]\n        }\n        update[i] = curr\n    }\n    curr = curr.forward[0]\n    // 如果值不存在则返回 false\n    if curr == nil || curr.val != num {\n        return false\n    }\n    for i := 0; i < s.level && update[i].forward[i] == curr; i++ {\n        // 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳\n        update[i].forward[i] = curr.forward[i]\n    }\n    // 更新当前的 level\n    for s.level > 1 && s.head.forward[s.level-1] == nil {\n        s.level--\n    }\n    return true\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log n)$，其中 $n$ 为 $\\texttt{add}$ 的调用次数。详细分析参考题解描述。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为 $\\texttt{add}$ 的调用次数。详细分析参考题解描述。"
}