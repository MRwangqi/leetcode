{
	"titleSlug": "maximum-equal-frequency",
	"slug": "zui-da-xiang-deng-pin-lu-by-leetcode-sol-5y2m",
	"url": "https://leetcode-cn.com/problems/maximum-equal-frequency/solution/zui-da-xiang-deng-pin-lu-by-leetcode-sol-5y2m/",
	"content": "#### 方法一：哈希表\n\n使用哈希表 $\\textit{count}$ 记录数 $x$ 出现的次数 $\\textit{count}[x]$，$\\textit{freq}$ 记录出现次数为 $f$ 的数的数目为 $\\textit{freq}[f]$，$\\textit{maxFreq}$ 表示最大出现次数。\n\n依次遍历数组，假设当前访问的数为 $\\textit{nums}[i]$，对应地更新 $\\textit{count}$，$\\textit{freq}$ 以及 $\\textit{maxFreq}$。以 $\\textit{nums}[i]$ 结尾的数组前缀符合要求的充要条件为满足以下三个条件之一：\n\n+ 最大出现次数 $\\textit{maxFreq} = 1$：那么所有数的出现次数都是一次，随意删除一个数既可符合要求。\n\n+ 所有数的出现次数都是 $\\textit{maxFreq}$ 或 $\\textit{maxFreq} - 1$，并且最大出现次数的数只有一个：删除一个最大出现次数的数，那么所有数的出现次数都是 $\\textit{maxFreq} - 1$。\n\n+ 除开一个数，其他所有数的出现次数都是 $\\textit{maxFreq}$，并且该数的出现次数为 $1$：直接删除出现次数为 $1$ 的数，那么所有数的出现次数都是 $\\textit{maxFreq}$。\n\n```Python [sol1-Python3]\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        freq, count = Counter(), Counter()\n        ans = maxFreq = 0\n        for i, num in enumerate(nums):\n            if count[num]:\n                freq[count[num]] -= 1\n            count[num] += 1\n            maxFreq = max(maxFreq, count[num])\n            freq[count[num]] += 1\n            if maxFreq == 1 or \\\n               freq[maxFreq] * maxFreq + freq[maxFreq - 1] * (maxFreq - 1) == i + 1 and freq[maxFreq] == 1 or \\\n               freq[maxFreq] * maxFreq + 1 == i + 1 and freq[1] == 1:\n                ans = max(ans, i + 1)\n        return ans\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int maxEqualFreq(vector<int>& nums) {\n        unordered_map<int, int> freq, count;\n        int res = 0, maxFreq = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (count[nums[i]] > 0) {\n                freq[count[nums[i]]]--;\n            }\n            count[nums[i]]++;\n            maxFreq = max(maxFreq, count[nums[i]]);\n            freq[count[nums[i]]]++;\n            bool ok = maxFreq == 1 ||\n                    freq[maxFreq] * maxFreq + freq[maxFreq - 1] * (maxFreq - 1) == i + 1 && freq[maxFreq] == 1 ||\n                    freq[maxFreq] * maxFreq + 1 == i + 1 && freq[1] == 1;\n            if (ok) {\n                res = max(res, i + 1);\n            }\n        }\n        return res;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int maxEqualFreq(int[] nums) {\n        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();\n        Map<Integer, Integer> count = new HashMap<Integer, Integer>();\n        int res = 0, maxFreq = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (count.getOrDefault(nums[i], 0) > 0) {\n                freq.put(count.get(nums[i]), freq.get(count.get(nums[i])) - 1);\n            }\n            count.put(nums[i], count.getOrDefault(nums[i], 0) + 1);\n            maxFreq = Math.max(maxFreq, count.get(nums[i]));\n            freq.put(count.get(nums[i]), freq.getOrDefault(count.get(nums[i]), 0) + 1);\n            boolean ok = maxFreq == 1 ||\n                    freq.get(maxFreq) * maxFreq + freq.get(maxFreq - 1) * (maxFreq - 1) == i + 1 && freq.get(maxFreq) == 1 ||\n                    freq.get(maxFreq) * maxFreq + 1 == i + 1 && freq.get(1) == 1;\n            if (ok) {\n                res = Math.max(res, i + 1);\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int MaxEqualFreq(int[] nums) {\n        Dictionary<int, int> freq = new Dictionary<int, int>();\n        Dictionary<int, int> count = new Dictionary<int, int>();\n        int res = 0, maxFreq = 0;\n        for (int i = 0; i < nums.Length; i++) {\n            if (!count.ContainsKey(nums[i])) {\n                count.Add(nums[i], 0);\n            }\n            if (count[nums[i]] > 0) {\n                freq[count[nums[i]]]--;\n            }\n            count[nums[i]]++;\n            maxFreq = Math.Max(maxFreq, count[nums[i]]);\n            if (!freq.ContainsKey(count[nums[i]])) {\n                freq.Add(count[nums[i]], 0);\n            }\n            freq[count[nums[i]]]++;\n            bool ok = maxFreq == 1 ||\n                    freq[maxFreq] * maxFreq + freq[maxFreq - 1] * (maxFreq - 1) == i + 1 && freq[maxFreq] == 1 ||\n                    freq[maxFreq] * maxFreq + 1 == i + 1 && freq[1] == 1;\n            if (ok) {\n                res = Math.Max(res, i + 1);\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C [sol1-C]\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} HashItem; \n\nHashItem *hashFindItem(const HashItem **obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nbool hashAddItem(HashItem **obj, int key, int val) {\n    if (hashFindItem(obj, key)) {\n        return false;\n    }\n    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = key;\n    pEntry->val = val;\n    HASH_ADD_INT(*obj, key, pEntry);\n    return true;\n}\n\nbool hashSetItem(HashItem **obj, int key, int val) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        hashAddItem(obj, key, val);\n    } else {\n        pEntry->val = val;\n    }\n    return true;\n}\n\nint hashGetItem(const HashItem **obj, int key, int defaultVal) {\n    HashItem *pEntry = hashFindItem(obj, key);\n    if (!pEntry) {\n        return defaultVal;\n    }\n    return pEntry->val;\n}\n\nvoid hashFree(HashItem **obj) {\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);             \n    }\n}\n\nint maxEqualFreq(int* nums, int numsSize) {\n    HashItem *freq = NULL, *count = NULL;\n    int res = 0, maxFreq = 0;\n    for (int i = 0; i < numsSize; i++) {\n        int val = hashGetItem(&count, nums[i], 0);\n        if (val > 0) {\n            hashSetItem(&freq, val, hashGetItem(&freq, val, 0) - 1);\n        }\n        hashSetItem(&count, nums[i], hashGetItem(&count, nums[i], 0) + 1);\n        maxFreq = MAX(maxFreq,  hashGetItem(&count, nums[i], 0));\n        val = hashGetItem(&count, nums[i], 0);\n        hashSetItem(&freq, val, hashGetItem(&freq, val, 0) + 1);\n        int val1 = hashGetItem(&freq, maxFreq, 0);\n        int val2 = hashGetItem(&freq, maxFreq - 1, 0);\n        int val3 = hashGetItem(&freq, 1, 0);\n        bool ok = maxFreq == 1 ||\n                val1 * maxFreq + val2 * (maxFreq - 1) == i + 1 && val1 == 1 ||\n                val1 * maxFreq + 1 == i + 1 && val3 == 1;\n        if (ok) {\n            res = MAX(res, i + 1);\n        }\n    }\n    hashFree(&count);\n    hashFree(&freq);\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar maxEqualFreq = function(nums) {\n    const freq = new Map();\n    const count = new Map();\n    let res = 0, maxFreq = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (!count.has(nums[i])) {\n            count.set(nums[i], 0);\n        }\n        if (count.get(nums[i]) > 0) {\n            freq.set(count.get(nums[i]), freq.get(count.get(nums[i])) - 1);\n        }\n        count.set(nums[i], count.get(nums[i]) + 1);\n        maxFreq = Math.max(maxFreq, count.get(nums[i]));\n        if (!freq.has(count.get(nums[i]))) {\n            freq.set(count.get(nums[i]), 0);\n        }\n        freq.set(count.get(nums[i]), freq.get(count.get(nums[i])) + 1);\n        const ok = maxFreq === 1 ||\n                freq.get(maxFreq) * maxFreq + freq.get(maxFreq - 1) * (maxFreq - 1) === i + 1 && freq.get(maxFreq) === 1 ||\n                freq.get(maxFreq) * maxFreq + 1 === i + 1 && freq.get(1) === 1;\n        if (ok) {\n            res = Math.max(res, i + 1);\n        }\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc maxEqualFreq(nums []int) (ans int) {\n    freq := map[int]int{}\n    count := map[int]int{}\n    maxFreq := 0\n    for i, num := range nums {\n        if count[num] > 0 {\n            freq[count[num]]--\n        }\n        count[num]++\n        maxFreq = max(maxFreq, count[num])\n        freq[count[num]]++\n        if maxFreq == 1 ||\n            freq[maxFreq]*maxFreq+freq[maxFreq-1]*(maxFreq-1) == i+1 && freq[maxFreq] == 1 ||\n            freq[maxFreq]*maxFreq+1 == i+1 && freq[1] == 1 {\n            ans = max(ans, i+1)\n        }\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if b > a {\n        return b\n    }\n    return a\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。遍历数组 $\\textit{nums}$ 需要 $O(n)$。\n\n+ 空间复杂度：$O(n)$。保存两个哈希表需要 $O(n)$ 的空间。"
}