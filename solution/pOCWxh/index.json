{
	"titleSlug": "pOCWxh",
	"slug": "er-cha-shu-jian-zhi-by-leetcode-solution-r0cg",
	"url": "https://leetcode-cn.com/problems/pOCWxh/solution/er-cha-shu-jian-zhi-by-leetcode-solution-r0cg/",
	"content": "#### 方法一：递归\n\n**思路**\n\n树相关的题目首先考虑用递归解决。首先确定边界条件，当输入为空时，即可返回空。然后对左子树和右子树分别递归进行 $\\textit{pruneTree}$ 操作。递归完成后，当这三个条件：左子树为空，右子树为空，当前节点的值为 $0$，同时满足时，才表示以当前节点为根的原二叉树的所有节点都为 $0$，需要将这棵子树移除，返回空。有任一条件不满足时，当前节点不应该移除，返回当前节点。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return None\n        root.left = self.pruneTree(root.left)\n        root.right = self.pruneTree(root.right)\n        if root.left is None and root.right is None and root.val == 0:\n            return None\n        return root\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public TreeNode pruneTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        root.left = pruneTree(root.left);\n        root.right = pruneTree(root.right);\n        if (root.left == null && root.right == null && root.val == 0) {\n            return null;\n        }\n        return root;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public TreeNode PruneTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        root.left = PruneTree(root.left);\n        root.right = PruneTree(root.right);\n        if (root.left == null && root.right == null && root.val == 0) {\n            return null;\n        }\n        return root;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        if (!root) {\n            return nullptr;\n        }\n        root->left = pruneTree(root->left);\n        root->right = pruneTree(root->right);\n        if (!root->left && !root->right && !root->val) {\n            return nullptr;\n        }\n        return root;\n    }   \n};\n```\n\n```C [sol1-C]\nstruct TreeNode* pruneTree(struct TreeNode* root){\n    if (!root) {\n        return NULL;\n    }\n    root->left = pruneTree(root->left);\n    root->right = pruneTree(root->right);\n    if (!root->left && !root->right && !root->val) {\n        return NULL;\n    }\n    return root;\n}\n```\n\n```go [sol1-Golang]\nfunc pruneTree(root *TreeNode) *TreeNode {\n    if root == nil {\n        return nil\n    }\n    root.Left = pruneTree(root.Left)\n    root.Right = pruneTree(root.Right)\n    if root.Left == nil && root.Right == nil && root.Val == 0 {\n        return nil\n    }\n    return root\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar pruneTree = function(root) {\n    if (!root) {\n        return null;\n    }\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n    if (!root.left && !root.right&& root.val === 0) {\n        return null;\n    }\n    return root;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是二叉树节点的个数。每个节点都需要遍历一次。\n\n- 空间复杂度：$O(n)$，其中 $n$ 是二叉树节点的个数。递归的深度最多为 $O(n)$。"
}