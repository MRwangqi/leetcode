{
	"titleSlug": "add-one-row-to-tree",
	"slug": "zai-er-cha-shu-zhong-zeng-jia-yi-xing-by-xcaf",
	"url": "https://leetcode-cn.com/problems/add-one-row-to-tree/solution/zai-er-cha-shu-zhong-zeng-jia-yi-xing-by-xcaf/",
	"content": "#### 方法一：深度优先搜索\n\n**思路**\n\n当输入 $\\textit{depth}$ 为 $1$ 时，需要创建一个新的 $\\textit{root}$，并将原 $\\textit{root}$ 作为新 $\\textit{root}$ 的左子节点。当 $\\textit{depth}$ 为 $2$ 时，需要在 $\\textit{root}$ 下新增两个节点 $\\textit{left}$ 和 $\\textit{right}$ 作为 $\\textit{root}$ 的新子节点，并把原左子节点作为 $\\textit{left}$ 的左子节点，把原右子节点作为 $\\textit{right}$ 的右子节点。当 $\\textit{depth}$ 大于 $2$ 时，需要继续递归往下层搜索，并将 $\\textit{depth}$ 减去 $1$，直到搜索到 $\\textit{depth}$ 为 $2$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def addOneRow(self, root: TreeNode, val: int, depth: int) -> TreeNode:\n        if root == None:\n            return\n        if depth == 1:\n            return TreeNode(val, root, None)\n        if depth == 2:\n            root.left = TreeNode(val, root.left, None)\n            root.right = TreeNode(val, None, root.right)\n        else:\n            root.left = self.addOneRow(root.left, val, depth - 1)\n            root.right = self.addOneRow(root.right, val, depth - 1)\n        return root\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public TreeNode addOneRow(TreeNode root, int val, int depth) {\n        if (root == null) {\n            return null;\n        }\n        if (depth == 1) {\n            return new TreeNode(val, root, null);\n        }\n        if (depth == 2) {\n            root.left = new TreeNode(val, root.left, null);\n            root.right = new TreeNode(val, null, root.right);\n        } else {\n            root.left = addOneRow(root.left, val, depth - 1);\n            root.right = addOneRow(root.right, val, depth - 1);\n        }\n        return root;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public TreeNode AddOneRow(TreeNode root, int val, int depth) {\n        if (root == null) {\n            return null;\n        }\n        if (depth == 1) {\n            return new TreeNode(val, root, null);\n        }\n        if (depth == 2) {\n            root.left = new TreeNode(val, root.left, null);\n            root.right = new TreeNode(val, null, root.right);\n        } else {\n            root.left = AddOneRow(root.left, val, depth - 1);\n            root.right = AddOneRow(root.right, val, depth - 1);\n        }\n        return root;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    TreeNode* addOneRow(TreeNode* root, int val, int depth) {\n        if (root == nullptr) {\n            return nullptr;\n        }\n        if (depth == 1) {\n            return new TreeNode(val, root, nullptr);\n        }\n        if (depth == 2) {\n            root->left = new TreeNode(val, root->left, nullptr);\n            root->right = new TreeNode(val, nullptr, root->right);\n        } else {\n            root->left = addOneRow(root->left, val, depth - 1);\n            root->right = addOneRow(root->right, val, depth - 1);\n        }\n        return root;\n    }\n};\n```\n\n```C [sol1-C]\nstruct TreeNode* addOneRow(struct TreeNode* root, int val, int depth) {\n    if (root == NULL) {\n            return NULL;\n        }\n        struct TreeNode *node = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n        if (depth == 1) {\n            node = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n            node->val = val;\n            node->left = root;\n            node->right = NULL;\n            return node;\n        }\n        if (depth == 2) {\n            node = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n            node->val = val;\n            node->left = root->left;\n            node->right = NULL;\n            root->left = node;\n            node = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n            node->val = val;\n            node->left = NULL;\n            node->right = root->right;\n            root->right = node;\n        } else {\n            root->left = addOneRow(root->left, val, depth - 1);\n            root->right = addOneRow(root->right, val, depth - 1);\n        }\n        return root;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar addOneRow = function(root, val, depth) {\n    if (!root) {\n        return null;\n    }\n    if (depth === 1) {\n        return new TreeNode(val, root, null);\n    }\n    if (depth === 2) {\n        root.left = new TreeNode(val, root.left, null);\n        root.right = new TreeNode(val, null, root.right);\n    } else {\n        root.left = addOneRow(root.left, val, depth - 1);\n        root.right = addOneRow(root.right, val, depth - 1);\n    }\n    return root;\n};\n```\n\n```go [sol1-Golang]\nfunc addOneRow(root *TreeNode, val, depth int) *TreeNode {\n    if root == nil {\n        return nil\n    }\n    if depth == 1 {\n        return &TreeNode{val, root, nil}\n    }\n    if depth == 2 {\n        root.Left = &TreeNode{val, root.Left, nil}\n        root.Right = &TreeNode{val, nil, root.Right}\n    } else {\n        root.Left = addOneRow(root.Left, val, depth-1)\n        root.Right = addOneRow(root.Right, val, depth-1)\n    }\n    return root\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为输入的树的节点数。最坏情况下，需要遍历整棵树。\n\n- 空间复杂度：$O(n)$，递归的深度最多为 $O(n)$。\n\n#### 方法二：广度优先搜索\n\n**思路**\n\n与深度优先搜索类似，我们用广度优先搜索找到要加的一行的上一行，然后对这一行的每个节点 $\\textit{node}$，都新增两个节点 $\\textit{left}$ 和 $\\textit{right}$ 作为 $\\textit{node}$ 的新子节点，并把原左子节点作为 $\\textit{left}$ 的左子节点，把原右子节点作为 $\\textit{right}$ 的右子节点。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def addOneRow(self, root: TreeNode, val: int, depth: int) -> TreeNode:\n        if depth == 1:\n            return TreeNode(val, root, None)\n        curLevel = [root]\n        for _ in range(1, depth - 1):\n            tmpt = []\n            for node in curLevel:\n                if node.left:\n                    tmpt.append(node.left)\n                if node.right:\n                    tmpt.append(node.right)\n            curLevel = tmpt\n        for node in curLevel:\n            node.left = TreeNode(val, node.left, None)\n            node.right = TreeNode(val, None, node.right)\n        return root\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public TreeNode addOneRow(TreeNode root, int val, int depth) {\n        if (depth == 1) {\n            return new TreeNode(val, root, null);\n        }\n        List<TreeNode> curLevel = new ArrayList<TreeNode>();\n        curLevel.add(root);\n        for (int i = 1; i < depth - 1; i++) {\n            List<TreeNode> tmpt = new ArrayList<TreeNode>();\n            for (TreeNode node : curLevel) {\n                if (node.left != null) {\n                    tmpt.add(node.left);\n                }\n                if (node.right != null) {\n                    tmpt.add(node.right);\n                }\n            }\n            curLevel = tmpt;\n        }\n        for (TreeNode node : curLevel) {\n            node.left = new TreeNode(val, node.left, null);\n            node.right = new TreeNode(val, null, node.right);\n        }\n        return root;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public TreeNode AddOneRow(TreeNode root, int val, int depth) {\n        if (depth == 1) {\n            return new TreeNode(val, root, null);\n        }\n        IList<TreeNode> curLevel = new List<TreeNode>();\n        curLevel.Add(root);\n        for (int i = 1; i < depth - 1; i++) {\n            IList<TreeNode> tmpt = new List<TreeNode>();\n            foreach (TreeNode node in curLevel) {\n                if (node.left != null) {\n                    tmpt.Add(node.left);\n                }\n                if (node.right != null) {\n                    tmpt.Add(node.right);\n                }\n            }\n            curLevel = tmpt;\n        }\n        foreach (TreeNode node in curLevel) {\n            node.left = new TreeNode(val, node.left, null);\n            node.right = new TreeNode(val, null, node.right);\n        }\n        return root;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    TreeNode* addOneRow(TreeNode* root, int val, int depth) {\n        if (depth == 1) {\n            return new TreeNode(val, root, nullptr);\n        }\n        vector<TreeNode *> curLevel(1, root);\n        for (int i = 1; i < depth - 1; i++) {\n            vector<TreeNode *> tmpt;\n            for (auto &node : curLevel) {\n                if (node->left != nullptr) {\n                    tmpt.emplace_back(node->left);\n                }\n                if (node->right != nullptr) {\n                    tmpt.emplace_back(node->right);\n                }\n            }\n            curLevel = move(tmpt);\n        }\n        for (auto &node : curLevel) {\n            node->left = new TreeNode(val, node->left, nullptr);\n            node->right = new TreeNode(val, nullptr, node->right);\n        }\n        return root;\n    }\n};\n```\n\n```C [sol2-C]\n#define MAX_NODE_SIZE 10000\n\nstruct TreeNode* addOneRow(struct TreeNode* root, int val, int depth) {\n    struct TreeNode* node = NULL;\n    if (depth == 1) {\n        node = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n        node->val = val;\n        node->left = root;\n        node->right = NULL;\n        return node;\n    }\n    struct TreeNode **queue = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * MAX_NODE_SIZE);\n    int head = 0, tail = 0;\n    queue[tail++] = root;\n    for (int i = 1; i < depth - 1; i++) {\n        int sz = tail - head;\n        for (int j = 0; j < sz; j++) {\n            if (queue[head]->left != NULL) {\n                queue[tail++] = queue[head]->left;\n            }\n            if (queue[head]->right != NULL) {\n                queue[tail++] = queue[head]->right;\n            }\n            head++;\n        }\n    }\n    for (; head != tail; head++) {\n        node = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n        node->val = val;\n        node->left = queue[head]->left;\n        node->right = NULL;\n        queue[head]->left = node;\n        node = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n        node->val = val;\n        node->left = NULL;\n        node->right = queue[head]->right;\n        queue[head]->right = node;\n    }\n    return root;\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar addOneRow = function(root, val, depth) {\n    if (depth === 1) {\n        return new TreeNode(val, root, null);\n    }\n    let curLevel = [];\n    curLevel.push(root);\n    for (let i = 1; i < depth - 1; i++) {\n        const tmp = [];\n        for (const node of curLevel) {\n            if (node.left) {\n                tmp.push(node.left);\n            }\n            if (node.right) {\n                tmp.push(node.right);\n            }\n        }\n        curLevel = tmp;\n    }\n    for (const node of curLevel) {\n        node.left = new TreeNode(val, node.left, null);\n        node.right = new TreeNode(val, null, node.right);\n    }\n    return root;\n};\n```\n\n```go [sol2-Golang]\nfunc addOneRow(root *TreeNode, val, depth int) *TreeNode {\n    if depth == 1 {\n        return &TreeNode{val, root, nil}\n    }\n    nodes := []*TreeNode{root}\n    for i := 1; i < depth-1; i++ {\n        tmp := nodes\n        nodes = nil\n        for _, node := range tmp {\n            if node.Left != nil {\n                nodes = append(nodes, node.Left)\n            }\n            if node.Right != nil {\n                nodes = append(nodes, node.Right)\n            }\n        }\n    }\n    for _, node := range nodes {\n        node.Left = &TreeNode{val, node.Left, nil}\n        node.Right = &TreeNode{val, nil, node.Right}\n    }\n    return root\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为输入的树的节点数。最坏情况下，需要遍历整棵树。\n\n- 空间复杂度：$O(n)$，数组空间开销最多为 $O(n)$。"
}