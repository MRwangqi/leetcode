{
	"titleSlug": "find-good-days-to-rob-the-bank",
	"slug": "gua-he-da-jie-yin-xing-de-ri-zi-by-leetc-z6r1",
	"url": "https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/solution/gua-he-da-jie-yin-xing-de-ri-zi-by-leetc-z6r1/",
	"content": "#### 方法一：动态规划\n\n**思路**\n\n题目中第 $i$ 天适合打劫需满足：第 $i$ 天前连续 $\\textit{time}$ 天警卫数目都是非递增与第 $i$ 天后连续 $\\textit{time}$ 天警卫数目都是非递减。只需要预先计算出第 $i$ 天前警卫数目连续非递增的天数以及第 $i$ 天后警卫数目连续非递减的天数即可判断第 $i$ 天是否适合打劫。设第 $i$ 天前警卫数目连续非递增的天数为 $\\textit{left}_i$，第 $i$ 天后警卫数目连续非递减的天数为 $\\textit{right}_i$，当第 $i$ 天同时满足 $\\textit{left}_i \\ge \\textit{time},\\textit{right}_i \\ge \\textit{time}$ 时，即可认定第 $i$ 天适合打劫。计算连续非递增和非递减的天数的方法如下：\n\n+ 如果第 $i$ 天的警卫数目小于等于第 $i-1$ 天的警卫数目，假设已知第 $i-1$ 天前有 $j$ 天连续非递增，则此时满足 $\\textit{security}_{i-1} \\le \\textit{security}_{i-2} \\cdots \\le \\textit{security}_{i-j-1}$，已知 $\\textit{security}_i \\le \\textit{security}_{i-1}$，可推出 $\\textit{security}_{i} \\le \\textit{security}_{i-1} \\cdots \\le \\textit{security}_{i-j-1}$，则此时 $\\textit{left}_i = j + 1 = \\textit{left}_{i-1} + 1$；如果第 $i$ 天的警卫数目大于第 $i-1$ 天的警卫数目，则此时 $\\textit{left}_i = 0$。\n\n+ 如果第 $i$ 天的警卫数目小于等于第 $i+1$ 天的警卫数目，假设已知第 $i+1$ 天后有 $j$ 天连续非递减，则此时满足 $\\textit{security}_{i+1} \\le \\textit{security}_{i+2} \\cdots \\le \\textit{security}_{i+j+1}$，已知 $\\textit{security}_i \\le \\textit{security}_{i+1}$，可推出 $\\textit{security}_{i} \\le \\textit{security}_{i+1} \\cdots \\le \\textit{security}_{i+j+1}$，则此时 $\\textit{right}_i = j + 1 = \\textit{right}_{i+1} + 1$；如果第 $i$ 天的警卫数目大于第 $i+1$ 天的警卫数目，则此时 $\\textit{right}_i = 0$。\n\n依次检测所有的日期，即可得到所有适合打劫的日子。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\n        n = len(security)\n        left = [0] * n\n        right = [0] * n\n        for i in range(1, n):\n            if security[i] <= security[i - 1]:\n                left[i] = left[i - 1] + 1\n            if security[n - i - 1] <= security[n - i]:\n                right[n - i - 1] = right[n - i] + 1\n        return [i for i in range(time, n - time) if left[i] >= time and right[i] >= time]\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\n        int n = security.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        for (int i = 1; i < n; i++) {\n            if (security[i] <= security[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n            if (security[n - i - 1] <= security[n - i]) {\n                right[n - i - 1] = right[n - i] + 1;\n            }\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i = time; i < n - time; i++) {\n            if (left[i] >= time && right[i] >= time) {\n                ans.add(i);    \n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\n        int n = security.size();\n        vector<int> left(n);\n        vector<int> right(n);\n        for (int i = 1; i < n; i++) {\n            if (security[i] <= security[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n            if (security[n - i - 1] <= security[n - i]) {\n                right[n - i - 1] = right[n - i] + 1;\n            }\n        }\n\n        vector<int> ans;\n        for (int i = time; i < n - time; i++) {\n            if (left[i] >= time && right[i] >= time) {\n                ans.emplace_back(i);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public IList<int> GoodDaysToRobBank(int[] security, int time) {\n        int n = security.Length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        for (int i = 1; i < n; i++) {\n            if (security[i] <= security[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n            if (security[n - i - 1] <= security[n - i]) {\n                right[n - i - 1] = right[n - i] + 1;\n            }\n        }\n\n        IList<int> ans = new List<int>();\n        for (int i = time; i < n - time; i++) {\n            if (left[i] >= time && right[i] >= time) {\n                ans.Add(i);    \n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C [sol1-C]\nint* goodDaysToRobBank(int* security, int securitySize, int time, int* returnSize) {\n    int * left = (int *)malloc(sizeof(int) * securitySize);\n    int * right = (int *)malloc(sizeof(int) * securitySize);\n    memset(left, 0, sizeof(int) * securitySize);\n    memset(right, 0, sizeof(int) * securitySize);\n    for (int i = 1; i < securitySize; i++) {\n        if (security[i] <= security[i - 1]) {\n            left[i] = left[i - 1] + 1;\n        }\n        if (security[securitySize - i - 1] <= security[securitySize - i]) {\n            right[securitySize - i - 1] = right[securitySize - i] + 1;\n        }\n    }\n\n    int * ans = (int *)malloc(sizeof(int) * securitySize);\n    int pos = 0;\n    for (int i = time; i < securitySize - time; i++) {\n        if (left[i] >= time && right[i] >= time) {\n            ans[pos++] = i;\n        }\n    }\n    free(left);\n    free(right);\n    *returnSize = pos;\n    return ans;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar goodDaysToRobBank = function(security, time) {\n    const n = security.length;\n    const left = new Array(n).fill(0);\n    const right = new Array(n).fill(0);\n    for (let i = 1; i < n; i++) {\n        if (security[i] <= security[i - 1]) {\n            left[i] = left[i - 1] + 1;\n        }\n        if (security[n - i - 1] <= security[n - i]) {\n            right[n - i - 1] = right[n - i] + 1;\n        }\n    }\n\n    const ans = [];\n    for (let i = time; i < n - time; i++) {\n        if (left[i] >= time && right[i] >= time) {\n            ans.push(i);    \n        }\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc goodDaysToRobBank(security []int, time int) (ans []int) {\n    n := len(security)\n    left := make([]int, n)\n    right := make([]int, n)\n    for i := 1; i < n; i++ {\n        if security[i] <= security[i-1] {\n            left[i] = left[i-1] + 1\n        }\n        if security[n-i-1] <= security[n-i] {\n            right[n-i-1] = right[n-i] + 1\n        }\n    }\n\n    for i := time; i < n-time; i++ {\n        if left[i] >= time && right[i] >= time {\n            ans = append(ans, i)\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{security}$ 的长度。需要遍历数组求出第 $i$ 天前连续非递增的天数与第 $i$ 天后连续非递减的天数，然后再遍历数组检测第 $i$ 天是否适合打劫。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{security}$ 的长度。需要 $O(n)$ 的空间来存储第 $i$ 天前连续非递增的天数与第 $i$ 天后连续非递减的天数。"
}