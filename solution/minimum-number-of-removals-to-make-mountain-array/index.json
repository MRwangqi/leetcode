{
	"titleSlug": "minimum-number-of-removals-to-make-mountain-array",
	"slug": "fen-bie-jiesuan-by-mindexercise-qpa4",
	"url": "https://leetcode-cn.com/problems/minimum-number-of-removals-to-make-mountain-array/solution/fen-bie-jiesuan-by-mindexercise-qpa4/",
	"content": "### 解题思路\n![image.png](https://pic.leetcode-cn.com/1658305341-yotOnl-image.png)\n\n参考https://leetcode.cn/problems/longest-increasing-subsequence/solution/pythonjavajavascriptgo-lis-zui-chang-sha-e36x/\n\n### 代码\n\n```golang\nfunc minimumMountainRemovals(nums []int) int {\n    res := len(nums)\n\n    for i := 1; i < len(nums) - 1; i ++ {\n        target := nums[i]\n        inc := countInc(nums[:i], target) // 前半段需要删除的数量\n\n        if inc >= i {\n            continue\n        }\n\n        dec := countDec(nums[i + 1:], target) // 后半段需要删除的数量\n\n        if dec + i >= len(nums) - 1 {\n            continue\n        }\n\n        //fmt.Println(i, nums[i], inc, dec)\n\n        res = min(res, inc + dec)\n    }\n\n    return res\n\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc countDec(nums []int, target int) int {\n    stack := []int{}\n    for i := len(nums) - 1; i >= 0; i -- {\n        num := nums[i]\n\n        if num >= target {\n            continue\n        }\n\n        l := 0\n        for r := len(stack); l < r; {\n            mid := (l + r) / 2\n            if stack[mid] >= num {\n                r = mid\n            } else {\n                l = mid + 1\n            }\n        }\n        if l == len(stack) {\n            stack = append(stack, num)\n        } else {\n            stack[l] = num\n        }\n    }\n    return len(nums) - len(stack)\n}\n\nfunc countInc(nums []int, target int) int {\n    // 计算以target为最大值的最长递增子序列，用dp\n    // 单调栈只能计算连续的\n\n    stack := []int{}\n    for _, num := range nums {\n\n        if num >= target {\n            continue\n        }\n\n        l := 0\n        for r := len(stack); l < r; {\n            mid := (l + r) / 2\n            if stack[mid] >= num {\n                r = mid\n            } else {\n                l = mid + 1\n            }\n        }\n        if l == len(stack) {\n            stack = append(stack, num)\n        } else {\n            stack[l] = num\n        }\n    }\n    return len(nums) - len(stack)\n}\n```"
}