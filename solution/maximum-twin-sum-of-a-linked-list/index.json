{
	"titleSlug": "maximum-twin-sum-of-a-linked-list",
	"slug": "lian-biao-zui-da-luan-sheng-he-by-leetco-uoc7",
	"url": "https://leetcode-cn.com/problems/maximum-twin-sum-of-a-linked-list/solution/lian-biao-zui-da-luan-sheng-he-by-leetco-uoc7/",
	"content": "#### 方法一：快满指针 + 反转链表\n\n**思路与算法**\n\n我们首先使用快满指针找出后一半部分的起始节点。具体地，我们用慢指针 $\\textit{slow}$ 指向 $\\textit{head}$，快指针 $\\textit{fast}$ 指向 $\\textit{head}$ 的下一个节点。随后，我们每次将 $\\textit{slow}$ 向后移动一个节点，同时 $\\textit{fast}$ 向后移动两个节点。当 $\\textit{fast}$ 到达链表的最后一个节点（即下一个节点是空节点）时：\n\n- $\\textit{slow}$ 刚好指向链表前一半部分的末尾节点；\n\n- $\\textit{slow}$ 的下一个节点即为链表后一半部分的起始节点。\n\n随后，我们需要将链表的后一半部分进行反转。如果读者不知道如何实现这一步，可以参考[「206. 反转链表」的官方题解](https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/)。当链表的后一半部分被反转后，原先我们需要求出的是第 $i$ 个节点和第 $n-1-i$ 的节点的和，此时就变成了求出第 $i$ 个节点和第 $i+n/2$ 个节点的和。\n\n这样一来，我们就可以使用两个指针分别从「链表前一半部分的起始节点」和「链表后一半部分的起始节点」开始遍历。在遍历的过程中，我们计算两个指针指向节点的元素之和，并维护最大值即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int pairSum(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        while (fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        // 反转链表\n        ListNode* last = slow->next;\n        while (last->next) {\n            ListNode* cur = last->next;\n            last->next = cur->next;\n            cur->next = slow->next;\n            slow->next = cur;\n        }\n        int ans = 0;\n        ListNode* x = head;\n        ListNode* y = slow->next;\n        while (y) {\n            ans = max(ans, x->val + y->val);\n            x = x->next;\n            y = y->next;\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def pairSum(self, head: Optional[ListNode]) -> int:\n        slow, fast = head, head.next\n        while fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 反转链表\n        last = slow.next\n        while last.next:\n            cur = last.next\n            last.next = cur.next\n            cur.next = slow.next\n            slow.next = cur\n\n        ans = 0\n        x, y = head, slow.next\n        while y:\n            ans = max(ans, x.val + y.val)\n            x, y = x.next, y.next\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$。\n\n- 空间复杂度：$O(1)$。"
}