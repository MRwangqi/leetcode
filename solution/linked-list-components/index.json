{
	"titleSlug": "linked-list-components",
	"slug": "lian-biao-zu-jian-by-leetcode-solution-5f91",
	"url": "https://leetcode-cn.com/problems/linked-list-components/solution/lian-biao-zu-jian-by-leetcode-solution-5f91/",
	"content": "#### 方法一：计算组件的起始位置\n\n**思路**\n\n此题需要计算组件的个数，只需在链表中计算有多少组件的起始位置即可。当一个节点满足以下条件之一时，它是组件的起始位置：\n\n- 节点的值在数组 $\\textit{nums}$ 中且节点位于链表起始位置；\n- 节点的值在数组 $\\textit{nums}$ 中且节点的前一个点不在数组 $\\textit{nums}$ 中。\n\n遍历链表，计算出满足条件的点的个数即可。因为需要多次判断值是否位于数组 $\\textit{nums}$ 中，用一个哈希集合保存数组 $\\textit{nums}$ 中的点可以降低时间复杂度。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\n        numsSet = set(nums)\n        inSet = False\n        res = 0\n        while head:\n            if head.val not in numsSet:\n                inSet = False\n            elif not inSet:\n                inSet = True\n                res += 1\n            head = head.next\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int numComponents(ListNode head, int[] nums) {\n        Set<Integer> numsSet = new HashSet<Integer>();\n        for (int num : nums) {\n            numsSet.add(num);\n        }\n        boolean inSet = false;\n        int res = 0;\n        while (head != null) {\n            if (numsSet.contains(head.val)) {\n                if (!inSet) {\n                    inSet = true;\n                    res++;\n                }\n            } else {\n                inSet = false;\n            }\n            head = head.next;\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int NumComponents(ListNode head, int[] nums) {\n        ISet<int> numsSet = new HashSet<int>();\n        foreach (int num in nums) {\n            numsSet.Add(num);\n        }\n        bool inSet = false;\n        int res = 0;\n        while (head != null) {\n            if (numsSet.Contains(head.val)) {\n                if (!inSet) {\n                    inSet = true;\n                    res++;\n                }\n            } else {\n                inSet = false;\n            }\n            head = head.next;\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int numComponents(ListNode* head, vector<int>& nums) {\n        unordered_set<int> numsSet;\n        for (int num : nums) {\n            numsSet.emplace(num);\n        }\n        bool inSet = false;\n        int res = 0;\n        while (head != nullptr) {\n            if (numsSet.count(head->val)) {\n                if (!inSet) {\n                    inSet = true;\n                    res++;\n                }\n            } else {\n                inSet = false;\n            }\n            head = head->next;\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\ntypedef struct {\n    int key;\n    UT_hash_handle hh;\n} HashItem; \n\nHashItem *hashFindItem(HashItem **obj, int key) {\n    HashItem *pEntry = NULL;\n    HASH_FIND_INT(*obj, &key, pEntry);\n    return pEntry;\n}\n\nbool hashAddItem(HashItem **obj, int key) {\n    if (hashFindItem(obj, key)) {\n        return false;\n    }\n    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));\n    pEntry->key = key;\n    HASH_ADD_INT(*obj, key, pEntry);\n    return true;\n}\n\nvoid hashFree(HashItem **obj) {\n    HashItem *curr = NULL, *tmp = NULL;\n    HASH_ITER(hh, *obj, curr, tmp) {\n        HASH_DEL(*obj, curr);  \n        free(curr);             \n    }\n}\n\nint numComponents(struct ListNode* head, int* nums, int numsSize) {\n    HashItem *numsSet = NULL;\n    for (int i = 0; i < numsSize; i++) {\n        hashAddItem(&numsSet, nums[i]);\n    }\n    bool inSet = false;\n    int res = 0;\n    while (head != NULL) {\n        if (hashFindItem(&numsSet, head->val) != NULL) {\n            if (!inSet) {\n                inSet = true;\n                res++;\n            }\n        } else {\n            inSet = false;\n        }\n        head = head->next;\n    }\n    hashFree(&numsSet);\n    return res;\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar numComponents = function(head, nums) {\n    const numsSet = new Set();\n    for (const num of nums) {\n        numsSet.add(num);\n    }\n    let inSet = false;\n    let res = 0;\n    while (head) {\n        if (numsSet.has(head.val)) {\n            if (!inSet) {\n                inSet = true;\n                res++;\n            }\n        } else {\n            inSet = false;\n        }\n        head = head.next;\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc numComponents(head *ListNode, nums []int) (ans int) {\n    set := make(map[int]struct{}, len(nums))\n    for _, v := range nums {\n        set[v] = struct{}{}\n    }\n    for inSet := false; head != nil; head = head.Next {\n        if _, ok := set[head.Val]; !ok {\n            inSet = false\n        } else if !inSet {\n            inSet = true\n            ans++\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，需要遍历一遍链表。\n\n- 空间复杂度：$O(m)$，其中 $m$ 是数组 $\\textit{nums}$ 的长度，需要一个哈希集合来存储 $\\textit{nums}$ 的元素。"
}