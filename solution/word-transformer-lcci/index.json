{
	"titleSlug": "word-transformer-lcci",
	"slug": "by-xiaowei_algorithm-vp2o",
	"url": "https://leetcode-cn.com/problems/word-transformer-lcci/solution/by-xiaowei_algorithm-vp2o/",
	"content": "**解题思路：**\r\n\r\n1. 和[127. 单词接龙](/problems/word-ladder/)、[剑指 Offer II 108. 单词演变](/problems/om3reC/)、[126. 单词接龙 II](/problems/word-ladder-ii/)、[433. 最小基因变化](/problems/minimum-genetic-mutation/)、[752. 打开转盘锁](/problems/open-the-lock/)、[剑指 Offer II 109. 开密码锁](/problems/zlDJc7/)基本差不多\r\n2. 就是常规的`BFS`，深搜、回溯啥的完全不用\r\n3. 队列存路径就行，找到符合答案的一条路径直接返回即可，而且我这个答案还是最短路径，`126. 单词接龙 II`算进阶版\r\n4. 更新\r\n- 本系列题解与`2022`年`6`月`8`日重写，干掉了大部分单向`BSF`中的`VIS`集合\r\n- `2022`年`6`月`27`，官方加了`case`，导致`单词接龙2`过不了，需要用回溯法\r\n\r\n**代码如下：**\r\n\r\n\r\n[面试题 17.22. 单词转换](/problems/word-transformer-lcci/)\r\n```java \r\n//面试题 17.22. 单词转换\r\nclass Solution {\r\n    public List<String> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n        List<String> list = new ArrayList<>();\r\n        Set<String> set = new HashSet<>(wordList);\r\n        if(!set.contains(endWord)) {\r\n            return list;\r\n        }\r\n        Queue<List<String>> queue = new ArrayDeque<>();\r\n        list.add(beginWord);\r\n        queue.add(list);\r\n        set.remove(beginWord);\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            while (size > 0) {\r\n                List<String> curPath = queue.poll();\r\n                String curWord = curPath.get(curPath.size() - 1);\r\n                for (int i = 0; i < curWord.length(); i++) {\r\n                    char[] ch = curWord.toCharArray();\r\n                    char temp = ch[i];\r\n                    for (char j = 'a'; j <= 'z'; j++) {\r\n                        if (j == temp) {\r\n                            continue;\r\n                        }\r\n                        ch[i] = j;\r\n                        String nextWord = new String(ch);\r\n                        if (set.contains(nextWord)) {\r\n                            List<String> newPath = new ArrayList<>(curPath);\r\n                            newPath.add(nextWord);\r\n                            set.remove(nextWord);\r\n                            if (nextWord.equals(endWord)) {\r\n                                return newPath;\r\n                            } else {\r\n                                queue.add(newPath);\r\n                            }\r\n                        }\r\n                    }\r\n                    ch[i] = temp;\r\n                }\r\n                size--;\r\n            }\r\n        }\r\n        return new ArrayList<>();\r\n    }\r\n}\r\n```\r\n[127. 单词接龙](/problems/word-ladder/)\r\n[剑指 Offer II 108. 单词演变](/problems/om3reC/)\r\n```java []\r\n//127. 单词接龙\r\n//剑指 Offer II 108. 单词演变\r\n//单向BFS\r\nclass Solution {\r\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\r\n        Set<String> set = new HashSet<>(wordList);\r\n        if (!set.contains(endWord)) {\r\n            return 0;\r\n        }\r\n        Queue<String> queue = new ArrayDeque<>();\r\n        queue.add(beginWord);\r\n        set.remove(beginWord);\r\n        int step = 1;\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            while (size > 0) {\r\n                String cur = queue.poll();\r\n                char[] ch = cur.toCharArray();\r\n                for (int i = 0; i < ch.length; i++) {\r\n                    char temp = ch[i];\r\n                    for (char j = 'a'; j <= 'z'; j++) {\r\n                        if (j == temp) {\r\n                            continue;\r\n                        }\r\n                        ch[i] = j;\r\n                        String next = new String(ch);\r\n                        if (set.contains(next)) {\r\n                            if (next.equals(endWord)) {\r\n                                return step + 1;\r\n                            }\r\n                            queue.add(next);\r\n                            set.remove(next);\r\n                        }\r\n                    }\r\n                    ch[i] = temp;\r\n                }\r\n                size--;\r\n            }\r\n            step++;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n```\r\n```java []\r\n//127. 单词接龙\r\n//剑指 Offer II 108. 单词演变\r\n//双向BFS\r\n//双向BFS\r\nclass Solution {\r\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\r\n         Set<String> set = new HashSet<>(wordList);\r\n        if (!set.contains(endWord)) {\r\n            return 0;\r\n        }\r\n        Set<String> vis = new HashSet<>();\r\n        Queue<String> beginQueue = new ArrayDeque<>();\r\n        Queue<String> endQueue = new ArrayDeque<>();\r\n        beginQueue.add(beginWord);\r\n        endQueue.add(endWord);\r\n        int step = 1;\r\n        while (!beginQueue.isEmpty() && !endQueue.isEmpty()) {\r\n            int beginSize = beginQueue.size();\r\n            int endSize = endQueue.size();\r\n            int res = 0;\r\n            if (beginSize <= endSize) {\r\n                res = getStep(step, beginQueue, endQueue, set, vis);\r\n            } else {\r\n                res = getStep(step, endQueue, beginQueue, set, vis);\r\n            }\r\n\r\n            if (res != -1) {\r\n                return res;\r\n            }\r\n            step++;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    private int getStep(int step, Queue<String> beginQueue, Queue<String> endQueue, Set<String> set, Set<String> vis) {\r\n        int size = beginQueue.size();\r\n        while (size > 0) {\r\n            String cur = beginQueue.poll();\r\n            char[] ch = cur.toCharArray();\r\n            for (int i = 0; i < ch.length; i++) {\r\n                char temp = ch[i];\r\n                for (char j = 'a'; j <= 'z'; j++) {\r\n                    if (j == temp) {\r\n                        continue;\r\n                    }\r\n                    ch[i] = j;\r\n                    String next = new String(ch);\r\n                    if (!set.contains(next)) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (endQueue.contains(next)) {\r\n                        return step + 1;\r\n                    }\r\n\r\n                    if (!vis.contains(next)) {\r\n                        vis.add(next);\r\n                        beginQueue.add(next);\r\n                    }\r\n                }\r\n                ch[i] = temp;\r\n            }\r\n            size--;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```\r\n[126. 单词接龙 II](/problems/word-ladder-ii/)\r\n```java []\r\n//126. 单词接龙 II\r\n//BFS超时\r\nclass Solution {\r\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n        List<List<String>> res = new ArrayList<>();\r\n        Set<String> set = new HashSet<>(wordList);\r\n        if (!set.contains(endWord)) {\r\n            return res;\r\n        }\r\n        Queue<List<String>> queue = new ArrayDeque<>();\r\n        Set<String> vis = new HashSet<>();\r\n        set.remove(beginWord);\r\n        List<String> path = new ArrayList<>();\r\n        path.add(beginWord);\r\n        queue.add(path);\r\n        while (!queue.isEmpty()) {\r\n            int szie = queue.size();\r\n            while (szie > 0) {\r\n                List<String> curPath = queue.poll();\r\n                String curWord = curPath.get(curPath.size() - 1);\r\n                char[] ch = curWord.toCharArray();\r\n                for (int i = 0; i < ch.length; i++) {\r\n                    char temp = ch[i];\r\n                    for (char j = 'a'; j <= 'z'; j++) {\r\n                        if (temp == j) {\r\n                            continue;\r\n                        }\r\n                        ch[i] = j;\r\n                        String nextWord = new String(ch);\r\n                        if (set.contains(nextWord)) {\r\n                            List<String> newPath = new ArrayList<>(curPath);\r\n                            newPath.add(nextWord);\r\n                            vis.add(nextWord);\r\n                            if (!nextWord.equals(endWord)) {\r\n                                queue.add(newPath);\r\n                            } else {\r\n                                res.add(newPath);\r\n                            }\r\n                        }\r\n                    }\r\n                    ch[i] = temp;\r\n                }\r\n                szie--; \r\n            }\r\n            for (String s : vis) {\r\n                set.remove(s);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n```java []\r\n//126. 单词接龙 II\r\n//BFS+DFS 不超时\r\nclass Solution {\r\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n        List<List<String>> res = new ArrayList<>();\r\n        if (beginWord == null || endWord == null || wordList == null) {\r\n            return res;\r\n        }\r\n        Set<String> wordSet = new HashSet<>(wordList);\r\n        if (!wordSet.contains(endWord)) {\r\n            return res;\r\n        }\r\n        Map<String, List<String>> graph = new HashMap<>();\r\n        Queue<String> queue = new ArrayDeque<>();\r\n        queue.add(beginWord);\r\n        boolean flag = false;\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            Set<String> vis = new HashSet<>();\r\n            while (size > 0) {\r\n                String cur = queue.poll();\r\n                char[] charArray = cur.toCharArray();\r\n                for (int i = 0; i < charArray.length; i++) {\r\n                    char temp = charArray[i];\r\n                    for (char c = 'a'; c <= 'z'; c++) {\r\n                        if (temp == c) {\r\n                            continue;\r\n                        }\r\n                        charArray[i] = c;\r\n                        String str = new String(charArray);\r\n                        if (wordSet.contains(str)) {\r\n                            if (str.equals(endWord)) {\r\n                                flag = true;\r\n                            }\r\n                            if (!vis.contains(str)) {\r\n                                List<String> list = new ArrayList<>();\r\n                                list.add(cur);\r\n                                graph.put(str, list);\r\n                                queue.add(str);\r\n                                vis.add(str);\r\n                            } else {\r\n                                List<String> list = graph.get(str);\r\n                                list.add(cur);\r\n                                graph.put(str, list);\r\n                            }\r\n                        }\r\n                    }\r\n                    charArray[i] = temp;\r\n                }\r\n                size--;\r\n            }\r\n            for (String s : vis) {\r\n                wordSet.remove(s);\r\n            }\r\n\r\n            if (flag) {\r\n                LinkedList<String> path = new LinkedList<>();\r\n                path.add(endWord);\r\n                dfs(res, path, endWord, beginWord, graph);\r\n                return res;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public void dfs(List<List<String>> res, LinkedList<String> path, String cur, String endWord, Map<String, List<String>> graph) {\r\n        if (cur.equals(endWord)) {\r\n            List<String> copy = new LinkedList<>(path);\r\n            res.add(copy);\r\n            return;\r\n        }\r\n        List<String> nexts = graph.get(cur);\r\n        for (String next : nexts) {\r\n            path.addFirst(next);\r\n            dfs(res, path, next, endWord, graph);\r\n            path.removeFirst();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n[433. 最小基因变化](/problems/minimum-genetic-mutation/)\r\n```java []\r\n//433. 最小基因变化\r\n//单向BFS\r\nclass Solution {\r\n    private static final char[] CHARS = {'A', 'C', 'G', 'T'};\r\n    public int minMutation(String start, String end, String[] bank) {\r\n        if (bank == null || bank.length == 0) {\r\n            return -1;\r\n        }\r\n        int n = bank.length;\r\n        Set<String> set = new HashSet<>();\r\n        for (String str : bank) {\r\n            set.add(str);\r\n        }\r\n        if (!set.contains(end)) {\r\n            return -1;\r\n        }\r\n\r\n        Queue<String> queue = new ArrayDeque();\r\n        queue.add(start);\r\n        set.remove(start);\r\n        int step = 0;\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            while (size > 0) {\r\n                String cur = queue.poll();\r\n                char[] ch = cur.toCharArray();\r\n                for (int i = 0; i < 8; i++) {\r\n                    char temp = ch[i];\r\n                    for (char c : CHARS) {\r\n                        if (temp == c) {\r\n                            continue;\r\n                        }\r\n                        ch[i] = c;\r\n                        String next = new String(ch);\r\n                        if (set.contains(next)) {\r\n                            if (next.equals(end)) {\r\n                                return step + 1;\r\n                            }\r\n                            queue.add(next);\r\n                            set.remove(next);\r\n                        }\r\n                    }\r\n                    ch[i] = temp;\r\n                }\r\n                size--;\r\n            }\r\n            step++;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```\r\n\r\n```java []\r\n//433. 最小基因变化\r\n//双向BFS\r\nclass Solution {\r\n    private static final char[] CHARS = {'A', 'C', 'G', 'T'};\r\n    public int minMutation(String start, String end, String[] bank) {\r\n        if (bank == null || bank.length == 0) {\r\n            return -1;\r\n        }\r\n        int n = bank.length;\r\n        Set<String> set = new HashSet<>();\r\n        for (String str : bank) {\r\n            set.add(str);\r\n        }\r\n        if (!set.contains(end)) {\r\n            return -1;\r\n        }\r\n        Set<String> vis = new HashSet<>();\r\n        Queue<String> beginQueue = new ArrayDeque<>();\r\n        Queue<String> endQueue = new ArrayDeque<>();\r\n        beginQueue.add(start);\r\n        endQueue.add(end);\r\n        int step = 0;\r\n        while (!beginQueue.isEmpty() && !endQueue.isEmpty()) {\r\n            int beginSize = beginQueue.size();\r\n            int endSize = endQueue.size();\r\n            int res = 0;\r\n            if (beginSize <= endSize) {\r\n                res = getStep(step, beginQueue, endQueue, set, vis);\r\n            } else {\r\n                res = getStep(step, endQueue, beginQueue, set, vis);\r\n            }\r\n\r\n            if (res != -1) {\r\n                return res;\r\n            }\r\n            step++;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n\r\n    private int getStep(int step, Queue<String> beginQueue, Queue<String> endQueue, Set<String> set, Set<String> vis) {\r\n        int size = beginQueue.size();\r\n        while (size > 0) {\r\n            String cur = beginQueue.poll();\r\n            char[] ch = cur.toCharArray();\r\n            for (int i = 0; i < 8; i++) {\r\n                char temp = ch[i];\r\n                for (char c : CHARS) {\r\n                    if (c == temp) {\r\n                        continue;\r\n                    }\r\n                    ch[i] = c;\r\n                    String next = new String(ch);\r\n                    if (!set.contains(next)) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (endQueue.contains(next)) {\r\n                        return step + 1;\r\n                    }\r\n\r\n                    if (!vis.contains(next)) {\r\n                        vis.add(next);\r\n                        beginQueue.add(next);\r\n                    }\r\n\r\n                }\r\n                ch[i] = temp;\r\n            }\r\n            size--;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```\r\n[752. 打开转盘锁](/problems/open-the-lock/)\r\n[剑指 Offer II 109. 开密码锁](/problems/zlDJc7/)\r\n```java\r\n//752. 打开转盘锁\r\n//剑指 Offer II 109. 开密码锁\r\nclass Solution {\r\n    private static final int[] BECOME = {1, 9};\r\n    public int openLock(String[] deadends, String target) {\r\n        if (target.equals(\"0000\")) {\r\n            return 0;\r\n        }\r\n        Set<String> dead = new HashSet<>();\r\n        for (String s : deadends) {\r\n            dead.add(s);\r\n        }\r\n        if (dead.contains(\"0000\")) {\r\n            return -1;\r\n        }\r\n        Queue<String> queue = new ArrayDeque<>();\r\n        queue.add(\"0000\");\r\n        dead.add(\"0000\");\r\n        int step = 0;\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            while (size > 0) {\r\n                String cur = queue.poll();\r\n                char[] ch = cur.toCharArray();\r\n                for (int i = 0; i < 4; i++) {\r\n                    char temp = ch[i];\r\n                    int oriNum = temp - '0';\r\n                    for (int j : BECOME) {\r\n                        int nextNum = (oriNum + j) % 10;\r\n                        ch[i] = (char) (nextNum + '0');\r\n                        String next = new String(ch);\r\n                        if (!dead.contains(next)) {\r\n                            if (next.equals(target)) {\r\n                                return step + 1;\r\n                            }\r\n                            dead.add(next);\r\n                            queue.add(next);\r\n                        }\r\n                    }\r\n                    ch[i] = temp;\r\n                }\r\n                size--;\r\n            }\r\n            step++;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n```\r\n"
}