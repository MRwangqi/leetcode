{
	"titleSlug": "find-closest-number-to-zero",
	"slug": "zhao-dao-zui-jie-jin-0-de-shu-zi-by-leet-za0j",
	"url": "https://leetcode-cn.com/problems/find-closest-number-to-zero/solution/zhao-dao-zui-jie-jin-0-de-shu-zi-by-leet-za0j/",
	"content": "#### 方法一：遍历\n\n**思路与算法**\n\n一个数与 $0$ 的距离即为该数的绝对值，因此我们需要找出数组 $\\textit{nums}$ 里面绝对值最小的元素的最大值。\n\n我们遍历数组，并用 $\\textit{res}$ 来维护已遍历元素中绝对值最小且数值最大的元素，以及 $\\textit{dis}$ 来维护已遍历元素的最小绝对值。这两个变量的初值即为数组第一个元素的数值与绝对值。\n\n当我们遍历到新的元素 $\\textit{num}$ 时，我们需要比较该数绝对值 $|\\textit{num}|$ 与 $\\textit{dis}$ 的关系，此时会有三种情况:\n\n- $|\\textit{num}| < \\textit{dis}$，此时我们需要将 $\\textit{res}$ 更新为 $\\textit{num}$，并将 $\\textit{dis}$ 更新为 $|\\textit{num}|$；\n\n- $|\\textit{num}| = \\textit{dis}$，此时我们需要将 $\\textit{res}$ 更新为 $\\textit{res}$ 与 $\\textit{num}$ 的最大值；\n\n- $|\\textit{num}| > \\textit{dis}$，此时无需进行任何操作。\n\n最终，$\\textit{res}$ 即为数组 $\\textit{nums}$ 里面绝对值最小的元素的最大值，我们返回该值作为答案。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int findClosestNumber(vector<int>& nums) {\n        int res = nums[0];   // 已遍历元素中绝对值最小且数值最大的元素\n        int dis = abs(nums[0]);   // 已遍历元素的最小绝对值\n        for (int num: nums) {\n            if (abs(num) < dis) {\n                dis = abs(num);\n                res = num;\n            } else if (abs(num) == dis) {\n                res = max(res, num);\n            }\n        }\n        return res;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def findClosestNumber(self, nums: List[int]) -> int:\n        res = nums[0]   # 已遍历元素中绝对值最小且数值最大的元素\n        dis = abs(nums[0])   # 已遍历元素的最小绝对值\n        for num in nums:\n            if abs(num) < dis:\n                dis = abs(num)\n                res = num\n            elif abs(num) == dis:\n                res = max(res, num)\n        return res\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{nums}$ 的长度。即为遍历寻找对应数字的时间复杂度。\n\n- 空间复杂度：$O(1)$。"
}