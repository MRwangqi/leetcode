{
	"titleSlug": "pond-sizes-lcci",
	"slug": "dfs-bfsliang-chong-jie-fa-by-xueliangwang",
	"url": "https://leetcode-cn.com/problems/pond-sizes-lcci/solution/dfs-bfsliang-chong-jie-fa-by-xueliangwang/",
	"content": "更多优质内容，欢迎关注我的微信公众号：小王同学的学习笔记。题主今年秋招斩获多家大厂算法offer，我会根据自己的准备过程和面试经验，定期更新高质量算法笔记和秋招经验贴，欢迎勾搭！\n\n这是一道中等难度的题目。这道题如果抽象出来就是一道非常经典的广度优先遍历（BFS）的题目。针对BFS类型的题目，其实我们是有一套解题的模板：\n\n```\nqueue=collections.deque([])\nqueue.append(第一个满足条件的点)\n\nwhile queue 不空：\n    cur = queue.popleft()\n    标记我们访问过cur这个点，从而之后不会再访问到这个点\n    for 节点 in cur的所有相邻节点：\n        if 该节点有效且满足条件：\n            queue.append(该节点)\n            标记我们访问过这个节点\n```\n\n顺着这个模板，我我们可以很方便地写出如下代码：\n\n```python\nclass Solution:\n    def pondSizes(self, land: List[List[int]]) -> List[int]:\n        n = len(land)\n        m = len(land[0])\n        deque = collections.deque([])\n        rst=[]\n        for i in range(n):\n            for j in range(m):\n                if land[i][j]==0:\n                    land[i][j]=1\n                    deque.append((i,j))\n                    tmp_count = 0\n                    while deque:\n                        x,y = deque.popleft()\n                        tmp_count+=1\n                        for (dx,dy) in [(x+1,y),(x-1,y),(x,y+1),(x,y-1),(x+1,y+1),(x+1,y-1),(x-1,y+1),(x-1,y-1)]:\n                            if dx>=0 and dx<n and dy>=0 and dy<m and land[dx][dy]==0:\n                                deque.append((dx,dy))\n                                land[dx][dy]=1\n                    rst.append(tmp_count)\n        rst.sort()\n        return rst\n```\n\n\n\n当然，这道题我们也可以使用深度优先遍历（DFS）来进行解答。从我个人的经验上来讲，我们在思考DFS解法的时候，最重要的是搞清楚，**我们每个节点返回值是什么意义**？搞清楚了这个，DFS问题也就迎刃而解。关于DFS相关的解法，大家可以多写写树相关的题目，会加深大家的理解。\n\n具体到这道题，我们在DFS的时候，每个节点返回值的意义是，**与这个节点连接的下游节点的水域面积**。搞清楚了这个，我们给出代码：\n\n```python\nclass Solution:\n    def pondSizes(self, land: List[List[int]]) -> List[int]:\n        n = len(land)\n        m = len(land[0])\n        rst = []\n        def dfs(i,j):\n            land[i][j]=1\n            area = 1\n            for (dx,dy) in [(i+1,j),(i-1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:\n                if dx>=0 and dx<n and dy>=0 and dy<m and land[dx][dy]==0:\n                    area+=dfs(dx,dy)\n            return area\n\n        for i in range(n):\n            for j in range(m):\n                if land[i][j]==0:\n                    rst.append(dfs(i,j))      \n        rst.sort()\n        return rst\n```\n\n"
}