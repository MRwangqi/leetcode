{
	"titleSlug": "delete-node-in-a-bst",
	"slug": "shan-chu-er-cha-sou-suo-shu-zhong-de-jie-n6vo",
	"url": "https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/shan-chu-er-cha-sou-suo-shu-zhong-de-jie-n6vo/",
	"content": "#### 方法一：递归\n\n**思路**\n\n二叉搜索树有以下性质：\n- 左子树的所有节点（如果有）的值均小于当前节点的值；\n- 右子树的所有节点（如果有）的值均大于当前节点的值；\n- 左子树和右子树均为二叉搜索树。\n\n二叉搜索树的题目往往可以用递归来解决。此题要求删除二叉树的节点，函数 $\\textit{deleteNode}$ 的输入是二叉树的根节点 $\\textit{root}$ 和一个整数 $\\textit{key}$，输出是删除值为 $\\textit{key}$ 的节点后的二叉树，并保持二叉树的有序性。可以按照以下情况分类讨论：\n- $\\textit{root}$ 为空，代表未搜索到值为 $\\textit{key}$ 的节点，返回空。\n- $\\textit{root.val} > \\textit{key}$，表示值为 $\\textit{key}$ 的节点可能存在于 $\\textit{root}$ 的左子树中，需要递归地在 $\\textit{root.left}$ 调用 $\\textit{deleteNode}$，并返回 $\\textit{root}$。\n- $\\textit{root.val} < \\textit{key}$，表示值为 $\\textit{key}$ 的节点可能存在于 $\\textit{root}$ 的右子树中，需要递归地在 $\\textit{root.right}$ 调用 $\\textit{deleteNode}$，并返回 $\\textit{root}$。\n- $\\textit{root.val} = \\textit{key}$，$\\textit{root}$ 即为要删除的节点。此时要做的是删除 $\\textit{root}$，并将它的子树合并成一棵子树，保持有序性，并返回根节点。根据 $\\textit{root}$ 的子树情况分成以下情况讨论：\n    - $\\textit{root}$ 为叶子节点，没有子树。此时可以直接将它删除，即返回空。\n    - $\\textit{root}$ 只有左子树，没有右子树。此时可以将它的左子树作为新的子树，返回它的左子节点。\n    - $\\textit{root}$ 只有右子树，没有左子树。此时可以将它的右子树作为新的子树，返回它的右子节点。\n    - $\\textit{root}$ 有左右子树，这时可以将 $\\textit{root}$ 的后继节点（比 $\\textit{root}$ 大的最小节点，即它的右子树中的最小节点，记为 $\\textit{successor}$）作为新的根节点替代 $\\textit{root}$，并将 $\\textit{successor}$ 从 $\\textit{root}$ 的右子树中删除，使得在保持有序性的情况下合并左右子树。\n    简单证明，$\\textit{successor}$ 位于 $\\textit{root}$ 的右子树中，因此大于 $\\textit{root}$ 的所有左子节点；$\\textit{successor}$ 是 $\\textit{root}$ 的右子树中的最小节点，因此小于 $\\textit{root}$ 的右子树中的其他节点。以上两点保持了新子树的有序性。\n    在代码实现上，我们可以先寻找 $\\textit{successor}$，再删除它。$\\textit{successor}$ 是 $\\textit{root}$ 的右子树中的最小节点，可以先找到 $\\textit{root}$ 的右子节点，再不停地往左子节点寻找，直到找到一个不存在左子节点的节点，这个节点即为 $\\textit{successor}$。然后递归地在 $\\textit{root.right}$ 调用 $\\textit{deleteNode}$ 来删除 $\\textit{successor}$。因为 $\\textit{successor}$ 没有左子节点，因此这一步递归调用不会再次步入这一种情况。然后将 $\\textit{successor}$ 更新为新的 $\\textit{root}$ 并返回。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        if root is None:\n            return None\n        if root.val > key:\n            root.left = self.deleteNode(root.left, key)\n        elif root.val < key:\n            root.right = self.deleteNode(root.right, key)\n        elif root.left is None or root.right is None:\n            root = root.left if root.left else root.right\n        else:\n            successor = root.right\n            while successor.left:\n                successor = successor.left\n            successor.right = self.deleteNode(root.right, successor.val)\n            successor.left = root.left\n            return successor\n        return root\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (root == nullptr) {\n            return nullptr;\n        }\n        if (root->val > key) {\n            root->left = deleteNode(root->left, key);\n            return root;\n        }\n        if (root->val < key) {\n            root->right = deleteNode(root->right, key);\n            return root;\n        }\n        if (root->val == key) {\n            if (!root->left && !root->right) {\n                return nullptr;\n            }\n            if (!root->right) {\n                return root->left;\n            }\n            if (!root->left) {\n                return root->right;\n            }\n            TreeNode *successor = root->right;\n            while (successor->left) {\n                successor = successor->left;\n            }\n            root->right = deleteNode(root->right, successor->val);\n            successor->right = root->right;\n            successor->left = root->left;\n            return successor;\n        }\n        return root;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null) {\n            return null;\n        }\n        if (root.val > key) {\n            root.left = deleteNode(root.left, key);\n            return root;\n        }\n        if (root.val < key) {\n            root.right = deleteNode(root.right, key);\n            return root;\n        }\n        if (root.val == key) {\n            if (root.left == null && root.right == null) {\n                return null;\n            }\n            if (root.right == null) {\n                return root.left;\n            }\n            if (root.left == null) {\n                return root.right;\n            }\n            TreeNode successor = root.right;\n            while (successor.left != null) {\n                successor = successor.left;\n            }\n            root.right = deleteNode(root.right, successor.val);\n            successor.right = root.right;\n            successor.left = root.left;\n            return successor;\n        }\n        return root;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public TreeNode DeleteNode(TreeNode root, int key) {\n        if (root == null) {\n            return null;\n        }\n        if (root.val > key) {\n            root.left = DeleteNode(root.left, key);\n            return root;\n        }\n        if (root.val < key) {\n            root.right = DeleteNode(root.right, key);\n            return root;\n        }\n        if (root.val == key) {\n            if (root.left == null && root.right == null) {\n                return null;\n            }\n            if (root.right == null) {\n                return root.left;\n            }\n            if (root.left == null) {\n                return root.right;\n            }\n            TreeNode successor = root.right;\n            while (successor.left != null) {\n                successor = successor.left;\n            }\n            root.right = DeleteNode(root.right, successor.val);\n            successor.right = root.right;\n            successor.left = root.left;\n            return successor;\n        }\n        return root;\n    }\n}\n```\n\n```C [sol1-C]\nstruct TreeNode* deleteNode(struct TreeNode* root, int key){\n    if (root == NULL) {\n        return NULL;\n    }\n    if (root->val > key) {\n        root->left = deleteNode(root->left, key);\n        return root;\n    }\n    if (root->val < key) {\n        root->right = deleteNode(root->right, key);\n        return root;\n    }\n    if (root->val == key) {\n        if (!root->left && !root->right) {\n            return NULL;\n        }\n        if (!root->right) {\n            return root->left;\n        }\n        if (!root->left) {\n            return root->right;\n        }\n        struct TreeNode *successor = root->right;\n        while (successor->left) {\n            successor = successor->left;\n        }\n        root->right = deleteNode(root->right, successor->val);\n        successor->right = root->right;\n        successor->left = root->left;\n        return successor;\n    }\n    return root;\n}\n```\n\n```go [sol1-Golang]\nfunc deleteNode(root *TreeNode, key int) *TreeNode {\n    switch {\n    case root == nil:\n        return nil\n    case root.Val > key:\n        root.Left = deleteNode(root.Left, key)\n    case root.Val < key:\n        root.Right = deleteNode(root.Right, key)\n    case root.Left == nil || root.Right == nil:\n        if root.Left != nil {\n            return root.Left\n        }\n        return root.Right\n    default:\n        successor := root.Right\n        for successor.Left != nil {\n            successor = successor.Left\n        }\n        successor.Right = deleteNode(root.Right, successor.Val)\n        successor.Left = root.Left\n        return successor\n    }\n    return root\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar deleteNode = function(root, key) {\n    if (!root) {\n        return null;\n    }\n    if (root.val > key) {\n        root.left = deleteNode(root.left, key);\n        return root;\n    }\n    if (root.val < key) {\n        root.right = deleteNode(root.right, key);\n        return root;\n    }\n    if (root.val === key) {\n        if (!root.left && !root.right) {\n            return null;\n        }\n        if (!root.right) {\n            return root.left;\n        }\n        if (!root.left) {\n            return root.right;\n        }\n        let successor = root.right;\n        while (successor.left) {\n            successor = successor.left;\n        }\n        root.right = deleteNode(root.right, successor.val);\n        successor.right = root.right;\n        successor.left = root.left;\n        return successor;\n    }\n    return root;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{root}$ 的节点个数。最差情况下，寻找和删除 $\\textit{successor}$ 各需要遍历一次树。\n\n- 空间复杂度：$O(n)$，其中 $n$ 为 $\\textit{root}$ 的节点个数。递归的深度最深为 $O(n)$。\n\n#### 方法二：迭代\n\n**思路**\n\n方法一的递归深度最多为 $n$，而大部分是由寻找值为 $\\textit{key}$ 的节点贡献的，而寻找节点这一部分可以用迭代来优化。寻找并删除 $\\textit{successor}$ 时，也可以用一个变量保存它的父节点，从而可以节省一步递归操作。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        cur, curParent = root, None\n        while cur and cur.val != key:\n            curParent = cur\n            cur = cur.left if cur.val > key else cur.right\n        if cur is None:\n            return root\n        if cur.left is None and cur.right is None:\n            cur = None\n        elif cur.right is None:\n            cur = cur.left\n        elif cur.left is None:\n            cur = cur.right\n        else:\n            successor, successorParent = cur.right, cur\n            while successor.left:\n                successorParent = successor\n                successor = successor.left\n            if successorParent.val == cur.val:\n                successorParent.right = successor.right\n            else:\n                successorParent.left = successor.right\n            successor.right = cur.right\n            successor.left = cur.left\n            cur = successor\n        if curParent is None:\n            return cur\n        if curParent.left and curParent.left.val == key:\n            curParent.left = cur\n        else:\n            curParent.right = cur\n        return root\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        TreeNode *cur = root, *curParent = nullptr;\n        while (cur && cur->val != key) {\n            curParent = cur;\n            if (cur->val > key) {\n                cur = cur->left;\n            } else {\n                cur = cur->right;\n            }\n        }\n        if (!cur) {\n            return root;\n        }\n        if (!cur->left && !cur->right) {\n            cur = nullptr;\n        } else if (!cur->right) {\n            cur = cur->left;\n        } else if (!cur->left) {\n            cur = cur->right;\n        } else {\n            TreeNode *successor = cur->right, *successorParent = cur;\n            while (successor->left) {\n                successorParent = successor;\n                successor = successor->left;\n            }\n            if (successorParent->val == cur->val) {\n                successorParent->right = successor->right;\n            } else {\n                successorParent->left = successor->right;\n            }\n            successor->right = cur->right;\n            successor->left = cur->left;\n            cur = successor;\n        }\n        if (!curParent) {\n            return cur;\n        } else {\n            if (curParent->left && curParent->left->val == key) {\n                curParent->left = cur;\n            } else {\n                curParent->right = cur;\n            }\n            return root;\n        }\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        TreeNode cur = root, curParent = null;\n        while (cur != null && cur.val != key) {\n            curParent = cur;\n            if (cur.val > key) {\n                cur = cur.left;\n            } else {\n                cur = cur.right;\n            }\n        }\n        if (cur == null) {\n            return root;\n        }\n        if (cur.left == null && cur.right == null) {\n            cur = null;\n        } else if (cur.right == null) {\n            cur = cur.left;\n        } else if (cur.left == null) {\n            cur = cur.right;\n        } else {\n            TreeNode successor = cur.right, successorParent = cur;\n            while (successor.left != null) {\n                successorParent = successor;\n                successor = successor.left;\n            }\n            if (successorParent.val == cur.val) {\n                successorParent.right = successor.right;\n            } else {\n                successorParent.left = successor.right;\n            }\n            successor.right = cur.right;\n            successor.left = cur.left;\n            cur = successor;\n        }\n        if (curParent == null) {\n            return cur;\n        } else {\n            if (curParent.left != null && curParent.left.val == key) {\n                curParent.left = cur;\n            } else {\n                curParent.right = cur;\n            }\n            return root;\n        }\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public TreeNode DeleteNode(TreeNode root, int key) {\n        TreeNode cur = root, curParent = null;\n        while (cur != null && cur.val != key) {\n            curParent = cur;\n            if (cur.val > key) {\n                cur = cur.left;\n            } else {\n                cur = cur.right;\n            }\n        }\n        if (cur == null) {\n            return root;\n        }\n        if (cur.left == null && cur.right == null) {\n            cur = null;\n        } else if (cur.right == null) {\n            cur = cur.left;\n        } else if (cur.left == null) {\n            cur = cur.right;\n        } else {\n            TreeNode successor = cur.right, successorParent = cur;\n            while (successor.left != null) {\n                successorParent = successor;\n                successor = successor.left;\n            }\n            if (successorParent.val == cur.val) {\n                successorParent.right = successor.right;\n            } else {\n                successorParent.left = successor.right;\n            }\n            successor.right = cur.right;\n            successor.left = cur.left;\n            cur = successor;\n        }\n        if (curParent == null) {\n            return cur;\n        } else {\n            if (curParent.left != null && curParent.left.val == key) {\n                curParent.left = cur;\n            } else {\n                curParent.right = cur;\n            }\n            return root;\n        }\n    }\n}\n```\n\n```C [sol2-C]\nstruct TreeNode* deleteNode(struct TreeNode* root, int key){\n    struct TreeNode *cur = root, *curParent = NULL;\n    while (cur && cur->val != key) {\n        curParent = cur;\n        if (cur->val > key) {\n            cur = cur->left;\n        } else {\n            cur = cur->right;\n        }\n    }\n    if (!cur) {\n        return root;\n    }\n    if (!cur->left && !cur->right) {\n        cur = NULL;\n    } else if (!cur->right) {\n        cur = cur->left;\n    } else if (!cur->left) {\n        cur = cur->right;\n    } else {\n        struct TreeNode *successor = cur->right, *successorParent = cur;\n        while (successor->left) {\n            successorParent = successor;\n            successor = successor->left;\n        }\n        if (successorParent->val == cur->val) {\n            successorParent->right = successor->right;\n        } else {\n            successorParent->left = successor->right;\n        }\n        successor->right = cur->right;\n        successor->left = cur->left;\n        cur = successor;\n    }\n    if (!curParent) {\n        return cur;\n    } else {\n        if (curParent->left && curParent->left->val == key) {\n            curParent->left = cur;\n        } else {\n            curParent->right = cur;\n        }\n        return root;\n    }\n}\n```\n\n```go [sol2-Golang]\nfunc deleteNode(root *TreeNode, key int) *TreeNode {\n    var cur, curParent *TreeNode = root, nil\n    for cur != nil && cur.Val != key {\n        curParent = cur\n        if cur.Val > key {\n            cur = cur.Left\n        } else {\n            cur = cur.Right\n        }\n    }\n    if cur == nil {\n        return root\n    }\n    if cur.Left == nil && cur.Right == nil {\n        cur = nil\n    } else if cur.Right == nil {\n        cur = cur.Left\n    } else if cur.Left == nil {\n        cur = cur.Right\n    } else {\n        successor, successorParent := cur.Right, cur\n        for successor.Left != nil {\n            successorParent = successor\n            successor = successor.Left\n        }\n        if successorParent.Val == cur.Val {\n            successorParent.Right = successor.Right\n        } else {\n            successorParent.Left = successor.Right\n        }\n        successor.Right = cur.Right\n        successor.Left = cur.Left\n        cur = successor\n    }\n    if curParent == nil {\n        return cur\n    }\n    if curParent.Left != nil && curParent.Left.Val == key {\n        curParent.Left = cur\n    } else {\n        curParent.Right = cur\n    }\n    return root\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar deleteNode = function(root, key) {\n    let cur = root, curParent = null;\n    while (cur && cur.val !== key) {\n        curParent = cur;\n        if (cur.val > key) {\n            cur = cur.left;\n        } else {\n            cur = cur.right;\n        }\n    }\n    if (!cur) {\n        return root;\n    }\n    if (!cur.left && !cur.right) {\n        cur = null;\n    } else if (!cur.right) {\n        cur = cur.left;\n    } else if (!cur.left) {\n        cur = cur.right;\n    } else {\n        let successor = cur.right, successorParent = cur;\n        while (successor.left) {\n            successorParent = successor;\n            successor = successor.left;\n        }\n        if (successorParent.val === cur.val) {\n            successorParent.right = successor.right;\n        } else {\n            successorParent.left = successor.right;\n        }\n        successor.right = cur.right;\n        successor.left = cur.left;\n        cur = successor;\n    }\n    if (!curParent) {\n        return cur;\n    } else {\n        if (curParent.left && curParent.left.val === key) {\n            curParent.left = cur;\n        } else {\n            curParent.right = cur;\n        }\n        return root;\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为 $\\textit{root}$ 的节点个数。最差情况下，需要遍历一次树。\n\n- 空间复杂度：$O(1)$。使用的空间为常数。"
}