{
	"titleSlug": "simplify-path",
	"slug": "jian-hua-lu-jing-by-leetcode-solution-aucq",
	"url": "https://leetcode-cn.com/problems/simplify-path/solution/jian-hua-lu-jing-by-leetcode-solution-aucq/",
	"content": "#### 方法一：栈\n\n**思路与算法**\n\n我们首先将给定的字符串 $\\textit{path}$ 根据 $\\texttt{/}$ 分割成一个由若干字符串组成的列表，记为 $\\textit{names}$。根据题目中规定的「规范路径的下述格式」，$\\textit{names}$ 中包含的字符串只能为以下几种：\n\n- 空字符串。例如当出现多个连续的 $\\texttt{/}$，就会分割出空字符串；\n\n- 一个点 $\\texttt{.}$；\n\n- 两个点 $\\texttt{..}$；\n\n- 只包含英文字母、数字或 $\\texttt{\\_}$ 的目录名。\n\n对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理，因为「空字符串」没有任何含义，而「一个点」表示当前目录本身，我们无需切换目录。\n\n对于「两个点」或者「目录名」，我们则可以用一个栈来维护路径中的每一个目录名。当我们遇到「两个点」时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录。当我们遇到「目录名」时，就把它放入栈。\n\n这样一来，我们只需要遍历 $\\textit{names}$ 中的每个字符串并进行上述操作即可。在所有的操作完成后，我们将从栈底到栈顶的字符串用 $\\texttt{/}$ 进行连接，再在最前面加上 $\\texttt{/}$ 表示根目录，就可以得到简化后的规范路径。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        auto split = [](const string& s, char delim) -> vector<string> {\n            vector<string> ans;\n            string cur;\n            for (char ch: s) {\n                if (ch == delim) {\n                    ans.push_back(move(cur));\n                    cur.clear();\n                }\n                else {\n                    cur += ch;\n                }\n            }\n            ans.push_back(move(cur));\n            return ans;\n        };\n\n        vector<string> names = split(path, '/');\n        vector<string> stack;\n        for (string& name: names) {\n            if (name == \"..\") {\n                if (!stack.empty()) {\n                    stack.pop_back();\n                }\n            }\n            else if (!name.empty() && name != \".\") {\n                stack.push_back(move(name));\n            }\n        }\n        string ans;\n        if (stack.empty()) {\n            ans = \"/\";\n        }\n        else {\n            for (string& name: stack) {\n                ans += \"/\" + move(name);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public String simplifyPath(String path) {\n        String[] names = path.split(\"/\");\n        Deque<String> stack = new ArrayDeque<String>();\n        for (String name : names) {\n            if (\"..\".equals(name)) {\n                if (!stack.isEmpty()) {\n                    stack.pollLast();\n                }\n            } else if (name.length() > 0 && !\".\".equals(name)) {\n                stack.offerLast(name);\n            }\n        }\n        StringBuffer ans = new StringBuffer();\n        if (stack.isEmpty()) {\n            ans.append('/');\n        } else {\n            while (!stack.isEmpty()) {\n                ans.append('/');\n                ans.append(stack.pollFirst());\n            }\n        }\n        return ans.toString();\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public string SimplifyPath(string path) {\n        string[] names = path.Split(\"/\");\n        IList<string> stack = new List<string>();\n        foreach (string name in names) {\n            if (\"..\".Equals(name)) {\n                if (stack.Count > 0) {\n                    stack.RemoveAt(stack.Count - 1);\n                }\n            } else if (name.Length > 0 && !\".\".Equals(name)) {\n                stack.Add(name);\n            }\n        }\n        StringBuilder ans = new StringBuilder();\n        if (stack.Count == 0) {\n            ans.Append('/');\n        } else {\n            foreach (string name in stack) {\n                ans.Append('/');\n                ans.Append(name);\n            }\n        }\n        return ans.ToString();\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        names = path.split(\"/\")\n        stack = list()\n        for name in names:\n            if name == \"..\":\n                if stack:\n                    stack.pop()\n            elif name and name != \".\":\n                stack.append(name)\n        return \"/\" + \"/\".join(stack)\n```\n\n```C [sol1-C]\nchar ** split(const char * s, char delim, int * returnSize) {\n    int n = strlen(s);\n    char ** ans = (char **)malloc(sizeof(char *) * n);\n    int pos = 0;\n    int curr = 0;\n    int len = 0;\n    \n    while (pos < n) {\n        while (pos < n && s[pos] == delim) {\n            ++pos;\n        }\n        curr = pos;\n        while (pos < n && s[pos] != delim) {\n            ++pos;\n        }\n        if (curr < n) {\n            ans[len] = (char *)malloc(sizeof(char) * (pos - curr + 1)); \n            strncpy(ans[len], s + curr, pos - curr);\n            ans[len][pos - curr] = '\\0';\n            ++len;\n        }\n    }\n    *returnSize = len;\n    return ans;\n}\n\nchar * simplifyPath(char * path){\n    int namesSize = 0;\n    int n = strlen(path);\n    char ** names = split(path, '/', &namesSize);\n    char ** stack = (char **)malloc(sizeof(char *) * namesSize);\n    int stackSize = 0;\n    for (int i = 0; i < namesSize; ++i) {\n        if (!strcmp(names[i], \"..\")) {\n            if (stackSize > 0) {\n                --stackSize;\n            } \n        } else if (strcmp(names[i], \".\")){\n            stack[stackSize] = names[i];\n            ++stackSize;\n        } \n    }\n    \n    char * ans = (char *)malloc(sizeof(char) * (n + 1));\n    int curr = 0;\n    if (stackSize == 0) {\n        ans[curr] = '/';\n        ++curr;\n    } else {\n        for (int i = 0; i < stackSize; ++i) {\n            ans[curr] = '/';\n            ++curr;\n            strcpy(ans + curr, stack[i]);\n            curr += strlen(stack[i]);\n        }\n    }\n    ans[curr] = '\\0';\n    for (int i = 0; i < namesSize; ++i) {\n        free(names[i]);\n    }\n    free(names);\n    free(stack);\n    return ans;\n}\n```\n\n```go [sol1-Golang]\nfunc simplifyPath(path string) string {\n    stack := []string{}\n    for _, name := range strings.Split(path, \"/\") {\n        if name == \"..\" {\n            if len(stack) > 0 {\n                stack = stack[:len(stack)-1]\n            }\n        } else if name != \"\" && name != \".\" {\n            stack = append(stack, name)\n        }\n    }\n    return \"/\" + strings.Join(stack, \"/\")\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar simplifyPath = function(path) {\n    const names = path.split(\"/\");\n    const stack = [];\n    for (const name of names) {\n        if (name === \"..\") {\n            if (stack.length) {\n                stack.pop();\n            } \n        } else if (name.length && name !== \".\") {\n            stack.push(name);\n\n        }\n    }\n    \n    return \"/\" + stack.join(\"/\");\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $\\textit{path}$ 的长度。\n\n- 空间复杂度：$O(n)$。我们需要 $O(n)$ 的空间存储 $\\textit{names}$ 中的所有字符串。"
}