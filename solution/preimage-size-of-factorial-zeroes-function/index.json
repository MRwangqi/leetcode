{
	"titleSlug": "preimage-size-of-factorial-zeroes-function",
	"slug": "jie-cheng-han-shu-hou-k-ge-ling-by-leetc-n6vj",
	"url": "https://leetcode-cn.com/problems/preimage-size-of-factorial-zeroes-function/solution/jie-cheng-han-shu-hou-k-ge-ling-by-leetc-n6vj/",
	"content": "#### 方法一：二分查找\n\n**思路与算法**\n\n首先我们令 $\\textit{zeta}(x)$ 为 $x!$ 末尾零的个数。根据[「172. 阶乘后的零」的官方题解](https://leetcode.cn/problems/factorial-trailing-zeroes/solution/jie-cheng-hou-de-ling-by-leetcode-soluti-1egk/)，有\n\n$$\\textit{zeta}(x) = \\sum_{k = 1}^{\\infty}\\left\\lfloor{\\frac{x}{5^k}}\\right\\rfloor$$\n\n记 $n_{x}$ 表示 $x!$ 末尾零的个数**不小于** $x$ 的最小数，那么题目等价于求解 $n_{k + 1} - n_k$。\n \n由于 $\\textit{zeta}(x)$ 为**单调不减函数**，因此 $n_{k + 1}$ 和 $n_k$ 可以通过「二分查找」来求解。\n\n又因为\n\n$$\n\\textit{zeta}(x) = \\sum_{k = 1}^{\\infty}\\left\\lfloor{\\frac{x}{5^k}}\\right\\rfloor \n\\ge \\left\\lfloor{\\frac{x}{5}}\\right\\rfloor\n$$\n\n得\n\n$$\\textit{zeta}(5x) \\ge x$$\n\n所以当二分求解 $n_{x}$ 时，我们可以将二分的初始右边界 $r$ 设置为 $5x$。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def preimageSizeFZF(self, k: int) -> int:\n        def zeta(n: int) -> int:\n            res = 0\n            while n:\n                n //= 5\n                res += n\n            return res\n\n        def nx(k: int) -> int:\n            return bisect_left(range(5 * k), k, key=zeta)\n\n        return nx(k + 1) - nx(k)\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int zeta(long x) {\n        int res = 0;\n        while (x) {\n            res += x / 5;\n            x /= 5;\n        }\n        return res;\n    }\n\n    long long help(int k) {\n        long long r = 5LL * k;\n        long long l = 0;\n        while (l <= r) {\n            long long mid = (l + r) / 2;\n            if (zeta(mid) < k) {\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return r + 1;\n    }\n\n    int preimageSizeFZF(int k) {\n        return help(k + 1) - help(k);\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int preimageSizeFZF(int k) {\n        return (int) (help(k + 1) - help(k));\n    }\n\n    public long help(int k) {\n        long r = 5L * k;\n        long l = 0;\n        while (l <= r) {\n            long mid = (l + r) / 2;\n            if (zeta(mid) < k) {\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return r + 1;\n    }\n\n    public long zeta(long x) {\n        long res = 0;\n        while (x != 0) {\n            res += x / 5;\n            x /= 5;\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int PreimageSizeFZF(int k) {\n        return (int) (Help(k + 1) - Help(k));\n    }\n\n    public long Help(int k) {\n        long r = 5L * k;\n        long l = 0;\n        while (l <= r) {\n            long mid = (l + r) / 2;\n            if (Zeta(mid) < k) {\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return r + 1;\n    }\n\n    public long Zeta(long x) {\n        long res = 0;\n        while (x != 0) {\n            res += x / 5;\n            x /= 5;\n        }\n        return res;\n    }\n}\n```\n\n```C [sol1-C]\nlong long zeta(long x) {\n    long long res = 0;\n    while (x != 0) {\n        res += x / 5;\n        x /= 5;\n    }\n    return res;\n}\n\nlong long help(int k) {\n    long long r = 5LL * k;\n    long long l = 0;\n    while (l <= r) {\n        long mid = (l + r) / 2;\n        if (zeta(mid) < k) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return r + 1;\n}\n\nint preimageSizeFZF(int k){\n    return help(k + 1) - help(k);\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar preimageSizeFZF = function(k) {\n    return help(k + 1) - help(k);\n}\n\nconst help = (k) => {\n    let r = 5 * k;\n    let l = 0;\n    while (l <= r) {\n        const mid = Math.floor((l + r) / 2);\n        if (zeta(mid) < k) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return r + 1;\n}\n\nconst zeta = (x) => {\n    let res = 0;\n    while (x != 0) {\n        res += Math.floor(x / 5);\n        x = Math.floor(x / 5);\n    }\n    return res;\n};\n```\n\n```go [sol1-Golang]\nfunc zeta(n int) (res int) {\n    for n > 0 {\n        n /= 5\n        res += n\n    }\n    return\n}\n\nfunc nx(k int) int {\n    return sort.Search(5*k, func(x int) bool { return zeta(x) >= k })\n}\n\nfunc preimageSizeFZF(k int) int {\n    return nx(k+1) - nx(k)\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(\\log^2 k)$，其中 $k$ 为题目给定数字，二分查找 $n_{k + 1}, n_k$ 的时间复杂度为 $O(\\log k)$，其中每一步计算 $\\textit{zeta}(x)$ 的时间复杂度为 $O(\\log k)$。\n- 空间复杂度：$O(1)$，$\\textit{zeta}(x)$ 仅为常量空间开销。"
}