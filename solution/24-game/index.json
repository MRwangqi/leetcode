{
	"titleSlug": "24-game",
	"slug": "24-dian-you-xi-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/24-game/solution/24-dian-you-xi-by-leetcode-solution/",
	"content": "#### 方法一：回溯\n\n一共有 $4$ 个数和 $3$ 个运算操作，因此可能性非常有限。一共有多少种可能性呢？\n\n首先从 $4$ 个数字中有序地选出 $2$ 个数字，共有 $4 \\times 3=12$ 种选法，并选择加、减、乘、除 $4$ 种运算操作之一，用得到的结果取代选出的 $2$ 个数字，剩下 $3$ 个数字。\n\n然后在剩下的 $3$ 个数字中有序地选出 $2$ 个数字，共有 $3 \\times 2=6$ 种选法，并选择 $4$ 种运算操作之一，用得到的结果取代选出的 $2$ 个数字，剩下 $2$ 个数字。\n\n最后剩下 $2$ 个数字，有 $2$ 种不同的顺序，并选择 $4$ 种运算操作之一。\n\n因此，一共有 $12 \\times 4 \\times 6 \\times 4 \\times 2 \\times 4=9216$ 种不同的可能性。\n\n可以通过回溯的方法遍历所有不同的可能性。具体做法是，使用一个列表存储目前的全部数字，每次从列表中选出 $2$ 个数字，再选择一种运算操作，用计算得到的结果取代选出的 $2$ 个数字，这样列表中的数字就减少了 $1$ 个。重复上述步骤，直到列表中只剩下 $1$ 个数字，这个数字就是一种可能性的结果，如果结果等于 $24$，则说明可以通过运算得到 $24$。如果所有的可能性的结果都不等于 $24$，则说明无法通过运算得到 $24$。\n\n实现时，有一些细节需要注意。\n\n- 除法运算为实数除法，因此结果为浮点数，列表中存储的数字也都是浮点数。在判断结果是否等于 $24$ 时应考虑精度误差，这道题中，误差小于 $10^{-6}$ 可以认为是相等。\n\n- 进行除法运算时，除数不能为 $0$，如果遇到除数为 $0$ 的情况，则这种可能性可以直接排除。由于列表中存储的数字是浮点数，因此判断除数是否为 $0$ 时应考虑精度误差，这道题中，当一个数字的绝对值小于 $10^{-6}$ 时，可以认为该数字等于 $0$。\n\n还有一个可以优化的点。\n\n- 加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，则对于选出的 $2$ 个数字不需要考虑不同的顺序，在遇到第二种顺序时可以不进行运算，直接跳过。\n\n```Java [sol1-Java]\nclass Solution {\n    static final int TARGET = 24;\n    static final double EPSILON = 1e-6;\n    static final int ADD = 0, MULTIPLY = 1, SUBTRACT = 2, DIVIDE = 3;\n\n    public boolean judgePoint24(int[] nums) {\n        List<Double> list = new ArrayList<Double>();\n        for (int num : nums) {\n            list.add((double) num);\n        }\n        return solve(list);\n    }\n\n    public boolean solve(List<Double> list) {\n        if (list.size() == 0) {\n            return false;\n        }\n        if (list.size() == 1) {\n            return Math.abs(list.get(0) - TARGET) < EPSILON;\n        }\n        int size = list.size();\n        for (int i = 0; i < size; i++) {\n            for (int j = 0; j < size; j++) {\n                if (i != j) {\n                    List<Double> list2 = new ArrayList<Double>();\n                    for (int k = 0; k < size; k++) {\n                        if (k != i && k != j) {\n                            list2.add(list.get(k));\n                        }\n                    }\n                    for (int k = 0; k < 4; k++) {\n                        if (k < 2 && i > j) {\n                            continue;\n                        }\n                        if (k == ADD) {\n                            list2.add(list.get(i) + list.get(j));\n                        } else if (k == MULTIPLY) {\n                            list2.add(list.get(i) * list.get(j));\n                        } else if (k == SUBTRACT) {\n                            list2.add(list.get(i) - list.get(j));\n                        } else if (k == DIVIDE) {\n                            if (Math.abs(list.get(j)) < EPSILON) {\n                                continue;\n                            } else {\n                                list2.add(list.get(i) / list.get(j));\n                            }\n                        }\n                        if (solve(list2)) {\n                            return true;\n                        }\n                        list2.remove(list2.size() - 1);\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    static constexpr int TARGET = 24;\n    static constexpr double EPSILON = 1e-6;\n    static constexpr int ADD = 0, MULTIPLY = 1, SUBTRACT = 2, DIVIDE = 3;\n\n    bool judgePoint24(vector<int> &nums) {\n        vector<double> l;\n        for (const int &num : nums) {\n            l.emplace_back(static_cast<double>(num));\n        }\n        return solve(l);\n    }\n\n    bool solve(vector<double> &l) {\n        if (l.size() == 0) {\n            return false;\n        }\n        if (l.size() == 1) {\n            return fabs(l[0] - TARGET) < EPSILON;\n        }\n        int size = l.size();\n        for (int i = 0; i < size; i++) {\n            for (int j = 0; j < size; j++) {\n                if (i != j) {\n                    vector<double> list2 = vector<double>();\n                    for (int k = 0; k < size; k++) {\n                        if (k != i && k != j) {\n                            list2.emplace_back(l[k]);\n                        }\n                    }\n                    for (int k = 0; k < 4; k++) {\n                        if (k < 2 && i > j) {\n                            continue;\n                        }\n                        if (k == ADD) {\n                            list2.emplace_back(l[i] + l[j]);\n                        } else if (k == MULTIPLY) {\n                            list2.emplace_back(l[i] * l[j]);\n                        } else if (k == SUBTRACT) {\n                            list2.emplace_back(l[i] - l[j]);\n                        } else if (k == DIVIDE) {\n                            if (fabs(l[j]) < EPSILON) {\n                                continue;\n                            }\n                            list2.emplace_back(l[i] / l[j]);\n                        }\n                        if (solve(list2)) {\n                            return true;\n                        }\n                        list2.pop_back();\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n```C [sol1-C]\nconst int TARGET = 24;\nconst double EPSILON = 1e-6;\nconst int ADD = 0, MULTIPLY = 1, SUBTRACT = 2, DIVIDE = 3;\n\nbool solve(double *l, int l_len) {\n    if (l_len == 0) {\n        return false;\n    }\n    if (l_len == 1) {\n        return fabs(l[0] - TARGET) < EPSILON;\n    }\n    int size = l_len;\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            if (i != j) {\n                double list2[20];\n                int l2_len = 0;\n                for (int k = 0; k < size; k++) {\n                    if (k != i && k != j) {\n                        list2[l2_len++] = l[k];\n                    }\n                }\n                for (int k = 0; k < 4; k++) {\n                    if (k < 2 && i > j) {\n                        continue;\n                    }\n                    if (k == ADD) {\n                        list2[l2_len++] = l[i] + l[j];\n                    } else if (k == MULTIPLY) {\n                        list2[l2_len++] = l[i] * l[j];\n                    } else if (k == SUBTRACT) {\n                        list2[l2_len++] = l[i] - l[j];\n                    } else if (k == DIVIDE) {\n                        if (fabs(l[j]) < EPSILON) {\n                            continue;\n                        }\n                        list2[l2_len++] = l[i] / l[j];\n                    }\n                    if (solve(list2, l2_len)) {\n                        return true;\n                    }\n                    l2_len--;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nbool judgePoint24(int *nums, int numsSize) {\n    double l[20];\n    int l_len = 0;\n    for (int i = 0; i < numsSize; i++) {\n        l[l_len++] = nums[i];\n    }\n    return solve(l, l_len);\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def judgePoint24(self, nums: List[int]) -> bool:\n        TARGET = 24\n        EPSILON = 1e-6\n        ADD, MULTIPLY, SUBTRACT, DIVIDE = 0, 1, 2, 3\n\n        def solve(nums: List[float]) -> bool:\n            if not nums:\n                return False\n            if len(nums) == 1:\n                return abs(nums[0] - TARGET) < EPSILON\n            for i, x in enumerate(nums):\n                for j, y in enumerate(nums):\n                    if i != j:\n                        newNums = list()\n                        for k, z in enumerate(nums):\n                            if k != i and k != j:\n                                newNums.append(z)\n                        for k in range(4):\n                            if k < 2 and i > j:\n                                continue\n                            if k == ADD:\n                                newNums.append(x + y)\n                            elif k == MULTIPLY:\n                                newNums.append(x * y)\n                            elif k == SUBTRACT:\n                                newNums.append(x - y)\n                            elif k == DIVIDE:\n                                if abs(y) < EPSILON:\n                                    continue\n                                newNums.append(x / y)\n                            if solve(newNums):\n                                return True\n                            newNums.pop()\n            return False\n\n        return solve(nums)\n```\n\n```golang [sol1-Golang]\nconst (\n    TARGET = 24\n    EPSILON = 1e-6\n    ADD, MULTIPLY, SUBTRACT, DIVIDE = 0, 1, 2, 3\n)\n\nfunc judgePoint24(nums []int) bool {\n    list := []float64{}\n    for _, num := range nums {\n        list = append(list, float64(num))\n    }\n    return solve(list)\n}\n\nfunc solve(list []float64) bool {\n    if len(list) == 0 {\n        return false\n    }\n    if len(list) == 1 {\n        return abs(list[0] - TARGET) < EPSILON\n    }\n    size := len(list)\n    for i := 0; i < size; i++ {\n        for j := 0; j < size; j++ {\n            if i != j {\n                list2 := []float64{}\n                for k := 0; k < size; k++ {\n                    if k != i && k != j {\n                        list2 = append(list2, list[k])\n                    }\n                }\n                for k := 0; k < 4; k++ {\n                    if k < 2 && i < j {\n                        continue\n                    }\n                    switch k {\n                    case ADD:\n                        list2 = append(list2, list[i] + list[j])\n                    case MULTIPLY:\n                        list2 = append(list2, list[i] * list[j])\n                    case SUBTRACT:\n                        list2 = append(list2, list[i] - list[j])\n                    case DIVIDE:\n                        if abs(list[j]) < EPSILON {\n                            continue\n                        } else {\n                            list2 = append(list2, list[i] / list[j])\n                        }\n                    }\n                    if solve(list2) {\n                        return true\n                    }\n                    list2 = list2[:len(list2) - 1]\n                }\n            }\n        }\n    }\n    return false\n}\n\nfunc abs(x float64) float64 {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$。一共有 $9216$ 种可能性，对于每种可能性，各项操作的时间复杂度都是 $O(1)$，因此总时间复杂度是 $O(1)$。\n\n- 空间复杂度：$O(1)$。空间复杂度取决于递归调用层数与存储中间状态的列表，因为一共有 $4$ 个数，所以递归调用的层数最多为 $4$，存储中间状态的列表最多包含 $4$ 个元素，因此空间复杂度为常数。"
}