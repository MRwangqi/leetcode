{
	"titleSlug": "minimum-operations-to-halve-array-sum",
	"slug": "jiang-shu-zu-he-jian-ban-de-zui-shao-cao-4lej",
	"url": "https://leetcode-cn.com/problems/minimum-operations-to-halve-array-sum/solution/jiang-shu-zu-he-jian-ban-de-zui-shao-cao-4lej/",
	"content": "#### 方法一：最大堆（优先队列）\n\n**提示 $1$**\n\n为了使得数组和减半的操作次数最少，我们需要在每次操作时让减少量尽可能大，即选择数值**最大**的元素进行减半操作。\n\n**提示 $1$ 解释**\n\n我们假设某一步操作没有选择数值最大的元素（记为 $\\textit{opt}$）进行操作，而是选择了 $\\textit{num} (\\textit{num} < \\textit{opt})$，那么后续可能有两种情况：\n\n- 第一种，如果后续的某一步中选择了对 $\\textit{opt}$ 减半，那么我们可以交换这两步的操作，最终减半所需的操作次数不变；\n\n- 第二种，如果后续没有对 $\\textit{opt}$ 进行过减半操作，那么将从当前开始到结束为止所有对 $\\textit{num}$ 减半的操作全部换成 $\\textit{opt}$ ，最终减半所需的操作次数也不会减少。\n\n因此，每次选择数值最大的元素进行操作是最优的。\n\n**思路与算法**\n\n根据 **提示 $1$**，每一次「减半元素」的操作可以被拆分为两个部分：\n\n- 从**当前**数组中**寻找到**最大值；\n\n- 将该值进行修改（减半）。\n\n假设**数组** $\\textit{nums}$ 的长度为 $n$，那么单次操作的时间复杂度为 $O(n)$，无法通过本题。因此我们可以将「减半元素」操作的两个部分进行如下修改：\n\n- 从当前数组中**记录并弹出**最大值；\n\n- 将该值进行修改，并**重新添加**至数组中。\n\n同时寻找一个可以在较好的时间复杂度下实现「查询并移除最大值」与「插入元素」的数据结构。\n\n我们可以用一个**最大堆**实现的优先队列来维护数组 $\\textit{nums}$，它可以在 $O(\\log n)$ 的时间复杂度下实现「查询并移除最大值」与「插入元素」这两个操作。\n\n我们用 $\\textit{dec}$ 维护减少的数值之和，并用 $\\textit{res}$ 记录当前减半操作的次数。每一次操作时，我们首先记录并弹出 $\\textit{piles}$ 中的最大值 $\\textit{opt}$，随后从中减去 $\\textit{opt} / 2$，并将修改后的值添加进 $\\textit{nums}$ 中。与此同时，我们将 $\\textit{dec}$ 加上 $\\textit{opt} / 2$，并将 $\\textit{res}$ 加上 $1$。当 $\\textit{dec} \\ge \\sum_i \\textit{nums}[i] / 2$ 时，代表此时数组和已经减半，我们返回 $\\textit{res}$ 作为答案。\n\n**细节**\n\n首先需要注意的是，$\\texttt{C++}$ 的二叉堆默认为**最大堆**，但$\\texttt{Python}$ 的二叉堆默认为**最小堆**，因此我们需要将 $\\textit{nums}$ 中的每个元素取相反数然后进行操作，并在维护减少的数值 $\\textit{dec}$ 时再次取相反数。\n\n其次，由于此处的减半操作没有取整，因此对于 $\\texttt{C++}$ 等语言，我们需要新建浮点数数组（优先队列）来进行减半操作。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int halveArray(vector<int>& nums) {\n        double total = accumulate(nums.begin(), nums.end(), 0.0);   // 数组和\n        int n = nums.size();\n        vector<double> arr(nums.begin(), nums.end());\n        make_heap(arr.begin(), arr.end());\n        double dec = 0.0;   // 数组和减少的数值\n        int res = 0;   // 减少操作的次数\n        while (dec < total / 2) {\n            // 单次操作：记录并弹出最大值，修改后重新添加进堆\n            pop_heap(arr.begin(), arr.end());\n            dec += arr.back() / 2;\n            arr.back() /= 2;\n            ++res;\n            push_heap(arr.begin(), arr.end());\n        }\n        return res;\n    }\n};\n```\n\n\n```Python [sol1-Python3]\nclass Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        total = sum(nums)   # 数组和\n        n = len(nums)\n        for i in range(n):\n            nums[i] = -nums[i]\n        heapq.heapify(nums)\n        dec = 0.0   # 数组和减少的数值\n        res = 0   # 减少操作的次数\n        while dec < total / 2:\n            # 单次操作：记录并弹出最大值，修改后重新添加进堆\n            opt = heapq.heappop(nums)\n            dec += -opt / 2\n            res += 1\n            heapq.heappush(nums, opt / 2)\n        return res\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n\\log n)$，其中 $n$ 为 $\\textit{nums}$ 的长度。建堆的复杂度为 $O(n)$；每次弹出最大值与添加新值的时间复杂度为 $O(\\log n)$，共需进行 $O(n)$ 次（考虑到将 $\\textit{nums}$ 中每个数字都进行减半操作，共需要 $n$ 次，最少的操作次数一定不会大于这个数字）。\n\n- 空间复杂度：由于不同语言的实现有所不同，因此空间复杂度也有所不同：\n  - 对于 $\\texttt{C++}$，空间复杂度为 $O(n)$，即辅助优先队列的空间开销；\n  - 对于 $\\texttt{Python}$，空间复杂度为 $O(1)$。"
}