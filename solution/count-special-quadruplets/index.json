{
	"titleSlug": "count-special-quadruplets",
	"slug": "tong-ji-te-shu-si-yuan-zu-by-leetcode-so-50e2",
	"url": "https://leetcode-cn.com/problems/count-special-quadruplets/solution/tong-ji-te-shu-si-yuan-zu-by-leetcode-so-50e2/",
	"content": "#### 方法一：直接枚举\n\n**思路与算法**\n\n最简单的方法是直接枚举四个下标 $a, b, c, d$ 并进行判断。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int countQuadruplets(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        for (int a = 0; a < n; ++a) {\n            for (int b = a + 1; b < n; ++b) {\n                for (int c = b + 1; c < n; ++c) {\n                    for (int d = c + 1; d < n; ++d) {\n                        if (nums[a] + nums[b] + nums[c] == nums[d]) {\n                            ++ans;\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int countQuadruplets(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n        for (int a = 0; a < n; ++a) {\n            for (int b = a + 1; b < n; ++b) {\n                for (int c = b + 1; c < n; ++c) {\n                    for (int d = c + 1; d < n; ++d) {\n                        if (nums[a] + nums[b] + nums[c] == nums[d]) {\n                            ++ans;\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int CountQuadruplets(int[] nums) {\n        int n = nums.Length;\n        int ans = 0;\n        for (int a = 0; a < n; ++a) {\n            for (int b = a + 1; b < n; ++b) {\n                for (int c = b + 1; c < n; ++c) {\n                    for (int d = c + 1; d < n; ++d) {\n                        if (nums[a] + nums[b] + nums[c] == nums[d]) {\n                            ++ans;\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for a in range(n):\n            for b in range(a + 1, n):\n                for c in range(b + 1, n):\n                    for d in range(c + 1, n):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            ans += 1\n        return ans\n```\n\n```go [sol1-Golang]\nfunc countQuadruplets(nums []int) (ans int) {\n    for a, x := range nums {\n        for b := a + 1; b < len(nums); b++ {\n            for c := b + 1; c < len(nums); c++ {\n                for _, y := range nums[c+1:] {\n                    if x+nums[b]+nums[c] == y {\n                        ans++\n                    }\n                }\n            }\n        }\n    }\n    return\n}\n```\n\n```C [sol1-C]\nint countQuadruplets(int* nums, int numsSize){\n    int ans = 0;\n    for (int a = 0; a < numsSize; ++a) {\n        for (int b = a + 1; b < numsSize; ++b) {\n            for (int c = b + 1; c < numsSize; ++c) {\n                for (int d = c + 1; d < numsSize; ++d) {\n                    if (nums[a] + nums[b] + nums[c] == nums[d]) {\n                        ++ans;\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^4)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(1)$。\n\n#### 方法二：使用哈希表存储 $\\textit{nums}[d]$\n\n**思路与算法**\n\n如果我们已经枚举了前三个下标 $a, b, c$，那么就已经知道了等式左侧 $\\textit{nums}[a] + \\textit{nums}[b] + \\textit{nums}[c]$ 的值，即为 $\\textit{nums}[d]$ 的值。对于下标 $d$ 而言，它的取值范围是 $c < d < n$，那么我们可以使用哈希表统计数组 $\\textit{nums}[c + 1]$ 到 $\\textit{nums}[n - 1]$ 中每个元素出现的次数。这样一来，我们就可以直接从哈希表中获得满足等式的 $d$ 的个数，而不需要在 $[c+1, n-1]$ 的范围内进行枚举了。\n\n**细节**\n\n在枚举前三个下标 $a, b, c$ 时，我们可以先**逆序**枚举 $c$。在 $c$ 减小的过程中，$d$ 的取值范围是逐渐增大的：即从 $c+1$ 减小到 $c$ 时，$d$ 的取值范围中多了 $c+1$ 这一项，而其余的项不变。因此我们只需要将 $\\textit{nums}[c + 1]$ 加入哈希表即可。\n\n在这之后，我们就可以枚举 $a, b$ 并使用哈希表计算答案了。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int countQuadruplets(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        unordered_map<int, int> cnt;\n        for (int c = n - 2; c >= 2; --c) {\n            ++cnt[nums[c + 1]];\n            for (int a = 0; a < c; ++a) {\n                for (int b = a + 1; b < c; ++b) {\n                    if (int sum = nums[a] + nums[b] + nums[c]; cnt.count(sum)) {\n                        ans += cnt[sum];\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int countQuadruplets(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        for (int c = n - 2; c >= 2; --c) {\n            cnt.put(nums[c + 1], cnt.getOrDefault(nums[c + 1], 0) + 1);\n            for (int a = 0; a < c; ++a) {\n                for (int b = a + 1; b < c; ++b) {\n                    ans += cnt.getOrDefault(nums[a] + nums[b] + nums[c], 0);\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int CountQuadruplets(int[] nums) {\n        int n = nums.Length;\n        int ans = 0;\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        for (int c = n - 2; c >= 2; --c) {\n            if (!cnt.ContainsKey(nums[c + 1])) {\n                cnt.Add(nums[c + 1], 1);\n            } else {\n                ++cnt[nums[c + 1]];\n            }\n            for (int a = 0; a < c; ++a) {\n                for (int b = a + 1; b < c; ++b) {\n                    int sum = nums[a] + nums[b] + nums[c];\n                    if (cnt.ContainsKey(sum)) {\n                        ans += cnt[sum];\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        cnt = Counter()\n        for c in range(n - 2, 1, -1):\n            cnt[nums[c + 1]] += 1\n            for a in range(c):\n                for b in range(a + 1, c):\n                    if (total := nums[a] + nums[b] + nums[c]) in cnt:\n                        ans += cnt[total]\n        return ans\n```\n\n```go [sol2-Golang]\nfunc countQuadruplets(nums []int) (ans int) {\n    cnt := map[int]int{}\n    for c := len(nums) - 2; c >= 2; c-- {\n        cnt[nums[c+1]]++\n        for a, x := range nums[:c] {\n            for _, y := range nums[a+1 : c] {\n                if sum := x + y + nums[c]; cnt[sum] > 0 {\n                    ans += cnt[sum]\n                }\n            }\n        }\n    }\n    return\n}\n```\n\n```C [sol2-C]\n#define MAXN 500\n\nint countQuadruplets(int* nums, int numsSize){\n    int ans = 0;\n    int * cnt = (int *)malloc(sizeof(int) * MAXN);\n    memset(cnt, 0, sizeof(int) * MAXN);\n    for (int c = numsSize - 2; c >= 2; --c) {\n        cnt[nums[c + 1]]++;\n        for (int a = 0; a < c; ++a) {\n            for (int b = a + 1; b < c; ++b) {\n                ans += cnt[nums[a] + nums[b] + nums[c]];\n            }\n        }\n    }\n    free(cnt);\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^3)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。我们只需要枚举 $a, b, c$。\n\n- 空间复杂度：$O(\\min(n, C))$，其中 $C$ 是数组 $\\textit{nums}$ 中的元素范围，在本题中 $C = 100$。在返回最终答案前，哈希表中会存储数组 $\\textit{nums}$ 中的所有元素，种类不会超过 $\\min(n, C)$ 个。\n\n#### 方法三：使用哈希表存储 $\\textit{nums}[d] - \\textit{nums}[c]$\n\n**思路与算法**\n\n我们将等式左侧的 $\\textit{nums}[c]$ 移动到右侧，变为：\n\n$$\n\\textit{nums}[a] + \\textit{nums}[b] = \\textit{nums}[d] - \\textit{nums}[c]\n$$\n\n如果我们已经枚举了前两个下标 $a, b$，那么就已经知道了等式左侧 $\\textit{nums}[a] + \\textit{nums}[b]$ 的值，即为 $\\textit{nums}[d] - \\textit{nums}[c]$ 的值。对于下标 $c, d$ 而言，它的取值范围是 $b < c < d < n$，那么我们可以使用哈希表统计满足上述要求的每一种 $\\textit{nums}[d] - \\textit{nums}[c]$ 出现的次数。这样一来，我们就可以直接从哈希表中获得满足等式的 $c, d$ 的个数，而不需要在 $[b+1, n-1]$ 的范围内进行枚举了。\n\n**细节**\n\n在枚举前两个下标 $a, b$ 时，我们可以先**逆序**枚举 $b$。在 $b$ 减小的过程中，$c$ 的取值范围是逐渐增大的：即从 $b+1$ 减小到 $b$ 时，$c$ 的取值范围中多了 $b+1$ 这一项，而其余的项不变。因此我们只需要将所有满足 $c=b+1$ 且 $d>c$ 的 $c, d$ 对应的 $\\textit{nums}[d] - \\textit{nums}[c]$ 加入哈希表即可。\n\n在这之后，我们就可以枚举 $a$ 并使用哈希表计算答案了。\n\n**代码**\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    int countQuadruplets(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        unordered_map<int, int> cnt;\n        for (int b = n - 3; b >= 1; --b) {\n            for (int d = b + 2; d < n; ++d) {\n                ++cnt[nums[d] - nums[b + 1]];\n            }\n            for (int a = 0; a < b; ++a) {\n                if (int sum = nums[a] + nums[b]; cnt.count(sum)) {\n                    ans += cnt[sum];\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int countQuadruplets(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        for (int b = n - 3; b >= 1; --b) {\n            for (int d = b + 2; d < n; ++d) {\n                cnt.put(nums[d] - nums[b + 1], cnt.getOrDefault(nums[d] - nums[b + 1], 0) + 1);\n            }\n            for (int a = 0; a < b; ++a) {\n                ans += cnt.getOrDefault(nums[a] + nums[b], 0);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol3-C#]\npublic class Solution {\n    public int CountQuadruplets(int[] nums) {\n        int n = nums.Length;\n        int ans = 0;\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        for (int b = n - 3; b >= 1; --b) {\n            for (int d = b + 2; d < n; ++d) {\n                int difference = nums[d] - nums[b + 1];\n                if (!cnt.ContainsKey(difference)) {\n                    cnt.Add(difference, 1);\n                } else {\n                    ++cnt[difference];\n                }\n            }\n            for (int a = 0; a < b; ++a) {\n                int sum = nums[a] + nums[b];\n                if (cnt.ContainsKey(sum)) {\n                    ans += cnt[sum];\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol3-Python3]\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        cnt = Counter()\n        for b in range(n - 3, 0, -1):\n            for d in range(b + 2, n):\n                cnt[nums[d] - nums[b + 1]] += 1\n            for a in range(b):\n                if (total := nums[a] + nums[b]) in cnt:\n                    ans += cnt[total]\n        return ans\n```\n\n```go [sol3-Golang]\nfunc countQuadruplets(nums []int) (ans int) {\n    cnt := map[int]int{}\n    for b := len(nums) - 3; b >= 1; b-- {\n        for _, x := range nums[b+2:] {\n            cnt[x-nums[b+1]]++\n        }\n        for _, x := range nums[:b] {\n            if sum := x + nums[b]; cnt[sum] > 0 {\n                ans += cnt[sum]\n            }\n        }\n    }\n    return\n}\n```\n\n```C [sol3-C]\n#define MAXN 500\n\nint countQuadruplets(int* nums, int numsSize){\n    int ans = 0;\n    int * cnt = (int *)malloc(sizeof(int) * MAXN);\n    memset(cnt, 0, sizeof(int) * MAXN);\n    for (int b = numsSize - 3; b >= 1; --b) {\n        for (int d = b + 2; d < numsSize; ++d) {\n            if (nums[d] >= nums[b + 1]) {\n                ++cnt[nums[d] - nums[b + 1]];\n            }\n        }\n        for (int a = 0; a < b; ++a) {\n            ans += cnt[nums[a] + nums[b]];\n        }\n    }\n    free(cnt);\n    return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。我们只需要枚举 $a, b, d$，并且 $a$ 和 $d$ 的枚举没有嵌套关系。\n\n- 空间复杂度：$O(\\min(n, C)^2)$，其中 $C$ 是数组 $\\textit{nums}$ 中的元素范围，在本题中 $C = 100$。在返回最终答案前，哈希表中会存储数组 $\\textit{nums}$ 中两个下标不同元素的差值，种类不会超过 $\\dfrac{\\min(n, C)(\\min(n, C) - 1)}{2} = O(\\min(n, C)^2)$ 个。"
}