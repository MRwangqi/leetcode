{
	"titleSlug": "flood-fill",
	"slug": "tu-xiang-xuan-ran-by-leetcode-solution",
	"url": "https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/",
	"content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![...e 733 å›¾åƒæ¸²æŸ“ ä»²è€€æ™–_1.mp4](54b82e69-bfc2-4a7c-abd3-ceeaa03f9225)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### å‰è¨€\n\næœ¬é¢˜è¦æ±‚å°†ç»™å®šçš„äºŒç»´æ•°ç»„ä¸­æŒ‡å®šçš„ã€Œè‰²å—ã€æŸ“æˆå¦ä¸€ç§é¢œè‰²ã€‚ã€Œè‰²å—ã€çš„å®šä¹‰æ˜¯ï¼šç›´æ¥æˆ–é—´æ¥ç›¸é‚»çš„åŒè‰²æ–¹æ ¼æ„æˆçš„æ•´ä½“ã€‚\n\nå¯ä»¥å‘ç°ï¼Œã€Œè‰²å—ã€å°±æ˜¯è¢«ä¸åŒé¢œè‰²çš„æ–¹æ ¼åŒ…å›´çš„ä¸€ä¸ªåŒè‰²å²›å±¿ã€‚æˆ‘ä»¬ä»è‰²å—ä¸­ä»»æ„ä¸€ä¸ªåœ°æ–¹å¼€å§‹ï¼Œåˆ©ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢æˆ–æ·±åº¦ä¼˜å…ˆæœç´¢å³å¯éå†æ•´ä¸ªå²›å±¿ã€‚\n\næ³¨æ„ï¼šå½“ç›®æ ‡é¢œè‰²å’Œåˆå§‹é¢œè‰²ç›¸åŒæ—¶ï¼Œæˆ‘ä»¬æ— éœ€å¯¹åŸæ•°ç»„è¿›è¡Œä¿®æ”¹ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢\n\n**æ€è·¯åŠç®—æ³•**\n\næˆ‘ä»¬ä»ç»™å®šçš„èµ·ç‚¹å¼€å§‹ï¼Œè¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚æ¯æ¬¡æœç´¢åˆ°ä¸€ä¸ªæ–¹æ ¼æ—¶ï¼Œå¦‚æœå…¶ä¸åˆå§‹ä½ç½®çš„æ–¹æ ¼é¢œè‰²ç›¸åŒï¼Œå°±å°†è¯¥æ–¹æ ¼åŠ å…¥é˜Ÿåˆ—ï¼Œå¹¶å°†è¯¥æ–¹æ ¼çš„é¢œè‰²æ›´æ–°ï¼Œä»¥é˜²æ­¢é‡å¤å…¥é˜Ÿã€‚\n\næ³¨æ„ï¼šå› ä¸ºåˆå§‹ä½ç½®çš„é¢œè‰²ä¼šè¢«ä¿®æ”¹ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¿å­˜åˆå§‹ä½ç½®çš„é¢œè‰²ï¼Œä»¥ä¾¿äºä¹‹åçš„æ›´æ–°æ“ä½œã€‚\n\n**ä»£ç **\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    const int dx[4] = {1, 0, 0, -1};\n    const int dy[4] = {0, 1, -1, 0};\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n        int currColor = image[sr][sc];\n        if (currColor == color) {\n            return image;\n        }\n        int n = image.size(), m = image[0].size();\n        queue<pair<int, int>> que;\n        que.emplace(sr, sc);\n        image[sr][sc] = color;\n        while (!que.empty()) {\n            int x = que.front().first, y = que.front().second;\n            que.pop();\n            for (int i = 0; i < 4; i++) {\n                int mx = x + dx[i], my = y + dy[i];\n                if (mx >= 0 && mx < n && my >= 0 && my < m && image[mx][my] == currColor) {\n                    que.emplace(mx, my);\n                    image[mx][my] = color;\n                }\n            }\n        }\n        return image;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    int[] dx = {1, 0, 0, -1};\n    int[] dy = {0, 1, -1, 0};\n\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\n        int currColor = image[sr][sc];\n        if (currColor == color) {\n            return image;\n        }\n        int n = image.length, m = image[0].length;\n        Queue<int[]> queue = new LinkedList<int[]>();\n        queue.offer(new int[]{sr, sc});\n        image[sr][sc] = color;\n        while (!queue.isEmpty()) {\n            int[] cell = queue.poll();\n            int x = cell[0], y = cell[1];\n            for (int i = 0; i < 4; i++) {\n                int mx = x + dx[i], my = y + dy[i];\n                if (mx >= 0 && mx < n && my >= 0 && my < m && image[mx][my] == currColor) {\n                    queue.offer(new int[]{mx, my});\n                    image[mx][my] = color;\n                }\n            }\n        }\n        return image;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        currColor = image[sr][sc]\n        if currColor == color:\n            return image\n        \n        n, m = len(image), len(image[0])\n        que = collections.deque([(sr, sc)])\n        image[sr][sc] = color\n        while que:\n            x, y = que.popleft()\n            for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:\n                if 0 <= mx < n and 0 <= my < m and image[mx][my] == currColor:\n                    que.append((mx, my))\n                    image[mx][my] = color\n        \n        return image\n```\n\n```C [sol1-C]\nconst int dx[4] = {1, 0, 0, -1};\nconst int dy[4] = {0, 1, -1, 0};\n\nint** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes) {\n    int n = imageSize, m = imageColSize[0];\n    *returnSize = n;\n    for (int i = 0; i < n; i++) {\n        (*returnColumnSizes)[i] = m;\n    }\n    int currColor = image[sr][sc];\n    if (currColor == color) {\n        return image;\n    }\n    int que[n * m][2];\n    int l = 0, r = 0;\n    que[r][0] = sr, que[r++][1] = sc;\n    image[sr][sc] = color;\n    while (l < r) {\n        int x = que[l][0], y = que[l++][1];\n        for (int i = 0; i < 4; i++) {\n            int mx = x + dx[i], my = y + dy[i];\n            if (mx >= 0 && mx < n && my >= 0 && my < m && image[mx][my] == currColor) {\n                que[r][0] = mx, que[r++][1] = my;\n                image[mx][my] = color;\n            }\n        }\n    }\n    return image;\n}\n```\n\n```golang [sol1-Golang]\nvar (\n    dx = []int{1, 0, 0, -1}\n    dy = []int{0, 1, -1, 0}\n)\n\nfunc floodFill(image [][]int, sr int, sc int, color int) [][]int {\n    currColor := image[sr][sc]\n    if currColor == color {\n        return image\n    }\n    n, m := len(image), len(image[0])\n    queue := [][]int{}\n    queue = append(queue, []int{sr, sc})\n    image[sr][sc] = color\n    for i := 0; i < len(queue); i++ {\n        cell := queue[i]\n        for j := 0; j < 4; j++ {\n            mx, my := cell[0] + dx[j], cell[1] + dy[j]\n            if mx >= 0 && mx < n && my >= 0 && my < m && image[mx][my] == currColor {\n                queue = append(queue, []int{mx, my})\n                image[mx][my] = color\n            }\n        }\n    }\n    return image\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n\\times m)$ï¼Œå…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«æ˜¯äºŒç»´æ•°ç»„çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚æœ€åæƒ…å†µä¸‹éœ€è¦éå†æ‰€æœ‰çš„æ–¹æ ¼ä¸€æ¬¡ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n\\times m)$ï¼Œå…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«æ˜¯äºŒç»´æ•°ç»„çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚ä¸»è¦ä¸ºé˜Ÿåˆ—çš„å¼€é”€ã€‚\n\n#### æ–¹æ³•äºŒï¼šæ·±åº¦ä¼˜å…ˆæœç´¢\n\n**æ€è·¯åŠç®—æ³•**\n\næˆ‘ä»¬ä»ç»™å®šçš„èµ·ç‚¹å¼€å§‹ï¼Œè¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ã€‚æ¯æ¬¡æœç´¢åˆ°ä¸€ä¸ªæ–¹æ ¼æ—¶ï¼Œå¦‚æœå…¶ä¸åˆå§‹ä½ç½®çš„æ–¹æ ¼é¢œè‰²ç›¸åŒï¼Œå°±å°†è¯¥æ–¹æ ¼çš„é¢œè‰²æ›´æ–°ï¼Œä»¥é˜²æ­¢é‡å¤æœç´¢ï¼›å¦‚æœä¸ç›¸åŒï¼Œåˆ™è¿›è¡Œå›æº¯ã€‚\n\næ³¨æ„ï¼šå› ä¸ºåˆå§‹ä½ç½®çš„é¢œè‰²ä¼šè¢«ä¿®æ”¹ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¿å­˜åˆå§‹ä½ç½®çš„é¢œè‰²ï¼Œä»¥ä¾¿äºä¹‹åçš„æ›´æ–°æ“ä½œã€‚\n\n**ä»£ç **\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    const int dx[4] = {1, 0, 0, -1};\n    const int dy[4] = {0, 1, -1, 0};\n    void dfs(vector<vector<int>>& image, int x, int y, int currColor, int color) {\n        if (image[x][y] == currColor) {\n            image[x][y] = color;\n            for (int i = 0; i < 4; i++) {\n                int mx = x + dx[i], my = y + dy[i];\n                if (mx >= 0 && mx < image.size() && my >= 0 && my < image[0].size()) {\n                    dfs(image, mx, my, currColor, color);\n                }\n            }\n        }\n    }\n\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n        int currColor = image[sr][sc];\n        if (currColor != color) {\n            dfs(image, sr, sc, currColor, color);\n        }\n        return image;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    int[] dx = {1, 0, 0, -1};\n    int[] dy = {0, 1, -1, 0};\n\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\n        int currColor = image[sr][sc];\n        if (currColor != color) {\n            dfs(image, sr, sc, currColor, color);\n        }\n        return image;\n    }\n\n    public void dfs(int[][] image, int x, int y, int currColor, int color) {\n        if (image[x][y] == currColor) {\n            image[x][y] = color;\n            for (int i = 0; i < 4; i++) {\n                int mx = x + dx[i], my = y + dy[i];\n                if (mx >= 0 && mx < image.length && my >= 0 && my < image[0].length) {\n                    dfs(image, mx, my, currColor, color);\n                }\n            }\n        }\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        n, m = len(image), len(image[0])\n        currColor = image[sr][sc]\n\n        def dfs(x: int, y: int):\n            if image[x][y] == currColor:\n                image[x][y] = color\n                for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:\n                    if 0 <= mx < n and 0 <= my < m and image[mx][my] == currColor:\n                        dfs(mx, my)\n\n        if currColor != color:\n            dfs(sr, sc)\n        return image\n```\n\n```C [sol2-C]\nconst int dx[4] = {1, 0, 0, -1};\nconst int dy[4] = {0, 1, -1, 0};\n\nint n, m;\n\nvoid dfs(int** image, int x, int y, int currColor, int color) {\n    if (image[x][y] == currColor) {\n        image[x][y] = color;\n        for (int i = 0; i < 4; i++) {\n            int mx = x + dx[i], my = y + dy[i];\n            if (mx >= 0 && mx < n && my >= 0 && my < m) {\n                dfs(image, mx, my, currColor, color);\n            }\n        }\n    }\n}\n\nint** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes) {\n    n = imageSize, m = imageColSize[0];\n    *returnSize = n;\n    for (int i = 0; i < n; i++) {\n        (*returnColumnSizes)[i] = m;\n    }\n    int currColor = image[sr][sc];\n    if (currColor != color) {\n        dfs(image, sr, sc, currColor, color);\n    }\n    return image;\n}\n```\n\n```golang [sol2-Golang]\nvar (\n    dx = []int{1, 0, 0, -1}\n    dy = []int{0, 1, -1, 0}\n)\n\nfunc floodFill(image [][]int, sr int, sc int, color int) [][]int {\n    currColor := image[sr][sc]\n    if currColor != color {\n        dfs(image, sr, sc, currColor, color)\n    }\n    return image\n}\n\nfunc dfs(image [][]int, x, y, currColor, color int) {\n    if image[x][y] == currColor {\n        image[x][y] = color\n        for i := 0; i < 4; i++ {\n            mx, my := x + dx[i], y + dy[i]\n            if mx >= 0 && mx < len(image) && my >= 0 && my < len(image[0]) {\n                dfs(image, mx, my, currColor, color)\n            }\n        }\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n\\times m)$ï¼Œå…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«æ˜¯äºŒç»´æ•°ç»„çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚æœ€åæƒ…å†µä¸‹éœ€è¦éå†æ‰€æœ‰çš„æ–¹æ ¼ä¸€æ¬¡ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n\\times m)$ï¼Œå…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«æ˜¯äºŒç»´æ•°ç»„çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚ä¸»è¦ä¸ºæ ˆç©ºé—´çš„å¼€é”€ã€‚"
}