{
	"titleSlug": "fHi6rV",
	"slug": "python-by-condescending-paynebzr-w0tf",
	"url": "https://leetcode-cn.com/problems/fHi6rV/solution/python-by-condescending-paynebzr-w0tf/",
	"content": "```Python3 []\r\nDIRs=[[1,0],[-1,0],[1,-1],[-1,-1],[0,-1],[1,1],[-1,1],[0,1]]\r\n\r\nclass Solution:\r\n    def flipChess(self, chessboard: List[str]) -> int:\r\n        m,n=len(chessboard),len(chessboard[0])\r\n        q,ans=deque(),0\r\n        for x in range(m):\r\n            for y in range(n):\r\n                if chessboard[x][y]=='.':\r\n                    #生成棋盘的副本，将不可变对象字符串列表化，方便后续修改\r\n                    cbCopy=[list(row) for row in chessboard]\r\n                    cbCopy[x][y]='X'\r\n                    q.append((x,y))\r\n                    currAns=0\r\n\r\n                    #q为已落下待BFS的黑棋坐标队列\r\n                    while q:\r\n                        cx,cy=q.popleft()\r\n                        #对8个方向进行搜索\r\n                        for dx,dy in DIRs:\r\n                            nx,ny=cx+dx,cy+dy\r\n                            #搜索到白棋则继续向该方向搜索，直至越界或遇到黑棋\r\n                            while 0<=nx<m and 0<=ny<n and cbCopy[nx][ny]=='O':\r\n                                nx+=dx\r\n                                ny+=dy\r\n                            #若未越界且遇到黑棋，逐步返回起始点并将搜索路径上的白棋全部翻转\r\n                            if 0<=nx<m and 0<=ny<n and cbCopy[nx][ny]=='X':\r\n                                nx-=dx\r\n                                ny-=dy\r\n                                while nx!=cx or ny!=cy:\r\n                                    cbCopy[nx][ny]='X'\r\n                                    #将翻转白棋得到的黑棋加入队列进行下一轮搜索                        \r\n                                    q.append((nx,ny))\r\n                                    currAns+=1\r\n                                    nx-=dx\r\n                                    ny-=dy\r\n                    ans=max(ans,currAns)\r\n        return ans\r\n```"
}