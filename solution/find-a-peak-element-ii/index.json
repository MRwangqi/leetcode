{
	"titleSlug": "find-a-peak-element-ii",
	"slug": "by-haonshi-scrr",
	"url": "https://leetcode-cn.com/problems/find-a-peak-element-ii/solution/by-haonshi-scrr/",
	"content": "## 方法：二分法\n\n### 解题思路\n\n解决这道题的理论基础是：每一行的最大值中，一定存在一个最大值是峰值。\n\n通俗地证明一下，对于第 $i$ 行的最大值 $m[i][j]$，它已经比`左`、`右`相邻的数大，如果它不是峰值，那么它就是小于上一行或下一行的数。\n\n以它小于上一行的数 $m[i - 1][j]$ 为例，如果 $m[i - 1][j]$ 是这一行的最大值，它肯定比`左`、`右`、`下`相邻的数都大；即使它不是这一行的最大值，这一行的最大值 $m[i - 1][k]$ 也肯定跟比它下面相邻的 $m[i][k]$ 大。所以无论如何，在上一行都能找到一个比`左`、`右`、`下`相邻的数都大的值。\n\n接着，如果这个值还不是峰值，那就可以按照上面的步骤一直找下去直到找到或遇到边界为止，因为边界被视为`-1`，所以一定存在一个位置比`上`方向相邻的数大，那么我们就找到了同时比`左`、`右`、`下`、`上`相邻的数都大的数，也就是峰值。\n\n如果 $m[i][j]$ 小于下一行的数 $m[i + 1][j]$ 也是同理。\n\n既然朝着一个方向走一定能找到峰值，那么我们就可以通过**二分法**沿着一个维度快速地进行查找，从而将时间复杂度降到`O(m log(n))`或`O(n log(m))`。\n\n### 代码\n\n```C++ []\nclass Solution {\npublic:\n    vector<int> findPeakGrid(vector<vector<int>>& mat) {\n        int m = mat.size();\n        int n = mat[0].size();\n        // 在列方向进行二分查找，确定峰值所在行\n        int low = 0;\n        int high = m - 1;\n        while (low < high) {\n            int mid = (low + high) / 2;\n            // 获取mid行最大值的下标\n            int maxIndex = max_element(mat[mid].begin(), mat[mid].end()) - mat[mid].begin();\n            // 比下方的值小，下方一定存在峰值\n            if (mat[mid][maxIndex] < mat[mid + 1][maxIndex]) {\n                low = mid + 1;\n            } else {\n                high = mid; // 峰值是本身或在上方\n            }\n        }\n        // 找到峰值所在行，再确定这一行的最大值\n        int maxIndex = max_element(mat[low].begin(), mat[low].end()) - mat[low].begin();\n        return {low, maxIndex};\n    }\n};\n```"
}