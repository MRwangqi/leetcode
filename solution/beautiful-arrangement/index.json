{
	"titleSlug": "beautiful-arrangement",
	"slug": "you-mei-de-pai-lie-by-leetcode-solution-vea2",
	"url": "https://leetcode-cn.com/problems/beautiful-arrangement/solution/you-mei-de-pai-lie-by-leetcode-solution-vea2/",
	"content": "#### 方法一：回溯\n\n**思路和算法**\n\n我们可以使用回溯法解决本题，从左向右依次向目标排列中放入数即可。\n\n具体地，我们定义函数 $\\textit{backtrack}(\\textit{index}, n)$，表示尝试向位置 $\\textit{index}$ 放入数。其中 $n$ 表示排列的长度。在当前函数中，我们首先找到一个符合条件的未被使用过的数，然后递归地执行 $\\textit{backtrack}(\\textit{index}+1, n)$，当该函数执行完毕，回溯到当前层，我们再尝试下一个符合条件的未被使用过的数即可。\n\n回溯过程中，我们可以用 $\\textit{vis}$ 数组标记哪些数被使用过，每次我们选中一个数 $x$，我们就将 $\\textit{vis}[x]$ 标记为 $\\texttt{true}$，回溯完成后，我们再将其置为 $\\texttt{false}$。\n\n特别地，为了优化回溯效率，我们可以预处理每个位置的符合条件的数有哪些，用二维数组 $\\textit{match}$ 保存。当我们尝试向位置 $\\textit{index}$ 放入数时，我们只需要遍历 $\\textit{match}[\\textit{index}]$ 即可。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<vector<int>> match;\n    vector<int> vis;\n    int num;\n\n    void backtrack(int index, int n) {\n        if (index == n + 1) {\n            num++;\n            return;\n        }\n        for (auto &x : match[index]) {\n            if (!vis[x]) {\n                vis[x] = true;\n                backtrack(index + 1, n);\n                vis[x] = false;\n            }\n        }\n    }\n\n    int countArrangement(int n) {\n        vis.resize(n + 1);\n        match.resize(n + 1);\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (i % j == 0 || j % i == 0) {\n                    match[i].push_back(j);\n                }\n            }\n        }\n        backtrack(1, n);\n        return num;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    List<Integer>[] match;\n    boolean[] vis;\n    int num;\n\n    public int countArrangement(int n) {\n        vis = new boolean[n + 1];\n        match = new List[n + 1];\n        for (int i = 0; i <= n; i++) {\n            match[i] = new ArrayList<Integer>();\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (i % j == 0 || j % i == 0) {\n                    match[i].add(j);\n                }\n            }\n        }\n        backtrack(1, n);\n        return num;\n    }\n\n    public void backtrack(int index, int n) {\n        if (index == n + 1) {\n            num++;\n            return;\n        }\n        for (int x : match[index]) {\n            if (!vis[x]) {\n                vis[x] = true;\n                backtrack(index + 1, n);\n                vis[x] = false;\n            }\n        }\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    IList<int>[] match;\n    bool[] vis;\n    int num;\n\n    public int CountArrangement(int n) {\n        vis = new bool[n + 1];\n        match = new IList<int>[n + 1];\n        for (int i = 0; i <= n; i++) {\n            match[i] = new List<int>();\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (i % j == 0 || j % i == 0) {\n                    match[i].Add(j);\n                }\n            }\n        }\n        Backtrack(1, n);\n        return num;\n    }\n\n    public void Backtrack(int index, int n) {\n        if (index == n + 1) {\n            num++;\n            return;\n        }\n        foreach (int x in match[index]) {\n            if (!vis[x]) {\n                vis[x] = true;\n                Backtrack(index + 1, n);\n                vis[x] = false;\n            }\n        }\n    }\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar countArrangement = function(n) {\n    const vis = new Array(n + 1).fill(0);\n    const match = new Array(n + 1).fill(0);\n    let num = 0;\n    for (let i = 0; i <= n; i++) {\n        match[i] = [];\n    }\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (i % j === 0 || j % i === 0) {\n                match[i].push(j);\n            }\n        }\n    }\n\n    const backtrack = (index, n) => {\n        if (index === n + 1) {\n            num++;\n            return;\n        }\n        for (const x of match[index]) {\n            if (!vis[x]) {\n                vis[x] = true;\n                backtrack(index + 1, n);\n                vis[x] = false;\n            }\n        }\n    }\n    \n    backtrack(1, n);\n    return num;\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        match = defaultdict(list)\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i % j == 0 or j % i == 0:\n                    match[i].append(j)\n        \n        num = 0\n        vis = set()\n\n        def backtrack(index: int) -> None:\n            if index == n + 1:\n                nonlocal num\n                num += 1\n                return\n            \n            for x in match[index]:\n                if x not in vis:\n                    vis.add(x)\n                    backtrack(index + 1)\n                    vis.discard(x)\n                   \n        backtrack(1)\n        return num\n```\n\n```C [sol1-C]\nint **match;\nint *matchColSize;\nint *vis;\nint num;\n\nvoid backtrack(int index, int n) {\n    if (index == n + 1) {\n        num++;\n        return;\n    }\n    for (int i = 0; i < matchColSize[index]; i++) {\n        int x = match[index][i];\n        if (!vis[x]) {\n            vis[x] = true;\n            backtrack(index + 1, n);\n            vis[x] = false;\n        }\n    }\n}\n\nint countArrangement(int n) {\n    vis = malloc(sizeof(int) * (n + 1));\n    match = malloc(sizeof(int *) * (n + 1));\n    matchColSize = malloc(sizeof(int) * (n + 1));\n    memset(matchColSize, 0, sizeof(int) * (n + 1));\n    memset(vis, 0, sizeof(int) * (n + 1));\n    num = 0;\n    for (int i = 1; i <= n; i++) {\n        match[i] = malloc(sizeof(int) * (n));\n        for (int j = 1; j <= n; j++) {\n            if (i % j == 0 || j % i == 0) {\n                match[i][matchColSize[i]++] = j;\n            }\n        }\n    }\n    backtrack(1, n);\n    return num;\n}\n```\n\n```go [sol1-Golang]\nfunc countArrangement(n int) (ans int) {\n    vis := make([]bool, n+1)\n    match := make([][]int, n+1)\n    for i := 1; i <= n; i++ {\n        for j := 1; j <= n; j++ {\n            if i%j == 0 || j%i == 0 {\n                match[i] = append(match[i], j)\n            }\n        }\n    }\n\n    var backtrack func(int)\n    backtrack = func(index int) {\n        if index > n {\n            ans++\n            return\n        }\n        for _, x := range match[index] {\n            if !vis[x] {\n                vis[x] = true\n                backtrack(index + 1)\n                vis[x] = false\n            }\n        }\n    }\n    backtrack(1)\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n!)$，其中 $n$ 为排列的长度。预处理 $\\textit{match}$ 数组的时间复杂度为 $O(n^2)$，回溯的时间复杂度为 $O(n!)$，因此总时间复杂度为 $O(n^2 + n!) = O(n!)$。\n\n- 空间复杂度：$O(n^2)$，我们需要 $O(n^2)$ 的空间保存 $\\textit{match}$ 数组，递归的栈空间大小为 $O(n)$，因此总空间复杂度为 $O(n^2 + n) = O(n^2)$。\n\n\n#### 方法二：状态压缩 + 动态规划\n\n**思路和算法**\n\n由于题目保证了排列的长度 $n$ 至多为 $15$，因此我们可以用一个位数为 $n$ 的二进制数 $\\textit{mask}$ 表示排列中的数被选取的情况。若 $\\textit{mask}$ 中的第 $i$ 位为 $1$（从 $0$ 开始编号），则数 $i+1$ 已经被选取，否则就还未被选取。我们可以利用这样的二进制数表示选取数的过程的状态，以 $n = 4, \\textit{mask} = (0110)_2$ 为例，这代表数 $2,3$ 都已经被选取，并以任意顺序放置在排列中前两个位置。\n\n令 $f[\\textit{mask}]$ 表示状态为 $\\textit{mask}$ 时的可行方案总数，这样答案即为 $f[2^n - 1]$。\n\n这样我们可以得到状态间的转移方程：\n\n$$\nf[\\textit{mask}] = \\sum_{i \\in \\textit{mask} ~\\wedge \\big( i+1 \\mid \\textit{num}(\\textit{mask}) ~\\vee~ \\textit{num}(\\textit{mask}) \\mid i+1 \\big) } f[\\textit{mask} - 2^i]\n$$\n\n其中 $\\textit{num}(\\textit{mask})$ 表示二进制数 $\\textit{mask}$ 中 $1$ 的个数，$x \\mid y$ 表示 $x$ 可以整除 $y$。\n\n状态转移方程的含义为，当我们想要计算 $f[\\textit{mask}]$ 时，我们只需要在前 $\\textit{num}(\\textit{mask}) - 1$ 位都已经放置了数的情况下，考虑第 $\\textit{num}(\\textit{mask})$ 位要放置的数即可，我们枚举当前位的符合条件的数，并将方案数累加到 $f[\\textit{mask}]$ 中即可。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int countArrangement(int n) {\n        vector<int> f(1 << n);\n        f[0] = 1;\n        for (int mask = 1; mask < (1 << n); mask++) {\n            int num = __builtin_popcount(mask);\n            for (int i = 0; i < n; i++) {\n                if (mask & (1 << i) && (num % (i + 1) == 0 || (i + 1) % num == 0)) {\n                    f[mask] += f[mask ^ (1 << i)];\n                }\n            }\n        }\n        return f[(1 << n) - 1];\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int countArrangement(int n) {\n        int[] f = new int[1 << n];\n        f[0] = 1;\n        for (int mask = 1; mask < (1 << n); mask++) {\n            int num = Integer.bitCount(mask);\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0 && ((num % (i + 1)) == 0 || (i + 1) % num == 0)) {\n                    f[mask] += f[mask ^ (1 << i)];\n                }\n            }\n        }\n        return f[(1 << n) - 1];\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int CountArrangement(int n) {\n        int[] f = new int[1 << n];\n        f[0] = 1;\n        for (int mask = 1; mask < (1 << n); mask++) {\n            int num = BitCount(mask);\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0 && ((num % (i + 1)) == 0 || (i + 1) % num == 0)) {\n                    f[mask] += f[mask ^ (1 << i)];\n                }\n            }\n        }\n        return f[(1 << n) - 1];\n    }\n\n    private static int BitCount(int i) {\n        i = i - ((i >> 1) & 0x55555555);\n        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n        i = (i + (i >> 4)) & 0x0f0f0f0f;\n        i = i + (i >> 8);\n        i = i + (i >> 16);\n        return i & 0x3f;\n    }\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar countArrangement = function(n) {\n    const f = new Array(1 << n).fill(0);\n    f[0] = 1;\n    for (let mask = 1; mask < (1 << n); mask++) {\n        const num = mask.toString(2).split('0').join('').length\n        for (let i = 0; i < n; i++) {\n            if ((mask & (1 << i)) !== 0 && ((num % (i + 1)) === 0 || (i + 1) % num === 0)) {\n                f[mask] += f[mask ^ (1 << i)];\n            }\n        }\n    }\n    return f[(1 << n) - 1];\n};\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        f = [0] * (1 << n)\n        f[0] = 1\n        for mask in range(1, 1 << n):\n            num = bin(mask).count(\"1\")\n            for i in range(n):\n                if mask & (1 << i) and (num % (i + 1) == 0 or (i + 1) % num == 0):\n                    f[mask] += f[mask ^ (1 << i)]\n        \n        return f[(1 << n) - 1]\n```\n\n```C [sol2-C]\nint countArrangement(int n) {\n    int f[1 << n];\n    memset(f, 0, sizeof(f));\n    f[0] = 1;\n    for (int mask = 1; mask < (1 << n); mask++) {\n        int num = __builtin_popcount(mask);\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i) && (num % (i + 1) == 0 || (i + 1) % num == 0)) {\n                f[mask] += f[mask ^ (1 << i)];\n            }\n        }\n    }\n    return f[(1 << n) - 1];\n}\n```\n\n```go [sol2-Golang]\nfunc countArrangement(n int) int {\n    f := make([]int, 1<<n)\n    f[0] = 1\n    for mask := 1; mask < 1<<n; mask++ {\n        num := bits.OnesCount(uint(mask))\n        for i := 0; i < n; i++ {\n            if mask>>i&1 > 0 && (num%(i+1) == 0 || (i+1)%num == 0) {\n                f[mask] += f[mask^1<<i]\n            }\n        }\n    }\n    return f[1<<n-1]\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n \\times 2^n)$，其中 $n$ 为排列的长度。我们需要 $O(2^n)$ 的时间枚举所有状态，每个状态需要 $O(n)$ 的时间检查所有符合条件的数。因此总时间复杂度为 $O(n \\times 2^n)$。\n\n- 空间复杂度：$O(2^n)$，其中 $n$ 为排列的长度。我们需要 $O(2^n)$ 的空间保存状态。"
}