{
	"titleSlug": "brace-expansion-ii",
	"slug": "by-masx200-r25j",
	"url": "https://leetcode-cn.com/problems/brace-expansion-ii/solution/by-masx200-r25j/",
	"content": "### 解题思路\n正则表达式+哈希表+排序+深度优先搜索+递归\n生成抽象语法树\n### 代码\n\n```typescript []\nfunction braceExpansionII(s: string): string[] {\n    if (s.includes(\"{\")) {\n        const m = parse(s);\n\n        if (typeof m === \"string\") return [m];\n        return deduplication(evaluate(m)).sort();\n    } else {\n        return [s];\n    }\n}\nfunction deduplication<T>(iter: Iterable<T>): Array<T> {\n    return Array.from(new Set(iter));\n}\n function parse(s: string): Expression | string {\n    const m = s.match(/\\,|\\{|\\}|[a-z]+/g) ?? [];\n    if (!m || !m.length) return { type: \"AddExpression\", children: [] };\n\n    let i = 0;\n\n    function dfs(): Expression | string {\n        const a: (string | Expression)[] = [];\n\n        while (i < m.length) {\n            const value = m[i];\n            if (value === \"{\") {\n                i++;\n                a.push(dfs());\n            } else if (value === \"}\") {\n                i++;\n                break;\n            } else {\n                a.push(value);\n                i++;\n            }\n        }\n\n        if (a.length == 1) {\n            return a[0];\n        }\n        return a.includes(\",\")\n            ? splitAdd(a)\n            : { type: \"MultExpression\", children: a };\n    }\n    const r = dfs();\n    return r;\n}\nfunction splitAdd(a: (string | Expression)[]): Expression | string {\n    const e: AddExpression = { type: \"AddExpression\", children: [] };\n    if (a.length === 1) return a[0];\n    const index = a.indexOf(\",\");\n    if (index < 0) return { type: \"MultExpression\", children: a };\n\n    if (index === 1) {\n        e.children.push(a[0]);\n    } else {\n        e.children.push({\n            type: \"MultExpression\",\n            children: a.slice(0, index),\n        });\n    }\n    e.children.push(splitAdd(a.slice(index + 1)));\n    if (e.children.length == 1) {\n        return e.children[0];\n    }\n    return e;\n}\n function evaluate(m: Expression | string): string[] {\n    if (typeof m === \"string\") return [m];\n\n    if (m.type === \"MultExpression\") {\n        return m.children.reduce((p: string[], c): string[] => {\n            const left = p;\n            const right = typeof c === \"string\" ? [c] : evaluate(c);\n            if (p.length === 0) return right;\n            return left.map((v) => right.map((r) => v + r)).flat();\n        }, [] as string[]);\n    } else {\n        return m.children.map(evaluate).flat();\n    }\n}\n type Expression = AddExpression | MultExpression;\n\n interface AddExpression {\n    type: \"AddExpression\";\n    children: (Expression | string)[];\n}\n interface MultExpression {\n    type: \"MultExpression\";\n    children: (Expression | string)[];\n}\n```\n\n```javascript []\nfunction n(n) {\n  const t = n.match(/\\,|\\{|\\}|[a-z]+/g) ?? [];\n  if (!t || !t.length) return { type: \"AddExpression\", children: [] };\n  let r = 0;\n  const i = (function n() {\n    const i = [];\n    for (; r < t.length; ) {\n      const e = t[r];\n      if (\"{\" === e) r++, i.push(n());\n      else {\n        if (\"}\" === e) {\n          r++;\n          break;\n        }\n        i.push(e), r++;\n      }\n    }\n    return 1 == i.length\n      ? i[0]\n      : i.includes(\",\")\n      ? e(i)\n      : { type: \"MultExpression\", children: i };\n  })();\n  return i;\n}\nfunction e(n) {\n  const t = { type: \"AddExpression\", children: [] };\n  if (1 === n.length) return n[0];\n  const r = n.indexOf(\",\");\n  return r < 0\n    ? { type: \"MultExpression\", children: n }\n    : (1 === r\n        ? t.children.push(n[0])\n        : t.children.push({ type: \"MultExpression\", children: n.slice(0, r) }),\n      t.children.push(e(n.slice(r + 1))),\n      1 == t.children.length ? t.children[0] : t);\n}\nfunction t(n) {\n  return \"string\" == typeof n\n    ? [n]\n    : \"MultExpression\" === n.type\n    ? n.children.reduce((n, e) => {\n        const r = n,\n          i = \"string\" == typeof e ? [e] : t(e);\n        return 0 === n.length ? i : r.map((n) => i.map((e) => n + e)).flat();\n      }, [])\n    : n.children.map(t).flat();\n}\n function braceExpansionII(e) {\n  if (e.includes(\"{\")) {\n    const i = n(e);\n    return \"string\" == typeof i\n      ? [i]\n      : ((r = t(i)), Array.from(new Set(r))).sort();\n  }\n  return [e];\n  var r;\n}\n\n```"
}