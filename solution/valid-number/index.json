{
	"titleSlug": "valid-number",
	"slug": "you-xiao-shu-zi-by-leetcode-solution-298l",
	"url": "https://leetcode-cn.com/problems/valid-number/solution/you-xiao-shu-zi-by-leetcode-solution-298l/",
	"content": "#### 方法一：确定有限状态自动机\n\n**预备知识**\n\n确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：\n\n- 有一个特殊的状态，被称作「初始状态」。\n- 还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。\n\n起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。\n\n**注意**：如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。\n\n一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。\n\n自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。\n\n自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP 算法」有着密切的关联；在工程领域，它是实现「正则表达式」的基础。\n\n**问题描述**\n\n在 [C++ 文档](https://en.cppreference.com/w/cpp/language/floating_literal) 中，描述了一个合法的数值字符串应当具有的格式。具体而言，它包含以下部分：\n- 符号位，即 $+$、$-$ 两种符号\n- 整数部分，即由若干字符 $0-9$ 组成的字符串\n- 小数点\n- 小数部分，其构成与整数部分相同\n- 指数部分，其中包含开头的字符 $\\text{e}$（大写小写均可）、可选的符号位，和整数部分\n\n在上面描述的五个部分中，每个部分都不是必需的，但也受一些额外规则的制约，如：\n- 如果符号位存在，其后面必须跟着数字或小数点。\n- 小数点的前后两侧，至少有一侧是数字。\n\n**思路与算法**\n\n根据上面的描述，现在可以定义自动机的「状态集合」了。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：\n\n0. 初始状态\n1. 符号位\n2. 整数部分\n3. 左侧有整数的小数点\n4. 左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）\n5. 小数部分\n6. 字符 $\\text{e}$\n7. 指数部分的符号位\n8. 指数部分的整数部分\n\n下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 0，而「接受状态」的集合则为状态 2、状态 3、状态 5 以及状态 8。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。\n\n最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程以图解的方式表示出来：\n\n![fig1](https://assets.leetcode-cn.com/solution-static/65/1.png)\n\n比较上图与「预备知识」一节中对自动机的描述，可以看出有一点不同：\n- 我们没有单独地考虑每种字符，而是划分为若干类。由于全部 $10$ 个数字字符彼此之间都等价，因此只需定义一种统一的「数字」类型即可。对于正负号也是同理。\n\n在实际代码中，我们需要处理转移失败的情况。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。\n\n**代码**\n\n可以很简单地将上面的状态转移图翻译成代码：\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    enum State {\n        STATE_INITIAL,\n        STATE_INT_SIGN,\n        STATE_INTEGER,\n        STATE_POINT,\n        STATE_POINT_WITHOUT_INT,\n        STATE_FRACTION,\n        STATE_EXP,\n        STATE_EXP_SIGN,\n        STATE_EXP_NUMBER,\n        STATE_END\n    };\n\n    enum CharType {\n        CHAR_NUMBER,\n        CHAR_EXP,\n        CHAR_POINT,\n        CHAR_SIGN,\n        CHAR_ILLEGAL\n    };\n\n    CharType toCharType(char ch) {\n        if (ch >= '0' && ch <= '9') {\n            return CHAR_NUMBER;\n        } else if (ch == 'e' || ch == 'E') {\n            return CHAR_EXP;\n        } else if (ch == '.') {\n            return CHAR_POINT;\n        } else if (ch == '+' || ch == '-') {\n            return CHAR_SIGN;\n        } else {\n            return CHAR_ILLEGAL;\n        }\n    }\n\n    bool isNumber(string s) {\n        unordered_map<State, unordered_map<CharType, State>> transfer{\n            {\n                STATE_INITIAL, {\n                    {CHAR_NUMBER, STATE_INTEGER},\n                    {CHAR_POINT, STATE_POINT_WITHOUT_INT},\n                    {CHAR_SIGN, STATE_INT_SIGN}\n                }\n            }, {\n                STATE_INT_SIGN, {\n                    {CHAR_NUMBER, STATE_INTEGER},\n                    {CHAR_POINT, STATE_POINT_WITHOUT_INT}\n                }\n            }, {\n                STATE_INTEGER, {\n                    {CHAR_NUMBER, STATE_INTEGER},\n                    {CHAR_EXP, STATE_EXP},\n                    {CHAR_POINT, STATE_POINT}\n                }\n            }, {\n                STATE_POINT, {\n                    {CHAR_NUMBER, STATE_FRACTION},\n                    {CHAR_EXP, STATE_EXP}\n                }\n            }, {\n                STATE_POINT_WITHOUT_INT, {\n                    {CHAR_NUMBER, STATE_FRACTION}\n                }\n            }, {\n                STATE_FRACTION,\n                {\n                    {CHAR_NUMBER, STATE_FRACTION},\n                    {CHAR_EXP, STATE_EXP}\n                }\n            }, {\n                STATE_EXP,\n                {\n                    {CHAR_NUMBER, STATE_EXP_NUMBER},\n                    {CHAR_SIGN, STATE_EXP_SIGN}\n                }\n            }, {\n                STATE_EXP_SIGN, {\n                    {CHAR_NUMBER, STATE_EXP_NUMBER}\n                }\n            }, {\n                STATE_EXP_NUMBER, {\n                    {CHAR_NUMBER, STATE_EXP_NUMBER}\n                }\n            }\n        };\n\n        int len = s.length();\n        State st = STATE_INITIAL;\n\n        for (int i = 0; i < len; i++) {\n            CharType typ = toCharType(s[i]);\n            if (transfer[st].find(typ) == transfer[st].end()) {\n                return false;\n            } else {\n                st = transfer[st][typ];\n            }\n        }\n        return st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean isNumber(String s) {\n        Map<State, Map<CharType, State>> transfer = new HashMap<State, Map<CharType, State>>();\n        Map<CharType, State> initialMap = new HashMap<CharType, State>() {{\n            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);\n            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);\n            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);\n        }};\n        transfer.put(State.STATE_INITIAL, initialMap);\n        Map<CharType, State> intSignMap = new HashMap<CharType, State>() {{\n            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);\n            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);\n        }};\n        transfer.put(State.STATE_INT_SIGN, intSignMap);\n        Map<CharType, State> integerMap = new HashMap<CharType, State>() {{\n            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);\n            put(CharType.CHAR_EXP, State.STATE_EXP);\n            put(CharType.CHAR_POINT, State.STATE_POINT);\n        }};\n        transfer.put(State.STATE_INTEGER, integerMap);\n        Map<CharType, State> pointMap = new HashMap<CharType, State>() {{\n            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);\n            put(CharType.CHAR_EXP, State.STATE_EXP);\n        }};\n        transfer.put(State.STATE_POINT, pointMap);\n        Map<CharType, State> pointWithoutIntMap = new HashMap<CharType, State>() {{\n            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);\n        }};\n        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);\n        Map<CharType, State> fractionMap = new HashMap<CharType, State>() {{\n            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);\n            put(CharType.CHAR_EXP, State.STATE_EXP);\n        }};\n        transfer.put(State.STATE_FRACTION, fractionMap);\n        Map<CharType, State> expMap = new HashMap<CharType, State>() {{\n            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);\n            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);\n        }};\n        transfer.put(State.STATE_EXP, expMap);\n        Map<CharType, State> expSignMap = new HashMap<CharType, State>() {{\n            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);\n        }};\n        transfer.put(State.STATE_EXP_SIGN, expSignMap);\n        Map<CharType, State> expNumberMap = new HashMap<CharType, State>() {{\n            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);\n        }};\n        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);\n\n        int length = s.length();\n        State state = State.STATE_INITIAL;\n\n        for (int i = 0; i < length; i++) {\n            CharType type = toCharType(s.charAt(i));\n            if (!transfer.get(state).containsKey(type)) {\n                return false;\n            } else {\n                state = transfer.get(state).get(type);\n            }\n        }\n        return state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;\n    }\n\n    public CharType toCharType(char ch) {\n        if (ch >= '0' && ch <= '9') {\n            return CharType.CHAR_NUMBER;\n        } else if (ch == 'e' || ch == 'E') {\n            return CharType.CHAR_EXP;\n        } else if (ch == '.') {\n            return CharType.CHAR_POINT;\n        } else if (ch == '+' || ch == '-') {\n            return CharType.CHAR_SIGN;\n        } else {\n            return CharType.CHAR_ILLEGAL;\n        }\n    }\n\n    enum State {\n        STATE_INITIAL,\n        STATE_INT_SIGN,\n        STATE_INTEGER,\n        STATE_POINT,\n        STATE_POINT_WITHOUT_INT,\n        STATE_FRACTION,\n        STATE_EXP,\n        STATE_EXP_SIGN,\n        STATE_EXP_NUMBER,\n        STATE_END\n    }\n\n    enum CharType {\n        CHAR_NUMBER,\n        CHAR_EXP,\n        CHAR_POINT,\n        CHAR_SIGN,\n        CHAR_ILLEGAL\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public bool IsNumber(string s) {\n        Dictionary<State, Dictionary<CharType, State>> transfer = new Dictionary<State, Dictionary<CharType, State>>();\n        Dictionary<CharType, State> initialDictionary = new Dictionary<CharType, State> {\n            {CharType.CHAR_NUMBER, State.STATE_INTEGER},\n            {CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT},\n            {CharType.CHAR_SIGN, State.STATE_INT_SIGN}\n        };\n        transfer.Add(State.STATE_INITIAL, initialDictionary);\n        Dictionary<CharType, State> intSignDictionary = new Dictionary<CharType, State> {\n            {CharType.CHAR_NUMBER, State.STATE_INTEGER},\n            {CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT}\n        };\n        transfer.Add(State.STATE_INT_SIGN, intSignDictionary);\n        Dictionary<CharType, State> integerDictionary = new Dictionary<CharType, State> {\n            {CharType.CHAR_NUMBER, State.STATE_INTEGER},\n            {CharType.CHAR_EXP, State.STATE_EXP},\n            {CharType.CHAR_POINT, State.STATE_POINT}\n        };\n        transfer.Add(State.STATE_INTEGER, integerDictionary);\n        Dictionary<CharType, State> pointDictionary = new Dictionary<CharType, State> {\n            {CharType.CHAR_NUMBER, State.STATE_FRACTION},\n            {CharType.CHAR_EXP, State.STATE_EXP}\n        };\n        transfer.Add(State.STATE_POINT, pointDictionary);\n        Dictionary<CharType, State> pointWithoutIntDictionary = new Dictionary<CharType, State> {\n            {CharType.CHAR_NUMBER, State.STATE_FRACTION}\n        };\n        transfer.Add(State.STATE_POINT_WITHOUT_INT, pointWithoutIntDictionary);\n        Dictionary<CharType, State> fractionDictionary = new Dictionary<CharType, State> {\n            {CharType.CHAR_NUMBER, State.STATE_FRACTION},\n            {CharType.CHAR_EXP, State.STATE_EXP}\n        };\n        transfer.Add(State.STATE_FRACTION, fractionDictionary);\n        Dictionary<CharType, State> expDictionary = new Dictionary<CharType, State> {\n            {CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER},\n            {CharType.CHAR_SIGN, State.STATE_EXP_SIGN}\n        };\n        transfer.Add(State.STATE_EXP, expDictionary);\n        Dictionary<CharType, State> expSignDictionary = new Dictionary<CharType, State> {\n            {CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER}\n        };\n        transfer.Add(State.STATE_EXP_SIGN, expSignDictionary);\n        Dictionary<CharType, State> expNumberDictionary = new Dictionary<CharType, State> {\n            {CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER}\n        };\n        transfer.Add(State.STATE_EXP_NUMBER, expNumberDictionary);\n\n        int length = s.Length;\n        State state = State.STATE_INITIAL;\n\n        for (int i = 0; i < length; i++) {\n            CharType type = ToCharType(s[i]);\n            if (!transfer[state].ContainsKey(type)) {\n                return false;\n            } else {\n                state = transfer[state][type];\n            }\n        }\n        return state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;\n    }\n\n    CharType ToCharType(char ch) {\n        if (ch >= '0' && ch <= '9') {\n            return CharType.CHAR_NUMBER;\n        } else if (ch == 'e' || ch == 'E') {\n            return CharType.CHAR_EXP;\n        } else if (ch == '.') {\n            return CharType.CHAR_POINT;\n        } else if (ch == '+' || ch == '-') {\n            return CharType.CHAR_SIGN;\n        } else {\n            return CharType.CHAR_ILLEGAL;\n        }\n    }\n\n    enum State {\n        STATE_INITIAL,\n        STATE_INT_SIGN,\n        STATE_INTEGER,\n        STATE_POINT,\n        STATE_POINT_WITHOUT_INT,\n        STATE_FRACTION,\n        STATE_EXP,\n        STATE_EXP_SIGN,\n        STATE_EXP_NUMBER,\n        STATE_END\n    }\n\n    enum CharType {\n        CHAR_NUMBER,\n        CHAR_EXP,\n        CHAR_POINT,\n        CHAR_SIGN,\n        CHAR_ILLEGAL\n    }\n}\n```\n\n```golang [sol1-Golang]\ntype State int\ntype CharType int\n\nconst (\n    STATE_INITIAL State = iota\n    STATE_INT_SIGN\n    STATE_INTEGER\n    STATE_POINT\n    STATE_POINT_WITHOUT_INT\n    STATE_FRACTION\n    STATE_EXP\n    STATE_EXP_SIGN\n    STATE_EXP_NUMBER\n    STATE_END\n)\n\nconst (\n    CHAR_NUMBER CharType = iota\n    CHAR_EXP\n    CHAR_POINT\n    CHAR_SIGN\n    CHAR_ILLEGAL\n)\n\nfunc toCharType(ch byte) CharType {\n    switch ch {\n    case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n        return CHAR_NUMBER\n    case 'e', 'E':\n        return CHAR_EXP\n    case '.':\n        return CHAR_POINT\n    case '+', '-':\n        return CHAR_SIGN\n    default:\n        return CHAR_ILLEGAL\n    }\n}\n\nfunc isNumber(s string) bool {\n    transfer := map[State]map[CharType]State{\n        STATE_INITIAL: map[CharType]State{\n            CHAR_NUMBER: STATE_INTEGER,\n            CHAR_POINT:  STATE_POINT_WITHOUT_INT,\n            CHAR_SIGN:   STATE_INT_SIGN,\n        },\n        STATE_INT_SIGN: map[CharType]State{\n            CHAR_NUMBER: STATE_INTEGER,\n            CHAR_POINT:  STATE_POINT_WITHOUT_INT,\n        },\n        STATE_INTEGER: map[CharType]State{\n            CHAR_NUMBER: STATE_INTEGER,\n            CHAR_EXP:    STATE_EXP,\n            CHAR_POINT:  STATE_POINT,\n        },\n        STATE_POINT: map[CharType]State{\n            CHAR_NUMBER: STATE_FRACTION,\n            CHAR_EXP:    STATE_EXP,\n        },\n        STATE_POINT_WITHOUT_INT: map[CharType]State{\n            CHAR_NUMBER: STATE_FRACTION,\n        },\n        STATE_FRACTION: map[CharType]State{\n            CHAR_NUMBER: STATE_FRACTION,\n            CHAR_EXP:    STATE_EXP,\n        },\n        STATE_EXP: map[CharType]State{\n            CHAR_NUMBER: STATE_EXP_NUMBER,\n            CHAR_SIGN:   STATE_EXP_SIGN,\n        },\n        STATE_EXP_SIGN: map[CharType]State{\n            CHAR_NUMBER: STATE_EXP_NUMBER,\n        },\n        STATE_EXP_NUMBER: map[CharType]State{\n            CHAR_NUMBER: STATE_EXP_NUMBER,\n        },\n    }\n    state := STATE_INITIAL\n    for i := 0; i < len(s); i++ {\n        typ := toCharType(s[i])\n        if _, ok := transfer[state][typ]; !ok {\n            return false\n        } else {\n            state = transfer[state][typ]\n        }\n    }\n    return state == STATE_INTEGER || state == STATE_POINT || state == STATE_FRACTION || state == STATE_EXP_NUMBER || state == STATE_END\n}\n```\n\n```C [sol1-C]\nenum State {\n    STATE_INITIAL,\n    STATE_INT_SIGN,\n    STATE_INTEGER,\n    STATE_POINT,\n    STATE_POINT_WITHOUT_INT,\n    STATE_FRACTION,\n    STATE_EXP,\n    STATE_EXP_SIGN,\n    STATE_EXP_NUMBER,\n    STATE_END,\n    STATE_ILLEGAL\n};\n\nenum CharType {\n    CHAR_NUMBER,\n    CHAR_EXP,\n    CHAR_POINT,\n    CHAR_SIGN,\n    CHAR_ILLEGAL\n};\n\nenum CharType toCharType(char ch) {\n    if (ch >= '0' && ch <= '9') {\n        return CHAR_NUMBER;\n    } else if (ch == 'e' || ch == 'E') {\n        return CHAR_EXP;\n    } else if (ch == '.') {\n        return CHAR_POINT;\n    } else if (ch == '+' || ch == '-') {\n        return CHAR_SIGN;\n    } else {\n        return CHAR_ILLEGAL;\n    }\n}\n\nenum State transfer(enum State st, enum CharType typ) {\n    switch (st) {\n        case STATE_INITIAL: {\n            switch (typ) {\n                case CHAR_NUMBER:\n                    return STATE_INTEGER;\n                case CHAR_POINT:\n                    return STATE_POINT_WITHOUT_INT;\n                case CHAR_SIGN:\n                    return STATE_INT_SIGN;\n                default:\n                    return STATE_ILLEGAL;\n            }\n        }\n        case STATE_INT_SIGN: {\n            switch (typ) {\n                case CHAR_NUMBER:\n                    return STATE_INTEGER;\n                case CHAR_POINT:\n                    return STATE_POINT_WITHOUT_INT;\n                default:\n                    return STATE_ILLEGAL;\n            }\n        }\n        case STATE_INTEGER: {\n            switch (typ) {\n                case CHAR_NUMBER:\n                    return STATE_INTEGER;\n                case CHAR_EXP:\n                    return STATE_EXP;\n                case CHAR_POINT:\n                    return STATE_POINT;\n                default:\n                    return STATE_ILLEGAL;\n            }\n        }\n        case STATE_POINT: {\n            switch (typ) {\n                case CHAR_NUMBER:\n                    return STATE_FRACTION;\n                case CHAR_EXP:\n                    return STATE_EXP;\n                default:\n                    return STATE_ILLEGAL;\n            }\n        }\n        case STATE_POINT_WITHOUT_INT: {\n            switch (typ) {\n                case CHAR_NUMBER:\n                    return STATE_FRACTION;\n                default:\n                    return STATE_ILLEGAL;\n            }\n        }\n        case STATE_FRACTION: {\n            switch (typ) {\n                case CHAR_NUMBER:\n                    return STATE_FRACTION;\n                case CHAR_EXP:\n                    return STATE_EXP;\n                default:\n                    return STATE_ILLEGAL;\n            }\n        }\n        case STATE_EXP: {\n            switch (typ) {\n                case CHAR_NUMBER:\n                    return STATE_EXP_NUMBER;\n                case CHAR_SIGN:\n                    return STATE_EXP_SIGN;\n                default:\n                    return STATE_ILLEGAL;\n            }\n        }\n        case STATE_EXP_SIGN: {\n            switch (typ) {\n                case CHAR_NUMBER:\n                    return STATE_EXP_NUMBER;\n                default:\n                    return STATE_ILLEGAL;\n            }\n        }\n        case STATE_EXP_NUMBER: {\n            switch (typ) {\n                case CHAR_NUMBER:\n                    return STATE_EXP_NUMBER;\n                default:\n                    return STATE_ILLEGAL;\n            }\n        }\n        default:\n            return STATE_ILLEGAL;\n    }\n}\n\nbool isNumber(char* s) {\n    int len = strlen(s);\n    enum State st = STATE_INITIAL;\n\n    for (int i = 0; i < len; i++) {\n        enum CharType typ = toCharType(s[i]);\n        enum State nextState = transfer(st, typ);\n        if (nextState == STATE_ILLEGAL) return false;\n        st = nextState;\n    }\n    return st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END;\n}\n```\n\n```Python [sol1-Python3]\nfrom enum import Enum\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        State = Enum(\"State\", [\n            \"STATE_INITIAL\",\n            \"STATE_INT_SIGN\",\n            \"STATE_INTEGER\",\n            \"STATE_POINT\",\n            \"STATE_POINT_WITHOUT_INT\",\n            \"STATE_FRACTION\",\n            \"STATE_EXP\",\n            \"STATE_EXP_SIGN\",\n            \"STATE_EXP_NUMBER\",\n            \"STATE_END\"\n        ])\n        Chartype = Enum(\"Chartype\", [\n            \"CHAR_NUMBER\",\n            \"CHAR_EXP\",\n            \"CHAR_POINT\",\n            \"CHAR_SIGN\",\n            \"CHAR_ILLEGAL\"\n        ])\n\n        def toChartype(ch: str) -> Chartype:\n            if ch.isdigit():\n                return Chartype.CHAR_NUMBER\n            elif ch.lower() == \"e\":\n                return Chartype.CHAR_EXP\n            elif ch == \".\":\n                return Chartype.CHAR_POINT\n            elif ch == \"+\" or ch == \"-\":\n                return Chartype.CHAR_SIGN\n            else:\n                return Chartype.CHAR_ILLEGAL\n        \n        transfer = {\n            State.STATE_INITIAL: {\n                Chartype.CHAR_NUMBER: State.STATE_INTEGER,\n                Chartype.CHAR_POINT: State.STATE_POINT_WITHOUT_INT,\n                Chartype.CHAR_SIGN: State.STATE_INT_SIGN\n            },\n            State.STATE_INT_SIGN: {\n                Chartype.CHAR_NUMBER: State.STATE_INTEGER,\n                Chartype.CHAR_POINT: State.STATE_POINT_WITHOUT_INT\n            },\n            State.STATE_INTEGER: {\n                Chartype.CHAR_NUMBER: State.STATE_INTEGER,\n                Chartype.CHAR_EXP: State.STATE_EXP,\n                Chartype.CHAR_POINT: State.STATE_POINT\n            },\n            State.STATE_POINT: {\n                Chartype.CHAR_NUMBER: State.STATE_FRACTION,\n                Chartype.CHAR_EXP: State.STATE_EXP\n            },\n            State.STATE_POINT_WITHOUT_INT: {\n                Chartype.CHAR_NUMBER: State.STATE_FRACTION\n            },\n            State.STATE_FRACTION: {\n                Chartype.CHAR_NUMBER: State.STATE_FRACTION,\n                Chartype.CHAR_EXP: State.STATE_EXP\n            },\n            State.STATE_EXP: {\n                Chartype.CHAR_NUMBER: State.STATE_EXP_NUMBER,\n                Chartype.CHAR_SIGN: State.STATE_EXP_SIGN\n            },\n            State.STATE_EXP_SIGN: {\n                Chartype.CHAR_NUMBER: State.STATE_EXP_NUMBER\n            },\n            State.STATE_EXP_NUMBER: {\n                Chartype.CHAR_NUMBER: State.STATE_EXP_NUMBER\n            },\n        }\n\n        st = State.STATE_INITIAL\n        for ch in s:\n            typ = toChartype(ch)\n            if typ not in transfer[st]:\n                return False\n            st = transfer[st][typ]\n        \n        return st in [State.STATE_INTEGER, State.STATE_POINT, State.STATE_FRACTION, State.STATE_EXP_NUMBER, State.STATE_END]\n```\n\n```JavaScript [sol1-JavaScript]\nvar isNumber = function(s) {\n    const State = {\n        STATE_INITIAL : \"STATE_INITIAL\",\n        STATE_INT_SIGN : \"STATE_INT_SIGN\",\n        STATE_INTEGER : \"STATE_INTEGER\",\n        STATE_POINT : \"STATE_POINT\",\n        STATE_POINT_WITHOUT_INT : \"STATE_POINT_WITHOUT_INT\",\n        STATE_FRACTION : \"STATE_FRACTION\",\n        STATE_EXP : \"STATE_EXP\",\n        STATE_EXP_SIGN : \"STATE_EXP_SIGN\",\n        STATE_EXP_NUMBER : \"STATE_EXP_NUMBER\",\n        STATE_END : \"STATE_END\"\n    }\n\n    const CharType = {\n        CHAR_NUMBER : \"CHAR_NUMBER\",\n        CHAR_EXP : \"CHAR_EXP\",\n        CHAR_POINT : \"CHAR_POINT\",\n        CHAR_SIGN : \"CHAR_SIGN\",\n        CHAR_ILLEGAL : \"CHAR_ILLEGAL\"\n    }\n\n    const toCharType = (ch) => {\n        if (!isNaN(ch)) {\n            return CharType.CHAR_NUMBER;\n        } else if (ch.toLowerCase() === 'e') {\n            return CharType.CHAR_EXP;\n        } else if (ch === '.') {\n            return CharType.CHAR_POINT;\n        } else if (ch === '+' || ch === '-') {\n            return CharType.CHAR_SIGN;\n        } else {\n            return CharType.CHAR_ILLEGAL;\n        }\n    }   \n\n    const transfer = new Map();\n    const initialMap = new Map();\n    initialMap.set(CharType.CHAR_NUMBER, State.STATE_INTEGER);\n    initialMap.set(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);\n    initialMap.set(CharType.CHAR_SIGN, State.STATE_INT_SIGN);\n    transfer.set(State.STATE_INITIAL, initialMap);\n    const intSignMap = new Map();\n    intSignMap.set(CharType.CHAR_NUMBER, State.STATE_INTEGER);\n    intSignMap.set(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);\n    transfer.set(State.STATE_INT_SIGN, intSignMap);\n    const integerMap = new Map();\n    integerMap.set(CharType.CHAR_NUMBER, State.STATE_INTEGER);\n    integerMap.set(CharType.CHAR_EXP, State.STATE_EXP);\n    integerMap.set(CharType.CHAR_POINT, State.STATE_POINT);\n    transfer.set(State.STATE_INTEGER, integerMap);\n    const pointMap = new Map() \n    pointMap.set(CharType.CHAR_NUMBER, State.STATE_FRACTION);\n    pointMap.set(CharType.CHAR_EXP, State.STATE_EXP);\n    transfer.set(State.STATE_POINT, pointMap);\n    const pointWithoutIntMap = new Map();\n    pointWithoutIntMap.set(CharType.CHAR_NUMBER, State.STATE_FRACTION);\n    transfer.set(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);\n    const fractionMap = new Map();\n    fractionMap.set(CharType.CHAR_NUMBER, State.STATE_FRACTION);\n    fractionMap.set(CharType.CHAR_EXP, State.STATE_EXP);\n    transfer.set(State.STATE_FRACTION, fractionMap);\n    const expMap = new Map(); \n    expMap.set(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);\n    expMap.set(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);\n    transfer.set(State.STATE_EXP, expMap);\n    const expSignMap = new Map();\n    expSignMap.set(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);\n    transfer.set(State.STATE_EXP_SIGN, expSignMap);\n    const expNumberMap = new Map();\n    expNumberMap.set(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);\n    transfer.set(State.STATE_EXP_NUMBER, expNumberMap);\n\n    const length = s.length;\n    let state = State.STATE_INITIAL;\n\n    for (let i = 0; i < length; i++) {\n        const type = toCharType(s[i]);\n        if (!transfer.get(state).has(type)) {\n            return false;\n        } else {\n            state = transfer.get(state).get(type);\n        }\n    }\n    return state === State.STATE_INTEGER || state === State.STATE_POINT || state === State.STATE_FRACTION || state === State.STATE_EXP_NUMBER || state === State.STATE_END;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为字符串的长度。我们需要遍历字符串的每个字符，其中状态转移所需的时间复杂度为 $O(1)$。\n\n- 空间复杂度：$O(1)$。只需要创建固定大小的状态转移表。"
}