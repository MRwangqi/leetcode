{
	"titleSlug": "count-number-of-pairs-with-absolute-difference-k",
	"slug": "chai-de-jue-dui-zhi-wei-k-de-shu-dui-shu-xspo",
	"url": "https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/solution/chai-de-jue-dui-zhi-wei-k-de-shu-dui-shu-xspo/",
	"content": "#### 方法一：暴力\n\n**思路**\n\n我们可以使用两层循环，一层遍历 $i$，一层遍历 $j$，对每个 $(i，j)$ 的组合，判断差的绝对值是否为 $k$，统计所有符合条件的数对。\n\n**代码**\n\n```Python [sol1-Python3]\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        res, n = 0, len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if abs(nums[i] - nums[j]) == k:\n                    res += 1\n        return res\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int countKDifference(int[] nums, int k) {\n        int res = 0, n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (Math.abs(nums[i] - nums[j]) == k) {\n                    ++res;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int CountKDifference(int[] nums, int k) {\n        int res = 0, n = nums.Length;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (Math.Abs(nums[i] - nums[j]) == k) {\n                    ++res;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int countKDifference(vector<int>& nums, int k) {\n        int res = 0, n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (abs(nums[i] - nums[j]) == k) {\n                    ++res;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n```C [sol1-C]\nint countKDifference(int* nums, int numsSize, int k){\n    int res = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        for (int j = i + 1; j < numsSize; ++j) {\n            if (abs(nums[i] - nums[j]) == k) {\n                ++res;\n            }\n        }\n    }\n    return res;\n}\n```\n\n```go [sol1-Golang]\nfunc countKDifference(nums []int, k int) (ans int) {\n    for j, x := range nums {\n        for _, y := range nums[:j] {\n            if abs(x-y) == k {\n                ans++\n            }\n        }\n    }\n    return\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```\n\n```JavaScript [sol1-JavaScript]\nvar countKDifference = function(nums, k) {\n    let res = 0, n = nums.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            if (Math.abs(nums[i] - nums[j]) == k) {\n                ++res;\n            }\n        }\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度。我们使用了两层循环来寻找所有符合条件的数对。\n\n- 空间复杂度：$O(1)$。我们仅使用常数空间。\n\n#### 方法二：哈希表 + 一次遍历\n\n**思路**\n\n我们进行一次遍历，遍历时下标代表 $j$。对每一个 $j$，我们需要知道在这个 $j$ 之前的符合条件的 $i$ 的个数，即满足 $|\\texttt{nums}[i] - \\texttt{nums}[j]| = k$ 的 $i$ 的个数，亦即满足 $\\texttt{nums}[i] = \\texttt{nums}[j] + k$ 或 $\\texttt{nums}[i] = \\texttt{nums}[j] - k$ 的 $i$ 的个数。使用哈希表可以在 $O(1)$ 的时间内统计出这样的个数，因此在遍历时我们可以使用一个哈希表来维护不同数值的频率，并统计符合条件的数对总数。\n\n**代码**\n\n```Python [sol2-Python3]\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        res = 0\n        cnt = Counter()\n        for num in nums:\n            res += cnt[num - k] + cnt[num + k]\n            cnt[num] += 1\n        return res\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int countKDifference(int[] nums, int k) {\n        int res = 0, n = nums.length;\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        for (int j = 0; j < n; ++j) {\n            res += cnt.getOrDefault(nums[j] - k, 0) + cnt.getOrDefault(nums[j] + k, 0);\n            cnt.put(nums[j], cnt.getOrDefault(nums[j], 0) + 1);\n        }\n        return res;\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int CountKDifference(int[] nums, int k) {\n        int res = 0, n = nums.Length;\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        for (int j = 0; j < n; ++j) {\n            res += (cnt.ContainsKey(nums[j] - k) ? cnt[nums[j] - k] : 0) + (cnt.ContainsKey(nums[j] + k) ? cnt[nums[j] + k] : 0);\n            if (!cnt.ContainsKey(nums[j])) {\n                cnt.Add(nums[j], 0);\n            }\n            ++cnt[nums[j]];\n        }\n        return res;\n    }\n}\n```\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    int countKDifference(vector<int>& nums, int k) {\n        int res = 0, n = nums.size();\n        unordered_map<int, int> cnt;\n        for (int j = 0; j < n; ++j) {\n            res += (cnt.count(nums[j] - k) ? cnt[nums[j] - k] : 0);\n            res += (cnt.count(nums[j] + k) ? cnt[nums[j] + k] : 0);\n            ++cnt[nums[j]];\n        }\n        return res;\n    }\n};\n```\n\n```C [sol2-C]\ntypedef struct  {\n    int key;            \n    int val;\n    UT_hash_handle hh;\n} HashEntry;\n\nint countKDifference(int* nums, int numsSize, int k){\n    int res = 0;\n    HashEntry * cnt = NULL;\n    for (int j = 0; j < numsSize; ++j) {\n        HashEntry * pEntry = NULL;\n        int curr = nums[j] - k;\n        HASH_FIND_INT(cnt, &curr, pEntry);\n        if (NULL != pEntry) {\n            res += pEntry->val;\n        }\n        curr = nums[j] + k;\n        HASH_FIND_INT(cnt, &curr, pEntry);\n        if (NULL != pEntry) {\n            res += pEntry->val;\n        }\n        HASH_FIND_INT(cnt, &nums[j], pEntry);\n        if (NULL == pEntry) {\n            pEntry = (HashEntry *)malloc(sizeof(HashEntry));\n            pEntry->key = nums[j];\n            pEntry->val = 1;\n            HASH_ADD_INT(cnt, key, pEntry);\n        } else {\n            ++pEntry->val;\n        }\n    }\n    HashEntry * curr = NULL, * next = NULL;\n    HASH_ITER(hh, cnt, curr, next) {\n        HASH_DEL(cnt, curr);\n    }\n    return res;\n}\n```\n\n```go [sol2-Golang]\nfunc countKDifference(nums []int, k int) (ans int) {\n    cnt := map[int]int{}\n    for _, num := range nums {\n        ans += cnt[num-k] + cnt[num+k]\n        cnt[num]++\n    }\n    return\n}\n```\n\n```JavaScript [sol2-JavaScript]\nvar countKDifference = function(nums, k) {\n    let res = 0, n = nums.length;\n    const cnt = new Map();\n    for (let j = 0; j < n; ++j) {\n        res += (cnt.get(nums[j] - k) || 0) + (cnt.get(nums[j] + k) || 0);\n        cnt.set(nums[j], (cnt.get(nums[j]) || 0) + 1);\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $\\textit{nums}$ 的长度。我们仅使用了一次遍历来寻找所有符合条件的数对。\n\n- 空间复杂度：$O(n)$。哈希表消耗了 $O(n)$ 的空间。"
}